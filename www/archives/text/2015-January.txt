From pete at petertodd.org  Sat Jan  3 03:48:29 2015
From: pete at petertodd.org (Peter Todd)
Date: Fri, 2 Jan 2015 22:48:29 -0500
Subject: [Bitcoin-development] BIP: Voluntary deposit bonds
In-Reply-To: <54A1A99E.1020604@certimix.com>
References: <54A1A99E.1020604@certimix.com>
Message-ID: <20150103034829.GP6538@savin.petertodd.org>

On Mon, Dec 29, 2014 at 04:21:02PM -0300, Sergio Lerner wrote:
> I propose to allow miners to voluntarily lock funds by letting miners
> add additional inputs to the coinbase transaction. Currently the
> coinbase transaction does not allow any real input  to be added (only a
> pseudo-input).
> This is a hard-fork, and we could include it the next time a hardfork is
> made.
> The modifications to the code are minimal (no more than 12 lines
> modified where IsCoinBase() is called), and they generally involve
> removing code, not adding.
> 
> Why ?
> 
> Because sometime in the future (maybe 5-10 years) we may have to deal
> with problems of securing the blockchain, as the subsidy is lowered. We
> don't want the number of confirmation blocks to be increased in
> compensation because Bitcoin won't be able to compete with other payment
> networks.
> Then by having this hardfork now, we will be able to soft-fork later to
> any rule we may came come up with involving deposit bonds,
> proof-of-stake, and the penalization of double-mining (mining two blocks
> at the same height) to prevent short-range attacks.
> 
> Can it hurt?
> 
> No. I doesn't not change the incentives or the security in any way, as

It definitely does change the incentives as it makes it easy and secure
to pay miners to mine specific blocks rather than specific transactions.
For instance I could securely pay a miner to mine a re-org in a specific
way, something I can't do right now. From the perspective of "the
blockchain must move forward" this is worrying. I have proposed this
idea before myself for my PowPay(1) micropayments scheme, but on
reflection I don't think it's a good idea anymore.

PowPay in general is an idea I'm now rather dubious about: it works much
better with large mining pools, which would further incentivise pools to
get bigger. In general we want mining to be dumber, not smarter, to keep
the overhead of it as small as possible to getting into it is as easy as
possible.

re: hard-fork vs. soft-fork, Gregory Maxwell's comments elsewhere in the
thread are what I'd say myself.

1) [Bitcoin-development] Coinbase TxOut Hashcash,
   Peter Todd, May 10th 2013,
   http://www.mail-archive.com/bitcoin-development at lists.sourceforge.net/msg02159.html

-- 
'peter'[:-1]@petertodd.org
000000000000000008bb7f424d81b7a0ea568086f4d320c2867705f88c27bb0a
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150102/f46b00e9/attachment.sig>

From jrn at jrn.me.uk  Sun Jan  4 14:43:05 2015
From: jrn at jrn.me.uk (Ross Nicoll)
Date: Sun, 04 Jan 2015 14:43:05 +0000
Subject: [Bitcoin-development] Re-enabling simple tx replacement
Message-ID: <54A95179.2070200@jrn.me.uk>

Dear all,

I've been looking at atomic cross-chain trading (
https://en.bitcoin.it/wiki/Atomic_cross-chain_trading ) between the
Bitcoin and Dogecoin blockchains, and have a mostly functional
prototype. However as it stands if the refund transaction is relayed
before the actual spend transaction, it "blocks" the legitimate spend
transaction from being accepted into the memory pool.

I'd like to enable TX replacement in the case where all conflicting
transactions are not final, and the replacement is final. While yes,
this still leaves scope for "unpaid for" bandwidth, hopefully being able
to do a single replacement isn't a major issue.

For those wanting background on this,
https://github.com/bitcoin/bitcoin/pull/2516 may be useful reading.

I've drafted a patch for this
https://github.com/rnicoll/bitcoin/commit/e668d36607f008990ccaac7275e463a6efdd9b5a
but have not yet raised a PR, as historically this has lead to a lot of
discussion in Github which is better suited to this mailing list.

I'm therefore looking for feedback while I continue testing that patch,
and any comments would be welcomed.

Ross



From gmaxwell at gmail.com  Sun Jan  4 17:04:24 2015
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Sun, 4 Jan 2015 17:04:24 +0000
Subject: [Bitcoin-development] Re-enabling simple tx replacement
In-Reply-To: <54A95179.2070200@jrn.me.uk>
References: <54A95179.2070200@jrn.me.uk>
Message-ID: <CAAS2fgSw=Goibe2LkXsEH5xjyftjQq4FxJh-dhaP_N5ea21ugQ@mail.gmail.com>

On Sun, Jan 4, 2015 at 2:43 PM, Ross Nicoll <jrn at jrn.me.uk> wrote:
> Dear all,
>
> I've been looking at atomic cross-chain trading (
> https://en.bitcoin.it/wiki/Atomic_cross-chain_trading ) between the
> Bitcoin and Dogecoin blockchains, and have a mostly functional
> prototype. However as it stands if the refund transaction is relayed
> before the actual spend transaction, it "blocks" the legitimate spend
> transaction from being accepted into the memory pool.

Unless there is a serious bug that I am not aware of this is not the
case. The unlocked transaction is not relayable and will not be
mempooled (well, until right before it locks).

> I've drafted a patch for this
> https://github.com/rnicoll/bitcoin/commit/e668d36607f008990ccaac7275e463a6efdd9b5a
> but have not yet raised a PR, as historically this has lead to a lot of
> discussion in Github which is better suited to this mailing list.
>
> I'm therefore looking for feedback while I continue testing that patch,
> and any comments would be welcomed.

This appears to have absolutely no protection against denial of
service, it seems to me that a single user can rapidly update their
transaction and exhaust the relay bandwidth of the entire network.



From jrn at jrn.me.uk  Sun Jan  4 17:22:11 2015
From: jrn at jrn.me.uk (Ross Nicoll)
Date: Sun, 04 Jan 2015 17:22:11 +0000
Subject: [Bitcoin-development] Re-enabling simple tx replacement
In-Reply-To: <CAAS2fgSw=Goibe2LkXsEH5xjyftjQq4FxJh-dhaP_N5ea21ugQ@mail.gmail.com>
References: <54A95179.2070200@jrn.me.uk>
	<CAAS2fgSw=Goibe2LkXsEH5xjyftjQq4FxJh-dhaP_N5ea21ugQ@mail.gmail.com>
Message-ID: <54A976C3.1030805@jrn.me.uk>

On 04/01/15 17:04, Gregory Maxwell wrote:
> On Sun, Jan 4, 2015 at 2:43 PM, Ross Nicoll <jrn at jrn.me.uk> wrote:
>> Dear all,
>>
>> I've been looking at atomic cross-chain trading (
>> https://en.bitcoin.it/wiki/Atomic_cross-chain_trading ) between the
>> Bitcoin and Dogecoin blockchains, and have a mostly functional
>> prototype. However as it stands if the refund transaction is relayed
>> before the actual spend transaction, it "blocks" the legitimate spend
>> transaction from being accepted into the memory pool.
> 
> Unless there is a serious bug that I am not aware of this is not the
> case. The unlocked transaction is not relayable and will not be
> mempooled (well, until right before it locks).

Grabbing a simple test case:
https://chain.so/tx/BTCTEST/f903a31f2474df737d324c60abf2407e1cf7e052844da4ccffbfab81cf6ac1f8
- that won't lock until 0028 UTC on the 5th.

I've tried closing the wallet, moving the wallet.dat file out of the
way, and then attempting the spend transaction (which can be locked
immediately), and it either rejects it on acceptance to mempool, or it
is never included in a block.

Compare with
https://chain.so/tx/BTCTEST/0b96eb0c9bf8a6ca08bb9d75e44970889db77779c6d3122296c0169959f979cc
where the refund was not sent first, and the transaction has succeeded.

>> I've drafted a patch for this
>> https://github.com/rnicoll/bitcoin/commit/e668d36607f008990ccaac7275e463a6efdd9b5a
>> but have not yet raised a PR, as historically this has lead to a lot of
>> discussion in Github which is better suited to this mailing list.
>>
>> I'm therefore looking for feedback while I continue testing that patch,
>> and any comments would be welcomed.
> 
> This appears to have absolutely no protection against denial of
> service, it seems to me that a single user can rapidly update their
> transaction and exhaust the relay bandwidth of the entire network.
> 

They can only replace a non-final transaction with a final transaction,
so the replacement can happen at most once (any later replacement would
be attempting to replace a final transaction, and therefore fails). So,
while they can expend twice the bandwidth compared to a non-replacement,
I don't think that's a major issue?




From gmaxwell at gmail.com  Sun Jan  4 17:35:37 2015
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Sun, 4 Jan 2015 17:35:37 +0000
Subject: [Bitcoin-development] Re-enabling simple tx replacement
In-Reply-To: <54A976C3.1030805@jrn.me.uk>
References: <54A95179.2070200@jrn.me.uk>
	<CAAS2fgSw=Goibe2LkXsEH5xjyftjQq4FxJh-dhaP_N5ea21ugQ@mail.gmail.com>
	<54A976C3.1030805@jrn.me.uk>
Message-ID: <CAAS2fgTxwD2GJ-n+d=ovEYWCxpwyPO_DMBguP_ioc+_cdEhW=w@mail.gmail.com>

On Sun, Jan 4, 2015 at 5:22 PM, Ross Nicoll <jrn at jrn.me.uk> wrote:
> Grabbing a simple test case:
> https://chain.so/tx/BTCTEST/f903a31f2474df737d324c60abf2407e1cf7e052844da4ccffbfab81cf6ac1f8
> - that won't lock until 0028 UTC on the 5th.
>
> I've tried closing the wallet, moving the wallet.dat file out of the
> way, and then attempting the spend transaction (which can be locked
> immediately), and it either rejects it on acceptance to mempool, or it
> is never included in a block.

Can you send me the actual raw transaction (that site doesn't appear
have a way to get it, only some cooked json output; which doesn't
include the sequence number).

As I said, it's a severe bug if unlocked transactions are being
relayed or mempooled far in advance.

> They can only replace a non-final transaction with a final transaction,

Ah I missed that the replacement had to be final. Thats indeed a much
more sane thing to do than I was thinking (sorry for some reason I saw
the +1 and thought it was just checking the sequence number was
higher.)

> I don't think that's a major issue?

If they can relay the first one to begin with its an an issue, the
replacement just makes it twice an issue. :)



From gmaxwell at gmail.com  Sun Jan  4 17:44:59 2015
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Sun, 4 Jan 2015 17:44:59 +0000
Subject: [Bitcoin-development] Re-enabling simple tx replacement
In-Reply-To: <CAAS2fgTxwD2GJ-n+d=ovEYWCxpwyPO_DMBguP_ioc+_cdEhW=w@mail.gmail.com>
References: <54A95179.2070200@jrn.me.uk>
	<CAAS2fgSw=Goibe2LkXsEH5xjyftjQq4FxJh-dhaP_N5ea21ugQ@mail.gmail.com>
	<54A976C3.1030805@jrn.me.uk>
	<CAAS2fgTxwD2GJ-n+d=ovEYWCxpwyPO_DMBguP_ioc+_cdEhW=w@mail.gmail.com>
Message-ID: <CAAS2fgROnDRbzNubLa588mXRJR4jwEBotvQi5bFm5dnNQxiwTA@mail.gmail.com>

On Sun, Jan 4, 2015 at 5:35 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:
> Can you send me the actual raw transaction (that site doesn't appear
> have a way to get it, only some cooked json output; which doesn't
> include the sequence number).

Nevermind, I guess. I think I figured out your problem: The behaviour
on testnet is busted because the non-mempooling is enforced by
IsStandardTx which is bypassed in testnet. We should enforce that
elsewhere.

This isn't the case on the real network.



From jrn at jrn.me.uk  Sun Jan  4 17:45:01 2015
From: jrn at jrn.me.uk (Ross Nicoll)
Date: Sun, 04 Jan 2015 17:45:01 +0000
Subject: [Bitcoin-development] Re-enabling simple tx replacement
In-Reply-To: <CAAS2fgTxwD2GJ-n+d=ovEYWCxpwyPO_DMBguP_ioc+_cdEhW=w@mail.gmail.com>
References: <54A95179.2070200@jrn.me.uk>	<CAAS2fgSw=Goibe2LkXsEH5xjyftjQq4FxJh-dhaP_N5ea21ugQ@mail.gmail.com>	<54A976C3.1030805@jrn.me.uk>
	<CAAS2fgTxwD2GJ-n+d=ovEYWCxpwyPO_DMBguP_ioc+_cdEhW=w@mail.gmail.com>
Message-ID: <54A97C1D.1080604@jrn.me.uk>

On 04/01/15 17:35, Gregory Maxwell wrote:
> On Sun, Jan 4, 2015 at 5:22 PM, Ross Nicoll <jrn at jrn.me.uk> wrote:
>> Grabbing a simple test case:
>> https://chain.so/tx/BTCTEST/f903a31f2474df737d324c60abf2407e1cf7e052844da4ccffbfab81cf6ac1f8
>> - that won't lock until 0028 UTC on the 5th.
>>
>> I've tried closing the wallet, moving the wallet.dat file out of the
>> way, and then attempting the spend transaction (which can be locked
>> immediately), and it either rejects it on acceptance to mempool, or it
>> is never included in a block.
> 
> Can you send me the actual raw transaction (that site doesn't appear
> have a way to get it, only some cooked json output; which doesn't
> include the sequence number).
> 
> As I said, it's a severe bug if unlocked transactions are being
> relayed or mempooled far in advance.

Attached. Sequence number for the input is set to 1, please do tell me
if I've misunderstood how it's used.

>> They can only replace a non-final transaction with a final transaction,
> 
> Ah I missed that the replacement had to be final. Thats indeed a much
> more sane thing to do than I was thinking (sorry for some reason I saw
> the +1 and thought it was just checking the sequence number was
> higher.)
> 
>> I don't think that's a major issue?
> 
> If they can relay the first one to begin with its an an issue, the
> replacement just makes it twice an issue. :)
> 

I'll set up a few nodes tomorrow and double check it's in fact relaying
in the latest version. If it's simply an issue of incorrect relaying,
that's significantly simpler at least, and the problem can be tackled
through that instead.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: f903a31f2474df737d324c60abf2407e1cf7e052844da4ccffbfab81cf6ac1f8.hex
Type: text/x-hex
Size: 606 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150104/4c954510/attachment.bin>

From pete at petertodd.org  Sun Jan  4 17:47:36 2015
From: pete at petertodd.org (Peter Todd)
Date: Sun, 4 Jan 2015 12:47:36 -0500
Subject: [Bitcoin-development] Re-enabling simple tx replacement
In-Reply-To: <CAAS2fgROnDRbzNubLa588mXRJR4jwEBotvQi5bFm5dnNQxiwTA@mail.gmail.com>
References: <54A95179.2070200@jrn.me.uk>
	<CAAS2fgSw=Goibe2LkXsEH5xjyftjQq4FxJh-dhaP_N5ea21ugQ@mail.gmail.com>
	<54A976C3.1030805@jrn.me.uk>
	<CAAS2fgTxwD2GJ-n+d=ovEYWCxpwyPO_DMBguP_ioc+_cdEhW=w@mail.gmail.com>
	<CAAS2fgROnDRbzNubLa588mXRJR4jwEBotvQi5bFm5dnNQxiwTA@mail.gmail.com>
Message-ID: <20150104174736.GA17628@savin.petertodd.org>

On Sun, Jan 04, 2015 at 05:44:59PM +0000, Gregory Maxwell wrote:
> On Sun, Jan 4, 2015 at 5:35 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:
> > Can you send me the actual raw transaction (that site doesn't appear
> > have a way to get it, only some cooked json output; which doesn't
> > include the sequence number).
> 
> Nevermind, I guess. I think I figured out your problem: The behaviour
> on testnet is busted because the non-mempooling is enforced by
> IsStandardTx which is bypassed in testnet. We should enforce that
> elsewhere.
> 
> This isn't the case on the real network.

Yup.

I have a pull-req open to fix this:

https://github.com/bitcoin/bitcoin/pull/5521

-- 
'peter'[:-1]@petertodd.org
00000000000000000237ec84e4b02efbdf3bcbf62308c873da802caedd12432f
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150104/f83dab5f/attachment.sig>

From jrn at jrn.me.uk  Sun Jan  4 18:11:52 2015
From: jrn at jrn.me.uk (Ross Nicoll)
Date: Sun, 04 Jan 2015 18:11:52 +0000
Subject: [Bitcoin-development] Re-enabling simple tx replacement
In-Reply-To: <CAAS2fgROnDRbzNubLa588mXRJR4jwEBotvQi5bFm5dnNQxiwTA@mail.gmail.com>
References: <54A95179.2070200@jrn.me.uk>	<CAAS2fgSw=Goibe2LkXsEH5xjyftjQq4FxJh-dhaP_N5ea21ugQ@mail.gmail.com>	<54A976C3.1030805@jrn.me.uk>	<CAAS2fgTxwD2GJ-n+d=ovEYWCxpwyPO_DMBguP_ioc+_cdEhW=w@mail.gmail.com>
	<CAAS2fgROnDRbzNubLa588mXRJR4jwEBotvQi5bFm5dnNQxiwTA@mail.gmail.com>
Message-ID: <54A98268.8030309@jrn.me.uk>

On 04/01/15 17:44, Gregory Maxwell wrote:
> On Sun, Jan 4, 2015 at 5:35 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:
>> Can you send me the actual raw transaction (that site doesn't appear
>> have a way to get it, only some cooked json output; which doesn't
>> include the sequence number).
> 
> Nevermind, I guess. I think I figured out your problem: The behaviour
> on testnet is busted because the non-mempooling is enforced by
> IsStandardTx which is bypassed in testnet. We should enforce that
> elsewhere.
> 
> This isn't the case on the real network.
> 

Ah, thanks for that.

I'll try Peter's patch for testnet tomorrow, sounds like it should fix
this for my use case.




From gmaxwell at gmail.com  Sun Jan  4 18:31:12 2015
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Sun, 4 Jan 2015 18:31:12 +0000
Subject: [Bitcoin-development] Re-enabling simple tx replacement
In-Reply-To: <54A98268.8030309@jrn.me.uk>
References: <54A95179.2070200@jrn.me.uk>
	<CAAS2fgSw=Goibe2LkXsEH5xjyftjQq4FxJh-dhaP_N5ea21ugQ@mail.gmail.com>
	<54A976C3.1030805@jrn.me.uk>
	<CAAS2fgTxwD2GJ-n+d=ovEYWCxpwyPO_DMBguP_ioc+_cdEhW=w@mail.gmail.com>
	<CAAS2fgROnDRbzNubLa588mXRJR4jwEBotvQi5bFm5dnNQxiwTA@mail.gmail.com>
	<54A98268.8030309@jrn.me.uk>
Message-ID: <CAAS2fgT9Poj=OD9EyqpiPgTc_jB+EyLV+3ye5i65zHxF456zjw@mail.gmail.com>

On Sun, Jan 4, 2015 at 6:11 PM, Ross Nicoll <jrn at jrn.me.uk> wrote:
> Ah, thanks for that.
>
> I'll try Peter's patch for testnet tomorrow, sounds like it should fix
> this for my use case.

Thanks for presenting your solution as code in any case. In spite of
the fact that I gave it a crappy read this time, it really is a useful
way to communicate and I wish more people did that.



From jtimon at jtimon.cc  Sun Jan  4 23:06:13 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Mon, 5 Jan 2015 00:06:13 +0100
Subject: [Bitcoin-development] Re-enabling simple tx replacement
In-Reply-To: <CAAS2fgT9Poj=OD9EyqpiPgTc_jB+EyLV+3ye5i65zHxF456zjw@mail.gmail.com>
References: <54A95179.2070200@jrn.me.uk>
	<CAAS2fgSw=Goibe2LkXsEH5xjyftjQq4FxJh-dhaP_N5ea21ugQ@mail.gmail.com>
	<54A976C3.1030805@jrn.me.uk>
	<CAAS2fgTxwD2GJ-n+d=ovEYWCxpwyPO_DMBguP_ioc+_cdEhW=w@mail.gmail.com>
	<CAAS2fgROnDRbzNubLa588mXRJR4jwEBotvQi5bFm5dnNQxiwTA@mail.gmail.com>
	<54A98268.8030309@jrn.me.uk>
	<CAAS2fgT9Poj=OD9EyqpiPgTc_jB+EyLV+3ye5i65zHxF456zjw@mail.gmail.com>
Message-ID: <CABm2gDp2LE147d146aFWFfxcdY4uw5yDyVYjWm1aLBbkqOApzg@mail.gmail.com>

On Sun, Jan 4, 2015 at 7:31 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:
> Thanks for presenting your solution as code in any case. It really is a useful
> way to communicate and I wish more people did that.

+1



From joliver at airmail.cc  Tue Jan  6 11:03:47 2015
From: joliver at airmail.cc (joliver at airmail.cc)
Date: Tue, 06 Jan 2015 11:03:47 +0000
Subject: [Bitcoin-development] The relationship between
 Proof-of-Publication and Anti-Replay Oracles
In-Reply-To: <20141222001136.GA10165@savin.petertodd.org>
References: <20141212090551.GA8259@muck>
	<20141220144800.GA26284@savin.petertodd.org>
	<20141222001136.GA10165@savin.petertodd.org>
Message-ID: <57e9838d0b92bd3226b10c6cf2651914@airmail.cc>

On 2014-12-22 00:11, Peter Todd wrote:
> On Sat, Dec 20, 2014 at 09:48:01AM -0500, Peter Todd wrote:
> The classic "proof-of-publication" system is to embed opaque data (as
> far as bitcoin miners are concerned) in transactions using OP_RETURN.
> A significance of establishing "proof-of-publication" as a universal
> underlying primitive is that this OP_RETURN trick is then sufficient
> for anything you might want. But part of what Bitcoin provides is
> indexing and validation/exclusion, and this is important for
> supporting efficient anti-replay proofs. Proof-of-(non)-publication
> alone isn't sufficient for this.

Are we going to get an answer to this or Adam Back's critique? Doesn't 
sound like this so-called "proof-of-publication" actually works 
according to the experts. Is it an concept anyone but Peter Todd 
actually believes in?



From 21xe14 at gmail.com  Thu Jan  8 18:36:29 2015
From: 21xe14 at gmail.com (21E14)
Date: Thu, 8 Jan 2015 18:36:29 +0000
Subject: [Bitcoin-development] A look back and a look forward
Message-ID: <CAFZQHkFP81iYsAadejL1Si60FgtQSLvN==67ft2YRtsL9MqyDg@mail.gmail.com>

Alex Daley recently stated that "one of the problems with Bitcoin is that
it takes us backwards in the transaction chain. Suddenly, you're dealing
with something that's much more cash-like. If Target had been hacked, and
instead of using credit-cards, what was stolen from them were actually
bitcoins, that they have been storing Bitcoin addresses in their systems
and those systems were compromised, Target wouldn't just have a PR
nightmare in their hands. They would be out of business."

Of course, it needn't be Target. The scenario has played out with a number
of exchanges, and is a sword of Damocles hanging over the cryptocurrency
space. The recent Winklevoss Bitcoin Trust SEC filing warns that "the
Trust?s bitcoins may be subject to loss, damage, theft or restriction on
access. There is a risk that part or all of the Trust?s bitcoins could be
lost, stolen or destroyed. The Sponsor believes that the Trust?s bitcoins
held in the Trust Custody Account will be an appealing target to hackers or
malware distributors seeking to destroy, damage or steal the Trust?s
bitcoins. Although the Security System?s design includes various elements,
such as redundancy, segregation and cold storage, to minimize the risk of
loss, damage and theft, neither the Custodian nor the Sponsor can guarantee
that the Security System will prevent such loss, damage or theft..."

This needn't be so, once an optional identity layer, modeled after the
Internet itself, is provided, as proposed in late August of last year on
this mailing list:

http://sourceforge.net/p/bitcoin/mailman/message/32737796/
http://sourceforge.net/p/bitcoin/mailman/message/32742809/

I hope it is apparent that this is the killer app folks have been searching
for in vain. Like its Internet analogues, BCIs will not be created
overnight and without collaboration - and TNABC is as good a place as any
for it.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150108/964d2eef/attachment.html>

From nathan.cook at gmail.com  Fri Jan  9 11:40:53 2015
From: nathan.cook at gmail.com (Nathan Cook)
Date: Fri, 9 Jan 2015 13:40:53 +0200
Subject: [Bitcoin-development] Bi-directional micropayment channels with
	CHECKLOCKTIMEVERIFY
Message-ID: <CAGNXQMSSCtgiyFEGHS2ufuc-RZcAtpEJyFpQMDmNKd1qEDq5qA@mail.gmail.com>

A limitation on most existing micropayment channel ideas is that payments
can only flow in one direction. This is because the payment receiver can
sign -any- transaction you send them, not just the most recent one, and so
it's possible to just sign the transaction transferring the largest amount
into their control. This is easily remedied by opening a second payment
channel in the opposite direction, but now both parties have to deposit
funds over the lifetime of the two channels. If one party doesn't know
ahead of time whether or not the other party will go into credit, having
only one channel may save the use of a deposit.

I propose a way of using CHECKLOCKTIMEVERIFY to allow a reversible payment
channel, introducing at most one additional broadcast transaction, with a
waiting period before the payment receiver can access deposited funds. The
extra transaction and waiting period apply only when the depositor doesn't
co-operate with the receiver.

In this protocol, the setup is identical, with a deposit made to a P2SH
address matching a script allowing either single-party+CHECKLOCKTIME or
2-of-2. In this case, however, payments made by the depositor occur in the
form of unbroadcast transactions to special -holding addresses-.

These holding addresses are themselves P2SH addresses, with scripts known
to both parties. Each script may be redeemed in one of two ways:
by the payment receiver, using their signature with a CHECKLOCKTIME
restriction that expires some period of time after the restriction on the
depositor's refund transaction, or
by the depositor, using their own signature, together with a hashlock.

In the second case, we actually use a double hashlock, i.e. the depositor
must provide a value which when SHA256-hashed twice produces the value in
the script.

The receiver generates these values according to the following algorithm:
Beginning with a secret S_0, they double hash S_0 to make the hashlock
value for the first payment, D_0 =H(H(S_0)). Then to make S_i+1 given S_i,
they create a public nonce, N_i, and let S_i+1 = H(N_i | H(S_i)), where a|b
denotes the string a followed by the string b. The hashlock values D_i are
not secret, and can be disclosed in advance or as part of the process of
receiving the associated payment.

When the receiver wants to refund some amount to the depositor, the
receiver finds the last payment which left the depositor with a balance
-greater- than the desired balance, and negotiates a rewind of the payment
sequence to that point, with an additional payment of the remainder by the
depositor. Suppose the last payment that will remain valid was the i-th
payment, counting from zero. The receiver creates a new nonce, N'_i,
creates the associated new secret value S'_i+1 by S'_i+1 = H(N'_i |
H(S_i)), and sends D'_i+1 to the depositor with a request for payment of
the right amount. This amount will be greater than that associated to D_i,
but less than that associated to D_i+1, so the depositor does not need to
trust the receiver in order to honour the request. The payment chain is now
forked at D_i, with a branch D_i+1, D_i+2... and a branch that only has
D'_i+1. The receiver now unwinds the old branch, back to D_i, by revealing
S_i+1 to the depositor. The depositor can now generate - and check - the
secrets S_i+1, S_i+2..., and so knows that if the receiver attempts to sign
and broadcast a transaction to an address using one of those secrets, the
depositor can take back all their funds before the receiver is able to put
their own (CHECKLOCKTIME restricted) transaction from that address on the
blockchain. Now the best usable payment to the receiver is the one
associated to D'_i+1.

When the two parties want to close the payment channel, one party signs a
transaction from the deposit address to whatever addresses are desired, and
sends the transaction to the other party to add their own signature and
publish. This avoids either party having to wait for CHECKLOCKTIME
restrictions to expire. If either party abandons the protocol at this
point, the other can use the CHECKLOCKTIME restrictions to ensure they get
at least as much as they would if both cooperated. Note that the holding
addresses are only used on the blockchain when the protocol is abandoned.

This protocol does not deal with the case of malicious attacks on a party's
network connection, which could keep them offline until CHECKLOCKTIME has
expired. This is something that each party should consider when choosing
how long the restrictions should be in place for. The protocol improves on
blueadept's use of a new nLockTime for each reverse payment[1], by keeping
the wait time independent of the number of payments, and not requiring
either party to predict ahead of time how many payments will occur.

A note on generating hashlock secrets: the protocol works perfectly well
without generating them deterministically. Using an HMAC-style derivation
is more of a convenience than anything else - it saves storing and
transmitting all the secrets when a chain needs to be invalidated - but it
does encode the fact that the addresses form a chain into the addresses'
scripts, which is a nice property to have.

[1] https://bitcointalk.org/index.php?topic=814770.msg9185225#msg9185225

I first posted this at https://bitcointalk.org/index.php?topic=918018.0 and
have edited it slightly for posting on this list. Thanks to Peter Todd for
the suggestion to submit it here for review.

Nathan Cook
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150109/dc18ce68/attachment.html>

From mike at plan99.net  Fri Jan  9 13:20:07 2015
From: mike at plan99.net (Mike Hearn)
Date: Fri, 9 Jan 2015 14:20:07 +0100
Subject: [Bitcoin-development] Bi-directional micropayment channels with
	CHECKLOCKTIMEVERIFY
In-Reply-To: <CAGNXQMSSCtgiyFEGHS2ufuc-RZcAtpEJyFpQMDmNKd1qEDq5qA@mail.gmail.com>
References: <CAGNXQMSSCtgiyFEGHS2ufuc-RZcAtpEJyFpQMDmNKd1qEDq5qA@mail.gmail.com>
Message-ID: <CANEZrP0ZabL2S=UhB2u7en2AfrckPk5CQe0YN-i4eDXQK-LF6A@mail.gmail.com>

>
> A limitation on most existing micropayment channel ideas is that payments
> can only flow in one direction.
>

It's worth noting that the original protocol as designed by Satoshi did not
have this limitation. It has evolved this way because of ad-hoc DoS fixes
over time (btw I'm not saying they were the wrong thing to do, as non "ad
hoc" solutions are significantly more work). But it seems like eventually a
different approach to handling DoS attacks based on resource prioritisation
and scheduling will become needed / implemented, and at that point the
original design could be safely brought back to life.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150109/dee4f22b/attachment.html>

From jgarzik at bitpay.com  Fri Jan  9 13:22:00 2015
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Fri, 9 Jan 2015 08:22:00 -0500
Subject: [Bitcoin-development] Bi-directional micropayment channels with
	CHECKLOCKTIMEVERIFY
In-Reply-To: <CANEZrP0ZabL2S=UhB2u7en2AfrckPk5CQe0YN-i4eDXQK-LF6A@mail.gmail.com>
References: <CAGNXQMSSCtgiyFEGHS2ufuc-RZcAtpEJyFpQMDmNKd1qEDq5qA@mail.gmail.com>
	<CANEZrP0ZabL2S=UhB2u7en2AfrckPk5CQe0YN-i4eDXQK-LF6A@mail.gmail.com>
Message-ID: <CAJHLa0NoDU+DOPfubhbVs8_Y92+uGG=mZ2+ruRCXkeULghWVVg@mail.gmail.com>

Mike, Can you be more specific?  You reference "original design" without
saying how it was different/better.



On Fri, Jan 9, 2015 at 8:20 AM, Mike Hearn <mike at plan99.net> wrote:

> A limitation on most existing micropayment channel ideas is that payments
>> can only flow in one direction.
>>
>
> It's worth noting that the original protocol as designed by Satoshi did
> not have this limitation. It has evolved this way because of ad-hoc DoS
> fixes over time (btw I'm not saying they were the wrong thing to do, as non
> "ad hoc" solutions are significantly more work). But it seems like
> eventually a different approach to handling DoS attacks based on resource
> prioritisation and scheduling will become needed / implemented, and at that
> point the original design could be safely brought back to life.
>
>
>
> ------------------------------------------------------------------------------
> Dive into the World of Parallel Programming! The Go Parallel Website,
> sponsored by Intel and developed in partnership with Slashdot Media, is
> your
> hub for all things parallel software development, from weekly thought
> leadership blogs to news, videos, case studies, tutorials and more. Take a
> look and join the conversation now. http://goparallel.sourceforge.net
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>


-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150109/d9790647/attachment.html>

From gmaxwell at gmail.com  Fri Jan  9 13:26:14 2015
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Fri, 9 Jan 2015 13:26:14 +0000
Subject: [Bitcoin-development] Bi-directional micropayment channels with
	CHECKLOCKTIMEVERIFY
In-Reply-To: <CANEZrP0ZabL2S=UhB2u7en2AfrckPk5CQe0YN-i4eDXQK-LF6A@mail.gmail.com>
References: <CAGNXQMSSCtgiyFEGHS2ufuc-RZcAtpEJyFpQMDmNKd1qEDq5qA@mail.gmail.com>
	<CANEZrP0ZabL2S=UhB2u7en2AfrckPk5CQe0YN-i4eDXQK-LF6A@mail.gmail.com>
Message-ID: <CAAS2fgTvLCs-qXONhEVdOyWJLhQzuu-s3Rff5Y3bCiAj9Rjg-w@mail.gmail.com>

On Fri, Jan 9, 2015 at 1:20 PM, Mike Hearn <mike at plan99.net> wrote:
>> A limitation on most existing micropayment channel ideas is that payments
>> can only flow in one direction.
> It's worth noting that the original protocol as designed by Satoshi did not
> have this limitation. It has evolved this way because of ad-hoc DoS fixes
> over time (btw I'm not saying they were the wrong thing to do, as non "ad
> hoc" solutions are significantly more work). But it seems like eventually a
> different approach to handling DoS attacks based on resource prioritisation
> and scheduling will become needed / implemented, and at that point the
> original design could be safely brought back to life.

I don't agree with your understanding.  Expecting replacement to work
and be enforced is completely unsafe. People (sanely) refuse to use
protocols which are broken by refund malleability, which is a much
narrower expectation for miners than expecting the sequence ratchet to
go one way.



From mike at plan99.net  Fri Jan  9 13:42:52 2015
From: mike at plan99.net (Mike Hearn)
Date: Fri, 9 Jan 2015 14:42:52 +0100
Subject: [Bitcoin-development] Bi-directional micropayment channels with
	CHECKLOCKTIMEVERIFY
In-Reply-To: <CAJHLa0NoDU+DOPfubhbVs8_Y92+uGG=mZ2+ruRCXkeULghWVVg@mail.gmail.com>
References: <CAGNXQMSSCtgiyFEGHS2ufuc-RZcAtpEJyFpQMDmNKd1qEDq5qA@mail.gmail.com>
	<CANEZrP0ZabL2S=UhB2u7en2AfrckPk5CQe0YN-i4eDXQK-LF6A@mail.gmail.com>
	<CAJHLa0NoDU+DOPfubhbVs8_Y92+uGG=mZ2+ruRCXkeULghWVVg@mail.gmail.com>
Message-ID: <CANEZrP1H-_4XiG+Azm7M4FgLrayuML+kdQ7LineXsU3FUH6=Qw@mail.gmail.com>

The original design is documented at the bottom of here:

https://en.bitcoin.it/wiki/Contracts#Example_7:_Rapidly-adjusted_.28micro.29payments_to_a_pre-determined_party

In this design, time locked transactions can be broadcast across the
network and replaced by broadcasting a new transaction that uses higher
sequence numbers. That's what the sequence number field is for. It was
intended to allow arbitrary high frequency trading between a set of
parties, though the "channel" notion is a simple way to think about the two
party case.

The issue is that you can broadcast transactions with a lock time far in
the future to fill up memory, and keep broadcasting replacements to use up
CPU time and bandwidth.

Additionally, there is a school of thought that says Bitcoin must work even
if lots of miners are malicious and willing to break arbitrary things in
order to try and get more money. I don't think Bitcoin can really be a
mainstream success under such a threat model, for a whole bunch of reasons
(e.g. the economy relies pretty heavily on unconfirmed transactions), but
under such a threat model there's nothing that forces miners to actually
include the latest version in the block chain. They could pick any version.
In the 2-of-2 channel model it takes both parties to sign, so clients can
enforce that all versions have the same fee attached.

I disagree with Gregory that people refuse to use protocols that are
affected by malleability. There aren't any user-friendly apps that use
refunds currently, so we have no idea whether people would refuse to use
them or not. It's an open question. The answer would probably depend on the
real prevalence of attacks, which is currently unknowable and likely
application specific.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150109/0e36b48d/attachment.html>

From mike at plan99.net  Fri Jan  9 14:00:59 2015
From: mike at plan99.net (Mike Hearn)
Date: Fri, 9 Jan 2015 15:00:59 +0100
Subject: [Bitcoin-development] A look back and a look forward
In-Reply-To: <CAFZQHkFP81iYsAadejL1Si60FgtQSLvN==67ft2YRtsL9MqyDg@mail.gmail.com>
References: <CAFZQHkFP81iYsAadejL1Si60FgtQSLvN==67ft2YRtsL9MqyDg@mail.gmail.com>
Message-ID: <CANEZrP3VXnX7B7wQ4LOUCs+aifx747svyo5Gysw1SG0bgcT+WA@mail.gmail.com>

>
> This needn't be so, once an optional identity layer, modeled after the
> Internet itself, is provided, as proposed in late August of last year on
> this mailing list
>

I think the observation about Target vs Bitcoin exchanges is a sharp one,
but I'm not sure how your proposal helps. You say it's an optional identity
layer, but obviously any thief is going to opt out of being identified.

For things like the Bitstamp hack, it's not clear how identity can help,
because they were already doing KYC for all their customers. To take that
further at the protocol level would require* all* transactions to have
attached identity info, and that isn't going to happen - it wouldn't be
Bitcoin, at that point.

I think that long term, it's probably possible to defend private keys
adequately, even for large sums of money (maybe not bitstamp-large but
we'll see). You can have very minimalist secure hardware that would have
some additional policies on top, like refusing to sign transactions without
an identity proof of who controls the target address. Very tight hot
wallets that risk analyse the instructions they're receiving have been
proposed years ago.

No such hardware presently exists, but that's mostly because
implementations always lag behind a long way behind ideas rather than any
fundamental technical bottleneck. Perhaps the Bitstamp event will finally
spur development of such things forward.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150109/bf8adcd6/attachment.html>

From gmaxwell at gmail.com  Fri Jan  9 14:50:09 2015
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Fri, 9 Jan 2015 14:50:09 +0000
Subject: [Bitcoin-development] Bi-directional micropayment channels with
	CHECKLOCKTIMEVERIFY
In-Reply-To: <CANEZrP1H-_4XiG+Azm7M4FgLrayuML+kdQ7LineXsU3FUH6=Qw@mail.gmail.com>
References: <CAGNXQMSSCtgiyFEGHS2ufuc-RZcAtpEJyFpQMDmNKd1qEDq5qA@mail.gmail.com>
	<CANEZrP0ZabL2S=UhB2u7en2AfrckPk5CQe0YN-i4eDXQK-LF6A@mail.gmail.com>
	<CAJHLa0NoDU+DOPfubhbVs8_Y92+uGG=mZ2+ruRCXkeULghWVVg@mail.gmail.com>
	<CANEZrP1H-_4XiG+Azm7M4FgLrayuML+kdQ7LineXsU3FUH6=Qw@mail.gmail.com>
Message-ID: <CAAS2fgTMKwo2LOAmW+WzFnHcE7UXvCKgi7WCQLMtGDn2eaxLDA@mail.gmail.com>

On Fri, Jan 9, 2015 at 1:42 PM, Mike Hearn <mike at plan99.net> wrote:
> Additionally, there is a school of thought that says Bitcoin must work even
> if lots of miners are malicious and willing to break arbitrary things in
> order to try and get more money. I don't think Bitcoin can really be a

This being unsafe doesn't require "a lot" though, if 1% of the
hashpower is naughty, an attacker will have a 1% success rate. Naughty
can also just mean broken in various ways, like mining while somewhat
partitioned (didn't hear the update) potentially due to a DOS attack,
or because of some garbage collection policy made it forget the
transaction to conserve resources.  An unkind user can simply run
software that automatically attempts (by sending naughty miners an
earlier conflict right before the locktime expires).  "Use Blue
Rewards wallet for 2% cash back for all the Bitcoin purchases you make
online!" :P

Of course, all the miners who don't play along will very much see how
much income they're missing.

> so clients can enforce that all versions have the same fee attached

Sadly, they cannot.  This is why I specifically mentioned child pays for parent.

In any case,  sometimes a 1% fault rate is acceptable. But generally
for cases that they are, even weaker constructs (e.g. no payment
channel at all, just accept an IOU) are also often acceptable, and
cannot be modulated in their success by resource starvation attacks on
the network.

We have objective proof of substantial miners behaving maliciously,
that much isn't a speculative concern.

The school of thought view is a bit too black and white. My
perspective is that absolute soundness is best (rules which cannot be
broken at all), followed by cryptographic soundness (rules that
breaking requires P=NP, theft of a secret, or insane luck), followed
by economic soundness (rules that cannot be profitably broken),
followed by honesty soundness (rules that hold when the participants
follow the rules and aren't faulty).  We should try to move up that
stack as far towards absolutely soundness as possible; and be
increasingly cautious about compromises as we move down it espeically
because the last two are unstable and difficult to reason about
because they strongly import the vulgarities of humanity into the
security model.   If we could make the whole system absolutely sound
or cryptographically sound, I would think we should (and would) even
if it implied other compromises. But we can't and so users of Bitcoin
must navigate this risk stack.

One thing that I think you miss in this argument is that one man's
integrity is another man's malice.  The history of security and
privacy is filled with instances where someone's trust was violated
because there someone was, rightly or wrongly, convinced that Some
Reason was Good Enough to justify it. Because of this a risk analysis
has to import the clarity of judgement, morality, coerceability,
personal values, etc. of everyone in the trust chain; and many of
these things are unknowable; this greatly increases the costs of
transacting, and the efforts to mitigate those costs (and the failures
to remove the harms) result in an unequitable enviroment where some
people get unjust rewards and unequal access to justice. The gain from
cryptographic tools is being able to make some level of stronger
assurances which cut out most of that trust, they're predictable,
'cheap' on a marginal basis, and fair in a fundamental sense (in
theory everyone has equal access to math).  So, while I could even buy
the argument that miners will never believe themselves to be "actually
malicious", history shows that people's ability to convince themselves
of the justification of something is basically unbounded, even
outright thieves often believe they're owed their spoils-- and there
are a lot of ways to misbehave in Bitcoin that stop short of theft.
And so, where we cannot have cryptographic security enforce the rules,
we-- those who use and depend on Bitcoin-- _generally_ ought to behave
in ways that cannot be harmed by a failure to follow the rules so that
we don't _invite_ failures to follow the rules and thereby create an
institution of it.

Of course, all things equal I don't want to choose for other people
what tools they can use and what risks they take. But in the case of
relaying locked transactions this isn't an otherwise neutral choice: A
straight forward "relay and store any locked spend" policy has
unbounded space and communications complexity.  It's not clear to me
that if any real degree of "you can take your risks, it'll probably
work, but maybe not" can be supported without a very large resource
cost to the network, and without creating incentives to DOS attack the
network (e.g. to make it forget previous spends).  It may be that
there is some set of constraints that actually do make it workable and
don't create the incentives though... meaning that it may _merely_ be
unsafe for people who choose to use it. If so, then it might be
reasonable but we also cannot ignore the incentives it creates in a
wider ecosystem and what their ultimate conclusion might be. E.g. If
you put a bounty for miners to behave 'wrong' in a way the system
cannot prevent, some will. Is the next step to try to say that only
"good" miners can mine?   If so, how many more steps until every
transaction is being tested against a set of system external goodness
criteria?  In that state, is Bitcoin any better than a very
computationally and bandwidth inefficient version of Paypal?

Slipper slope arguments can be a bit slippery. I don't have any clear
answers. I do know that ignoring the risks we know about isn't a good
path.



From 21xe14 at gmail.com  Fri Jan  9 19:36:18 2015
From: 21xe14 at gmail.com (21E14)
Date: Fri, 9 Jan 2015 19:36:18 +0000
Subject: [Bitcoin-development] A look back and a look forward
In-Reply-To: <CANEZrP3VXnX7B7wQ4LOUCs+aifx747svyo5Gysw1SG0bgcT+WA@mail.gmail.com>
References: <CAFZQHkFP81iYsAadejL1Si60FgtQSLvN==67ft2YRtsL9MqyDg@mail.gmail.com>
	<CANEZrP3VXnX7B7wQ4LOUCs+aifx747svyo5Gysw1SG0bgcT+WA@mail.gmail.com>
Message-ID: <CAFZQHkF8mpPcGw0QnVed0rAxC7oOo2C6aNWrL3a+-vMYC2KroQ@mail.gmail.com>

> I think the observation about Target vs Bitcoin exchanges is a sharp one,
> but I'm not sure how your proposal helps. You say it's an optional
identity
> layer, but obviously any thief is going to opt out of being identified.

Let me translate it to this year's vocabulary. Think of BCIs as a
sidechain: let the legacy financial system migrate, to the extent desired,
to a more heavily regulated pegged sidechain with a stronger identity
layer. Let protocol-level rules regulate this nexus between the custodial
(sidechain) and non-custodial address spaces (blockchain). This isn't
entirely unlike the rules currently governing coin issuance i.e. coinbase
transactions. Let the market forces play it out. Iterate as needed. I
suspect that in retrospect it'll seem obvious. Many moons from now the
balance might shift between the two, but it won't matter much. The system
will have means to recover from catastrophic failure modes.

To help internalize such an evolution, please consider the layers the
Bitcoin protocol builds on top of: segment 52:32 ("The Internet is being
upgraded") of the BBC documentary "Inside The Dark Web" (
https://www.youtube.com/watch?v=qXajND7BQzk#t=3152). Kaspersky's comments a
few minutes earlier (50:06) aren't entirely out of context here either.
Clearly, the need is acute for Bitcoin to become institutional i.e. for
"billions of dollars of human value" to flow through it, as one Money 20/20
participant put it.


On Fri, Jan 9, 2015 at 2:00 PM, Mike Hearn <mike at plan99.net> wrote:

> This needn't be so, once an optional identity layer, modeled after the
>> Internet itself, is provided, as proposed in late August of last year on
>> this mailing list
>>
>
> I think the observation about Target vs Bitcoin exchanges is a sharp one,
> but I'm not sure how your proposal helps. You say it's an optional identity
> layer, but obviously any thief is going to opt out of being identified.
>
> For things like the Bitstamp hack, it's not clear how identity can help,
> because they were already doing KYC for all their customers. To take that
> further at the protocol level would require* all* transactions to have
> attached identity info, and that isn't going to happen - it wouldn't be
> Bitcoin, at that point.
>
> I think that long term, it's probably possible to defend private keys
> adequately, even for large sums of money (maybe not bitstamp-large but
> we'll see). You can have very minimalist secure hardware that would have
> some additional policies on top, like refusing to sign transactions without
> an identity proof of who controls the target address. Very tight hot
> wallets that risk analyse the instructions they're receiving have been
> proposed years ago.
>
> No such hardware presently exists, but that's mostly because
> implementations always lag behind a long way behind ideas rather than any
> fundamental technical bottleneck. Perhaps the Bitstamp event will finally
> spur development of such things forward.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150109/aa8619e3/attachment.html>

From gmaxwell at gmail.com  Sat Jan 10 04:26:23 2015
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Sat, 10 Jan 2015 04:26:23 +0000
Subject: [Bitcoin-development] OpenSSL 1.0.0p / 1.0.1k incompatible,
	causes blockchain rejection.
Message-ID: <CAAS2fgR2a+3wb+He611pxy_Ypur0gq+o7SRjUHa4-R+xHLLnyA@mail.gmail.com>

OpenSSL 1.0.0p / 1.0.1k was recently released and is being
pushed out by various operating system maintainers.  My review
determined that this update is incompatible with the Bitcoin
system and could lead to consensus forks.

Bitcoin Core released binaries from Bitcoin.org are unaffected,
as are any built with the gitian deterministic build system.

If you are running third-party or self-compiled Bitcoin Core
or an alternative implementation using OpenSSL you must not
update OpenSSL or must run a Bitcoin software containing a
workaround:

https://github.com/bitcoin/bitcoin/commit/488ed32f2ada1d1dd108fc245d025c4d5f252783
(versions of this will be backported to other stable branches soon)

The tests included with Bitcoin Core in the test_bitcoin
utility already detect this condition and fail.  (_Do not ignore or
disable the tests in order to run or distribute software
which fails_)

The incompatibility is due to the OpenSSL update changing the
behavior of ECDSA validation to reject any signature which is
not encoded in a very rigid manner.  This was a result of
OpenSSL's change for CVE-2014-8275 "Certificate fingerprints
can be modified".

While for most applications it is generally acceptable to eagerly
reject some signatures, Bitcoin is a consensus system where all
participants must generally agree on the exact validity or
invalidity of the input data.  In a sense, consistency is more
important than "correctness".

As a result, an uncontrolled 'fix' can constitute a security
vulnerability for the Bitcoin system.  The Bitcoin Core developers
have been aware of this class of risk for a long time and have
taken measures to mitigate it generally; e.g., shipping static
binaries, internalizing the Leveldb library... etc.

It was somewhat surprising, however, to see this kind of change show
up as a "low" priority fix in a security update and pushed out live
onto large numbers of systems within hours.

We were specifically aware of potential hard-forks due to signature
encoding handling and had been hoping to close them via BIP62 in 0.10.
BIP62's purpose is to improve transaction malleability handling and
as a side effect rigidly defines the encoding for signatures, but the
overall scope of BIP62 has made it take longer than we'd like to
deploy.

(Coincidentally, I wrote about this concern and our unique demands on
 cryptographic software as part of a comment on Reddit shortly before
 discovering that part of this OpenSSL update was actually
 incompatible with Bitcoin:
 https://www.reddit.com/r/Bitcoin/comments/2rrxq7/on_why_010s_release_notes_say_we_have_reason_to/cnitbz3
)

The patches above, however, only fix one symptom of the general
problem: relying on software not designed or distributed for
consensus use (in particular OpenSSL) for consensus-normative
behavior.  Therefore, as an incremental improvement, I propose
a targeted soft-fork to enforce strict DER compliance soon,
utilizing a subset of BIP62.

Adding a blockchain rule for strict DER will reduce the risk of
consensus inconsistencies from alternative implementations of
signature parsing or signature verification, simplify BIP62,
and better isolate the cryptographic validation code from the
consensus algorithm. A failure to do so will likely leave us
in this situation, or possibly worse, again in the future.

The relevant incompatible transactions are already non-standard on
the network since 0.8.0's release in February 2013, although there
was seemingly a single miner still mining incompatible transactions.
That miner has been contacted and has fixed their software, so a
soft-fork with no chain forking should be possible.



From pete at petertodd.org  Sat Jan 10 05:40:38 2015
From: pete at petertodd.org (Peter Todd)
Date: Sat, 10 Jan 2015 00:40:38 -0500
Subject: [Bitcoin-development] OpenSSL 1.0.0p / 1.0.1k incompatible,
 causes blockchain rejection.
In-Reply-To: <CAAS2fgR2a+3wb+He611pxy_Ypur0gq+o7SRjUHa4-R+xHLLnyA@mail.gmail.com>
References: <CAAS2fgR2a+3wb+He611pxy_Ypur0gq+o7SRjUHa4-R+xHLLnyA@mail.gmail.com>
Message-ID: <20150110054038.GA2048@savin.petertodd.org>

On Sat, Jan 10, 2015 at 04:26:23AM +0000, Gregory Maxwell wrote:
> The incompatibility is due to the OpenSSL update changing the
> behavior of ECDSA validation to reject any signature which is
> not encoded in a very rigid manner.  This was a result of
> OpenSSL's change for CVE-2014-8275 "Certificate fingerprints
> can be modified".
> 
> While for most applications it is generally acceptable to eagerly
> reject some signatures, Bitcoin is a consensus system where all
> participants must generally agree on the exact validity or
> invalidity of the input data.  In a sense, consistency is more
> important than "correctness".

As an aside, it's interesting to note that this issue is not entirely
unique to miners.

For example in micropayment channel protocols the receiver must validate
signatures from the sender to ensure that they will be able to broadcast
transactions containing those signatures in the near-future. If they
accept a signature as valid that the majority of hashing power rejects
as invalid the sender can simply wait until the micropayment channel
timeout expires to recover 100% of their funds, ripping off the
receiver. There's many other advanced Bitcoin protocols with similar
vulnerabilities; I'd be interested to hear if anyone can come up with a
similar vulnerability in a non-Bitcoin protocol, and wouldn't be that
surprised if they did.

While I have often cautioned people before to avoid using libsecp256k1
for verification on the grounds that consensus trumps correctness, the
above incompatibility does strongly suggest that OpenSSL may not itself
have very good consensus-critical design. Along with Maxwell and
Wuille's recent findings? CVE-2014-3570 - strong evidence of the
excellent testing the library has undergone - I personally am now of the
opinion that migrating Bitcoin Core to libsecp256k1 in the near future
is a good idea on the grounds that it provides us with a well-written,
and well-understood library designed with consensus in mind that'll
probably give us fewer consensus problems than our existing OpenSSL
dependency. It'll also help advanced protocol implementations by giving
them a clear dependency to use when they need consensus-critical
signature evaluation.

1) https://www.reddit.com/r/Bitcoin/comments/2rrxq7/on_why_010s_release_notes_say_we_have_reason_to/

-- 
'peter'[:-1]@petertodd.org
000000000000003b82d8644b56c846e7497118b04a6ec68d3e0a23d33323b82e
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150110/ad0d1541/attachment.sig>

From laanwj at gmail.com  Sat Jan 10 08:35:47 2015
From: laanwj at gmail.com (Wladimir)
Date: Sat, 10 Jan 2015 08:35:47 +0000
Subject: [Bitcoin-development] OpenSSL 1.0.0p / 1.0.1k incompatible,
 causes blockchain rejection.
In-Reply-To: <CAAS2fgR2a+3wb+He611pxy_Ypur0gq+o7SRjUHa4-R+xHLLnyA@mail.gmail.com>
References: <CAAS2fgR2a+3wb+He611pxy_Ypur0gq+o7SRjUHa4-R+xHLLnyA@mail.gmail.com>
Message-ID: <CA+s+GJCe+6ioiopyfi4eJvFkrPukyW+mMedZ_nKcUEdy-5TEhg@mail.gmail.com>

On Sat, Jan 10, 2015 at 4:26 AM, Gregory Maxwell <gmaxwell at gmail.com> wrote:
> https://github.com/bitcoin/bitcoin/commit/488ed32f2ada1d1dd108fc245d025c4d5f252783
> (versions of this will be backported to other stable branches soon)

For those that build from source, patches to cope with the new OpenSSL
versions are now available on stable branches 0.8, 0.9 and rc branch
0.10:

0.8 branch (on top of 0.8.6)
========================
https://github.com/bitcoin/bitcoin/tree/0.8
https://github.com/bitcoin/bitcoin/commits/0.8

To fetch, build, and test:
```
git clone -b 0.8 https://github.com/bitcoin/bitcoin.git bitcoin-0.8
cd bitcoin-0.8/src
make -f makefile.unix
make -f makefile.unix check
```

0.9 branch (on top of 0.9.3+)
========================
https://github.com/bitcoin/bitcoin/tree/0.9
https://github.com/bitcoin/bitcoin/commits/0.9

To fetch, build, and test:
```
git clone -b 0.9 https://github.com/bitcoin/bitcoin.git bitcoin-0.9
cd bitcoin-0.9/src
./autogen.sh
./configure
make
make check
```

0.10 branch (on top of 0.10.0rc1+)
========================
https://github.com/bitcoin/bitcoin/tree/0.10
https://github.com/bitcoin/bitcoin/commits/0.10

```
git clone -b 0.10 https://github.com/bitcoin/bitcoin.git bitcoin-0.10
cd bitcoin-0.10/src
./autogen.sh
./configure
make
make check
```

Wladimir



From gghomeprodukcija at gmail.com  Sat Jan 10 11:37:17 2015
From: gghomeprodukcija at gmail.com (ggprodukcija kig)
Date: Sat, 10 Jan 2015 12:37:17 +0100
Subject: [Bitcoin-development] i need money
Message-ID: <CAFVbj0ndtyj6vup2LgQ8vveLZ0DkjFo34AQvKTMNM44+9zbZAA@mail.gmail.com>

Hi, can you send me 5btc  to my bitcoin actun. i rely need plees man
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150110/d0648455/attachment.html>

From parazyd at archlinux.info  Sat Jan 10 12:18:31 2015
From: parazyd at archlinux.info (Ivan Jelincic)
Date: Sat, 10 Jan 2015 13:18:31 +0100
Subject: [Bitcoin-development] OpenSSL 1.0.0p / 1.0.1k incompatible,
 causes blockchain rejection.
In-Reply-To: <CA+s+GJCe+6ioiopyfi4eJvFkrPukyW+mMedZ_nKcUEdy-5TEhg@mail.gmail.com>
References: <CAAS2fgR2a+3wb+He611pxy_Ypur0gq+o7SRjUHa4-R+xHLLnyA@mail.gmail.com>
	<CA+s+GJCe+6ioiopyfi4eJvFkrPukyW+mMedZ_nKcUEdy-5TEhg@mail.gmail.com>
Message-ID: <54B11897.5020100@archlinux.info>

Is openssl1.0.1j unaffected?

On 01/10/2015 09:35 AM, Wladimir wrote:
> On Sat, Jan 10, 2015 at 4:26 AM, Gregory Maxwell <gmaxwell at gmail.com> wrote:
>> https://github.com/bitcoin/bitcoin/commit/488ed32f2ada1d1dd108fc245d025c4d5f252783
>> (versions of this will be backported to other stable branches soon)
> For those that build from source, patches to cope with the new OpenSSL
> versions are now available on stable branches 0.8, 0.9 and rc branch
> 0.10:
>
> 0.8 branch (on top of 0.8.6)
> ========================
> https://github.com/bitcoin/bitcoin/tree/0.8
> https://github.com/bitcoin/bitcoin/commits/0.8
>
> To fetch, build, and test:
> ```
> git clone -b 0.8 https://github.com/bitcoin/bitcoin.git bitcoin-0.8
> cd bitcoin-0.8/src
> make -f makefile.unix
> make -f makefile.unix check
> ```
>
> 0.9 branch (on top of 0.9.3+)
> ========================
> https://github.com/bitcoin/bitcoin/tree/0.9
> https://github.com/bitcoin/bitcoin/commits/0.9
>
> To fetch, build, and test:
> ```
> git clone -b 0.9 https://github.com/bitcoin/bitcoin.git bitcoin-0.9
> cd bitcoin-0.9/src
> ./autogen.sh
> ./configure
> make
> make check
> ```
>
> 0.10 branch (on top of 0.10.0rc1+)
> ========================
> https://github.com/bitcoin/bitcoin/tree/0.10
> https://github.com/bitcoin/bitcoin/commits/0.10
>
> ```
> git clone -b 0.10 https://github.com/bitcoin/bitcoin.git bitcoin-0.10
> cd bitcoin-0.10/src
> ./autogen.sh
> ./configure
> make
> make check
> ```
>
> Wladimir
>
> ------------------------------------------------------------------------------
> Dive into the World of Parallel Programming! The Go Parallel Website,
> sponsored by Intel and developed in partnership with Slashdot Media, is your
> hub for all things parallel software development, from weekly thought
> leadership blogs to news, videos, case studies, tutorials and more. Take a
> look and join the conversation now. http://goparallel.sourceforge.net
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>




From odinn.cyberguerrilla at riseup.net  Sun Jan 11 09:16:47 2015
From: odinn.cyberguerrilla at riseup.net (odinn)
Date: Sun, 11 Jan 2015 09:16:47 +0000
Subject: [Bitcoin-development] Bi-directional micropayment channels with
 CHECKLOCKTIMEVERIFY
In-Reply-To: <CANEZrP1H-_4XiG+Azm7M4FgLrayuML+kdQ7LineXsU3FUH6=Qw@mail.gmail.com>
References: <CAGNXQMSSCtgiyFEGHS2ufuc-RZcAtpEJyFpQMDmNKd1qEDq5qA@mail.gmail.com>	<CANEZrP0ZabL2S=UhB2u7en2AfrckPk5CQe0YN-i4eDXQK-LF6A@mail.gmail.com>	<CAJHLa0NoDU+DOPfubhbVs8_Y92+uGG=mZ2+ruRCXkeULghWVVg@mail.gmail.com>
	<CANEZrP1H-_4XiG+Azm7M4FgLrayuML+kdQ7LineXsU3FUH6=Qw@mail.gmail.com>
Message-ID: <54B23F7F.5000408@riseup.net>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Please comment if possible on some of the techno-cultural implications
of ongoing development of bi-directional micropayment channels?

For example, consider zakat example(s):
www[dot]hidaya[dot]org/publications/zakat-information/10-what-is-zakat-obligatory-charity
That involves a system based on trust and which is somewhat circular
in nature (such funds as are going in one direction may also be going
simultaneously on balance in another direction somewhere else), where
the trustless bitcoin utilizes math, rather than personal trust in
order to keep the system going.
Here is some more on zakat:
en[dot]wikipedia[dot]org/wiki/Zakat
en[dot]wikipedia[dot]org/wiki/Ridda_wars (Discusses in depth some
differences between Sunni and Shiite on the subject of Zakat)

A sort of traditional philanthropic historic overview in the USA from
the 1900s forward is seen here, but it is fairly minimal and not too
revealing:
www[dot]nptrust[dot]org/history-of-giving/timeline/1900s/

A general microgiving example(s) (not yet fully modeled but for which
some prototype software ideas and concepts are in process today):
abis[dot]io

Cheers,

- -O

Mike Hearn:
> The original design is documented at the bottom of here:
> 
> https://en.bitcoin.it/wiki/Contracts#Example_7:_Rapidly-adjusted_.28micro.29payments_to_a_pre-determined_party
>
>
>
> 
In this design, time locked transactions can be broadcast across
> the network and replaced by broadcasting a new transaction that 
> uses higher sequence numbers. That's what the sequence number field
> is for. It was intended to allow arbitrary high frequency trading
> between a set of parties, though the "channel" notion is a simple
> way to think about the two party case.
> 
> The issue is that you can broadcast transactions with a lock time 
> far in the future to fill up memory, and keep broadcasting 
> replacements to use up CPU time and bandwidth.
> 
> Additionally, there is a school of thought that says Bitcoin must 
> work even if lots of miners are malicious and willing to break 
> arbitrary things in order to try and get more money. I don't think
>  Bitcoin can really be a mainstream success under such a threat 
> model, for a whole bunch of reasons (e.g. the economy relies pretty
> heavily on unconfirmed transactions), but under such a threat model
> there's nothing that forces miners to actually include the latest
> version in the block chain. They could pick any version. In the
> 2-of-2 channel model it takes both parties to sign, so clients can
> enforce that all versions have the same fee attached.
> 
> I disagree with Gregory that people refuse to use protocols that 
> are affected by malleability. There aren't any user-friendly apps 
> that use refunds currently, so we have no idea whether people would
> refuse to use them or not. It's an open question. The answer would
> probably depend on the real prevalence of attacks, which is 
> currently unknowable and likely application specific.
> 
> 
> 
> ------------------------------------------------------------------------------
>
>
>
> 
Dive into the World of Parallel Programming! The Go Parallel Website,
> sponsored by Intel and developed in partnership with Slashdot 
> Media, is your hub for all things parallel software development, 
> from weekly thought leadership blogs to news, videos, case studies,
> tutorials and more. Take a look and join the conversation now.
> http://goparallel.sourceforge.net
> 
> 
> 
> _______________________________________________ Bitcoin-development
> mailing list Bitcoin-development at lists.sourceforge.net 
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> 

- -- 
http://abis.io ~
"a protocol concept to enable decentralization
and expansion of a giving economy, and a new social good"
https://keybase.io/odinn
-----BEGIN PGP SIGNATURE-----

iQEcBAEBCgAGBQJUsj9+AAoJEGxwq/inSG8Cvu8H/RutYcVPdN+GrtAYxNkm2x7n
v/NtBIZwGs7iN6g14Te/ynEfBQRzYwVABL+d1nEuNdlYl6IB4mCXkFrz7hlFJNgK
2WOq4iKApS1tV9MFAcaxnYy6W8z5T8VpQRqxNbbFEG145cGP2l/5CYwXOmPOBdp7
qTnLs9oVyhixcfb/piFhd/4xRvlvwxVyvCamrAXBUIpgpW/VB/kfG8ikCazvcJB6
lSY+CogSGqObjlO7PhKcsZz/gTNrSIp40upyktfqZvQxWLp4WR7+GYz7vUXoofQO
Obt3ya6lZBLLL0EHYkJzAiKRy4aoIgIUzyshIHTdiQIwZC6HWnv2++sJdneng8g=
=+e6h
-----END PGP SIGNATURE-----



From mike at plan99.net  Sun Jan 11 18:56:29 2015
From: mike at plan99.net (Mike Hearn)
Date: Sun, 11 Jan 2015 19:56:29 +0100
Subject: [Bitcoin-development] Bi-directional micropayment channels with
	CHECKLOCKTIMEVERIFY
In-Reply-To: <CAAS2fgTMKwo2LOAmW+WzFnHcE7UXvCKgi7WCQLMtGDn2eaxLDA@mail.gmail.com>
References: <CAGNXQMSSCtgiyFEGHS2ufuc-RZcAtpEJyFpQMDmNKd1qEDq5qA@mail.gmail.com>
	<CANEZrP0ZabL2S=UhB2u7en2AfrckPk5CQe0YN-i4eDXQK-LF6A@mail.gmail.com>
	<CAJHLa0NoDU+DOPfubhbVs8_Y92+uGG=mZ2+ruRCXkeULghWVVg@mail.gmail.com>
	<CANEZrP1H-_4XiG+Azm7M4FgLrayuML+kdQ7LineXsU3FUH6=Qw@mail.gmail.com>
	<CAAS2fgTMKwo2LOAmW+WzFnHcE7UXvCKgi7WCQLMtGDn2eaxLDA@mail.gmail.com>
Message-ID: <CANEZrP3SE_=w_3K5YK2_L3JpiPp27Ykzbk79vn+3PsUAVWgzYg@mail.gmail.com>

Firstly, apologies to Nathan for not actually providing feedback on his
protocol. I've put pondering it onto my mental todo list. The notion of a
payment tree is interesting but complicated - I would need to think about
it and maybe draw myself some diagrams before having useful feedback here.
If you wanted to implement it, you could fork the existing code in bitcoinj
and extend it with the new functionality.

I raised the original Satoshi design mainly to inform and so the approaches
can be compared. It may well be that this proposed protocol is superior in
every way, in which case the nSequence approach would be of no further use,
assuming Nathan's protocol generalises to n-party HFT.

Replying now to Gregory:

I think we agree, and are just phrasing things differently (or slowly
groping towards consensus at the speed of email threads :-).

It's likely that over time Bitcoin will end up being multi-layered, with
the block chain being the base layer that syncs everyone up, and higher
layers doing things that miners either can't do or can't be trusted to do.
Like the proposal from GreenAddress to be a well known signer who is
trusted to not double spend.

>From miners perspective, there are multiple schemes where they are viable
if cost(fraud) < benefit, at the moment unconfirmed transactions appear to
be an example of that, and putting resource control considerations to one
side, it's possible that tx replacement would be the same. Or not. The
calculation for miners isn't easy, because if they play by the rules then
they may have a long term and reliable income stream, but if they break the
rules then that payment traffic will migrate to other solutions and they
end up with nothing. Whether it's worth it depends on how long term they're
thinking.

If we imagine a hypothetical future where lots of economic activity is
being done over Satoshi-style replaceable contracts, and suddenly a new big
short-termist miner comes along who decides that just breaking the rules
will give him more profit before the business dries up, what would happen?
If fraud costs get too extreme the old fallback of a purely centralised
solution is always there - for software compatibility purposes this would
look like a trusted node who doesn't broadcast the transactions at all and
just keeps them centrally, then mines or broadcasts the final version
themselves. Client apps would just be configured to connect directly to
that node.

Making that more competitive means having more such nodes/miners, until
eventually you have a network of miners that are regulated by identity and
bannable and don't share the tx's outside their network. That probably gets
you 95% of the benefit of the old model with maybe 150% (wild ass guess) of
the costs. "Identity" in this case can mean lots of fancy crypto things
beyond old-fashioned govt name+address style.

I don't think that'd be just an expensive and inefficient PayPal, as you'd
still have the key difference that simplifies so much - the trusted third
party doesn't hold any funds on deposit and can't directly
steal/lend/gamble with any funds. To earn money by being corrupt requires
complicated schemes where they strike secret deals to favour one party or
another, and that corruption can then be easily detected and published, so
it seems like the risk is much lower.

Bitcoin is already a pretty complex ecosystem with different kinds of trust
and decentralisation models in use. I see the next 5-10 years as a giant
cost optimisation experiment  .... where are the best settings of the
various decentralisation/speed/fees/complexity/identity knobs for different
kinds of people?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150111/6ed6eb1c/attachment.html>

From pete at petertodd.org  Sun Jan 11 22:24:47 2015
From: pete at petertodd.org (Peter Todd)
Date: Sun, 11 Jan 2015 17:24:47 -0500
Subject: [Bitcoin-development] Bi-directional micropayment channels with
 CHECKLOCKTIMEVERIFY
In-Reply-To: <CAGNXQMSSCtgiyFEGHS2ufuc-RZcAtpEJyFpQMDmNKd1qEDq5qA@mail.gmail.com>
References: <CAGNXQMSSCtgiyFEGHS2ufuc-RZcAtpEJyFpQMDmNKd1qEDq5qA@mail.gmail.com>
Message-ID: <20150111222447.GA15168@savin.petertodd.org>

On Fri, Jan 09, 2015 at 01:40:53PM +0200, Nathan Cook wrote:

Would you mind doing up some actual scriptPubKeys/transactions using
this idea as an example? I think it'd make the review process a lot
easier for everyone if there was something more concrete. (equally,
sorry I haven't had a chance to look at this, very busy for the rest of
the month)

You may find my CLTV-using micropayment channel demo useful reference
material too:

https://github.com/petertodd/checklocktimeverify-demos/blob/master/micropayment-channel.py

> A limitation on most existing micropayment channel ideas is that payments
> can only flow in one direction. This is because the payment receiver can
> sign -any- transaction you send them, not just the most recent one, and so
> it's possible to just sign the transaction transferring the largest amount
> into their control. This is easily remedied by opening a second payment
> channel in the opposite direction, but now both parties have to deposit
> funds over the lifetime of the two channels. If one party doesn't know
> ahead of time whether or not the other party will go into credit, having
> only one channel may save the use of a deposit.

-- 
'peter'[:-1]@petertodd.org
00000000000000000d41f9ac3e2a4a621769f4f077c490bf2b2a967ebfd04e42
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150111/8ab79b84/attachment.sig>

From laanwj at gmail.com  Mon Jan 12 09:40:51 2015
From: laanwj at gmail.com (Wladimir)
Date: Mon, 12 Jan 2015 09:40:51 +0000
Subject: [Bitcoin-development] OpenSSL 1.0.0p / 1.0.1k incompatible,
 causes blockchain rejection.
In-Reply-To: <54B11897.5020100@archlinux.info>
References: <CAAS2fgR2a+3wb+He611pxy_Ypur0gq+o7SRjUHa4-R+xHLLnyA@mail.gmail.com>
	<CA+s+GJCe+6ioiopyfi4eJvFkrPukyW+mMedZ_nKcUEdy-5TEhg@mail.gmail.com>
	<54B11897.5020100@archlinux.info>
Message-ID: <CA+s+GJBMcZ3Bzpcrk1PngOzOzhO7ravkrY0zp6nd9iifqJpxTg@mail.gmail.com>

On Sat, Jan 10, 2015 at 12:18 PM, Ivan Jelincic <parazyd at archlinux.info> wrote:
> Is openssl1.0.1j unaffected?

Yes. It concerns CVE-2014-8275.

Which in https://www.openssl.org/news/openssl-1.0.1-notes.html is under:

Major changes between OpenSSL 1.0.1j and OpenSSL 1.0.1k [8 Jan 2015]

Wladimir



From laanwj at gmail.com  Mon Jan 12 11:31:33 2015
From: laanwj at gmail.com (Wladimir)
Date: Mon, 12 Jan 2015 11:31:33 +0000
Subject: [Bitcoin-development] [ANN] 0.10.0rc2 has been tagged
Message-ID: <CA+s+GJDx9CFobm+4nNt_zKmDZMHnKUoVDmHu2wByihD8qTBTRA@mail.gmail.com>

I've just tagged 0.10.0rc2 in git.

To fetch, build, and test (see also doc/build-*.md):
```
git clone -b v0.10.0rc2 https://github.com/bitcoin/bitcoin.git bitcoin-0.10
cd bitcoin-0.10
./autogen.sh
./configure
make
make check
```

Note: This includes the changes required for interoperability with
OpenSSL 1.0.1k.

Notable changes relative to v0.10.0rc1:

- 4e7c219 Catch UTXO set read errors and shutdown
- a3a7317 Introduce 10 minute block download timeout
- 12b7c44 Improve robustness of DER recoding code
- 76ce5c8 fail immediately on an empty signature
- 2d375fe depends: bump openssl to 1.0.1k
- ace39db consensus: guard against openssl's new strict DER checks
- 263b65e tests: run sanity checks in tests too
- e2677d7 Fix smartfees test for change to relay policy
- b7a4ecc Build: Only check for boost when building code that requires it
- 867c600 Catch LevelDB errors during flush
- 008138c Bugfix: only track UTXO modification after lookup
- 3022e7d Require sufficent priority for relay of free transactions
- 06fdf32 bitcoin-tx: Fix JSON validation of prevtxs
- 58fda4d Update seed IPs, based on bitcoin.sipa.be crawler data
- 94b362d On close of splashscreen interrupt verifyDB
- 1eadfd9 Bugfix: prioritisetransaction: Do some basic sanity checking on txid
- 18021d0 Remove bitnodes.io from dnsseeds.
- b790d13 English translation update
- 8543b0d Correct tooltip on address book page
- 87d43a3 rpcserver: attempt to fix uncaught exception.
- 06ca065 Fix CScriptID(const CScript& in) in empty script case

Wladmir



From laanwj at gmail.com  Tue Jan 13 21:13:27 2015
From: laanwj at gmail.com (Wladimir)
Date: Tue, 13 Jan 2015 21:13:27 +0000
Subject: [Bitcoin-development] [ANN] 0.10.0rc3 has been tagged
In-Reply-To: <CA+s+GJBrFmt5hVKoB6Cv5ysSQ5BCwuLcQePqi_ZtSH18sJ6D9g@mail.gmail.com>
References: <CA+s+GJBrFmt5hVKoB6Cv5ysSQ5BCwuLcQePqi_ZtSH18sJ6D9g@mail.gmail.com>
Message-ID: <CA+s+GJCQRjsg_Zzy2AOhitwdShSBoqSz7=eiyrfwq_qeJrF=cw@mail.gmail.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512


On Mon, Jan 12, 2015 at 3:28 PM, Wladimir <laanwj at gmail.com> wrote:
> On Mon, Jan 12, 2015 at 11:31 AM, Wladimir <laanwj at gmail.com> wrote:
>
> If you build from source, and have already built rc2, there is no
> reason to build rc3.

0.10.0rc3 executables have been uploaded to https://bitcoin.org/bin/0.10.0/test

Wladimir

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1

iQEcBAEBCgAGBQJUtYo5AAoJEHSBCwEjRsmmGZkH/j51NRB/qJpIFuqz8fQo+ojI
3ZX3Njgcs8mwGcJrOqURJTuLYkj/FVCIsgvIrfCDAkWssxSh320vdktSj6vfBL4T
t0IlOHZI+vCXEB6OW+guIF9huae5OHMnuxzxcVye8dJEMrQ76Zm9CmubyOTsvZCn
eSDHIqjdu9ygbrPdGXiVQAZ1YVVV2KtHTU+AVGLPkw6EfclefXgVPm3Sp+78LJl7
ZBwgr+NpZQesOh+bIafeJLeEbMfqjOHGzZrh66dTgxhw7Eyd7QpnsRehmRozKGtg
g7FPepeDRC1tRElJlzaHn1+V61YHEj6dADCLrZ57gSXPljlnXCWo4YfAF5D6IfQ=
=yml9
-----END PGP SIGNATURE-----



From ruben at blocktrail.com  Wed Jan 14 16:37:10 2015
From: ruben at blocktrail.com (Ruben de Vries)
Date: Wed, 14 Jan 2015 17:37:10 +0100
Subject: [Bitcoin-development] convention/standard for sorting public keys
	for p2sh multisig transactions
Message-ID: <CABETNRtquBWEZZ=jOcWojcgMTpjU5nWP9p74DArLxOXqqQT7og@mail.gmail.com>

For p2sh multisig TXs the order of the public keys affect the hash and
there doesn't seem to be an agreed upon way of sorting the public keys.

If there would be a standard (recommended) way of sorting the public keys
that would make it easier for services that implement some form of multisig
to be compatible with each other without much hassle and making it possible
to import keys from one service to another.

I'm not suggesting forcing the order, just setting a standard to recommend,
there doesn't seem to be much reason for (new) services to not follow that
recommendation.

Ryan from BitPay broad this up before (
https://sourceforge.net/p/bitcoin/mailman/message/32092958/) and in bitcore
they've implemented lexicographical sorting on the hex of the public key.
In a short search I can't find any other library that has a sorting
function, let alone using it by default, so bitcore is currently my only
reference.


?Ruben de Vries
?CTO, BlockTrail
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150114/9114f30a/attachment.html>

From c1.sf-bitcoin at niftybox.net  Wed Jan 14 17:39:10 2015
From: c1.sf-bitcoin at niftybox.net (devrandom)
Date: Wed, 14 Jan 2015 09:39:10 -0800
Subject: [Bitcoin-development] convention/standard for sorting public
 keys for p2sh multisig transactions
In-Reply-To: <CABETNRtquBWEZZ=jOcWojcgMTpjU5nWP9p74DArLxOXqqQT7og@mail.gmail.com>
References: <CABETNRtquBWEZZ=jOcWojcgMTpjU5nWP9p74DArLxOXqqQT7og@mail.gmail.com>
Message-ID: <1421257150.8969.4.camel@niftybox.net>

At CryptoCorp we recommend to our customers that they sort
lexicographically by the public key bytes of the leaf public keys.  i.e.
the same as BitPay.

On Wed, 2015-01-14 at 17:37 +0100, Ruben de Vries wrote:
> For p2sh multisig TXs the order of the public keys affect the hash and
> there doesn't seem to be an agreed upon way of sorting the public
> keys.
> 
> 
> If there would be a standard (recommended) way of sorting the public
> keys that would make it easier for services that implement some form
> of multisig to be compatible with each other without much hassle and
> making it possible to import keys from one service to another.
> 
> 
> I'm not suggesting forcing the order, just setting a standard to
> recommend, there doesn't seem to be much reason for (new) services to
> not follow that recommendation.
> 
> 
> Ryan from BitPay broad this up before
> (https://sourceforge.net/p/bitcoin/mailman/message/32092958/) and in
> bitcore they've implemented lexicographical sorting on the hex of the
> public key.
> In a short search I can't find any other library that has a sorting
> function, let alone using it by default, so bitcore is currently my
> only reference.
> 
> 
> 
> 
> ?Ruben de Vries
> ?CTO, BlockTrail
> ------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> http://p.sf.net/sfu/gigenet
> _______________________________________________ Bitcoin-development mailing list Bitcoin-development at lists.sourceforge.net https://lists.sourceforge.net/lists/listinfo/bitcoin-development

-- 
Miron / devrandom






From elombrozo at gmail.com  Wed Jan 14 18:00:39 2015
From: elombrozo at gmail.com (Eric Lombrozo)
Date: Wed, 14 Jan 2015 10:00:39 -0800
Subject: [Bitcoin-development] convention/standard for sorting public
 keys for p2sh multisig transactions
In-Reply-To: <1421257150.8969.4.camel@niftybox.net>
References: <CABETNRtquBWEZZ=jOcWojcgMTpjU5nWP9p74DArLxOXqqQT7og@mail.gmail.com>
	<1421257150.8969.4.camel@niftybox.net>
Message-ID: <CABr1YTcDMhyT=3dbnSJnnBXnKCO-Cfbip7G+H9A9zVDmjEafHg@mail.gmail.com>

I think everyone is pretty much following this standard now.

- Eric
On Jan 14, 2015 12:58 PM, "devrandom" <c1.sf-bitcoin at niftybox.net> wrote:

> At CryptoCorp we recommend to our customers that they sort
> lexicographically by the public key bytes of the leaf public keys.  i.e.
> the same as BitPay.
>
> On Wed, 2015-01-14 at 17:37 +0100, Ruben de Vries wrote:
> > For p2sh multisig TXs the order of the public keys affect the hash and
> > there doesn't seem to be an agreed upon way of sorting the public
> > keys.
> >
> >
> > If there would be a standard (recommended) way of sorting the public
> > keys that would make it easier for services that implement some form
> > of multisig to be compatible with each other without much hassle and
> > making it possible to import keys from one service to another.
> >
> >
> > I'm not suggesting forcing the order, just setting a standard to
> > recommend, there doesn't seem to be much reason for (new) services to
> > not follow that recommendation.
> >
> >
> > Ryan from BitPay broad this up before
> > (https://sourceforge.net/p/bitcoin/mailman/message/32092958/) and in
> > bitcore they've implemented lexicographical sorting on the hex of the
> > public key.
> > In a short search I can't find any other library that has a sorting
> > function, let alone using it by default, so bitcore is currently my
> > only reference.
> >
> >
> >
> >
> > ?Ruben de Vries
> > ?CTO, BlockTrail
> >
> ------------------------------------------------------------------------------
> > New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> > GigeNET is offering a free month of service with a new server in Ashburn.
> > Choose from 2 high performing configs, both with 100TB of bandwidth.
> > Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> > http://p.sf.net/sfu/gigenet
> > _______________________________________________ Bitcoin-development
> mailing list Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
> --
> Miron / devrandom
>
>
>
>
>
> ------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> http://p.sf.net/sfu/gigenet
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150114/230bd912/attachment.html>

From root at haskoin.com  Wed Jan 14 18:58:07 2015
From: root at haskoin.com (Jean-Pierre Rupp)
Date: Wed, 14 Jan 2015 18:58:07 +0000
Subject: [Bitcoin-development] convention/standard for sorting public
 keys for p2sh multisig transactions
In-Reply-To: <1421257150.8969.4.camel@niftybox.net>
References: <CABETNRtquBWEZZ=jOcWojcgMTpjU5nWP9p74DArLxOXqqQT7og@mail.gmail.com>
	<1421257150.8969.4.camel@niftybox.net>
Message-ID: <54B6BC3F.6050805@haskoin.com>

We in Haskoin do the same.

On 14/01/15 17:39, devrandom wrote:
> At CryptoCorp we recommend to our customers that they sort
> lexicographically by the public key bytes of the leaf public keys.  i.e.
> the same as BitPay.

-- 
Be Happy :)



From jp at eeqj.com  Wed Jan 14 19:27:30 2015
From: jp at eeqj.com (Jeffrey Paul)
Date: Wed, 14 Jan 2015 11:27:30 -0800
Subject: [Bitcoin-development] convention/standard for sorting public
	keys for p2sh multisig transactions
In-Reply-To: <1421257150.8969.4.camel@niftybox.net>
References: <CABETNRtquBWEZZ=jOcWojcgMTpjU5nWP9p74DArLxOXqqQT7og@mail.gmail.com>
	<1421257150.8969.4.camel@niftybox.net>
Message-ID: <6E575287-887C-4628-834C-282B67AFAA94@eeqj.com>


> On 20150114, at 09:39, devrandom <c1.sf-bitcoin at niftybox.net> wrote:
> 
> At CryptoCorp we recommend to our customers that they sort
> lexicographically by the public key bytes of the leaf public keys.  i.e.
> the same as BitPay.

To clarify: the raw bytes of the public key itself, not the ascii base58 representation of the pubkey hash - right?

-jp

--
Jeffrey Paul                                                      EEQJ
jp at eeqj.com                                           https://eeqj.com
+1-800-403-1126 (America)                  +1-312-361-0355 (Worldwide)
5539 AD00 DE4C 42F3 AFE1                      1575 0524 43F4 DF2A 55C2




From stick at gk2.sk  Wed Jan 14 19:58:54 2015
From: stick at gk2.sk (Pavol Rusnak)
Date: Wed, 14 Jan 2015 20:58:54 +0100
Subject: [Bitcoin-development] convention/standard for sorting public
 keys for p2sh multisig transactions
In-Reply-To: <6E575287-887C-4628-834C-282B67AFAA94@eeqj.com>
References: <CABETNRtquBWEZZ=jOcWojcgMTpjU5nWP9p74DArLxOXqqQT7og@mail.gmail.com>	<1421257150.8969.4.camel@niftybox.net>
	<6E575287-887C-4628-834C-282B67AFAA94@eeqj.com>
Message-ID: <54B6CA7E.3070600@gk2.sk>

On 14/01/15 20:27, Jeffrey Paul wrote:
> To clarify: the raw bytes of the public key itself, not the ascii base58 representation of the pubkey hash - right?

Could you give an example of two pubkeys where the following condition
is met?

raw(pubkey1) > raw(pubkey2) and base58(pubkey1) < base58(pubkey2)

-- 
Best Regards / S pozdravom,

Pavol Rusnak <stick at gk2.sk>



From jgarzik at bitpay.com  Wed Jan 14 20:32:57 2015
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Wed, 14 Jan 2015 15:32:57 -0500
Subject: [Bitcoin-development] convention/standard for sorting public
 keys for p2sh multisig transactions
In-Reply-To: <CABETNRtquBWEZZ=jOcWojcgMTpjU5nWP9p74DArLxOXqqQT7og@mail.gmail.com>
References: <CABETNRtquBWEZZ=jOcWojcgMTpjU5nWP9p74DArLxOXqqQT7og@mail.gmail.com>
Message-ID: <CAJHLa0OdLFK+D2WF8UET7WYF_FcXENd_Vqx-7JZ034Zux6qgrA@mail.gmail.com>

Sounds like this warrants a micro-BIP just to get everybody on the same
page.


On Wed, Jan 14, 2015 at 11:37 AM, Ruben de Vries <ruben at blocktrail.com>
wrote:

> For p2sh multisig TXs the order of the public keys affect the hash and
> there doesn't seem to be an agreed upon way of sorting the public keys.
>
> If there would be a standard (recommended) way of sorting the public keys
> that would make it easier for services that implement some form of multisig
> to be compatible with each other without much hassle and making it possible
> to import keys from one service to another.
>
> I'm not suggesting forcing the order, just setting a standard to
> recommend, there doesn't seem to be much reason for (new) services to not
> follow that recommendation.
>
> Ryan from BitPay broad this up before (
> https://sourceforge.net/p/bitcoin/mailman/message/32092958/) and in
> bitcore they've implemented lexicographical sorting on the hex of the
> public key.
> In a short search I can't find any other library that has a sorting
> function, let alone using it by default, so bitcore is currently my only
> reference.
>
>
> ?Ruben de Vries
> ?CTO, BlockTrail
>
>
> ------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> http://p.sf.net/sfu/gigenet
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>


-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150114/2468d959/attachment.html>

From elombrozo at gmail.com  Wed Jan 14 23:53:26 2015
From: elombrozo at gmail.com (Eric Lombrozo)
Date: Wed, 14 Jan 2015 15:53:26 -0800
Subject: [Bitcoin-development] convention/standard for sorting public
 keys for p2sh multisig transactions
In-Reply-To: <6E575287-887C-4628-834C-282B67AFAA94@eeqj.com>
References: <CABETNRtquBWEZZ=jOcWojcgMTpjU5nWP9p74DArLxOXqqQT7og@mail.gmail.com>
	<1421257150.8969.4.camel@niftybox.net>
	<6E575287-887C-4628-834C-282B67AFAA94@eeqj.com>
Message-ID: <CABr1YTdqUxBs3+dMmtZ5dQvxP8MBFgttCdJ9cuvy10LdwAKaYQ@mail.gmail.com>

I would highly recommend NOT using Base58 for anything except stuff that is
to be copy/pasted by the enduser.

Internally, pubkeys are DER-encoded integers.

- Eric
On Jan 14, 2015 2:54 PM, "Jeffrey Paul" <jp at eeqj.com> wrote:

>
> > On 20150114, at 09:39, devrandom <c1.sf-bitcoin at niftybox.net> wrote:
> >
> > At CryptoCorp we recommend to our customers that they sort
> > lexicographically by the public key bytes of the leaf public keys.  i.e.
> > the same as BitPay.
>
> To clarify: the raw bytes of the public key itself, not the ascii base58
> representation of the pubkey hash - right?
>
> -jp
>
> --
> Jeffrey Paul                                                      EEQJ
> jp at eeqj.com                                           https://eeqj.com
> +1-800-403-1126 (America)                  +1-312-361-0355 (Worldwide)
> 5539 AD00 DE4C 42F3 AFE1                      1575 0524 43F4 DF2A 55C2
>
>
>
> ------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> http://p.sf.net/sfu/gigenet
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150114/2a23f3b3/attachment.html>

From elombrozo at gmail.com  Thu Jan 15 01:09:54 2015
From: elombrozo at gmail.com (Eric Lombrozo)
Date: Wed, 14 Jan 2015 17:09:54 -0800
Subject: [Bitcoin-development] convention/standard for sorting public
 keys for p2sh multisig transactions
In-Reply-To: <CALKy-wreXNohc_Pe_DLBS1cXoS-3j8C_F7WsKuU=CYYKF9NB1Q@mail.gmail.com>
References: <CABETNRtquBWEZZ=jOcWojcgMTpjU5nWP9p74DArLxOXqqQT7og@mail.gmail.com>
	<1421257150.8969.4.camel@niftybox.net>
	<6E575287-887C-4628-834C-282B67AFAA94@eeqj.com>
	<CABr1YTdqUxBs3+dMmtZ5dQvxP8MBFgttCdJ9cuvy10LdwAKaYQ@mail.gmail.com>
	<CALKy-wreXNohc_Pe_DLBS1cXoS-3j8C_F7WsKuU=CYYKF9NB1Q@mail.gmail.com>
Message-ID: <CABr1YTc+vBVmn5PgW1b8udg2YCFwaUOAMS8dfRRtO-OrxNSn-w@mail.gmail.com>

Ciphrex was using this convention well before BitPay...and BitPay's BIP32
implementation was at least partly taken from ours.

- Eric
On Jan 14, 2015 8:03 PM, "Andy Alness" <andy at coinbase.com> wrote:

> Doing same (BitPay convention) for our multisig support.
>
> On Wed, Jan 14, 2015 at 3:53 PM, Eric Lombrozo <elombrozo at gmail.com>
> wrote:
> > I would highly recommend NOT using Base58 for anything except stuff that
> is
> > to be copy/pasted by the enduser.
> >
> > Internally, pubkeys are DER-encoded integers.
> >
> > - Eric
> >
> > On Jan 14, 2015 2:54 PM, "Jeffrey Paul" <jp at eeqj.com> wrote:
> >>
> >>
> >> > On 20150114, at 09:39, devrandom <c1.sf-bitcoin at niftybox.net> wrote:
> >> >
> >> > At CryptoCorp we recommend to our customers that they sort
> >> > lexicographically by the public key bytes of the leaf public keys.
> i.e.
> >> > the same as BitPay.
> >>
> >> To clarify: the raw bytes of the public key itself, not the ascii base58
> >> representation of the pubkey hash - right?
> >>
> >> -jp
> >>
> >> --
> >> Jeffrey Paul                                                      EEQJ
> >> jp at eeqj.com                                           https://eeqj.com
> >> +1-800-403-1126 (America)                  +1-312-361-0355 (Worldwide)
> >> 5539 AD00 DE4C 42F3 AFE1                      1575 0524 43F4 DF2A 55C2
> >>
> >>
> >>
> >>
> ------------------------------------------------------------------------------
> >> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> >> GigeNET is offering a free month of service with a new server in
> Ashburn.
> >> Choose from 2 high performing configs, both with 100TB of bandwidth.
> >> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> >> http://p.sf.net/sfu/gigenet
> >> _______________________________________________
> >> Bitcoin-development mailing list
> >> Bitcoin-development at lists.sourceforge.net
> >> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> >
> >
> >
> ------------------------------------------------------------------------------
> > New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> > GigeNET is offering a free month of service with a new server in Ashburn.
> > Choose from 2 high performing configs, both with 100TB of bandwidth.
> > Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> > http://p.sf.net/sfu/gigenet
> > _______________________________________________
> > Bitcoin-development mailing list
> > Bitcoin-development at lists.sourceforge.net
> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> >
>
>
>
> --
> Andy Alness
> Software Engineer
> Coinbase
> San Francisco, CA
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150114/df980217/attachment.html>

From bip at mattwhitlock.name  Thu Jan 15 01:17:52 2015
From: bip at mattwhitlock.name (Matt Whitlock)
Date: Wed, 14 Jan 2015 20:17:52 -0500
Subject: [Bitcoin-development] convention/standard for sorting public
	keys for p2sh multisig transactions
In-Reply-To: <CABr1YTdqUxBs3+dMmtZ5dQvxP8MBFgttCdJ9cuvy10LdwAKaYQ@mail.gmail.com>
References: <CABETNRtquBWEZZ=jOcWojcgMTpjU5nWP9p74DArLxOXqqQT7og@mail.gmail.com>
	<6E575287-887C-4628-834C-282B67AFAA94@eeqj.com>
	<CABr1YTdqUxBs3+dMmtZ5dQvxP8MBFgttCdJ9cuvy10LdwAKaYQ@mail.gmail.com>
Message-ID: <3382316.6TbFyFjyI6@crushinator>

On Wednesday, 14 January 2015, at 3:53 pm, Eric Lombrozo wrote:
> Internally, pubkeys are DER-encoded integers.

I thought pubkeys were represented as raw integers (i.e., they're embedded in Script as a push operation whose payload is the raw bytes of the big-endian representation of the integer). As far as I know, DER encoding is only used for signatures. Am I mistaken?



From jbrown at bluedroplet.com  Thu Jan 15 11:59:15 2015
From: jbrown at bluedroplet.com (Jonathan Brown)
Date: Thu, 15 Jan 2015 18:59:15 +0700
Subject: [Bitcoin-development] convention/standard for sorting public
 keys for p2sh multisig transactions
In-Reply-To: <CAJHLa0OdLFK+D2WF8UET7WYF_FcXENd_Vqx-7JZ034Zux6qgrA@mail.gmail.com>
References: <CABETNRtquBWEZZ=jOcWojcgMTpjU5nWP9p74DArLxOXqqQT7og@mail.gmail.com>
	<CAJHLa0OdLFK+D2WF8UET7WYF_FcXENd_Vqx-7JZ034Zux6qgrA@mail.gmail.com>
Message-ID: <CABaYTy9U41_chiD-+MCY+ixKO-eA_Ch7LDv7uLvEgqzWy0x1xg@mail.gmail.com>

In BIP45 it mentions "lexicographically sorting the public keys".

https://github.com/bitcoin/bips/blob/master/bip-0045.mediawiki#Address_Generation_Procedure

On 15 January 2015 at 03:32, Jeff Garzik <jgarzik at bitpay.com> wrote:

> Sounds like this warrants a micro-BIP just to get everybody on the same
> page.
>
>
> On Wed, Jan 14, 2015 at 11:37 AM, Ruben de Vries <ruben at blocktrail.com>
> wrote:
>
>> For p2sh multisig TXs the order of the public keys affect the hash and
>> there doesn't seem to be an agreed upon way of sorting the public keys.
>>
>> If there would be a standard (recommended) way of sorting the public keys
>> that would make it easier for services that implement some form of multisig
>> to be compatible with each other without much hassle and making it possible
>> to import keys from one service to another.
>>
>> I'm not suggesting forcing the order, just setting a standard to
>> recommend, there doesn't seem to be much reason for (new) services to not
>> follow that recommendation.
>>
>> Ryan from BitPay broad this up before (
>> https://sourceforge.net/p/bitcoin/mailman/message/32092958/) and in
>> bitcore they've implemented lexicographical sorting on the hex of the
>> public key.
>> In a short search I can't find any other library that has a sorting
>> function, let alone using it by default, so bitcore is currently my only
>> reference.
>>
>>
>> ?Ruben de Vries
>> ?CTO, BlockTrail
>>
>>
>> ------------------------------------------------------------------------------
>> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
>> GigeNET is offering a free month of service with a new server in Ashburn.
>> Choose from 2 high performing configs, both with 100TB of bandwidth.
>> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
>> http://p.sf.net/sfu/gigenet
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>>
>
>
> --
> Jeff Garzik
> Bitcoin core developer and open source evangelist
> BitPay, Inc.      https://bitpay.com/
>
>
> ------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> http://p.sf.net/sfu/gigenet
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150115/b521875e/attachment.html>

From root at haskoin.com  Thu Jan 15 12:33:39 2015
From: root at haskoin.com (Jean-Pierre Rupp)
Date: Thu, 15 Jan 2015 12:33:39 +0000
Subject: [Bitcoin-development] convention/standard for sorting public
 keys for p2sh multisig transactions
In-Reply-To: <3382316.6TbFyFjyI6@crushinator>
References: <CABETNRtquBWEZZ=jOcWojcgMTpjU5nWP9p74DArLxOXqqQT7og@mail.gmail.com>	<6E575287-887C-4628-834C-282B67AFAA94@eeqj.com>	<CABr1YTdqUxBs3+dMmtZ5dQvxP8MBFgttCdJ9cuvy10LdwAKaYQ@mail.gmail.com>
	<3382316.6TbFyFjyI6@crushinator>
Message-ID: <54B7B3A3.1000809@haskoin.com>

A public key is a point in the elliptic curve.  As such it has an X and
a Y component.  Its serialization is described very succintly here:

https://en.bitcoin.it/wiki/Protocol_specification#Signatures

On 15/01/15 01:17, Matt Whitlock wrote:
> I thought pubkeys were represented as raw integers (i.e., they're embedded in Script as a push operation whose payload is the raw bytes of the big-endian representation of the integer). As far as I know, DER encoding is only used for signatures. Am I mistaken?

-- 
Be Happy :)



From ruben at blocktrail.com  Fri Jan 16 10:16:56 2015
From: ruben at blocktrail.com (Ruben de Vries)
Date: Fri, 16 Jan 2015 11:16:56 +0100
Subject: [Bitcoin-development] convention/standard for sorting public
 keys for p2sh multisig transactions
In-Reply-To: <CA+s+GJCsta-FesGv7zW_i2pEtZM5U20ZqP2V_Oog_LBtQBbe-w@mail.gmail.com>
References: <CABETNRtquBWEZZ=jOcWojcgMTpjU5nWP9p74DArLxOXqqQT7og@mail.gmail.com>
	<6E575287-887C-4628-834C-282B67AFAA94@eeqj.com>
	<CABr1YTdqUxBs3+dMmtZ5dQvxP8MBFgttCdJ9cuvy10LdwAKaYQ@mail.gmail.com>
	<3382316.6TbFyFjyI6@crushinator>
	<CA+s+GJCsta-FesGv7zW_i2pEtZM5U20ZqP2V_Oog_LBtQBbe-w@mail.gmail.com>
Message-ID: <CABETNRsTS=eDqTL5Cj8uYxLPZhWHW=p8CCxCdP7uUAHYujs7gA@mail.gmail.com>

Since we only need the sorting for creating the scriptPubKey,
wouldn't it make the most sense to sort it by the way it represented in
that context?


On Thu, Jan 15, 2015 at 2:03 PM, Wladimir <laanwj at gmail.com> wrote:

> On Thu, Jan 15, 2015 at 1:17 AM, Matt Whitlock <bip at mattwhitlock.name>
> wrote:
> > On Wednesday, 14 January 2015, at 3:53 pm, Eric Lombrozo wrote:
> >> Internally, pubkeys are DER-encoded integers.
> >
> > I thought pubkeys were represented as raw integers (i.e., they're
> embedded in Script as a push operation whose payload is the raw bytes of
> the big-endian representation of the integer). As far as I know, DER
> encoding is only used for signatures. Am I mistaken?
>
> OP_CHECKSIG (and OP_CHECKSIGVERIFY) takes a DER-encoded pubkey and a
> DER-encoded signature on the stack.
>
> Possibly you're confused with OP_HASH160 <hash160> OP_EQUALVERIFY as
> used in outputs, which compares the 160-bit hash of the pubkey against
> the given hash (usually taken from a bitcoin address).
>
> It doesn't help understanding to consider either as integers. They are
> binary blob objects with either a fixed format (DER) or a fixed size
> (hashes).
>
> Wladimir
>



-- 
BlockTrail B.V.
Barbara Strozzilaan 201
1083HN Amsterdam
The Netherlands

Phone: +31 (0)612227277
E-mail: ruben at blocktrail.com
Web: www.blocktrail.com
Github: www.github.com/rubensayshi

BlockTrail B.V. Is registered with the Dutch Chamber of Commerce in
Amsterdam with registration No.:60262060 and VAT No.:NL853833035B01
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150116/6dcebfd8/attachment.html>

From me at thomaskerin.io  Fri Jan 16 16:34:17 2015
From: me at thomaskerin.io (Thomas Kerin)
Date: Fri, 16 Jan 2015 16:34:17 +0000
Subject: [Bitcoin-development] convention/standard for sorting public
 keys for p2sh multisig transactions
In-Reply-To: <CABETNRsTS=eDqTL5Cj8uYxLPZhWHW=p8CCxCdP7uUAHYujs7gA@mail.gmail.com>
References: <CABETNRtquBWEZZ=jOcWojcgMTpjU5nWP9p74DArLxOXqqQT7og@mail.gmail.com>	<6E575287-887C-4628-834C-282B67AFAA94@eeqj.com>	<CABr1YTdqUxBs3+dMmtZ5dQvxP8MBFgttCdJ9cuvy10LdwAKaYQ@mail.gmail.com>	<3382316.6TbFyFjyI6@crushinator>	<CA+s+GJCsta-FesGv7zW_i2pEtZM5U20ZqP2V_Oog_LBtQBbe-w@mail.gmail.com>
	<CABETNRsTS=eDqTL5Cj8uYxLPZhWHW=p8CCxCdP7uUAHYujs7gA@mail.gmail.com>
Message-ID: <54B93D89.5020005@thomaskerin.io>


-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

It would - it assumes you have the set of keys and are sorting before
you derive and send funds to such a P2SH address.

It seems there is scope for further narrowing down how a multisig
scripthash address should be determined - what do people think of
anticipating only compressed keys for scripts?

It's possible to cause confusion if one put forward a compressed key at
some time, and an uncompressed key at another. A different script hash
would be produced even though there is no difference to the keys
involved. The client will not search for this.


Having spoken with Jean-Pierre and Ruben about this for quite some time
now, there is 100% the need for a BIP outlining this. Everyone has had
the idea at some point, and some of us already using it, but people
shouldn't have to go digging in BIP45 for the two lines which mention
it. All we need is a place to put the docs.

I am building up a list of implementations which currently support
sorting, and briefly describing a motivation for such a BIP.


On 16/01/15 10:16, Ruben de Vries wrote:
> Since we only need the sorting for creating the scriptPubKey,
> wouldn't it make the most sense to sort it by the way it represented
in that context?
>
>
> On Thu, Jan 15, 2015 at 2:03 PM, Wladimir <laanwj at gmail.com
<mailto:laanwj at gmail.com>> wrote:
>
>     On Thu, Jan 15, 2015 at 1:17 AM, Matt Whitlock
<bip at mattwhitlock.name <mailto:bip at mattwhitlock.name>> wrote:
>     > On Wednesday, 14 January 2015, at 3:53 pm, Eric Lombrozo wrote:
>     >> Internally, pubkeys are DER-encoded integers.
>     >
>     > I thought pubkeys were represented as raw integers (i.e.,
they're embedded in Script as a push operation whose payload is the raw
bytes of the big-endian representation of the integer). As far as I
know, DER encoding is only used for signatures. Am I mistaken?
>
>     OP_CHECKSIG (and OP_CHECKSIGVERIFY) takes a DER-encoded pubkey and a
>     DER-encoded signature on the stack.
>
>     Possibly you're confused with OP_HASH160 <hash160> OP_EQUALVERIFY as
>     used in outputs, which compares the 160-bit hash of the pubkey against
>     the given hash (usually taken from a bitcoin address).
>
>     It doesn't help understanding to consider either as integers. They are
>     binary blob objects with either a fixed format (DER) or a fixed size
>     (hashes).
>
>     Wladimir
>
>
>
>
> --
> BlockTrail B.V.
> Barbara Strozzilaan 201
> 1083HN Amsterdam
> The Netherlands
>
> Phone:+31 (0)612227277
> E-mail:ruben at blocktrail.com <mailto:ruben at blocktrail.com>
> Web:www.blocktrail.com
> <http://www.blocktrail.com/>
> Github:www.github.com/rubensayshi <http://www.github.com/rubensayshi>
>
> BlockTrail B.V. Is registered with the Dutch Chamber of Commerce in
Amsterdam with registration No.:60262060 and VAT No.:NL853833035B01
>
>
>
------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> http://p.sf.net/sfu/gigenet
>
>
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development

- -- 
Thomas Kerin
- -------------------------

My PGP key can be found here
<http://pgp.mit.edu/pks/lookup?op=get&search=0x3F0D2F83A2966155>
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1

iQJ8BAEBCgBmBQJUuT2EXxSAAAAAAC4AKGlzc3Vlci1mcHJAbm90YXRpb25zLm9w
ZW5wZ3AuZmlmdGhob3JzZW1hbi5uZXQ2MzI1MzM4QjJGOTU5OEUzREMzQzc0MzAz
RjBEMkY4M0EyOTY2MTU1AAoJED8NL4OilmFV4GgP/Rr955cDBA34e58lLdjXkqzi
EYDH5QfsTdUQQVUvkK0OBq7RQwkbb7Kn5u6U8UD3hEhaWwQGhrQ/gOJrqM68glma
YfYupugMesTTu4Fxm/AtNv4Cifr29EZB1gu9hBeZGT4FL863+0ShvWHdHvscOcmg
3SGv0De+1bd93j7p+9jyWh/sYpHEdi0lQBMkkCzSzhXPZzoHEglUmVYBRcmrjaag
ycHuQfN5zjM0fJ18R6f7PCOOAhDi9+7xpikDArvHmKb4BZjOuMBTprN2Mzdg98Uz
Rw4LRsLuht5VCnWHvC8+TUUEMUO8QOMrRxLYJSDVGcl0XYXT0EiRfnkqCr5ab8mm
KqLcxpSLxrDGd4OiHwWB7oDsg9tWXwVmyQgFsTLsxaNkL8AFRG59mAhbK9j+0+1E
Bd/pMx0VgGXpn1Urism5YlrR4FZ5USbYn9O0NxhUkQb550qvRtaAQNUVSJPEW0AG
/2pQdFOOqkI1wI0g2L/ZcC+fwBqUok+5MyMTb4NuuvaMDpR7vOeeobIpYLjL0VVZ
dNzfnlCQxGw/7QrFIbvnye8fNIMZZ9qtJx00bvXYizRyUhrF/FrRgwj2DhEjz6xM
3+CHKXNmb0qGg6jKgHvXQFic2DVo3IaNmZtVDBqyqCBKmC/A65rRws5uxIimUsIC
k4af62ZBGpSAhJ4ajCIY
=Ni9V
-----END PGP SIGNATURE-----

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150116/12059b7e/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0xA2966155.asc
Type: application/pgp-keys
Size: 5712 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150116/12059b7e/attachment.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0xA2966155.asc.sig
Type: application/pgp-signature
Size: 639 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150116/12059b7e/attachment.sig>

From etotheipi at gmail.com  Fri Jan 16 17:09:39 2015
From: etotheipi at gmail.com (Alan Reiner)
Date: Fri, 16 Jan 2015 12:09:39 -0500
Subject: [Bitcoin-development] convention/standard for sorting public
 keys for p2sh multisig transactions
In-Reply-To: <54B93D89.5020005@thomaskerin.io>
References: <CABETNRtquBWEZZ=jOcWojcgMTpjU5nWP9p74DArLxOXqqQT7og@mail.gmail.com>	<6E575287-887C-4628-834C-282B67AFAA94@eeqj.com>	<CABr1YTdqUxBs3+dMmtZ5dQvxP8MBFgttCdJ9cuvy10LdwAKaYQ@mail.gmail.com>	<3382316.6TbFyFjyI6@crushinator>	<CA+s+GJCsta-FesGv7zW_i2pEtZM5U20ZqP2V_Oog_LBtQBbe-w@mail.gmail.com>	<CABETNRsTS=eDqTL5Cj8uYxLPZhWHW=p8CCxCdP7uUAHYujs7gA@mail.gmail.com>
	<54B93D89.5020005@thomaskerin.io>
Message-ID: <54B945D3.1000404@gmail.com>

I see no reason to restrict compressed/uncompressed.  Strings don't have
to be the same length to sort them lexicographically.  If a multi-sig
participant provides an uncompressed key, they are declaring that the
key that they use and it will only be used uncompressed.   Clients don't
have to go looking for all combinations of compressed & uncompressed.

On 01/16/2015 11:34 AM, Thomas Kerin wrote:
>
>
> It seems there is scope for further narrowing down how a multisig
> scripthash address should be determined - what do people think of
> anticipating only compressed keys for scripts?
>
> It's possible to cause confusion if one put forward a compressed key
> at some time, and an uncompressed key at another. A different script
> hash would be produced even though there is no difference to the keys
> involved. The client will not search for this.
>
>
> Having spoken with Jean-Pierre and Ruben about this for quite some
> time now, there is 100% the need for a BIP outlining this. Everyone
> has had the idea at some point, and some of us already using it, but
> people shouldn't have to go digging in BIP45 for the two lines which
> mention it. All we need is a place to put the docs.
>
> I am building up a list of implementations which currently support
> sorting, and briefly describing a motivation for such a BIP.
>
>
> On 16/01/15 10:16, Ruben de Vries wrote:
> > Since we only need the sorting for creating the scriptPubKey,
> > wouldn't it make the most sense to sort it by the way it represented
> in that context?
>
>
> > On Thu, Jan 15, 2015 at 2:03 PM, Wladimir <laanwj at gmail.com
> <mailto:laanwj at gmail.com>> wrote:
>
> >     On Thu, Jan 15, 2015 at 1:17 AM, Matt Whitlock
> <bip at mattwhitlock.name <mailto:bip at mattwhitlock.name>> wrote:
> >     > On Wednesday, 14 January 2015, at 3:53 pm, Eric Lombrozo wrote:
> >     >> Internally, pubkeys are DER-encoded integers.
> >     >
> >     > I thought pubkeys were represented as raw integers (i.e.,
> they're embedded in Script as a push operation whose payload is the
> raw bytes of the big-endian representation of the integer). As far as
> I know, DER encoding is only used for signatures. Am I mistaken?
>
> >     OP_CHECKSIG (and OP_CHECKSIGVERIFY) takes a DER-encoded pubkey and a
> >     DER-encoded signature on the stack.
>
> >     Possibly you're confused with OP_HASH160 <hash160> OP_EQUALVERIFY as
> >     used in outputs, which compares the 160-bit hash of the pubkey
> against
> >     the given hash (usually taken from a bitcoin address).
>
> >     It doesn't help understanding to consider either as integers.
> They are
> >     binary blob objects with either a fixed format (DER) or a fixed size
> >     (hashes).
>
> >     Wladimir
>
>
>
>
> > --
> > BlockTrail B.V.
> > Barbara Strozzilaan 201
> > 1083HN Amsterdam
> > The Netherlands
>
> > Phone:+31 (0)612227277
> > E-mail:ruben at blocktrail.com <mailto:ruben at blocktrail.com>
> > Web:www.blocktrail.com
> > <http://www.blocktrail.com/>
> > Github:www.github.com/rubensayshi <http://www.github.com/rubensayshi>
>
> > BlockTrail B.V. Is registered with the Dutch Chamber of Commerce in
> Amsterdam with registration No.:60262060 and VAT No.:NL853833035B01
>
>
> >
> ------------------------------------------------------------------------------
> > New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> > GigeNET is offering a free month of service with a new server in
> Ashburn.
> > Choose from 2 high performing configs, both with 100TB of bandwidth.
> > Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> > http://p.sf.net/sfu/gigenet
>
>
> > _______________________________________________
> > Bitcoin-development mailing list
> > Bitcoin-development at lists.sourceforge.net
> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
>
>
>
------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> http://p.sf.net/sfu/gigenet
>
>
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150116/74819d20/attachment.html>

From root at haskoin.com  Fri Jan 16 18:40:17 2015
From: root at haskoin.com (Jean-Pierre Rupp)
Date: Fri, 16 Jan 2015 18:40:17 +0000
Subject: [Bitcoin-development] convention/standard for sorting public
 keys for p2sh multisig transactions
Message-ID: <20150116184024.3C808220525A@erelay1.ox.registrar-servers.com>

It is better if the scheme is strongly deterministic.On 16 Jan 2015 17:09, Alan Reiner <etotheipi at gmail.com> wrote:
>
> I see no reason to restrict compressed/uncompressed.? Strings don't have to be the same length to sort them lexicographically.? If a multi-sig participant provides an uncompressed key, they are declaring that the key that they use and it will only be used uncompressed.?? Clients don't have to go looking for all combinations of compressed & uncompressed.
>
> On 01/16/2015 11:34 AM, Thomas Kerin wrote:
> >
>>
>>
>> It seems there is scope for further narrowing down how a multisig scripthash address should be determined - what do people think of anticipating only compressed keys for scripts?
>>
>> It's possible to cause confusion if one put forward a compressed key at some time, and an uncompressed key at another. A different script hash would be produced even though there is no difference to the keys involved. The client will not search for this.
>>
>>
>> Having spoken with Jean-Pierre and Ruben about this for quite some time now, there is 100% the need for a BIP outlining this. Everyone has had the idea at some point, and some of us already using it, but people shouldn't have to go digging in BIP45 for the two lines which mention it. All we need is a place to put the docs.
>>
>> I am building up a list of implementations which currently support sorting, and briefly describing a motivation for such a BIP.
>>
>>
>> On 16/01/15 10:16, Ruben de Vries wrote:
>> > Since we only need the sorting for creating the scriptPubKey,
>> > wouldn't it make the most sense to sort it by the way it represented in that context?
>>
>>
>> > On Thu, Jan 15, 2015 at 2:03 PM, Wladimir <laanwj at gmail.com <mailto:laanwj at gmail.com>> wrote:
>>
>> >???? On Thu, Jan 15, 2015 at 1:17 AM, Matt Whitlock <bip at mattwhitlock.name <mailto:bip at mattwhitlock.name>> wrote:
>> >???? > On Wednesday, 14 January 2015, at 3:53 pm, Eric Lombrozo wrote:
>> >???? >> Internally, pubkeys are DER-encoded integers.
>> >???? >
>> >???? > I thought pubkeys were represented as raw integers (i.e., they're embedded in Script as a push operation whose payload is the raw bytes of the big-endian representation of the integer). As far as I know, DER encoding is only used for signatures. Am I mistaken?
>>
>> >???? OP_CHECKSIG (and OP_CHECKSIGVERIFY) takes a DER-encoded pubkey and a
>> >???? DER-encoded signature on the stack.
>>
>> >???? Possibly you're confused with OP_HASH160 <hash160> OP_EQUALVERIFY as
>> >???? used in outputs, which compares the 160-bit hash of the pubkey against
>> >???? the given hash (usually taken from a bitcoin address).
>>
>> >???? It doesn't help understanding to consider either as integers. They are
>> >???? binary blob objects with either a fixed format (DER) or a fixed size
>> >???? (hashes).
>>
>> >???? Wladimir
>>
>>
>>
>>
>> > --
>> > BlockTrail B.V.
>> > Barbara Strozzilaan 201
>> > 1083HN Amsterdam
>> > The Netherlands
>>
>> > Phone:+31 (0)612227277
>> > E-mail:ruben at blocktrail.com <mailto:ruben at blocktrail.com>
>> > Web:www.blocktrail.com
>> > <http://www.blocktrail.com/>
>> > Github:www.github.com/rubensayshi <http://www.github.com/rubensayshi>
>>
>> > BlockTrail B.V. Is registered with the Dutch Chamber of Commerce in Amsterdam with registration No.:60262060 and VAT No.:NL853833035B01
>>
>>
>> > ------------------------------------------------------------------------------
>> > New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
>> > GigeNET is offering a free month of service with a new server in Ashburn.
>> > Choose from 2 high performing configs, both with 100TB of bandwidth.
>> > Higher redundancy.Lower latency.Increased capacity.Completely compliant.
>> > http://p.sf.net/sfu/gigenet
>>
>>
>> > _______________________________________________
>> > Bitcoin-development mailing list
>> > Bitcoin-development at lists.sourceforge.net
>> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
> >
> >
> >
> > ------------------------------------------------------------------------------
> > New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> > GigeNET is offering a free month of service with a new server in Ashburn.
> > Choose from 2 high performing configs, both with 100TB of bandwidth.
> > Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> > http://p.sf.net/sfu/gigenet
> >
> >
> > _______________________________________________
> > Bitcoin-development mailing list
> > Bitcoin-development at lists.sourceforge.net
> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>

From runesvend at gmail.com  Sat Jan 17 20:45:27 2015
From: runesvend at gmail.com (=?UTF-8?Q?Rune_Kj=C3=A6r_Svendsen?=)
Date: Sat, 17 Jan 2015 21:45:27 +0100
Subject: [Bitcoin-development] IMPULSE: Instant Payments using the Bitcoin
	protocol
Message-ID: <CAH2=CKzsikCnQHBdXnPa=OhHEs2-4D+t79ZCbrH7-qspmA64jQ@mail.gmail.com>

Hi list

Found this on reddit: http://impulse.is/

PDF: http://impulse.is/impulse.pdf

I'd love to hear this list's thoughts.

/runeks
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150117/813343df/attachment.html>

From rnbrady at gmail.com  Mon Jan 19 19:07:30 2015
From: rnbrady at gmail.com (Richard Brady)
Date: Mon, 19 Jan 2015 19:07:30 +0000
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
Message-ID: <CAN5esQJe0uUm0NyctaBa6WH7_JjeE_OLR=FY_XQWnSr50VRDyA@mail.gmail.com>

Hi Gavin, Mike and co

Is there a strong driver behind the choice of Google Protocol Buffers for
payment request encoding in BIP-0070?

Performance doesn't feel that relevant when you think that:
1. Payment requests are not broadcast, this is a request / response flow,
much more akin to a web request.
2. One would be cramming this data into a binary format just so you can
then attach it to a no-so-binary format such as HTTP.

Some great things about protocols/encodings such as HTTP/JSON/XML are:
1. They are human readable on-the-wire. No Wireshark plugin required,
tcpdump or ngrep will do.
2. There are tons of great open source libraries and API for parsing /
manipulating / generating.
3. It's really easy to hand-craft a test message for debugging.
4. The standards are much easier to read and write. They don't need to
contain code like BIP-0070 currently does and they can contain examples,
which BIP70 does not.
5. They are thoroughly specified by independent standards bodies such as
the IETF. Gotta love a bit of MUST / SHOULD / MAY in a standard.
6. They're a family ;-)

Keen to hear your thoughts on this and very keen to watch the payment
protocol grow regardless of encoding choice! My background is SIP / VoIP
and I think that could be a fascinating use case for this protocol which
I'm hoping to do some work on.

Best,
Richard
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/6edaa8fd/attachment.html>

From rnbrady at gmail.com  Mon Jan 19 19:16:54 2015
From: rnbrady at gmail.com (Richard Brady)
Date: Mon, 19 Jan 2015 19:16:54 +0000
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <CAJHLa0OTynX4oiQoyanpRKE2tpAuS4L5X-2j20328725J9RrvQ@mail.gmail.com>
References: <CAN5esQJe0uUm0NyctaBa6WH7_JjeE_OLR=FY_XQWnSr50VRDyA@mail.gmail.com>
	<CAJHLa0OTynX4oiQoyanpRKE2tpAuS4L5X-2j20328725J9RrvQ@mail.gmail.com>
Message-ID: <CAN5esQJK4UnkQC=y6aT15txFekpptv32+5n4CbyR=6G6J7HF4A@mail.gmail.com>

Fair points, although for me the line is blurred between which of those are
security considerations vs performance considerations.

Richard

On 19 January 2015 at 19:09, Jeff Garzik <jgarzik at bitpay.com> wrote:

> Text formats such as XML or JSON are far less deterministic, are more
> loosely specified, have wide variance in parsing, are not very hash-able,
> the list goes on.
>
>
> On Mon, Jan 19, 2015 at 2:07 PM, Richard Brady <rnbrady at gmail.com> wrote:
>
>> Hi Gavin, Mike and co
>>
>> Is there a strong driver behind the choice of Google Protocol Buffers for
>> payment request encoding in BIP-0070?
>>
>> Performance doesn't feel that relevant when you think that:
>> 1. Payment requests are not broadcast, this is a request / response flow,
>> much more akin to a web request.
>> 2. One would be cramming this data into a binary format just so you can
>> then attach it to a no-so-binary format such as HTTP.
>>
>> Some great things about protocols/encodings such as HTTP/JSON/XML are:
>> 1. They are human readable on-the-wire. No Wireshark plugin required,
>> tcpdump or ngrep will do.
>> 2. There are tons of great open source libraries and API for parsing /
>> manipulating / generating.
>> 3. It's really easy to hand-craft a test message for debugging.
>> 4. The standards are much easier to read and write. They don't need to
>> contain code like BIP-0070 currently does and they can contain examples,
>> which BIP70 does not.
>> 5. They are thoroughly specified by independent standards bodies such as
>> the IETF. Gotta love a bit of MUST / SHOULD / MAY in a standard.
>> 6. They're a family ;-)
>>
>> Keen to hear your thoughts on this and very keen to watch the payment
>> protocol grow regardless of encoding choice! My background is SIP / VoIP
>> and I think that could be a fascinating use case for this protocol which
>> I'm hoping to do some work on.
>>
>> Best,
>> Richard
>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/edf3572c/attachment.html>

From bip at mattwhitlock.name  Mon Jan 19 19:19:50 2015
From: bip at mattwhitlock.name (Matt Whitlock)
Date: Mon, 19 Jan 2015 14:19:50 -0500
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <CAN5esQJe0uUm0NyctaBa6WH7_JjeE_OLR=FY_XQWnSr50VRDyA@mail.gmail.com>
References: <CAN5esQJe0uUm0NyctaBa6WH7_JjeE_OLR=FY_XQWnSr50VRDyA@mail.gmail.com>
Message-ID: <2109963.TWzmcrtnFv@crushinator>

Even if a compact binary encoding is a high priority, there are more "standard" choices than Google Protocol Buffers. For example, ASN.1 is a very rigorously defined standard that has been around for decades, and ASN.1 even has an XML encoding (XER) that is directly convertible to/from the binary encoding (BER/DER), given the schema. In practice, I'm mostly agnostic about what encoding is actually used in BIP70, and I wouldn't fault BIP70 for choosing Google Protocol Buffers, but the very existence of Protobuf perplexes me, as it apparently re-solves a problem that was solved 40 years ago by ASN.1. It's as though the engineers at Google weren't aware that ASN.1 existed.


On Monday, 19 January 2015, at 7:07 pm, Richard Brady wrote:
> Hi Gavin, Mike and co
> 
> Is there a strong driver behind the choice of Google Protocol Buffers for
> payment request encoding in BIP-0070?
> 
> Performance doesn't feel that relevant when you think that:
> 1. Payment requests are not broadcast, this is a request / response flow,
> much more akin to a web request.
> 2. One would be cramming this data into a binary format just so you can
> then attach it to a no-so-binary format such as HTTP.
> 
> Some great things about protocols/encodings such as HTTP/JSON/XML are:
> 1. They are human readable on-the-wire. No Wireshark plugin required,
> tcpdump or ngrep will do.
> 2. There are tons of great open source libraries and API for parsing /
> manipulating / generating.
> 3. It's really easy to hand-craft a test message for debugging.
> 4. The standards are much easier to read and write. They don't need to
> contain code like BIP-0070 currently does and they can contain examples,
> which BIP70 does not.
> 5. They are thoroughly specified by independent standards bodies such as
> the IETF. Gotta love a bit of MUST / SHOULD / MAY in a standard.
> 6. They're a family ;-)
> 
> Keen to hear your thoughts on this and very keen to watch the payment
> protocol grow regardless of encoding choice! My background is SIP / VoIP
> and I think that could be a fascinating use case for this protocol which
> I'm hoping to do some work on.
> 
> Best,
> Richard



From jgarzik at bitpay.com  Mon Jan 19 19:09:13 2015
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Mon, 19 Jan 2015 14:09:13 -0500
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <CAN5esQJe0uUm0NyctaBa6WH7_JjeE_OLR=FY_XQWnSr50VRDyA@mail.gmail.com>
References: <CAN5esQJe0uUm0NyctaBa6WH7_JjeE_OLR=FY_XQWnSr50VRDyA@mail.gmail.com>
Message-ID: <CAJHLa0OTynX4oiQoyanpRKE2tpAuS4L5X-2j20328725J9RrvQ@mail.gmail.com>

Text formats such as XML or JSON are far less deterministic, are more
loosely specified, have wide variance in parsing, are not very hash-able,
the list goes on.


On Mon, Jan 19, 2015 at 2:07 PM, Richard Brady <rnbrady at gmail.com> wrote:

> Hi Gavin, Mike and co
>
> Is there a strong driver behind the choice of Google Protocol Buffers for
> payment request encoding in BIP-0070?
>
> Performance doesn't feel that relevant when you think that:
> 1. Payment requests are not broadcast, this is a request / response flow,
> much more akin to a web request.
> 2. One would be cramming this data into a binary format just so you can
> then attach it to a no-so-binary format such as HTTP.
>
> Some great things about protocols/encodings such as HTTP/JSON/XML are:
> 1. They are human readable on-the-wire. No Wireshark plugin required,
> tcpdump or ngrep will do.
> 2. There are tons of great open source libraries and API for parsing /
> manipulating / generating.
> 3. It's really easy to hand-craft a test message for debugging.
> 4. The standards are much easier to read and write. They don't need to
> contain code like BIP-0070 currently does and they can contain examples,
> which BIP70 does not.
> 5. They are thoroughly specified by independent standards bodies such as
> the IETF. Gotta love a bit of MUST / SHOULD / MAY in a standard.
> 6. They're a family ;-)
>
> Keen to hear your thoughts on this and very keen to watch the payment
> protocol grow regardless of encoding choice! My background is SIP / VoIP
> and I think that could be a fascinating use case for this protocol which
> I'm hoping to do some work on.
>
> Best,
> Richard
>
>
>
> ------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> http://p.sf.net/sfu/gigenet
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>


-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/2046cd15/attachment.html>

From jgarzik at bitpay.com  Mon Jan 19 19:34:18 2015
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Mon, 19 Jan 2015 14:34:18 -0500
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <CAN5esQJK4UnkQC=y6aT15txFekpptv32+5n4CbyR=6G6J7HF4A@mail.gmail.com>
References: <CAN5esQJe0uUm0NyctaBa6WH7_JjeE_OLR=FY_XQWnSr50VRDyA@mail.gmail.com>
	<CAJHLa0OTynX4oiQoyanpRKE2tpAuS4L5X-2j20328725J9RrvQ@mail.gmail.com>
	<CAN5esQJK4UnkQC=y6aT15txFekpptv32+5n4CbyR=6G6J7HF4A@mail.gmail.com>
Message-ID: <CAJHLa0MCv8kCZLJ2PkBdkDuPZBv4GTosYq-sfqjgri=bG65AMw@mail.gmail.com>

None of those listed were in the context of performance.  Parsing of binary
or text is quite fast these days, and is not really a consideration versus
other needs such as a predictable encoding for a single data
representation.  XML and JSON both can represent the same post-evaluation
user data a million different ways, which is awful for anything you are
signing and hashing.  Text formats also transit binary data very poorly,
leading to unnecessary wrapping and unwrappiing (a programmatic, visibility
& bug; again performance not a primary concern).

This is evident because both XML and JSON have standards efforts under way
to correct some of these problems and make them more deterministic.
However, such standards are not field deployed and widely supported by
parsers and generators alike.




On Mon, Jan 19, 2015 at 2:16 PM, Richard Brady <rnbrady at gmail.com> wrote:

> Fair points, although for me the line is blurred between which of those
> are security considerations vs performance considerations.
>
> Richard
>
> On 19 January 2015 at 19:09, Jeff Garzik <jgarzik at bitpay.com> wrote:
>
>> Text formats such as XML or JSON are far less deterministic, are more
>> loosely specified, have wide variance in parsing, are not very hash-able,
>> the list goes on.
>>
>>
>> On Mon, Jan 19, 2015 at 2:07 PM, Richard Brady <rnbrady at gmail.com> wrote:
>>
>>> Hi Gavin, Mike and co
>>>
>>> Is there a strong driver behind the choice of Google Protocol Buffers
>>> for payment request encoding in BIP-0070?
>>>
>>> Performance doesn't feel that relevant when you think that:
>>> 1. Payment requests are not broadcast, this is a request / response
>>> flow, much more akin to a web request.
>>> 2. One would be cramming this data into a binary format just so you can
>>> then attach it to a no-so-binary format such as HTTP.
>>>
>>> Some great things about protocols/encodings such as HTTP/JSON/XML are:
>>> 1. They are human readable on-the-wire. No Wireshark plugin required,
>>> tcpdump or ngrep will do.
>>> 2. There are tons of great open source libraries and API for parsing /
>>> manipulating / generating.
>>> 3. It's really easy to hand-craft a test message for debugging.
>>> 4. The standards are much easier to read and write. They don't need to
>>> contain code like BIP-0070 currently does and they can contain examples,
>>> which BIP70 does not.
>>> 5. They are thoroughly specified by independent standards bodies such as
>>> the IETF. Gotta love a bit of MUST / SHOULD / MAY in a standard.
>>> 6. They're a family ;-)
>>>
>>> Keen to hear your thoughts on this and very keen to watch the payment
>>> protocol grow regardless of encoding choice! My background is SIP / VoIP
>>> and I think that could be a fascinating use case for this protocol which
>>> I'm hoping to do some work on.
>>>
>>> Best,
>>> Richard
>>>
>>>


-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/eb614bf2/attachment.html>

From mike at plan99.net  Mon Jan 19 19:37:22 2015
From: mike at plan99.net (Mike Hearn)
Date: Mon, 19 Jan 2015 20:37:22 +0100
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <2109963.TWzmcrtnFv@crushinator>
References: <CAN5esQJe0uUm0NyctaBa6WH7_JjeE_OLR=FY_XQWnSr50VRDyA@mail.gmail.com>
	<2109963.TWzmcrtnFv@crushinator>
Message-ID: <CANEZrP0C__aC8Y643j0oy+mnYB7KqGA8Ry04R5NEqbbkuPxchw@mail.gmail.com>

The engineers at Google were well aware that ASN.1 existed. I can assure
you of that, because I was one of them.

The protobuf FAQ has a very polite take on the matter:

   https://developers.google.com/protocol-buffers/docs/faq

This email thread gives more enlightenment:

   https://groups.google.com/forum/#!topic/protobuf/eNAZlnPKVW4

Anyone who has actually had to work with both ASN.1 and protocol buffers
will be able to explain why ASN.1 should not be chosen for any modern
formats. A lot of it boils down to simplicty and quality of
implementations, especially open source implementations.

With respect to the specific concerns Richard raises:

Performance doesn't feel that relevant when you think that:
>

Performance wasn't a concern.


> 2. One would be cramming this data into a binary format just so you can
> then attach it to a no-so-binary format such as HTTP.
>

HTTP transmits files as binary on the wire. So it's binary-clean and,
moreover, HTTP/2 aka SPDY is fully binary and doesn't use text anywhere
except the gzip dictionary.


> 2. There are tons of great open source libraries and API for parsing /
> manipulating / generating.
>

Luckily, this is also true of protocol buffers. Language support is pretty
good these days.


> 4. The standards are much easier to read and write. They don't need to
> contain code like BIP-0070 currently does and they can contain examples,
> which BIP70 does not.
>

BIP 70 doesn't contain any code, as far as I know. The protobuf schema
might look like code, but it's not - it's just a description of what fields
a message can contain and their types. This is very relevant for a
specification!

JSON in particular is pretty awful and I don't like it much. It suffers
complexities with things as basic as encoding numbers and strings. It's
very much unsuited to applications where correctness matters and where
you're dealing with binary structures.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/e6a76662/attachment.html>

From jgarzik at bitpay.com  Mon Jan 19 19:38:23 2015
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Mon, 19 Jan 2015 14:38:23 -0500
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <2109963.TWzmcrtnFv@crushinator>
References: <CAN5esQJe0uUm0NyctaBa6WH7_JjeE_OLR=FY_XQWnSr50VRDyA@mail.gmail.com>
	<2109963.TWzmcrtnFv@crushinator>
Message-ID: <CAJHLa0NVt_X--pOu_ZNPeY+tT6UJDNdNJqiK9k6g4FTY6Z8B3A@mail.gmail.com>

ASN.1 is not nearly as flexible when it comes to well-supported libraries,
generators, and the ecosystem that surrounds the actual encoding.  You
don't see ASN.1 compilers + language support packages for [all popular
programming languages], as you do with protobufs.

Google engineers were well aware it existed I'm sure.  There are wider
considerations beyond the low-level specified format.

Protobufs have their problems and aren't perfect, but ASN.1 ecosystem is
far less developed in the programming ecosystem, far less approachable for
programmers.  BIP70 wouldn't have been as easily and widely adopted if
ASN.1 had been chosen.




On Mon, Jan 19, 2015 at 2:19 PM, Matt Whitlock <bip at mattwhitlock.name>
wrote:

> Even if a compact binary encoding is a high priority, there are more
> "standard" choices than Google Protocol Buffers. For example, ASN.1 is a
> very rigorously defined standard that has been around for decades, and
> ASN.1 even has an XML encoding (XER) that is directly convertible to/from
> the binary encoding (BER/DER), given the schema. In practice, I'm mostly
> agnostic about what encoding is actually used in BIP70, and I wouldn't
> fault BIP70 for choosing Google Protocol Buffers, but the very existence of
> Protobuf perplexes me, as it apparently re-solves a problem that was solved
> 40 years ago by ASN.1. It's as though the engineers at Google weren't aware
> that ASN.1 existed.
>
>
> On Monday, 19 January 2015, at 7:07 pm, Richard Brady wrote:
> > Hi Gavin, Mike and co
> >
> > Is there a strong driver behind the choice of Google Protocol Buffers for
> > payment request encoding in BIP-0070?
> >
> > Performance doesn't feel that relevant when you think that:
> > 1. Payment requests are not broadcast, this is a request / response flow,
> > much more akin to a web request.
> > 2. One would be cramming this data into a binary format just so you can
> > then attach it to a no-so-binary format such as HTTP.
> >
> > Some great things about protocols/encodings such as HTTP/JSON/XML are:
> > 1. They are human readable on-the-wire. No Wireshark plugin required,
> > tcpdump or ngrep will do.
> > 2. There are tons of great open source libraries and API for parsing /
> > manipulating / generating.
> > 3. It's really easy to hand-craft a test message for debugging.
> > 4. The standards are much easier to read and write. They don't need to
> > contain code like BIP-0070 currently does and they can contain examples,
> > which BIP70 does not.
> > 5. They are thoroughly specified by independent standards bodies such as
> > the IETF. Gotta love a bit of MUST / SHOULD / MAY in a standard.
> > 6. They're a family ;-)
> >
> > Keen to hear your thoughts on this and very keen to watch the payment
> > protocol grow regardless of encoding choice! My background is SIP / VoIP
> > and I think that could be a fascinating use case for this protocol which
> > I'm hoping to do some work on.
> >
> > Best,
> > Richard
>
>
> ------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> http://p.sf.net/sfu/gigenet
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/439ccfd3/attachment.html>

From pete at petertodd.org  Mon Jan 19 19:48:26 2015
From: pete at petertodd.org (Peter Todd)
Date: Mon, 19 Jan 2015 12:48:26 -0700
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers
	for	encoding?
In-Reply-To: <CAJHLa0OTynX4oiQoyanpRKE2tpAuS4L5X-2j20328725J9RrvQ@mail.gmail.com>
References: <CAN5esQJe0uUm0NyctaBa6WH7_JjeE_OLR=FY_XQWnSr50VRDyA@mail.gmail.com>
	<CAJHLa0OTynX4oiQoyanpRKE2tpAuS4L5X-2j20328725J9RrvQ@mail.gmail.com>
Message-ID: <2C7D6208-1921-4DDC-90FE-DB1ABE1D61DB@petertodd.org>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256



On 19 January 2015 12:09:13 GMT-07:00, Jeff Garzik <jgarzik at bitpay.com> wrote:
>Text formats such as XML or JSON are far less deterministic, are more
>loosely specified, have wide variance in parsing, are not very
>hash-able,
>the list goes on.

Protocol buffers isn't any more hashable than XML or json - round trips aren't deterministic with standard protobuf libraries. To make it deterministic you end up creating a new standard.

I have this problem for an asset representation standard for one of my clients, and I've reluctantly had to roll my own format.
-----BEGIN PGP SIGNATURE-----
Version: APG v1.1.1

iQFQBAEBCAA6BQJUvV+KMxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8
cGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhRwcCACNkpkkjIh8Zv5I8bOy
BpM2Tc5hVpg4KY6eKRXYLYgxoEnekDXN1/LJ5bfl+xzJTMTdt4f7YF0EjFJSIJ0C
UpR9KbEVShmt7UsoNwwAFxtMQmZe84vANGG11NI/cb95GO2TOlxYtPMFizQrp80s
ULAelID3Pd8yPeadU/yrF+daz9I8UHqOyioL0piWUT+kshuzqQNclHQaPKWoOPbW
XF4w1SAJjb1tHmkHqCY1HRvwlv8fqxXgjtEyjkz/HK70ZzOI+8aR49aigx2njwyL
F8EJ1gO3XkivRidTRKfbSloeq96TRneXXXfmyB6p8jI3O3BRkrk9x465EWMnzYu7
uJqo
=N1G+
-----END PGP SIGNATURE-----




From rnbrady at gmail.com  Mon Jan 19 19:57:47 2015
From: rnbrady at gmail.com (Richard Brady)
Date: Mon, 19 Jan 2015 19:57:47 +0000
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <2C7D6208-1921-4DDC-90FE-DB1ABE1D61DB@petertodd.org>
References: <CAN5esQJe0uUm0NyctaBa6WH7_JjeE_OLR=FY_XQWnSr50VRDyA@mail.gmail.com>
	<CAJHLa0OTynX4oiQoyanpRKE2tpAuS4L5X-2j20328725J9RrvQ@mail.gmail.com>
	<2C7D6208-1921-4DDC-90FE-DB1ABE1D61DB@petertodd.org>
Message-ID: <CAN5esQLCV=L0kYxDGhK2F=qZ8OqMxyYS+-Pn17U_M+nV4Sj3Og@mail.gmail.com>

Thanks guys, great answers.

The design choice certainly makes a lot more sense now regardless of
whether one agrees with it or not.

Regards,
Richard
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/3e66c433/attachment.html>

From etotheipi at gmail.com  Mon Jan 19 20:03:32 2015
From: etotheipi at gmail.com (Alan Reiner)
Date: Mon, 19 Jan 2015 15:03:32 -0500
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
 encoding?
In-Reply-To: <CAN5esQLCV=L0kYxDGhK2F=qZ8OqMxyYS+-Pn17U_M+nV4Sj3Og@mail.gmail.com>
References: <CAN5esQJe0uUm0NyctaBa6WH7_JjeE_OLR=FY_XQWnSr50VRDyA@mail.gmail.com>	<CAJHLa0OTynX4oiQoyanpRKE2tpAuS4L5X-2j20328725J9RrvQ@mail.gmail.com>	<2C7D6208-1921-4DDC-90FE-DB1ABE1D61DB@petertodd.org>
	<CAN5esQLCV=L0kYxDGhK2F=qZ8OqMxyYS+-Pn17U_M+nV4Sj3Og@mail.gmail.com>
Message-ID: <54BD6314.60607@gmail.com>

I'm a bit confused.  It's been a long time since I looked at protobuf
(and will have to dig into it soon), but I seem to recall it doesn't
have any of the determinism properties you guys just said.  It is
intended to allow you to skip details of the on-the-wire representations
and just send a bunch of named fields between systems.  I thought there
was no guarantee that two identical protobuf structures will get
serialized identically...?




On 01/19/2015 02:57 PM, Richard Brady wrote:
> Thanks guys, great answers. 
>
> The design choice certainly makes a lot more sense now regardless of
> whether one agrees with it or not.
>
> Regards,
> Richard
>
>
>
> ------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> http://p.sf.net/sfu/gigenet
>
>
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/c6c82c2c/attachment.html>

From pete at petertodd.org  Mon Jan 19 20:06:38 2015
From: pete at petertodd.org (Peter Todd)
Date: Mon, 19 Jan 2015 13:06:38 -0700
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <54BD6314.60607@gmail.com>
References: <CAN5esQJe0uUm0NyctaBa6WH7_JjeE_OLR=FY_XQWnSr50VRDyA@mail.gmail.com>
	<CAJHLa0OTynX4oiQoyanpRKE2tpAuS4L5X-2j20328725J9RrvQ@mail.gmail.com>
	<2C7D6208-1921-4DDC-90FE-DB1ABE1D61DB@petertodd.org>
	<CAN5esQLCV=L0kYxDGhK2F=qZ8OqMxyYS+-Pn17U_M+nV4Sj3Og@mail.gmail.com>
	<54BD6314.60607@gmail.com>
Message-ID: <36AE6BD8-D329-46D3-9C11-232C6B1D1CBF@petertodd.org>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

That's 100% true: BIP70 passes around serialized protobuf data that it signs directly for this reason; it could just as easily be a byte array with json in it. (not that json/XML/etc. doesn't have other flaws)


On 19 January 2015 13:03:32 GMT-07:00, Alan Reiner <etotheipi at gmail.com> wrote:
>I'm a bit confused.  It's been a long time since I looked at protobuf
>(and will have to dig into it soon), but I seem to recall it doesn't
>have any of the determinism properties you guys just said.  It is
>intended to allow you to skip details of the on-the-wire
>representations
>and just send a bunch of named fields between systems.  I thought there
>was no guarantee that two identical protobuf structures will get
>serialized identically...?
>
>
>
>
>On 01/19/2015 02:57 PM, Richard Brady wrote:
>> Thanks guys, great answers.
>>
>> The design choice certainly makes a lot more sense now regardless of
>> whether one agrees with it or not.
>>
>> Regards,
>> Richard
>>
>>
>>
>>
>------------------------------------------------------------------------------
>> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
>> GigeNET is offering a free month of service with a new server in
>Ashburn.
>> Choose from 2 high performing configs, both with 100TB of bandwidth.
>> Higher redundancy.Lower latency.Increased capacity.Completely
>compliant.
>> http://p.sf.net/sfu/gigenet
>>
>>
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
>
>------------------------------------------------------------------------
>
>------------------------------------------------------------------------------
>New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
>GigeNET is offering a free month of service with a new server in
>Ashburn.
>Choose from 2 high performing configs, both with 100TB of bandwidth.
>Higher redundancy.Lower latency.Increased capacity.Completely
>compliant.
>http://p.sf.net/sfu/gigenet
>
>------------------------------------------------------------------------
>
>_______________________________________________
>Bitcoin-development mailing list
>Bitcoin-development at lists.sourceforge.net
>https://lists.sourceforge.net/lists/listinfo/bitcoin-development
-----BEGIN PGP SIGNATURE-----
Version: APG v1.1.1

iQFQBAEBCAA6BQJUvWPOMxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8
cGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhbq4CACAptz1s1rYdQtviI5Y
UrqoifRAldRlUaOphle5OKCK+Gus0zqhqm/kiaQtbCg39F1gZ43QrJ/+t9kjZ19l
QcrtnIEffAyBdzCXiZH7N9HwGalxBRyiUcKc5iZT2DOYw4rwdJvYXB/PdlPOvGkq
rx/q93r2dJSFMFonnmM9pzbvUKS6dLrAWUTJCWH9EVK54TxBjVkoPXuZJEGBHr88
6MMTiRu1+KblxZbOozGRIXmrfd/7+akM6jLMU9FO4BwosUitOc9OWznGS1rvumlQ
5ESTzaiM9TpBLIW3rkJZmqA51Z1lbgVxXFA4HbctyQeMKIZxNn8e+RpWGYdpCblc
wfd6
=GYj6
-----END PGP SIGNATURE-----




From mike at plan99.net  Mon Jan 19 20:40:13 2015
From: mike at plan99.net (Mike Hearn)
Date: Mon, 19 Jan 2015 21:40:13 +0100
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <54BD6314.60607@gmail.com>
References: <CAN5esQJe0uUm0NyctaBa6WH7_JjeE_OLR=FY_XQWnSr50VRDyA@mail.gmail.com>
	<CAJHLa0OTynX4oiQoyanpRKE2tpAuS4L5X-2j20328725J9RrvQ@mail.gmail.com>
	<2C7D6208-1921-4DDC-90FE-DB1ABE1D61DB@petertodd.org>
	<CAN5esQLCV=L0kYxDGhK2F=qZ8OqMxyYS+-Pn17U_M+nV4Sj3Og@mail.gmail.com>
	<54BD6314.60607@gmail.com>
Message-ID: <CANEZrP3ZdFcQsP+EWgTYQDccFZbrZFTk+xi-YdWPCJzMRH79pA@mail.gmail.com>

>
> I'm a bit confused.  It's been a long time since I looked at protobuf (and
> will have to dig into it soon), but I seem to recall it doesn't have any of
> the determinism properties you guys just said.
>

It's not guaranteed no, which is why we store signed sub-messages as byte
arrays instead of typed submessages. In practice though, most
implementations do seem to serialise things the same way. I recall Python
used to be an odd one out, unsure if it still is.

OK, I guess we can boil this down more simply. BIP 70 uses protocol buffers
because I designed it and implemented the original prototype (with lots of
input from Gavin and an earlier proposal by sipa). I used protocol buffers
because, beyond all their nice properties, I used to work at Google and so
was very familiar with them.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/bbd8b7d4/attachment.html>

From gavin at bitcoinfoundation.org  Mon Jan 19 20:56:37 2015
From: gavin at bitcoinfoundation.org (Gavin Andresen)
Date: Mon, 19 Jan 2015 15:56:37 -0500
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <CANEZrP3ZdFcQsP+EWgTYQDccFZbrZFTk+xi-YdWPCJzMRH79pA@mail.gmail.com>
References: <CAN5esQJe0uUm0NyctaBa6WH7_JjeE_OLR=FY_XQWnSr50VRDyA@mail.gmail.com>
	<CAJHLa0OTynX4oiQoyanpRKE2tpAuS4L5X-2j20328725J9RrvQ@mail.gmail.com>
	<2C7D6208-1921-4DDC-90FE-DB1ABE1D61DB@petertodd.org>
	<CAN5esQLCV=L0kYxDGhK2F=qZ8OqMxyYS+-Pn17U_M+nV4Sj3Og@mail.gmail.com>
	<54BD6314.60607@gmail.com>
	<CANEZrP3ZdFcQsP+EWgTYQDccFZbrZFTk+xi-YdWPCJzMRH79pA@mail.gmail.com>
Message-ID: <CABsx9T1hwCky7s6kza00_RuueaVbNB++ZuHY3j00iwJTN6tCyA@mail.gmail.com>

On Mon, Jan 19, 2015 at 3:40 PM, Mike Hearn <mike at plan99.net> wrote:

> OK, I guess we can boil this down more simply. BIP 70 uses protocol
>> buffers because I designed it and implemented the original prototype (with
>> lots of input from Gavin and an earlier proposal by sipa). I used protocol
>> buffers because, beyond all their nice properties, I used to work at Google
>> and so was very familiar with them.
>>
>
What Mike said. Runner-up for encoding was JSON.

XML+ASN.1 was Right Out, because lots of us hate XML and ASN.1 with a
burning passion. Complexity is the Enemy of Security, and both XML and
ASN.1 are too complex.


-- 
--
Gavin Andresen
Chief Scientist, Bitcoin Foundation
https://www.bitcoinfoundation.org/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/e1a3fb5a/attachment.html>

From jrn at jrn.me.uk  Mon Jan 19 20:59:16 2015
From: jrn at jrn.me.uk (Ross Nicoll)
Date: Mon, 19 Jan 2015 20:59:16 +0000
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
 encoding?
In-Reply-To: <CANEZrP3ZdFcQsP+EWgTYQDccFZbrZFTk+xi-YdWPCJzMRH79pA@mail.gmail.com>
References: <CAN5esQJe0uUm0NyctaBa6WH7_JjeE_OLR=FY_XQWnSr50VRDyA@mail.gmail.com>	<CAJHLa0OTynX4oiQoyanpRKE2tpAuS4L5X-2j20328725J9RrvQ@mail.gmail.com>	<2C7D6208-1921-4DDC-90FE-DB1ABE1D61DB@petertodd.org>	<CAN5esQLCV=L0kYxDGhK2F=qZ8OqMxyYS+-Pn17U_M+nV4Sj3Og@mail.gmail.com>	<54BD6314.60607@gmail.com>
	<CANEZrP3ZdFcQsP+EWgTYQDccFZbrZFTk+xi-YdWPCJzMRH79pA@mail.gmail.com>
Message-ID: <54BD7024.5070008@jrn.me.uk>

For what it's worth, there was consideration of replacing protocol
buffers when modifying BIP70 to function with the altcoin I work on
(changes were required anyway in eliminate any risk that payment
requests could not be accidentally applied to the wrong blockchain). The
eventual conclusion was that while we might have used JSON or XML if we
were starting from scratch, there's no choice that's clearly better.
While deployed infrastructure for payment protocol is still quite
limited, it seems that the cost to replace at this point is higher than not.

If there's ever a major reworking of the standard, for example to handle
recurring payments, it's probably worth thinking about then, but
protocol buffers result in a compact data format which is supported by
most major languages (and size is a concern if dealing with Bluetooth or
NFC), and has no major drawbacks I am aware of.

Ross

On 19/01/2015 20:40, Mike Hearn wrote:
>> I'm a bit confused.  It's been a long time since I looked at protobuf (and
>> will have to dig into it soon), but I seem to recall it doesn't have any of
>> the determinism properties you guys just said.
>>
> It's not guaranteed no, which is why we store signed sub-messages as byte
> arrays instead of typed submessages. In practice though, most
> implementations do seem to serialise things the same way. I recall Python
> used to be an odd one out, unsure if it still is.
>
> OK, I guess we can boil this down more simply. BIP 70 uses protocol buffers
> because I designed it and implemented the original prototype (with lots of
> input from Gavin and an earlier proposal by sipa). I used protocol buffers
> because, beyond all their nice properties, I used to work at Google and so
> was very familiar with them.
>
>
>
> ------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> http://p.sf.net/sfu/gigenet
>
>
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/c508d0e9/attachment.html>

From jgarzik at bitpay.com  Mon Jan 19 21:21:54 2015
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Mon, 19 Jan 2015 16:21:54 -0500
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <54BD6314.60607@gmail.com>
References: <CAN5esQJe0uUm0NyctaBa6WH7_JjeE_OLR=FY_XQWnSr50VRDyA@mail.gmail.com>
	<CAJHLa0OTynX4oiQoyanpRKE2tpAuS4L5X-2j20328725J9RrvQ@mail.gmail.com>
	<2C7D6208-1921-4DDC-90FE-DB1ABE1D61DB@petertodd.org>
	<CAN5esQLCV=L0kYxDGhK2F=qZ8OqMxyYS+-Pn17U_M+nV4Sj3Og@mail.gmail.com>
	<54BD6314.60607@gmail.com>
Message-ID: <CAJHLa0NA357Fa2CjBPopKvDs1T0FFOsPjnizsVWPNWX46LfgyA@mail.gmail.com>

Correct.  I should have said "more likely to be deterministic"  Bitcoin
Core does not *rely* on determinism in BIP70; I was referring to recent
upstream efforts to make protobufs usable in a deterministic fashion by
default.

On Mon, Jan 19, 2015 at 3:03 PM, Alan Reiner <etotheipi at gmail.com> wrote:

>  I'm a bit confused.  It's been a long time since I looked at protobuf
> (and will have to dig into it soon), but I seem to recall it doesn't have
> any of the determinism properties you guys just said.  It is intended to
> allow you to skip details of the on-the-wire representations and just send
> a bunch of named fields between systems.  I thought there was no guarantee
> that two identical protobuf structures will get serialized identically...?
>
>
>
>
>
> On 01/19/2015 02:57 PM, Richard Brady wrote:
>
>   Thanks guys, great answers.
>
>  The design choice certainly makes a lot more sense now regardless of
> whether one agrees with it or not.
>
>  Regards,
> Richard
>
>
>
> ------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.http://p.sf.net/sfu/gigenet
>
>
>
> _______________________________________________
> Bitcoin-development mailing listBitcoin-development at lists.sourceforge.nethttps://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
>
>
> ------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> http://p.sf.net/sfu/gigenet
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>


-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/5f969ba7/attachment.html>

From brianchoffman at gmail.com  Mon Jan 19 21:22:49 2015
From: brianchoffman at gmail.com (Brian Hoffman)
Date: Mon, 19 Jan 2015 16:22:49 -0500
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <CABsx9T1hwCky7s6kza00_RuueaVbNB++ZuHY3j00iwJTN6tCyA@mail.gmail.com>
References: <CAN5esQJe0uUm0NyctaBa6WH7_JjeE_OLR=FY_XQWnSr50VRDyA@mail.gmail.com>
	<CAJHLa0OTynX4oiQoyanpRKE2tpAuS4L5X-2j20328725J9RrvQ@mail.gmail.com>
	<2C7D6208-1921-4DDC-90FE-DB1ABE1D61DB@petertodd.org>
	<CAN5esQLCV=L0kYxDGhK2F=qZ8OqMxyYS+-Pn17U_M+nV4Sj3Og@mail.gmail.com>
	<54BD6314.60607@gmail.com>
	<CANEZrP3ZdFcQsP+EWgTYQDccFZbrZFTk+xi-YdWPCJzMRH79pA@mail.gmail.com>
	<CABsx9T1hwCky7s6kza00_RuueaVbNB++ZuHY3j00iwJTN6tCyA@mail.gmail.com>
Message-ID: <DBC5EDDB-4920-492F-8625-F4E00273832A@gmail.com>

Damn if SPKI had won out we would be parsing S-expressions instead of X.509 certificates. ASN.1 is not fun IMHO.


> On Jan 19, 2015, at 3:56 PM, Gavin Andresen <gavin at bitcoinfoundation.org> wrote:
> 
> On Mon, Jan 19, 2015 at 3:40 PM, Mike Hearn <mike at plan99.net> wrote:
>>> OK, I guess we can boil this down more simply. BIP 70 uses protocol buffers because I designed it and implemented the original prototype (with lots of input from Gavin and an earlier proposal by sipa). I used protocol buffers because, beyond all their nice properties, I used to work at Google and so was very familiar with them.
> 
> 
> What Mike said. Runner-up for encoding was JSON.
> 
> XML+ASN.1 was Right Out, because lots of us hate XML and ASN.1 with a burning passion. Complexity is the Enemy of Security, and both XML and ASN.1 are too complex.
> 
> 
> -- 
> --
> Gavin Andresen
> Chief Scientist, Bitcoin Foundation
> https://www.bitcoinfoundation.org/
> 
> ------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> http://p.sf.net/sfu/gigenet
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150119/ea970d31/attachment.html>

From pete at petertodd.org  Tue Jan 20 15:46:41 2015
From: pete at petertodd.org (Peter Todd)
Date: Tue, 20 Jan 2015 10:46:41 -0500
Subject: [Bitcoin-development] The legal risks of auto-updating wallet
 software; custodial relationships
Message-ID: <20150120154641.GA32556@muck>

I was talking to a lawyer with a background in finance law the other day
and we came to a somewhat worrying conclusion: authors of Bitcoin wallet
software probably have a custodial relationship with their users,
especially if they use auto-update mechanisms. Unfortunately this has
potential legal implications as custodial relationships tend to be
pretty highly regulated.

Why is this? Well, in most jurisdictions financial laws a custodial
relationship is defined as having the ability, but not the right, to
dispose of an asset. If you have the private keys for your users'
bitcoins - e.g. an exchange or "online" wallet - you clearly have the
ability to spend those bitcoins, thus you have a custodial relationship.
However if you can trivially obtain those private keys you can also
argue you have a custodial relationship. For instance StrongCoin was
able to seize funds stolen from OzCoin? with a small change to the
client-side Javascript their users download from them every time they
visit the site. Portraying that as "the ability to dispose of an asset"
in a court of law would be pretty easy. Equally on a technical level
this isn't much different from how auto-updating software works.

Now I'm sure people in this audience will immediately point out that by
that logic your OS vendor is also in a custodial relationship - they
after all can push an update that steals everyones' bitcoins regardless
of what local wallet you use. But the law isn't a deterministic
algorithm, it's a political process. Circle is easy to portray as having
a custodial relationship, StrongCoin and Blockchain.info are a little
harder, Android Wallet harder still, Bitcoin Core's multi-party
deterministicly compiled releases even harder.

But ultimately we're not going to know until court cases start
happening. In the meantime probably the best advice - other than getting
out of the wallet business! - is to do everything you can to prevent
losses through malicious auto-updates. Create systems where as many
people as possible have to sign off and review an update before it has
the opportunity to spend user funds. Not having auto-updates at all is a
(legally) safe way to achieve that goal; if you do have them make sure
the process by which an update happens is controlled by more than one
person and there are mechanisms in place to create good audit logs of
how exactly an update happened.

Finally keep in mind that one of the consequences of a custodial
relationship is that some legal authority might try to *force* you to
seize user funds. StrongCoin made it 100% clear to authorities that they
and sites like them are able to seize funds at will - I won't be
surprised if authorities use that power in the future. The more
automatic and less transparent an update is, the higher the chance some
authority will lean on you to seize funds. So don't make it easy for
yourself to meet those demands.

1) https://bitcoinmagazine.com/4273/ozcoin-hacked-stolen-funds-seized-and-returned-by-strongcoin/

-- 
'peter'[:-1]@petertodd.org
00000000000000001a5e1dc75b28e8445c6e8a5c35c76637e33a3e96d487b74c
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/7cff1133/attachment.sig>

From pete at petertodd.org  Tue Jan 20 17:15:57 2015
From: pete at petertodd.org (Peter Todd)
Date: Tue, 20 Jan 2015 12:15:57 -0500
Subject: [Bitcoin-development] The legal risks of auto-updating wallet
 software; custodial relationships
In-Reply-To: <CAHpxFbEoDLMGKB7arHbgB+4kx8BwgcX7nBUZz6yP9k4LjZeu1A@mail.gmail.com>
References: <20150120154641.GA32556@muck>
	<CAHpxFbEoDLMGKB7arHbgB+4kx8BwgcX7nBUZz6yP9k4LjZeu1A@mail.gmail.com>
Message-ID: <20150120171557.GA29353@muck>

On Tue, Jan 20, 2015 at 08:43:57AM -0800, Daniel Stadulis wrote:
> Hey Peter,
> 
> What would you say to the argument: given developers have auto update
> capabilities they only have the ability to *give themselves* *the ability* to
> have custodial rights?

Heh, well, courts tend not to have the narrow-minded pedantic logic that
programmers do; quite likely that they'd see having the ability to give
themselves the ability as equivalent to simply having the ability. What
matters more is intent: the authors of an operating system had no intent
to have a custodial relationship over anyones' BTC, so they'd be off the
hook. The authors of a Bitcoin wallet on the other hand, depends on how
you go about it.

For instance Lighthouse has something called UpdateFX, which allows for
multi-signature updates. It also supports deterministic builds, and
allows users to chose whether or not they'll follow new updates
automatically, or only update on demand. In a court that could be all
brought up as examples of intent *not* to have a custodial relationship,
which may be enough to sway judge/jury, and certainly will help avoid
ending up in court in the first place by virtue of the fact that all
those protections help avoid theft, and increase the # of people that an
authority need to involve to seize funds via an update.

-- 
'peter'[:-1]@petertodd.org
00000000000000001a5e1dc75b28e8445c6e8a5c35c76637e33a3e96d487b74c
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/f81ee500/attachment.sig>

From bip at mattwhitlock.name  Tue Jan 20 17:23:14 2015
From: bip at mattwhitlock.name (Matt Whitlock)
Date: Tue, 20 Jan 2015 12:23:14 -0500
Subject: [Bitcoin-development] The legal risks of auto-updating wallet
	software; custodial relationships
In-Reply-To: <20150120154641.GA32556@muck>
References: <20150120154641.GA32556@muck>
Message-ID: <2236907.ZtrNgikFVR@crushinator>

On Tuesday, 20 January 2015, at 10:46 am, Peter Todd wrote:
> I was talking to a lawyer with a background in finance law the other day
> and we came to a somewhat worrying conclusion: authors of Bitcoin wallet
> software probably have a custodial relationship with their users,
> especially if they use auto-update mechanisms. Unfortunately this has
> potential legal implications as custodial relationships tend to be
> pretty highly regulated.
> 
> Why is this? Well, in most jurisdictions financial laws a custodial
> relationship is defined as having the ability, but not the right, to
> dispose of an asset. If you have the private keys for your users'
> bitcoins - e.g. an exchange or "online" wallet - you clearly have the
> ability to spend those bitcoins, thus you have a custodial relationship.

If you have the private keys for your users' bitcoins, then you are every bit as much the owner of those bitcoins as your users are. There is no custodial relationship, as you have both the ability and the right to spend those bitcoins. Possession of a private key is equivalent to ownership of the bitcoins controlled by that private key.



From pete at petertodd.org  Tue Jan 20 17:40:05 2015
From: pete at petertodd.org (Peter Todd)
Date: Tue, 20 Jan 2015 12:40:05 -0500
Subject: [Bitcoin-development] The legal risks of auto-updating wallet
 software; custodial relationships
In-Reply-To: <2236907.ZtrNgikFVR@crushinator>
References: <20150120154641.GA32556@muck>
 <2236907.ZtrNgikFVR@crushinator>
Message-ID: <20150120174004.GB29353@muck>

On Tue, Jan 20, 2015 at 12:23:14PM -0500, Matt Whitlock wrote:
> On Tuesday, 20 January 2015, at 10:46 am, Peter Todd wrote:
> > I was talking to a lawyer with a background in finance law the other day
> > and we came to a somewhat worrying conclusion: authors of Bitcoin wallet
> > software probably have a custodial relationship with their users,
> > especially if they use auto-update mechanisms. Unfortunately this has
> > potential legal implications as custodial relationships tend to be
> > pretty highly regulated.
> > 
> > Why is this? Well, in most jurisdictions financial laws a custodial
> > relationship is defined as having the ability, but not the right, to
> > dispose of an asset. If you have the private keys for your users'
> > bitcoins - e.g. an exchange or "online" wallet - you clearly have the
> > ability to spend those bitcoins, thus you have a custodial relationship.
> 
> If you have the private keys for your users' bitcoins, then you are every bit as much the owner of those bitcoins as your users are. There is no custodial relationship, as you have both the ability and the right to spend those bitcoins. Possession of a private key is equivalent to ownership of the bitcoins controlled by that private key.

Posessing a private key certainly does not give you an automatic legal
right to anything. As an example I could sign an agreement with you that
promised I would manage some BTC on your behalf. That agreement without
any doubt takes away any legal right I had to your BTC, enough though I
may have have the technical ability to spend them. This is the very
reason why the law has the notion of a custodial relationship in the
first place.

Don't assume the logic you'd use with tech has anything to do with the
logic courts use.

-- 
'peter'[:-1]@petertodd.org
00000000000000001a5e1dc75b28e8445c6e8a5c35c76637e33a3e96d487b74c
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/38300c4b/attachment.sig>

From bip at mattwhitlock.name  Tue Jan 20 17:44:25 2015
From: bip at mattwhitlock.name (Matt Whitlock)
Date: Tue, 20 Jan 2015 12:44:25 -0500
Subject: [Bitcoin-development] The legal risks of auto-updating wallet
	software; custodial relationships
In-Reply-To: <20150120174004.GB29353@muck>
References: <20150120154641.GA32556@muck> <2236907.ZtrNgikFVR@crushinator>
	<20150120174004.GB29353@muck>
Message-ID: <1621602.tsoQEXJ6OT@crushinator>

On Tuesday, 20 January 2015, at 12:40 pm, Peter Todd wrote:
> On Tue, Jan 20, 2015 at 12:23:14PM -0500, Matt Whitlock wrote:
> > If you have the private keys for your users' bitcoins, then you are every bit as much the owner of those bitcoins as your users are. There is no custodial relationship, as you have both the ability and the right to spend those bitcoins. Possession of a private key is equivalent to ownership of the bitcoins controlled by that private key.
> 
> Posessing a private key certainly does not give you an automatic legal
> right to anything. As an example I could sign an agreement with you that
> promised I would manage some BTC on your behalf. That agreement without
> any doubt takes away any legal right I had to your BTC, enough though I
> may have have the technical ability to spend them. This is the very
> reason why the law has the notion of a custodial relationship in the
> first place.

I never signed any kind of agreement with Andreas Schildbach. I keep my bitcoins in his wallet with the full knowledge that an auto-update could clean me out. (I only hold "walking around" amounts of money in my mobile wallet for exactly this reason.) I would love it if Andreas offered me an agreement not to spend my bitcoins without my consent, but I doubt he'd legally be allowed to offer such an agreement, as that would indeed set up a custodial relationship, which would put him into all sorts of regulatory headache.



From tamas at bitsofproof.com  Tue Jan 20 17:44:31 2015
From: tamas at bitsofproof.com (Tamas Blummer)
Date: Tue, 20 Jan 2015 18:44:31 +0100
Subject: [Bitcoin-development] The legal risks of auto-updating wallet
	software; custodial relationships
In-Reply-To: <2236907.ZtrNgikFVR@crushinator>
References: <20150120154641.GA32556@muck> <2236907.ZtrNgikFVR@crushinator>
Message-ID: <656E7756-5F0B-4594-B9F1-8CC68C7A5EE5@bitsofproof.com>

Knowing the private key and owning the linked coins is not necessarily the same in front of a court.

At least in german law there is a difference between ?Eigentum' means ownership and ?Besitz? means ability to deal with it.
Being able to deal with an asset does not make you the owner.

Tamas Blummer

On Jan 20, 2015, at 6:23 PM, Matt Whitlock <bip at mattwhitlock.name> wrote:
> 
> If you have the private keys for your users' bitcoins, then you are every bit as much the owner of those bitcoins as your users are. There is no custodial relationship, as you have both the ability and the right to spend those bitcoins. Possession of a private key is equivalent to ownership of the bitcoins controlled by that private key.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/8260e6bb/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 496 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/8260e6bb/attachment.sig>

From bip at mattwhitlock.name  Tue Jan 20 17:47:04 2015
From: bip at mattwhitlock.name (Matt Whitlock)
Date: Tue, 20 Jan 2015 12:47:04 -0500
Subject: [Bitcoin-development] The legal risks of auto-updating wallet
	software; custodial relationships
In-Reply-To: <656E7756-5F0B-4594-B9F1-8CC68C7A5EE5@bitsofproof.com>
References: <20150120154641.GA32556@muck> <2236907.ZtrNgikFVR@crushinator>
	<656E7756-5F0B-4594-B9F1-8CC68C7A5EE5@bitsofproof.com>
Message-ID: <30930479.sqHpaOe3cY@crushinator>

On Tuesday, 20 January 2015, at 6:44 pm, Tamas Blummer wrote:
> Knowing the private key and owning the linked coins is not necessarily the same in front of a court.
> 
> At least in german law there is a difference between ?Eigentum' means ownership and ?Besitz? means ability to deal with it.
> Being able to deal with an asset does not make you the owner.

So what we're telling the newbies in /r/bitcoin is plain wrong. Bitcoins *do* have an owner independent from the parties who have access to the private keys that control their disposition. That's pretty difficult to reconcile from a technological perspective.




From pete at petertodd.org  Tue Jan 20 17:49:45 2015
From: pete at petertodd.org (Peter Todd)
Date: Tue, 20 Jan 2015 12:49:45 -0500
Subject: [Bitcoin-development] The legal risks of auto-updating wallet
 software; custodial relationships
In-Reply-To: <30930479.sqHpaOe3cY@crushinator>
References: <20150120154641.GA32556@muck> <2236907.ZtrNgikFVR@crushinator>
	<656E7756-5F0B-4594-B9F1-8CC68C7A5EE5@bitsofproof.com>
	<30930479.sqHpaOe3cY@crushinator>
Message-ID: <20150120174944.GC29353@muck>

On Tue, Jan 20, 2015 at 12:47:04PM -0500, Matt Whitlock wrote:
> On Tuesday, 20 January 2015, at 6:44 pm, Tamas Blummer wrote:
> > Knowing the private key and owning the linked coins is not necessarily the same in front of a court.
> > 
> > At least in german law there is a difference between ?Eigentum' means ownership and ?Besitz? means ability to deal with it.
> > Being able to deal with an asset does not make you the owner.
> 
> So what we're telling the newbies in /r/bitcoin is plain wrong. Bitcoins *do* have an owner independent from the parties who have access to the private keys that control their disposition. That's pretty difficult to reconcile from a technological perspective.

The law concerns itself with what should be done, not what can be done.

Bitcoin the technology doesn't have a concept of "ownership" - that's a
legal notion, not a mathematical one.

-- 
'peter'[:-1]@petertodd.org
00000000000000001a5e1dc75b28e8445c6e8a5c35c76637e33a3e96d487b74c
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/58de4e30/attachment.sig>

From tamas at bitsofproof.com  Tue Jan 20 17:56:28 2015
From: tamas at bitsofproof.com (Tamas Blummer)
Date: Tue, 20 Jan 2015 18:56:28 +0100
Subject: [Bitcoin-development] The legal risks of auto-updating wallet
	software; custodial relationships
In-Reply-To: <30930479.sqHpaOe3cY@crushinator>
References: <20150120154641.GA32556@muck> <2236907.ZtrNgikFVR@crushinator>
	<656E7756-5F0B-4594-B9F1-8CC68C7A5EE5@bitsofproof.com>
	<30930479.sqHpaOe3cY@crushinator>
Message-ID: <12ED3204-6F51-4CEC-960C-5771597ACB4D@bitsofproof.com>

I am not a lawyer, just thinking loud.
I think that technology is a strong argument before court, but I suspect that it is just that, as of now.

Tamas Blummer
On Jan 20, 2015, at 6:47 PM, Matt Whitlock <bip at mattwhitlock.name> wrote:

> On Tuesday, 20 January 2015, at 6:44 pm, Tamas Blummer wrote:
>> Knowing the private key and owning the linked coins is not necessarily the same in front of a court.
>> 
>> At least in german law there is a difference between ?Eigentum' means ownership and ?Besitz? means ability to deal with it.
>> Being able to deal with an asset does not make you the owner.
> 
> So what we're telling the newbies in /r/bitcoin is plain wrong. Bitcoins *do* have an owner independent from the parties who have access to the private keys that control their disposition. That's pretty difficult to reconcile from a technological perspective.
> 
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/516a0e8b/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 496 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/516a0e8b/attachment.sig>

From justus.ranvier at monetas.net  Tue Jan 20 17:47:23 2015
From: justus.ranvier at monetas.net (Justus Ranvier)
Date: Tue, 20 Jan 2015 11:47:23 -0600
Subject: [Bitcoin-development] The legal risks of auto-updating wallet
 software; custodial relationships
In-Reply-To: <20150120154641.GA32556@muck>
References: <20150120154641.GA32556@muck>
Message-ID: <54BE94AB.3020207@monetas.net>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 01/20/2015 03:46 PM, Peter Todd wrote:
> But ultimately we're not going to know until court cases start 
> happening. In the meantime probably the best advice - other than
> getting out of the wallet business! - is to do everything you can
> to prevent losses through malicious auto-updates. Create systems
> where as many people as possible have to sign off and review an
> update before it has the opportunity to spend user funds. Not
> having auto-updates at all is a (legally) safe way to achieve that
> goal; if you do have them make sure the process by which an update
> happens is controlled by more than one person and there are
> mechanisms in place to create good audit logs of how exactly an
> update happened.
> 
> Finally keep in mind that one of the consequences of a custodial 
> relationship is that some legal authority might try to *force* you
> to seize user funds. StrongCoin made it 100% clear to authorities
> that they and sites like them are able to seize funds at will - I
> won't be surprised if authorities use that power in the future. The
> more automatic and less transparent an update is, the higher the
> chance some authority will lean on you to seize funds. So don't
> make it easy for yourself to meet those demands.

One suggestion you didn't mention was jurisdictional arbitrage - don't
be located in the same country as the majority of your users.

Or, from the other perspective, users should be strongly encouraged to
get their wallet software from companies/organizations not located in
the same country as them.


- -- 
Justus Ranvier                   | Monetas <http://monetas.net/>
<mailto:justus at monetas.net>      | Public key ID : C3F7BB2638450DB5
                                 | BM-2cTepVtZ6AyJAs2Y8LpcvZB8KbdaWLwKqc
-----BEGIN PGP SIGNATURE-----

iQIcBAEBAgAGBQJUvpSqAAoJECpf2nDq2eYj0oQQAI62vLPzFrkLZoRw3bIw5GWt
6L8dpLUviRS7ZaQlNB49TT4L4Ky+MJ1PxaHwb4YPxrVcCWDLiJb51CtODduF/9rR
8N4xoQuf/6DhsBHWJE8NDwP+9JUOlY23xdSe/BlLz9N1Ql/EV0HTCu28A9xbhK1L
QHgwX3p5/ZCJo7PCARF3o+EZOif5MsA4MdQ11HhyFWN/fgww9AVOIg/0m+tIqkjR
yoOzFww4AejC7nxi+Q+elljpvp2Q/Nv8cVOVlp9l4+f9P7sg0em9YUCE+iAxoZTT
7b9soUXFUjWlxFITR5RnjlDUnmra9QhBIhogBQbLelt/vdoRInz+kXxroR2x3uKh
EJoet2czRB1oiRKHE4iSAv+1pnavQJDVo5/mUMzeM15zCnQ16Mfu9aOpqvijK0cw
u67E4IAPJ2PmUy4sPPJ/4H4FPLmJrSUkLxxzq/4prmLLmeZZvPwjavnULHir4jyG
aaxFqMkbeJSeK3hLk7hnlrwpQRAEq7om+EpQ7fAx1lmEoA3eOHaeclh7/XzDwIB4
AK/jX+1ylhGvfuKNzwTQVX8dEzaHRwLAfLfHUNnP80WhBzH5ODicwcOwwOanL6/A
qgqwDSSB/Q5aj3VsThQ+PR81u/wA5t/Av9+Wn/g+AEMyzCnJcnHxDe41ZEn4UzYY
+RAX1P8yzF/M2ZQUeMLh
=G0GE
-----END PGP SIGNATURE-----
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0xEAD9E623.asc
Type: application/pgp-keys
Size: 17528 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/7edc7d91/attachment.bin>

From tamas at bitsofproof.com  Tue Jan 20 18:48:38 2015
From: tamas at bitsofproof.com (Tamas Blummer)
Date: Tue, 20 Jan 2015 19:48:38 +0100
Subject: [Bitcoin-development] The legal risks of auto-updating wallet
	software; custodial relationships
In-Reply-To: <54BE94AB.3020207@monetas.net>
References: <20150120154641.GA32556@muck> <54BE94AB.3020207@monetas.net>
Message-ID: <FCDDDA53-8B1C-48EF-82B1-FED9B6DE21D5@bitsofproof.com>

Justus,

In contrary. 

Not being in the jurisdiction of the wallet provider makes it harder for the user to reclaim funds taken by the wallet provider.
The legal hurdle to force confiscation through a wallet provider might also be lower if the target user is not domestic.

Tamas Blummer
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/328a83be/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 496 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/328a83be/attachment.sig>

From kristovatlas.lists at gmail.com  Tue Jan 20 18:52:14 2015
From: kristovatlas.lists at gmail.com (Kristov Atlas)
Date: Tue, 20 Jan 2015 13:52:14 -0500
Subject: [Bitcoin-development] Request for Comment: Bitcoin Wallet Privacy
	Ratings Criteria
Message-ID: <CAGH37SJJ42ixCcxYWwEiHKuqjghmw+bhRLgdT1AVVViOYNwoyQ@mail.gmail.com>

The Open Bitcoin Privacy Project is seeking public comment on our ratings
criteria for Bitcoin wallet privacy. Please provide your feedback within
the next week through Jan 23, 2015 to ensure that it will be considered for
version 1.0 of the document.

https://github.com/OpenBitcoinPrivacyProject/wallet-ratings/blob/master/criteria.md

In conjunction with a scoring matrix that will determine the weight of each
sub-category, this criteria will be used to evaluate and score a variety of
Bitcoin wallets, which will be published on our website at
openbitcoinprivacyproject.org.

Feedback through this mailing list is, of course, welcome; if you have a
GitHub account, this is the preferred medium for proposing changes to the
document.

The current version of the criteria was authored by myself, as well as
other OBPP members including Justus Ranvier (Monetas), Chris Pacia (Bitcoin
Authenticator), and Samuel Patterson (Open Bazaar).

Thank you in advance for your feedback,

Kristov Atlas
kristovatlas at gmail.com
author at anonymousbitcoinbook.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/994fedb5/attachment.html>

From justus.ranvier at monetas.net  Tue Jan 20 19:31:14 2015
From: justus.ranvier at monetas.net (Justus Ranvier)
Date: Tue, 20 Jan 2015 13:31:14 -0600
Subject: [Bitcoin-development] The legal risks of auto-updating wallet
 software; custodial relationships
In-Reply-To: <FCDDDA53-8B1C-48EF-82B1-FED9B6DE21D5@bitsofproof.com>
References: <20150120154641.GA32556@muck> <54BE94AB.3020207@monetas.net>
	<FCDDDA53-8B1C-48EF-82B1-FED9B6DE21D5@bitsofproof.com>
Message-ID: <54BEAD02.5010908@monetas.net>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 01/20/2015 12:48 PM, Tamas Blummer wrote:
> The legal hurdle to force confiscation through a wallet provider
> might also be lower if the target user is not domestic.

Depending on the threat model, the incentive to force confiscation
might also be lower.

- -- 
Justus Ranvier                   | Monetas <http://monetas.net/>
<mailto:justus at monetas.net>      | Public key ID : C3F7BB2638450DB5
                                 | BM-2cTepVtZ6AyJAs2Y8LpcvZB8KbdaWLwKqc
-----BEGIN PGP SIGNATURE-----

iQIcBAEBAgAGBQJUvq0CAAoJECpf2nDq2eYjr9kP/RWEg8Az43T+7qMFnrk37+y/
0pyEQ/zisao1d0LouxyGFu704U8Qayk96hUu+2GAQpS8hHVA0CmDW8E1hqKG2nGl
MTTQYp7932NY2NysIvNaQDhVErZZFqMpPYCnsSrnwUrygh+QjWAI8nvrrcgprG5/
zybzs5IJjFQ7QwYJ92D01shkqQJLYYspp2ME3z97AwPCBanN8eG4Iji/V8/aJqcZ
ZqF7yUjAySVUOUzR+Vju1C7N1i9MHzIG9vZA/jkaCiqZ8bvyQTm9LwSK3quoxGAB
lTplIwKjWsEvs0nm0RyurcPIWq1ppfPiWCaMCNDA5Byz3mJbSrRW5ErFgBtpYkgw
CF+WqoWU8fajQjqd8xcsKJmVyQqk4dUWXJQLGnd6pC3DCZGOPhr+6674vgmEQG5A
bXoBAtJfAJkxkDGEsngs4EBGc08iy+t6tJUh7+wI/La8xulM5BgJkQRTnL4Hn6KS
pcgYV9JP1BWMB4fkdL81mKnG98BJ98pj019C0nuPYQtSA0rUsWG9d3NYDPe87I+K
7UJ6NlNxTLxnS7nhr8Wk9UdqkFMsCQxF/RFR6I9vCQ/FMSD+i1786I72kkyf4cWJ
4ZssTX3yo6pN/faU2cBk84PQlA2ziARXqO+jzbxVR7AFpT2BESUtBdirh1CPEMfR
piBBTr6I86R2bpZYv046
=pJvU
-----END PGP SIGNATURE-----
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0xEAD9E623.asc
Type: application/pgp-keys
Size: 17528 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150120/e0e51275/attachment.bin>

From odinn.cyberguerrilla at riseup.net  Tue Jan 20 21:33:53 2015
From: odinn.cyberguerrilla at riseup.net (odinn)
Date: Tue, 20 Jan 2015 21:33:53 +0000
Subject: [Bitcoin-development] The legal risks of auto-updating wallet
 software; custodial relationships
In-Reply-To: <FCDDDA53-8B1C-48EF-82B1-FED9B6DE21D5@bitsofproof.com>
References: <20150120154641.GA32556@muck> <54BE94AB.3020207@monetas.net>
	<FCDDDA53-8B1C-48EF-82B1-FED9B6DE21D5@bitsofproof.com>
Message-ID: <54BEC9C1.3000600@riseup.net>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Um ~ "jurisdiction of wallet provider?"

If that's the (perhaps ot) bit you want to run on this thread then my
comments are:

Get out of web wallet businesses now.  It's not a jurisdictional
question anymore, although I think there used to be very valid long
running debates on where it would be best to do business.  Now it just
feels like you will be bouncing from one place to another -
determining where your exit is as soon as you establish a (physical)
presence, because jurisdictions sense a serious threat from the
advancement of financial cryptography as it will evolve in the next
several years. So you have to be mobile, or do something like what
they are establishing at blueseed (see http://blueseed.com which is
just off coast of San Francisco).  Please perk up and don't just swipe
to delete, read the whole e-mail.  There are some configurations (e.g.
the zero knowledge bit) you can do to mitigate the issues but if you
are asking users to log in and log out of a service that relies on a
web site then in the end you doom them (and any service you provide)
to mandatory storage of customer data and ultimately loss of customer
resources due to identification of the customer.

I think you need to stop quibbling about the details and just get over
it and understand that the problem of web wallet users and
corporations that serve web wallet customers being forced to give up
information constantly to governments means that web wallets are
certainly no longer a viable solution.  And post-cromnibus with the
extra financial surveillance provisions now passed on 3rd party
matters, it's even worse.  This is not subject to debate, it's just a
fact.  Period.  Web wallet corps exist now only on a model that exists
to burn the users.  Convenient?  Yes.  But is it good for the users in
the long haul?  Absolutely not.  Do alternative to the web wallets
exist? Absolutely.

Back off.. Go to p2p.  Stop advocating for webby solutions.  In fact,
I don't think that anyone working for coinbase or bitpay should be,
anymore.  I think that on principle you should withdraw and end your
employment from such services.

Core?  Good.  Electrum Wallet?  good.  Mycelium? Local Trader? Open
Bazaar?  Could be better, but great.  These are the kind of things we
need.  No signups, avoids centralizations, no grabbing your data, no
ID collection and requirements.

As to the issue of auto-updating itself... I think the simplest answer
to this question (personally) is that (go ahead and attack me here)
there shouldn't be auto-updates... but that there should be
auto-notifications for update when (a) update is available, but that
(b) this notification should never "push" the user to update (e.g. the
notification should never say "oh hey user if you don't update by such
and such a date, your wallet will not work or satoshis will die
because of your inaction"
(stays quiet while likely 100-e-mail thread is spawned from this)

- -O

Tamas Blummer:
> Justus,
> 
> In contrary.
> 
> Not being in the jurisdiction of the wallet provider makes it
> harder for the user to reclaim funds taken by the wallet provider. 
> The legal hurdle to force confiscation through a wallet provider
> might also be lower if the target user is not domestic.
> 
> Tamas Blummer
> 
> 
> 
> ------------------------------------------------------------------------------
>
> 
New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in
> Ashburn. Choose from 2 high performing configs, both with 100TB of
> bandwidth. Higher redundancy.Lower latency.Increased
> capacity.Completely compliant. http://p.sf.net/sfu/gigenet
> 
> 
> 
> _______________________________________________ Bitcoin-development
> mailing list Bitcoin-development at lists.sourceforge.net 
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> 

- -- 
http://abis.io ~
"a protocol concept to enable decentralization
and expansion of a giving economy, and a new social good"
https://keybase.io/odinn
-----BEGIN PGP SIGNATURE-----

iQEcBAEBCgAGBQJUvsnBAAoJEGxwq/inSG8CGekIAJH4lUdk81sVfQqxZ4sKOKFM
5iAvCD4JNuV+xcCZBiNNr1GxIZEVoDRQYupo7wB1A5uGW+STLHDGsEMuDNyiOcNl
oSsJQFZJabxL7dIn8g89Gw+8J8LtYKEkHHZLk5J5QF0DkRljXjEcOV4KL6WXhdl5
ToV01POMUBbSJsQt2lLznmCvQ+4QW5/GJ9Hk04HIub+kzuil0R23CgRH9QFevC9S
2/RT3NnfGFu+jU5+K/o8RbuUuzExq94x4w266IEmJc0NsLHxnxsg2PefabQbfdzp
P7FU7+D9NsIOaBGTXnQK80kpgRCJ49Gf9HXHKFYg2KCFuqgJYa8DnHm1Xlfo7DQ=
=yS8H
-----END PGP SIGNATURE-----



From roy at gnomon.org.uk  Tue Jan 20 21:49:52 2015
From: roy at gnomon.org.uk (Roy Badami)
Date: Tue, 20 Jan 2015 21:49:52 +0000
Subject: [Bitcoin-development] The legal risks of auto-updating wallet
 software; custodial relationships
In-Reply-To: <20150120154641.GA32556@muck>
References: <20150120154641.GA32556@muck>
Message-ID: <20150120214936.GP5396@giles.gnomon.org.uk>

> Why is this? Well, in most jurisdictions financial laws a custodial
> relationship is defined as having the ability, but not the right, to
> dispose of an asset.

So if I leave my window open while I'm out and there's some cash on my
desk, visible from the street, then every passer by now has a
custodial relationship with me?

Your example of a malicious software update seems more akin to a theft
like that (which is clearly not a custodial relationship) rather than
a true custodial relationship.

roy



From pieter.wuille at gmail.com  Wed Jan 21 00:35:49 2015
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Tue, 20 Jan 2015 19:35:49 -0500
Subject: [Bitcoin-development] [softfork proposal] Strict DER signatures
Message-ID: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>

Hello everyone,

We've been aware of the risk of depending on OpenSSL for consensus
rules for a while, and were trying to get rid of this as part of BIP
62 (malleability protection), which was however postponed due to
unforeseen complexities. The recent evens (see the thread titled
"OpenSSL 1.0.0p / 1.0.1k incompatible, causes blockchain rejection."
on this mailing list) have made it clear that the problem is very
real, however, and I would prefer to have a fundamental solution for
it sooner rather than later.

I therefore propose a softfork to make non-DER signatures illegal
(they've been non-standard since v0.8.0). A draft BIP text can be
found on:

    https://gist.github.com/sipa/5d12c343746dad376c80

The document includes motivation and specification. In addition, an
implementation (including unit tests derived from the BIP text) can be
found on:

    https://github.com/sipa/bitcoin/commit/bipstrictder

Comments/criticisms are very welcome, but I'd prefer keeping the
discussion here on the mailinglist (which is more accessible than on
the gist).

-- 
Pieter



From rusty at rustcorp.com.au  Wed Jan 21 04:45:26 2015
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Wed, 21 Jan 2015 15:15:26 +1030
Subject: [Bitcoin-development] [softfork proposal] Strict DER signatures
In-Reply-To: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
References: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
Message-ID: <878ugwbv2x.fsf@rustcorp.com.au>

Pieter Wuille <pieter.wuille at gmail.com> writes:
> Hello everyone,
>
> We've been aware of the risk of depending on OpenSSL for consensus
> rules for a while, and were trying to get rid of this as part of BIP
> 62 (malleability protection), which was however postponed due to
> unforeseen complexities. The recent evens (see the thread titled
> "OpenSSL 1.0.0p / 1.0.1k incompatible, causes blockchain rejection."
> on this mailing list) have made it clear that the problem is very
> real, however, and I would prefer to have a fundamental solution for
> it sooner rather than later.
>
> I therefore propose a softfork to make non-DER signatures illegal
> (they've been non-standard since v0.8.0). A draft BIP text can be
> found on:
>
>     https://gist.github.com/sipa/5d12c343746dad376c80

Cut and paste bug in the last check:

// Null bytes at the start of R are not allowed, unless it would otherwise be
// interpreted as a negative number.
    if (lenS > 1 && (sig[lenR + 6] == 0x00) && !(sig[lenR + 7] & 0x80))
    return false;

You mean "null bytes at the start of S".

Cheers,
Rusty.



From 21xe14 at gmail.com  Wed Jan 21 06:07:13 2015
From: 21xe14 at gmail.com (21E14)
Date: Wed, 21 Jan 2015 06:07:13 +0000
Subject: [Bitcoin-development] Why Bitcoin is and isn't like the Internet
Message-ID: <CAFZQHkFfpTw2rua8D21BEB9S723+VQ+8xt19AjPm0_iQSs5YuQ@mail.gmail.com>

This is a response to a wonderfully insightful recent post by Joichi Ito,
the Director of the MIT Media Lab. In it, Dr. Ito, notably a former Board
Member of ICANN, offered his thoughts on "Why Bitcoin is and isn't like the
Internet" and asked a most pertinent question: "Whether there is an ICANN
equivalent needed for Bitcoin." As suggested in recent posts to the mailing
list, I believe there might be, but for a reason that may not seem obvious
at first.

Alan Reiner expressed the need this way: "I think one of the biggest issues
facing Bitcoin right now is not the lack of a 'killer app.' It is lack of
insurance options. Early adopters would like to believe that the majority
of users will hold their own Bitcoin, but I believe that is not a realistic
option when life-changing quantities of Bitcoin are involved. We should not
trust Grandma to secure her own retirement savings via complicated computer
maneuvers. More to the point, she should not trust herself or anyone else
(sic!) to hold it unless there is a strong protection against loss events.
Right now the solution is for Grandma to avoid keeping her money in
Bitcoin. Bitcoin needs a strong backbone of insured storage options so that
Grandma can confidently participate in this new technology." This is
certainly an observation to take heed of coming from the founder of Armory
Technologies.

The protection against loss events ought to be understood in the broadest
sense. What is needed is a disaster recovery mechanism. Andreas
Antonopoulos remarks expressed this candidly last year: "Bitcoin doesn't
have a middle of the road mediocre growth model. It basically either dies,
because of a fundamental flaw in the Bitcoin system. Not an external
factor, an internal factor: We blow it up by accident. And that could
happen... Bitcoin will play out in the next three years. In the next three
years we're going to see Bitcoin arrive on the global stage and make a
substantial impact, both in financial terms and in political terms. It will
happen. Or it will die. Either way. I'm not sure. In which case we'll
reboot another currency."

A body, not entirely unlike ICANN, can manage the nexus to the physical
world, and help address Bitcoin's catastrophic failure modes. Bitcoin's
coin ownership protocol would thus join the ranks of its payment protocol,
coin issuance protocol, consensus mechanism and inflation control that pose
no lethal threat to the ecosystem. In addition to their coin-agnostic
nature, I suspect the high valuation of large Bitcoin hubs relative to
Bitcoin's market cap at this stage in its lifecycle is partly reflective of
the sneaking suspicion that a custodial bitcoin (a bitcoin attached to an
identity) may be worth more than a non-custodial one. With this in mind,
I'll pitch in for the ticket should Dr. Ito decide to join the next month's
DevCore Boston conference aimed at supporting the future development of
Bitcoin. It's an hour's walk from MIT after all.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150121/45fa2d7d/attachment.html>

From voisine at gmail.com  Wed Jan 21 07:35:50 2015
From: voisine at gmail.com (Aaron Voisine)
Date: Tue, 20 Jan 2015 23:35:50 -0800
Subject: [Bitcoin-development] Why Bitcoin is and isn't like the Internet
In-Reply-To: <CAFZQHkFfpTw2rua8D21BEB9S723+VQ+8xt19AjPm0_iQSs5YuQ@mail.gmail.com>
References: <CAFZQHkFfpTw2rua8D21BEB9S723+VQ+8xt19AjPm0_iQSs5YuQ@mail.gmail.com>
Message-ID: <CACq0ZD4WVq=J91C2r3ENfvms2QHFiw2Tck=_f=85LKetbuuC3A@mail.gmail.com>

Ultimately the only way to insure bitcoin holdings is with an insurer
who themselves holds enough bitcoin to cover replacement of insured
funds. In the existing insurance industry, this is handled through a
system of re-insurance, where smaller firms are themselves insured
against catastrophic events that might cause a large number of
simultaneous claims. At the top of the chain sits super-cat insurance
firms like Berkshire Hathaway who do actually have the reserves to pay
out in case of such a super catastrophy. This is one of the most
lucrative businesses in the world, and one that today's very large
bitcoin holders will find themselves uniquely positioned to engage in
as bitcoin grows into a major global currency.

Aaron Voisine
breadwallet.com


On Tue, Jan 20, 2015 at 10:07 PM, 21E14 <21xe14 at gmail.com> wrote:
> This is a response to a wonderfully insightful recent post by Joichi Ito,
> the Director of the MIT Media Lab. In it, Dr. Ito, notably a former Board
> Member of ICANN, offered his thoughts on "Why Bitcoin is and isn't like the
> Internet" and asked a most pertinent question: "Whether there is an ICANN
> equivalent needed for Bitcoin." As suggested in recent posts to the mailing
> list, I believe there might be, but for a reason that may not seem obvious
> at first.
>
> Alan Reiner expressed the need this way: "I think one of the biggest issues
> facing Bitcoin right now is not the lack of a 'killer app.' It is lack of
> insurance options. Early adopters would like to believe that the majority of
> users will hold their own Bitcoin, but I believe that is not a realistic
> option when life-changing quantities of Bitcoin are involved. We should not
> trust Grandma to secure her own retirement savings via complicated computer
> maneuvers. More to the point, she should not trust herself or anyone else
> (sic!) to hold it unless there is a strong protection against loss events.
> Right now the solution is for Grandma to avoid keeping her money in Bitcoin.
> Bitcoin needs a strong backbone of insured storage options so that Grandma
> can confidently participate in this new technology." This is certainly an
> observation to take heed of coming from the founder of Armory Technologies.
>
> The protection against loss events ought to be understood in the broadest
> sense. What is needed is a disaster recovery mechanism. Andreas Antonopoulos
> remarks expressed this candidly last year: "Bitcoin doesn't have a middle of
> the road mediocre growth model. It basically either dies, because of a
> fundamental flaw in the Bitcoin system. Not an external factor, an internal
> factor: We blow it up by accident. And that could happen... Bitcoin will
> play out in the next three years. In the next three years we're going to see
> Bitcoin arrive on the global stage and make a substantial impact, both in
> financial terms and in political terms. It will happen. Or it will die.
> Either way. I'm not sure. In which case we'll reboot another currency."
>
> A body, not entirely unlike ICANN, can manage the nexus to the physical
> world, and help address Bitcoin's catastrophic failure modes. Bitcoin's coin
> ownership protocol would thus join the ranks of its payment protocol, coin
> issuance protocol, consensus mechanism and inflation control that pose no
> lethal threat to the ecosystem. In addition to their coin-agnostic nature, I
> suspect the high valuation of large Bitcoin hubs relative to Bitcoin's
> market cap at this stage in its lifecycle is partly reflective of the
> sneaking suspicion that a custodial bitcoin (a bitcoin attached to an
> identity) may be worth more than a non-custodial one. With this in mind,
> I'll pitch in for the ticket should Dr. Ito decide to join the next month's
> DevCore Boston conference aimed at supporting the future development of
> Bitcoin. It's an hour's walk from MIT after all.
>
> ------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> http://p.sf.net/sfu/gigenet
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>



From alonmuroch at gmail.com  Wed Jan 21 08:20:42 2015
From: alonmuroch at gmail.com (Alon Muroch)
Date: Wed, 21 Jan 2015 10:20:42 +0200
Subject: [Bitcoin-development] Why Bitcoin is and isn't like the Internet
In-Reply-To: <CAFZQHkFfpTw2rua8D21BEB9S723+VQ+8xt19AjPm0_iQSs5YuQ@mail.gmail.com>
References: <CAFZQHkFfpTw2rua8D21BEB9S723+VQ+8xt19AjPm0_iQSs5YuQ@mail.gmail.com>
Message-ID: <CADCNpyOTMij44XwNwgmdViyaiL2xcyit1xEqV5-UEg_0_EZjQw@mail.gmail.com>

Bitcoin has a major crossroad ahead regarding a suitable platform for the
average non technical main stream user. Until now the majority of the
available solutions were at two extremes, or DIY your security and privacy
*OR* let a 3rd party service do it for you. The DIY solution is obviously
not scalable, but it seems that 3rd party solutions are not scalable as
well. If we compare for a second a 3rd party services with traditional
banks, it seems banks have two major "advantages" over them. Entry costs
for creating a bank are HUGE so a priori very few people can actually
create such a service, second, their physical and IT security
infrastructure are heavily regulated which insures a minimum of security
level to the end user (and even so money is stolen frequently). Entry costs
and regulation do not exist in the bitcoin space, meaning two programers in
their spare time can create a wallet/ platform and the non technical end
user cannot know if his money is safe, did they hire the right security
expert, did they invest enough in protecting and backing up his keys, etc.

Many services tried to tackle those problems with multisig (2 of 2 and 2 of
3) to create a syntactical 2 factor authentication/ authorisation mechanism
but in reality those solutions didn't really increase security and their
failure point is always a single device. Coupling those said problems with
the fact that bitcoin transactions are irreversible and are a scarce
commodity, trying to insure them the way our money is insured by the
government when we deposit it in the bank becomes a huge problem. Premiums
will be very high and will only grow as the appetite of hackers to steal
coins increase.

I personally believe we have the tools for creating a platform that is both
secure and private but most importantly it does it in a decentralised way.
Creating true 2 (or more) factor authentication/ authorisation schemes can
improve dramatically personal security to a point where 3rd party wallet
services will become a thing of the past. Succeeding in that will mean the
next billion non technical bitcoin users will have a platform to use
securely and a base line for building cool services on top.

Alon Muroch
bitcoinauthenticator.org

>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150121/f6a0836a/attachment.html>

From pieter.wuille at gmail.com  Wed Jan 21 16:49:28 2015
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Wed, 21 Jan 2015 11:49:28 -0500
Subject: [Bitcoin-development] [softfork proposal] Strict DER signatures
In-Reply-To: <878ugwbv2x.fsf@rustcorp.com.au>
References: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
	<878ugwbv2x.fsf@rustcorp.com.au>
Message-ID: <CAPg+sBiRXTUehzj=4kjK7VQAqD4nu-155sZzAbemYy4Me006rg@mail.gmail.com>

On Tue, Jan 20, 2015 at 11:45 PM, Rusty Russell <rusty at rustcorp.com.au> wrote:
> // Null bytes at the start of R are not allowed, unless it would otherwise be
> // interpreted as a negative number.
>     if (lenS > 1 && (sig[lenR + 6] == 0x00) && !(sig[lenR + 7] & 0x80))
>     return false;
>
> You mean "null bytes at the start of S".

Thanks, fixed.

-- 
Pieter



From pete at petertodd.org  Wed Jan 21 19:10:53 2015
From: pete at petertodd.org (Peter Todd)
Date: Wed, 21 Jan 2015 11:10:53 -0800
Subject: [Bitcoin-development] [softfork proposal] Strict DER signatures
In-Reply-To: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
References: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
Message-ID: <20150121191053.GB8403@muck>

On Tue, Jan 20, 2015 at 07:35:49PM -0500, Pieter Wuille wrote:

I read this and it's boring, now that all my objections have been met. :)

I'll try get a chance to actually test/review this in detail; in SF for
the next three weeks with some ugly deadlines and a slow laptop. :(

> Hello everyone,
> 
> We've been aware of the risk of depending on OpenSSL for consensus
> rules for a while, and were trying to get rid of this as part of BIP
> 62 (malleability protection), which was however postponed due to
> unforeseen complexities. The recent evens (see the thread titled
> "OpenSSL 1.0.0p / 1.0.1k incompatible, causes blockchain rejection."
> on this mailing list) have made it clear that the problem is very
> real, however, and I would prefer to have a fundamental solution for
> it sooner rather than later.
> 
> I therefore propose a softfork to make non-DER signatures illegal
> (they've been non-standard since v0.8.0). A draft BIP text can be
> found on:
> 
>     https://gist.github.com/sipa/5d12c343746dad376c80
> 
> The document includes motivation and specification. In addition, an
> implementation (including unit tests derived from the BIP text) can be
> found on:
> 
>     https://github.com/sipa/bitcoin/commit/bipstrictder
> 
> Comments/criticisms are very welcome, but I'd prefer keeping the
> discussion here on the mailinglist (which is more accessible than on
> the gist).

-- 
'peter'[:-1]@petertodd.org
00000000000000001a5e1dc75b28e8445c6e8a5c35c76637e33a3e96d487b74c
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150121/39547316/attachment.sig>

From odinn.cyberguerrilla at riseup.net  Wed Jan 21 19:44:35 2015
From: odinn.cyberguerrilla at riseup.net (odinn)
Date: Wed, 21 Jan 2015 19:44:35 +0000
Subject: [Bitcoin-development] Why Bitcoin is and isn't like the Internet
In-Reply-To: <CADCNpyOTMij44XwNwgmdViyaiL2xcyit1xEqV5-UEg_0_EZjQw@mail.gmail.com>
References: <CAFZQHkFfpTw2rua8D21BEB9S723+VQ+8xt19AjPm0_iQSs5YuQ@mail.gmail.com>
	<CADCNpyOTMij44XwNwgmdViyaiL2xcyit1xEqV5-UEg_0_EZjQw@mail.gmail.com>
Message-ID: <54C001A3.8020301@riseup.net>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

3rd party / web wallets are no longer viable except as means to burn
customers and divulge (or be forced to divulge) their data to
governments and corporations.

Rather than restate what I have already posted on this matter I'll
leave it there. It's time also for those who are managing bitcoin.org
to reconsider what's posted there (the criteria for what's posted there

 - at present the "web wallet" section should be excluded, that is to
say, Removed! from bitcoin.org

 with the possible exception of CoinKite to remain, which has a
reasonable argument for having made such privacy advances as to merit
usage by people (and to remain at bitcoin.org)

Additionally, I see no point in recommending any of the other wallets
except Electrum, Mycelium, Core, and in the hardware side, the ones
that appear (Trezor and HW1).

Furthermore, I believe those of you who are working for Coinbase
customer operations or Bitpay (I will not name names, you know who you
are) should resign from your employment.  I will bring this point up
regularly.  You can easily find employment elsewhere, your skills are
in high demand.

- -O

Alon Muroch:
> Bitcoin has a major crossroad ahead regarding a suitable platform
> for the average non technical main stream user. Until now the
> majority of the available solutions were at two extremes, or DIY
> your security and privacy *OR* let a 3rd party service do it for
> you. The DIY solution is obviously not scalable, but it seems that
> 3rd party solutions are not scalable as well. If we compare for a
> second a 3rd party services with traditional banks, it seems banks
> have two major "advantages" over them. Entry costs for creating a
> bank are HUGE so a priori very few people can actually create such
> a service, second, their physical and IT security infrastructure
> are heavily regulated which insures a minimum of security level to
> the end user (and even so money is stolen frequently). Entry costs 
> and regulation do not exist in the bitcoin space, meaning two
> programers in their spare time can create a wallet/ platform and
> the non technical end user cannot know if his money is safe, did
> they hire the right security expert, did they invest enough in
> protecting and backing up his keys, etc.
> 
> Many services tried to tackle those problems with multisig (2 of 2
> and 2 of 3) to create a syntactical 2 factor authentication/
> authorisation mechanism but in reality those solutions didn't
> really increase security and their failure point is always a single
> device. Coupling those said problems with the fact that bitcoin
> transactions are irreversible and are a scarce commodity, trying to
> insure them the way our money is insured by the government when we
> deposit it in the bank becomes a huge problem. Premiums will be
> very high and will only grow as the appetite of hackers to steal 
> coins increase.
> 
> I personally believe we have the tools for creating a platform that
> is both secure and private but most importantly it does it in a
> decentralised way. Creating true 2 (or more) factor authentication/
> authorisation schemes can improve dramatically personal security to
> a point where 3rd party wallet services will become a thing of the
> past. Succeeding in that will mean the next billion non technical
> bitcoin users will have a platform to use securely and a base line
> for building cool services on top.
> 
> Alon Muroch bitcoinauthenticator.org
> 
>> 
>> 
> 
> 
> 
> ------------------------------------------------------------------------------
>
> 
New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in
> Ashburn. Choose from 2 high performing configs, both with 100TB of
> bandwidth. Higher redundancy.Lower latency.Increased
> capacity.Completely compliant. http://p.sf.net/sfu/gigenet
> 
> 
> 
> _______________________________________________ Bitcoin-development
> mailing list Bitcoin-development at lists.sourceforge.net 
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> 

- -- 
http://abis.io ~
"a protocol concept to enable decentralization
and expansion of a giving economy, and a new social good"
https://keybase.io/odinn
-----BEGIN PGP SIGNATURE-----

iQEcBAEBCgAGBQJUwAGjAAoJEGxwq/inSG8CJoAIAMDR0h40IhFQNa8BW4AFeKUR
7tg84e752c7wY153GY/P7MOFL6w3E9h4tXzxdohTMMfF5Q6Ip6HaaifYmMpegFSS
WEHK0a3C2F+4sQMmMBtWbfyPsG5sJYtldY5hboSbh/6vXJJLXLSd+Sz3WHYx1Qjs
qn6sw5CA2Q0fborTxcsNZixUXD/OF5tTjDozp+KfnZ0imvBoKfhfJFlaNUXNon7U
zdPfahOrRIM5o70pjo6VwoutKRXr49JIoi47r9Uc3ujckUbLA5CVBApj4FApayb5
sXk8Ks+p6IvBr6Q0ycxXOKmPwbSALC5pLa7Ncb1MFFBGzxKFsMjoRwOLTXHlLUE=
=WgO4
-----END PGP SIGNATURE-----



From doug at bitcoinarmory.com  Wed Jan 21 19:29:52 2015
From: doug at bitcoinarmory.com (Douglas Roark)
Date: Wed, 21 Jan 2015 14:29:52 -0500
Subject: [Bitcoin-development] [softfork proposal] Strict DER signatures
In-Reply-To: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
References: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
Message-ID: <54BFFE30.8010105@bitcoinarmory.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

On 2015/1/20 19:35, Pieter Wuille wrote:> Hello everyone,
> Comments/criticisms are very welcome, but I'd prefer keeping the 
> discussion here on the mailinglist (which is more accessible than
> on the gist).

Nice paper, Pieter. I do have a bit of feedback.

1)The first sentence of "Deployment" has a typo. "We reuse the
double-threshold switchover mechanism from BIP 34, with the same
*thresholds*, [....]"

2)I think the handling of the sighash byte in the comments of
IsDERSignature() could use a little tweaking. If you look at
CheckSignatureEncoding() in the actual code (src/script/interpreter.cpp
in master), it's clear that the sighash byte is included as part of the
signature struct, even though it's not part of the actual DER encoding
being checked by IsDERSignature(). This is fine. I just think that the
code comments in the paper ought to make this point clearer, either in
the sighash description, or as a comment when checking the sig size
(i.e., size-3 is valid because sighash is included), or both.

3)The paper says a sig with size=0 is correctly coded but is neither
valid nor DER. Perhaps this code should be elsewhere in the Bitcoin
code? It seems to me that letting a sig pass in IsDERSignature() when
it's not actually DER-encoded is incorrect.

Thanks.

- ---
Douglas Roark
Senior Developer
Armory Technologies, Inc.
doug at bitcoinarmory.com
PGP key ID: 92ADC0D7
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - https://gpgtools.org

iQIcBAEBCgAGBQJUv/4vAAoJEGybVGGSrcDXMxkP/1N2lLAloCKdRUpMBLPEZ5jh
bJ4reCeqrMy6JetsKSGfGKdAe7kGkeRl6s8dlHYnpUmnODXU9BCku3zHi3+qm8IC
GZlwSdSSgmRneP7btPula0CG31o7X2UJiDW/2IOZl6ul8b7LB2L56O+Ew+PNm+at
tCfRcpKtq9LYCnRYR0azd4c5YY9/o7zlkpGi8CututzuEa4Rcm92U1extoo2tC/j
nzUfbfcQVL0a7JaRU4VYNceYrcG/xSpKPjsEU/F+5IwnUxL/kebz0EDt1kzm+fOE
EMUMXyYgoyW5VDFNjxu00PnJUfVNCOXN/N/h9eCdskCL3AtH6xg1kzam5OGvpEZS
QDMNSmQl4Zpx5WiATylNkhhzb/8GowamkSFg4SUjBsjpwOTMTIF0Qhnt+DdzwpI2
etxCGds154nL4p/bkulseczwxOZWin9oZxJnCxp40oFl8fva0BwHVx45uMyI61Ko
qRJ9Ol0CDoId3h1EMTt4uyoNxrOzgrj8/+V4BBytOAMMmsfD0VgY68xzdywJxYnC
jgU99huhwtJpn9QT6JAbgPAaboomu6hDCohV+J+DCCkIiYFk1jxp+FQ4xZDzcKeo
gMYpmFefPAxnHvDXf1v1A+Xw8plN6/NREaIpprh7Ep+q/8vYAiwwHfKjubdMkB3D
WnTR5YbqyGxc/Pvh9Ncq
=C/wj
-----END PGP SIGNATURE-----



From pieter.wuille at gmail.com  Wed Jan 21 20:30:44 2015
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Wed, 21 Jan 2015 15:30:44 -0500
Subject: [Bitcoin-development] [softfork proposal] Strict DER signatures
In-Reply-To: <54BFFE30.8010105@bitcoinarmory.com>
References: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
	<54BFFE30.8010105@bitcoinarmory.com>
Message-ID: <CAPg+sBhx=_DubYGZhBSMmYzeyZQd1NE_p0dLzoODY02vU0LQUQ@mail.gmail.com>

On Wed, Jan 21, 2015 at 2:29 PM, Douglas Roark <doug at bitcoinarmory.com> wrote:
> Nice paper, Pieter. I do have a bit of feedback.

Thanks for the comments. I hope I have clarified the text a bit accordingly.

> 1)The first sentence of "Deployment" has a typo. "We reuse the
> double-threshold switchover mechanism from BIP 34, with the same
> *thresholds*, [....]"

Fixed.

> 2)I think the handling of the sighash byte in the comments of
> IsDERSignature() could use a little tweaking. If you look at
> CheckSignatureEncoding() in the actual code (src/script/interpreter.cpp
> in master), it's clear that the sighash byte is included as part of the
> signature struct, even though it's not part of the actual DER encoding
> being checked by IsDERSignature(). This is fine. I just think that the
> code comments in the paper ought to make this point clearer, either in
> the sighash description, or as a comment when checking the sig size
> (i.e., size-3 is valid because sighash is included), or both.

I've renamed the function to IsValidSignatureEncoding, as it is not
strictly about DER (it adds a Bitcoin-specific byte, and supports and
empty string too).

> 3)The paper says a sig with size=0 is correctly coded but is neither
> valid nor DER. Perhaps this code should be elsewhere in the Bitcoin
> code? It seems to me that letting a sig pass in IsDERSignature() when
> it's not actually DER-encoded is incorrect.

I've expanded the comments about it a bit.

-- 
Pieter



From gavinandresen at gmail.com  Wed Jan 21 20:37:06 2015
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Wed, 21 Jan 2015 15:37:06 -0500
Subject: [Bitcoin-development] [softfork proposal] Strict DER signatures
In-Reply-To: <54BFFE30.8010105@bitcoinarmory.com>
References: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
	<54BFFE30.8010105@bitcoinarmory.com>
Message-ID: <CABsx9T3-wpMV8A8x2kqkWSB2XAiBVVY0RnAAiDKd54Og9erZiQ@mail.gmail.com>

DERSIG BIP looks great to me, just a few nit-picky changes suggested:

You mention the "DER standard" : should link to
http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf (or
whatever is best reference for DER).

"this would simplify avoiding OpenSSL in consensus implementations"  -->
"this would make it easier for non-OpenSSL implementations"

"causing opcode failure"  : I know what you mean by "opcode failure", but
it might be good to be more explicit.

"since v0.8.0, and nearly no transactions" -->  "and very few
transactions..."

"reducing this avenue for malleability is useful on itself as well"  :
awkward English. How about just "This proposal has the added benefit of
reducing transaction malleability (see BIP62)."


-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150121/c90302a5/attachment.html>

From doug at bitcoinarmory.com  Wed Jan 21 20:52:12 2015
From: doug at bitcoinarmory.com (Douglas Roark)
Date: Wed, 21 Jan 2015 15:52:12 -0500
Subject: [Bitcoin-development] [softfork proposal] Strict DER signatures
In-Reply-To: <CABsx9T3-wpMV8A8x2kqkWSB2XAiBVVY0RnAAiDKd54Og9erZiQ@mail.gmail.com>
References: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>	<54BFFE30.8010105@bitcoinarmory.com>
	<CABsx9T3-wpMV8A8x2kqkWSB2XAiBVVY0RnAAiDKd54Og9erZiQ@mail.gmail.com>
Message-ID: <54C0117C.6050505@bitcoinarmory.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

On 2015/1/21 15:37, Gavin Andresen wrote:
> You mention the "DER standard" : should link to
> http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf
>
> 
(or whatever is best reference for DER).

The link you gave is to the 2002 revision.
http://www.itu.int/rec/T-REC-X.690-200811-I/en has the latest revision
(Nov. 2008) and, AFAIK, is the most visible link to people searching
for X.690.

That said, X.690 is the definitive DER document (if not exactly the
easiest read). A link to it wouldn't hurt.

> "this would simplify avoiding OpenSSL in consensus implementations"
> --> "this would make it easier for non-OpenSSL implementations"
> 
> "causing opcode failure"  : I know what you mean by "opcode
> failure", but it might be good to be more explicit.
> 
> "since v0.8.0, and nearly no transactions" -->  "and very few 
> transactions..."
> 
> "reducing this avenue for malleability is useful on itself as well"
> : awkward English. How about just "This proposal has the added
> benefit of reducing transaction malleability (see BIP62)."

These all look good to me.

- ---
Douglas Roark
Senior Developer
Armory Technologies, Inc.
doug at bitcoinarmory.com
PGP key ID: 92ADC0D7
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - https://gpgtools.org

iQIcBAEBCgAGBQJUwBF8AAoJEGybVGGSrcDXBxcP/j9dKIeXkOvDFgSzON2hmjxT
nzpPcxovGt+ds1KqHMtuMm8+Mmc/Z8kOhKWzgQKYlxq8eQayQ4X/DUr97IY248NX
udVM6vEp/azPkXLOQnO6POpv8Il6twyuYGvFAHLiYe9k9qMfdSKZetx5xFKVBsuj
DhRY2TnWC7/OXNUrT7H5TPHDaGHyXeJ47XSOVjGQ/qxdczIzvmt11amZ/Vn2+uXh
Rvz+0CzbpXYaqYB04ZnIv5lxknmjWGbxPdht/SoOly8INehQacWnwUNZJpilKb6x
qEpbDGNxW2zHEFgfNHmtr9PCBN8KyiVnTt+VZpNNl7PJCxZiK6uiwyNxsmOBhBtm
Hrsvxb9GqEO/6PKesEo+Hi+6hhzzQRC6Xrf85SaFMzw9UjKuuRhstxx7XhudKFkN
lBJcxd40G7kWk0Gv+YQmhFUyXUBqloEFGrFlzWniFKaJGzZs5D0JPd83DsPI4RuT
0M63YabL8qplYN8vnyUXabFpzglvQdAFqZS2GsO6zwAeWrqxsojpcEpikj4T+izR
W1TzaRDdm5pEaMMxvb6wFIgO32uAjN1a8GrRj+uk5cxuiOuk/C4Ii18FYhqEtDNd
Gv80rPxWEOxbCoSqH6igPnySw3ePFLBzgC4eSLBTnqfKYltd8fTeS9wGy47+L1YO
qb5K/xlqt+REOdbTGLHi
=MNXG
-----END PGP SIGNATURE-----



From apoelstra at wpsoftware.net  Wed Jan 21 20:27:37 2015
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Wed, 21 Jan 2015 12:27:37 -0800
Subject: [Bitcoin-development] [softfork proposal] Strict DER signatures
In-Reply-To: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
References: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
Message-ID: <20150121202736.GZ29138@shavo.vs.shawcable.net>


I've read this and it looks A-OK to me.

Andrew



On Tue, Jan 20, 2015 at 07:35:49PM -0500, Pieter Wuille wrote:
> Hello everyone,
> 
> We've been aware of the risk of depending on OpenSSL for consensus
> rules for a while, and were trying to get rid of this as part of BIP
> 62 (malleability protection), which was however postponed due to
> unforeseen complexities. The recent evens (see the thread titled
> "OpenSSL 1.0.0p / 1.0.1k incompatible, causes blockchain rejection."
> on this mailing list) have made it clear that the problem is very
> real, however, and I would prefer to have a fundamental solution for
> it sooner rather than later.
> 
> I therefore propose a softfork to make non-DER signatures illegal
> (they've been non-standard since v0.8.0). A draft BIP text can be
> found on:
> 
>     https://gist.github.com/sipa/5d12c343746dad376c80
> 
> The document includes motivation and specification. In addition, an
> implementation (including unit tests derived from the BIP text) can be
> found on:
> 
>     https://github.com/sipa/bitcoin/commit/bipstrictder
> 
> Comments/criticisms are very welcome, but I'd prefer keeping the
> discussion here on the mailinglist (which is more accessible than on
> the gist).
> 
> -- 
> Pieter
> 
> ------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> http://p.sf.net/sfu/gigenet
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> 

-- 
Andrew Poelstra
Mathematics Department, University of Texas at Austin
Email: apoelstra at wpsoftware.net
Web:   http://www.wpsoftware.net/andrew

"If they had taught a class on how to be the kind of citizen Dick Cheney
 worries about, I would have finished high school."   --Edward Snowden

-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 490 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150121/c2345e35/attachment.sig>

From doug at bitcoinarmory.com  Wed Jan 21 20:39:50 2015
From: doug at bitcoinarmory.com (Douglas Roark)
Date: Wed, 21 Jan 2015 15:39:50 -0500
Subject: [Bitcoin-development] [softfork proposal] Strict DER signatures
In-Reply-To: <CAPg+sBhx=_DubYGZhBSMmYzeyZQd1NE_p0dLzoODY02vU0LQUQ@mail.gmail.com>
References: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>	<54BFFE30.8010105@bitcoinarmory.com>
	<CAPg+sBhx=_DubYGZhBSMmYzeyZQd1NE_p0dLzoODY02vU0LQUQ@mail.gmail.com>
Message-ID: <54C00E96.5070201@bitcoinarmory.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

On 2015/1/21 15:30, Pieter Wuille wrote:
> Thanks for the comments. I hope I have clarified the text a bit 
> accordingly.

You're welcome. All the revisions look good to me.

- ---
Douglas Roark
Senior Developer
Armory Technologies, Inc.
doug at bitcoinarmory.com
PGP key ID: 92ADC0D7
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - https://gpgtools.org

iQIcBAEBCgAGBQJUwA6WAAoJEGybVGGSrcDXvmEP/A09j4lq2P0RMqrvtwnDQRmH
oimbGwC2a/BbpACBegn0cdFYMURFFcec4gHKyvuN7xR4SRsgQ+Djq/KranAMkYbs
ZQVFGXRWdZhfsh7bY4zbBUj+H8c8PAsKL0D7S8r4iXviuUimXJXqESUYote9Ylz3
rwjiK3oRiCSMpTMiI3eDjrbQt5HHLw3hKL7W6zTerx64eCaO2JsIn/Pk4Krf9xwd
1ejpyqrK/9s90NPB0Qqieqbgg7WoQYP+ZMzFi5oNxtNrZjlOCNSQKLN0IXqnnMnS
+AoB4B5TUGCdLq3Wlo69mhLaLYNaPNHEoGNUwikXqsd5WeqsayuYDl36rI4MLWgB
ZBVO6D2BErqdqMTrmUEurubXMb6CCAuFu6iYjO3vucQ0l+7xD7OW/XiK7ZPNFuwj
2fJCjRHjqgDwKlIUF3Gh7BwRrT2iZRoFYWXDVRBMiJpHvs1+U79pQENp4BmQLWE+
xn3gX9r755mVDJL10MFM6jKijgTCGA2hEFjK2Vu1JJMeVSIGaOdEIen2DxS2mqnZ
b/t9VDxfbFQRw5pj2zHsvFDGBe7DEhvBSqbNtiPrY5/LITeP8Nt4CZ9PHrYPJV5A
ocUx98l1sqy7P0QiYzAEp5tpdjTS17MVNPt84JLJnk7wL+fDRfKKV3A7tI/ziFJe
hjW91YNTIrs+ZFLV/HJc
=Rjcd
-----END PGP SIGNATURE-----



From pieter.wuille at gmail.com  Wed Jan 21 21:22:07 2015
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Wed, 21 Jan 2015 16:22:07 -0500
Subject: [Bitcoin-development] [softfork proposal] Strict DER signatures
In-Reply-To: <CABsx9T3-wpMV8A8x2kqkWSB2XAiBVVY0RnAAiDKd54Og9erZiQ@mail.gmail.com>
References: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
	<54BFFE30.8010105@bitcoinarmory.com>
	<CABsx9T3-wpMV8A8x2kqkWSB2XAiBVVY0RnAAiDKd54Og9erZiQ@mail.gmail.com>
Message-ID: <CAPg+sBitdL0fRvxFBqT8kR4BGsqgV5rgTTiB3hLm+gJMv4Ca9A@mail.gmail.com>

On Wed, Jan 21, 2015 at 3:37 PM, Gavin Andresen <gavinandresen at gmail.com> wrote:
> DERSIG BIP looks great to me, just a few nit-picky changes suggested:
>
> You mention the "DER standard" : should link to
> http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf (or
> whatever is best reference for DER).
>
> "this would simplify avoiding OpenSSL in consensus implementations"  -->
> "this would make it easier for non-OpenSSL implementations"
>
> "causing opcode failure"  : I know what you mean by "opcode failure", but it
> might be good to be more explicit.
>
> "since v0.8.0, and nearly no transactions" -->  "and very few
> transactions..."
>
> "reducing this avenue for malleability is useful on itself as well"  :
> awkward English. How about just "This proposal has the added benefit of
> reducing transaction malleability (see BIP62)."

Nit addressed, hopefully.

-- 
Pieter



From davec at conformal.com  Wed Jan 21 22:57:22 2015
From: davec at conformal.com (Dave Collins)
Date: Wed, 21 Jan 2015 16:57:22 -0600
Subject: [Bitcoin-development] [softfork proposal] Strict DER signatures
In-Reply-To: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
References: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
Message-ID: <54C02ED2.6040806@conformal.com>

I'm really glad to see this proposal.  We already treat non-DER
signatures as non-standard in btcd and agree that extending them be
illegal as a part of a soft fork is a smart and sane thing to do.

It's also good to see the explicit use of signature parsing since it
matches what we already do as well because we noticed noticed OpenSSL's
notion of big numbers (unsigned) didn't agree with Go's (signed).  By
having the explicit signature scheme and checking clearly called out in
a BIP, it greatly lowers the chances of there being any disagreement
about what is valid or invalid due to an underlying dependency.

+1

On 1/20/2015 6:35 PM, Pieter Wuille wrote:
> Hello everyone,
> 
> We've been aware of the risk of depending on OpenSSL for consensus
> rules for a while, and were trying to get rid of this as part of BIP
> 62 (malleability protection), which was however postponed due to
> unforeseen complexities. The recent evens (see the thread titled
> "OpenSSL 1.0.0p / 1.0.1k incompatible, causes blockchain rejection."
> on this mailing list) have made it clear that the problem is very
> real, however, and I would prefer to have a fundamental solution for
> it sooner rather than later.
> 
> I therefore propose a softfork to make non-DER signatures illegal
> (they've been non-standard since v0.8.0). A draft BIP text can be
> found on:
> 
>     https://gist.github.com/sipa/5d12c343746dad376c80
> 
> The document includes motivation and specification. In addition, an
> implementation (including unit tests derived from the BIP text) can be
> found on:
> 
>     https://github.com/sipa/bitcoin/commit/bipstrictder
> 
> Comments/criticisms are very welcome, but I'd prefer keeping the
> discussion here on the mailinglist (which is more accessible than on
> the gist).
> 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 834 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150121/8834b942/attachment.sig>

From rusty at rustcorp.com.au  Thu Jan 22 00:32:35 2015
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Thu, 22 Jan 2015 11:02:35 +1030
Subject: [Bitcoin-development] [softfork proposal] Strict DER signatures
In-Reply-To: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
References: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
Message-ID: <87egqnwt7g.fsf@rustcorp.com.au>

Pieter Wuille <pieter.wuille at gmail.com> writes:
> Hello everyone,
>
> We've been aware of the risk of depending on OpenSSL for consensus
> rules for a while, and were trying to get rid of this as part of BIP
> 62 (malleability protection), which was however postponed due to
> unforeseen complexities. The recent evens (see the thread titled
> "OpenSSL 1.0.0p / 1.0.1k incompatible, causes blockchain rejection."
> on this mailing list) have made it clear that the problem is very
> real, however, and I would prefer to have a fundamental solution for
> it sooner rather than later.

OK, I worked up a clearer (but more verbose) version with fewer
magic numbers.  More importantly, feel free to steal the test cases.

One weirdness is the restriction on maximum total length, rather than a
32 byte (33 with 0-prepad) limit on signatures themselves.

Apologies for my babytalk C++.  Am sure there's a neater way.

/* Licensed under Creative Commons zero (public domain). */
#include <vector>
#include <cstdlib>
#include <cassert>

#ifdef CLARIFY
bool ConsumeByte(const std::vector<unsigned char> &sig, size_t &off,
                 unsigned int &val)
{
    if (off >= sig.size()) return false;

    val = sig[off++];
    return true;
}

bool ConsumeTypeByte(const std::vector<unsigned char> &sig, size_t &off,
                     unsigned int t)
{
    unsigned int type;
    if (!ConsumeByte(sig, off, type)) return false;

    return (type == t);
}

bool ConsumeNonZeroLength(const std::vector<unsigned char> &sig, size_t &off,
                          unsigned int &len)
{
    if (!ConsumeByte(sig, off, len)) return false;

    // Zero-length integers are not allowed.
    return (len != 0);
}

bool ConsumeNumber(const std::vector<unsigned char> &sig, size_t &off,
                   unsigned int len)
{
    // Length of number should be within signature.
    if (off + len > sig.size()) return false;

    // Negative numbers are not allowed.
    if (sig[off] & 0x80) return false;

    // Zero bytes at the start are not allowed, unless it would
    // otherwise be interpreted as a negative number.
    if (len > 1 && (sig[off] == 0x00) && !(sig[off+1] & 0x80)) return false;

    // Consume number itself.
    off += len;
    return true;
}

// Consume a DER encoded integer, update off if successful.
bool ConsumeDERInteger(const std::vector<unsigned char> &sig, size_t &off) {
    unsigned int len;

    // Type byte must be "integer"
    if (!ConsumeTypeByte(sig, off, 0x02)) return false;
    if (!ConsumeNonZeroLength(sig, off, len)) return false;
    // Now the BE encoded value itself.
    if (!ConsumeNumber(sig, off, len)) return false;

    return true;
}

bool IsValidSignatureEncoding(const std::vector<unsigned char> &sig) {
    // Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S] [sighash]
    // * total-length: 1-byte length descriptor of everything that follows,
    //     excluding the sighash byte.
    // * R-length: 1-byte length descriptor of the R value that follows.
    // * R: arbitrary-length big-endian encoded R value. It cannot start with any
    //     null bytes, unless the first byte that follows is 0x80 or higher, in which
    //     case a single null byte is required.
    // * S-length: 1-byte length descriptor of the S value that follows.
    // * S: arbitrary-length big-endian encoded S value. The same rules apply.
    // * sighash: 1-byte value indicating what data is hashed.

    // Accept empty signature as correctly encoded (but invalid) signature,
    // even though it is not strictly DER.
    if (sig.size() == 0) return true;

    // Maximum size constraint.
    if (sig.size() > 73) return false;

    size_t off = 0;

    // A signature is of type "compound".
    if (!ConsumeTypeByte(sig, off, 0x30)) return false;

    unsigned int len;
    if (!ConsumeNonZeroLength(sig, off, len)) return false;

    // Make sure the length covers the rest (except sighash).
    if (len + 1 != sig.size() - off) return false;

    // Check R value.
    if (!ConsumeDERInteger(sig, off)) return false;

    // Check S value.
    if (!ConsumeDERInteger(sig, off)) return false;

    // There should exactly one byte left (the sighash).
    return off + 1 == sig.size() ? true : false;
}
#else
bool IsValidSignatureEncoding(const std::vector<unsigned char> &sig) {
    // Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S] [sighash]
    // * total-length: 1-byte length descriptor of everything that follows,
    //     excluding the sighash byte.
    // * R-length: 1-byte length descriptor of the R value that follows.
    // * R: arbitrary-length big-endian encoded R value. It must use the shortest
    //     possible encoding for a positive integers (which means no null bytes at
    //     the start, except a single one when the next byte has its highest bit set).
    // * S-length: 1-byte length descriptor of the S value that follows.
    // * S: arbitrary-length big-endian encoded S value. The same rules apply.
    // * sighash: 1-byte value indicating what data is hashed (not part of the DER
    //     signature)

    // Accept empty signature as correctly encoded (but invalid) signature,
    // even though it is not strictly DER. This avoids needing full DER signatures
    // in places where any invalid signature would do. Given that the empty string is
    // always invalid as signature, this is safe.
    if (sig.size() == 0) return true;

    // Minimum and maximum size constraints.
    if (sig.size() < 9) return false;
    if (sig.size() > 73) return false;

    // A signature is of type 0x30 (compound).
    if (sig[0] != 0x30) return false;

    // Make sure the length covers the entire signature.
    if (sig[1] != sig.size() - 3) return false;

    // Extract the length of the R element.
    unsigned int lenR = sig[3];

    // Make sure the length of the S element is still inside the signature.
    if (5 + lenR >= sig.size()) return false;

    // Extract the length of the S element.
    unsigned int lenS = sig[5 + lenR];

    // Verify that the length of the signature matches the sum of the length
    // of the elements.
    if ((size_t)(lenR + lenS + 7) != sig.size()) return false;
 
    // Check whether the R element is an integer.
    if (sig[2] != 0x02) return false;

    // Zero-length integers are not allowed for R.
    if (lenR == 0) return false;

    // Negative numbers are not allowed for R.
    if (sig[4] & 0x80) return false;

    // Null bytes at the start of R are not allowed, unless R would
    // otherwise be interpreted as a negative number.
    if (lenR > 1 && (sig[4] == 0x00) && !(sig[5] & 0x80)) return false;

    // Check whether the S element is an integer.
    if (sig[lenR + 4] != 0x02) return false;

    // Zero-length integers are not allowed for S.
    if (lenS == 0) return false;

    // Negative numbers are not allowed for S.
    if (sig[lenR + 6] & 0x80) return false;

    // Null bytes at the start of S are not allowed, unless S would otherwise be
    // interpreted as a negative number.
    if (lenS > 1 && (sig[lenR + 6] == 0x00) && !(sig[lenR + 7] & 0x80)) return false;

    return true;
}
#endif

#define COMPOUND 0x30
#define NOT_COMPOUND 0x31

// Len gets adjusted by check() to be actual length with this offset.
#define LEN_OK 0
#define LEN_TOO_BIG 1
#define LEN_TOO_SMALL 0xff

#define INT 0x02
#define NOT_INT 0x03

#define MINIMAL_SIGLEN 1
#define MINIMAL_SIGVAL 0x0

#define NORMAL_SIGLEN 32
#define NORMAL_SIGVAL(S) S, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, \
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,              \
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,              \
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f

// 33 bytes is possible, with 0 prepended.
#define MAXIMAL_SIGLEN 33
#define MAXIMAL_SIGVAL(S) NORMAL_SIGVAL(S), 0x20

#define OVERSIZE_SIGLEN 34
#define OVERSIZE_SIGVAL(S) MAXIMAL_SIGVAL(S), 0x21

#define ZEROPAD_SIGLEN (1 + NORMAL_SIGLEN)
#define ZEROPAD_SIGVAL(S) 00, NORMAL_SIGVAL(S)

#define SIGHASH 0xf0

static bool check(const std::vector<unsigned char> &sig)
{
    std::vector<unsigned char> fixed = sig;

    // Fixup length
    if (fixed.size() > 1)
        fixed[1] += fixed.size() - 3;
    return IsValidSignatureEncoding(fixed);
}

#define good(arr) assert(check(std::vector<unsigned char>(arr, arr+sizeof(arr))))
#define bad(arr) assert(!check(std::vector<unsigned char>(arr, arr+sizeof(arr))))

// The OK cases.
static unsigned char zerolen[] = { };
static unsigned char normal[] = { COMPOUND, LEN_OK,
                                  INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
                                  INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
                                  SIGHASH };
static unsigned char min_r[] = { COMPOUND, LEN_OK,
                                 INT, MINIMAL_SIGLEN, MINIMAL_SIGVAL,
                                 INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
                                 SIGHASH };
static unsigned char min_s[] = { COMPOUND, LEN_OK,
                                 INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
                                 INT, MINIMAL_SIGLEN, MINIMAL_SIGVAL,
                                 SIGHASH };
static unsigned char max_r[] = { COMPOUND, LEN_OK,
                                 INT, MAXIMAL_SIGLEN, MAXIMAL_SIGVAL(0x1),
                                 INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
                                 SIGHASH };
static unsigned char max_s[] = { COMPOUND, LEN_OK,
                                 INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
                                 INT, MAXIMAL_SIGLEN, MAXIMAL_SIGVAL(0x2),
                                 SIGHASH };
// As long as total size doesn't go over, a single sig is allowed > 33 bytes
static unsigned char wierd_s_len[] = { COMPOUND, LEN_OK,
                                       INT, OVERSIZE_SIGLEN, OVERSIZE_SIGVAL(0x1),
                                       INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
                                       SIGHASH };
static unsigned char wierd_r_len[] = { COMPOUND, LEN_OK,
                                       INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
                                       INT, OVERSIZE_SIGLEN, OVERSIZE_SIGVAL(0x2),
                                       SIGHASH };
static unsigned char zeropad_s[] = { COMPOUND, LEN_OK,
                                     INT, ZEROPAD_SIGLEN, ZEROPAD_SIGVAL(0x81),
                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
                                     SIGHASH };
static unsigned char zeropad_r[] = { COMPOUND, LEN_OK,
                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
                                     INT, ZEROPAD_SIGLEN, ZEROPAD_SIGVAL(0x82),
                                     SIGHASH };


// The fail cases.
static unsigned char not_compound[] = { NOT_COMPOUND, LEN_OK,
                                        INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
                                        INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
                                        SIGHASH };
static unsigned char short_len[] = { COMPOUND, LEN_TOO_SMALL,
                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
                                     SIGHASH };
static unsigned char long_len[] = { COMPOUND, LEN_TOO_BIG,
                                    INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
                                    INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
                                    SIGHASH };
static unsigned char r_notint[] = { COMPOUND, LEN_OK,
                                    NOT_INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
                                    INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
                                    SIGHASH };
static unsigned char s_notint[] = { COMPOUND, LEN_OK,
                                    INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
                                    NOT_INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
                                    SIGHASH };
static unsigned char s_oversig[] = { COMPOUND, LEN_OK,
                                     INT, OVERSIZE_SIGLEN, OVERSIZE_SIGVAL(0x1),
                                     INT, MAXIMAL_SIGLEN, MAXIMAL_SIGVAL(0x2),
                                     SIGHASH };
static unsigned char r_oversig[] = { COMPOUND, LEN_OK,
                                     INT, MAXIMAL_SIGLEN, MAXIMAL_SIGVAL(0x1),
                                     INT, OVERSIZE_SIGLEN, OVERSIZE_SIGVAL(0x2),
                                     SIGHASH };
static unsigned char s_negative[] = { COMPOUND, LEN_OK,
                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x81),
                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
                                      SIGHASH };
static unsigned char r_negative[] = { COMPOUND, LEN_OK,
                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x82),
                                      SIGHASH };
static unsigned char zeropad_bad_s[] = { COMPOUND, LEN_OK,
                                         INT, ZEROPAD_SIGLEN, ZEROPAD_SIGVAL(0x1),
                                         INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
                                         SIGHASH };
static unsigned char zeropad_bad_r[] = { COMPOUND, LEN_OK,
                                         INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
                                         INT, ZEROPAD_SIGLEN, ZEROPAD_SIGVAL(0x2),
                                         SIGHASH };
static unsigned char missing_sighash[] = { COMPOUND, LEN_OK,
                                           INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
                                           INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2) };
static unsigned char extra_byte[] = { COMPOUND, LEN_OK,
                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
                                      SIGHASH, 0 };

// Bad signature lengths
static unsigned char zerolen_r[] = { COMPOUND, LEN_OK,
                                     INT, 0,
                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
                                     SIGHASH };
static unsigned char zerolen_s[] = { COMPOUND, LEN_OK,
                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
                                     INT, 0,
                                     SIGHASH };
static unsigned char overlen_r_by_1[] = { COMPOUND, LEN_OK,
                                          INT, NORMAL_SIGLEN + 1 + 1 + NORMAL_SIGLEN + 1 + 1, NORMAL_SIGVAL(0x1),
                                          INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
                                          SIGHASH };
static unsigned char overlen_s_by_1[] = { COMPOUND, LEN_OK,
                                          INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
                                          INT, NORMAL_SIGLEN+1+1, NORMAL_SIGVAL(0x2),
                                          SIGHASH };
static unsigned char underlen_r_by_1[] = { COMPOUND, LEN_OK,
                                           INT, NORMAL_SIGLEN-1, NORMAL_SIGVAL(0x1),
                                           INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
                                           SIGHASH };
static unsigned char underlen_s_by_1[] = { COMPOUND, LEN_OK,
                                           INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
                                           INT, NORMAL_SIGLEN-1, NORMAL_SIGVAL(0x2),
                                           SIGHASH };

int main()
{
    good(zerolen);
    good(normal);
    good(min_r);
    good(min_s);
    good(max_r);
    good(max_s);
    good(wierd_s_len);
    good(wierd_r_len);
    good(zeropad_s);
    good(zeropad_r);

    // Try different amounts of truncation.
    for (size_t i = 1; i < sizeof(normal)-1; i++)
        assert(!check(std::vector<unsigned char>(normal, normal+i)));

    bad(not_compound);
    bad(short_len);
    bad(long_len);
    bad(r_notint);
    bad(s_notint);
    bad(s_oversig);
    bad(r_oversig);
    bad(s_negative);
    bad(r_negative);
    bad(s_negative);
    bad(r_negative);
    bad(zeropad_bad_s);
    bad(zeropad_bad_r);
    bad(zerolen_r);
    bad(zerolen_s);
    bad(overlen_r_by_1);
    bad(overlen_s_by_1);
    bad(underlen_r_by_1);
    bad(underlen_s_by_1);
    bad(missing_sighash);
    bad(extra_byte);

    return 0;
}





From cryptocurrencies at quidecco.de  Thu Jan 22 00:44:16 2015
From: cryptocurrencies at quidecco.de (Isidor Zeuner)
Date: Thu, 22 Jan 2015 01:44:16 +0100 (CET)
Subject: [Bitcoin-development] Deanonymisation of clients in Bitcoin P2P
 network paper
In-Reply-To: <CANEZrP1Wh_98+47PmmHwSTDoSASw96R+Xnh5qWzROdmxPwO0Gw@mail.gmail.com>
References: <CANEZrP1Wh_98+47PmmHwSTDoSASw96R+Xnh5qWzROdmxPwO0Gw@mail.gmail.com>
	<CAJHLa0N6+hpwNECpHUSiKuj4-BYohh=Wr1DP=67Ff8xVBsi8-Q@mail.gmail.com>
	<54760A50.201@riseup.net> <20141127020947.A13D2E19A09@quidecco.de>
	<CAAS2fgRSxBmyDg5R7WgisB-XmhrpGVKHXQpchtL-Ow0xDQAziA@mail.gmail.com>
	<CANEZrP2JLUu9V4HGSLWr1Mg37qmTFVuihTQhJeJ4iyQPxrqsMQ@mail.gmail.com>
	<20141208161514.6C492E1B59B@quidecco.de>
Message-ID: <20150122004416.93EFDE27748@quidecco.de>

Hi there,

some thoughts in-line:
> >
> > Finally, distributors of consumer wallets can use this research in
> > order to distribute their wallet with policies which may be less prone
> > to Tor-specific attacks. Or leave this out altogether if their
> > audience has different expectations for connecting to Bitcoin.
> >
>
> Sure. I guess there will be wallets for all kinds of people in future,
> sharing a common core that they can customise (this is certainly the vision
> and general direction for bitcoinj, and it's working out OK).
>
> To clarify, my comments above were for mainstream granny-focused wallets.
> Wallets designed for crypto geeks can and should expose all the knobs to
> let people run wild.
>

I hear that. But I don't see why mainstream wallets and wallets
designed for crypto research should not share a common core. Nor do I
understand why having a common core for different types of wallets
should be reserved for BitcoinJ.

When Bitcoin was pretty new, having a less customizable core did
probably have more of a merit in order to achieve network stability
through monoculture. But as of today, Bitcoin has proven itself as
being capable of allowing a variety of client application to run on
the network, so why should the reference implementation not reflect
this kind of diversity? The policy the mainstream distribution imposes
upon the core can still be rather restrictive.

> One possible direction to go is to use Tor for writing to the network and
> use general link encryption and better Bloom filtering for reading it. Thus
> new transactions would pop out of Tor exits, but there isn't much they can
> do that's malicious there except mutate them or block them entirely. If you
> insert the same transaction into the P2P network via say 10 randomly chosen
> exits, the worst a malicious mutator can do is race the real transaction
> and that's no different to a malicious P2P node. Even in a world where an
> attacker has DoS-banned a lot of nodes and now controls your TX submission
> path entirely, it's hard to see how it helps them.
>

It might deserve some research in order to determine how Tor's
privacy guarantees might be impacted if we allow attackers to mess
around with exit node choices in a rather predictable and low-cost
manner. Unfortunately, I can't think of another (non-Bitcoin)
application which puts Tor to a similar test.

> The nice thing about the above approach is that it solves the latency
> problems. Startup speed is really an issue for reading from the network:
> just syncing the block chain is already enough of a speed hit without
> adding consensus sync as well. But if you're syncing the block chain via
> the clearnet you can connect to Tor in parallel so that by the time the
> user has scanned a QR code, verified the details on the screen and then
> pressed the Pay button, you have a warm connection and can upload the TX
> through that. It reduces the level of startup time optimisation needed,
> although Tor consensus download is still too slow even to race a QR code
> scan at the moment. I think tuning the consensus caching process and
> switching to a fresh one on the fly might be the way to go.
>

I do agree that hybrid clearnet/Tor approaches come with interesting
performance properties.

> When BIP70 is in use, you wouldn't write the tx to the network yourself but
> you could download the PaymentRequest and upload the Payment message via an
> SSLd Tor connection to the merchant. Then malicious exits can only DoS you
> but not do anything else so there's no need for multiple exit paths
> simultaneously.
>

BIP70 is interesting, indeed, although I still fail to understand why
(according to the specs I saw) the PaymentRequest message is signed,
but not the Payment message.

But in context of the discussed protocol issues, I think it just moves
the issue from the payer to the payee, so it may or may not partially
relieve network-related issues, depending on the usage scenario.

Best regards,

Isidor



From david.vorick at gmail.com  Thu Jan 22 03:12:31 2015
From: david.vorick at gmail.com (David Vorick)
Date: Wed, 21 Jan 2015 22:12:31 -0500
Subject: [Bitcoin-development] [softfork proposal] Strict DER signatures
In-Reply-To: <87egqnwt7g.fsf@rustcorp.com.au>
References: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
	<87egqnwt7g.fsf@rustcorp.com.au>
Message-ID: <CAFVRnyqhU1aLvj_WxFPY2Vu2mEwhm7jiuKrdbnwJWqvCqPVxGQ@mail.gmail.com>

Seems like a good change to me.

On Wed, Jan 21, 2015 at 7:32 PM, Rusty Russell <rusty at rustcorp.com.au>
wrote:

> Pieter Wuille <pieter.wuille at gmail.com> writes:
> > Hello everyone,
> >
> > We've been aware of the risk of depending on OpenSSL for consensus
> > rules for a while, and were trying to get rid of this as part of BIP
> > 62 (malleability protection), which was however postponed due to
> > unforeseen complexities. The recent evens (see the thread titled
> > "OpenSSL 1.0.0p / 1.0.1k incompatible, causes blockchain rejection."
> > on this mailing list) have made it clear that the problem is very
> > real, however, and I would prefer to have a fundamental solution for
> > it sooner rather than later.
>
> OK, I worked up a clearer (but more verbose) version with fewer
> magic numbers.  More importantly, feel free to steal the test cases.
>
> One weirdness is the restriction on maximum total length, rather than a
> 32 byte (33 with 0-prepad) limit on signatures themselves.
>
> Apologies for my babytalk C++.  Am sure there's a neater way.
>
> /* Licensed under Creative Commons zero (public domain). */
> #include <vector>
> #include <cstdlib>
> #include <cassert>
>
> #ifdef CLARIFY
> bool ConsumeByte(const std::vector<unsigned char> &sig, size_t &off,
>                  unsigned int &val)
> {
>     if (off >= sig.size()) return false;
>
>     val = sig[off++];
>     return true;
> }
>
> bool ConsumeTypeByte(const std::vector<unsigned char> &sig, size_t &off,
>                      unsigned int t)
> {
>     unsigned int type;
>     if (!ConsumeByte(sig, off, type)) return false;
>
>     return (type == t);
> }
>
> bool ConsumeNonZeroLength(const std::vector<unsigned char> &sig, size_t
> &off,
>                           unsigned int &len)
> {
>     if (!ConsumeByte(sig, off, len)) return false;
>
>     // Zero-length integers are not allowed.
>     return (len != 0);
> }
>
> bool ConsumeNumber(const std::vector<unsigned char> &sig, size_t &off,
>                    unsigned int len)
> {
>     // Length of number should be within signature.
>     if (off + len > sig.size()) return false;
>
>     // Negative numbers are not allowed.
>     if (sig[off] & 0x80) return false;
>
>     // Zero bytes at the start are not allowed, unless it would
>     // otherwise be interpreted as a negative number.
>     if (len > 1 && (sig[off] == 0x00) && !(sig[off+1] & 0x80)) return
> false;
>
>     // Consume number itself.
>     off += len;
>     return true;
> }
>
> // Consume a DER encoded integer, update off if successful.
> bool ConsumeDERInteger(const std::vector<unsigned char> &sig, size_t &off)
> {
>     unsigned int len;
>
>     // Type byte must be "integer"
>     if (!ConsumeTypeByte(sig, off, 0x02)) return false;
>     if (!ConsumeNonZeroLength(sig, off, len)) return false;
>     // Now the BE encoded value itself.
>     if (!ConsumeNumber(sig, off, len)) return false;
>
>     return true;
> }
>
> bool IsValidSignatureEncoding(const std::vector<unsigned char> &sig) {
>     // Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
> [sighash]
>     // * total-length: 1-byte length descriptor of everything that follows,
>     //     excluding the sighash byte.
>     // * R-length: 1-byte length descriptor of the R value that follows.
>     // * R: arbitrary-length big-endian encoded R value. It cannot start
> with any
>     //     null bytes, unless the first byte that follows is 0x80 or
> higher, in which
>     //     case a single null byte is required.
>     // * S-length: 1-byte length descriptor of the S value that follows.
>     // * S: arbitrary-length big-endian encoded S value. The same rules
> apply.
>     // * sighash: 1-byte value indicating what data is hashed.
>
>     // Accept empty signature as correctly encoded (but invalid) signature,
>     // even though it is not strictly DER.
>     if (sig.size() == 0) return true;
>
>     // Maximum size constraint.
>     if (sig.size() > 73) return false;
>
>     size_t off = 0;
>
>     // A signature is of type "compound".
>     if (!ConsumeTypeByte(sig, off, 0x30)) return false;
>
>     unsigned int len;
>     if (!ConsumeNonZeroLength(sig, off, len)) return false;
>
>     // Make sure the length covers the rest (except sighash).
>     if (len + 1 != sig.size() - off) return false;
>
>     // Check R value.
>     if (!ConsumeDERInteger(sig, off)) return false;
>
>     // Check S value.
>     if (!ConsumeDERInteger(sig, off)) return false;
>
>     // There should exactly one byte left (the sighash).
>     return off + 1 == sig.size() ? true : false;
> }
> #else
> bool IsValidSignatureEncoding(const std::vector<unsigned char> &sig) {
>     // Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
> [sighash]
>     // * total-length: 1-byte length descriptor of everything that follows,
>     //     excluding the sighash byte.
>     // * R-length: 1-byte length descriptor of the R value that follows.
>     // * R: arbitrary-length big-endian encoded R value. It must use the
> shortest
>     //     possible encoding for a positive integers (which means no null
> bytes at
>     //     the start, except a single one when the next byte has its
> highest bit set).
>     // * S-length: 1-byte length descriptor of the S value that follows.
>     // * S: arbitrary-length big-endian encoded S value. The same rules
> apply.
>     // * sighash: 1-byte value indicating what data is hashed (not part of
> the DER
>     //     signature)
>
>     // Accept empty signature as correctly encoded (but invalid) signature,
>     // even though it is not strictly DER. This avoids needing full DER
> signatures
>     // in places where any invalid signature would do. Given that the
> empty string is
>     // always invalid as signature, this is safe.
>     if (sig.size() == 0) return true;
>
>     // Minimum and maximum size constraints.
>     if (sig.size() < 9) return false;
>     if (sig.size() > 73) return false;
>
>     // A signature is of type 0x30 (compound).
>     if (sig[0] != 0x30) return false;
>
>     // Make sure the length covers the entire signature.
>     if (sig[1] != sig.size() - 3) return false;
>
>     // Extract the length of the R element.
>     unsigned int lenR = sig[3];
>
>     // Make sure the length of the S element is still inside the signature.
>     if (5 + lenR >= sig.size()) return false;
>
>     // Extract the length of the S element.
>     unsigned int lenS = sig[5 + lenR];
>
>     // Verify that the length of the signature matches the sum of the
> length
>     // of the elements.
>     if ((size_t)(lenR + lenS + 7) != sig.size()) return false;
>
>     // Check whether the R element is an integer.
>     if (sig[2] != 0x02) return false;
>
>     // Zero-length integers are not allowed for R.
>     if (lenR == 0) return false;
>
>     // Negative numbers are not allowed for R.
>     if (sig[4] & 0x80) return false;
>
>     // Null bytes at the start of R are not allowed, unless R would
>     // otherwise be interpreted as a negative number.
>     if (lenR > 1 && (sig[4] == 0x00) && !(sig[5] & 0x80)) return false;
>
>     // Check whether the S element is an integer.
>     if (sig[lenR + 4] != 0x02) return false;
>
>     // Zero-length integers are not allowed for S.
>     if (lenS == 0) return false;
>
>     // Negative numbers are not allowed for S.
>     if (sig[lenR + 6] & 0x80) return false;
>
>     // Null bytes at the start of S are not allowed, unless S would
> otherwise be
>     // interpreted as a negative number.
>     if (lenS > 1 && (sig[lenR + 6] == 0x00) && !(sig[lenR + 7] & 0x80))
> return false;
>
>     return true;
> }
> #endif
>
> #define COMPOUND 0x30
> #define NOT_COMPOUND 0x31
>
> // Len gets adjusted by check() to be actual length with this offset.
> #define LEN_OK 0
> #define LEN_TOO_BIG 1
> #define LEN_TOO_SMALL 0xff
>
> #define INT 0x02
> #define NOT_INT 0x03
>
> #define MINIMAL_SIGLEN 1
> #define MINIMAL_SIGVAL 0x0
>
> #define NORMAL_SIGLEN 32
> #define NORMAL_SIGVAL(S) S, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, \
>         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,              \
>         0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,              \
>         0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
>
> // 33 bytes is possible, with 0 prepended.
> #define MAXIMAL_SIGLEN 33
> #define MAXIMAL_SIGVAL(S) NORMAL_SIGVAL(S), 0x20
>
> #define OVERSIZE_SIGLEN 34
> #define OVERSIZE_SIGVAL(S) MAXIMAL_SIGVAL(S), 0x21
>
> #define ZEROPAD_SIGLEN (1 + NORMAL_SIGLEN)
> #define ZEROPAD_SIGVAL(S) 00, NORMAL_SIGVAL(S)
>
> #define SIGHASH 0xf0
>
> static bool check(const std::vector<unsigned char> &sig)
> {
>     std::vector<unsigned char> fixed = sig;
>
>     // Fixup length
>     if (fixed.size() > 1)
>         fixed[1] += fixed.size() - 3;
>     return IsValidSignatureEncoding(fixed);
> }
>
> #define good(arr) assert(check(std::vector<unsigned char>(arr,
> arr+sizeof(arr))))
> #define bad(arr) assert(!check(std::vector<unsigned char>(arr,
> arr+sizeof(arr))))
>
> // The OK cases.
> static unsigned char zerolen[] = { };
> static unsigned char normal[] = { COMPOUND, LEN_OK,
>                                   INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
>                                   INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
>                                   SIGHASH };
> static unsigned char min_r[] = { COMPOUND, LEN_OK,
>                                  INT, MINIMAL_SIGLEN, MINIMAL_SIGVAL,
>                                  INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
>                                  SIGHASH };
> static unsigned char min_s[] = { COMPOUND, LEN_OK,
>                                  INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
>                                  INT, MINIMAL_SIGLEN, MINIMAL_SIGVAL,
>                                  SIGHASH };
> static unsigned char max_r[] = { COMPOUND, LEN_OK,
>                                  INT, MAXIMAL_SIGLEN, MAXIMAL_SIGVAL(0x1),
>                                  INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
>                                  SIGHASH };
> static unsigned char max_s[] = { COMPOUND, LEN_OK,
>                                  INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
>                                  INT, MAXIMAL_SIGLEN, MAXIMAL_SIGVAL(0x2),
>                                  SIGHASH };
> // As long as total size doesn't go over, a single sig is allowed > 33
> bytes
> static unsigned char wierd_s_len[] = { COMPOUND, LEN_OK,
>                                        INT, OVERSIZE_SIGLEN,
> OVERSIZE_SIGVAL(0x1),
>                                        INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x2),
>                                        SIGHASH };
> static unsigned char wierd_r_len[] = { COMPOUND, LEN_OK,
>                                        INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x1),
>                                        INT, OVERSIZE_SIGLEN,
> OVERSIZE_SIGVAL(0x2),
>                                        SIGHASH };
> static unsigned char zeropad_s[] = { COMPOUND, LEN_OK,
>                                      INT, ZEROPAD_SIGLEN,
> ZEROPAD_SIGVAL(0x81),
>                                      INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x2),
>                                      SIGHASH };
> static unsigned char zeropad_r[] = { COMPOUND, LEN_OK,
>                                      INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x1),
>                                      INT, ZEROPAD_SIGLEN,
> ZEROPAD_SIGVAL(0x82),
>                                      SIGHASH };
>
>
> // The fail cases.
> static unsigned char not_compound[] = { NOT_COMPOUND, LEN_OK,
>                                         INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x1),
>                                         INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x2),
>                                         SIGHASH };
> static unsigned char short_len[] = { COMPOUND, LEN_TOO_SMALL,
>                                      INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x1),
>                                      INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x2),
>                                      SIGHASH };
> static unsigned char long_len[] = { COMPOUND, LEN_TOO_BIG,
>                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
>                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
>                                     SIGHASH };
> static unsigned char r_notint[] = { COMPOUND, LEN_OK,
>                                     NOT_INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x1),
>                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
>                                     SIGHASH };
> static unsigned char s_notint[] = { COMPOUND, LEN_OK,
>                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
>                                     NOT_INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x2),
>                                     SIGHASH };
> static unsigned char s_oversig[] = { COMPOUND, LEN_OK,
>                                      INT, OVERSIZE_SIGLEN,
> OVERSIZE_SIGVAL(0x1),
>                                      INT, MAXIMAL_SIGLEN,
> MAXIMAL_SIGVAL(0x2),
>                                      SIGHASH };
> static unsigned char r_oversig[] = { COMPOUND, LEN_OK,
>                                      INT, MAXIMAL_SIGLEN,
> MAXIMAL_SIGVAL(0x1),
>                                      INT, OVERSIZE_SIGLEN,
> OVERSIZE_SIGVAL(0x2),
>                                      SIGHASH };
> static unsigned char s_negative[] = { COMPOUND, LEN_OK,
>                                       INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x81),
>                                       INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x2),
>                                       SIGHASH };
> static unsigned char r_negative[] = { COMPOUND, LEN_OK,
>                                       INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x1),
>                                       INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x82),
>                                       SIGHASH };
> static unsigned char zeropad_bad_s[] = { COMPOUND, LEN_OK,
>                                          INT, ZEROPAD_SIGLEN,
> ZEROPAD_SIGVAL(0x1),
>                                          INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x2),
>                                          SIGHASH };
> static unsigned char zeropad_bad_r[] = { COMPOUND, LEN_OK,
>                                          INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x1),
>                                          INT, ZEROPAD_SIGLEN,
> ZEROPAD_SIGVAL(0x2),
>                                          SIGHASH };
> static unsigned char missing_sighash[] = { COMPOUND, LEN_OK,
>                                            INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x1),
>                                            INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x2) };
> static unsigned char extra_byte[] = { COMPOUND, LEN_OK,
>                                       INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x1),
>                                       INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x2),
>                                       SIGHASH, 0 };
>
> // Bad signature lengths
> static unsigned char zerolen_r[] = { COMPOUND, LEN_OK,
>                                      INT, 0,
>                                      INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x2),
>                                      SIGHASH };
> static unsigned char zerolen_s[] = { COMPOUND, LEN_OK,
>                                      INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x1),
>                                      INT, 0,
>                                      SIGHASH };
> static unsigned char overlen_r_by_1[] = { COMPOUND, LEN_OK,
>                                           INT, NORMAL_SIGLEN + 1 + 1 +
> NORMAL_SIGLEN + 1 + 1, NORMAL_SIGVAL(0x1),
>                                           INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x2),
>                                           SIGHASH };
> static unsigned char overlen_s_by_1[] = { COMPOUND, LEN_OK,
>                                           INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x1),
>                                           INT, NORMAL_SIGLEN+1+1,
> NORMAL_SIGVAL(0x2),
>                                           SIGHASH };
> static unsigned char underlen_r_by_1[] = { COMPOUND, LEN_OK,
>                                            INT, NORMAL_SIGLEN-1,
> NORMAL_SIGVAL(0x1),
>                                            INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x2),
>                                            SIGHASH };
> static unsigned char underlen_s_by_1[] = { COMPOUND, LEN_OK,
>                                            INT, NORMAL_SIGLEN,
> NORMAL_SIGVAL(0x1),
>                                            INT, NORMAL_SIGLEN-1,
> NORMAL_SIGVAL(0x2),
>                                            SIGHASH };
>
> int main()
> {
>     good(zerolen);
>     good(normal);
>     good(min_r);
>     good(min_s);
>     good(max_r);
>     good(max_s);
>     good(wierd_s_len);
>     good(wierd_r_len);
>     good(zeropad_s);
>     good(zeropad_r);
>
>     // Try different amounts of truncation.
>     for (size_t i = 1; i < sizeof(normal)-1; i++)
>         assert(!check(std::vector<unsigned char>(normal, normal+i)));
>
>     bad(not_compound);
>     bad(short_len);
>     bad(long_len);
>     bad(r_notint);
>     bad(s_notint);
>     bad(s_oversig);
>     bad(r_oversig);
>     bad(s_negative);
>     bad(r_negative);
>     bad(s_negative);
>     bad(r_negative);
>     bad(zeropad_bad_s);
>     bad(zeropad_bad_r);
>     bad(zerolen_r);
>     bad(zerolen_s);
>     bad(overlen_r_by_1);
>     bad(overlen_s_by_1);
>     bad(underlen_r_by_1);
>     bad(underlen_s_by_1);
>     bad(missing_sighash);
>     bad(extra_byte);
>
>     return 0;
> }
>
>
>
>
> ------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> http://p.sf.net/sfu/gigenet
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150121/fba1f709/attachment.html>

From bip at mattwhitlock.name  Thu Jan 22 04:18:07 2015
From: bip at mattwhitlock.name (Matt Whitlock)
Date: Wed, 21 Jan 2015 23:18:07 -0500
Subject: [Bitcoin-development] [softfork proposal] Strict DER signatures
In-Reply-To: <87egqnwt7g.fsf@rustcorp.com.au>
References: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
	<87egqnwt7g.fsf@rustcorp.com.au>
Message-ID: <2955914.eNECdfYQmZ@crushinator>

To be more in the C++ spirit, I would suggest changing the (const std::vector<unsigned char> &sig, size_t &off) parameters to (std::vector<unsigned char>::const_iterator &itr, std::vector<unsigned char>::const_iterator end).

Example:

bool ConsumeNumber(std::vector<unsigned char>::const_iterator &itr, std::vector<unsigned char>::const_iterator end, unsigned int len)
{
	// Length of number should be within signature.
	if (itr + len >= end) return false;
 
	// Negative numbers are not allowed.
	if (*itr & 0x80) return false;
 
	// Zero bytes at the start are not allowed, unless it would
	// otherwise be interpreted as a negative number.
	if (len > 1 && (*itr == 0x00) && !(*(itr + 1) & 0x80)) return false;
 
	// Consume number itself.
	itr += len;
	return true;
}


On Thursday, 22 January 2015, at 11:02 am, Rusty Russell wrote:
> Pieter Wuille <pieter.wuille at gmail.com> writes:
> > Hello everyone,
> >
> > We've been aware of the risk of depending on OpenSSL for consensus
> > rules for a while, and were trying to get rid of this as part of BIP
> > 62 (malleability protection), which was however postponed due to
> > unforeseen complexities. The recent evens (see the thread titled
> > "OpenSSL 1.0.0p / 1.0.1k incompatible, causes blockchain rejection."
> > on this mailing list) have made it clear that the problem is very
> > real, however, and I would prefer to have a fundamental solution for
> > it sooner rather than later.
> 
> OK, I worked up a clearer (but more verbose) version with fewer
> magic numbers.  More importantly, feel free to steal the test cases.
> 
> One weirdness is the restriction on maximum total length, rather than a
> 32 byte (33 with 0-prepad) limit on signatures themselves.
> 
> Apologies for my babytalk C++.  Am sure there's a neater way.
> 
> /* Licensed under Creative Commons zero (public domain). */
> #include <vector>
> #include <cstdlib>
> #include <cassert>
> 
> #ifdef CLARIFY
> bool ConsumeByte(const std::vector<unsigned char> &sig, size_t &off,
>                  unsigned int &val)
> {
>     if (off >= sig.size()) return false;
> 
>     val = sig[off++];
>     return true;
> }
> 
> bool ConsumeTypeByte(const std::vector<unsigned char> &sig, size_t &off,
>                      unsigned int t)
> {
>     unsigned int type;
>     if (!ConsumeByte(sig, off, type)) return false;
> 
>     return (type == t);
> }
> 
> bool ConsumeNonZeroLength(const std::vector<unsigned char> &sig, size_t &off,
>                           unsigned int &len)
> {
>     if (!ConsumeByte(sig, off, len)) return false;
> 
>     // Zero-length integers are not allowed.
>     return (len != 0);
> }
> 
> bool ConsumeNumber(const std::vector<unsigned char> &sig, size_t &off,
>                    unsigned int len)
> {
>     // Length of number should be within signature.
>     if (off + len > sig.size()) return false;
> 
>     // Negative numbers are not allowed.
>     if (sig[off] & 0x80) return false;
> 
>     // Zero bytes at the start are not allowed, unless it would
>     // otherwise be interpreted as a negative number.
>     if (len > 1 && (sig[off] == 0x00) && !(sig[off+1] & 0x80)) return false;
> 
>     // Consume number itself.
>     off += len;
>     return true;
> }
> 
> // Consume a DER encoded integer, update off if successful.
> bool ConsumeDERInteger(const std::vector<unsigned char> &sig, size_t &off) {
>     unsigned int len;
> 
>     // Type byte must be "integer"
>     if (!ConsumeTypeByte(sig, off, 0x02)) return false;
>     if (!ConsumeNonZeroLength(sig, off, len)) return false;
>     // Now the BE encoded value itself.
>     if (!ConsumeNumber(sig, off, len)) return false;
> 
>     return true;
> }
> 
> bool IsValidSignatureEncoding(const std::vector<unsigned char> &sig) {
>     // Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S] [sighash]
>     // * total-length: 1-byte length descriptor of everything that follows,
>     //     excluding the sighash byte.
>     // * R-length: 1-byte length descriptor of the R value that follows.
>     // * R: arbitrary-length big-endian encoded R value. It cannot start with any
>     //     null bytes, unless the first byte that follows is 0x80 or higher, in which
>     //     case a single null byte is required.
>     // * S-length: 1-byte length descriptor of the S value that follows.
>     // * S: arbitrary-length big-endian encoded S value. The same rules apply.
>     // * sighash: 1-byte value indicating what data is hashed.
> 
>     // Accept empty signature as correctly encoded (but invalid) signature,
>     // even though it is not strictly DER.
>     if (sig.size() == 0) return true;
> 
>     // Maximum size constraint.
>     if (sig.size() > 73) return false;
> 
>     size_t off = 0;
> 
>     // A signature is of type "compound".
>     if (!ConsumeTypeByte(sig, off, 0x30)) return false;
> 
>     unsigned int len;
>     if (!ConsumeNonZeroLength(sig, off, len)) return false;
> 
>     // Make sure the length covers the rest (except sighash).
>     if (len + 1 != sig.size() - off) return false;
> 
>     // Check R value.
>     if (!ConsumeDERInteger(sig, off)) return false;
> 
>     // Check S value.
>     if (!ConsumeDERInteger(sig, off)) return false;
> 
>     // There should exactly one byte left (the sighash).
>     return off + 1 == sig.size() ? true : false;
> }
> #else
> bool IsValidSignatureEncoding(const std::vector<unsigned char> &sig) {
>     // Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S] [sighash]
>     // * total-length: 1-byte length descriptor of everything that follows,
>     //     excluding the sighash byte.
>     // * R-length: 1-byte length descriptor of the R value that follows.
>     // * R: arbitrary-length big-endian encoded R value. It must use the shortest
>     //     possible encoding for a positive integers (which means no null bytes at
>     //     the start, except a single one when the next byte has its highest bit set).
>     // * S-length: 1-byte length descriptor of the S value that follows.
>     // * S: arbitrary-length big-endian encoded S value. The same rules apply.
>     // * sighash: 1-byte value indicating what data is hashed (not part of the DER
>     //     signature)
> 
>     // Accept empty signature as correctly encoded (but invalid) signature,
>     // even though it is not strictly DER. This avoids needing full DER signatures
>     // in places where any invalid signature would do. Given that the empty string is
>     // always invalid as signature, this is safe.
>     if (sig.size() == 0) return true;
> 
>     // Minimum and maximum size constraints.
>     if (sig.size() < 9) return false;
>     if (sig.size() > 73) return false;
> 
>     // A signature is of type 0x30 (compound).
>     if (sig[0] != 0x30) return false;
> 
>     // Make sure the length covers the entire signature.
>     if (sig[1] != sig.size() - 3) return false;
> 
>     // Extract the length of the R element.
>     unsigned int lenR = sig[3];
> 
>     // Make sure the length of the S element is still inside the signature.
>     if (5 + lenR >= sig.size()) return false;
> 
>     // Extract the length of the S element.
>     unsigned int lenS = sig[5 + lenR];
> 
>     // Verify that the length of the signature matches the sum of the length
>     // of the elements.
>     if ((size_t)(lenR + lenS + 7) != sig.size()) return false;
>  
>     // Check whether the R element is an integer.
>     if (sig[2] != 0x02) return false;
> 
>     // Zero-length integers are not allowed for R.
>     if (lenR == 0) return false;
> 
>     // Negative numbers are not allowed for R.
>     if (sig[4] & 0x80) return false;
> 
>     // Null bytes at the start of R are not allowed, unless R would
>     // otherwise be interpreted as a negative number.
>     if (lenR > 1 && (sig[4] == 0x00) && !(sig[5] & 0x80)) return false;
> 
>     // Check whether the S element is an integer.
>     if (sig[lenR + 4] != 0x02) return false;
> 
>     // Zero-length integers are not allowed for S.
>     if (lenS == 0) return false;
> 
>     // Negative numbers are not allowed for S.
>     if (sig[lenR + 6] & 0x80) return false;
> 
>     // Null bytes at the start of S are not allowed, unless S would otherwise be
>     // interpreted as a negative number.
>     if (lenS > 1 && (sig[lenR + 6] == 0x00) && !(sig[lenR + 7] & 0x80)) return false;
> 
>     return true;
> }
> #endif
> 
> #define COMPOUND 0x30
> #define NOT_COMPOUND 0x31
> 
> // Len gets adjusted by check() to be actual length with this offset.
> #define LEN_OK 0
> #define LEN_TOO_BIG 1
> #define LEN_TOO_SMALL 0xff
> 
> #define INT 0x02
> #define NOT_INT 0x03
> 
> #define MINIMAL_SIGLEN 1
> #define MINIMAL_SIGVAL 0x0
> 
> #define NORMAL_SIGLEN 32
> #define NORMAL_SIGVAL(S) S, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, \
>         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,              \
>         0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,              \
>         0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
> 
> // 33 bytes is possible, with 0 prepended.
> #define MAXIMAL_SIGLEN 33
> #define MAXIMAL_SIGVAL(S) NORMAL_SIGVAL(S), 0x20
> 
> #define OVERSIZE_SIGLEN 34
> #define OVERSIZE_SIGVAL(S) MAXIMAL_SIGVAL(S), 0x21
> 
> #define ZEROPAD_SIGLEN (1 + NORMAL_SIGLEN)
> #define ZEROPAD_SIGVAL(S) 00, NORMAL_SIGVAL(S)
> 
> #define SIGHASH 0xf0
> 
> static bool check(const std::vector<unsigned char> &sig)
> {
>     std::vector<unsigned char> fixed = sig;
> 
>     // Fixup length
>     if (fixed.size() > 1)
>         fixed[1] += fixed.size() - 3;
>     return IsValidSignatureEncoding(fixed);
> }
> 
> #define good(arr) assert(check(std::vector<unsigned char>(arr, arr+sizeof(arr))))
> #define bad(arr) assert(!check(std::vector<unsigned char>(arr, arr+sizeof(arr))))
> 
> // The OK cases.
> static unsigned char zerolen[] = { };
> static unsigned char normal[] = { COMPOUND, LEN_OK,
>                                   INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
>                                   INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
>                                   SIGHASH };
> static unsigned char min_r[] = { COMPOUND, LEN_OK,
>                                  INT, MINIMAL_SIGLEN, MINIMAL_SIGVAL,
>                                  INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
>                                  SIGHASH };
> static unsigned char min_s[] = { COMPOUND, LEN_OK,
>                                  INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
>                                  INT, MINIMAL_SIGLEN, MINIMAL_SIGVAL,
>                                  SIGHASH };
> static unsigned char max_r[] = { COMPOUND, LEN_OK,
>                                  INT, MAXIMAL_SIGLEN, MAXIMAL_SIGVAL(0x1),
>                                  INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
>                                  SIGHASH };
> static unsigned char max_s[] = { COMPOUND, LEN_OK,
>                                  INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
>                                  INT, MAXIMAL_SIGLEN, MAXIMAL_SIGVAL(0x2),
>                                  SIGHASH };
> // As long as total size doesn't go over, a single sig is allowed > 33 bytes
> static unsigned char wierd_s_len[] = { COMPOUND, LEN_OK,
>                                        INT, OVERSIZE_SIGLEN, OVERSIZE_SIGVAL(0x1),
>                                        INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
>                                        SIGHASH };
> static unsigned char wierd_r_len[] = { COMPOUND, LEN_OK,
>                                        INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
>                                        INT, OVERSIZE_SIGLEN, OVERSIZE_SIGVAL(0x2),
>                                        SIGHASH };
> static unsigned char zeropad_s[] = { COMPOUND, LEN_OK,
>                                      INT, ZEROPAD_SIGLEN, ZEROPAD_SIGVAL(0x81),
>                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
>                                      SIGHASH };
> static unsigned char zeropad_r[] = { COMPOUND, LEN_OK,
>                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
>                                      INT, ZEROPAD_SIGLEN, ZEROPAD_SIGVAL(0x82),
>                                      SIGHASH };
> 
> 
> // The fail cases.
> static unsigned char not_compound[] = { NOT_COMPOUND, LEN_OK,
>                                         INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
>                                         INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
>                                         SIGHASH };
> static unsigned char short_len[] = { COMPOUND, LEN_TOO_SMALL,
>                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
>                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
>                                      SIGHASH };
> static unsigned char long_len[] = { COMPOUND, LEN_TOO_BIG,
>                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
>                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
>                                     SIGHASH };
> static unsigned char r_notint[] = { COMPOUND, LEN_OK,
>                                     NOT_INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
>                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
>                                     SIGHASH };
> static unsigned char s_notint[] = { COMPOUND, LEN_OK,
>                                     INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
>                                     NOT_INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
>                                     SIGHASH };
> static unsigned char s_oversig[] = { COMPOUND, LEN_OK,
>                                      INT, OVERSIZE_SIGLEN, OVERSIZE_SIGVAL(0x1),
>                                      INT, MAXIMAL_SIGLEN, MAXIMAL_SIGVAL(0x2),
>                                      SIGHASH };
> static unsigned char r_oversig[] = { COMPOUND, LEN_OK,
>                                      INT, MAXIMAL_SIGLEN, MAXIMAL_SIGVAL(0x1),
>                                      INT, OVERSIZE_SIGLEN, OVERSIZE_SIGVAL(0x2),
>                                      SIGHASH };
> static unsigned char s_negative[] = { COMPOUND, LEN_OK,
>                                       INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x81),
>                                       INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
>                                       SIGHASH };
> static unsigned char r_negative[] = { COMPOUND, LEN_OK,
>                                       INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
>                                       INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x82),
>                                       SIGHASH };
> static unsigned char zeropad_bad_s[] = { COMPOUND, LEN_OK,
>                                          INT, ZEROPAD_SIGLEN, ZEROPAD_SIGVAL(0x1),
>                                          INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
>                                          SIGHASH };
> static unsigned char zeropad_bad_r[] = { COMPOUND, LEN_OK,
>                                          INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
>                                          INT, ZEROPAD_SIGLEN, ZEROPAD_SIGVAL(0x2),
>                                          SIGHASH };
> static unsigned char missing_sighash[] = { COMPOUND, LEN_OK,
>                                            INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
>                                            INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2) };
> static unsigned char extra_byte[] = { COMPOUND, LEN_OK,
>                                       INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
>                                       INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
>                                       SIGHASH, 0 };
> 
> // Bad signature lengths
> static unsigned char zerolen_r[] = { COMPOUND, LEN_OK,
>                                      INT, 0,
>                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
>                                      SIGHASH };
> static unsigned char zerolen_s[] = { COMPOUND, LEN_OK,
>                                      INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
>                                      INT, 0,
>                                      SIGHASH };
> static unsigned char overlen_r_by_1[] = { COMPOUND, LEN_OK,
>                                           INT, NORMAL_SIGLEN + 1 + 1 + NORMAL_SIGLEN + 1 + 1, NORMAL_SIGVAL(0x1),
>                                           INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
>                                           SIGHASH };
> static unsigned char overlen_s_by_1[] = { COMPOUND, LEN_OK,
>                                           INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
>                                           INT, NORMAL_SIGLEN+1+1, NORMAL_SIGVAL(0x2),
>                                           SIGHASH };
> static unsigned char underlen_r_by_1[] = { COMPOUND, LEN_OK,
>                                            INT, NORMAL_SIGLEN-1, NORMAL_SIGVAL(0x1),
>                                            INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x2),
>                                            SIGHASH };
> static unsigned char underlen_s_by_1[] = { COMPOUND, LEN_OK,
>                                            INT, NORMAL_SIGLEN, NORMAL_SIGVAL(0x1),
>                                            INT, NORMAL_SIGLEN-1, NORMAL_SIGVAL(0x2),
>                                            SIGHASH };
> 
> int main()
> {
>     good(zerolen);
>     good(normal);
>     good(min_r);
>     good(min_s);
>     good(max_r);
>     good(max_s);
>     good(wierd_s_len);
>     good(wierd_r_len);
>     good(zeropad_s);
>     good(zeropad_r);
> 
>     // Try different amounts of truncation.
>     for (size_t i = 1; i < sizeof(normal)-1; i++)
>         assert(!check(std::vector<unsigned char>(normal, normal+i)));
> 
>     bad(not_compound);
>     bad(short_len);
>     bad(long_len);
>     bad(r_notint);
>     bad(s_notint);
>     bad(s_oversig);
>     bad(r_oversig);
>     bad(s_negative);
>     bad(r_negative);
>     bad(s_negative);
>     bad(r_negative);
>     bad(zeropad_bad_s);
>     bad(zeropad_bad_r);
>     bad(zerolen_r);
>     bad(zerolen_s);
>     bad(overlen_r_by_1);
>     bad(overlen_s_by_1);
>     bad(underlen_r_by_1);
>     bad(underlen_s_by_1);
>     bad(missing_sighash);
>     bad(extra_byte);
> 
>     return 0;
> }
> 
> 
> 
> ------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> http://p.sf.net/sfu/gigenet
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development



From pieter.wuille at gmail.com  Thu Jan 22 04:20:25 2015
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Wed, 21 Jan 2015 23:20:25 -0500
Subject: [Bitcoin-development] [softfork proposal] Strict DER signatures
In-Reply-To: <2955914.eNECdfYQmZ@crushinator>
References: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
	<87egqnwt7g.fsf@rustcorp.com.au> <2955914.eNECdfYQmZ@crushinator>
Message-ID: <CAPg+sBg8F4ZRXLCvCv+sqapJudyKpGvHB+e=TYSTnG+cP5im0g@mail.gmail.com>

On Wed, Jan 21, 2015 at 11:18 PM, Matt Whitlock <bip at mattwhitlock.name> wrote:
> To be more in the C++ spirit, I would suggest changing the (const std::vector<unsigned char> &sig, size_t &off) parameters to (std::vector<unsigned char>::const_iterator &itr, std::vector<unsigned char>::const_iterator end).

I agree that is more in the spirit of C++, but part of the motivation
for including C++ code that it mostly matches the exact code that has
been used in the past two major Bitcoin Core releases (to interpret
signatures as standard).

-- 
Pieter



From for-gmane at mutluit.com  Thu Jan 22 09:36:23 2015
From: for-gmane at mutluit.com (U.Mutlu)
Date: Thu, 22 Jan 2015 10:36:23 +0100
Subject: [Bitcoin-development] Securing wallet on paper
Message-ID: <m9qgan$bk1$1@ger.gmane.org>

I don't know yet the details of how a wallet looks like internally,
but I think it should be possible to print the wallet incl. acct nbr
out on classical paper (as base16 or base64 etc.) for filing it
in a physical home or bank safe.

Later, typing it from paper to a small converter program that recreates the 
wallet file.

IMO this is a good security against possible computer hardware disasters.

Of course one has to secure this further with encryption against bank 
fraud/theft etc.
Ie. the output on paper should be encrypted, and the owner
should place the key somewhere else.

I would suggest the developers make such functionality available for the user.

cu
Uenal




From stick at gk2.sk  Thu Jan 22 09:46:26 2015
From: stick at gk2.sk (Pavol Rusnak)
Date: Thu, 22 Jan 2015 10:46:26 +0100
Subject: [Bitcoin-development] Securing wallet on paper
In-Reply-To: <m9qgan$bk1$1@ger.gmane.org>
References: <m9qgan$bk1$1@ger.gmane.org>
Message-ID: <54C0C6F2.7070300@gk2.sk>

On 22/01/15 10:36, U.Mutlu wrote:
> Later, typing it from paper to a small converter program that recreates the 
> wallet file.

Bitcoin Core still does not support Hierarchical Deterministic aka BIP32
Wallets. Without them it is possible to backup just one private key per
backup, which is rather useless and in fact dangerous.

> I would suggest the developers make such functionality available for the user.

I would suggest looking at different software wallets that do support
such functionality such as Electrum or Multibit.

-- 
Best Regards / S pozdravom,

Pavol Rusnak <stick at gk2.sk>



From jbrown at bluedroplet.com  Thu Jan 22 10:20:51 2015
From: jbrown at bluedroplet.com (Jonathan Brown)
Date: Thu, 22 Jan 2015 17:20:51 +0700
Subject: [Bitcoin-development] Ensuring security of funds and preserving
 anonymity when using Bitcoin for e-commerce
Message-ID: <CABaYTy_e-zj=voyLJ89af6ByCW9+=qkh+4xWukMv598JD3JTAA@mail.gmail.com>

I wrote a blog post entitled "Ensuring security of funds and preserving
anonymity when using Bitcoin for e-commerce".

I thought the readers of this list might be interested.

http://jonathanpatrick.me/blog/bitcoin-ecommerce
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150122/587f8ea1/attachment.html>

From mike at plan99.net  Thu Jan 22 13:20:29 2015
From: mike at plan99.net (Mike Hearn)
Date: Thu, 22 Jan 2015 14:20:29 +0100
Subject: [Bitcoin-development] Deanonymisation of clients in Bitcoin P2P
 network paper
In-Reply-To: <20150122004416.93EFDE27748@quidecco.de>
References: <CAJHLa0N6+hpwNECpHUSiKuj4-BYohh=Wr1DP=67Ff8xVBsi8-Q@mail.gmail.com>
	<54760A50.201@riseup.net> <20141127020947.A13D2E19A09@quidecco.de>
	<CAAS2fgRSxBmyDg5R7WgisB-XmhrpGVKHXQpchtL-Ow0xDQAziA@mail.gmail.com>
	<CANEZrP2JLUu9V4HGSLWr1Mg37qmTFVuihTQhJeJ4iyQPxrqsMQ@mail.gmail.com>
	<20141208161514.6C492E1B59B@quidecco.de>
	<CANEZrP1Wh_98+47PmmHwSTDoSASw96R+Xnh5qWzROdmxPwO0Gw@mail.gmail.com>
	<20150122004416.93EFDE27748@quidecco.de>
Message-ID: <CANEZrP2H8P0nh6224UKbnZ7EXrNE6jwM_SZSj6UaMn1QqWumDg@mail.gmail.com>

>
> I hear that. But I don't see why mainstream wallets and wallets
> designed for crypto research should not share a common core.
>

I think there was some misunderstanding. I was saying they *could and
should* share common cores, so we are in agreement without realising it :)
I also didn't mean to imply there was anything special about bitcoinj, just
that it's an example of a wallet engine that's already in use.


> BIP70 is interesting, indeed, although I still fail to understand why
> (according to the specs I saw) the PaymentRequest message is signed,
> but not the Payment message.
>

Because it's intended to be submitted via HTTPS. But what would you sign
the message with? Some arbitrary key bound to the transaction?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150122/03b843c2/attachment.html>

From tomh at thinlink.com  Thu Jan 22 15:19:26 2015
From: tomh at thinlink.com (Tom Harding)
Date: Thu, 22 Jan 2015 07:19:26 -0800
Subject: [Bitcoin-development] IMPULSE: Instant Payments using the
 Bitcoin protocol
In-Reply-To: <CAH2=CKzsikCnQHBdXnPa=OhHEs2-4D+t79ZCbrH7-qspmA64jQ@mail.gmail.com>
References: <CAH2=CKzsikCnQHBdXnPa=OhHEs2-4D+t79ZCbrH7-qspmA64jQ@mail.gmail.com>
Message-ID: <54C114FE.4070308@thinlink.com>

On 1/17/2015 12:45 PM, Rune Kj?r Svendsen wrote:
> PDF: http://impulse.is/impulse.pdf
>
> I'd love to hear this list's thoughts.
>

Will success be defined by "BitPay Payment Channels Accepted Here" signs 
appearing in shop windows?




From jgarzik at bitpay.com  Thu Jan 22 16:29:24 2015
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Thu, 22 Jan 2015 11:29:24 -0500
Subject: [Bitcoin-development] IMPULSE: Instant Payments using the
	Bitcoin protocol
In-Reply-To: <54C114FE.4070308@thinlink.com>
References: <CAH2=CKzsikCnQHBdXnPa=OhHEs2-4D+t79ZCbrH7-qspmA64jQ@mail.gmail.com>
	<54C114FE.4070308@thinlink.com>
Message-ID: <CAJHLa0PX31xF6rFugW3z1x-xXmzZGn47EnQESSggJpQ=7my7DQ@mail.gmail.com>

The user experience is significantly more secure than today.

Presumably the future supports many payment facilitators, including m-of-n
oracles, and this is perfectly compatible with that.


On Thu, Jan 22, 2015 at 10:19 AM, Tom Harding <tomh at thinlink.com> wrote:

> On 1/17/2015 12:45 PM, Rune Kj?r Svendsen wrote:
> > PDF: http://impulse.is/impulse.pdf
> >
> > I'd love to hear this list's thoughts.
> >
>
> Will success be defined by "BitPay Payment Channels Accepted Here" signs
> appearing in shop windows?
>
>
>
> ------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> http://p.sf.net/sfu/gigenet
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150122/44b184f9/attachment.html>

From justusranvier at riseup.net  Thu Jan 22 16:36:31 2015
From: justusranvier at riseup.net (Justus Ranvier)
Date: Thu, 22 Jan 2015 16:36:31 +0000
Subject: [Bitcoin-development] IMPULSE: Instant Payments using the
 Bitcoin protocol
In-Reply-To: <CAH2=CKzsikCnQHBdXnPa=OhHEs2-4D+t79ZCbrH7-qspmA64jQ@mail.gmail.com>
References: <CAH2=CKzsikCnQHBdXnPa=OhHEs2-4D+t79ZCbrH7-qspmA64jQ@mail.gmail.com>
Message-ID: <54C1270F.4090100@riseup.net>

On 01/17/2015 08:45 PM, Rune Kj?r Svendsen wrote:
> Hi list
> 
> Found this on reddit: http://impulse.is/
> 
> PDF: http://impulse.is/impulse.pdf
> 
> I'd love to hear this list's thoughts.
> 
> /runeks

I'm concerned about the silence that always erupts whenever
privacy-hostile products are proposed.


-- 
Support online privacy by using email encryption whenever possible.
Learn how here: http://www.youtube.com/watch?v=bakOKJFtB-k



From zooko at leastauthority.com  Thu Jan 22 22:41:47 2015
From: zooko at leastauthority.com (Zooko Wilcox-OHearn)
Date: Thu, 22 Jan 2015 22:41:47 +0000
Subject: [Bitcoin-development] [softfork proposal] Strict DER signatures
In-Reply-To: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
References: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
Message-ID: <CAM_a8Jzt=Q8m=-7wur1UdscqQRQmg+TBFNtneUtRH3nh+TOTDQ@mail.gmail.com>

.Hi there. Thank you for your work on this.

I've looked over https://gist.github.com/sipa/5d12c343746dad376c80 and
https://github.com/sipa/bitcoin/commit/bipstrictder . I didn't
actually audit the included reference implementation of
IsValidSignatureEncoding(), and I didn't check whether the test
vectors in https://github.com/sipa/bitcoin/commit/f94e806f8bfa007a3de4b45fa3c9860f2747e427
exercise all of the branches that are changed by this patch.

I have the following comments:

* It seems like a good idea to do this.

* I don't see any problem with using the upgrade mechanism from BIP 34
for this. It's cool! I'm happy that such a mechanism seems to work in
practice.

* Should the bipstrictder give a rationale or link to why accept the
0-length sig as correctly-encoded-but-invalid? I guess the rationale
is an efficiency issue as described in the log entry for
https://github.com/sipa/bitcoin/commit/041f1e3597812c250ebedbd8f4ef1565591d2c34
.

* Does this mean there are still multiple ways to encode a correctly
encoded but invalid signature, one of which is the 0-length string?
Would it make sense for this change to also treat any *other*
correctly-encoded-but-invalid sig (besides the 0-length string) as
incorrectly-encoded? Did I just step in some BIP62?

* It would be good to verify that all the branches of the new
IsDERSignature() from
https://github.com/sipa/bitcoin/commit/0c427135151a6bed657438ffb2e670be84eb3642
are tested by the test vectors in
https://github.com/sipa/bitcoin/commit/f94e806f8bfa007a3de4b45fa3c9860f2747e427
. Eyeballing it, there are about 20 branches touched by the patch, and
about 24 new test vectors.

* It would be good to finish the TODOs in
https://github.com/sipa/bitcoin/commit/b7986119a5d41337fea1e83804ed6223438158ec
so that it was actually testing the upgrade behavior.

* missing comment:
https://github.com/sipa/bitcoin/commit/e186f6a80161f9fa45fbced82ab1d22f081b942c#commitcomment-9406643

Okay, that's all I've got. Hope it helps! Thanks again for your good work!

Regards,

Zooko



From slush at centrum.cz  Fri Jan 23 14:51:02 2015
From: slush at centrum.cz (slush)
Date: Fri, 23 Jan 2015 15:51:02 +0100
Subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE
Message-ID: <CAJna-HjwMRff_+7BvcR2YME9f2yUQPvfKOGZ1qq9d0nOGqORkg@mail.gmail.com>

Hi,

is any progress or even discussion in this area?

https://bitcointalk.org/index.php?topic=181734.0

I don't insist on any specific solution, but this is becoming a real issue
as hardware wallets are more widespread. I'm sitting next to TREZOR for 40
minutes already, because it streams and validate some complex transaction.
By using proposed solution, such signature would be a matter of few seconds.

That's also not just about time/resource/hw cost optimization. I'm talking
about possibility of huge simplification of the firmware (=security FTW),
because 50% of actual codebase is solving this particular downside of
Bitcoin protocol.

So, there's real world problem. On which solution can we as a community
find a wide agreement?

Best,
Marek
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/30a6ffb5/attachment.html>

From etotheipi at gmail.com  Fri Jan 23 15:24:17 2015
From: etotheipi at gmail.com (Alan Reiner)
Date: Fri, 23 Jan 2015 10:24:17 -0500
Subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE
In-Reply-To: <CAJna-HjwMRff_+7BvcR2YME9f2yUQPvfKOGZ1qq9d0nOGqORkg@mail.gmail.com>
References: <CAJna-HjwMRff_+7BvcR2YME9f2yUQPvfKOGZ1qq9d0nOGqORkg@mail.gmail.com>
Message-ID: <54C267A1.8090208@gmail.com>

The SIGHASH_WITHINPUTVALUE proposal is a hardfork, but otherwise
non-intrusive, doesn't change any TxOut scripts, doesn't change any
tx/block parsing (besides verification), it works with all existing
coins in the network, and existing software doesn't have to use it if
they don't want to upgrade their signers.   The proposal simply provides
a way to optionally sign the input values with the TxOut scripts.  In
other words a signature right now says "I sign this transaction using
these inputs, whatever value they are."  With this SIGHASH type, the
signature says "I sign this transaction assuming that input 0 is X BTC,
input 1 is Y BTC,....".  If the online computer providing the data to be
signed lies about the value of any input, the resulting signature will
be invalid.

Unfortunately, it seems that there was no soft-fork way to achieve this
benefit, at least not one that had favorable properties.  Most of the
soft-fork variations of it required the coins being spent to have been
originated in a special way.  In other words, it would only work if the
coins had entered the wallet with some special, modified TxOut script. 
So it wouldn't work with existing coins, and would require senders to
update their software to reshape the way they send transactions to be
compatible with our goals.

I *strongly* encourage this to be considered for inclusion at some
point.  Not only does it simplify HW as Marek suggested, it increases
the options for online-offline communication channels, which is also a
win for security.  Right now, QR codes don't work because of the
possibility of having to transfer megabytes over the channel, and no way
to for the signer to control that size.  With this change, it's possible
for the signer to control the size of each chunk of data to guarantee it
fits in, say, a QR code (even if it means breaking it up into a couple
smaller transactions).

-Alan



On 01/23/2015 09:51 AM, slush wrote:
> Hi,
>
> is any progress or even discussion in this area? 
>
> https://bitcointalk.org/index.php?topic=181734.0
>
> I don't insist on any specific solution, but this is becoming a real
> issue as hardware wallets are more widespread. I'm sitting next to
> TREZOR for 40 minutes already, because it streams and validate some
> complex transaction. By using proposed solution, such signature would
> be a matter of few seconds.
>
> That's also not just about time/resource/hw cost optimization. I'm
> talking about possibility of huge simplification of the firmware
> (=security FTW), because 50% of actual codebase is solving this
> particular downside of Bitcoin protocol.
>
> So, there's real world problem. On which solution can we as a
> community find a wide agreement?
>
> Best,
> Marek
>
>
> ------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> http://p.sf.net/sfu/gigenet
>
>
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/46e022bd/attachment.html>

From tamas at bitsofproof.com  Fri Jan 23 15:31:46 2015
From: tamas at bitsofproof.com (Tamas Blummer)
Date: Fri, 23 Jan 2015 16:31:46 +0100
Subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE
In-Reply-To: <CAJna-HjwMRff_+7BvcR2YME9f2yUQPvfKOGZ1qq9d0nOGqORkg@mail.gmail.com>
References: <CAJna-HjwMRff_+7BvcR2YME9f2yUQPvfKOGZ1qq9d0nOGqORkg@mail.gmail.com>
Message-ID: <78662993-6C67-4480-8062-55CC9FA63908@bitsofproof.com>

Not a fix, but would reduce the financial risk, if nodes were not relaying excessive fee transactions.

Tamas Blummer

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/04250c18/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 496 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/04250c18/attachment.sig>

From slush at centrum.cz  Fri Jan 23 15:40:39 2015
From: slush at centrum.cz (slush)
Date: Fri, 23 Jan 2015 16:40:39 +0100
Subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE
In-Reply-To: <54C267A1.8090208@gmail.com>
References: <CAJna-HjwMRff_+7BvcR2YME9f2yUQPvfKOGZ1qq9d0nOGqORkg@mail.gmail.com>
	<54C267A1.8090208@gmail.com>
Message-ID: <CAJna-Hj1UrMx5bHmN2DXm2U-9uEmw2GN3z=SeF0oevibCV6zvw@mail.gmail.com>

> I *strongly* encourage this to be considered for inclusion at some point.

Thanks Alan for a nice summary. I also agree that such stuff should be
implemented at some point. Anyway, I would probably not vote for doing hard
fork *just* for this change, but if I remember well, there're other ideas
flying around in the air and waiting for hardfork...

Marek

On Fri, Jan 23, 2015 at 4:24 PM, Alan Reiner <etotheipi at gmail.com> wrote:

>  The SIGHASH_WITHINPUTVALUE proposal is a hardfork, but otherwise
> non-intrusive, doesn't change any TxOut scripts, doesn't change any
> tx/block parsing (besides verification), it works with all existing coins
> in the network, and existing software doesn't have to use it if they don't
> want to upgrade their signers.   The proposal simply provides a way to
> optionally sign the input values with the TxOut scripts.  In other words a
> signature right now says "I sign this transaction using these inputs,
> whatever value they are."  With this SIGHASH type, the signature says "I
> sign this transaction assuming that input 0 is X BTC, input 1 is Y
> BTC,....".  If the online computer providing the data to be signed lies
> about the value of any input, the resulting signature will be invalid.
>
> Unfortunately, it seems that there was no soft-fork way to achieve this
> benefit, at least not one that had favorable properties.  Most of the
> soft-fork variations of it required the coins being spent to have been
> originated in a special way.  In other words, it would only work if the
> coins had entered the wallet with some special, modified TxOut script.  So
> it wouldn't work with existing coins, and would require senders to update
> their software to reshape the way they send transactions to be compatible
> with our goals.
>
> I *strongly* encourage this to be considered for inclusion at some
> point.  Not only does it simplify HW as Marek suggested, it increases the
> options for online-offline communication channels, which is also a win for
> security.  Right now, QR codes don't work because of the possibility of
> having to transfer megabytes over the channel, and no way to for the signer
> to control that size.  With this change, it's possible for the signer to
> control the size of each chunk of data to guarantee it fits in, say, a QR
> code (even if it means breaking it up into a couple smaller transactions).
>
> -Alan
>
>
>
>
> On 01/23/2015 09:51 AM, slush wrote:
>
> Hi,
>
>  is any progress or even discussion in this area?
>
>  https://bitcointalk.org/index.php?topic=181734.0
>
>  I don't insist on any specific solution, but this is becoming a real
> issue as hardware wallets are more widespread. I'm sitting next to TREZOR
> for 40 minutes already, because it streams and validate some complex
> transaction. By using proposed solution, such signature would be a matter
> of few seconds.
>
>  That's also not just about time/resource/hw cost optimization. I'm
> talking about possibility of huge simplification of the firmware (=security
> FTW), because 50% of actual codebase is solving this particular downside of
> Bitcoin protocol.
>
>  So, there's real world problem. On which solution can we as a community
> find a wide agreement?
>
>  Best,
> Marek
>
>
> ------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.http://p.sf.net/sfu/gigenet
>
>
>
> _______________________________________________
> Bitcoin-development mailing listBitcoin-development at lists.sourceforge.nethttps://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
>
>
> ------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> http://p.sf.net/sfu/gigenet
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> T
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/0b4fa4b3/attachment.html>

From etotheipi at gmail.com  Fri Jan 23 15:42:54 2015
From: etotheipi at gmail.com (Alan Reiner)
Date: Fri, 23 Jan 2015 10:42:54 -0500
Subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE
In-Reply-To: <78662993-6C67-4480-8062-55CC9FA63908@bitsofproof.com>
References: <CAJna-HjwMRff_+7BvcR2YME9f2yUQPvfKOGZ1qq9d0nOGqORkg@mail.gmail.com>
	<78662993-6C67-4480-8062-55CC9FA63908@bitsofproof.com>
Message-ID: <54C26BFE.1080103@gmail.com>

Unfortunately, one major attack vector is someone isolating your node,
getting you to sign away your whole wallet to fee, and then selling it
to a mining pool to mine it before you can figure why your transactions
aren't making it to the network.  In such an attack, the relay rules
aren't relevant, and if the attacker can DoS you for 24 hours, it
doesn't take a ton of mining power to make the attack extremely likely
to succeed.




On 01/23/2015 10:31 AM, Tamas Blummer wrote:
> Not a fix, but would reduce the financial risk, if nodes were not
> relaying excessive fee transactions.
>
> Tamas Blummer
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/af0bb7ef/attachment.html>

From slush at centrum.cz  Fri Jan 23 15:47:41 2015
From: slush at centrum.cz (slush)
Date: Fri, 23 Jan 2015 16:47:41 +0100
Subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE
In-Reply-To: <54C26BFE.1080103@gmail.com>
References: <CAJna-HjwMRff_+7BvcR2YME9f2yUQPvfKOGZ1qq9d0nOGqORkg@mail.gmail.com>
	<78662993-6C67-4480-8062-55CC9FA63908@bitsofproof.com>
	<54C26BFE.1080103@gmail.com>
Message-ID: <CAJna-HiXxt5E=FBiDuWMCKrK4C0dcvhHEjTAoK3LGQLafJOqtQ@mail.gmail.com>

Correct, plus the most likely scenario in such attack is that the malware
even don't push such tx with excessive fees to the network, but send it
directly to attacker's pool/miner.

M.

On Fri, Jan 23, 2015 at 4:42 PM, Alan Reiner <etotheipi at gmail.com> wrote:

>  Unfortunately, one major attack vector is someone isolating your node,
> getting you to sign away your whole wallet to fee, and then selling it to a
> mining pool to mine it before you can figure why your transactions aren't
> making it to the network.  In such an attack, the relay rules aren't
> relevant, and if the attacker can DoS you for 24 hours, it doesn't take a
> ton of mining power to make the attack extremely likely to succeed.
>
>
>
>
> On 01/23/2015 10:31 AM, Tamas Blummer wrote:
>
> Not a fix, but would reduce the financial risk, if nodes were not relaying
> excessive fee transactions.
>
>  Tamas Blummer
>
>
>
>
>
> ------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> http://p.sf.net/sfu/gigenet
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/2562323d/attachment.html>

From gmaxwell at gmail.com  Fri Jan 23 16:05:10 2015
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Fri, 23 Jan 2015 16:05:10 +0000
Subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE
In-Reply-To: <54C267A1.8090208@gmail.com>
References: <CAJna-HjwMRff_+7BvcR2YME9f2yUQPvfKOGZ1qq9d0nOGqORkg@mail.gmail.com>
	<54C267A1.8090208@gmail.com>
Message-ID: <CAAS2fgQSAj=YHhtvy=MY9GvbEZNxtLUwzfrdPnSQBUKZYdj4oA@mail.gmail.com>

On Fri, Jan 23, 2015 at 3:24 PM, Alan Reiner <etotheipi at gmail.com> wrote:
> Unfortunately, it seems that there was no soft-fork way to achieve this
> benefit, at least not one that had favorable properties.  Most of the
> soft-fork variations of it required the coins being spent to have been
> originated in a special way.  In other words, it would only work if the
> coins had entered the wallet with some special, modified TxOut script.  So
> it wouldn't work with existing coins, and would require senders to update
> their software to reshape the way they send transactions to be compatible
> with our goals.

I think this is unreasonable. There is a straight-forward soft-fork
approach which is safe (e.g. no risk of invalidating existing
transactions). Yes, it means that you need to use newly created
addresses to get coins that use the new signature type... but thats
only the case for people who want the new capability. This is
massively preferable to expecting _every_ _other_ user of the system
(including miners, full nodes, etc.) to replace their software with an
incompatible new version just to accommodate your transactions, for
which they may care nothing about and which would otherwise not have
any urgent need to change.

I've expected this need to be addressed simply as a side effect of a
new, more efficient, checksig operator which some people have been
working on and off on but which has taken a backseat to other more
urgent issues.

On Fri, Jan 23, 2015 at 2:51 PM, slush <slush at centrum.cz> wrote:
> as hardware wallets are more widespread. I'm sitting next to TREZOR for 40
> minutes already, because it streams and validate some complex transaction.

Can you help me understand whats taking 40 minutes here? Thats a
surprisingly high number, and so I'm wondering if I'm not missing
something there.



From tamas at bitsofproof.com  Fri Jan 23 16:08:50 2015
From: tamas at bitsofproof.com (Tamas Blummer)
Date: Fri, 23 Jan 2015 17:08:50 +0100
Subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE
In-Reply-To: <CAJna-HiXxt5E=FBiDuWMCKrK4C0dcvhHEjTAoK3LGQLafJOqtQ@mail.gmail.com>
References: <CAJna-HjwMRff_+7BvcR2YME9f2yUQPvfKOGZ1qq9d0nOGqORkg@mail.gmail.com>
	<78662993-6C67-4480-8062-55CC9FA63908@bitsofproof.com>
	<54C26BFE.1080103@gmail.com>
	<CAJna-HiXxt5E=FBiDuWMCKrK4C0dcvhHEjTAoK3LGQLafJOqtQ@mail.gmail.com>
Message-ID: <954BF4E3-8DF2-4927-9E25-C5D66127FFA5@bitsofproof.com>

You mean an isolated signing device without memory right? 

An isolated node would still know the transactions substantiating its coins, why would it sign them away to fees ?

Tamas Blummer

On Jan 23, 2015, at 4:47 PM, slush <slush at centrum.cz> wrote:

> Correct, plus the most likely scenario in such attack is that the malware even don't push such tx with excessive fees to the network, but send it directly to attacker's pool/miner.
> 
> M.
> 
> On Fri, Jan 23, 2015 at 4:42 PM, Alan Reiner <etotheipi at gmail.com> wrote:
> Unfortunately, one major attack vector is someone isolating your node, getting you to sign away your whole wallet to fee, and then selling it to a mining pool to mine it before you can figure why your transactions aren't making it to the network.  In such an attack, the relay rules aren't relevant, and if the attacker can DoS you for 24 hours, it doesn't take a ton of mining power to make the attack extremely likely to succeed.
> 
> 
> 
> 
> On 01/23/2015 10:31 AM, Tamas Blummer wrote:
>> Not a fix, but would reduce the financial risk, if nodes were not relaying excessive fee transactions.
>> 
>> Tamas Blummer
>> 
>> 
> 
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/5dc6f4b7/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 496 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/5dc6f4b7/attachment.sig>

From adam at cypherspace.org  Fri Jan 23 16:12:28 2015
From: adam at cypherspace.org (Adam Back)
Date: Fri, 23 Jan 2015 16:12:28 +0000
Subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE
In-Reply-To: <954BF4E3-8DF2-4927-9E25-C5D66127FFA5@bitsofproof.com>
References: <CAJna-HjwMRff_+7BvcR2YME9f2yUQPvfKOGZ1qq9d0nOGqORkg@mail.gmail.com>
	<78662993-6C67-4480-8062-55CC9FA63908@bitsofproof.com>
	<54C26BFE.1080103@gmail.com>
	<CAJna-HiXxt5E=FBiDuWMCKrK4C0dcvhHEjTAoK3LGQLafJOqtQ@mail.gmail.com>
	<954BF4E3-8DF2-4927-9E25-C5D66127FFA5@bitsofproof.com>
Message-ID: <CALqxMTGTUYgA9OebK7aaTnrMEf=OMaW=e36m_0BMyprCX=yFQw@mail.gmail.com>

its an always offline node, so it knows nothing really other than a
BIP 32 hierarchy of keys & a signature request.

So the signature request has to drag with it information to validate
what the value is, in order to be sure not to sign away 99% to fees.
Signing the transaction value and having the network validate that the
value in the sig matches full nodes view of the tx value avoids that
issue.  Simple, elegant, but... we have no live beta mechanism, and
hence risk & testing makes that tricky.  Plus the full network upgrade
issue if its not backwards compatible.

Adam

On 23 January 2015 at 16:08, Tamas Blummer <tamas at bitsofproof.com> wrote:
> You mean an isolated signing device without memory right?
>
> An isolated node would still know the transactions substantiating its coins,
> why would it sign them away to fees ?
>
> Tamas Blummer
>
> On Jan 23, 2015, at 4:47 PM, slush <slush at centrum.cz> wrote:
>
> Correct, plus the most likely scenario in such attack is that the malware
> even don't push such tx with excessive fees to the network, but send it
> directly to attacker's pool/miner.
>
> M.
>
> On Fri, Jan 23, 2015 at 4:42 PM, Alan Reiner <etotheipi at gmail.com> wrote:
>>
>> Unfortunately, one major attack vector is someone isolating your node,
>> getting you to sign away your whole wallet to fee, and then selling it to a
>> mining pool to mine it before you can figure why your transactions aren't
>> making it to the network.  In such an attack, the relay rules aren't
>> relevant, and if the attacker can DoS you for 24 hours, it doesn't take a
>> ton of mining power to make the attack extremely likely to succeed.
>>
>>
>>
>>
>> On 01/23/2015 10:31 AM, Tamas Blummer wrote:
>>
>> Not a fix, but would reduce the financial risk, if nodes were not relaying
>> excessive fee transactions.
>>
>> Tamas Blummer
>>
>>
>>
>>
>
>
> ------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> http://p.sf.net/sfu/gigenet
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>



From adam at cypherspace.org  Fri Jan 23 16:17:25 2015
From: adam at cypherspace.org (Adam Back)
Date: Fri, 23 Jan 2015 16:17:25 +0000
Subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE
In-Reply-To: <CALqxMTGTUYgA9OebK7aaTnrMEf=OMaW=e36m_0BMyprCX=yFQw@mail.gmail.com>
References: <CAJna-HjwMRff_+7BvcR2YME9f2yUQPvfKOGZ1qq9d0nOGqORkg@mail.gmail.com>
	<78662993-6C67-4480-8062-55CC9FA63908@bitsofproof.com>
	<54C26BFE.1080103@gmail.com>
	<CAJna-HiXxt5E=FBiDuWMCKrK4C0dcvhHEjTAoK3LGQLafJOqtQ@mail.gmail.com>
	<954BF4E3-8DF2-4927-9E25-C5D66127FFA5@bitsofproof.com>
	<CALqxMTGTUYgA9OebK7aaTnrMEf=OMaW=e36m_0BMyprCX=yFQw@mail.gmail.com>
Message-ID: <CALqxMTH2F5-Aj+U-D5KAtbJAAejCxmKgi+8knYAmSKJ_De0kyg@mail.gmail.com>

Issues like that particular one (simple elegant fix, strong utility
justification) plus previously more privacy stuff (like committed tx,
homomorphic encrypted values) was what got me wondering about a way to
do a live beta (one-way peg) and then to get excited about the 2wp &
Greg's mechanism for that.

I think it would be hypothetically possible to make a "special"
singleton sidechain which is merge mined, and has a consensus rule to
require some proportion of reward be sent to it via coinbase tx (a
mechanism to address incentive incompatibility) and a general timeline
eg 12mo to next version +/- etc. might be an interesting thing to
explore as a place to store live versions of "hard fork wishlist"
items where people who need them early can help validate them.

I am not sure that helps the full network upgrade issue though.

Adam

On 23 January 2015 at 16:12, Adam Back <adam at cypherspace.org> wrote:
> its an always offline node, so it knows nothing really other than a
> BIP 32 hierarchy of keys & a signature request.
>
> So the signature request has to drag with it information to validate
> what the value is, in order to be sure not to sign away 99% to fees.
> Signing the transaction value and having the network validate that the
> value in the sig matches full nodes view of the tx value avoids that
> issue.  Simple, elegant, but... we have no live beta mechanism, and
> hence risk & testing makes that tricky.  Plus the full network upgrade
> issue if its not backwards compatible.
>
> Adam
>
> On 23 January 2015 at 16:08, Tamas Blummer <tamas at bitsofproof.com> wrote:
>> You mean an isolated signing device without memory right?
>>
>> An isolated node would still know the transactions substantiating its coins,
>> why would it sign them away to fees ?
>>
>> Tamas Blummer
>>
>> On Jan 23, 2015, at 4:47 PM, slush <slush at centrum.cz> wrote:
>>
>> Correct, plus the most likely scenario in such attack is that the malware
>> even don't push such tx with excessive fees to the network, but send it
>> directly to attacker's pool/miner.
>>
>> M.
>>
>> On Fri, Jan 23, 2015 at 4:42 PM, Alan Reiner <etotheipi at gmail.com> wrote:
>>>
>>> Unfortunately, one major attack vector is someone isolating your node,
>>> getting you to sign away your whole wallet to fee, and then selling it to a
>>> mining pool to mine it before you can figure why your transactions aren't
>>> making it to the network.  In such an attack, the relay rules aren't
>>> relevant, and if the attacker can DoS you for 24 hours, it doesn't take a
>>> ton of mining power to make the attack extremely likely to succeed.
>>>
>>>
>>>
>>>
>>> On 01/23/2015 10:31 AM, Tamas Blummer wrote:
>>>
>>> Not a fix, but would reduce the financial risk, if nodes were not relaying
>>> excessive fee transactions.
>>>
>>> Tamas Blummer
>>>
>>>
>>>
>>>
>>
>>
>> ------------------------------------------------------------------------------
>> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
>> GigeNET is offering a free month of service with a new server in Ashburn.
>> Choose from 2 high performing configs, both with 100TB of bandwidth.
>> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
>> http://p.sf.net/sfu/gigenet
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>



From slush at centrum.cz  Fri Jan 23 16:18:34 2015
From: slush at centrum.cz (slush)
Date: Fri, 23 Jan 2015 17:18:34 +0100
Subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE
In-Reply-To: <CAAS2fgQSAj=YHhtvy=MY9GvbEZNxtLUwzfrdPnSQBUKZYdj4oA@mail.gmail.com>
References: <CAJna-HjwMRff_+7BvcR2YME9f2yUQPvfKOGZ1qq9d0nOGqORkg@mail.gmail.com>
	<54C267A1.8090208@gmail.com>
	<CAAS2fgQSAj=YHhtvy=MY9GvbEZNxtLUwzfrdPnSQBUKZYdj4oA@mail.gmail.com>
Message-ID: <CAJna-HgL_-PTfmS-kA00DfZiZ8uPFqQTytihY6o8De5KVvDThw@mail.gmail.com>

On Fri, Jan 23, 2015 at 5:05 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:

> I think this is unreasonable. There is a straight-forward soft-fork
> approach which is safe (e.g. no risk of invalidating existing
> transactions). Yes, it means that you need to use newly created
> addresses to get coins that use the new signature type...


Can you send me any reference about this? Of course if that solves the
problem, hard fork would not be necessary anymore. I'm just not aware of
any.

Can you help me understand whats taking 40 minutes here? Thats a
> surprisingly high number, and so I'm wondering if I'm not missing
> something there.
>
>
To sign transaction with hundreds of inputs on device with limited memory
capabilities, I need to stream all previous transactions into device, for
every signed input.

That means roughly 200^2 transaction verifications for 200 inputs to sign.
Very slow, but does not limit the device for any particular size of signed
transaction.

Marek
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/26b40164/attachment.html>

From etotheipi at gmail.com  Fri Jan 23 16:23:06 2015
From: etotheipi at gmail.com (Alan Reiner)
Date: Fri, 23 Jan 2015 11:23:06 -0500
Subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE
In-Reply-To: <CAAS2fgQSAj=YHhtvy=MY9GvbEZNxtLUwzfrdPnSQBUKZYdj4oA@mail.gmail.com>
References: <CAJna-HjwMRff_+7BvcR2YME9f2yUQPvfKOGZ1qq9d0nOGqORkg@mail.gmail.com>	<54C267A1.8090208@gmail.com>
	<CAAS2fgQSAj=YHhtvy=MY9GvbEZNxtLUwzfrdPnSQBUKZYdj4oA@mail.gmail.com>
Message-ID: <54C2756A.2020907@gmail.com>


On 01/23/2015 11:05 AM, Gregory Maxwell wrote:
> On Fri, Jan 23, 2015 at 3:24 PM, Alan Reiner <etotheipi at gmail.com> wrote:
>> Unfortunately, it seems that there was no soft-fork way to achieve this
>> benefit, at least not one that had favorable properties.  Most of the
>> soft-fork variations of it required the coins being spent to have been
>> originated in a special way.  In other words, it would only work if the
>> coins had entered the wallet with some special, modified TxOut script.  So
>> it wouldn't work with existing coins, and would require senders to update
>> their software to reshape the way they send transactions to be compatible
>> with our goals.
> I think this is unreasonable. There is a straight-forward soft-fork
> approach which is safe (e.g. no risk of invalidating existing
> transactions). Yes, it means that you need to use newly created
> addresses to get coins that use the new signature type... but thats
> only the case for people who want the new capability. This is
> massively preferable to expecting _every_ _other_ user of the system
> (including miners, full nodes, etc.) to replace their software with an
> incompatible new version just to accommodate your transactions, for
> which they may care nothing about and which would otherwise not have
> any urgent need to change.
>
>


As far as I'm concerned, anything that requires the coins to originate
in the wallet with some special form is a non-starter.  The new SIGHASH
type allows you to sign transactions with any coins already in your
wallet, and imposes no requirements on anyone paying your cold wallet. 
Any such proposals that require origination structure means that 100% of
people paying you need to "be nice" and use this new script type, or
else you *have* to



From etotheipi at gmail.com  Fri Jan 23 16:27:27 2015
From: etotheipi at gmail.com (Alan Reiner)
Date: Fri, 23 Jan 2015 11:27:27 -0500
Subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE
In-Reply-To: <CAAS2fgQSAj=YHhtvy=MY9GvbEZNxtLUwzfrdPnSQBUKZYdj4oA@mail.gmail.com>
References: <CAJna-HjwMRff_+7BvcR2YME9f2yUQPvfKOGZ1qq9d0nOGqORkg@mail.gmail.com>	<54C267A1.8090208@gmail.com>
	<CAAS2fgQSAj=YHhtvy=MY9GvbEZNxtLUwzfrdPnSQBUKZYdj4oA@mail.gmail.com>
Message-ID: <54C2766F.6030200@gmail.com>


On 01/23/2015 11:05 AM, Gregory Maxwell wrote:
> On Fri, Jan 23, 2015 at 3:24 PM, Alan Reiner <etotheipi at gmail.com> wrote:
>> Unfortunately, it seems that there was no soft-fork way to achieve this
>> benefit, at least not one that had favorable properties.  Most of the
>> soft-fork variations of it required the coins being spent to have been
>> originated in a special way.  In other words, it would only work if the
>> coins had entered the wallet with some special, modified TxOut script.  So
>> it wouldn't work with existing coins, and would require senders to update
>> their software to reshape the way they send transactions to be compatible
>> with our goals.
> I think this is unreasonable. There is a straight-forward soft-fork
> approach which is safe (e.g. no risk of invalidating existing
> transactions). Yes, it means that you need to use newly created
> addresses to get coins that use the new signature type... but thats
> only the case for people who want the new capability. This is
> massively preferable to expecting _every_ _other_ user of the system
> (including miners, full nodes, etc.) to replace their software with an
> incompatible new version just to accommodate your transactions, for
> which they may care nothing about and which would otherwise not have
> any urgent need to change.
>
>


As far as I'm concerned, anything that requires the coins to originate
in the wallet with some special form is a non-starter.  The new SIGHASH
type allows you to sign transactions with *any* coins already in your
wallet, and imposes no requirements on anyone paying your cold wallet to
be compatible with your signer. 

Any proposals that require coin origination features means that 100% of
people paying you need to "be nice" and send you coins with this special
structure.  You can't spend old coins that were sent before this
proposal was implemented, and if anyone sends you coins without
respecting the new structure, then your signing devices need the
full-complexity routines to accommodate, which defeats the entire purpose.

I am happy to entertain other ideas that achieve our goals here, but I'm
fairly confident that the new SIGHASH type is the only way that would
allow devices like Trezor to truly simplify their design (and still work
securely on 100% of funds contained by the wallet).




From etotheipi at gmail.com  Fri Jan 23 16:33:54 2015
From: etotheipi at gmail.com (Alan Reiner)
Date: Fri, 23 Jan 2015 11:33:54 -0500
Subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE
In-Reply-To: <54C2766F.6030200@gmail.com>
References: <CAJna-HjwMRff_+7BvcR2YME9f2yUQPvfKOGZ1qq9d0nOGqORkg@mail.gmail.com>	<54C267A1.8090208@gmail.com>
	<CAAS2fgQSAj=YHhtvy=MY9GvbEZNxtLUwzfrdPnSQBUKZYdj4oA@mail.gmail.com>
	<54C2766F.6030200@gmail.com>
Message-ID: <54C277F2.7010905@gmail.com>


On 01/23/2015 11:27 AM, Alan Reiner wrote:
>
> I am happy to entertain other ideas that achieve our goals here, but I'm
> fairly confident that the new SIGHASH type is the only way that would
> allow devices like Trezor to truly simplify their design (and still work
> securely on 100% of funds contained by the wallet).
>
 
Self-correction ... I didn't mean it's the "only way", I mean it's by
far the easiest, simplest, least-intrusive way that achieves the
properties we need for this to be useful.



From slush at centrum.cz  Fri Jan 23 16:35:23 2015
From: slush at centrum.cz (slush)
Date: Fri, 23 Jan 2015 17:35:23 +0100
Subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE
In-Reply-To: <54C2766F.6030200@gmail.com>
References: <CAJna-HjwMRff_+7BvcR2YME9f2yUQPvfKOGZ1qq9d0nOGqORkg@mail.gmail.com>
	<54C267A1.8090208@gmail.com>
	<CAAS2fgQSAj=YHhtvy=MY9GvbEZNxtLUwzfrdPnSQBUKZYdj4oA@mail.gmail.com>
	<54C2766F.6030200@gmail.com>
Message-ID: <CAJna-Hi4nUGoOm7ON=jbp-SFVO5-nrMMyNKNV6AYP0hJG_PZdw@mail.gmail.com>

Oh, now I got the 'soft-fork' alternative. If that means that *senders* to
Trezor need to be nice guys and use some special outputs, then it's,
obviously, no-go solution.

I understand political aspect around hard-fork. Anyway, are there any other
pending projects waiting for hard-fork? Maybe we should join our effort in
some way.

M.

On Fri, Jan 23, 2015 at 5:27 PM, Alan Reiner <etotheipi at gmail.com> wrote:

>
> I am happy to entertain other ideas that achieve our goals here, but I'm
> fairly confident that the new SIGHASH type is the only way that would
> allow devices like Trezor to truly simplify their design (and still work
> securely on 100% of funds contained by the wallet).
>
>
>
> ------------------------------------------------------------------------------
> New Year. New Location. New Benefits. New Data Center in Ashburn, VA.
> GigeNET is offering a free month of service with a new server in Ashburn.
> Choose from 2 high performing configs, both with 100TB of bandwidth.
> Higher redundancy.Lower latency.Increased capacity.Completely compliant.
> http://p.sf.net/sfu/gigenet
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/be814f81/attachment.html>

From gmaxwell at gmail.com  Fri Jan 23 16:52:28 2015
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Fri, 23 Jan 2015 16:52:28 +0000
Subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE
In-Reply-To: <CAJna-HgL_-PTfmS-kA00DfZiZ8uPFqQTytihY6o8De5KVvDThw@mail.gmail.com>
References: <CAJna-HjwMRff_+7BvcR2YME9f2yUQPvfKOGZ1qq9d0nOGqORkg@mail.gmail.com>
	<54C267A1.8090208@gmail.com>
	<CAAS2fgQSAj=YHhtvy=MY9GvbEZNxtLUwzfrdPnSQBUKZYdj4oA@mail.gmail.com>
	<CAJna-HgL_-PTfmS-kA00DfZiZ8uPFqQTytihY6o8De5KVvDThw@mail.gmail.com>
Message-ID: <CAAS2fgSKBS9zCQqp+hJUF2Ro8LNw4s0=J08M=76sOJmNfpLptQ@mail.gmail.com>

On Fri, Jan 23, 2015 at 4:18 PM, slush <slush at centrum.cz> wrote:
> Can you send me any reference about this? Of course if that solves the
> problem, hard fork would not be necessary anymore. I'm just not aware of
> any.

Sure; will aggregate up the citations when I'm not travling later today.

> To sign transaction with hundreds of inputs on device with limited memory
> capabilities, I need to stream all previous transactions into device, for
> every signed input.
>
> That means roughly 200^2 transaction verifications for 200 inputs to sign.
> Very slow, but does not limit the device for any particular size of signed
> transaction.

I'm not sure where the ^2 is coming from.  So what I'd understand that
you'd do is stream in the input txid:vouts which you spend, then you'd
stream the actual inputs which would just be hashed and value
extracted (but no other verification), and you'd build a table of
txid:vout->value, then the actual transaction to be signed.

This should have O(inputs) hashing and communications overhead. Is
there a step I'm missing?



From slush at centrum.cz  Fri Jan 23 17:40:54 2015
From: slush at centrum.cz (slush)
Date: Fri, 23 Jan 2015 18:40:54 +0100
Subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE
In-Reply-To: <CAAS2fgSKBS9zCQqp+hJUF2Ro8LNw4s0=J08M=76sOJmNfpLptQ@mail.gmail.com>
References: <CAJna-HjwMRff_+7BvcR2YME9f2yUQPvfKOGZ1qq9d0nOGqORkg@mail.gmail.com>
	<54C267A1.8090208@gmail.com>
	<CAAS2fgQSAj=YHhtvy=MY9GvbEZNxtLUwzfrdPnSQBUKZYdj4oA@mail.gmail.com>
	<CAJna-HgL_-PTfmS-kA00DfZiZ8uPFqQTytihY6o8De5KVvDThw@mail.gmail.com>
	<CAAS2fgSKBS9zCQqp+hJUF2Ro8LNw4s0=J08M=76sOJmNfpLptQ@mail.gmail.com>
Message-ID: <CAJna-Hi1PaJ-Xxr+quubtOVrhv-KPxkbC=jhNU5cm43GOnb67A@mail.gmail.com>

Yes, the step you're missing is "and build the table". Dynamic memory
allocation is something you want to avoid, as well as any artifical
restrictions to number of inputs or outputs. Current solution is slow, but
there's really no limitation on tx size.

Plus there're significant restrictions to memory in embedded world.
Actually TREZOR uses pretty powerful (and expensive) MCU just because it
needs to do such validations and calculate such hashes. With
SIGHASH_WITHINPUTVALUE or similar we may cut hardware cost significantly.

Marek

On Fri, Jan 23, 2015 at 5:52 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:

> I'm not sure where the ^2 is coming from.  So what I'd understand that
> you'd do is stream in the input txid:vouts which you spend, then you'd
> stream the actual inputs which would just be hashed and value
> extracted (but no other verification), and you'd build a table of
> txid:vout->value, then the actual transaction to be signed.
>
> This should have O(inputs) hashing and communications overhead. Is
> there a step I'm missing?
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/20ba09ee/attachment.html>

From pete at petertodd.org  Fri Jan 23 17:49:59 2015
From: pete at petertodd.org (Peter Todd)
Date: Fri, 23 Jan 2015 09:49:59 -0800
Subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE
In-Reply-To: <CAJna-Hi4nUGoOm7ON=jbp-SFVO5-nrMMyNKNV6AYP0hJG_PZdw@mail.gmail.com>
References: <CAJna-HjwMRff_+7BvcR2YME9f2yUQPvfKOGZ1qq9d0nOGqORkg@mail.gmail.com>
	<54C267A1.8090208@gmail.com>
	<CAAS2fgQSAj=YHhtvy=MY9GvbEZNxtLUwzfrdPnSQBUKZYdj4oA@mail.gmail.com>
	<54C2766F.6030200@gmail.com>
	<CAJna-Hi4nUGoOm7ON=jbp-SFVO5-nrMMyNKNV6AYP0hJG_PZdw@mail.gmail.com>
Message-ID: <087FD04D-4DBA-4E93-AA84-FD77AA9FE136@petertodd.org>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256



On 23 January 2015 08:35:23 GMT-08:00, slush <slush at centrum.cz> wrote:
>Oh, now I got the 'soft-fork' alternative. If that means that *senders*
>to
>Trezor need to be nice guys and use some special outputs, then it's,
>obviously, no-go solution.

That's what P2SH is for; the senders will just be sending to a P2SH address.

>I understand political aspect around hard-fork. Anyway, are there any
>other
>pending projects waiting for hard-fork?

Hard-forks aren't hard for directly political issues, they're politically hard because they're risky by requiring everyone yo upgrade at once. In the case of signature validation, that touches a *lot* of third party code that people rely on to avoid being defrauded.

FWIW I've actually got a half-finished writeup for how to use OP_CODESEPARATOR and a CHECKSIG2 soft-fork to have signatures sign fees and so forth.
-----BEGIN PGP SIGNATURE-----
Version: APG v1.1.1

iQFQBAEBCAA6BQJUwonGMxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8
cGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhbwkCADP7AcJ6a6V/y7MHt2x
ZiCXYsfHq5j03kbSWXGi1Q/9RqWGVha1fhWPp62yhDxbWOfh5QKauCbrt2g1AqT3
xbnh+2XE1rApBQIiJ6u0wZmpCi+4EhH2M9R8UYu9oIMzBe4K2jhzUbzcOR9Qplyq
9j6yevNrvtNHZb2OTiaKelxnuZUEiAsONHPOvR8Fkflwbd/w279OeilRjHYt3A/J
U22KOwjNrpa7/QE/HeC0QINqr3S132Yg4iYFwPviBwGq/WXQuLHIzGtgKOzrIC1T
h6kpWO9CjSxVbjMrf68IrSHRv92K8y1LiHFRZvzp3ulzcGBo2btazmrp/fUDLCr0
6uFg
=uDeM
-----END PGP SIGNATURE-----




From gmaxwell at gmail.com  Fri Jan 23 18:51:06 2015
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Fri, 23 Jan 2015 18:51:06 +0000
Subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE
In-Reply-To: <CAJna-Hi1PaJ-Xxr+quubtOVrhv-KPxkbC=jhNU5cm43GOnb67A@mail.gmail.com>
References: <CAJna-HjwMRff_+7BvcR2YME9f2yUQPvfKOGZ1qq9d0nOGqORkg@mail.gmail.com>
	<54C267A1.8090208@gmail.com>
	<CAAS2fgQSAj=YHhtvy=MY9GvbEZNxtLUwzfrdPnSQBUKZYdj4oA@mail.gmail.com>
	<CAJna-HgL_-PTfmS-kA00DfZiZ8uPFqQTytihY6o8De5KVvDThw@mail.gmail.com>
	<CAAS2fgSKBS9zCQqp+hJUF2Ro8LNw4s0=J08M=76sOJmNfpLptQ@mail.gmail.com>
	<CAJna-Hi1PaJ-Xxr+quubtOVrhv-KPxkbC=jhNU5cm43GOnb67A@mail.gmail.com>
Message-ID: <CAAS2fgThuM90uy7fUKxTY_h==S6VwEnYE5m3NBPJZEUtVjAK0w@mail.gmail.com>

On Fri, Jan 23, 2015 at 5:40 PM, slush <slush at centrum.cz> wrote:
> Yes, the step you're missing is "and build the table". Dynamic memory
> allocation is something you want to avoid, as well as any artifical
> restrictions to number of inputs or outputs. Current solution is slow, but
> there's really no limitation on tx size.
>
> Plus there're significant restrictions to memory in embedded world. Actually
> TREZOR uses pretty powerful (and expensive) MCU just because it needs to do
> such validations and calculate such hashes. With SIGHASH_WITHINPUTVALUE or
> similar we may cut hardware cost significantly.

I'm quite familiar with embedded development :), and indeed trezor MCU
is what I would generally consider (over-)powered which is why I was
somewhat surprised by the numbers; I'm certainly not expecting you to
perform dynamic allocation... but wasn't clear on how 40 minutes and
was I just trying to understand. Using a table to avoid retransmitting
reused transactions is just an optimization and can be done in
constant memory (e.g. falling back to retransmission if filled).

So what I'm understanding now is that you stream the transaction along
with its inputs interleaved in order to reduce the memory requirement
to two midstates and a value accumulator; requiring resending the
transaction... so in the worst case transaction (since you can't get
in more than about 800 inputs at the maximum transaction size) each
input spending from (one or more, since even one would be repeated)
100kb input transactions you might send about 800MBytes of data, which
could take a half an hour if hashing runs at 45KB/s or slower?

(If so, okay then there isn't another thing that I was missing).



From slush at centrum.cz  Fri Jan 23 19:19:40 2015
From: slush at centrum.cz (slush)
Date: Fri, 23 Jan 2015 20:19:40 +0100
Subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE
In-Reply-To: <CAAS2fgThuM90uy7fUKxTY_h==S6VwEnYE5m3NBPJZEUtVjAK0w@mail.gmail.com>
References: <CAJna-HjwMRff_+7BvcR2YME9f2yUQPvfKOGZ1qq9d0nOGqORkg@mail.gmail.com>
	<54C267A1.8090208@gmail.com>
	<CAAS2fgQSAj=YHhtvy=MY9GvbEZNxtLUwzfrdPnSQBUKZYdj4oA@mail.gmail.com>
	<CAJna-HgL_-PTfmS-kA00DfZiZ8uPFqQTytihY6o8De5KVvDThw@mail.gmail.com>
	<CAAS2fgSKBS9zCQqp+hJUF2Ro8LNw4s0=J08M=76sOJmNfpLptQ@mail.gmail.com>
	<CAJna-Hi1PaJ-Xxr+quubtOVrhv-KPxkbC=jhNU5cm43GOnb67A@mail.gmail.com>
	<CAAS2fgThuM90uy7fUKxTY_h==S6VwEnYE5m3NBPJZEUtVjAK0w@mail.gmail.com>
Message-ID: <CAJna-Hi3Q8vxFXRemmdnd131Bcq7RYrdfizbOt0oGXuDQFW3pw@mail.gmail.com>

You're right, there can be done some optimizations. Workarounds of
workaround. All this adds complexity, which reduces the security.

Marek

On Fri, Jan 23, 2015 at 7:51 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:

> On Fri, Jan 23, 2015 at 5:40 PM, slush <slush at centrum.cz> wrote:
> > Yes, the step you're missing is "and build the table". Dynamic memory
> > allocation is something you want to avoid, as well as any artifical
> > restrictions to number of inputs or outputs. Current solution is slow,
> but
> > there's really no limitation on tx size.
> >
> > Plus there're significant restrictions to memory in embedded world.
> Actually
> > TREZOR uses pretty powerful (and expensive) MCU just because it needs to
> do
> > such validations and calculate such hashes. With SIGHASH_WITHINPUTVALUE
> or
> > similar we may cut hardware cost significantly.
>
> I'm quite familiar with embedded development :), and indeed trezor MCU
> is what I would generally consider (over-)powered which is why I was
> somewhat surprised by the numbers; I'm certainly not expecting you to
> perform dynamic allocation... but wasn't clear on how 40 minutes and
> was I just trying to understand. Using a table to avoid retransmitting
> reused transactions is just an optimization and can be done in
> constant memory (e.g. falling back to retransmission if filled).
>
> So what I'm understanding now is that you stream the transaction along
> with its inputs interleaved in order to reduce the memory requirement
> to two midstates and a value accumulator; requiring resending the
> transaction... so in the worst case transaction (since you can't get
> in more than about 800 inputs at the maximum transaction size) each
> input spending from (one or more, since even one would be repeated)
> 100kb input transactions you might send about 800MBytes of data, which
> could take a half an hour if hashing runs at 45KB/s or slower?
>
> (If so, okay then there isn't another thing that I was missing).
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150123/c2669876/attachment.html>

From cryptocurrencies at quidecco.de  Sat Jan 24 13:19:34 2015
From: cryptocurrencies at quidecco.de (Isidor Zeuner)
Date: Sat, 24 Jan 2015 14:19:34 +0100 (CET)
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
 encoding?
In-Reply-To: <54BD7024.5070008@jrn.me.uk>
References: <54BD7024.5070008@jrn.me.uk>
	<CANEZrP3ZdFcQsP+EWgTYQDccFZbrZFTk+xi-YdWPCJzMRH79pA@mail.gmail.com>
Message-ID: <20150124131934.C9E6FE2A9B0@quidecco.de>

> For what it's worth, there was consideration of replacing protocol
> buffers when modifying BIP70 to function with the altcoin I work on
> (changes were required anyway in eliminate any risk that payment
> requests could not be accidentally applied to the wrong blockchain).

Why not serialize some kind of blockchain identifier with the
messages? Arbitrarily deviating from a given design choice just for
the sake of doing it differently may serve the goal of creating more
overall code diversity, but would not necessarily serve the quality of
the blockchain network where it is done for.

Best regards,

Isidor



From pieter.wuille at gmail.com  Sun Jan 25 14:34:08 2015
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Sun, 25 Jan 2015 10:34:08 -0400
Subject: [Bitcoin-development] [softfork proposal] Strict DER signatures
In-Reply-To: <87egqnwt7g.fsf@rustcorp.com.au>
References: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
	<87egqnwt7g.fsf@rustcorp.com.au>
Message-ID: <CAPg+sBjQAi_hCcoV0gecVQAd4PYKzRd5F_nymz8UVt9BFg8O2Q@mail.gmail.com>

On Wed, Jan 21, 2015 at 8:32 PM, Rusty Russell <rusty at rustcorp.com.au> wrote:
> One weirdness is the restriction on maximum total length, rather than a
> 32 byte (33 with 0-prepad) limit on signatures themselves.

Glad that you point this out; I believe that's a weakness with more
impact now that this function is used for consensus. Let me clarify.

This function was originally written for Bitcoin Core v0.8.0, where it
was only used to enforce non-standardness, not consensus. In that
setting, there was no need to require a maximum length for the R and S
arguments, as overly-long R or S values (which, because of a further
rule, do not have excessive padding) will always result in integers >=
2^256, which means the encoded signature would never be valid
according to the ECDSA specification. A restriction on the total
length is required however, as BER allows multi-byte length
descriptors, which this function cannot (and shouldn't, as it's not
DER) parse.

However, in the currently proposed soft fork, non-DER results in
immediate script failure, which is distinguishable from invalid
signatures (by negating the result of a CHECKSIG, for example using a
NOT after it). I must admit that having invalid signatures with
overly-long R or S but acceptable R+S size be distinguishable from
invalid signatures where R+S is too large is ugly, and unnecessary.

Adding individual R and S length restrictions (ideally: saying that no
more than 32 bytes, excluding the padding 0 byte in front, is invalid)
would be trivial, but it means deviating slightly from the
standardness rule implementation that has been deployed for a while.
There should not really be much risk in doing so, as there are still
no node implementation releases (apart from the v0.10.0 rc's) that
would mine a CHECKSIG whose result is negated.

So, I think there are two options:
* Just add this R/S length restriction rule as a standardness
requirement, but not make it part of the soft fork. A later softfork
can then add this easily. The same can be done for several other
changes if they are deemed useful, like only allowing 0 (the empty
array) as invalid signature (any other causes failure script
immediately), requiring correct encoding even for non-evaluated
signatures, ...
* Add it to the softfork now, and be done with it.

Opinions?

-- 
Pieter



From gmaxwell at gmail.com  Sun Jan 25 14:48:10 2015
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Sun, 25 Jan 2015 14:48:10 +0000
Subject: [Bitcoin-development] [softfork proposal] Strict DER signatures
In-Reply-To: <CAPg+sBjQAi_hCcoV0gecVQAd4PYKzRd5F_nymz8UVt9BFg8O2Q@mail.gmail.com>
References: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
	<87egqnwt7g.fsf@rustcorp.com.au>
	<CAPg+sBjQAi_hCcoV0gecVQAd4PYKzRd5F_nymz8UVt9BFg8O2Q@mail.gmail.com>
Message-ID: <CAAS2fgQjTq1M6fF5KDiZ-qBrCWjs9z5VKtj-c1ghRfDeK6iyPA@mail.gmail.com>

On Sun, Jan 25, 2015 at 2:34 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:
> * Add it to the softfork now, and be done with it.

Initially I was of the opinion that we couldn't do that, because
soft-forks which hit transactions many nodes would relay+mine creates
a forking risk... but with the realization that imbalanced R/S plus
checksig-not would only be work with 0.10rc/git changed my mind.
Unlike two years ago miners no longer appear to be racing the bleeding
edge, and it's never show up in a release. Obviously the next RC would
also make those non-standard. And then we'll have some non-trivial
amount of time before the soft-fork activates for whatever stragglers
there are on 0.10 prerelease code to update. The deployment of the
soft-fork rules themselves will already drive people to update.

In terms of being robust to implementation differences, not permitting
overlarge R/S is obviously prudent.

So I think we should just go ahead with R/S length upper bounds as
both IsStandard and in STRICTDER.



From pieter.wuille at gmail.com  Sun Jan 25 16:57:23 2015
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Sun, 25 Jan 2015 12:57:23 -0400
Subject: [Bitcoin-development] [softfork proposal] Strict DER signatures
In-Reply-To: <CAM_a8Jzt=Q8m=-7wur1UdscqQRQmg+TBFNtneUtRH3nh+TOTDQ@mail.gmail.com>
References: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
	<CAM_a8Jzt=Q8m=-7wur1UdscqQRQmg+TBFNtneUtRH3nh+TOTDQ@mail.gmail.com>
Message-ID: <CAPg+sBi7OnV9Tm06VBoHv54opQy3RJHzmyD+imcaUq8sEw=6qQ@mail.gmail.com>

On Thu, Jan 22, 2015 at 6:41 PM, Zooko Wilcox-OHearn
<zooko at leastauthority.com> wrote:
> * Should the bipstrictder give a rationale or link to why accept the
> 0-length sig as correctly-encoded-but-invalid? I guess the rationale
> is an efficiency issue as described in the log entry for
> https://github.com/sipa/bitcoin/commit/041f1e3597812c250ebedbd8f4ef1565591d2c34

I've lately been updating the BIP text without updating the code in
the repository; I've synced them now. The sigsize=0 case was actually
already handled elsewhere already, so I removed the code and added a
comment about it now in the BIP text.

> * Does this mean there are still multiple ways to encode a correctly
> encoded but invalid signature, one of which is the 0-length string?
> Would it make sense for this change to also treat any *other*
> correctly-encoded-but-invalid sig (besides the 0-length string) as
> incorrectly-encoded? Did I just step in some BIP62?

You didn't miss anything; that's correct. In fact, Peter Todd already
pointed out the possibility of making non-empty invalid signatures
illegal. The reason for not doing it yet is that I'd like this BIP to
be minimal and uncontroversial - it's a real problem we want to fix as
fast as is reasonable. It wouldn't be hard to make this a standardness
rule though, and perhaps later softfork it in as consensus rule if
there was sufficient agreement about it.

> * It would be good to verify that all the branches of the new
> IsDERSignature() from
> https://github.com/sipa/bitcoin/commit/0c427135151a6bed657438ffb2e670be84eb3642
> are tested by the test vectors in
> https://github.com/sipa/bitcoin/commit/f94e806f8bfa007a3de4b45fa3c9860f2747e427
> . Eyeballing it, there are about 20 branches touched by the patch, and
> about 24 new test vectors.

A significiant part of DERSIG behaviour (which didn't change, only the
cases in which it is enforced) was already tested, in fact. Some
branches remained untested however; I've added extra test cases in the
repository. They give 100% coverage for IsValidSignatureEncoding (the
new name for IsDERSignature) now (tested with gcov).

> * It would be good to finish the TODOs in
> https://github.com/sipa/bitcoin/commit/b7986119a5d41337fea1e83804ed6223438158ec
> so that it was actually testing the upgrade behavior.

I agree, but that requires very significant changes to the codebase,
as we currently have no way to mine blocks with non-acceptable
transactions. Ideally, the RPC tests gain some means of
building/mining blocks from without the Python test framework. Things
like that would make the code changes also hard to backport, which we
definitely will need to do to roll this out quickly.

> * missing comment:
> https://github.com/sipa/bitcoin/commit/e186f6a80161f9fa45fbced82ab1d22f081b942c#commitcomment-9406643

Fixed.

> Okay, that's all I've got. Hope it helps! Thanks again for your good work!

Thanks!

-- 
Pieter



From jrn at jrn.me.uk  Sun Jan 25 22:59:37 2015
From: jrn at jrn.me.uk (Ross Nicoll)
Date: Sun, 25 Jan 2015 22:59:37 +0000
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
 encoding?
In-Reply-To: <20150124131934.C9E6FE2A9B0@quidecco.de>
References: <54BD7024.5070008@jrn.me.uk>
	<CANEZrP3ZdFcQsP+EWgTYQDccFZbrZFTk+xi-YdWPCJzMRH79pA@mail.gmail.com>
	<20150124131934.C9E6FE2A9B0@quidecco.de>
Message-ID: <54C57559.3090205@jrn.me.uk>

That was essentially what we did in the end, we replaced the network
identifier ("main"/"test") with the genesis block hash. The result is
never going to accidentally work with Bitcoin Core (nor vice-versa), but
is readily extensible to any other altcoins that want to use the
specification without requiring any sort of central registry.

Ross

On 24/01/15 13:19, Isidor Zeuner wrote:
>> For what it's worth, there was consideration of replacing protocol
>> buffers when modifying BIP70 to function with the altcoin I work on
>> (changes were required anyway in eliminate any risk that payment
>> requests could not be accidentally applied to the wrong blockchain).
>
> Why not serialize some kind of blockchain identifier with the
> messages? Arbitrarily deviating from a given design choice just for
> the sake of doing it differently may serve the goal of creating more
> overall code diversity, but would not necessarily serve the quality of
> the blockchain network where it is done for.
>
> Best regards,
>
> Isidor




From pieter.wuille at gmail.com  Mon Jan 26 05:14:39 2015
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Mon, 26 Jan 2015 01:14:39 -0400
Subject: [Bitcoin-development] [softfork proposal] Strict DER signatures
In-Reply-To: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
References: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
Message-ID: <CAPg+sBj62GwsBAEpTPWR+Lk4xgT1snUHt=3QpHQwTpCxKXzmAQ@mail.gmail.com>

On Tue, Jan 20, 2015 at 8:35 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:
> I therefore propose a softfork to make non-DER signatures illegal
> (they've been non-standard since v0.8.0). A draft BIP text can be
> found on:
>
>     https://gist.github.com/sipa/5d12c343746dad376c80

I'd like to request a BIP number for this.

-- 
Pieter



From gmaxwell at gmail.com  Mon Jan 26 18:35:47 2015
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Mon, 26 Jan 2015 18:35:47 +0000
Subject: [Bitcoin-development] [softfork proposal] Strict DER signatures
In-Reply-To: <CAPg+sBj62GwsBAEpTPWR+Lk4xgT1snUHt=3QpHQwTpCxKXzmAQ@mail.gmail.com>
References: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
	<CAPg+sBj62GwsBAEpTPWR+Lk4xgT1snUHt=3QpHQwTpCxKXzmAQ@mail.gmail.com>
Message-ID: <CAAS2fgRy0-ORuZ-o02uszqRE+9e5sZNf-OewmsZFoHZpem8mcA@mail.gmail.com>

On Mon, Jan 26, 2015 at 5:14 AM, Pieter Wuille <pieter.wuille at gmail.com> wrote:
> On Tue, Jan 20, 2015 at 8:35 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:
>> I therefore propose a softfork to make non-DER signatures illegal
>> (they've been non-standard since v0.8.0). A draft BIP text can be
>> found on:
>>
>>     https://gist.github.com/sipa/5d12c343746dad376c80
>
> I'd like to request a BIP number for this.

Sure. BIP0066. There was also some feedback on Bitcointalk, which I
think you've addressed:
https://bitcointalk.org/index.php?topic=932054.0 I also had off-list
positive feedback from Amir Taak, so we have positive feedback from
several implementers.

One of the points that was raised which we'd discussed pre-proposal
that was brought up there that I thought I should summarize here was
the possibility that someone had previously authored an nlocked spend
with an invalidly encoded signature. In those cases the signature can
just be mutated to get it mined, and would need to be already to pass
IsStandard rules. A case that isn't covered if if they have a chain of
transactions after that nlocked transaction, but those cases would
already be at extreme risk of malleability (esp since their unchanged
form is non-standard), and that coupled with the fact that avoiding
this would undermine the intent of the BIP (independence from  a
specific encoding scheme) seems to have been convincing as much.



From laanwj at gmail.com  Wed Jan 28 06:24:06 2015
From: laanwj at gmail.com (Wladimir)
Date: Wed, 28 Jan 2015 07:24:06 +0100 (CET)
Subject: [Bitcoin-development] [softfork proposal] Strict DER signatures
In-Reply-To: <CAAS2fgRy0-ORuZ-o02uszqRE+9e5sZNf-OewmsZFoHZpem8mcA@mail.gmail.com>
References: <CAPg+sBhk7F2OHT64i2LNSjv8DR5tD3RJkLJGzPGZW8OPQTCjQw@mail.gmail.com>
	<CAPg+sBj62GwsBAEpTPWR+Lk4xgT1snUHt=3QpHQwTpCxKXzmAQ@mail.gmail.com>
	<CAAS2fgRy0-ORuZ-o02uszqRE+9e5sZNf-OewmsZFoHZpem8mcA@mail.gmail.com>
Message-ID: <alpine.DEB.2.10.1501280723121.21680@nzrgulfg.ivfhpber.pbz>


On Mon, 26 Jan 2015, Gregory Maxwell wrote:

> On Mon, Jan 26, 2015 at 5:14 AM, Pieter Wuille <pieter.wuille at gmail.com> wrote:
>> On Tue, Jan 20, 2015 at 8:35 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:
>>> I therefore propose a softfork to make non-DER signatures illegal
>>> (they've been non-standard since v0.8.0). A draft BIP text can be
>>> found on:
>>>
>>>     https://gist.github.com/sipa/5d12c343746dad376c80
>>
>> I'd like to request a BIP number for this.
>
> Sure. BIP0066. There was also some feedback on Bitcointalk, which I
> think you've addressed

Progress information for the list: there is now a pull request
implementing the strict DER verification behavior, as well as the
deployment specified in BIP66 for Bitcoin Core. It needs
your review and testing:

https://github.com/bitcoin/bitcoin/pull/5713

Wladimir



From nicolas.dorier at gmail.com  Wed Jan 28 12:45:29 2015
From: nicolas.dorier at gmail.com (Nicolas DORIER)
Date: Wed, 28 Jan 2015 13:45:29 +0100
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
Message-ID: <CALYO6Xt-jTYwpywUaH-s4YPYyGUp1_BLSEswscnwX+Vu166Lcw@mail.gmail.com>

I agree that the use protocol buffer and x509 by BIP70 is a poor choice.

The choice should have been done to maximize portability, not to maximize
efficiency and flexibility.

What I ended up doing for having a similar codebase on all plateform is to
parse a BIP70 messages with the help of a web service that convert it to
JSON.
I don't like this solution since it had a trust dependency, and the
certificate verification become handled by the web service, not the device.
But even if I solved google buffer problem, I would stumble upon having
headache to validate the x509 certificate chain on every plateforms.

A simple BIP70 using JSON + HTTPS would have make things more easy.
I agree that it requires that the merchant own the domain name of the BIP70
endpoint, but I don't consider such a big of a deal, since this is how
e-commerce works.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/6e5b0a0e/attachment.html>

From laanwj at gmail.com  Wed Jan 28 13:32:40 2015
From: laanwj at gmail.com (Wladimir)
Date: Wed, 28 Jan 2015 14:32:40 +0100 (CET)
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
 encoding?
In-Reply-To: <CALYO6Xt-jTYwpywUaH-s4YPYyGUp1_BLSEswscnwX+Vu166Lcw@mail.gmail.com>
References: <CALYO6Xt-jTYwpywUaH-s4YPYyGUp1_BLSEswscnwX+Vu166Lcw@mail.gmail.com>
Message-ID: <alpine.DEB.2.10.1501281419110.21680@nzrgulfg.ivfhpber.pbz>


On Wed, 28 Jan 2015, Nicolas DORIER wrote:

> I agree that the use protocol buffer and x509 by BIP70 is a poor choice.

Well x509 is an international standard in common use, you can't do much 
better with regard to portability. Your suggestion about HTTPS makes 
little sense, you do know what TLS uses x509 internally as well?

Re: protocol buffers, I don't know if it's the best possible one, but one 
serialization method had to be picked. If it weren't, we could still have 
still been discussing which one to use by now. Just like for JSON there 
are bindings for many languages.

Though JSON parsers are much more diverse, which people using Bitcoin 
Core's RPC have bumped into e.g. some have some problems 
handling large numbers. Something you wouldn't expect using a 
straightforward binary format. There's no obvious best choice.

Wladimir



From nicolas.dorier at gmail.com  Wed Jan 28 14:00:40 2015
From: nicolas.dorier at gmail.com (Nicolas DORIER)
Date: Wed, 28 Jan 2015 15:00:40 +0100
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <alpine.DEB.2.10.1501281419110.21680@nzrgulfg.ivfhpber.pbz>
References: <CALYO6Xt-jTYwpywUaH-s4YPYyGUp1_BLSEswscnwX+Vu166Lcw@mail.gmail.com>
	<alpine.DEB.2.10.1501281419110.21680@nzrgulfg.ivfhpber.pbz>
Message-ID: <CALYO6Xv=k+Ztvke90SDB91StFBL7C0U49ufMD-WjG91uHLshFg@mail.gmail.com>

Sure I know that x509 is international standard. And that HTTPS uses TLS.
This is not my point, my point is that when we use HTTPS the developer
delegates certificates verification to the plateform he is running on, so
developer don't have to bother about it, making the implementation safer
and easier.

On the other hand, if you charge the developer (and not the plateform) to
check certificate validity, it means that you have to develop a different
codebase for all plateform you are targeting, because each plateform store
trusted root certificate in a different manner with different APIs, and
also have different types representing a X509 Certificate.

So, let's say I want to target IOS + WP + Android + WinRT + desktop win, I
need to develop 4 times chain verification and certificate parsing.
(Because I can't verify a certificate if it is not in the specific type of
the underlying plateform)

And since it would take too much time to do that, I end up delegating
parsing and trust verification to a third party service.

2015-01-28 14:32 GMT+01:00 Wladimir <laanwj at gmail.com>:

>
> On Wed, 28 Jan 2015, Nicolas DORIER wrote:
>
>  I agree that the use protocol buffer and x509 by BIP70 is a poor choice.
>>
>
> Well x509 is an international standard in common use, you can't do much
> better with regard to portability. Your suggestion about HTTPS makes little
> sense, you do know what TLS uses x509 internally as well?
>
> Re: protocol buffers, I don't know if it's the best possible one, but one
> serialization method had to be picked. If it weren't, we could still have
> still been discussing which one to use by now. Just like for JSON there are
> bindings for many languages.
>
> Though JSON parsers are much more diverse, which people using Bitcoin
> Core's RPC have bumped into e.g. some have some problems handling large
> numbers. Something you wouldn't expect using a straightforward binary
> format. There's no obvious best choice.
>
> Wladimir
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/193f06f5/attachment.html>

From mike at plan99.net  Wed Jan 28 15:42:42 2015
From: mike at plan99.net (Mike Hearn)
Date: Wed, 28 Jan 2015 16:42:42 +0100
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <CALYO6Xv=k+Ztvke90SDB91StFBL7C0U49ufMD-WjG91uHLshFg@mail.gmail.com>
References: <CALYO6Xt-jTYwpywUaH-s4YPYyGUp1_BLSEswscnwX+Vu166Lcw@mail.gmail.com>
	<alpine.DEB.2.10.1501281419110.21680@nzrgulfg.ivfhpber.pbz>
	<CALYO6Xv=k+Ztvke90SDB91StFBL7C0U49ufMD-WjG91uHLshFg@mail.gmail.com>
Message-ID: <CANEZrP3PCHaTO3-HA3GHFxwuJJpW2dbvPuV4R1sFPcFW49uGgw@mail.gmail.com>

>
> On the other hand, if you charge the developer (and not the plateform) to
> check certificate validity, it means that you have to develop a different
> codebase for all plateform you are targeting, because each plateform store
> trusted root certificate in a different manner with different APIs, and
> also have different types representing a X509 Certificate.
>

That's what cross-platform abstraction libraries are for. Both Java and Qt
provide a key store library that can load from either the OS root store or
a custom one. If your chosen app platform doesn't, OK, then you'll have to
make or find one yourself. Perhaps contribute it upstream or make it a
library. But that's not a limitation of BIP70.

Just as a reminder, there is no obligation to use the OS root store. You
can (and quite possibly should) take a snapshot of the Mozilla/Apple/MSFT
etc stores and load it in your app. We do this in bitcoinj by default to
avoid cases where BIP70 requests work on some platforms and not others,
although the developer can easily override this and use the OS root store
instead.

Of all possible solutions, using a third party service to convert things to
JSON is one of the least obvious and highest effort. I don't know anyone
else who arrived at such a conclusion and respectfully disagree that this
is a problem with the design choices in BIP70. It sounds like a bizarre
hack around lack of features in whatever runtime you're using.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/aabfe25a/attachment.html>

From jgarzik at bitpay.com  Wed Jan 28 16:04:58 2015
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Wed, 28 Jan 2015 11:04:58 -0500
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <CANEZrP3PCHaTO3-HA3GHFxwuJJpW2dbvPuV4R1sFPcFW49uGgw@mail.gmail.com>
References: <CALYO6Xt-jTYwpywUaH-s4YPYyGUp1_BLSEswscnwX+Vu166Lcw@mail.gmail.com>
	<alpine.DEB.2.10.1501281419110.21680@nzrgulfg.ivfhpber.pbz>
	<CALYO6Xv=k+Ztvke90SDB91StFBL7C0U49ufMD-WjG91uHLshFg@mail.gmail.com>
	<CANEZrP3PCHaTO3-HA3GHFxwuJJpW2dbvPuV4R1sFPcFW49uGgw@mail.gmail.com>
Message-ID: <CAJHLa0Mu3Mjn=N-fTQ_fjwp+NUpfBqpdnXZiHoKz1s3tcZa+Cg@mail.gmail.com>

Not to mention the tiresome and error-prone task of writing your own
JSON-to-schema marshalling code -- or something equivalent to the protobufs
compiler and libs for JSON.

protobufs -- and its modern competitors such as msgpack -- natively provide
type support in a way that must be hacked into JSON or XML.

The protobuf/msgpack design is engineered to avoid bugs routinely found in
JSON parsing code; due to the amount of code & effort involved in JSON
input sanity checking, bugs and inconsistencies inevitable arise.  We have
seen this in bitcoind with JSON-RPC.



On Wed, Jan 28, 2015 at 10:42 AM, Mike Hearn <mike at plan99.net> wrote:

> On the other hand, if you charge the developer (and not the plateform) to
>> check certificate validity, it means that you have to develop a different
>> codebase for all plateform you are targeting, because each plateform store
>> trusted root certificate in a different manner with different APIs, and
>> also have different types representing a X509 Certificate.
>>
>
> That's what cross-platform abstraction libraries are for. Both Java and Qt
> provide a key store library that can load from either the OS root store or
> a custom one. If your chosen app platform doesn't, OK, then you'll have to
> make or find one yourself. Perhaps contribute it upstream or make it a
> library. But that's not a limitation of BIP70.
>
> Just as a reminder, there is no obligation to use the OS root store. You
> can (and quite possibly should) take a snapshot of the Mozilla/Apple/MSFT
> etc stores and load it in your app. We do this in bitcoinj by default to
> avoid cases where BIP70 requests work on some platforms and not others,
> although the developer can easily override this and use the OS root store
> instead.
>
> Of all possible solutions, using a third party service to convert things
> to JSON is one of the least obvious and highest effort. I don't know anyone
> else who arrived at such a conclusion and respectfully disagree that this
> is a problem with the design choices in BIP70. It sounds like a bizarre
> hack around lack of features in whatever runtime you're using.
>
>
>
> ------------------------------------------------------------------------------
> Dive into the World of Parallel Programming. The Go Parallel Website,
> sponsored by Intel and developed in partnership with Slashdot Media, is
> your
> hub for all things parallel software development, from weekly thought
> leadership blogs to news, videos, case studies, tutorials and more. Take a
> look and join the conversation now. http://goparallel.sourceforge.net/
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>


-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/328f8f70/attachment.html>

From nicolas.dorier at gmail.com  Wed Jan 28 16:34:26 2015
From: nicolas.dorier at gmail.com (Nicolas DORIER)
Date: Wed, 28 Jan 2015 17:34:26 +0100
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <CANEZrP3PCHaTO3-HA3GHFxwuJJpW2dbvPuV4R1sFPcFW49uGgw@mail.gmail.com>
References: <CALYO6Xt-jTYwpywUaH-s4YPYyGUp1_BLSEswscnwX+Vu166Lcw@mail.gmail.com>
	<alpine.DEB.2.10.1501281419110.21680@nzrgulfg.ivfhpber.pbz>
	<CALYO6Xv=k+Ztvke90SDB91StFBL7C0U49ufMD-WjG91uHLshFg@mail.gmail.com>
	<CANEZrP3PCHaTO3-HA3GHFxwuJJpW2dbvPuV4R1sFPcFW49uGgw@mail.gmail.com>
Message-ID: <CALYO6Xucf7xqE_4ykJqFyS_AEAT0X-1aGvYmA0WXzX7By0c0uQ@mail.gmail.com>

My point is not that there is a limitation in BIP70. My point is that you
put the burden of certificate verification on developer's shoulder when we
can just leverage built in HTTPS support of the platform.
This make cross plateform dev a nightmare.

Sure I can use a snapshot of moz/apple/msft store. I depends on
BouncyCastle, as bitcoinj, so I theorically can use that way.
However, if you want to use your plateform's store, then you are toasted,
and the code for converting from BC X509 Certificate to one of each
plateform is not obvious and is a headache. Thing that could be just left
to the HTTPS support of your plateform.

Have you tried to do that on windows RT and IOS ? I tried, and I quickly
stopped doing that since it is not worth the effort. (Frankly I am not even
sure you can on win rt, since the API is a stripped down version of windows)

Why have you not heard about the problem ? (until now, because I have this
problem because I need to have the same codebase on
winrt/win/android/ios/tablets)
Because bitcoinj just rely either java's own abstraction of certificate or
on BC one. But I highly doubt they are using the plateform store, and even
if you theorically can, dealing with X509 is very prone to error... for
something that the plateform should just do for you.
Also, you bundle mozilla's store in bitcoinj, what happen when the store
change and your customer have not intent to use bitcoinj new version ? by
leveraging the plateform you benefit from automatic updates.
Also, does java stores deals with certificate revocations ? sure you can
theorically code that too... or just let the plateform deals with it.

BIP70 does not limit to anything but it is a gigantic pain in the ass for
easy cross development because of protobuff and embedded certificates.
BIP70 is a client side technology, not a performance and storage critical
data structure.

The only valid point of having embedded certificates is to allow the owner
of the website to be different from the merchant. But since merchants often
have their own website, a protocol without having to reinvent x509 would
have been better suited to current needs.

2015-01-28 16:42 GMT+01:00 Mike Hearn <mike at plan99.net>:

> On the other hand, if you charge the developer (and not the plateform) to
>> check certificate validity, it means that you have to develop a different
>> codebase for all plateform you are targeting, because each plateform store
>> trusted root certificate in a different manner with different APIs, and
>> also have different types representing a X509 Certificate.
>>
>
> That's what cross-platform abstraction libraries are for. Both Java and Qt
> provide a key store library that can load from either the OS root store or
> a custom one. If your chosen app platform doesn't, OK, then you'll have to
> make or find one yourself. Perhaps contribute it upstream or make it a
> library. But that's not a limitation of BIP70.
>
> Just as a reminder, there is no obligation to use the OS root store. You
> can (and quite possibly should) take a snapshot of the Mozilla/Apple/MSFT
> etc stores and load it in your app. We do this in bitcoinj by default to
> avoid cases where BIP70 requests work on some platforms and not others,
> although the developer can easily override this and use the OS root store
> instead.
>
> Of all possible solutions, using a third party service to convert things
> to JSON is one of the least obvious and highest effort. I don't know anyone
> else who arrived at such a conclusion and respectfully disagree that this
> is a problem with the design choices in BIP70. It sounds like a bizarre
> hack around lack of features in whatever runtime you're using.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/8a32ba6e/attachment.html>

From giuseppe at bitonic.nl  Wed Jan 28 16:19:55 2015
From: giuseppe at bitonic.nl (Giuseppe Mazzotta)
Date: Wed, 28 Jan 2015 17:19:55 +0100
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
 encoding?
In-Reply-To: <CANEZrP3PCHaTO3-HA3GHFxwuJJpW2dbvPuV4R1sFPcFW49uGgw@mail.gmail.com>
References: <CALYO6Xt-jTYwpywUaH-s4YPYyGUp1_BLSEswscnwX+Vu166Lcw@mail.gmail.com>	<alpine.DEB.2.10.1501281419110.21680@nzrgulfg.ivfhpber.pbz>	<CALYO6Xv=k+Ztvke90SDB91StFBL7C0U49ufMD-WjG91uHLshFg@mail.gmail.com>
	<CANEZrP3PCHaTO3-HA3GHFxwuJJpW2dbvPuV4R1sFPcFW49uGgw@mail.gmail.com>
Message-ID: <54C90C2B.3090708@bitonic.nl>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

On 28-01-15 16:42, Mike Hearn wrote:
> Just as a reminder, there is no obligation to use the OS root
> store. You can (and quite possibly should) take a snapshot of the 
> Mozilla/Apple/MSFT etc stores and load it in your app. We do this
> in bitcoinj by default to avoid cases where BIP70 requests work on
> some platforms and not others, although the developer can easily
> override this and use the OS root store instead.
> 
Except that Mozilla/Apple/MSFT will update these certificate stores -
second their policies - and your snapshot/collection might get
outdated at a different pace than the OS-provided certificates,
depending on how you (or the package maintainer) are rolling out updates.

I am not saying that OS-provided certificate stores are a holy grail,
as they comes with their quirks&headaches (for example try to install
your CA certificate on Mac), but generally I consider shipping your
own snapshot a bad practice, as it makes the system less secure by
default for the casual user and harder to audit for the (eventual) admins.

If you are a developer, that's a whole different story.

- -- 
  Giuseppe Mazzotta
    /- Bitonic _/
-----BEGIN PGP SIGNATURE-----

iQEcBAEBCgAGBQJUyQwrAAoJEKWX1kB3NXekfLkH/3Bd2yPD0ccZRUzWJ47wQmFd
uRxpOjlxZMy3ww4PpxPxqJTrSwyH0gwbNCbuXkds9kkx9+AwxEkT8VZXZVA1KNeo
RaLNgqs4R5zK06shTjV+AXe5HwDCEeFuJIIRGM35D8kSKtbPuzKe5UtiIRaBRdZG
e+d6CQKklYK8yn24hUGg30Y0rEcrLicXmcJlrjElA+8pKYDIeP3SrMWjLj9QKFhJ
VBKxXlyviZ2LGf9wD6p+GLgjDu4LNEQdJPpTNzg7yWSegnKmxopefojkCrHtqJQ7
LC4Lr3K3hp5Nbct1YWRt09VQYic/xaGBCSUdKTEL1xTUv7oD/DY7l15zjKi7gtw=
=ZJVu
-----END PGP SIGNATURE-----



From bip at mattwhitlock.name  Wed Jan 28 16:51:06 2015
From: bip at mattwhitlock.name (Matt Whitlock)
Date: Wed, 28 Jan 2015 11:51:06 -0500
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <54C90C2B.3090708@bitonic.nl>
References: <CALYO6Xt-jTYwpywUaH-s4YPYyGUp1_BLSEswscnwX+Vu166Lcw@mail.gmail.com>
	<CANEZrP3PCHaTO3-HA3GHFxwuJJpW2dbvPuV4R1sFPcFW49uGgw@mail.gmail.com>
	<54C90C2B.3090708@bitonic.nl>
Message-ID: <2225268.rOb4P6uJX2@crushinator>

On Wednesday, 28 January 2015, at 5:19 pm, Giuseppe Mazzotta wrote:
> On 28-01-15 16:42, Mike Hearn wrote:
> > Just as a reminder, there is no obligation to use the OS root
> > store. You can (and quite possibly should) take a snapshot of the
> > Mozilla/Apple/MSFT etc stores and load it in your app. We do this
> > in bitcoinj by default to avoid cases where BIP70 requests work on
> > some platforms and not others, although the developer can easily
> > override this and use the OS root store instead.
> >
> Except that Mozilla/Apple/MSFT will update these certificate stores -
> second their policies - and your snapshot/collection might get
> outdated at a different pace than the OS-provided certificates,
> depending on how you (or the package maintainer) are rolling out updates.

I'm frankly _horrified_ to learn that BitcoinJ ships its own root CA certificates bundle. This means that, if a root CA gets breached and a certificate gets revoked, all BitcoinJ-using software will be vulnerable until BitcoinJ ships an update *and* the software in question pulls in the new BitcoinJ update and releases its own update. That might never happen.



From nicolas.dorier at gmail.com  Wed Jan 28 16:52:54 2015
From: nicolas.dorier at gmail.com (Nicolas DORIER)
Date: Wed, 28 Jan 2015 17:52:54 +0100
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <CAJHLa0Mu3Mjn=N-fTQ_fjwp+NUpfBqpdnXZiHoKz1s3tcZa+Cg@mail.gmail.com>
References: <CALYO6Xt-jTYwpywUaH-s4YPYyGUp1_BLSEswscnwX+Vu166Lcw@mail.gmail.com>
	<alpine.DEB.2.10.1501281419110.21680@nzrgulfg.ivfhpber.pbz>
	<CALYO6Xv=k+Ztvke90SDB91StFBL7C0U49ufMD-WjG91uHLshFg@mail.gmail.com>
	<CANEZrP3PCHaTO3-HA3GHFxwuJJpW2dbvPuV4R1sFPcFW49uGgw@mail.gmail.com>
	<CAJHLa0Mu3Mjn=N-fTQ_fjwp+NUpfBqpdnXZiHoKz1s3tcZa+Cg@mail.gmail.com>
Message-ID: <CALYO6Xs_20YpKeqmtu8N6Vt2uCSV4hM6S=6=zLhfBb_GCyuikg@mail.gmail.com>

For the number of field there is in the spec, I don't consider having a
JSON to schama really worthwhile.
If you fear it is error prone, then we should provide some testing data for
the BIP70. (Which I already did for protobuf, but was rejected, because
deemed no useful thanks to the code generator... But such code generator
gave me inconsistencies with gavin's implementation for example)

Why do you think type support is very useful in our case ? we have 3 types,
and dealing only with bytes, int, and string.
It cost me more time to find a suitable cross plateform lib for protobuf
(in c#, that works in ios and winrt) than I would by just coding the json
wrapper classes by hand. (JSON libs are more wildspread and supported than
protobuf)

2015-01-28 17:04 GMT+01:00 Jeff Garzik <jgarzik at bitpay.com>:

> Not to mention the tiresome and error-prone task of writing your own
> JSON-to-schema marshalling code -- or something equivalent to the protobufs
> compiler and libs for JSON.
>
> protobufs -- and its modern competitors such as msgpack -- natively
> provide type support in a way that must be hacked into JSON or XML.
>
> The protobuf/msgpack design is engineered to avoid bugs routinely found in
> JSON parsing code; due to the amount of code & effort involved in JSON
> input sanity checking, bugs and inconsistencies inevitable arise.  We have
> seen this in bitcoind with JSON-RPC.
>
>
>
> On Wed, Jan 28, 2015 at 10:42 AM, Mike Hearn <mike at plan99.net> wrote:
>
>> On the other hand, if you charge the developer (and not the plateform) to
>>> check certificate validity, it means that you have to develop a different
>>> codebase for all plateform you are targeting, because each plateform store
>>> trusted root certificate in a different manner with different APIs, and
>>> also have different types representing a X509 Certificate.
>>>
>>
>> That's what cross-platform abstraction libraries are for. Both Java and
>> Qt provide a key store library that can load from either the OS root store
>> or a custom one. If your chosen app platform doesn't, OK, then you'll have
>> to make or find one yourself. Perhaps contribute it upstream or make it a
>> library. But that's not a limitation of BIP70.
>>
>> Just as a reminder, there is no obligation to use the OS root store. You
>> can (and quite possibly should) take a snapshot of the Mozilla/Apple/MSFT
>> etc stores and load it in your app. We do this in bitcoinj by default to
>> avoid cases where BIP70 requests work on some platforms and not others,
>> although the developer can easily override this and use the OS root store
>> instead.
>>
>> Of all possible solutions, using a third party service to convert things
>> to JSON is one of the least obvious and highest effort. I don't know anyone
>> else who arrived at such a conclusion and respectfully disagree that this
>> is a problem with the design choices in BIP70. It sounds like a bizarre
>> hack around lack of features in whatever runtime you're using.
>>
>>
>>
>> ------------------------------------------------------------------------------
>> Dive into the World of Parallel Programming. The Go Parallel Website,
>> sponsored by Intel and developed in partnership with Slashdot Media, is
>> your
>> hub for all things parallel software development, from weekly thought
>> leadership blogs to news, videos, case studies, tutorials and more. Take a
>> look and join the conversation now. http://goparallel.sourceforge.net/
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>>
>
>
> --
> Jeff Garzik
> Bitcoin core developer and open source evangelist
> BitPay, Inc.      https://bitpay.com/
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/2eaf6cc2/attachment.html>

From mike at plan99.net  Wed Jan 28 16:55:43 2015
From: mike at plan99.net (Mike Hearn)
Date: Wed, 28 Jan 2015 17:55:43 +0100
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <CALYO6Xucf7xqE_4ykJqFyS_AEAT0X-1aGvYmA0WXzX7By0c0uQ@mail.gmail.com>
References: <CALYO6Xt-jTYwpywUaH-s4YPYyGUp1_BLSEswscnwX+Vu166Lcw@mail.gmail.com>
	<alpine.DEB.2.10.1501281419110.21680@nzrgulfg.ivfhpber.pbz>
	<CALYO6Xv=k+Ztvke90SDB91StFBL7C0U49ufMD-WjG91uHLshFg@mail.gmail.com>
	<CANEZrP3PCHaTO3-HA3GHFxwuJJpW2dbvPuV4R1sFPcFW49uGgw@mail.gmail.com>
	<CALYO6Xucf7xqE_4ykJqFyS_AEAT0X-1aGvYmA0WXzX7By0c0uQ@mail.gmail.com>
Message-ID: <CANEZrP1N4nwATG2FNJwc8jHZg3HfjSxHOL0u84jTi7Tx0+d9dQ@mail.gmail.com>

>
> My point is not that there is a limitation in BIP70. My point is that you
> put the burden of certificate verification on developer's shoulder when we
> can just leverage built in HTTPS support of the platform.
>

Platforms that support HTTPS but not certificate handling are rare - I know
HTML5 is such a platform but such apps are inherently dependent on the
server anyway and the server can just do the parsing and validation work
itself. If WinRT is such a platform, OK, too bad.

The embedding of the certificates is not arbitrary or pointless, by the
way. It's there for a very good reason - it makes the signed payment
request verifiable by third parties. Effectively you can store the signed
message and present it later to someone else, it's undeniable. Combined
with the transactions and merkle branches linking them to the block chain,
what you have is a form of digital receipt ... a proof of purchase that can
be automatically verified as legitimate. This has all kinds of use cases.

Because of how HTTPS works, you can't easily prove to a third party that a
server gave you a piece of data. Doing so requires staggeringly complex
hacks (see tls notary) and when we designed BIP70, those hacks didn't even
exist. So we'd lose the benefit of having a digitally signed request.

Additionally, doing things this way means BIP70 requests can be signed by
things which are not HTTPS servers. For example you can sign with an email
address cert, an EV certificate i.e. a company, a certificate issued by
some user forum, whatever else we end up wanting. Not every payment
recipient can be identified by a domain name + dynamic session.


> However, if you want to use your plateform's store, then you are toasted
>

That's a bit melodramatic. BitcoinJ is able to use the Android, JRE,
Windows and Mac certificate stores all using the same code or very minor
variants on it (e.g. on Mac you have to specify you want the system store
but it's a one-liner).

Yes, that's not *every* platform. Some will require custom binding glue and
it depends what abstractions and languages you are using.


> Have you tried to do that on windows RT and IOS ? I tried, and I quickly
> stopped doing that since it is not worth the effort. (Frankly I am not even
> sure you can on win rt, since the API is a stripped down version of windows)
>

There is code to do iOS using the Apple APIs here:

https://github.com/voisine/breadwallet/blob/master/BreadWallet/BRPaymentProtocol.m#L391


> Why have you not heard about the problem ? (until now, because I have this
> problem because I need to have the same codebase on
> winrt/win/android/ios/tablets)
>

WinRT is a minority platform in the extreme, and all the other platforms
you mentioned have the necessary APIs. Java abstracts you from them. So I
think you are encountering this problem because you desire to target WinRT
and other platforms with a single codebase. That's an unusual constraint.

AFAIK the only other people who encountered this are BitPay, because they
want to do everything in Javascript which doesn't really provide any major
APIs.


> Also, you bundle mozilla's store in bitcoinj, what happen when the store
> change and your customer have not intent to use bitcoinj new version ? by
> leveraging the plateform you benefit from automatic updates.
>

Yes, there are pros and cons to bundling a custom root store.


> Also, does java stores deals with certificate revocations ? sure you can
> theorically code that too... or just let the plateform deals with it.
>

It can do OCSP checks, yes, although I believe no wallets currently do so.
A better solution would be to implement an OCSP stapling extension to BIP70
though.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/04112261/attachment.html>

From mike at plan99.net  Wed Jan 28 17:02:15 2015
From: mike at plan99.net (Mike Hearn)
Date: Wed, 28 Jan 2015 18:02:15 +0100
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <2225268.rOb4P6uJX2@crushinator>
References: <CALYO6Xt-jTYwpywUaH-s4YPYyGUp1_BLSEswscnwX+Vu166Lcw@mail.gmail.com>
	<CANEZrP3PCHaTO3-HA3GHFxwuJJpW2dbvPuV4R1sFPcFW49uGgw@mail.gmail.com>
	<54C90C2B.3090708@bitonic.nl> <2225268.rOb4P6uJX2@crushinator>
Message-ID: <CANEZrP2f=+J7OMW3WEf=BZq0MC-xAVBSkDHRTZspu0pgNrU5LA@mail.gmail.com>

>
> I'm frankly _horrified_ to learn that BitcoinJ ships its own root CA
> certificates bundle. This means that, if a root CA gets breached and a
> certificate gets revoked, all BitcoinJ-using software will be vulnerable
> until BitcoinJ ships an update *and* the software in question pulls in the
> new BitcoinJ update and releases its own update. That might never happen.


If your wallet is unmaintained, you have other problems beyond (extremely
rare) root CA revocations.

As far as I know the only time a CA in wide usage has been revoked entirely
is DigiNotar.

One advantage of doing it this way is if, for example, a widely used piece
of community infrastructure (e.g. bitcointalk, reddit, whatever) decides to
become a CA, the Bitcoin community can decide to have different inclusion
rules vs the OS/browser root CA programs. For example we'd probably relax
the constraint to use an HSM and just ensure that the rendering of the
asserted identity isn't confusible with other kinds of more strongly
protected identities. For example no forum usernames like "foo.com" but
rendering it in the UI as "Reddit forum user foo.com" would be OK.

Also you don't get problems due to old operating systems not including new
certs.

Finally, Linux doesn't have any kind of standardised cert/keystore API.
There are a few places where popular distros put certs but AFAIK they
aren't standardised and there's no standard code to load them. So that's
another reason why there's a built in store.

But yes, this is a debatable topic on which reasonable people can disagree.
The API makes it easy to use the platform OS store for wallet devs that
want to do that, and I think using the platform store on Android is the
default. It's only on the desktop where we fall back to a different store.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/bdcd16f5/attachment.html>

From nicolas.dorier at gmail.com  Wed Jan 28 17:04:40 2015
From: nicolas.dorier at gmail.com (Nicolas Dorier)
Date: Wed, 28 Jan 2015 18:04:40 +0100
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <CANEZrP1N4nwATG2FNJwc8jHZg3HfjSxHOL0u84jTi7Tx0+d9dQ@mail.gmail.com>
References: <CALYO6Xt-jTYwpywUaH-s4YPYyGUp1_BLSEswscnwX+Vu166Lcw@mail.gmail.com>
	<alpine.DEB.2.10.1501281419110.21680@nzrgulfg.ivfhpber.pbz>
	<CALYO6Xv=k+Ztvke90SDB91StFBL7C0U49ufMD-WjG91uHLshFg@mail.gmail.com>
	<CANEZrP3PCHaTO3-HA3GHFxwuJJpW2dbvPuV4R1sFPcFW49uGgw@mail.gmail.com>
	<CALYO6Xucf7xqE_4ykJqFyS_AEAT0X-1aGvYmA0WXzX7By0c0uQ@mail.gmail.com>
	<CANEZrP1N4nwATG2FNJwc8jHZg3HfjSxHOL0u84jTi7Tx0+d9dQ@mail.gmail.com>
Message-ID: <CA+1nnr=5PVhME1nZz=5Ki9SXH4Ok=pamDSGr_8Pz6nzyM9SRbQ@mail.gmail.com>

Mike, I am not denying it is impossible to do all of that.
Just that it is not a trivial stuff to do to make it works everywhere, and
I think that it is not a good thing for a client side technology.
BIP70 has its use, and I understand why there is case where it is good to
ship the certs in the message and not depends on the transport.

But a standard that just use JSON and HTTPS, even if less flexible that
BIP70, would make it easier and sufficient for today's use case.

On Wed, Jan 28, 2015 at 5:55 PM, Mike Hearn <mike at plan99.net> wrote:

> My point is not that there is a limitation in BIP70. My point is that you
>> put the burden of certificate verification on developer's shoulder when we
>> can just leverage built in HTTPS support of the platform.
>>
>
> Platforms that support HTTPS but not certificate handling are rare - I
> know HTML5 is such a platform but such apps are inherently dependent on the
> server anyway and the server can just do the parsing and validation work
> itself. If WinRT is such a platform, OK, too bad.
>
> The embedding of the certificates is not arbitrary or pointless, by the
> way. It's there for a very good reason - it makes the signed payment
> request verifiable by third parties. Effectively you can store the signed
> message and present it later to someone else, it's undeniable. Combined
> with the transactions and merkle branches linking them to the block chain,
> what you have is a form of digital receipt ... a proof of purchase that can
> be automatically verified as legitimate. This has all kinds of use cases.
>
> Because of how HTTPS works, you can't easily prove to a third party that a
> server gave you a piece of data. Doing so requires staggeringly complex
> hacks (see tls notary) and when we designed BIP70, those hacks didn't even
> exist. So we'd lose the benefit of having a digitally signed request.
>
> Additionally, doing things this way means BIP70 requests can be signed by
> things which are not HTTPS servers. For example you can sign with an email
> address cert, an EV certificate i.e. a company, a certificate issued by
> some user forum, whatever else we end up wanting. Not every payment
> recipient can be identified by a domain name + dynamic session.
>
>
>> However, if you want to use your plateform's store, then you are toasted
>>
>
> That's a bit melodramatic. BitcoinJ is able to use the Android, JRE,
> Windows and Mac certificate stores all using the same code or very minor
> variants on it (e.g. on Mac you have to specify you want the system store
> but it's a one-liner).
>
> Yes, that's not *every* platform. Some will require custom binding glue
> and it depends what abstractions and languages you are using.
>
>
>> Have you tried to do that on windows RT and IOS ? I tried, and I quickly
>> stopped doing that since it is not worth the effort. (Frankly I am not even
>> sure you can on win rt, since the API is a stripped down version of windows)
>>
>
> There is code to do iOS using the Apple APIs here:
>
>
> https://github.com/voisine/breadwallet/blob/master/BreadWallet/BRPaymentProtocol.m#L391
>
>
>> Why have you not heard about the problem ? (until now, because I have
>> this problem because I need to have the same codebase on
>> winrt/win/android/ios/tablets)
>>
>
> WinRT is a minority platform in the extreme, and all the other platforms
> you mentioned have the necessary APIs. Java abstracts you from them. So I
> think you are encountering this problem because you desire to target WinRT
> and other platforms with a single codebase. That's an unusual constraint.
>
> AFAIK the only other people who encountered this are BitPay, because they
> want to do everything in Javascript which doesn't really provide any major
> APIs.
>
>
>> Also, you bundle mozilla's store in bitcoinj, what happen when the store
>> change and your customer have not intent to use bitcoinj new version ? by
>> leveraging the plateform you benefit from automatic updates.
>>
>
> Yes, there are pros and cons to bundling a custom root store.
>
>
>> Also, does java stores deals with certificate revocations ? sure you can
>> theorically code that too... or just let the plateform deals with it.
>>
>
> It can do OCSP checks, yes, although I believe no wallets currently do so.
> A better solution would be to implement an OCSP stapling extension to BIP70
> though.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/0b7e5cdf/attachment.html>

From mike at plan99.net  Wed Jan 28 17:14:07 2015
From: mike at plan99.net (Mike Hearn)
Date: Wed, 28 Jan 2015 18:14:07 +0100
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <CA+1nnr=5PVhME1nZz=5Ki9SXH4Ok=pamDSGr_8Pz6nzyM9SRbQ@mail.gmail.com>
References: <CALYO6Xt-jTYwpywUaH-s4YPYyGUp1_BLSEswscnwX+Vu166Lcw@mail.gmail.com>
	<alpine.DEB.2.10.1501281419110.21680@nzrgulfg.ivfhpber.pbz>
	<CALYO6Xv=k+Ztvke90SDB91StFBL7C0U49ufMD-WjG91uHLshFg@mail.gmail.com>
	<CANEZrP3PCHaTO3-HA3GHFxwuJJpW2dbvPuV4R1sFPcFW49uGgw@mail.gmail.com>
	<CALYO6Xucf7xqE_4ykJqFyS_AEAT0X-1aGvYmA0WXzX7By0c0uQ@mail.gmail.com>
	<CANEZrP1N4nwATG2FNJwc8jHZg3HfjSxHOL0u84jTi7Tx0+d9dQ@mail.gmail.com>
	<CA+1nnr=5PVhME1nZz=5Ki9SXH4Ok=pamDSGr_8Pz6nzyM9SRbQ@mail.gmail.com>
Message-ID: <CANEZrP3ta59A0Fr9-afd1ByQ7U0G7kQVu_EsK-8AZkud74Kxpw@mail.gmail.com>

I think we'll just have to agree to disagree on this one. I've implemented
BIP70 a couple of times now and didn't find it to be difficult. I know you
had odd problems with the C# protobuf implementation you were using but
library bugs can happen for any kind of programming.

I forgot to mention the other reason it's done this way. One of the driving
goals of BIP70 was to support the TREZOR and similar devices. For hardware
wallets, it's critical to keep the amount of code they need to run as small
as possible. Any bugs in the code there can cause security holes and lead
to the device being hacked.

Doing it the way you suggest would mean the secure code would have to
contain complex and bug-prone text parsing logic as well as a full blown
HTTP and SSL stack, that requires not only X.509 handling but also lots of
other stuff on top. It'd increase cost, complexity and decrease security
quite a bit.

Whilst I appreciate if your platform provides a scripting-like API and
nothing low level it might seem easier to use JSON+HTTPS, that isn't the
case for one of the primary design targets.



On Wed, Jan 28, 2015 at 6:04 PM, Nicolas Dorier <nicolas.dorier at gmail.com>
wrote:

> Mike, I am not denying it is impossible to do all of that.
> Just that it is not a trivial stuff to do to make it works everywhere, and
> I think that it is not a good thing for a client side technology.
> BIP70 has its use, and I understand why there is case where it is good to
> ship the certs in the message and not depends on the transport.
>
> But a standard that just use JSON and HTTPS, even if less flexible that
> BIP70, would make it easier and sufficient for today's use case.
>
> On Wed, Jan 28, 2015 at 5:55 PM, Mike Hearn <mike at plan99.net> wrote:
>
>> My point is not that there is a limitation in BIP70. My point is that you
>>> put the burden of certificate verification on developer's shoulder when we
>>> can just leverage built in HTTPS support of the platform.
>>>
>>
>> Platforms that support HTTPS but not certificate handling are rare - I
>> know HTML5 is such a platform but such apps are inherently dependent on the
>> server anyway and the server can just do the parsing and validation work
>> itself. If WinRT is such a platform, OK, too bad.
>>
>> The embedding of the certificates is not arbitrary or pointless, by the
>> way. It's there for a very good reason - it makes the signed payment
>> request verifiable by third parties. Effectively you can store the signed
>> message and present it later to someone else, it's undeniable. Combined
>> with the transactions and merkle branches linking them to the block chain,
>> what you have is a form of digital receipt ... a proof of purchase that can
>> be automatically verified as legitimate. This has all kinds of use cases.
>>
>> Because of how HTTPS works, you can't easily prove to a third party that
>> a server gave you a piece of data. Doing so requires staggeringly complex
>> hacks (see tls notary) and when we designed BIP70, those hacks didn't even
>> exist. So we'd lose the benefit of having a digitally signed request.
>>
>> Additionally, doing things this way means BIP70 requests can be signed by
>> things which are not HTTPS servers. For example you can sign with an email
>> address cert, an EV certificate i.e. a company, a certificate issued by
>> some user forum, whatever else we end up wanting. Not every payment
>> recipient can be identified by a domain name + dynamic session.
>>
>>
>>> However, if you want to use your plateform's store, then you are toasted
>>>
>>
>> That's a bit melodramatic. BitcoinJ is able to use the Android, JRE,
>> Windows and Mac certificate stores all using the same code or very minor
>> variants on it (e.g. on Mac you have to specify you want the system store
>> but it's a one-liner).
>>
>> Yes, that's not *every* platform. Some will require custom binding glue
>> and it depends what abstractions and languages you are using.
>>
>>
>>> Have you tried to do that on windows RT and IOS ? I tried, and I quickly
>>> stopped doing that since it is not worth the effort. (Frankly I am not even
>>> sure you can on win rt, since the API is a stripped down version of windows)
>>>
>>
>> There is code to do iOS using the Apple APIs here:
>>
>>
>> https://github.com/voisine/breadwallet/blob/master/BreadWallet/BRPaymentProtocol.m#L391
>>
>>
>>> Why have you not heard about the problem ? (until now, because I have
>>> this problem because I need to have the same codebase on
>>> winrt/win/android/ios/tablets)
>>>
>>
>> WinRT is a minority platform in the extreme, and all the other platforms
>> you mentioned have the necessary APIs. Java abstracts you from them. So I
>> think you are encountering this problem because you desire to target WinRT
>> and other platforms with a single codebase. That's an unusual constraint.
>>
>> AFAIK the only other people who encountered this are BitPay, because they
>> want to do everything in Javascript which doesn't really provide any major
>> APIs.
>>
>>
>>> Also, you bundle mozilla's store in bitcoinj, what happen when the store
>>> change and your customer have not intent to use bitcoinj new version ? by
>>> leveraging the plateform you benefit from automatic updates.
>>>
>>
>> Yes, there are pros and cons to bundling a custom root store.
>>
>>
>>> Also, does java stores deals with certificate revocations ? sure you can
>>> theorically code that too... or just let the plateform deals with it.
>>>
>>
>> It can do OCSP checks, yes, although I believe no wallets currently do
>> so. A better solution would be to implement an OCSP stapling extension to
>> BIP70 though.
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/c4fd4b47/attachment.html>

From gubatron at gmail.com  Wed Jan 28 17:17:54 2015
From: gubatron at gmail.com (Angel Leon)
Date: Wed, 28 Jan 2015 12:17:54 -0500
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <CANEZrP3ta59A0Fr9-afd1ByQ7U0G7kQVu_EsK-8AZkud74Kxpw@mail.gmail.com>
References: <CALYO6Xt-jTYwpywUaH-s4YPYyGUp1_BLSEswscnwX+Vu166Lcw@mail.gmail.com>
	<alpine.DEB.2.10.1501281419110.21680@nzrgulfg.ivfhpber.pbz>
	<CALYO6Xv=k+Ztvke90SDB91StFBL7C0U49ufMD-WjG91uHLshFg@mail.gmail.com>
	<CANEZrP3PCHaTO3-HA3GHFxwuJJpW2dbvPuV4R1sFPcFW49uGgw@mail.gmail.com>
	<CALYO6Xucf7xqE_4ykJqFyS_AEAT0X-1aGvYmA0WXzX7By0c0uQ@mail.gmail.com>
	<CANEZrP1N4nwATG2FNJwc8jHZg3HfjSxHOL0u84jTi7Tx0+d9dQ@mail.gmail.com>
	<CA+1nnr=5PVhME1nZz=5Ki9SXH4Ok=pamDSGr_8Pz6nzyM9SRbQ@mail.gmail.com>
	<CANEZrP3ta59A0Fr9-afd1ByQ7U0G7kQVu_EsK-8AZkud74Kxpw@mail.gmail.com>
Message-ID: <CADZB0_a84VDU1iz8H_6AifsvZ5k68H10c1NV8irWuaz2v46EeQ@mail.gmail.com>

why not allow both serializations and keep serialization format a
parameter, keep everyone happy.

http://twitter.com/gubatron

On Wed, Jan 28, 2015 at 12:14 PM, Mike Hearn <mike at plan99.net> wrote:

> I think we'll just have to agree to disagree on this one. I've implemented
> BIP70 a couple of times now and didn't find it to be difficult. I know you
> had odd problems with the C# protobuf implementation you were using but
> library bugs can happen for any kind of programming.
>
> I forgot to mention the other reason it's done this way. One of the
> driving goals of BIP70 was to support the TREZOR and similar devices. For
> hardware wallets, it's critical to keep the amount of code they need to run
> as small as possible. Any bugs in the code there can cause security holes
> and lead to the device being hacked.
>
> Doing it the way you suggest would mean the secure code would have to
> contain complex and bug-prone text parsing logic as well as a full blown
> HTTP and SSL stack, that requires not only X.509 handling but also lots of
> other stuff on top. It'd increase cost, complexity and decrease security
> quite a bit.
>
> Whilst I appreciate if your platform provides a scripting-like API and
> nothing low level it might seem easier to use JSON+HTTPS, that isn't the
> case for one of the primary design targets.
>
>
>
> On Wed, Jan 28, 2015 at 6:04 PM, Nicolas Dorier <nicolas.dorier at gmail.com>
> wrote:
>
>> Mike, I am not denying it is impossible to do all of that.
>> Just that it is not a trivial stuff to do to make it works everywhere,
>> and I think that it is not a good thing for a client side technology.
>> BIP70 has its use, and I understand why there is case where it is good to
>> ship the certs in the message and not depends on the transport.
>>
>> But a standard that just use JSON and HTTPS, even if less flexible that
>> BIP70, would make it easier and sufficient for today's use case.
>>
>> On Wed, Jan 28, 2015 at 5:55 PM, Mike Hearn <mike at plan99.net> wrote:
>>
>>> My point is not that there is a limitation in BIP70. My point is that
>>>> you put the burden of certificate verification on developer's shoulder when
>>>> we can just leverage built in HTTPS support of the platform.
>>>>
>>>
>>> Platforms that support HTTPS but not certificate handling are rare - I
>>> know HTML5 is such a platform but such apps are inherently dependent on the
>>> server anyway and the server can just do the parsing and validation work
>>> itself. If WinRT is such a platform, OK, too bad.
>>>
>>> The embedding of the certificates is not arbitrary or pointless, by the
>>> way. It's there for a very good reason - it makes the signed payment
>>> request verifiable by third parties. Effectively you can store the signed
>>> message and present it later to someone else, it's undeniable. Combined
>>> with the transactions and merkle branches linking them to the block chain,
>>> what you have is a form of digital receipt ... a proof of purchase that can
>>> be automatically verified as legitimate. This has all kinds of use cases.
>>>
>>> Because of how HTTPS works, you can't easily prove to a third party that
>>> a server gave you a piece of data. Doing so requires staggeringly complex
>>> hacks (see tls notary) and when we designed BIP70, those hacks didn't even
>>> exist. So we'd lose the benefit of having a digitally signed request.
>>>
>>> Additionally, doing things this way means BIP70 requests can be signed
>>> by things which are not HTTPS servers. For example you can sign with an
>>> email address cert, an EV certificate i.e. a company, a certificate issued
>>> by some user forum, whatever else we end up wanting. Not every payment
>>> recipient can be identified by a domain name + dynamic session.
>>>
>>>
>>>> However, if you want to use your plateform's store, then you are toasted
>>>>
>>>
>>> That's a bit melodramatic. BitcoinJ is able to use the Android, JRE,
>>> Windows and Mac certificate stores all using the same code or very minor
>>> variants on it (e.g. on Mac you have to specify you want the system store
>>> but it's a one-liner).
>>>
>>> Yes, that's not *every* platform. Some will require custom binding glue
>>> and it depends what abstractions and languages you are using.
>>>
>>>
>>>> Have you tried to do that on windows RT and IOS ? I tried, and I
>>>> quickly stopped doing that since it is not worth the effort. (Frankly I am
>>>> not even sure you can on win rt, since the API is a stripped down version
>>>> of windows)
>>>>
>>>
>>> There is code to do iOS using the Apple APIs here:
>>>
>>>
>>> https://github.com/voisine/breadwallet/blob/master/BreadWallet/BRPaymentProtocol.m#L391
>>>
>>>
>>>> Why have you not heard about the problem ? (until now, because I have
>>>> this problem because I need to have the same codebase on
>>>> winrt/win/android/ios/tablets)
>>>>
>>>
>>> WinRT is a minority platform in the extreme, and all the other platforms
>>> you mentioned have the necessary APIs. Java abstracts you from them. So I
>>> think you are encountering this problem because you desire to target WinRT
>>> and other platforms with a single codebase. That's an unusual constraint.
>>>
>>> AFAIK the only other people who encountered this are BitPay, because
>>> they want to do everything in Javascript which doesn't really provide any
>>> major APIs.
>>>
>>>
>>>> Also, you bundle mozilla's store in bitcoinj, what happen when the
>>>> store change and your customer have not intent to use bitcoinj new version
>>>> ? by leveraging the plateform you benefit from automatic updates.
>>>>
>>>
>>> Yes, there are pros and cons to bundling a custom root store.
>>>
>>>
>>>> Also, does java stores deals with certificate revocations ? sure you
>>>> can theorically code that too... or just let the plateform deals with it.
>>>>
>>>
>>> It can do OCSP checks, yes, although I believe no wallets currently do
>>> so. A better solution would be to implement an OCSP stapling extension to
>>> BIP70 though.
>>>
>>
>>
>
>
> ------------------------------------------------------------------------------
> Dive into the World of Parallel Programming. The Go Parallel Website,
> sponsored by Intel and developed in partnership with Slashdot Media, is
> your
> hub for all things parallel software development, from weekly thought
> leadership blogs to news, videos, case studies, tutorials and more. Take a
> look and join the conversation now. http://goparallel.sourceforge.net/
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/42f6b20a/attachment.html>

From nicolas.dorier at gmail.com  Wed Jan 28 17:27:44 2015
From: nicolas.dorier at gmail.com (Nicolas DORIER)
Date: Wed, 28 Jan 2015 18:27:44 +0100
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <CANEZrP3ta59A0Fr9-afd1ByQ7U0G7kQVu_EsK-8AZkud74Kxpw@mail.gmail.com>
References: <CALYO6Xt-jTYwpywUaH-s4YPYyGUp1_BLSEswscnwX+Vu166Lcw@mail.gmail.com>
	<alpine.DEB.2.10.1501281419110.21680@nzrgulfg.ivfhpber.pbz>
	<CALYO6Xv=k+Ztvke90SDB91StFBL7C0U49ufMD-WjG91uHLshFg@mail.gmail.com>
	<CANEZrP3PCHaTO3-HA3GHFxwuJJpW2dbvPuV4R1sFPcFW49uGgw@mail.gmail.com>
	<CALYO6Xucf7xqE_4ykJqFyS_AEAT0X-1aGvYmA0WXzX7By0c0uQ@mail.gmail.com>
	<CANEZrP1N4nwATG2FNJwc8jHZg3HfjSxHOL0u84jTi7Tx0+d9dQ@mail.gmail.com>
	<CA+1nnr=5PVhME1nZz=5Ki9SXH4Ok=pamDSGr_8Pz6nzyM9SRbQ@mail.gmail.com>
	<CANEZrP3ta59A0Fr9-afd1ByQ7U0G7kQVu_EsK-8AZkud74Kxpw@mail.gmail.com>
Message-ID: <CALYO6XtG41q4UB1SYcGyM1JdG_iJJsO_A8DicHe8=2hW4i=4FQ@mail.gmail.com>

Sure,

But the mobile targets, it is still easier to use Json + HTTPS, especially
when you want one code base for everything.
And as you said, developers need to think about fetching mozilla store time
to time, and check revocations themselves. This is not obvious thing to do,
and hard to test correctly.

If your use case was the primary utility of BIP70, then I'd say it fit the
bill. But for cross plateform client development an atlernative would be
easier.

> why not allow both serializations and keep serialization format a
parameter, keep everyone happy.

It would be another BIP, because if we use JSON with HTTPS, the difference
is also in the semantic (no embedded certificates)

I will likely provide this option for a product I am developing. I will
only use another Content Type. We'll see then how it goes.

2015-01-28 18:14 GMT+01:00 Mike Hearn <mike at plan99.net>:

> I think we'll just have to agree to disagree on this one. I've implemented
> BIP70 a couple of times now and didn't find it to be difficult. I know you
> had odd problems with the C# protobuf implementation you were using but
> library bugs can happen for any kind of programming.
>
> I forgot to mention the other reason it's done this way. One of the
> driving goals of BIP70 was to support the TREZOR and similar devices. For
> hardware wallets, it's critical to keep the amount of code they need to run
> as small as possible. Any bugs in the code there can cause security holes
> and lead to the device being hacked.
>
> Doing it the way you suggest would mean the secure code would have to
> contain complex and bug-prone text parsing logic as well as a full blown
> HTTP and SSL stack, that requires not only X.509 handling but also lots of
> other stuff on top. It'd increase cost, complexity and decrease security
> quite a bit.
>
> Whilst I appreciate if your platform provides a scripting-like API and
> nothing low level it might seem easier to use JSON+HTTPS, that isn't the
> case for one of the primary design targets.
>
>
>
> On Wed, Jan 28, 2015 at 6:04 PM, Nicolas Dorier <nicolas.dorier at gmail.com>
> wrote:
>
>> Mike, I am not denying it is impossible to do all of that.
>> Just that it is not a trivial stuff to do to make it works everywhere,
>> and I think that it is not a good thing for a client side technology.
>> BIP70 has its use, and I understand why there is case where it is good to
>> ship the certs in the message and not depends on the transport.
>>
>> But a standard that just use JSON and HTTPS, even if less flexible that
>> BIP70, would make it easier and sufficient for today's use case.
>>
>> On Wed, Jan 28, 2015 at 5:55 PM, Mike Hearn <mike at plan99.net> wrote:
>>
>>> My point is not that there is a limitation in BIP70. My point is that
>>>> you put the burden of certificate verification on developer's shoulder when
>>>> we can just leverage built in HTTPS support of the platform.
>>>>
>>>
>>> Platforms that support HTTPS but not certificate handling are rare - I
>>> know HTML5 is such a platform but such apps are inherently dependent on the
>>> server anyway and the server can just do the parsing and validation work
>>> itself. If WinRT is such a platform, OK, too bad.
>>>
>>> The embedding of the certificates is not arbitrary or pointless, by the
>>> way. It's there for a very good reason - it makes the signed payment
>>> request verifiable by third parties. Effectively you can store the signed
>>> message and present it later to someone else, it's undeniable. Combined
>>> with the transactions and merkle branches linking them to the block chain,
>>> what you have is a form of digital receipt ... a proof of purchase that can
>>> be automatically verified as legitimate. This has all kinds of use cases.
>>>
>>> Because of how HTTPS works, you can't easily prove to a third party that
>>> a server gave you a piece of data. Doing so requires staggeringly complex
>>> hacks (see tls notary) and when we designed BIP70, those hacks didn't even
>>> exist. So we'd lose the benefit of having a digitally signed request.
>>>
>>> Additionally, doing things this way means BIP70 requests can be signed
>>> by things which are not HTTPS servers. For example you can sign with an
>>> email address cert, an EV certificate i.e. a company, a certificate issued
>>> by some user forum, whatever else we end up wanting. Not every payment
>>> recipient can be identified by a domain name + dynamic session.
>>>
>>>
>>>> However, if you want to use your plateform's store, then you are toasted
>>>>
>>>
>>> That's a bit melodramatic. BitcoinJ is able to use the Android, JRE,
>>> Windows and Mac certificate stores all using the same code or very minor
>>> variants on it (e.g. on Mac you have to specify you want the system store
>>> but it's a one-liner).
>>>
>>> Yes, that's not *every* platform. Some will require custom binding glue
>>> and it depends what abstractions and languages you are using.
>>>
>>>
>>>> Have you tried to do that on windows RT and IOS ? I tried, and I
>>>> quickly stopped doing that since it is not worth the effort. (Frankly I am
>>>> not even sure you can on win rt, since the API is a stripped down version
>>>> of windows)
>>>>
>>>
>>> There is code to do iOS using the Apple APIs here:
>>>
>>>
>>> https://github.com/voisine/breadwallet/blob/master/BreadWallet/BRPaymentProtocol.m#L391
>>>
>>>
>>>> Why have you not heard about the problem ? (until now, because I have
>>>> this problem because I need to have the same codebase on
>>>> winrt/win/android/ios/tablets)
>>>>
>>>
>>> WinRT is a minority platform in the extreme, and all the other platforms
>>> you mentioned have the necessary APIs. Java abstracts you from them. So I
>>> think you are encountering this problem because you desire to target WinRT
>>> and other platforms with a single codebase. That's an unusual constraint.
>>>
>>> AFAIK the only other people who encountered this are BitPay, because
>>> they want to do everything in Javascript which doesn't really provide any
>>> major APIs.
>>>
>>>
>>>> Also, you bundle mozilla's store in bitcoinj, what happen when the
>>>> store change and your customer have not intent to use bitcoinj new version
>>>> ? by leveraging the plateform you benefit from automatic updates.
>>>>
>>>
>>> Yes, there are pros and cons to bundling a custom root store.
>>>
>>>
>>>> Also, does java stores deals with certificate revocations ? sure you
>>>> can theorically code that too... or just let the plateform deals with it.
>>>>
>>>
>>> It can do OCSP checks, yes, although I believe no wallets currently do
>>> so. A better solution would be to implement an OCSP stapling extension to
>>> BIP70 though.
>>>
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/15e3e5bb/attachment.html>

From jgarzik at bitpay.com  Wed Jan 28 17:29:53 2015
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Wed, 28 Jan 2015 12:29:53 -0500
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <CALYO6Xs_20YpKeqmtu8N6Vt2uCSV4hM6S=6=zLhfBb_GCyuikg@mail.gmail.com>
References: <CALYO6Xt-jTYwpywUaH-s4YPYyGUp1_BLSEswscnwX+Vu166Lcw@mail.gmail.com>
	<alpine.DEB.2.10.1501281419110.21680@nzrgulfg.ivfhpber.pbz>
	<CALYO6Xv=k+Ztvke90SDB91StFBL7C0U49ufMD-WjG91uHLshFg@mail.gmail.com>
	<CANEZrP3PCHaTO3-HA3GHFxwuJJpW2dbvPuV4R1sFPcFW49uGgw@mail.gmail.com>
	<CAJHLa0Mu3Mjn=N-fTQ_fjwp+NUpfBqpdnXZiHoKz1s3tcZa+Cg@mail.gmail.com>
	<CALYO6Xs_20YpKeqmtu8N6Vt2uCSV4hM6S=6=zLhfBb_GCyuikg@mail.gmail.com>
Message-ID: <CAJHLa0MCyzm_t47R5Z5MPL9ruqM=uq15u26W3dwRsBy57K11=w@mail.gmail.com>

It is not "fear", it is field experience.

JSON has proven to be a bug generator for the reasons already stated.

JSON does not include type marshalling and input validation.
Protobufs/msgpack/etc. engineered those to occur automatically, because
that is an area shown by field experience to be a constant source of bugs
and inconsistent parsing/validation behavior.




On Wed, Jan 28, 2015 at 11:52 AM, Nicolas DORIER <nicolas.dorier at gmail.com>
wrote:

> For the number of field there is in the spec, I don't consider having a
> JSON to schama really worthwhile.
> If you fear it is error prone, then we should provide some testing data
> for the BIP70. (Which I already did for protobuf, but was rejected, because
> deemed no useful thanks to the code generator... But such code generator
> gave me inconsistencies with gavin's implementation for example)
>
> Why do you think type support is very useful in our case ? we have 3
> types, and dealing only with bytes, int, and string.
> It cost me more time to find a suitable cross plateform lib for protobuf
> (in c#, that works in ios and winrt) than I would by just coding the json
> wrapper classes by hand. (JSON libs are more wildspread and supported than
> protobuf)
>
> 2015-01-28 17:04 GMT+01:00 Jeff Garzik <jgarzik at bitpay.com>:
>
>> Not to mention the tiresome and error-prone task of writing your own
>> JSON-to-schema marshalling code -- or something equivalent to the protobufs
>> compiler and libs for JSON.
>>
>> protobufs -- and its modern competitors such as msgpack -- natively
>> provide type support in a way that must be hacked into JSON or XML.
>>
>> The protobuf/msgpack design is engineered to avoid bugs routinely found
>> in JSON parsing code; due to the amount of code & effort involved in JSON
>> input sanity checking, bugs and inconsistencies inevitable arise.  We have
>> seen this in bitcoind with JSON-RPC.
>>
>>
>>
>> On Wed, Jan 28, 2015 at 10:42 AM, Mike Hearn <mike at plan99.net> wrote:
>>
>>> On the other hand, if you charge the developer (and not the plateform)
>>>> to check certificate validity, it means that you have to develop a
>>>> different codebase for all plateform you are targeting, because each
>>>> plateform store trusted root certificate in a different manner with
>>>> different APIs, and also have different types representing a X509
>>>> Certificate.
>>>>
>>>
>>> That's what cross-platform abstraction libraries are for. Both Java and
>>> Qt provide a key store library that can load from either the OS root store
>>> or a custom one. If your chosen app platform doesn't, OK, then you'll have
>>> to make or find one yourself. Perhaps contribute it upstream or make it a
>>> library. But that's not a limitation of BIP70.
>>>
>>> Just as a reminder, there is no obligation to use the OS root store. You
>>> can (and quite possibly should) take a snapshot of the Mozilla/Apple/MSFT
>>> etc stores and load it in your app. We do this in bitcoinj by default to
>>> avoid cases where BIP70 requests work on some platforms and not others,
>>> although the developer can easily override this and use the OS root store
>>> instead.
>>>
>>> Of all possible solutions, using a third party service to convert things
>>> to JSON is one of the least obvious and highest effort. I don't know anyone
>>> else who arrived at such a conclusion and respectfully disagree that this
>>> is a problem with the design choices in BIP70. It sounds like a bizarre
>>> hack around lack of features in whatever runtime you're using.
>>>
>>>
>>>
>>> ------------------------------------------------------------------------------
>>> Dive into the World of Parallel Programming. The Go Parallel Website,
>>> sponsored by Intel and developed in partnership with Slashdot Media, is
>>> your
>>> hub for all things parallel software development, from weekly thought
>>> leadership blogs to news, videos, case studies, tutorials and more. Take
>>> a
>>> look and join the conversation now. http://goparallel.sourceforge.net/
>>> _______________________________________________
>>> Bitcoin-development mailing list
>>> Bitcoin-development at lists.sourceforge.net
>>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>>
>>>
>>
>>
>> --
>> Jeff Garzik
>> Bitcoin core developer and open source evangelist
>> BitPay, Inc.      https://bitpay.com/
>>
>
>


-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/37d1a41c/attachment.html>

From mike at plan99.net  Wed Jan 28 17:45:10 2015
From: mike at plan99.net (Mike Hearn)
Date: Wed, 28 Jan 2015 18:45:10 +0100
Subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for
	encoding?
In-Reply-To: <CAJHLa0MCyzm_t47R5Z5MPL9ruqM=uq15u26W3dwRsBy57K11=w@mail.gmail.com>
References: <CALYO6Xt-jTYwpywUaH-s4YPYyGUp1_BLSEswscnwX+Vu166Lcw@mail.gmail.com>
	<alpine.DEB.2.10.1501281419110.21680@nzrgulfg.ivfhpber.pbz>
	<CALYO6Xv=k+Ztvke90SDB91StFBL7C0U49ufMD-WjG91uHLshFg@mail.gmail.com>
	<CANEZrP3PCHaTO3-HA3GHFxwuJJpW2dbvPuV4R1sFPcFW49uGgw@mail.gmail.com>
	<CAJHLa0Mu3Mjn=N-fTQ_fjwp+NUpfBqpdnXZiHoKz1s3tcZa+Cg@mail.gmail.com>
	<CALYO6Xs_20YpKeqmtu8N6Vt2uCSV4hM6S=6=zLhfBb_GCyuikg@mail.gmail.com>
	<CAJHLa0MCyzm_t47R5Z5MPL9ruqM=uq15u26W3dwRsBy57K11=w@mail.gmail.com>
Message-ID: <CANEZrP3GgDYiHt+grWjX+gpDDh9HUvPDGLqi-mpgddEMd24q7w@mail.gmail.com>

>
> It is not "fear", it is field experience.
>
> JSON has proven to be a bug generator for the reasons already stated.
>

To back Jeff up on this point, today we see this story:

http://www.theregister.co.uk/2015/01/27/trivial_hole_left_black_phones_open_to_plunder/

The maker of BlackPhone ? a mobile marketed as offering unusually high
levels of security ? has patched *a critical vulnerability that allows
hackers to run malicious code on the handsets*. Attackers need little more
than a phone number to send a message that can compromise the devices via
the Silent Text application.

"The SCIMP protocol encodes messages as JSON objects, which are then
transmitted to the remote party over XMPP," Dowd explained to *The Register*.
"*The flaw I discovered occurs during the deserialization of these JSON
objects*. It is *a type confusion vulnerability*, which when exploited
allows an attacker to overwrite a pointer in memory, either partially or in
full. This pointer is later manipulated by the program and also the system
allocator, allowing you to do things such as pass arbitrary pointers to
free()."

The C++/Java/Python protocol buffer implementations are used by Google for
all internal inter-server communication. Any similar exploit in them would
result in total bypass of their entire internal security and auditing
system by allowing you to run code as any user. The Google security team is
very good, the protobuf code is carefully reviewed and the format is
relatively constrained. The chances of there being any security problems in
the parsing code generated by the protobuf compilers is drastically
smaller. As BIP70 requests are parsed by security sensitive code, this
matters.

The vision for BIP70 has always been to be a foundation for many features.
We haven't really done much with it so far because there have always been
higher priorities. But I hope that if Bitcoin continues to be successful
and grows, one day payment requests will have many different features in
them and those will likely include many complex data structures.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150128/ec7ad39e/attachment.html>

From gubatron at gmail.com  Sat Jan 31 00:48:40 2015
From: gubatron at gmail.com (Angel Leon)
Date: Sat, 31 Jan 2015 01:48:40 +0100
Subject: [Bitcoin-development] Is there a way to estimate the maximum number
 of transactions per minute Bitcoin can handle as it is today?
Message-ID: <CADZB0_aWkSApjRA-WQcVsonOTpZNX8=G=iuY3k+dKSwDq=xM6A@mail.gmail.com>

On the Chinese "Single's Day" (sort of like the american Black Friday)
according to MIT's Tech Review
<http://www.technologyreview.com/news/534001/alipay-leads-a-digital-finance-revolution-in-china/>
magazine

"Alipay handled up to 2.85 million transactions per minute, and 54 percent
of its transactions are made via mobile device."

For a few weeks I've been reading the conversations about block sizes and
the experiments being done on the subject with larger blocks.

On the day with the most transactions, the Bitcoin block chain averages
about 73 transactions per minute. I kept wondering what blocksize we'd need
for handling 100,000 transactions per minute, and estimated that roughly
we'd need a blocksize of about 1300x times larger than what we have now, so
bigger than 1Gb block... but seeing the numbers Alipay gets to handle just
in China make me wonder how scalable is Bitcoin if it were to truly compete
with worldwide financial services.

If you were to include double the number Alipay can handle, you'd be
shooting about 6 million transactions per minute, or roughly 60 million
transactions per block.

If you average every transaction around 250 bytes, then you'd need ~15
Gigabytes per block to be broadcast and hashed by all the full nodes every
10 minutes, eating good 2Tb of storage daily... do miners have enough
bandwidth and CPU power to handle this?

are my scalability concerns absurd?

http://twitter.com/gubatron
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150131/3b354179/attachment.html>

From martin.habovstiak at gmail.com  Sat Jan 31 01:30:49 2015
From: martin.habovstiak at gmail.com (Martin =?UTF-8?Q?Habov=C5=A1tiak?=)
Date: Sat, 31 Jan 2015 02:30:49 +0100
Subject: [Bitcoin-development] New BIP: protocol for multisignature payments
Message-ID: <1422667849.25602.6.camel@TARDIS>

Hello,

I've been thinking about how to solve security problems of the servers
holding huge amounts of bitcoins (exchanges, markets...) and came up
with this idea: https://gist.github.com/Kixunil/2ec79cf40a53fb899ac5

TL;DR: it's extension of BIP70 (but not fully compatible due to security
reasons) which supports making of multisig transactions dynamically.
(The most important thing is that the user provides his address.)

What do you think? Is it a good way to solve the problem or do you know
about something better? I would really like this or something similar
implemented by wallets.

Thank you for your feedback!

Martin
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: This is a digitally signed message part
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150131/de9440d7/attachment.sig>

From me at thomaskerin.io  Sat Jan 31 02:10:45 2015
From: me at thomaskerin.io (Thomas Kerin)
Date: Sat, 31 Jan 2015 02:10:45 +0000
Subject: [Bitcoin-development] New BIP: protocol for multisignature
 payments
Message-ID: <mailman.0.1434921516.5063.bitcoin-dev@lists.linuxfoundation.org>

Ooh, I had a very similar proposal, except it involved sharing generic P2SH scripts. It also involved facilitating requesting of signatures.. We should talk.On 31 Jan 2015 01:30, Martin Habov?tiak <martin.habovstiak at gmail.com> wrote:
>
> Hello, 
>
> I've been thinking about how to solve security problems of the servers 
> holding huge amounts of bitcoins (exchanges, markets...) and came up 
> with this idea: https://gist.github.com/Kixunil/2ec79cf40a53fb899ac5 
>
> TL;DR: it's extension of BIP70 (but not fully compatible due to security 
> reasons) which supports making of multisig transactions dynamically. 
> (The most important thing is that the user provides his address.) 
>
> What do you think? Is it a good way to solve the problem or do you know 
> about something better? I would really like this or something similar 
> implemented by wallets. 
>
> Thank you for your feedback! 
>
> Martin
>
> ------------------------------------------------------------------------------ 
> Dive into the World of Parallel Programming. The Go Parallel Website, 
> sponsored by Intel and developed in partnership with Slashdot Media, is your 
> hub for all things parallel software development, from weekly thought 
> leadership blogs to news, videos, case studies, tutorials and more. Take a 
> look and join the conversation now. http://goparallel.sourceforge.net/
> _______________________________________________ 
> Bitcoin-development mailing list 
> Bitcoin-development at lists.sourceforge.net 
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development 

From imsaguy at gmail.com  Sat Jan 31 02:58:29 2015
From: imsaguy at gmail.com (Nick Simpson)
Date: Fri, 30 Jan 2015 20:58:29 -0600
Subject: [Bitcoin-development] Is there a way to estimate the maximum
 number of transactions per minute Bitcoin can handle as it is today?
In-Reply-To: <CADZB0_aWkSApjRA-WQcVsonOTpZNX8=G=iuY3k+dKSwDq=xM6A@mail.gmail.com>
References: <CADZB0_aWkSApjRA-WQcVsonOTpZNX8=G=iuY3k+dKSwDq=xM6A@mail.gmail.com>
Message-ID: <CAOiKAtox1qmOEO6m9_ZjjR9QSqAGZv5s6YcBHq7oRnmNirdM=Q@mail.gmail.com>

This has been discussed before. I believe most people don't expect Bitcoin
to replace all of the various methods of payment.  Scalability is always a
concern, just not to the level of  Alipay this year (or the next or the
next for that matter.)

Nick
On Jan 30, 2015 7:08 PM, "Angel Leon" <gubatron at gmail.com> wrote:

> On the Chinese "Single's Day" (sort of like the american Black Friday)
> according to MIT's Tech Review
> <http://www.technologyreview.com/news/534001/alipay-leads-a-digital-finance-revolution-in-china/>
> magazine
>
> "Alipay handled up to 2.85 million transactions per minute, and 54 percent
> of its transactions are made via mobile device."
>
> For a few weeks I've been reading the conversations about block sizes and
> the experiments being done on the subject with larger blocks.
>
> On the day with the most transactions, the Bitcoin block chain averages
> about 73 transactions per minute. I kept wondering what blocksize we'd need
> for handling 100,000 transactions per minute, and estimated that roughly
> we'd need a blocksize of about 1300x times larger than what we have now, so
> bigger than 1Gb block... but seeing the numbers Alipay gets to handle just
> in China make me wonder how scalable is Bitcoin if it were to truly compete
> with worldwide financial services.
>
> If you were to include double the number Alipay can handle, you'd be
> shooting about 6 million transactions per minute, or roughly 60 million
> transactions per block.
>
> If you average every transaction around 250 bytes, then you'd need ~15
> Gigabytes per block to be broadcast and hashed by all the full nodes every
> 10 minutes, eating good 2Tb of storage daily... do miners have enough
> bandwidth and CPU power to handle this?
>
> are my scalability concerns absurd?
>
> http://twitter.com/gubatron
>
>
> ------------------------------------------------------------------------------
> Dive into the World of Parallel Programming. The Go Parallel Website,
> sponsored by Intel and developed in partnership with Slashdot Media, is
> your
> hub for all things parallel software development, from weekly thought
> leadership blogs to news, videos, case studies, tutorials and more. Take a
> look and join the conversation now. http://goparallel.sourceforge.net/
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150130/249fbe2e/attachment.html>

From allen.piscitello at gmail.com  Sat Jan 31 02:58:51 2015
From: allen.piscitello at gmail.com (Allen Piscitello)
Date: Fri, 30 Jan 2015 20:58:51 -0600
Subject: [Bitcoin-development] Is there a way to estimate the maximum
 number of transactions per minute Bitcoin can handle as it is today?
In-Reply-To: <CADZB0_aWkSApjRA-WQcVsonOTpZNX8=G=iuY3k+dKSwDq=xM6A@mail.gmail.com>
References: <CADZB0_aWkSApjRA-WQcVsonOTpZNX8=G=iuY3k+dKSwDq=xM6A@mail.gmail.com>
Message-ID: <CAJfRnm5H7gn6xmMFdikNFSy-geWrpW4dQDw8NsFqz_3YxH=ESg@mail.gmail.com>

You are assuming that the only way to use Bitcoin is on-chain transactions
and that is the only way for it to scale.  This is a mistake.

On Fri, Jan 30, 2015 at 6:48 PM, Angel Leon <gubatron at gmail.com> wrote:

> On the Chinese "Single's Day" (sort of like the american Black Friday)
> according to MIT's Tech Review
> <http://www.technologyreview.com/news/534001/alipay-leads-a-digital-finance-revolution-in-china/>
> magazine
>
> "Alipay handled up to 2.85 million transactions per minute, and 54 percent
> of its transactions are made via mobile device."
>
> For a few weeks I've been reading the conversations about block sizes and
> the experiments being done on the subject with larger blocks.
>
> On the day with the most transactions, the Bitcoin block chain averages
> about 73 transactions per minute. I kept wondering what blocksize we'd need
> for handling 100,000 transactions per minute, and estimated that roughly
> we'd need a blocksize of about 1300x times larger than what we have now, so
> bigger than 1Gb block... but seeing the numbers Alipay gets to handle just
> in China make me wonder how scalable is Bitcoin if it were to truly compete
> with worldwide financial services.
>
> If you were to include double the number Alipay can handle, you'd be
> shooting about 6 million transactions per minute, or roughly 60 million
> transactions per block.
>
> If you average every transaction around 250 bytes, then you'd need ~15
> Gigabytes per block to be broadcast and hashed by all the full nodes every
> 10 minutes, eating good 2Tb of storage daily... do miners have enough
> bandwidth and CPU power to handle this?
>
> are my scalability concerns absurd?
>
> http://twitter.com/gubatron
>
>
> ------------------------------------------------------------------------------
> Dive into the World of Parallel Programming. The Go Parallel Website,
> sponsored by Intel and developed in partnership with Slashdot Media, is
> your
> hub for all things parallel software development, from weekly thought
> leadership blogs to news, videos, case studies, tutorials and more. Take a
> look and join the conversation now. http://goparallel.sourceforge.net/
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150130/f60165ac/attachment.html>

From laanwj at gmail.com  Sat Jan 31 13:11:42 2015
From: laanwj at gmail.com (Wladimir)
Date: Sat, 31 Jan 2015 14:11:42 +0100 (CET)
Subject: [Bitcoin-development] Is there a way to estimate the maximum
 number of transactions per minute Bitcoin can handle as it is today?
In-Reply-To: <CAOiKAtox1qmOEO6m9_ZjjR9QSqAGZv5s6YcBHq7oRnmNirdM=Q@mail.gmail.com>
References: <CADZB0_aWkSApjRA-WQcVsonOTpZNX8=G=iuY3k+dKSwDq=xM6A@mail.gmail.com>
	<CAOiKAtox1qmOEO6m9_ZjjR9QSqAGZv5s6YcBHq7oRnmNirdM=Q@mail.gmail.com>
Message-ID: <alpine.DEB.2.10.1501311341580.21504@nzrgulfg.ivfhpber.pbz>


On Fri, 30 Jan 2015, Nick Simpson wrote:

> This has been discussed before. I believe most people don't expect Bitcoin to replace all of the various methods of payment.? Scalability is
> always a concern, just not to the level of? Alipay this year (or the next or the next for that matter.)

Yes, that about summarizes it.

The block chain is a single channel broadcasted over the entire 
world, and I don't believe it will ever be possible nor desirable to broadcast all the 
world's transactions over one channel.

The everyone-validates-everything approach doesn't scale. It is however
useful to settle larger transactions in an irreversible, zero-trust way. 
That's what makes the bitcoin system, as it is now, valuable.

But it is absurd for the whole world to have to validate every purchase of 
a cup of coffee or a bus ticket by six billion others.

Naively scaling up the block size will get some leeway in the short term, 
but I believe a future scalable payment system based on bitcoin will be 
mostly based on off-blockchain transactions (in some form) or that there 
will be a hierarchical or subdivided system (e.g. temporary or per-locale 
sidechains).

Wladimir

From mike at plan99.net  Sat Jan 31 17:04:52 2015
From: mike at plan99.net (Mike Hearn)
Date: Sat, 31 Jan 2015 18:04:52 +0100
Subject: [Bitcoin-development] Is there a way to estimate the maximum
 number of transactions per minute Bitcoin can handle as it is today?
In-Reply-To: <CADZB0_aWkSApjRA-WQcVsonOTpZNX8=G=iuY3k+dKSwDq=xM6A@mail.gmail.com>
References: <CADZB0_aWkSApjRA-WQcVsonOTpZNX8=G=iuY3k+dKSwDq=xM6A@mail.gmail.com>
Message-ID: <CANEZrP3+ca9Bumv=-2ot7T5s6cvGhN_dMqYmsxP7qP1V0WV4qg@mail.gmail.com>

>
> "Alipay handled up to 2.85 million transactions per minute, and 54 percent
> of its transactions are made via mobile device."
>

I know China is a very big place but even so - 47,500 transactions per
second would be almost quintiple what Visa handles across the entire world.
With only 300 million users and primarily online usage (?) this claim feels
a little suspect to me.

Given the wording "up to 2.85 million" I wonder if that is some freak spike
caused by people's behaviour being synchronised externally (e.g. a fixed
start time for the sale that people are waiting for). It's hard to imagine
that they sustained anything close to that for the entire day.

So this is really a discussion about peak performance.

If you average every transaction around 250 bytes, then you'd need ~15
> Gigabytes per block to be broadcast and hashed by all the full nodes every
> 10 minutes, eating good 2Tb of storage daily... do miners have enough
> bandwidth and CPU power to handle this?
>

There's a discussion of such things here that might be useful:

https://en.bitcoin.it/wiki/Scalability

It discusses various optimisations, like not actually sending tx data twice.

I wouldn't worry about it too much. It took decades for Visa to even
approach 10,000 txns/sec. PayPal, I believe, still "only" handles a few
hundred. And those services had the benefits of minimal competition,
working in people's local currencies, integrated dispute mediation and not
representing any real threat to the political status quo. Bitcoin isn't
going to be needing to handle Alipay's level of traffic any time soon.

Frankly, scaling is a nice problem to have, it means you're popular. It'd
be a mistake to just blindly assume Bitcoin will take over the world.
Growing market share is difficult. Worry more about how to get 300 million
crazy users than the precise broadcast protocol that'd be needed to handle
them ;)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150131/a5d02aba/attachment.html>

From mike at plan99.net  Sat Jan 31 17:19:35 2015
From: mike at plan99.net (Mike Hearn)
Date: Sat, 31 Jan 2015 18:19:35 +0100
Subject: [Bitcoin-development] New BIP: protocol for multisignature
	payments
In-Reply-To: <1422667849.25602.6.camel@TARDIS>
References: <1422667849.25602.6.camel@TARDIS>
Message-ID: <CANEZrP2V0+M5B0P3T6cUqmSh-0FTP5_VgNcegwQTQQM7XMfMsA@mail.gmail.com>

Hi Martin,

You're on the right lines. Your writeup is pretty similar to the high level
overview given here though:

https://en.bitcoin.it/wiki/Contracts#Example_2:_Escrow_and_dispute_mediation

To make 2-of-3 dispute mediation works requires implementing a wallet that
supports it, and the tools mediators need to manage incoming tickets, etc.
The BIP70 extension is probably the smallest part of the project.


On Sat, Jan 31, 2015 at 2:30 AM, Martin Habov?tiak <
martin.habovstiak at gmail.com> wrote:

> Hello,
>
> I've been thinking about how to solve security problems of the servers
> holding huge amounts of bitcoins (exchanges, markets...) and came up
> with this idea: https://gist.github.com/Kixunil/2ec79cf40a53fb899ac5
>
> TL;DR: it's extension of BIP70 (but not fully compatible due to security
> reasons) which supports making of multisig transactions dynamically.
> (The most important thing is that the user provides his address.)
>
> What do you think? Is it a good way to solve the problem or do you know
> about something better? I would really like this or something similar
> implemented by wallets.
>
> Thank you for your feedback!
>
> Martin
>
>
> ------------------------------------------------------------------------------
> Dive into the World of Parallel Programming. The Go Parallel Website,
> sponsored by Intel and developed in partnership with Slashdot Media, is
> your
> hub for all things parallel software development, from weekly thought
> leadership blogs to news, videos, case studies, tutorials and more. Take a
> look and join the conversation now. http://goparallel.sourceforge.net/
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150131/0ef5a3d8/attachment.html>

From martin.habovstiak at gmail.com  Sat Jan 31 17:47:07 2015
From: martin.habovstiak at gmail.com (=?UTF-8?Q?Martin_Habov=C5=A1tiak?=)
Date: Sat, 31 Jan 2015 19:47:07 +0200
Subject: [Bitcoin-development] New BIP: protocol for multisignature
	payments
In-Reply-To: <CANEZrP2V0+M5B0P3T6cUqmSh-0FTP5_VgNcegwQTQQM7XMfMsA@mail.gmail.com>
References: <1422667849.25602.6.camel@TARDIS>
	<CANEZrP2V0+M5B0P3T6cUqmSh-0FTP5_VgNcegwQTQQM7XMfMsA@mail.gmail.com>
Message-ID: <CALkkCJav7gQuDuPvWc_SOgVJGyfAorSWGHMvUjUTGZBJcGnNYQ@mail.gmail.com>

I know about that wiki page. I just wanted to design protocol which
would make it easier in practice. (now it would be done manually)

I could look at implementing it someday, but now I'd like to receive
feedback from community.

2015-01-31 19:19 GMT+02:00 Mike Hearn <mike at plan99.net>:
> Hi Martin,
>
> You're on the right lines. Your writeup is pretty similar to the high level
> overview given here though:
>
> https://en.bitcoin.it/wiki/Contracts#Example_2:_Escrow_and_dispute_mediation
>
> To make 2-of-3 dispute mediation works requires implementing a wallet that
> supports it, and the tools mediators need to manage incoming tickets, etc.
> The BIP70 extension is probably the smallest part of the project.
>
>
> On Sat, Jan 31, 2015 at 2:30 AM, Martin Habov?tiak
> <martin.habovstiak at gmail.com> wrote:
>>
>> Hello,
>>
>> I've been thinking about how to solve security problems of the servers
>> holding huge amounts of bitcoins (exchanges, markets...) and came up
>> with this idea: https://gist.github.com/Kixunil/2ec79cf40a53fb899ac5
>>
>> TL;DR: it's extension of BIP70 (but not fully compatible due to security
>> reasons) which supports making of multisig transactions dynamically.
>> (The most important thing is that the user provides his address.)
>>
>> What do you think? Is it a good way to solve the problem or do you know
>> about something better? I would really like this or something similar
>> implemented by wallets.
>>
>> Thank you for your feedback!
>>
>> Martin
>>
>>
>> ------------------------------------------------------------------------------
>> Dive into the World of Parallel Programming. The Go Parallel Website,
>> sponsored by Intel and developed in partnership with Slashdot Media, is
>> your
>> hub for all things parallel software development, from weekly thought
>> leadership blogs to news, videos, case studies, tutorials and more. Take a
>> look and join the conversation now. http://goparallel.sourceforge.net/
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>



From mike at plan99.net  Sat Jan 31 18:07:40 2015
From: mike at plan99.net (Mike Hearn)
Date: Sat, 31 Jan 2015 19:07:40 +0100
Subject: [Bitcoin-development] New BIP: protocol for multisignature
	payments
In-Reply-To: <CALkkCJav7gQuDuPvWc_SOgVJGyfAorSWGHMvUjUTGZBJcGnNYQ@mail.gmail.com>
References: <1422667849.25602.6.camel@TARDIS>
	<CANEZrP2V0+M5B0P3T6cUqmSh-0FTP5_VgNcegwQTQQM7XMfMsA@mail.gmail.com>
	<CALkkCJav7gQuDuPvWc_SOgVJGyfAorSWGHMvUjUTGZBJcGnNYQ@mail.gmail.com>
Message-ID: <CANEZrP2mv2yNtHN7KWFn6crHT_KhrW-GBB0EmK-BOrJQeEqMrg@mail.gmail.com>

>
> I could look at implementing it someday, but now I'd like to receive
> feedback from community.
>

IMO it's better to pair a protocol spec with an implementation. For one, it
can show up issues in the design you didn't think of. For another,
implementation is a lot more work than speccing out a few protocol buffers
and high level procedures, so people who are going to write an
implementation probably won't follow your design unless they have a great
degree of confidence in it and some compelling reason to use it (e.g.
interop with other users).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150131/79e7919b/attachment.html>

From gubatron at gmail.com  Sat Jan 31 20:08:57 2015
From: gubatron at gmail.com (Angel Leon)
Date: Sat, 31 Jan 2015 20:08:57 +0000
Subject: [Bitcoin-development] Is there a way to estimate the maximum
 number of transactions per minute Bitcoin can handle as it is today?
References: <CADZB0_aWkSApjRA-WQcVsonOTpZNX8=G=iuY3k+dKSwDq=xM6A@mail.gmail.com>
	<CANEZrP3+ca9Bumv=-2ot7T5s6cvGhN_dMqYmsxP7qP1V0WV4qg@mail.gmail.com>
Message-ID: <CADZB0_YYXto3SJjq2FcZPUKwsHas3chmgdcxhwhU_Hh6QO1vZg@mail.gmail.com>

My concerns come from 2 projects that could easily raise the current
transaction volume 10x daily in the short term,  perhaps even 100x a year
from now after the media blows it out.

Think legal bittorrent file sales: ebooks, indie music (albums and
singles), films, art, stock photography.

Think p2p amazon (OpenBazaar) and how that could grow exponentially in
terms of transactional volume when ecommerce penetrates geos currently
underserved.

Thanks for your explanations. it seems as of now we must rely on the likes
of centralized solutions like Bitpay, Coinbase to manage the transactional
volume we expect, or just wait for the technology to be ready finally
handle it in a real p2p fashion, no intermediaries.



On Sat, Jan 31, 2015, 6:04 PM Mike Hearn <mike at plan99.net> wrote:

> "Alipay handled up to 2.85 million transactions per minute, and 54 percent
>> of its transactions are made via mobile device."
>>
>
> I know China is a very big place but even so - 47,500 transactions per
> second would be almost quintiple what Visa handles across the entire world.
> With only 300 million users and primarily online usage (?) this claim feels
> a little suspect to me.
>
> Given the wording "up to 2.85 million" I wonder if that is some freak
> spike caused by people's behaviour being synchronised externally (e.g. a
> fixed start time for the sale that people are waiting for). It's hard to
> imagine that they sustained anything close to that for the entire day.
>
> So this is really a discussion about peak performance.
>
> If you average every transaction around 250 bytes, then you'd need ~15
>> Gigabytes per block to be broadcast and hashed by all the full nodes every
>> 10 minutes, eating good 2Tb of storage daily... do miners have enough
>> bandwidth and CPU power to handle this?
>>
>
> There's a discussion of such things here that might be useful:
>
> https://en.bitcoin.it/wiki/Scalability
>
> It discusses various optimisations, like not actually sending tx data
> twice.
>
> I wouldn't worry about it too much. It took decades for Visa to even
> approach 10,000 txns/sec. PayPal, I believe, still "only" handles a few
> hundred. And those services had the benefits of minimal competition,
> working in people's local currencies, integrated dispute mediation and not
> representing any real threat to the political status quo. Bitcoin isn't
> going to be needing to handle Alipay's level of traffic any time soon.
>
> Frankly, scaling is a nice problem to have, it means you're popular. It'd
> be a mistake to just blindly assume Bitcoin will take over the world.
> Growing market share is difficult. Worry more about how to get 300 million
> crazy users than the precise broadcast protocol that'd be needed to handle
> them ;)
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150131/3d6e83e1/attachment.html>

From gavinandresen at gmail.com  Sat Jan 31 21:50:15 2015
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Sat, 31 Jan 2015 17:50:15 -0400
Subject: [Bitcoin-development] New BIP: protocol for multisignature
	payments
In-Reply-To: <CANEZrP2mv2yNtHN7KWFn6crHT_KhrW-GBB0EmK-BOrJQeEqMrg@mail.gmail.com>
References: <1422667849.25602.6.camel@TARDIS>
	<CANEZrP2V0+M5B0P3T6cUqmSh-0FTP5_VgNcegwQTQQM7XMfMsA@mail.gmail.com>
	<CALkkCJav7gQuDuPvWc_SOgVJGyfAorSWGHMvUjUTGZBJcGnNYQ@mail.gmail.com>
	<CANEZrP2mv2yNtHN7KWFn6crHT_KhrW-GBB0EmK-BOrJQeEqMrg@mail.gmail.com>
Message-ID: <CABsx9T2d8ahBo7PC9S5UteHXcVLFtXT7NXjtSS+2sLamQYum1w@mail.gmail.com>

I agree- standards should be descriptive ("here is how this thing I did
works") and NOT proscriptive ("here's what I think will work, lets all try
to do it this way.").


On Sat, Jan 31, 2015 at 2:07 PM, Mike Hearn <mike at plan99.net> wrote:

> I could look at implementing it someday, but now I'd like to receive
>> feedback from community.
>>
>
> IMO it's better to pair a protocol spec with an implementation.
>

-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150131/dbd2ac48/attachment.html>

From brian.erdelyi at gmail.com  Sat Jan 31 22:15:53 2015
From: brian.erdelyi at gmail.com (Brian Erdelyi)
Date: Sat, 31 Jan 2015 18:15:53 -0400
Subject: [Bitcoin-development] Proposal to address Bitcoin malware
Message-ID: <27395C55-CF59-4E65-83CA-73F903272C5F@gmail.com>

Hello all,

The number of incidents involving malware targeting bitcoin users continues to rise.  One category of virus I find particularly nasty is when the bitcoin address you are trying to send money to is modified before the transaction is signed and recorded in the block chain.  This behaviour allows the malware to evade two-factor authentication by becoming active only when the bitcoin address is entered.  This is very similar to how man-in-the-browser malware attack online banking websites.

Out of band transaction verification/signing is one method used with online banking to help protect against this.  This can be done in a variety of ways with SMS, voice, mobile app or even security tokens.  This video demonstrates how HSBC uses a security token to verify transactions online.  https://www.youtube.com/watch?v=Sh2Iha88agE <https://www.youtube.com/watch?v=Sh2Iha88agE>.

Many Bitcoin wallets and services already use Open Authentication (OATH) based one-time passwords (OTP).  Is there any interest (or existing work) in in the Bitcoin community adopting the OATH Challenge-Response Algorithm (OCRA) for verifying transactions?

I know there are other forms of malware, however, I want to get thoughts on this approach as it would involve the use of a decimal representation of the bitcoin address (depending on particular application).  In the HSBC example (see YouTube video above), this was the last 8 digits of the recipient?s account number.  Would it make sense to convert a bitcoin address to decimal and then truncate to 8 digits for this purpose?  I understand that truncating the number in some way only increases the likelihood for collisions? however, would this still be practical or could the malware generate a rogue bitcoin address that would produce the same 8 digits of the legitimate bitcoin address?

Brian Erdelyi
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150131/d4aee3b9/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 842 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150131/d4aee3b9/attachment.sig>

From natanael.l at gmail.com  Sat Jan 31 22:38:55 2015
From: natanael.l at gmail.com (Natanael)
Date: Sat, 31 Jan 2015 23:38:55 +0100
Subject: [Bitcoin-development] Proposal to address Bitcoin malware
In-Reply-To: <27395C55-CF59-4E65-83CA-73F903272C5F@gmail.com>
References: <27395C55-CF59-4E65-83CA-73F903272C5F@gmail.com>
Message-ID: <CAAt2M18kRgJeNGu9GeKabRpTKPX9rVeoYiKoanz99bmV2jaf4w@mail.gmail.com>

Den 31 jan 2015 23:17 skrev "Brian Erdelyi" <brian.erdelyi at gmail.com>:
>
> Hello all,
>
> The number of incidents involving malware targeting bitcoin users
continues to rise.  One category of virus I find particularly nasty is when
the bitcoin address you are trying to send money to is modified before the
transaction is signed and recorded in the block chain.  This behaviour
allows the malware to evade two-factor authentication by becoming active
only when the bitcoin address is entered.  This is very similar to how
man-in-the-browser malware attack online banking websites.
>
> Out of band transaction verification/signing is one method used with
online banking to help protect against this.  This can be done in a variety
of ways with SMS, voice, mobile app or even security tokens.  This video
demonstrates how HSBC uses a security token to verify transactions online.
https://www.youtube.com/watch?v=Sh2Iha88agE.
>
> Many Bitcoin wallets and services already use Open Authentication (OATH)
based one-time passwords (OTP).  Is there any interest (or existing work)
in in the Bitcoin community adopting the OATH Challenge-Response Algorithm
(OCRA) for verifying transactions?
>
> I know there are other forms of malware, however, I want to get thoughts
on this approach as it would involve the use of a decimal representation of
the bitcoin address (depending on particular application).  In the HSBC
example (see YouTube video above), this was the last 8 digits of the
recipient?s account number.  Would it make sense to convert a bitcoin
address to decimal and then truncate to 8 digits for this purpose?  I
understand that truncating the number in some way only increases the
likelihood for collisions? however, would this still be practical or could
the malware generate a rogue bitcoin address that would produce the same 8
digits of the legitimate bitcoin address?

See vanitygen. Yes, 8 characters can be bruteforced.

You need about 100 bits of security for strong security, and at the very
least NOT less than ~64 (see distributed bruteforce projects attacking 64
bit keys for reference, you can find plenty via Google).

You shouldn't rely on mechanisms intended to be used for one-shot auth
where the secret is supposed to be unguessable for another system where the
attacker knows what the target string is and have a fair amount of time to
attempt bruteforce.

Use something more like HMAC instead.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150131/9343c650/attachment.html>

From martin.habovstiak at gmail.com  Sat Jan 31 23:02:45 2015
From: martin.habovstiak at gmail.com (=?UTF-8?Q?Martin_Habov=C5=A1tiak?=)
Date: Sun, 1 Feb 2015 01:02:45 +0200
Subject: [Bitcoin-development] New BIP: protocol for multisignature
	payments
In-Reply-To: <CABsx9T2d8ahBo7PC9S5UteHXcVLFtXT7NXjtSS+2sLamQYum1w@mail.gmail.com>
References: <1422667849.25602.6.camel@TARDIS>
	<CANEZrP2V0+M5B0P3T6cUqmSh-0FTP5_VgNcegwQTQQM7XMfMsA@mail.gmail.com>
	<CALkkCJav7gQuDuPvWc_SOgVJGyfAorSWGHMvUjUTGZBJcGnNYQ@mail.gmail.com>
	<CANEZrP2mv2yNtHN7KWFn6crHT_KhrW-GBB0EmK-BOrJQeEqMrg@mail.gmail.com>
	<CABsx9T2d8ahBo7PC9S5UteHXcVLFtXT7NXjtSS+2sLamQYum1w@mail.gmail.com>
Message-ID: <CALkkCJahDRBbCeKZYnL16VXugKkJ7vyZmzvfJOHkBbcqKfGcrg@mail.gmail.com>

I didn't consider that, thank you for feedback! I will try to find
some time for implementing it. I'll write again then.

2015-01-31 23:50 GMT+02:00 Gavin Andresen <gavinandresen at gmail.com>:
> I agree- standards should be descriptive ("here is how this thing I did
> works") and NOT proscriptive ("here's what I think will work, lets all try
> to do it this way.").
>
>
> On Sat, Jan 31, 2015 at 2:07 PM, Mike Hearn <mike at plan99.net> wrote:
>>>
>>> I could look at implementing it someday, but now I'd like to receive
>>> feedback from community.
>>
>>
>> IMO it's better to pair a protocol spec with an implementation.
>
>
> --
> --
> Gavin Andresen



From brian.erdelyi at gmail.com  Sat Jan 31 23:04:57 2015
From: brian.erdelyi at gmail.com (Brian Erdelyi)
Date: Sat, 31 Jan 2015 19:04:57 -0400
Subject: [Bitcoin-development] Proposal to address Bitcoin malware
In-Reply-To: <CAAt2M18kRgJeNGu9GeKabRpTKPX9rVeoYiKoanz99bmV2jaf4w@mail.gmail.com>
References: <27395C55-CF59-4E65-83CA-73F903272C5F@gmail.com>
	<CAAt2M18kRgJeNGu9GeKabRpTKPX9rVeoYiKoanz99bmV2jaf4w@mail.gmail.com>
Message-ID: <1348028F-26F8-42CB-9859-C9CB751BF0C9@gmail.com>

> See vanitygen. Yes, 8 characters can be brute forced.
> 

Thank you for this reference.  Interesting to see that there is a tool to generate a vanity bitcoin address.

I am still researching viruses that are designed to manipulate a bitcoin address.  I suspect they are primitive in that they use a hardcoded rogue bitcoin address as opposed to dynamically generating one.

As a start, this would help protect against malware that uses a static rogue bitcoin address.  The next thing would be for the malware to brute-force the legitimate bitcoin address and generate a rogue bitcoin address that would produce the same 8 digit code.  Curious to know how long this brute force would take?  Or perhaps, before converting to 8 digits there is some other hashing function that is performed.

Brian Erdelyi
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150131/88a7c6ef/attachment.html>

From natanael.l at gmail.com  Sat Jan 31 23:37:51 2015
From: natanael.l at gmail.com (Natanael)
Date: Sun, 1 Feb 2015 00:37:51 +0100
Subject: [Bitcoin-development] Proposal to address Bitcoin malware
In-Reply-To: <1348028F-26F8-42CB-9859-C9CB751BF0C9@gmail.com>
References: <27395C55-CF59-4E65-83CA-73F903272C5F@gmail.com>
	<CAAt2M18kRgJeNGu9GeKabRpTKPX9rVeoYiKoanz99bmV2jaf4w@mail.gmail.com>
	<1348028F-26F8-42CB-9859-C9CB751BF0C9@gmail.com>
Message-ID: <CAAt2M1_3BdKQTVxsN7Hc-W=q0_NWyhBg1UAuSwxRQ8BePDa-8g@mail.gmail.com>

Den 1 feb 2015 00:05 skrev "Brian Erdelyi" <brian.erdelyi at gmail.com>:
>>
>> See vanitygen. Yes, 8 characters can be brute forced.
>
> Thank you for this reference.  Interesting to see that there is a tool to
generate a vanity bitcoin address.
>
> I am still researching viruses that are designed to manipulate a bitcoin
address.  I suspect they are primitive in that they use a hardcoded rogue
bitcoin address as opposed to dynamically generating one.
>
> As a start, this would help protect against malware that uses a static
rogue bitcoin address.  The next thing would be for the malware to
brute-force the legitimate bitcoin address and generate a rogue bitcoin
address that would produce the same 8 digit code.  Curious to know how long
this brute force would take?  Or perhaps, before converting to 8 digits
there is some other hashing function that is performed.
>
> Brian Erdelyi

To bruteforce 8 decimals, on average you need (10^8)/2 = 50 000 000 tries.
log(50M)/log(2) = 25.6 bits of entropy.

One try = generate a random number, use it to generate an ECDSA keypair,
SHA256 and RIPEMD160 hash the public key per Bitcoin specs, then run that
OCRA hashing code, then compare strings. Considering the ECDSA operations
is by a large margin slower than all the hash functions, consider them to
just add a small percentage in performance drop vs regular vanitygen usage.

My non-gaming laptop performed IIRC at *a few million keys per second* with
OpenCL. I've used it to search for 6 character strings in the base58
Bitcoin addresses with it in 15 minutes to half an hour or so. That's about
35 bits of entropy (rough estimate, there's some details with padding in
the base58 representation that alters it).

So 2^(35-26) ~= 1 in 500 of that time, and that's if you use a laptop
instead of a GPU rig. Seconds at worst. Milliseconds if done on a rig.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150201/aaf8f5e0/attachment.html>

From natanael.l at gmail.com  Sat Jan 31 23:41:54 2015
From: natanael.l at gmail.com (Natanael)
Date: Sun, 1 Feb 2015 00:41:54 +0100
Subject: [Bitcoin-development] Proposal to address Bitcoin malware
In-Reply-To: <CAAt2M1_3BdKQTVxsN7Hc-W=q0_NWyhBg1UAuSwxRQ8BePDa-8g@mail.gmail.com>
References: <27395C55-CF59-4E65-83CA-73F903272C5F@gmail.com>
	<CAAt2M18kRgJeNGu9GeKabRpTKPX9rVeoYiKoanz99bmV2jaf4w@mail.gmail.com>
	<1348028F-26F8-42CB-9859-C9CB751BF0C9@gmail.com>
	<CAAt2M1_3BdKQTVxsN7Hc-W=q0_NWyhBg1UAuSwxRQ8BePDa-8g@mail.gmail.com>
Message-ID: <CAAt2M1-b7ByF0yVSmwD_nj3uUSo5GFOmH860n1k6oKX_sqvEkw@mail.gmail.com>

Den 1 feb 2015 00:37 skrev "Natanael" <natanael.l at gmail.com>:

>
> To bruteforce 8 decimals, on average you need (10^8)/2 = 50 000 000
tries. log(50M)/log(2) = 25.6 bits of entropy.

Oops. Used the wrong number in the entropy calculation. Add one bit, the
division by 2 wasn't supposed to be used in the entropy calculation.
Doesn't change the equation much, though.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150201/3fc6dca4/attachment.html>

