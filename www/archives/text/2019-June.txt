From jlrubin at mit.edu  Sat Jun  1 05:35:45 2019
From: jlrubin at mit.edu (Jeremy)
Date: Fri, 31 May 2019 22:35:45 -0700
Subject: [bitcoin-dev] OP_SECURETHEBAG (supersedes OP_CHECKOUTPUTSVERIFY)
Message-ID: <CAD5xwhjSj82YYuQHHbwgSLvUNV2RDY0b=yMYeLj-p6j7PpS9-Q@mail.gmail.com>

Hi All,

OP_CHECKOUTPUTSHASHVERIFY is retracted in favor of OP_SECURETHEBAG*.
OP_SECURETHEBAG does more or less the same thing, but fixes malleability
issues and lifts the single output restriction to a known number of inputs
restriction.

OP_CHECKOUTPUTSVERIFY had some issues with malleability of version and
locktime. OP_SECURETHEBAG commits to both of these values.

OP_SECURETHEBAG also lifts the restriction that OP_CHECKOUTPUTSVERIFY had
to be spent as only a single input, and instead just commits to the number
of inputs. This allows for more flexibility, but keeps it easy to get the
same single output restriction.

BIP:
https://github.com/JeremyRubin/bips/blob/op-secure-the-bag/bip-secure-the-bag.mediawiki
Implementation: https://github.com/JeremyRubin/bitcoin/tree/secure_the_bag

A particularly useful topic of discussion is how best to eliminate the
PUSHDATA and treat OP_SECURETHEBAG like a pushdata directly. I thought
about how the interpreter works and is implemented and couldn't come up
with something noninvasive.

Thank you for your review and discussion,

Jeremy

* Plus the name is better
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190531/b1cc3a48/attachment-0001.html>

From rusty at rustcorp.com.au  Sun Jun  2 04:41:39 2019
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Sun, 02 Jun 2019 14:11:39 +0930
Subject: [bitcoin-dev] [PROPOSAL] Emergency RBF (BIP 125)
Message-ID: <871s0c1tvg.fsf@rustcorp.com.au>

Hi all,

        I want to propose a modification to rules 3, 4 and 5 of BIP 125:

To remind you of BIP 125:
 3. The replacement transaction pays an absolute fee of at least the sum
    paid by the original transactions.

 4. The replacement transaction must also pay for its own bandwidth at
    or above the rate set by the node's minimum relay fee setting.

 5. The number of original transactions to be replaced and their
    descendant transactions which will be evicted from the mempool must not
    exceed a total of 100 transactions.

The new "emergency RBF" rule:

 6. If the original transaction was not in the first 4,000,000 weight
    units of the fee-ordered mempool and the replacement transaction is,
    rules 3, 4 and 5 do not apply.

This means:

1. RBF can be used in adversarial conditions, such as lightning
   unilateral closes where the adversary has another valid transaction
   and can use it to block yours.  This is a problem when we allow
   differential fees between the two current lightning transactions
   (aka "Bring Your Own Fees").

2. RBF can be used without knowing about miner's mempools, or that the
   above problem is occurring.  One simply gets close to the required
   maximum height for lightning timeout, and bids to get into the next
   block.

3. This proposal does not open any significant new ability to RBF spam,
   since it can (usually) only be used once.  IIUC bitcoind won't
   accept more that 100 descendents of an unconfirmed tx anyway.

4. This proposal makes RBF miner-incentive compatible.  Currently the
   protocol tells miners they shouldn't accept the highest bidding tx
   for the good of the network.  This conflict is particularly sharp
   in the case where the replacement tx would be immediately minable,
   which this proposal addresses.

Unfortunately I haven't found time to code this up in bitcoin, but if
there's positive response I can try.

Thanks for reading!
Rusty.

From ZmnSCPxj at protonmail.com  Sun Jun  2 05:35:43 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sun, 02 Jun 2019 05:35:43 +0000
Subject: [bitcoin-dev] OP_SECURETHEBAG (supersedes OP_CHECKOUTPUTSVERIFY)
In-Reply-To: <CAD5xwhjSj82YYuQHHbwgSLvUNV2RDY0b=yMYeLj-p6j7PpS9-Q@mail.gmail.com>
References: <CAD5xwhjSj82YYuQHHbwgSLvUNV2RDY0b=yMYeLj-p6j7PpS9-Q@mail.gmail.com>
Message-ID: <cf6u26qQgi-J4oe6u_eiBYJVoktC38pFkGFbeqhu5_OcUACFrpyy-d7wLzaGZh6h6hE6c2CbZmKAeiK3-bz8unKGrFMdZldOEk15PdadSKo=@protonmail.com>

> Using an OP_SECURETHEBAG Taproot, the recipient may even give the sender an address which makes a channel unbeknownst to them.


This requires special design to be safe.

Every offchain protocol requires a backout transaction to be created before the funding transaction output is committed onchain.
This backout transaction ensures that the funder of the channel can back out if the other side aborts the protocol.

For Poon-Dryja channels this is the initial commitment transaction.
The continued operation of the protocol requires the initial commitment to be revoked at the next update.

So we need a plausible backout for the receiver first.

To do so, we make the funding transaction address a Taproot with internal pubkey 2-of-2 of the receiver and its channel counterparty.
The Taproot hides a single script alternative, a `OP_SECURETHEBAG` that ensures it is paid out to a pure script (i.e. Taproot internal key is a NUMS point), the scripts forming a revocable output to the receiver (let receiver claim with `OP_CHECKSEQUENCEVERIFY`, or counterparty to revoke immediately if it knows revocation key).

This is essentially a walletless channel open, which I described before with `SIGHASH_NOINPUT`.

Channel factories using `OP_SECURETHEBAG` cannot be updated (i.e. not able to close channels and reuse funds to open new channels offchain), i.e. close-only factories.
The above revocation trick only works with two participants, and it would be largely pointless to have 2-participant factories (unless you were e.g. transporting HTLCs separately from DLCs in two channels of the same factory).

Channel factories based on the Decker-Russell-Osuntokun mechanism ("eltoo") allow reorganizing channels offchain, without hitting the chain at all.
These need `SIGHASH_NOINPUT`/`SIGHASH_ANYPREVOUT`.

For channel factories, `SIGHASH_NOINPUT` is better.
`OP_SECURETHEBAG` requires the funding output to commit to a particular output set.
`SIGHASH_NOINPUT` lets the signatories introduce a new possible output set later.

One might compare `OP_SECURETHEBAG` to MAST, while `SIGHASH_NOINPUT` is comparable to Graftroot.
MAST has a fixed set of alternatives, while Graftroot allows signatories to add new alternatives later.



Regards,
ZmnSCPxj


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Saturday, June 1, 2019 1:35 PM, Jeremy via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi All,
>
> OP_CHECKOUTPUTSHASHVERIFY is retracted in favor of OP_SECURETHEBAG*. OP_SECURETHEBAG does more or less the same thing, but fixes malleability issues and lifts the single output restriction to a known number of inputs restriction.
>
> OP_CHECKOUTPUTSVERIFY had some issues with malleability of version and locktime. OP_SECURETHEBAG commits to both of these values.
>
> OP_SECURETHEBAG also lifts the restriction that OP_CHECKOUTPUTSVERIFY had to be spent as only a single input, and instead just commits to the number of inputs. This allows for more flexibility, but keeps it easy to get the same single output restriction.
>
> BIP: https://github.com/JeremyRubin/bips/blob/op-secure-the-bag/bip-secure-the-bag.mediawiki
> Implementation: https://github.com/JeremyRubin/bitcoin/tree/secure_the_bag
>
> A particularly useful topic of discussion is how best to eliminate the PUSHDATA and treat OP_SECURETHEBAG like a pushdata directly. I thought about how the interpreter works and is implemented and couldn't come up with something noninvasive.
>
> Thank you for your review and discussion,
>
> Jeremy
>
> * Plus the name is better



From roconnor at blockstream.io  Sun Jun  2 14:32:33 2019
From: roconnor at blockstream.io (Russell O'Connor)
Date: Sun, 2 Jun 2019 10:32:33 -0400
Subject: [bitcoin-dev] OP_SECURETHEBAG (supersedes OP_CHECKOUTPUTSVERIFY)
In-Reply-To: <CAD5xwhjSj82YYuQHHbwgSLvUNV2RDY0b=yMYeLj-p6j7PpS9-Q@mail.gmail.com>
References: <CAD5xwhjSj82YYuQHHbwgSLvUNV2RDY0b=yMYeLj-p6j7PpS9-Q@mail.gmail.com>
Message-ID: <CAMZUoKm9aZMCnJzP3YvLZ5oycDG-pss8cYZwan2N71_gc95GDg@mail.gmail.com>

On Sat, Jun 1, 2019 at 12:47 PM Jeremy via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi All,
>
> OP_CHECKOUTPUTSHASHVERIFY is retracted in favor of OP_SECURETHEBAG*.
> OP_SECURETHEBAG does more or less the same thing, but fixes malleability
> issues and lifts the single output restriction to a known number of inputs
> restriction.
>
> OP_CHECKOUTPUTSVERIFY had some issues with malleability of version and
> locktime. OP_SECURETHEBAG commits to both of these values.
>

Can you elaborate a bit more on what the issues were?


> OP_SECURETHEBAG also lifts the restriction that OP_CHECKOUTPUTSVERIFY had
> to be spent as only a single input, and instead just commits to the number
> of inputs. This allows for more flexibility, but keeps it easy to get the
> same single output restriction.
>
> BIP:
> https://github.com/JeremyRubin/bips/blob/op-secure-the-bag/bip-secure-the-bag.mediawiki
> Implementation: https://github.com/JeremyRubin/bitcoin/tree/secure_the_bag
>
> A particularly useful topic of discussion is how best to eliminate the
> PUSHDATA and treat OP_SECURETHEBAG like a pushdata directly. I thought
> about how the interpreter works and is implemented and couldn't come up
> with something noninvasive.
>

I'm not a Core developer but from what I understand, I'd be inclined to to
treat OP_SECURETHEBAG as with an immediate 32-byte parameter by modifying
GetScriptOp to return the 32-byte parameter through pvchRet.

bool GetScriptOp(CScriptBase::const_iterator& pc,
CScriptBase::const_iterator end, opcodetype& opcodeRet,
std::vector<unsigned char>* pvchRet)
{
    opcodeRet = OP_INVALIDOPCODE;
    if (pvchRet)
        pvchRet->clear();
    if (pc >= end)
        return false;

    // Read instruction
    if (end - pc < 1)
        return false;
    unsigned int opcode = *pc++;

    // Immediate operand
    if (opcode <= OP_PUSHDATA4)
    {
        // ...
    }

    if (opcode == OP_SECURETHEBAG) {
        if (end - pc < 0 || (unsigned int)(end - pc) < 32)
            return false;
        if (pvchRet)
            pvchRet->assign(pc, pc + 32);
        pc += 32;
    }

    opcodeRet = static_cast<opcodetype>(opcode);
    return true;
}

and go from there.

Thank you for your review and discussion,
>
> Jeremy
>
> * Plus the name is better
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190602/74ada17f/attachment-0001.html>

From jlrubin at mit.edu  Sun Jun  2 21:32:20 2019
From: jlrubin at mit.edu (Jeremy)
Date: Sun, 2 Jun 2019 14:32:20 -0700
Subject: [bitcoin-dev] OP_SECURETHEBAG (supersedes OP_CHECKOUTPUTSVERIFY)
In-Reply-To: <CAMZUoKm9aZMCnJzP3YvLZ5oycDG-pss8cYZwan2N71_gc95GDg@mail.gmail.com>
References: <CAD5xwhjSj82YYuQHHbwgSLvUNV2RDY0b=yMYeLj-p6j7PpS9-Q@mail.gmail.com>
	<CAMZUoKm9aZMCnJzP3YvLZ5oycDG-pss8cYZwan2N71_gc95GDg@mail.gmail.com>
Message-ID: <CAD5xwhieGt3n+PrnZaqpSGM-fXUnEP_BWMtXH77KuPzSLGF79A@mail.gmail.com>

Hi Russell,

Thanks for the response. I double checked my work in drafting my response
and realized I didn't address all the malleability concerns, I believe I
have now (fingers crossed) addressed all points of malleability.

*The malleability concerns are as follows:*

A TXID is computed as:

def txid(self):
         r = b""
         r += struct.pack("<i", self.nVersion)
         r += ser_vector(self.vin)
         r += ser_vector(self.vout)
         r += struct.pack("<I", self.nLockTime)
         return sha256(r)

if the bag hash is just:

def get_bag_hash(self):
         r = b""
         r += ser_vector(self.vout)
         return TaggedHash("BagHash", r)

We allow changing a few things: nVersion, nLockTime, scriptSig (per input),
number of inputs, nSequence (per input) which can change the TXID/what the
transaction does.

changing nVersion: can disable BIP68, change TXID
changing nLockTime: can change TXID
changing nSequence: can change TXID
changing number of inputs: half spend problem, change TXID
changing scriptsigs: change TXID if co-spent with legacy input

Instead, we can use the following digest:

    def get_bag_hash(self):
         r = b""
         r += struct.pack("<i", self.nVersion)
         r += struct.pack("<I", self.nLockTime)
         r += sha256(b"".join(out.serialize() for out in self.vout))
         r += sha256(b"".join(struct.pack("<I", inp.nSequence) for inp in
self.vin))
         r += struct.pack("<Q", len(self.vin))
         for inp in self.vin:
             r += ser_string(inp.scriptSig)
         return TaggedHash("BagHash", r)

which should lock in all the relevant bits. The only part left out is the
COutpoint, which can't be known ahead of time (because it depends on the
creating txn). Technically, len(vin) is redundant with
sha256(b"".join(struct.pack("<I", inp.nSequence) for inp in self.vin)),
because the length padding on the hash implied the number of inputs, but I
figured it's best to err on explicit.

A further benefit (in a CISC sense) of committing to all these values is
that we enforce CLTV and CSV semantics for free on OP_SECURETHEBAG scripts,
which helps with channels.



*Treating OP_SECURETHEBAG as a PUSHDATA:*

I agree in theory it's nicer, and am 100% open to implementing it that way.
The only concern I have with doing it this way is that it means that a
flags must be added to GetOp (or GetOp must be modularized to be per-script
version) because it affects script parsing, as opposed to using a multibyte
opcode which contains a pushdata, which remain compatible with prior script
parsing.

I'd like to get rough consensus on the best approach for compatibility with
downstream software, hence choosing this option for the draft.

Personally, my preference is to *not* do flags and just have a separate
parser version which cleans up some of our past sins. We can experiment
with a fancier parser (as you've shown in Haskell/Rust/Coq), perhaps even
bitwise huffman encoding opcodes to save space on scripts (i.e. the 7 most
common opcodes could fit within 3 bits) or whatever else we like. I just
didn't want to have the scope creep too far on this particular BIP, but I'm
with you that lookahead is a hack compared to an actual parametrized
argument.

I think you'd also appreciate the template script expansion approach
mentioned in the BIP -- it gets around some of these concerns, but requires
changes to Taproot.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190602/dfb4e5a2/attachment-0001.html>

From lf-lists at mattcorallo.com  Mon Jun  3 09:48:31 2019
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Mon, 3 Jun 2019 11:48:31 +0200
Subject: [bitcoin-dev] [PROPOSAL] Emergency RBF (BIP 125)
In-Reply-To: <871s0c1tvg.fsf@rustcorp.com.au>
References: <871s0c1tvg.fsf@rustcorp.com.au>
Message-ID: <F252D824-5BE6-4B03-B59D-D40EAFBAEE84@mattcorallo.com>

I think this needs significantly improved motivation/description. A few areas I'd like to see calculated out:

1) wrt rule 3, for this to be obviously-incentive-compatible-for-the-next-miner, I'd think no evicted transactions would be allowed to be in the next block range. This would probably require some significant additional tracking in today's mempool logic.

2) wrt rule 4, I'd like to see a calculation of worst-case free relay. I think we're already not in a great place, but maybe it's worth it or maybe there is some other way to reduce this cost (intuitively it looks like this proposal could make things very, very, very bad).

3) wrt rule 5, I'd like to see benchmarks, it's probably a pretty nasty DoS attack, but it may also be the case that is (a) not worse than other fundamental issues or (b) sufficiently expensive.

4) As I've indicated before, I'm generaly not a fan of such vague protections for time-critical transactions such as payment channel punishment transactions. At a high-level, in this context your counterparty's transactions (not to mention every other transaction in everyone's mempool) are still involved in the decision about whether to accept an RBF, in contrast to previous proposals, which makes it much harder to reason about. As a specific example, if an attacker exploits mempool policy differences they may cause your concept of "top 4M weight" to be bogus for a subeset of nodes, causing propogation to be limited.

Obviously there is also a ton more client-side knowledge required and complexity to RBF decisions here than other previous, more narrowly-targeted proposals.

(I don't think this one use-case being not optimal should prevent such a proposal, i agree it's quite nice for some other cases).

Matt

> On Jun 2, 2019, at 06:41, Rusty Russell <rusty at rustcorp.com.au> wrote:
> 
> Hi all,
> 
>       I want to propose a modification to rules 3, 4 and 5 of BIP 125:
> 
> To remind you of BIP 125:
> 3. The replacement transaction pays an absolute fee of at least the sum
>   paid by the original transactions.
> 
> 4. The replacement transaction must also pay for its own bandwidth at
>   or above the rate set by the node's minimum relay fee setting.
> 
> 5. The number of original transactions to be replaced and their
>   descendant transactions which will be evicted from the mempool must not
>   exceed a total of 100 transactions.
> 
> The new "emergency RBF" rule:
> 
> 6. If the original transaction was not in the first 4,000,000 weight
>   units of the fee-ordered mempool and the replacement transaction is,
>   rules 3, 4 and 5 do not apply.
> 
> This means:
> 
> 1. RBF can be used in adversarial conditions, such as lightning
>  unilateral closes where the adversary has another valid transaction
>  and can use it to block yours.  This is a problem when we allow
>  differential fees between the two current lightning transactions
>  (aka "Bring Your Own Fees").
> 
> 2. RBF can be used without knowing about miner's mempools, or that the
>  above problem is occurring.  One simply gets close to the required
>  maximum height for lightning timeout, and bids to get into the next
>  block.
> 
> 3. This proposal does not open any significant new ability to RBF spam,
>  since it can (usually) only be used once.  IIUC bitcoind won't
>  accept more that 100 descendents of an unconfirmed tx anyway.
> 
> 4. This proposal makes RBF miner-incentive compatible.  Currently the
>  protocol tells miners they shouldn't accept the highest bidding tx
>  for the good of the network.  This conflict is particularly sharp
>  in the case where the replacement tx would be immediately minable,
>  which this proposal addresses.
> 
> Unfortunately I haven't found time to code this up in bitcoin, but if
> there's positive response I can try.
> 
> Thanks for reading!
> Rusty.


From roconnor at blockstream.io  Mon Jun  3 12:56:42 2019
From: roconnor at blockstream.io (Russell O'Connor)
Date: Mon, 3 Jun 2019 08:56:42 -0400
Subject: [bitcoin-dev] [PROPOSAL] Emergency RBF (BIP 125)
In-Reply-To: <871s0c1tvg.fsf@rustcorp.com.au>
References: <871s0c1tvg.fsf@rustcorp.com.au>
Message-ID: <CAMZUoKmXTONMqJ=0Vv7+e=q0CBL5h6Tio-5ec0bmZ+U4psOmCg@mail.gmail.com>

Hi Rusty,

On Sun, Jun 2, 2019 at 9:21 AM Rusty Russell via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> The new "emergency RBF" rule:
>
>  6. If the original transaction was not in the first 4,000,000 weight
>     units of the fee-ordered mempool and the replacement transaction is,
>     rules 3, 4 and 5 do not apply.
>
> This means:
>
> 3. This proposal does not open any significant new ability to RBF spam,
>    since it can (usually) only be used once.  IIUC bitcoind won't
>    accept more that 100 descendents of an unconfirmed tx anyway.
>

Is it not possible for Alice to grief Bob's node by alternating RBFing two
transactions, each one placing itself at the bottom of Bob's top 4,000,000
weight mempool which pushes the other one below the top 4,000,000 weight,
and then repeating with the other transaction?  It might be possible to
amend this proposal to partially mitigate this.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190603/66962193/attachment.html>

From rhavar at protonmail.com  Mon Jun  3 01:49:15 2019
From: rhavar at protonmail.com (rhavar at protonmail.com)
Date: Mon, 03 Jun 2019 01:49:15 +0000
Subject: [bitcoin-dev] [PROPOSAL] Emergency RBF (BIP 125)
In-Reply-To: <871s0c1tvg.fsf@rustcorp.com.au>
References: <871s0c1tvg.fsf@rustcorp.com.au>
Message-ID: <Ol3079c4eDHk0jCv6RMogcx3QPl-bZOr_AQL9siAOCtXSriqZjVhFf53iaJQbaFML0urBNmOaRVJrH848oFWs6ekCW58l4mg1hDXGjiM2WE=@protonmail.com>

+1

>From an incentive-compatible point of view, miners should be accepting transactions that increase the amount of fees that can achieved with 4M weight of transactions, so it seems like a pretty sane plan.

One common problem I've run into with RBF is since you're using RBF you probably want to low ball fees. With good coin selection (*cough* coinsayer.com *cough*), it'll use that opportunity to consolidate inputs. But now let's say fees suddenly spike (pretty common), you might want to fee bump your now stuck transaction. But now that fees are high, it doesn't make sense to be consolidating so ideally you'd just replace it with a much smaller transaction (that pays higher fee rate).


So if anything, I think your proposal doesn't go far enough. I think even in "non-emergency" cases, we could get away with removing the requirement to increase the absolute fee (as long as the fee rate is increased); which also makes it incentive compatible if you assume a reasonable fee-market.

I realize it does open potential DoS vectors, but they seem reasonably small.







-Ryan

??????? Original Message ???????
On Saturday, June 1, 2019 9:41 PM, Rusty Russell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi all,
>
> I want to propose a modification to rules 3, 4 and 5 of BIP 125:
>
> To remind you of BIP 125:
> 3. The replacement transaction pays an absolute fee of at least the sum
> paid by the original transactions.
>
> 4. The replacement transaction must also pay for its own bandwidth at
> or above the rate set by the node's minimum relay fee setting.
>
> 5. The number of original transactions to be replaced and their
> descendant transactions which will be evicted from the mempool must not
> exceed a total of 100 transactions.
>
> The new "emergency RBF" rule:
>
> 6. If the original transaction was not in the first 4,000,000 weight
> units of the fee-ordered mempool and the replacement transaction is,
> rules 3, 4 and 5 do not apply.
>
> This means:
>
> 1.  RBF can be used in adversarial conditions, such as lightning
>     unilateral closes where the adversary has another valid transaction
>     and can use it to block yours. This is a problem when we allow
>     differential fees between the two current lightning transactions
>     (aka "Bring Your Own Fees").
>
> 2.  RBF can be used without knowing about miner's mempools, or that the
>     above problem is occurring. One simply gets close to the required
>     maximum height for lightning timeout, and bids to get into the next
>     block.
>
> 3.  This proposal does not open any significant new ability to RBF spam,
>     since it can (usually) only be used once. IIUC bitcoind won't
>     accept more that 100 descendents of an unconfirmed tx anyway.
>
> 4.  This proposal makes RBF miner-incentive compatible. Currently the
>     protocol tells miners they shouldn't accept the highest bidding tx
>     for the good of the network. This conflict is particularly sharp
>     in the case where the replacement tx would be immediately minable,
>     which this proposal addresses.
>
>     Unfortunately I haven't found time to code this up in bitcoin, but if
>     there's positive response I can try.
>
>     Thanks for reading!
>     Rusty.
>
>
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From rsomsen at gmail.com  Tue Jun  4 11:28:26 2019
From: rsomsen at gmail.com (Ruben Somsen)
Date: Tue, 4 Jun 2019 13:28:26 +0200
Subject: [bitcoin-dev] Formalizing Blind Statechains as a minimalistic blind
	signing server
Message-ID: <CAPv7Tjb11yRix4ts76Rqz08yj=SOA1LBzq5E7gkxcrS26Sp=Ng@mail.gmail.com>

Hi everyone,

For those who are unfamiliar, Statechains enable the transfer UTXOs
off-chain with the help of a Statechain entity (trusted server(s))
without giving them full custodial control over your coins [0]. At
Scaling Bitcoin ?18 [1] I briefly mentioned utilizing blind signatures
[2] to make the entity unaware of what it's signing. I now think this
is the more interesting approach. The functionality can be described
fairly elegantly as follows.

Blind signing server with two functions users can call:

// Start new signature chain
(1) requestNewKey(userPubkey) => returns a new serverPubkey and
registers it to userPubkey

// Extend existing chain
(2) requestBlindSig(userSignature, blindedMessage, nextUserPubkey) =>
returns blindSignature, registers the serverPubkey to nextUserPubkey

The resulting output is a public ECC chain (one blindSignature per
user, one chain per serverPubkey) of blindly signed messages,
requested by users (1, 2, 3, etc.):

userSignature1(blindedMessage1, userPubkey2) => blindSignature1
userSignature2(blindedMessage2, userPubkey3) => blindSignature2
etc.

Assuming the server is honest (more on this below), we can use it to
transfer over the signing rights of a private key without actually
changing the key itself.

The functionality is general and therefore suitable for more than just
Bitcoin, but let's walk through the primary envisioned use case where
we transfer the ownership of a Bitcoin UTXO off-chain. Note that the
server is kept completely unaware that it's handling a BTC
transaction, since it's signing blindly:

- B uses function (1) with userPubkey = B to request serverPubkey A
- B then generates transitory key X, and creates a single MuSig key AX
(key X is called ?transitory? because its private key will later be passed on)
- B prepares tx1: 1BTC to AX (he doesn't send it yet)
- B creates tx2: an eltoo tx [3] that assigns the 1BTC back to B (off-chain)
- B uses (2) with nextUserPubkey = B and blindedMessage = tx2
- B sends tx1 to the blockchain and waits for it to confirm
- B receives a key from C in order to prepare a payment
- B creates tx3: an eltoo tx (with higher priority) with 1BTC to C (off-chain)
- B uses (2) with nextUserPubkey = C and blindedMessage = tx3
- B passes the private key of X (the transitory key) on to C
- C takes blinded tx2 and tx3 from the public server output and
unblinds them with X
- C only accepts the payment if everything is in order [4]

Even if the server goes offline, C can still get the money by sending
tx3 to the blockchain.

A and B can collude to take the money from C, but since all instances
of userSignature and blindSignature are published openly, cheating is
publicly detectable (e.g. the server signed two messages from B
instead of one).

Trust can be distributed by turning the server into a multisig
threshold key, so serverPubkey A becomes e.g. 8-of-12 multisig. This
means security can be on par with federated sidechains [5], and is
similar to how ZmnSCPxj replaced the escrow key with a federation in
?Smart Contracts Unchained? [6].

Lastly, by utilizing adaptor signatures [7], the userSignature can be
tied to the blindSignature. In fact, this can be done for any number
of signatures, allowing multiple signing sessions to take place
atomically [8]. This denies the server the ability to selectively
publish one signature and not the other, allowing safe atomic swaps
via the server.

Essentially, anything that requires UTXO ownership can be achieved
off-chain via Blind Statechains. Coinjoin, Lightning channel
opening/adjusting/closing, Discreet Log Contract style bets [9],
cross-chain atomic swaps, etc. Since the blind signing server
functionality is non-specific to Bitcoin, it'll be useful for
non-cryptocurrency related use cases as well, but I have not given
this a lot of thought.

I also recently published a more high-level overview of Statechains
here, which may be of interest:
https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39

-- Ruben Somsen



[0] Statechains paper:
https://github.com/RubenSomsen/rubensomsen.github.io/blob/master/img/statechains.pdf

[1] Statechains Scaling Bitcoin ?18: http://youtu.be/FI9cwksTrQs?t=47m36s
    Transcript:
http://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/statechains/

[2] Blind signatures, Jonas Nick:
http://diyhpl.us/wiki/transcripts/building-on-bitcoin/2018/blind-signatures-and-scriptless-scripts/

[3] eltoo: https://blockstream.com/eltoo.pdf

[4] Similar to client-side validation, Peter Todd:
https://diyhpl.us/wiki/transcripts/scalingbitcoin/milan/client-side-validation/

[5] Sidechains Appendix A, federated peg: https://blockstream.com/sidechains.pdf

[6] Smart Contracts Unchained ,ZmnSCPxj:
https://zmnscpxj.github.io/bitcoin/unchained.html

[7] Adaptor signatures, Andrew Poelstra:
http://diyhpl.us/wiki/transcripts/layer2-summit/2018/scriptless-scripts/

[8] Adam Gibson (Waxwing) separately made a similar observation on his
blog: https://joinmarket.me/blog/blog/multiparty-s6/

[9] Discreet Log Contracts, Thaddeus Dryja: https://adiabat.github.io/dlc.pdf

From aj at erisian.com.au  Wed Jun  5 09:30:39 2019
From: aj at erisian.com.au (Anthony Towns)
Date: Wed, 5 Jun 2019 19:30:39 +1000
Subject: [bitcoin-dev] OP_SECURETHEBAG (supersedes OP_CHECKOUTPUTSVERIFY)
In-Reply-To: <CAD5xwhjSj82YYuQHHbwgSLvUNV2RDY0b=yMYeLj-p6j7PpS9-Q@mail.gmail.com>
References: <CAD5xwhjSj82YYuQHHbwgSLvUNV2RDY0b=yMYeLj-p6j7PpS9-Q@mail.gmail.com>
Message-ID: <20190605093039.xfo7lcylqkhsfncv@erisian.com.au>

On Fri, May 31, 2019 at 10:35:45PM -0700, Jeremy via bitcoin-dev wrote:
> OP_CHECKOUTPUTSHASHVERIFY is retracted in favor of OP_SECURETHEBAG*.

I think you could generalise that slightly and make it fit in
with the existing opcode naming by calling it something like
"OP_CHECKTXDIGESTVERIFY" and pull a 33-byte value from the stack,
consisting of a sha256 hash and a sighash-byte, and adding a new sighash
value corresponding to the set of info you want to include in the hash,
which I think sounds a bit like "SIGHASH_EXACTLY_ONE_INPUT | SIGHASH_ALL"

FWIW, I'm not really seeing any reason to complicate the spec to ensure
the digest is precommitted as part of the opcode.

Cheers,
aj


From kanzure at gmail.com  Wed Jun  5 14:24:29 2019
From: kanzure at gmail.com (Bryan Bishop)
Date: Wed, 5 Jun 2019 09:24:29 -0500
Subject: [bitcoin-dev] Fwd: [ots-dev] miniOTS: ots proofs that fit in a tweet
In-Reply-To: <8736konncj.fsf@jb55.com>
References: <8736konncj.fsf@jb55.com>
Message-ID: <CABaSBawj6Su1i0F0-fL4Q1O+wU5rnC41qCno7BF3M2nVFMnVRw@mail.gmail.com>

---------- Forwarded message ---------
From: William Casarin <jb55 at jb55.com>
Date: Wed, Jun 5, 2019 at 9:13 AM
Subject: [ots-dev] miniOTS: ots proofs that fit in a tweet
To: <ots-dev at lists.opentimestamps.org>



Hello OTS people,

Following from my previous post about cleartext OTS proof sharing[1],
I've been working on a new OTS format called miniOTS, which is
minimal/compressed format that allows attestations to fit in a tweet[2]
and for other space constrained contexts.

Just stripping out additional attestations in the standard format only
gets it down to just above ~280 bytes when base58 encoded, which is too
much for a tweet, so I decided to roll a custom format that is a bit
more efficient with attestation and op tags.

The goal was to have small enoughs proofs that I could reply to a tweet
with the stamp of the previous message, instead of relying on external
sites such as @otsproofbot


Current format (210 bytes, 288 bytes base58-encoded):

00000000: 004f 7065 6e54 696d 6573 7461 6d70 7300  .OpenTimestamps.
00000010: 0050 726f 6f66 00bf 89e2 e884 e892 9401  .Proof..........
00000020: 08cb 2d4a f572 8d44 a5b0 7c7b f1ff 78a9  ..-J.r.D..|{..x.
00000030: 1818 7270 13f1 9bbd f4b0 344b 9e93 0c6b  ..rp......4K...k
00000040: 39f0 1020 34fe cad9 edef bab0 3420 e4ee  9.. 4.......4 ..
00000050: d3a7 c608 fff0 107c 31f7 da6c dbf2 3271  .......|1..l..2q
00000060: 904c c5dd f58d eb08 f120 e4f7 3eaf a747  .L....... ..>..G
00000070: 324a f096 1aa0 928d e1c1 91bf 3c38 237d  2J..........<8#}
00000080: d412 c1c0 e94c d4ae 3f76 08f1 045c 4cb3  .....L..?v...\L.
00000090: a4f0 08f7 834d 4b14 68fd 41ff 0083 dfe3  .....MK.h.A.....
000000a0: 0d2e f90c 8e2c 2b68 7474 7073 3a2f 2f62  .....,+https://b
000000b0: 6f62 2e62 7463 2e63 616c 656e 6461 722e  ob.btc.calendar.
000000c0: 6f70 656e 7469 6d65 7374 616d 7073 2e6f  opentimestamps.o
000000d0: 7267                                     rg

miniOTS format (133 bytes, 183 bytes base58-encoded):

00000000: 6f74 7301 8a20 34fe cad9 edef bab0 3420  ots.. 4.......4
00000010: e4ee d3a7 c683 8a7c 31f7 da6c dbf2 3271  .......|1..l..2q
00000020: 904c c5dd f58d eb83 8be4 f73e afa7 4732  .L.........>..G2
00000030: 4af0 961a a092 8de1 c191 bf3c 3823 7dd4  J..........<8#}.
00000040: 12c1 c0e9 4cd4 ae3f 7683 8b5c 4cb3 a48a  ....L..?v..\L...
00000050: f783 4d4b 1468 fd41 9a2b 6874 7470 733a  ..MK.h.A.+https:
00000060: 2f2f 626f 622e 6274 632e 6361 6c65 6e64  //bob.btc.calend
00000070: 6172 2e6f 7065 6e74 696d 6573 7461 6d70  ar.opentimestamp
00000080: 732e 6f72 67                             s.org


base58 before:

12j6JNmon36jC1MMcpvC8nHqg5p8DAT2mmPQ5aLaBmAbk8naEVt8HFVohRqkuMXZF2Wo2n9kv
5ByeL17yUww4NHuFyCT6PXsGxRuEZ12Z33gsLbXL5FuFmnvMLd3tzf76n69J7qxLPxmoAgm1z
9NEMi2MRypDNKy1GypGN5NLwerzy1nU5g5dZxV6TZ5rBs4gYqnMNJn9VMkfKeDSZ9M8aoMWrL
ShokXUpnS1qrqkTvTwyKMx17fhKfcP9FyhNkb81t8dwYLtBsN4QuP9UAktMUvjEoBzHt

base58 after:

6gQjQUehytgUevKLRtAFYbC6UJX72LCDgVWxAUPsCt3tqEVTEQfmUB1T1Y1GTyY8sugiPY97K
gWRPPXYJmH3J5jqVtyNLrzdkySM6VAYDVckya9BxbUbFB8Gs4U3LHEauTmgCPEhGhiRdC3eFW
63SwfAvKB8Q8Ku8ZM9uASCwWZ8K2AoVabuAn


You can check it out here:

  git clone https://git.sr.ht/~jb55/ots-tool

This is still a work in progress, I haven't built the miniOTS -> OTS
decoder yet.

make
./otsmini file.ots


Cheers,
Will


[1] id:878t1fzn0v.fsf at jb55.com
[2] https://twitter.com/jb55/status/1136260220521336832


-- 
- Bryan
http://heybryan.org/
1 512 203 0507
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190605/e02128e5/attachment.html>

From ZmnSCPxj at protonmail.com  Thu Jun  6 00:09:28 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 06 Jun 2019 00:09:28 +0000
Subject: [bitcoin-dev] Formalizing Blind Statechains as a minimalistic
	blind signing server
In-Reply-To: <CAPv7Tjb11yRix4ts76Rqz08yj=SOA1LBzq5E7gkxcrS26Sp=Ng@mail.gmail.com>
References: <CAPv7Tjb11yRix4ts76Rqz08yj=SOA1LBzq5E7gkxcrS26Sp=Ng@mail.gmail.com>
Message-ID: <8XXMxGjO1b4bM90Khn3tl63lPEBVJ0at9iJa1gZrZbz7NMaA7ANITVbHOJkctvJlxDUwR6H6dhG34Ko8phlu4_h_GcSXvyuYzPyW4ukEdMY=@protonmail.com>

Good morning Ruben,

> At
> Scaling Bitcoin ?18 [1] I briefly mentioned utilizing blind signatures
> [2] to make the entity unaware of what it's signing. I now think this
> is the more interesting approach. The functionality can be described
> fairly elegantly as follows.

I agree.
I had no interest in Statechains at all before, but now that you have blind signing servers, this is significantly more interesting.


>
> Blind signing server with two functions users can call:
>
> // Start new signature chain
> (1) requestNewKey(userPubkey) => returns a new serverPubkey and
> registers it to userPubkey
>
> // Extend existing chain
> (2) requestBlindSig(userSignature, blindedMessage, nextUserPubkey) =>
> returns blindSignature, registers the serverPubkey to nextUserPubkey
>
> The resulting output is a public ECC chain (one blindSignature per
> user, one chain per serverPubkey) of blindly signed messages,
> requested by users (1, 2, 3, etc.):
>
> userSignature1(blindedMessage1, userPubkey2) => blindSignature1
> userSignature2(blindedMessage2, userPubkey3) => blindSignature2
> etc.
>
> Assuming the server is honest (more on this below), we can use it to
> transfer over the signing rights of a private key without actually
> changing the key itself.
>
> The functionality is general and therefore suitable for more than just
> Bitcoin, but let's walk through the primary envisioned use case where
> we transfer the ownership of a Bitcoin UTXO off-chain. Note that the
> server is kept completely unaware that it's handling a BTC
> transaction, since it's signing blindly:
>
> -   B uses function (1) with userPubkey = B to request serverPubkey A
> -   B then generates transitory key X, and creates a single MuSig key AX
>     (key X is called ?transitory? because its private key will later be passed on)
>
> -   B prepares tx1: 1BTC to AX (he doesn't send it yet)
> -   B creates tx2: an eltoo tx [3] that assigns the 1BTC back to B (off-chain)

Of note, is that a Decker-Russell-Osuntokun construction ("eltoo") is not *strictly* required.
We can still make use of the Decker-Wattenhofer construction instead.

The core of Decker-Wattenhofer is a sequence of decrementing-`nSequence` update systems.
Number of maximum updates is limited by the starting `nSequence`, however if we put an update system inside an update system, we can "reset" the `nSequence` of the inner update system by updating the outer update system.
We can chain this concept further and add more update systems nested inside update systems to gain more leverage from the maximum relative wait time.

As we expect fewer updates are needed for statechains than e.g. actual Lightning channels (your given CoinSwap protocol is "only" two updates, for instance) this is usually a good tradeoff,

It is thus possible to use statechains in case `SIGHASH_ANYPREVOUT` is too controversial to get into Bitcoin, provided Schnorr (definitely uncontroversial) does get into Bitcoin.

>     A and B can collude to take the money from C, but since all instances
>     of userSignature and blindSignature are published openly, cheating is
>     publicly detectable (e.g. the server signed two messages from B
>     instead of one).

This still admits the possibility of an exit scam once a few "big enough" swaps are in position to be stolen, trading off earned reputation for cold-stored cash.

>
>     Trust can be distributed by turning the server into a multisig
>     threshold key, so serverPubkey A becomes e.g. 8-of-12 multisig. This
>     means security can be on par with federated sidechains [5], and is
>     similar to how ZmnSCPxj replaced the escrow key with a federation in
>     ?Smart Contracts Unchained? [6].

This makes me happy.

Regards,
ZmnSCPxj

From rsomsen at gmail.com  Thu Jun  6 05:20:31 2019
From: rsomsen at gmail.com (Ruben Somsen)
Date: Thu, 6 Jun 2019 07:20:31 +0200
Subject: [bitcoin-dev] Formalizing Blind Statechains as a minimalistic
 blind signing server
In-Reply-To: <8XXMxGjO1b4bM90Khn3tl63lPEBVJ0at9iJa1gZrZbz7NMaA7ANITVbHOJkctvJlxDUwR6H6dhG34Ko8phlu4_h_GcSXvyuYzPyW4ukEdMY=@protonmail.com>
References: <CAPv7Tjb11yRix4ts76Rqz08yj=SOA1LBzq5E7gkxcrS26Sp=Ng@mail.gmail.com>
	<8XXMxGjO1b4bM90Khn3tl63lPEBVJ0at9iJa1gZrZbz7NMaA7ANITVbHOJkctvJlxDUwR6H6dhG34Ko8phlu4_h_GcSXvyuYzPyW4ukEdMY=@protonmail.com>
Message-ID: <CAPv7TjYXwr7BLtMqh09QV6b_EZGjBBHw+pdq=3k90KV4j1hNJQ@mail.gmail.com>

Hi ZmnSCPxj,

Thank you for your comments.

>Of note, is that a Decker-Russell-Osuntokun construction ("eltoo") is not *strictly* required. We can still make use of the Decker-Wattenhofer construction instead.

Yes, an early draft (from before the eltoo paper) was using that
construction, but it seemed quite unwieldy. Timelocks have to be long,
nesting adds more transactions, channels expire faster with more use,
and tx fee handling is more complex. But you make a good point that if
SIGHASH_ANYPREVOUT turns out to be too controversial (or for
supporting older altcoins), this would be a potential fallback.

>This still admits the possibility of an exit scam once a few "big enough" swaps are in position to be stolen, trading off earned reputation for cold-stored cash.

That is correct. The worst case for security still comes down to
having to trust the federation, but the transitory key, as well as the
blind signature scheme, does add an interesting layer of separation
that makes it essentially "non-custodial". The article I linked has
more on this.

Cheers,
Ruben

On Thu, Jun 6, 2019 at 2:09 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>
> Good morning Ruben,
>
> > At
> > Scaling Bitcoin ?18 [1] I briefly mentioned utilizing blind signatures
> > [2] to make the entity unaware of what it's signing. I now think this
> > is the more interesting approach. The functionality can be described
> > fairly elegantly as follows.
>
> I agree.
> I had no interest in Statechains at all before, but now that you have blind signing servers, this is significantly more interesting.
>
>
> >
> > Blind signing server with two functions users can call:
> >
> > // Start new signature chain
> > (1) requestNewKey(userPubkey) => returns a new serverPubkey and
> > registers it to userPubkey
> >
> > // Extend existing chain
> > (2) requestBlindSig(userSignature, blindedMessage, nextUserPubkey) =>
> > returns blindSignature, registers the serverPubkey to nextUserPubkey
> >
> > The resulting output is a public ECC chain (one blindSignature per
> > user, one chain per serverPubkey) of blindly signed messages,
> > requested by users (1, 2, 3, etc.):
> >
> > userSignature1(blindedMessage1, userPubkey2) => blindSignature1
> > userSignature2(blindedMessage2, userPubkey3) => blindSignature2
> > etc.
> >
> > Assuming the server is honest (more on this below), we can use it to
> > transfer over the signing rights of a private key without actually
> > changing the key itself.
> >
> > The functionality is general and therefore suitable for more than just
> > Bitcoin, but let's walk through the primary envisioned use case where
> > we transfer the ownership of a Bitcoin UTXO off-chain. Note that the
> > server is kept completely unaware that it's handling a BTC
> > transaction, since it's signing blindly:
> >
> > -   B uses function (1) with userPubkey = B to request serverPubkey A
> > -   B then generates transitory key X, and creates a single MuSig key AX
> >     (key X is called ?transitory? because its private key will later be passed on)
> >
> > -   B prepares tx1: 1BTC to AX (he doesn't send it yet)
> > -   B creates tx2: an eltoo tx [3] that assigns the 1BTC back to B (off-chain)
>
> Of note, is that a Decker-Russell-Osuntokun construction ("eltoo") is not *strictly* required.
> We can still make use of the Decker-Wattenhofer construction instead.
>
> The core of Decker-Wattenhofer is a sequence of decrementing-`nSequence` update systems.
> Number of maximum updates is limited by the starting `nSequence`, however if we put an update system inside an update system, we can "reset" the `nSequence` of the inner update system by updating the outer update system.
> We can chain this concept further and add more update systems nested inside update systems to gain more leverage from the maximum relative wait time.
>
> As we expect fewer updates are needed for statechains than e.g. actual Lightning channels (your given CoinSwap protocol is "only" two updates, for instance) this is usually a good tradeoff,
>
> It is thus possible to use statechains in case `SIGHASH_ANYPREVOUT` is too controversial to get into Bitcoin, provided Schnorr (definitely uncontroversial) does get into Bitcoin.
>
> >     A and B can collude to take the money from C, but since all instances
> >     of userSignature and blindSignature are published openly, cheating is
> >     publicly detectable (e.g. the server signed two messages from B
> >     instead of one).
>
> This still admits the possibility of an exit scam once a few "big enough" swaps are in position to be stolen, trading off earned reputation for cold-stored cash.
>
> >
> >     Trust can be distributed by turning the server into a multisig
> >     threshold key, so serverPubkey A becomes e.g. 8-of-12 multisig. This
> >     means security can be on par with federated sidechains [5], and is
> >     similar to how ZmnSCPxj replaced the escrow key with a federation in
> >     ?Smart Contracts Unchained? [6].
>
> This makes me happy.
>
> Regards,
> ZmnSCPxj

From ZmnSCPxj at protonmail.com  Thu Jun  6 06:31:45 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 06 Jun 2019 06:31:45 +0000
Subject: [bitcoin-dev] Formalizing Blind Statechains as a minimalistic
	blind signing server
In-Reply-To: <CAPv7TjYXwr7BLtMqh09QV6b_EZGjBBHw+pdq=3k90KV4j1hNJQ@mail.gmail.com>
References: <CAPv7Tjb11yRix4ts76Rqz08yj=SOA1LBzq5E7gkxcrS26Sp=Ng@mail.gmail.com>
	<8XXMxGjO1b4bM90Khn3tl63lPEBVJ0at9iJa1gZrZbz7NMaA7ANITVbHOJkctvJlxDUwR6H6dhG34Ko8phlu4_h_GcSXvyuYzPyW4ukEdMY=@protonmail.com>
	<CAPv7TjYXwr7BLtMqh09QV6b_EZGjBBHw+pdq=3k90KV4j1hNJQ@mail.gmail.com>
Message-ID: <L118b6Auac7OxL9DmyvXmFldcnSvb1xU807qtsPt6fGY0-fpg55U5VmEdAgC1T87r274UuqZ-iS0yDNBhZfvhsEW3ZHhdl1eb5Cg4I04ckE=@protonmail.com>

Good morning Ruben,


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Thursday, June 6, 2019 1:20 PM, Ruben Somsen <rsomsen at gmail.com> wrote:

> Hi ZmnSCPxj,
>
> Thank you for your comments.
>
> > Of note, is that a Decker-Russell-Osuntokun construction ("eltoo") is not strictly required. We can still make use of the Decker-Wattenhofer construction instead.
>
> Yes, an early draft (from before the eltoo paper) was using that
> construction, but it seemed quite unwieldy. Timelocks have to be long,
> nesting adds more transactions, channels expire faster with more use,
> and tx fee handling is more complex. But you make a good point that if
> SIGHASH_ANYPREVOUT turns out to be too controversial (or for
> supporting older altcoins), this would be a potential fallback.

The lack of `SIGHASH_ANYPREVOUT` does make it difficult to operate a channel factory.
Factory operations would still require the signatures of all participants, but once a participant has released its signature, it cannot be sure whether its channels should be rooted on the previous factory state or the next (i.e. the [Stale Factory problem](https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-April/001974.html) ).
This is fixable if we use `SIGHASH_ANYPREVOUT` on channel update transactions.
Alternately without that flag we can run channels rooted on both the previous and next factory states, which actually is similar to what we need to do for splice-in (so we could reuse that code, possibly).

>
> > This still admits the possibility of an exit scam once a few "big enough" swaps are in position to be stolen, trading off earned reputation for cold-stored cash.
>
> That is correct. The worst case for security still comes down to
> having to trust the federation, but the transitory key, as well as the
> blind signature scheme, does add an interesting layer of separation
> that makes it essentially "non-custodial". The article I linked has
> more on this.

Of note is that this is roughly the same as the common key in my own Smart Contracts Unchained.

If `SIGHASH_ANYPREVOUT` ends up requiring a chaperone signature, it seems this transitory/common key can be used for the chaperone.

Going further on Smart Contracts Unchained, I observe that the below:

> // Start new signature chain
> (1) requestNewKey(userPubkey) => returns a new serverPubkey and registers it to userPubkey
> // Extend existing chain
> (2) requestBlindSig(userSignature, blindedMessage, nextUserPubkey) => returns blindSignature, registers the serverPubkey to nextUserPubkey

Can be generalized, such that instead of pubKeys and their signatures, we have validation programs and their witnesses.

For example, instead of userPubkey and nextUserPubkey we have a userScript and nextUserScript, with userSignature replaced by a userWitness.

This would be nearer to my own Smart Contracts Unchained, though without committing to the smart contract onchain, only offchain in the server.



>
> Cheers,
> Ruben
>
> On Thu, Jun 6, 2019 at 2:09 AM ZmnSCPxj ZmnSCPxj at protonmail.com wrote:
>
> > Good morning Ruben,
> >
> > > At
> > > Scaling Bitcoin ?18 [1] I briefly mentioned utilizing blind signatures
> > > [2] to make the entity unaware of what it's signing. I now think this
> > > is the more interesting approach. The functionality can be described
> > > fairly elegantly as follows.
> >
> > I agree.
> > I had no interest in Statechains at all before, but now that you have blind signing servers, this is significantly more interesting.
> >
> > > Blind signing server with two functions users can call:
> > > // Start new signature chain
> > > (1) requestNewKey(userPubkey) => returns a new serverPubkey and
> > > registers it to userPubkey
> > > // Extend existing chain
> > > (2) requestBlindSig(userSignature, blindedMessage, nextUserPubkey) =>
> > > returns blindSignature, registers the serverPubkey to nextUserPubkey
> > > The resulting output is a public ECC chain (one blindSignature per
> > > user, one chain per serverPubkey) of blindly signed messages,
> > > requested by users (1, 2, 3, etc.):
> > > userSignature1(blindedMessage1, userPubkey2) => blindSignature1
> > > userSignature2(blindedMessage2, userPubkey3) => blindSignature2
> > > etc.
> > > Assuming the server is honest (more on this below), we can use it to
> > > transfer over the signing rights of a private key without actually
> > > changing the key itself.
> > > The functionality is general and therefore suitable for more than just
> > > Bitcoin, but let's walk through the primary envisioned use case where
> > > we transfer the ownership of a Bitcoin UTXO off-chain. Note that the
> > > server is kept completely unaware that it's handling a BTC
> > > transaction, since it's signing blindly:
> > >
> > > -   B uses function (1) with userPubkey = B to request serverPubkey A
> > >
> > > -   B then generates transitory key X, and creates a single MuSig key AX
> > >     (key X is called ?transitory? because its private key will later be passed on)
> > >
> > > -   B prepares tx1: 1BTC to AX (he doesn't send it yet)
> > >
> > > -   B creates tx2: an eltoo tx [3] that assigns the 1BTC back to B (off-chain)
> > >
> >
> > Of note, is that a Decker-Russell-Osuntokun construction ("eltoo") is not strictly required.
> > We can still make use of the Decker-Wattenhofer construction instead.
> > The core of Decker-Wattenhofer is a sequence of decrementing-`nSequence` update systems.
> > Number of maximum updates is limited by the starting `nSequence`, however if we put an update system inside an update system, we can "reset" the `nSequence` of the inner update system by updating the outer update system.
> > We can chain this concept further and add more update systems nested inside update systems to gain more leverage from the maximum relative wait time.
> > As we expect fewer updates are needed for statechains than e.g. actual Lightning channels (your given CoinSwap protocol is "only" two updates, for instance) this is usually a good tradeoff,
> > It is thus possible to use statechains in case `SIGHASH_ANYPREVOUT` is too controversial to get into Bitcoin, provided Schnorr (definitely uncontroversial) does get into Bitcoin.
> >
> > >     A and B can collude to take the money from C, but since all instances
> > >     of userSignature and blindSignature are published openly, cheating is
> > >     publicly detectable (e.g. the server signed two messages from B
> > >     instead of one).
> > >
> >
> > This still admits the possibility of an exit scam once a few "big enough" swaps are in position to be stolen, trading off earned reputation for cold-stored cash.
> >
> > >     Trust can be distributed by turning the server into a multisig
> > >     threshold key, so serverPubkey A becomes e.g. 8-of-12 multisig. This
> > >     means security can be on par with federated sidechains [5], and is
> > >     similar to how ZmnSCPxj replaced the escrow key with a federation in
> > >     ?Smart Contracts Unchained? [6].
> > >
> >
> > This makes me happy.
> > Regards,
> > ZmnSCPxj



From ZmnSCPxj at protonmail.com  Thu Jun  6 07:30:13 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 06 Jun 2019 07:30:13 +0000
Subject: [bitcoin-dev] OP_SECURETHEBAG (supersedes OP_CHECKOUTPUTSVERIFY)
In-Reply-To: <20190605093039.xfo7lcylqkhsfncv@erisian.com.au>
References: <CAD5xwhjSj82YYuQHHbwgSLvUNV2RDY0b=yMYeLj-p6j7PpS9-Q@mail.gmail.com>
	<20190605093039.xfo7lcylqkhsfncv@erisian.com.au>
Message-ID: <im0q8670MxshmvMLmoJU0dv4rFhwWZNvQeQYv7i4fBWJOx0ghAdH8fYuQSqNxO2z8uxXGV-kurinUDfl0FsLWD0knw_U_h3zVZ0xy7vmn8o=@protonmail.com>

Good morning aj,


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Wednesday, June 5, 2019 5:30 PM, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Fri, May 31, 2019 at 10:35:45PM -0700, Jeremy via bitcoin-dev wrote:
>
> > OP_CHECKOUTPUTSHASHVERIFY is retracted in favor of OP_SECURETHEBAG*.
>
> I think you could generalise that slightly and make it fit in
> with the existing opcode naming by calling it something like
> "OP_CHECKTXDIGESTVERIFY" and pull a 33-byte value from the stack,
> consisting of a sha256 hash and a sighash-byte, and adding a new sighash
> value corresponding to the set of info you want to include in the hash,
> which I think sounds a bit like "SIGHASH_EXACTLY_ONE_INPUT | SIGHASH_ALL"
>
> FWIW, I'm not really seeing any reason to complicate the spec to ensure
> the digest is precommitted as part of the opcode.
>

I believe in combination with `OP_LEFT` and `OP_CAT` this allows Turing-complete smart contracts, in much the same way as `OP_CHECKSIGFROMSTACK`?

Pass in the spent transaction (serialised for txid) and the spending transaction (serialised for sighash) as part of the witness of the spending transaction.

Script verifies that the spending transaction witness value is indeed the spending transaction by `OP_SHA256 <SIGHASH_ALL> OP_SWAP OP_CAT OP_CHECKTXDIGESTVERIFY`.
Script verifies the spent transaction witness value is indeed the spent transaction by hashing it, then splitting up the hash with `OP_LEFT` into bytes, and comparing the bytes to the bytes in the input of the spending transaction witness value (txid being the bytes in reversed order).

Then the Script can extract a commitment of itself by extracting the output of the spent transaction.
This lets the Script check that the spending transaction also pays to the same script.

The Script can then access a state value, for example from an `OP_RETURN` output of the spent transaction, and enforce that a correct next-state is used in the spending transaction.
If the state is too large to fit in a standard `OP_RETURN`, then the current state can be passed in as a witness and validated against a hash commitment in an `OP_RETURN` output.

I believe this is the primary reason against not pulling data from the stack.

Regards,
ZmnSCPxj

From kanzure at gmail.com  Fri Jun  7 15:02:13 2019
From: kanzure at gmail.com (Bryan Bishop)
Date: Fri, 7 Jun 2019 10:02:13 -0500
Subject: [bitcoin-dev] Transcripts from coredev.tech Amsterdam 2019 meeting
Message-ID: <CABaSBazFqeS6-jtAbhK7eyzihz=qUv6eKDWdWV9Tp4HZjqSWsQ@mail.gmail.com>

Hi,

The following are some notes from the coredev.tech Amsterdam 2019 meeting.
Any mistakes are my probably my own.

Here is a conversation about the code review process in Bitcoin Core:
http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-05-code-review/

Here is a conversation with some of the maintainers about what problems
they are seeing:
http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-06-maintainers/

Wallet re-architecture discussion
http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-05-wallet-architecture/

Great consensus cleanup
http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-06-great-consensus-cleanup/

SIGHASH_NOINPUT, OP_CHECKSIGFROMSTACK, OP_CHECKOUTPUTSHASHVERIFY,
OP_SECURETHEBAG
http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-06-noinput-etc/

Taproot discussion
http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-06-taproot/

Utreexo
http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-06-utreexo/

assumeutxo
http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-assumeutxo/

Hardware wallets and HWI
http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-hardware-wallets/

bip151, p2p encryption and v2 message format
http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-p2p-encryption/

Signet for bitcoin test networks
http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-signet/

Statechains overview
http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-statechains/

Thanks,
- Bryan
https://heybryan.org/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190607/ffa4857e/attachment.html>

From me at emilengler.com  Fri Jun  7 23:49:16 2019
From: me at emilengler.com (Emil Engler)
Date: Sat, 8 Jun 2019 01:49:16 +0200
Subject: [bitcoin-dev] testnet4
Message-ID: <205859a9-635a-e958-a03f-8d9a35e0da1a@emilengler.com>

Hello, I tried myself with some Bitcoin development. For this I used of 
course the Bitcoin testnet. However it took me one hour to sync the 
blockchain with around 1538358 blocks. In my opinion that is too much 
for a testnet. Especially the blockchain size with around 26GB is so 
much. Would it be possible to reset the testnet with a new genesis block 
? And if so, can we setup a fixed cycle for resetting the testnet (For 
example every second 1st of January) ?

Greetings,
Emil Engler

From kanzure at gmail.com  Sat Jun  8 14:21:40 2019
From: kanzure at gmail.com (Bryan Bishop)
Date: Sat, 8 Jun 2019 09:21:40 -0500
Subject: [bitcoin-dev] testnet4
In-Reply-To: <205859a9-635a-e958-a03f-8d9a35e0da1a@emilengler.com>
References: <205859a9-635a-e958-a03f-8d9a35e0da1a@emilengler.com>
Message-ID: <CABaSBawPvOoTwQYQ0ZQc20b3g9GMp_fdz7cogHW25o40iF2UeA@mail.gmail.com>

Be greeted Emil,

On Sat, Jun 8, 2019 at 9:21 AM Emil Engler via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hello, I tried myself with some Bitcoin development. For this I used of
> course the Bitcoin testnet. However it took me one hour to sync the
> blockchain with around 1538358 blocks. In my opinion that is too much
> for a testnet. Especially the blockchain size with around 26GB is so
> much. Would it be possible to reset the testnet with a new genesis block
> ? And if so, can we setup a fixed cycle for resetting the testnet (For
> example every second 1st of January) ?
>

At the moment, I somewhat doubt this is likely to happen. Signet provides
an alternative for configuring multiple separate private and public testing
networks. If you would like to get involved, check out the recent
discussion on the topic recorded here:
http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-signet/

- Bryan
http://heybryan.org/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190608/ae64c521/attachment.html>

From rusty at rustcorp.com.au  Thu Jun  6 03:08:50 2019
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Thu, 06 Jun 2019 12:38:50 +0930
Subject: [bitcoin-dev] [PROPOSAL] Emergency RBF (BIP 125)
In-Reply-To: <CAMZUoKmXTONMqJ=0Vv7+e=q0CBL5h6Tio-5ec0bmZ+U4psOmCg@mail.gmail.com>
References: <871s0c1tvg.fsf@rustcorp.com.au>
	<CAMZUoKmXTONMqJ=0Vv7+e=q0CBL5h6Tio-5ec0bmZ+U4psOmCg@mail.gmail.com>
Message-ID: <87r287o1fh.fsf@rustcorp.com.au>

"Russell O'Connor" <roconnor at blockstream.io> writes:
> Hi Rusty,
>
> On Sun, Jun 2, 2019 at 9:21 AM Rusty Russell via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> The new "emergency RBF" rule:
>>
>>  6. If the original transaction was not in the first 4,000,000 weight
>>     units of the fee-ordered mempool and the replacement transaction is,
>>     rules 3, 4 and 5 do not apply.
>>
>> This means:
>>
>> 3. This proposal does not open any significant new ability to RBF spam,
>>    since it can (usually) only be used once.  IIUC bitcoind won't
>>    accept more that 100 descendents of an unconfirmed tx anyway.
>>
>
> Is it not possible for Alice to grief Bob's node by alternating RBFing two
> transactions, each one placing itself at the bottom of Bob's top 4,000,000
> weight mempool which pushes the other one below the top 4,000,000 weight,
> and then repeating with the other transaction?  It might be possible to
> amend this proposal to partially mitigate this.

Good point.  This will cost Alice approximately one tx every block, but
that may still be annoying.  My intuition says it's hard to play these
games across swathes of non-direct peers, since mempools are in constant
flux and propagation is a bit random.

What mitigations were you thinking?

Cheers,
Rusty.

From rusty at rustcorp.com.au  Thu Jun  6 05:16:54 2019
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Thu, 06 Jun 2019 14:46:54 +0930
Subject: [bitcoin-dev] [PROPOSAL] Emergency RBF (BIP 125)
In-Reply-To: <F252D824-5BE6-4B03-B59D-D40EAFBAEE84@mattcorallo.com>
References: <871s0c1tvg.fsf@rustcorp.com.au>
	<F252D824-5BE6-4B03-B59D-D40EAFBAEE84@mattcorallo.com>
Message-ID: <871s07nvi1.fsf@rustcorp.com.au>

Matt Corallo <lf-lists at mattcorallo.com> writes:
> I think this needs significantly improved motivation/description. A few areas I'd like to see calculated out:
>
> 1) wrt rule 3, for this to be obviously-incentive-compatible-for-the-next-miner, I'd think no evicted transactions would be allowed to be in the next block range. This would probably require some significant additional tracking in today's mempool logic.

This is a good question, which is why I really wanted to look into the
implementation details.  There are some approximations possible wrt. pre-
and post- tx bundle feerate, but they have to be examined closely.

> 2) wrt rule 4, I'd like to see a calculation of worst-case free relay. I think we're already not in a great place, but maybe it's worth it or maybe there is some other way to reduce this cost (intuitively it looks like this proposal could make things very, very, very bad).

I *think* you can currently create a tx at 1 sat/byte, have it
propagate, then RBF it to 2 sat/byte, 3... and do that a few thousand
times before your transaction gets mined.

If that's true, I don't think this proposal makes it worse.

>> 3) wrt rule 5, I'd like to see benchmarks, it's probably a pretty nasty DoS attack, but it may also be the case that is (a) not worse than other fundamental issues or (b) sufficiently expensive.

I thought we still meet rule 5 in practice since bitcoind will never
even accept a tree of unconfirmed txs which is > 100 txs?  That would
still stand, it's just that we'd still consider a replacement.

> 4) As I've indicated before, I'm generaly not a fan of such vague
> protections for time-critical transactions such as payment channel
> punishment transactions.

The bitcoin network offers no propagation guarantees; it's all best
effort anyway.  This makes it no worse, and we can tunnel txs through
the lightning network if we have to.

> At a high-level, in this context your counterparty's transactions (not to mention every other transaction in everyone's mempool) are still involved in the decision about whether to accept an RBF, in contrast to previous proposals, which makes it much harder to reason about. As a specific example, if an attacker exploits mempool policy differences they may cause your concept of "top 4M weight" to be bogus for a subeset of nodes, causing propogation to be limited.

If miners have a conflicting tx in the top 4MSipa, you don't have a
problem.  So an attacker needs to limit propagation in a way which
isolates the miners from either the new tx or the conflicting one, which
is much harder.

> Obviously there is also a ton more client-side knowledge required and complexity to RBF decisions here than other previous, more narrowly-targeted proposals.

Define client-side here?

I'd say from the lightning side it's as simple as a normal RBF policy
until you get within a few blocks of a deadline, then you increase the
fees until it's well within reach of the next block.  You can even
approximate this by looking at fees on the previous block, with some
care for outliers.

> (I don't think this one use-case being not optimal should prevent such a proposal, i agree it's quite nice for some other cases).

I like that it's conceptually simple and inventive-robust, and doesn't
really rely on bitcoind's internal policy mechanics of RBF.

I think in the longer term we're going to need other mechanisms for
restricting abusive propagation anyway, but that's a bit out-of-scope.

Thanks!
Rusty.

From roconnor at blockstream.io  Sun Jun  9 04:21:19 2019
From: roconnor at blockstream.io (Russell O'Connor)
Date: Sun, 9 Jun 2019 00:21:19 -0400
Subject: [bitcoin-dev] [PROPOSAL] Emergency RBF (BIP 125)
In-Reply-To: <87r287o1fh.fsf@rustcorp.com.au>
References: <871s0c1tvg.fsf@rustcorp.com.au>
	<CAMZUoKmXTONMqJ=0Vv7+e=q0CBL5h6Tio-5ec0bmZ+U4psOmCg@mail.gmail.com>
	<87r287o1fh.fsf@rustcorp.com.au>
Message-ID: <CAMZUoKmPAEYwCtiZ90cwiHz7C=WxaTouEy8dJwWC=Tkn5k-_PA@mail.gmail.com>

On Sat, Jun 8, 2019 at 11:59 PM Rusty Russell <rusty at rustcorp.com.au> wrote:

> "Russell O'Connor" <roconnor at blockstream.io> writes:
> > Hi Rusty,
> >
> > On Sun, Jun 2, 2019 at 9:21 AM Rusty Russell via bitcoin-dev <
> > bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> >> The new "emergency RBF" rule:
> >>
> >>  6. If the original transaction was not in the first 4,000,000 weight
> >>     units of the fee-ordered mempool and the replacement transaction is,
> >>     rules 3, 4 and 5 do not apply.
> >>
> >> This means:
> >>
> >> 3. This proposal does not open any significant new ability to RBF spam,
> >>    since it can (usually) only be used once.  IIUC bitcoind won't
> >>    accept more that 100 descendents of an unconfirmed tx anyway.
> >>
> >
> > Is it not possible for Alice to grief Bob's node by alternating RBFing
> two
> > transactions, each one placing itself at the bottom of Bob's top
> 4,000,000
> > weight mempool which pushes the other one below the top 4,000,000 weight,
> > and then repeating with the other transaction?  It might be possible to
> > amend this proposal to partially mitigate this.
>
> Good point.  This will cost Alice approximately one tx every block, but
> that may still be annoying.  My intuition says it's hard to play these
> games across swathes of non-direct peers, since mempools are in constant
> flux and propagation is a bit random.
>
> What mitigations were you thinking?
>

For example,  "If the original transaction was not in the first 4,000,000
weight units of the fee-ordered mempool and the replacement transaction is
in the first 2,000,000 weight units...." might adequately address the issue.
There are probably other ways as well.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190609/e1605c53/attachment.html>

From me at emilengler.com  Sat Jun  8 15:01:50 2019
From: me at emilengler.com (Emil Engler)
Date: Sat, 8 Jun 2019 17:01:50 +0200
Subject: [bitcoin-dev] testnet4
In-Reply-To: <CABaSBawPvOoTwQYQ0ZQc20b3g9GMp_fdz7cogHW25o40iF2UeA@mail.gmail.com>
References: <205859a9-635a-e958-a03f-8d9a35e0da1a@emilengler.com>
	<CABaSBawPvOoTwQYQ0ZQc20b3g9GMp_fdz7cogHW25o40iF2UeA@mail.gmail.com>
Message-ID: <cbe4190d-ee49-b6f0-de99-c526fabff6ab@emilengler.com>

I don't get why the testnet shouldn't be resetted just because there is 
a (probably better) alternative for it. The testnet is still a thing and 
is also used.

Am 08.06.19 um 16:21 schrieb Bryan Bishop:
> Be greeted Emil,
> 
> On Sat, Jun 8, 2019 at 9:21 AM Emil Engler via bitcoin-dev 
> <bitcoin-dev at lists.linuxfoundation.org 
> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
> 
>     Hello, I tried myself with some Bitcoin development. For this I used of
>     course the Bitcoin testnet. However it took me one hour to sync the
>     blockchain with around 1538358 blocks. In my opinion that is too much
>     for a testnet. Especially the blockchain size with around 26GB is so
>     much. Would it be possible to reset the testnet with a new genesis
>     block
>     ? And if so, can we setup a fixed cycle for resetting the testnet (For
>     example every second 1st of January) ?
> 
> 
> At the moment, I somewhat doubt this is likely to happen. Signet 
> provides an alternative for configuring multiple separate private and 
> public testing networks. If you would like to get involved, check out 
> the recent discussion on the topic recorded here:
> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-signet/
> 
> - Bryan
> http://heybryan.org/

From tamas.blummer at gmail.com  Sat Jun  8 18:59:09 2019
From: tamas.blummer at gmail.com (Tamas Blummer)
Date: Sat, 8 Jun 2019 20:59:09 +0200
Subject: [bitcoin-dev] WORKVERIFY: uncensorable contracts hedging biggest
 risk of mining without 3rd party or oracle
Message-ID: <CD8B22E6-6A8C-414B-86F2-D993475FE386@gmail.com>

In an earlier post [1] I suggested an approach to create native Bitcoin contracts that reduce mining's income volatility and received very helpful comments on implementation from Pieter Wuille [2] and Natanael [3]

After processing those comments I instead suggest the following restricted interpretation of nSequence and a new opcode WORKVERIFY that in combination is easier to implement and reason about as it follows the implementation pattern of CHECKSEQUENCEVERIFY[5]

Accumulated work on the blockchain is strictly increasing, therefore transaction eligibility rule with a >= condition on it would need no re-evaluation for descendant blocks, in mempool or at re-org, since additional blocks or re-org can only increase the accumulated work. Accumulated work is just like time, it is actually an alternate measure of time through computation[6], therefore analogous to MTP based restriction implemented with BIP68 [4].

=== (the implementation proposal) ===

(needs soft fork for two reasons, activation logic tbd.)

I. Stricter interpretation of nSequence to optionally refer accumulated work:

Only if bit 31 AND bit 30 is set in nSequence can the transaction be included into any block. This is a restricting a rule of BIP68 [4] that only required bit 31 to be set for unrestricted inclusion into blocks. Otherwise nSequence refers to accumulated work (see encoding later) and it is only viable to include the transaction into a block if the block has >= work accumulated. This would define the meaning of one additional bit in nSequence, but leave all other freedom of later improvement left by BIP68.

II. New WORKVERIFY opcode redefining a NOPx in transaction script as:

Terminate script with false for any reason described in BIP112 or if bit 31 is set but bit 30 is not set and 256 bit unsigned integer on stack is higher than (nSequence &0xffff)>> 6 * 2^((nSequence & 0x3f) + 84)

=== (end proposal) ===

Notes on the work encoding:

Total accumulated work as of now is > 2^90 and if we assume that mining capacity keeps increasing with Moore?s law (double every year) for the next 50 years, then it could sum up to 2^140. We have much less bits available in nSequence therefore we have to encode accumulated work in a floating point number with sufficient precision.

The work accumulated during the current difficulty adjustment cycle is > 2016 * 2^74 which is > 2^84. It is rather unlikely that accumulated work in a difficulty adjustment period drops below 2^80 ever again in future which means we need not be more precise than  2^80/2^90 or 2^-10 to allow for contracts that reference increment until the next adjustment. Therefore a mantissa of 10 bits should be sufficient. Using 6 bits of exponent and an offset of 2^84 we can express the range of [2^84, 2^148) that should be sufficient now and for foreseeable future. Please let me know if the approach is not optimal or future proof in your opinion.

Why, should we build this into Bitcoin ?

The most influential risk factor in miners' investment decision is the anticipated change of difficulty over the time horizon of the mining equipment's expected lifetime. Their investments secure the network. The ability to create contracts that reduce income volatility would lead to additional investment into mining.

A native Bitcoin contract is far superior to alternatives that could be offered on traditional markets as:

a native Bitcoin contract would be:
- uncensorable: It requires only the agreement to terms between those financially involved
- fully collaterized: no counterparty risk which means Miner could buy hedging contracts from any unkown and un-trusted actor that is able to commit collateral
- no oracle is needed
- no disagreement on the settlement
- publicly observable: allow to observe market opinion on future difficulty
- the length of the contract could match miner's investment horizon extending over several difficulty adjustments.

Why not on a side-chain ?

Work is fundamental and intrinsic to the base layer. A contract that reduces earnings volatility helps to attract more capital for mining and therefore increase security on the base layer.

How would this be used?

Miner and Speculator sign a transaction that has an nLockTime of S in the future. This gives both parties the option to alternatively spend committed output in case the other would not follow through and publish committing the collateral until S.

Speculators contribution to collateral is higher than that of the Miner. Miner?s collateral is the premium for the insurance provided by Speculator.

The single output of the transaction has following script:

IF
	<maturity> CHECKLOCKTIMEVERIFY DROP
        <speculator?s key> CHECKSIGVERIFY
ELSE
        <sufficient work> WORKVERIFY DROP
        <miner?s key> CHECKSIGVERIFY
ENDIF

This allows the speculator to take back its collateral plus the option premium after the maturity time point, which would however only be possible if it was not taken earlier by Miner as sufficient work was reached.

The contract in finance terms is an american digital call option with maturity and sufficient work as strike. The Miner profits of the contract if work accumulated is more than contracted in which case he would also have lower mining income, hence the contract would reduce earnings shortcome. The Speculator would earn the option premium if the contracted work was not required until maturity. In this case higher mining income through higher market share compensates Miner for the loss of option premium.  In both cases Miner?s income volatility is reduced. The Speculator may find it attractive to enter the contract if the probability weighted option premium represents an attractive interest on the capital committed.

Contracted work would reflect the consenus of expected difficulty increase over future time horizons. Observing above contracts on the blockchain would allow calculation of market implied forward curve of mining difficulty and its implied volatility which again would help evaluating investment proposals into mining.

An alternate more flexible setup would be a Lightning Network like re-allocation of total collateral. Which would allo parties to mark the option to market (observed work and volatility) as time passes and allow for cooperative unwind.

Tamas Blummer

[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016952.html
[2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016958.html
[3] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016969.html
[4] https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki
[5] https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki
[6] https://medium.com/@tamas.blummer/measuring-time-with-chain-of-blocks-893a38cc06bb
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190608/fae077b6/attachment.sig>

From dave at dtrt.org  Sun Jun  9 14:07:36 2019
From: dave at dtrt.org (David A. Harding)
Date: Sun, 9 Jun 2019 10:07:36 -0400
Subject: [bitcoin-dev] [PROPOSAL] Emergency RBF (BIP 125)
In-Reply-To: <871s07nvi1.fsf@rustcorp.com.au>
References: <871s0c1tvg.fsf@rustcorp.com.au>
	<F252D824-5BE6-4B03-B59D-D40EAFBAEE84@mattcorallo.com>
	<871s07nvi1.fsf@rustcorp.com.au>
Message-ID: <20190609140334.upcqalp24zrecwye@ganymede>

On Thu, Jun 06, 2019 at 02:46:54PM +0930, Rusty Russell via bitcoin-dev wrote:
> Matt Corallo <lf-lists at mattcorallo.com> writes:
> > 2) wrt rule 4, I'd like to see a calculation of worst-case free
> > relay. I think we're already not in a great place, but maybe it's
> > worth it or maybe there is some other way to reduce this cost
> > (intuitively it looks like this proposal could make things very,
> > very, very bad).
> 
> I *think* you can currently create a tx at 1 sat/byte, have it
> propagate, then RBF it to 2 sat/byte, 3... and do that a few thousand
> times before your transaction gets mined.

Yes, the current incremental relay fee in Bitcoin Core is 0.00001000
BTC/KvB.

> If that's true, I don't think this proposal makes it worse.

Here's a scenario that I think shows it being at least 20x worse.

Let's imagine that you create two transactions:

  tx0: A very small transaction (~100 vbytes) that's just 1-in, 1-out.
       At the minimum relay fee, this costs 0.00000100 BTC

  tx1: A child of that transaction that's very large (~100,000 vbytes,
       or almost 400,000 bytes using special scripts that allow witness
       stuffing).  At the minimum relay fee, this costs 0.00100000 BTC

Under the current rules, if an attacker wants to fee-bump tx0 by the
minimum incremental fee (a trivial amount, ~0.00000100 BTC), the
attacker's replacement also needs to pay for the eviction of the huge
child tx1 by that same incremental fee (~0.00100000).

Thus the replacement would cost the attacker a minimum of about
0.00100100 (~1 mBTC) for the original transactions and 0.00100100 for
the replacement (about 2 mBTC total).

The attacker could then spend another 1 mBTC re-attaching the child and
yet another 1 mBTC bumping again, incuring about a 2 mBTC cost per
replacement round.  At writing, 2 mBTC is about $14.00 USD---an amount
that's probably enough to deter most attacks at scale.

* * *

Under the new proposed rule 6, Mallory's replacement cost would be the
amount to get the small tx0 to near the top of the mempool (say
0.00100000 BTC/KvB, so 0.00010000 BTC total).  Because this would evict
the expensive child, it would actually reduce the original amount paid
by the attacker by 90% compared to the previous section's example where
using RBF increased the original costs by 100%.

The 0.1 mBTC cost of this attack is about $0.70 USD today for the
roughly the same data relay use as one round of the currently possible
attack.  In short, if I haven't misplaced a decimal point or made some
other mistake, I think the proposed rule 6 would result in approximately
a 95% reduction in the cost paid by an attacker for wasting 400,000
bytes of bandwidth per node (x60,000 nodes = 24 GB across all nodes, not
counting INV overhead).

Although the attacker might only get one replacement per block per
transaction pair out of this version of the attack, they could execute
the attack many times in parallel using different tranaction pairs.  If
this is combined with the treadmill leapfrogging Russell O'Connor
described elsewhere in this thread, the attack could possibly be
repeated multiple times per block per transaction pair at only slightly
increased cost (to pay the increasing next-block transaction fees).

> >> 3) wrt rule 5, I'd like to see benchmarks, it's probably a pretty
> >> nasty DoS attack, but it may also be the case that is (a) not worse
> >> than other fundamental issues or (b) sufficiently expensive.
> 
> I thought we still meet rule 5 in practice since bitcoind will never
> even accept a tree of unconfirmed txs which is > 100 txs?  That would
> still stand, it's just that we'd still consider a replacement.

Although the BIP125 limit is 100, Bitcoin Core's current default is 25.[1]
(When RBF was implemented in Bitcoin Core, transaction ancestry was only
tracked for purposes of ensuring valid transaction ordering within
blocks; later when CPFP was implemented, ancestry was additionally used
to calculate each transaction's package fee---the value of it and all
its unconfirmed ancestors.  This requires more computation to update
the mempool metadata when the ancestry graph changes.)

Again, I'd be thinking here of something similar to O'Connor's
treadmilling attack where replacements can push each other out of the
top mempool and so create enough churn for a CPU exhaustion attack.

> >>  Obviously there is also a ton more client-side knowledge required
> >>  and complexity to RBF decisions here than other previous, more
> >>  narrowly-targeted proposals.
> I'd say from the lightning side it's as simple as a normal RBF policy
> until you get within a few blocks of a deadline, then you increase the
> fees until it's well within reach of the next block.

It's already hard for wallet software to determine whether or not its
transactions have successfully been relayed.  This proposal requires LN
wallets not only be able to guess where the next-block feerate boundary
is in other nodes' individual mempools (now and in the future for the
time it takes the transaction to propagate to ~100% of miners), but it
possibly requires that under the condition that the LN wallet can't
guess too low because it might not get another chance for relay in the
limited time available before contract expiration.

On top of that, there's O'Connor's suggestion to increase treadmilling
costs by only allowing bumps if they're in the top-half of the
next-block mempool.

Considered that way, I worry that these constraints produce a recipe for
paying extremely high feerates.  If that's an actual risk, is that
actually significantly better than dealing with the existing transaction
pinning issue where one needs to pay a high total fee in order to evict
a bunch of junk descendents?  Paying lots of fees may not be the optimal
solution to the problem of having to pay lots of fees.  :-)

-Dave

[1] Excerpt from bitcoind -help-debug :

  -limitancestorcount=<n>
       Do not accept transactions if number of in-mempool ancestors is <n> or
       more (default: 25)

  -limitdescendantcount=<n>
       Do not accept transactions if any ancestor would have <n> or more
       in-mempool descendants (default: 25)

From tim_jannik at gmx.de  Sun Jun  9 14:55:25 2019
From: tim_jannik at gmx.de (Tim Menapace)
Date: Sun, 09 Jun 2019 16:55:25 +0200
Subject: [bitcoin-dev] bitcoin-dev Digest, Vol 49, Issue 8
In-Reply-To: <mailman.1827.1560068363.7313.bitcoin-dev@lists.linuxfoundation.org>
References: <mailman.1827.1560068363.7313.bitcoin-dev@lists.linuxfoundation.org>
Message-ID: <F1FD5AC3-12F0-4087-8AB6-D7DCF7799FF4@gmx.de>

>I don't get why the testnet shouldn't be >resetted just because there is 
>a (probably better) alternative for it. The >testnet is still a thing and 
>is also used.

Like Bryan said, lot of miners test here. E.g. new firmware versions, hardware prototypes and operation services. Difficulty will be on current levels in a short period of time.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190609/25bbb05c/attachment.html>

From me at emilengler.com  Sun Jun  9 18:56:47 2019
From: me at emilengler.com (Emil Engler)
Date: Sun, 9 Jun 2019 20:56:47 +0200
Subject: [bitcoin-dev] bitcoin-dev Digest, Vol 49, Issue 8
In-Reply-To: <F1FD5AC3-12F0-4087-8AB6-D7DCF7799FF4@gmx.de>
References: <mailman.1827.1560068363.7313.bitcoin-dev@lists.linuxfoundation.org>
	<F1FD5AC3-12F0-4087-8AB6-D7DCF7799FF4@gmx.de>
Message-ID: <d56dfe90-4977-def6-e35b-81bbbdb5c1da@emilengler.com>

But using the testnet means that you actually need to deal with resets. 
There were 2 resets in the past but the last was in 2011.

Am 09.06.19 um 16:55 schrieb Tim Menapace:
>  >I don't get why the testnet shouldn't be >resetted just because there is
>  >a (probably better) alternative for it. The >testnet is still a thing and
>  >is also used.
> 
> Like Bryan said, lot of miners test here. E.g. new firmware versions, 
> hardware prototypes and operation services. Difficulty will be on 
> current levels in a short period of time.

From kanzure at gmail.com  Sun Jun  9 21:14:39 2019
From: kanzure at gmail.com (Bryan Bishop)
Date: Sun, 9 Jun 2019 16:14:39 -0500
Subject: [bitcoin-dev] Transcripts from Breaking Bitcoin 2019
Message-ID: <CABaSBayy_V3ZzS-JwoMBMKy4MgNtz24Sax61o73KqxPJZ20grw@mail.gmail.com>

Hi all,

The following are some notes I took during Breaking Bitcoin 2019, selected
for relevance. Any mistakes are most likely my own.

Carl Dong gave an excellent talk on guix as a replacement for the gitian
build system:
http://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/bitcoin-build-system/
but really just watch his presentation:
https://www.youtube.com/watch?v=I2iShmUTEl8

Mempool analysis, client-side filtering, client updates
http://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/mempool-analysis-simulation/
http://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/neutrino/
http://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/p2p-encryption/

Some privacy and coinjoin talks:
http://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/breaking-bitcoin-privacy/
http://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/breaking-wasabi/

Hardware wallets:
http://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/extracting-seeds-from-hardware-wallets/
http://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/future-of-hardware-wallets/

Bitcoin upgrades:
http://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/secure-protocols-bip-taproot/

p2pool analysis:
http://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/security-attacks-decentralized-mining-pools/

Lightning network:
http://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/lightning-network-routing-security/
http://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/lightning-network-topological-analysis/
http://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/lightning-network-security-panel/

Of possible interest (general, not really development focused):
http://diyhpl.us/wiki/transcripts/breaking-bitcoin/2019/defense-of-bitcoin/

- Bryan
http://heybryan.org/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190609/d578b4da/attachment.html>

From rhavar at protonmail.com  Mon Jun 10 16:34:33 2019
From: rhavar at protonmail.com (rhavar at protonmail.com)
Date: Mon, 10 Jun 2019 16:34:33 +0000
Subject: [bitcoin-dev] [PROPOSAL] Emergency RBF (BIP 125)
In-Reply-To: <20190609140334.upcqalp24zrecwye@ganymede>
References: <871s0c1tvg.fsf@rustcorp.com.au>
	<F252D824-5BE6-4B03-B59D-D40EAFBAEE84@mattcorallo.com>
	<871s07nvi1.fsf@rustcorp.com.au>
	<20190609140334.upcqalp24zrecwye@ganymede>
Message-ID: <Vc5Hs-nKxWVZNRQlA2vc0KTKPN29OtbkcyGmwQzRFk1oc5WME_j0cdFYHAGcU2p2Y9ozTNnXwYhjBS4UyULZkb6UKAxPgeDm8ld3BpJ_VDs=@protonmail.com>

What about this? We store a RBU ("relay bandwidth used") with each transaction in the mempool. Where RBU is defined as the size of the transaction + RBU of all transactions it has evicted.

For a replacement to be valid: The feerate must be higher than what it's evicting, and the fee must be greater than minRelayFee*RBU.




-Ryan

??????? Original Message ???????
On Sunday, June 9, 2019 7:07 AM, David A. Harding via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Thu, Jun 06, 2019 at 02:46:54PM +0930, Rusty Russell via bitcoin-dev wrote:
>
> > Matt Corallo lf-lists at mattcorallo.com writes:
> >
> > > 2.  wrt rule 4, I'd like to see a calculation of worst-case free
> > >     relay. I think we're already not in a great place, but maybe it's
> > >     worth it or maybe there is some other way to reduce this cost
> > >     (intuitively it looks like this proposal could make things very,
> > >     very, very bad).
> > >
> >
> > I think you can currently create a tx at 1 sat/byte, have it
> > propagate, then RBF it to 2 sat/byte, 3... and do that a few thousand
> > times before your transaction gets mined.
>
> Yes, the current incremental relay fee in Bitcoin Core is 0.00001000
> BTC/KvB.
>
> > If that's true, I don't think this proposal makes it worse.
>
> Here's a scenario that I think shows it being at least 20x worse.
>
> Let's imagine that you create two transactions:
>
> tx0: A very small transaction (~100 vbytes) that's just 1-in, 1-out.
> At the minimum relay fee, this costs 0.00000100 BTC
>
> tx1: A child of that transaction that's very large (~100,000 vbytes,
> or almost 400,000 bytes using special scripts that allow witness
> stuffing). At the minimum relay fee, this costs 0.00100000 BTC
>
> Under the current rules, if an attacker wants to fee-bump tx0 by the
> minimum incremental fee (a trivial amount, ~0.00000100 BTC), the
> attacker's replacement also needs to pay for the eviction of the huge
> child tx1 by that same incremental fee (~0.00100000).
>
> Thus the replacement would cost the attacker a minimum of about
> 0.00100100 (~1 mBTC) for the original transactions and 0.00100100 for
> the replacement (about 2 mBTC total).
>
> The attacker could then spend another 1 mBTC re-attaching the child and
> yet another 1 mBTC bumping again, incuring about a 2 mBTC cost per
> replacement round. At writing, 2 mBTC is about $14.00 USD---an amount
> that's probably enough to deter most attacks at scale.
>
> Under the new proposed rule 6, Mallory's replacement cost would be the
> amount to get the small tx0 to near the top of the mempool (say
> 0.00100000 BTC/KvB, so 0.00010000 BTC total). Because this would evict
> the expensive child, it would actually reduce the original amount paid
> by the attacker by 90% compared to the previous section's example where
> using RBF increased the original costs by 100%.
>
> The 0.1 mBTC cost of this attack is about $0.70 USD today for the
> roughly the same data relay use as one round of the currently possible
> attack. In short, if I haven't misplaced a decimal point or made some
> other mistake, I think the proposed rule 6 would result in approximately
> a 95% reduction in the cost paid by an attacker for wasting 400,000
> bytes of bandwidth per node (x60,000 nodes = 24 GB across all nodes, not
> counting INV overhead).
>
> Although the attacker might only get one replacement per block per
> transaction pair out of this version of the attack, they could execute
> the attack many times in parallel using different tranaction pairs. If
> this is combined with the treadmill leapfrogging Russell O'Connor
> described elsewhere in this thread, the attack could possibly be
> repeated multiple times per block per transaction pair at only slightly
> increased cost (to pay the increasing next-block transaction fees).
>
> > > > 3.  wrt rule 5, I'd like to see benchmarks, it's probably a pretty
> > > >     nasty DoS attack, but it may also be the case that is (a) not worse
> > > >     than other fundamental issues or (b) sufficiently expensive.
> > > >
> >
> > I thought we still meet rule 5 in practice since bitcoind will never
> > even accept a tree of unconfirmed txs which is > 100 txs? That would
> > still stand, it's just that we'd still consider a replacement.
>
> Although the BIP125 limit is 100, Bitcoin Core's current default is 25.[1]
> (When RBF was implemented in Bitcoin Core, transaction ancestry was only
> tracked for purposes of ensuring valid transaction ordering within
> blocks; later when CPFP was implemented, ancestry was additionally used
> to calculate each transaction's package fee---the value of it and all
> its unconfirmed ancestors. This requires more computation to update
> the mempool metadata when the ancestry graph changes.)
>
> Again, I'd be thinking here of something similar to O'Connor's
> treadmilling attack where replacements can push each other out of the
> top mempool and so create enough churn for a CPU exhaustion attack.
>
> > > > Obviously there is also a ton more client-side knowledge required
> > > > and complexity to RBF decisions here than other previous, more
> > > > narrowly-targeted proposals.
> > > > I'd say from the lightning side it's as simple as a normal RBF policy
> > > > until you get within a few blocks of a deadline, then you increase the
> > > > fees until it's well within reach of the next block.
>
> It's already hard for wallet software to determine whether or not its
> transactions have successfully been relayed. This proposal requires LN
> wallets not only be able to guess where the next-block feerate boundary
> is in other nodes' individual mempools (now and in the future for the
> time it takes the transaction to propagate to ~100% of miners), but it
> possibly requires that under the condition that the LN wallet can't
> guess too low because it might not get another chance for relay in the
> limited time available before contract expiration.
>
> On top of that, there's O'Connor's suggestion to increase treadmilling
> costs by only allowing bumps if they're in the top-half of the
> next-block mempool.
>
> Considered that way, I worry that these constraints produce a recipe for
> paying extremely high feerates. If that's an actual risk, is that
> actually significantly better than dealing with the existing transaction
> pinning issue where one needs to pay a high total fee in order to evict
> a bunch of junk descendents? Paying lots of fees may not be the optimal
> solution to the problem of having to pay lots of fees. :-)
>
> -Dave
>
> [1] Excerpt from bitcoind -help-debug :
>
> -limitancestorcount=<n>
>
>        Do not accept transactions if number of in-mempool ancestors is <n> or
>
>        more (default: 25)
>
>
> -limitdescendantcount=<n>
>
>        Do not accept transactions if any ancestor would have <n> or more
>
>        in-mempool descendants (default: 25)
>
>
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From rsomsen at gmail.com  Wed Jun 12 21:26:01 2019
From: rsomsen at gmail.com (Ruben Somsen)
Date: Wed, 12 Jun 2019 23:26:01 +0200
Subject: [bitcoin-dev] Formalizing Blind Statechains as a minimalistic
 blind signing server
In-Reply-To: <L118b6Auac7OxL9DmyvXmFldcnSvb1xU807qtsPt6fGY0-fpg55U5VmEdAgC1T87r274UuqZ-iS0yDNBhZfvhsEW3ZHhdl1eb5Cg4I04ckE=@protonmail.com>
References: <CAPv7Tjb11yRix4ts76Rqz08yj=SOA1LBzq5E7gkxcrS26Sp=Ng@mail.gmail.com>
	<8XXMxGjO1b4bM90Khn3tl63lPEBVJ0at9iJa1gZrZbz7NMaA7ANITVbHOJkctvJlxDUwR6H6dhG34Ko8phlu4_h_GcSXvyuYzPyW4ukEdMY=@protonmail.com>
	<CAPv7TjYXwr7BLtMqh09QV6b_EZGjBBHw+pdq=3k90KV4j1hNJQ@mail.gmail.com>
	<L118b6Auac7OxL9DmyvXmFldcnSvb1xU807qtsPt6fGY0-fpg55U5VmEdAgC1T87r274UuqZ-iS0yDNBhZfvhsEW3ZHhdl1eb5Cg4I04ckE=@protonmail.com>
Message-ID: <CAPv7Tja9BCtzh=yjOX0nCK8E2K2JRpp7huCw_AwBXVM6J3+VfQ@mail.gmail.com>

Hi ZmnSCPxj,


Thanks for the reply. Sorry to keep you waiting, Coredev and Breaking
Bitcoin have been keeping me busy.

Transcript from Coredev (thanks Bryan):
http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-statechains/

Blind Statechains at Breaking Bitcoin:
https://www.youtube.com/watch?v=DqhxPWsJFZE&t=4h59m4s


>an early draft

I meant an early draft of Statechains, sorry if that was confusing.
But yes, it's essentially no different from channel factories without
eltoo.


>If `SIGHASH_ANYPREVOUT` ends up requiring a chaperone signature, it seems this transitory/common key can be used for the chaperone.

That is a good point. One thing I have not yet fully analysed are the
privacy considerations. Perhaps we don't want to reveal X on-chain.


>This would be nearer to my own Smart Contracts Unchained

Adding scripting is not my preferred approach. The beauty of the
system is that the server doesn't evaluate any scripts whatsoever.

That being said, Smart Contracts Unchained (SCU) can be inserted quite
elegantly as a separate smart contracting layer.

The observation is that anything that can be done with a UTXO
on-chain, can also be done off-chain via Statechains, including SCU.

If SCU is a single (N-of-N or (1-of-N + escrow)) key, you can simply
use this as the userKey (as well as inside the off-chain eltoo tx).

It's pretty interesting how smart contracting can be added like this.
Cool stuff, ZmnSCPxj. I'll definitely be thinking about this more.


Cheers,
Ruben

On Thu, Jun 6, 2019 at 8:32 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>
> Good morning Ruben,
>
>
> Sent with ProtonMail Secure Email.
>
> ??????? Original Message ???????
> On Thursday, June 6, 2019 1:20 PM, Ruben Somsen <rsomsen at gmail.com> wrote:
>
> > Hi ZmnSCPxj,
> >
> > Thank you for your comments.
> >
> > > Of note, is that a Decker-Russell-Osuntokun construction ("eltoo") is not strictly required. We can still make use of the Decker-Wattenhofer construction instead.
> >
> > Yes, an early draft (from before the eltoo paper) was using that
> > construction, but it seemed quite unwieldy. Timelocks have to be long,
> > nesting adds more transactions, channels expire faster with more use,
> > and tx fee handling is more complex. But you make a good point that if
> > SIGHASH_ANYPREVOUT turns out to be too controversial (or for
> > supporting older altcoins), this would be a potential fallback.
>
> The lack of `SIGHASH_ANYPREVOUT` does make it difficult to operate a channel factory.
> Factory operations would still require the signatures of all participants, but once a participant has released its signature, it cannot be sure whether its channels should be rooted on the previous factory state or the next (i.e. the [Stale Factory problem](https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-April/001974.html) ).
> This is fixable if we use `SIGHASH_ANYPREVOUT` on channel update transactions.
> Alternately without that flag we can run channels rooted on both the previous and next factory states, which actually is similar to what we need to do for splice-in (so we could reuse that code, possibly).
>
> >
> > > This still admits the possibility of an exit scam once a few "big enough" swaps are in position to be stolen, trading off earned reputation for cold-stored cash.
> >
> > That is correct. The worst case for security still comes down to
> > having to trust the federation, but the transitory key, as well as the
> > blind signature scheme, does add an interesting layer of separation
> > that makes it essentially "non-custodial". The article I linked has
> > more on this.
>
> Of note is that this is roughly the same as the common key in my own Smart Contracts Unchained.
>
> If `SIGHASH_ANYPREVOUT` ends up requiring a chaperone signature, it seems this transitory/common key can be used for the chaperone.
>
> Going further on Smart Contracts Unchained, I observe that the below:
>
> > // Start new signature chain
> > (1) requestNewKey(userPubkey) => returns a new serverPubkey and registers it to userPubkey
> > // Extend existing chain
> > (2) requestBlindSig(userSignature, blindedMessage, nextUserPubkey) => returns blindSignature, registers the serverPubkey to nextUserPubkey
>
> Can be generalized, such that instead of pubKeys and their signatures, we have validation programs and their witnesses.
>
> For example, instead of userPubkey and nextUserPubkey we have a userScript and nextUserScript, with userSignature replaced by a userWitness.
>
> This would be nearer to my own Smart Contracts Unchained, though without committing to the smart contract onchain, only offchain in the server.
>
>
>
> >
> > Cheers,
> > Ruben
> >
> > On Thu, Jun 6, 2019 at 2:09 AM ZmnSCPxj ZmnSCPxj at protonmail.com wrote:
> >
> > > Good morning Ruben,
> > >
> > > > At
> > > > Scaling Bitcoin ?18 [1] I briefly mentioned utilizing blind signatures
> > > > [2] to make the entity unaware of what it's signing. I now think this
> > > > is the more interesting approach. The functionality can be described
> > > > fairly elegantly as follows.
> > >
> > > I agree.
> > > I had no interest in Statechains at all before, but now that you have blind signing servers, this is significantly more interesting.
> > >
> > > > Blind signing server with two functions users can call:
> > > > // Start new signature chain
> > > > (1) requestNewKey(userPubkey) => returns a new serverPubkey and
> > > > registers it to userPubkey
> > > > // Extend existing chain
> > > > (2) requestBlindSig(userSignature, blindedMessage, nextUserPubkey) =>
> > > > returns blindSignature, registers the serverPubkey to nextUserPubkey
> > > > The resulting output is a public ECC chain (one blindSignature per
> > > > user, one chain per serverPubkey) of blindly signed messages,
> > > > requested by users (1, 2, 3, etc.):
> > > > userSignature1(blindedMessage1, userPubkey2) => blindSignature1
> > > > userSignature2(blindedMessage2, userPubkey3) => blindSignature2
> > > > etc.
> > > > Assuming the server is honest (more on this below), we can use it to
> > > > transfer over the signing rights of a private key without actually
> > > > changing the key itself.
> > > > The functionality is general and therefore suitable for more than just
> > > > Bitcoin, but let's walk through the primary envisioned use case where
> > > > we transfer the ownership of a Bitcoin UTXO off-chain. Note that the
> > > > server is kept completely unaware that it's handling a BTC
> > > > transaction, since it's signing blindly:
> > > >
> > > > -   B uses function (1) with userPubkey = B to request serverPubkey A
> > > >
> > > > -   B then generates transitory key X, and creates a single MuSig key AX
> > > >     (key X is called ?transitory? because its private key will later be passed on)
> > > >
> > > > -   B prepares tx1: 1BTC to AX (he doesn't send it yet)
> > > >
> > > > -   B creates tx2: an eltoo tx [3] that assigns the 1BTC back to B (off-chain)
> > > >
> > >
> > > Of note, is that a Decker-Russell-Osuntokun construction ("eltoo") is not strictly required.
> > > We can still make use of the Decker-Wattenhofer construction instead.
> > > The core of Decker-Wattenhofer is a sequence of decrementing-`nSequence` update systems.
> > > Number of maximum updates is limited by the starting `nSequence`, however if we put an update system inside an update system, we can "reset" the `nSequence` of the inner update system by updating the outer update system.
> > > We can chain this concept further and add more update systems nested inside update systems to gain more leverage from the maximum relative wait time.
> > > As we expect fewer updates are needed for statechains than e.g. actual Lightning channels (your given CoinSwap protocol is "only" two updates, for instance) this is usually a good tradeoff,
> > > It is thus possible to use statechains in case `SIGHASH_ANYPREVOUT` is too controversial to get into Bitcoin, provided Schnorr (definitely uncontroversial) does get into Bitcoin.
> > >
> > > >     A and B can collude to take the money from C, but since all instances
> > > >     of userSignature and blindSignature are published openly, cheating is
> > > >     publicly detectable (e.g. the server signed two messages from B
> > > >     instead of one).
> > > >
> > >
> > > This still admits the possibility of an exit scam once a few "big enough" swaps are in position to be stolen, trading off earned reputation for cold-stored cash.
> > >
> > > >     Trust can be distributed by turning the server into a multisig
> > > >     threshold key, so serverPubkey A becomes e.g. 8-of-12 multisig. This
> > > >     means security can be on par with federated sidechains [5], and is
> > > >     similar to how ZmnSCPxj replaced the escrow key with a federation in
> > > >     ?Smart Contracts Unchained? [6].
> > > >
> > >
> > > This makes me happy.
> > > Regards,
> > > ZmnSCPxj
>
>

From ZmnSCPxj at protonmail.com  Thu Jun 13 01:22:38 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 13 Jun 2019 01:22:38 +0000
Subject: [bitcoin-dev] Formalizing Blind Statechains as a minimalistic
	blind signing server
In-Reply-To: <CAPv7Tja9BCtzh=yjOX0nCK8E2K2JRpp7huCw_AwBXVM6J3+VfQ@mail.gmail.com>
References: <CAPv7Tjb11yRix4ts76Rqz08yj=SOA1LBzq5E7gkxcrS26Sp=Ng@mail.gmail.com>
	<8XXMxGjO1b4bM90Khn3tl63lPEBVJ0at9iJa1gZrZbz7NMaA7ANITVbHOJkctvJlxDUwR6H6dhG34Ko8phlu4_h_GcSXvyuYzPyW4ukEdMY=@protonmail.com>
	<CAPv7TjYXwr7BLtMqh09QV6b_EZGjBBHw+pdq=3k90KV4j1hNJQ@mail.gmail.com>
	<L118b6Auac7OxL9DmyvXmFldcnSvb1xU807qtsPt6fGY0-fpg55U5VmEdAgC1T87r274UuqZ-iS0yDNBhZfvhsEW3ZHhdl1eb5Cg4I04ckE=@protonmail.com>
	<CAPv7Tja9BCtzh=yjOX0nCK8E2K2JRpp7huCw_AwBXVM6J3+VfQ@mail.gmail.com>
Message-ID: <xc6X8fAM-1Aow8xjcyCFL7Z5r0s7Vmr_FFo1Mjoz5Hh12I0_6VAU-mlX9nj0aNZjJZ3qq5ehICalNeOqgEh1ziaZiF-Zvz7s42HGK-LXoM0=@protonmail.com>

Good morning Ruben,
> > an early draft
>
> I meant an early draft of Statechains, sorry if that was confusing.
> But yes, it's essentially no different from channel factories without
> eltoo.

Sorry, I am referring to current issues with channel factories, which were not addressed in the original channel factories paper.
Basically, the "Stale Factory" and "Broken Factory" problems.
Broken factory seems unsolvable.
Stale factory is fixable if the channels within the factory use `SIGHASH_NOINPUT` (assuming it gets into Bitcoin) for all unilateral paths (use `SIGHASH_ALL` for cooperative paths).

>
> > If `SIGHASH_ANYPREVOUT` ends up requiring a chaperone signature, it seems this transitory/common key can be used for the chaperone.
>
> That is a good point. One thing I have not yet fully analysed are the
> privacy considerations. Perhaps we don't want to reveal X on-chain.

On reflection, probably best not to.
It requires a script that reveals the pubkeys.
And it now becomes possible for the server to monitor the blockchain for revelation of server pubkey in a spend path.
This will let the server know, after-the-fact, that it was signing blockchain transactions.
This might not let it preemptively censor or otherwise disrupt, but it *could* sell the private fact that a statechain was used.
Combining it via MuSig is probably best, as the server is now unable to recognize even the pubkey (assuming it never is informed `X`).

>
> > This would be nearer to my own Smart Contracts Unchained
>
> Adding scripting is not my preferred approach. The beauty of the
> system is that the server doesn't evaluate any scripts whatsoever.

On reflection, this is probably best.
As the server is blinded, it cannot determine anything about the message being signed.

On the other cognition sub-agent, however, a simple scripting that allows "if somebody provides x of H(x) plus signature A, sign a blinded message M1, else if after 2:30PM PST on Jun 24 2019 if somebody provides signature of B, sign a blinded message M2" could still potentially be useful, and might allow "programmable escrow" like I imagine Smart Contracts Unchained could allow.

>
> That being said, Smart Contracts Unchained (SCU) can be inserted quite
> elegantly as a separate smart contracting layer.
>
> The observation is that anything that can be done with a UTXO
> on-chain, can also be done off-chain via Statechains, including SCU.

The Real (TM) observation is that anything that can be done with a UTXO onchain, can also be done offchain via any updateable offchain cryptocurrency system, whether Statechains, Spillman, Decker-Wattenhofer, Poon-Dryja, or Decker-Russell-Osuntokun.
(I should probably look up the authors of the Statechains paper to make my naming convention consistent)

One might observe that any updateable offchain cryptocurrency system worth its salt would have some way of unilaterally dropping transactions onchain.
Those transactions would create new UTXOs that can be spent by further transactions.
By presenting those "further transactions" to the offchain system, we can provide an argument that the offchain system can just "append" those "further transactions" to the existing unilateral-case transactions, then cut-through the further transactions on its next update (i.e. delete the current UTXOs spent and insert the new UTXOs introduced by the "further transactions").
(In the case of Statechains, you would present this argument to the signers of the latest `userPubKey`, not to the server, who is unaware of the semantics of what it is signing)


Regards,
ZmnSCPxj

From tamas.blummer at gmail.com  Thu Jun 13 08:14:02 2019
From: tamas.blummer at gmail.com (Tamas Blummer)
Date: Thu, 13 Jun 2019 10:14:02 +0200
Subject: [bitcoin-dev] An alternative: OP_CAT & OP_CHECKSIGFROMSTACK
In-Reply-To: <CAMZUoK=0YhqxguphmaKsMGZCy_NYVE_i53qGBfPVES=GAYTy1g@mail.gmail.com>
References: <CAMZUoK=0YhqxguphmaKsMGZCy_NYVE_i53qGBfPVES=GAYTy1g@mail.gmail.com>
Message-ID: <FADC3B05-60D2-4E41-AA59-6A0C1519C5B1@gmail.com>

ZmnSCPxj already observed in [1] that these ops would enable introspection of any field of the transactions and make both `OP_CHECKLOCKTIMEVERIFY` and `OP_CHECKSEQUENCEVERIFY` superfluous.
There is much more to this as enumerated in generic terms by Russel O?Connor below and I would like to add a concrete example.

We could implement oracle less difficulty contracts without the need the of a CISC type OP_WORKVERIFY but instead through resurrection/extension of OP_CAT, OP_GREATERTHANOREQUAL and introduction of a new RISC opcode OP_CHECKBLOCKATHEIGHT[3] suggested by Luke Dashjr. Thanks for the pointer to Nathan Cook [4]

Technically we could resurrect and add them without burning more than one OP_NOP by redefining it as a prefix (OP_EXTENSION), such as:

OP_EXTENSION OP_CAT would become a two byte opcode pointing to a resurrected implementation of OP_CAT.

This could be soft forked in.

A concrete oracle less difficulty contract could look like:
It is an european digital call option on target difficulty after maturity and 10 blocks notice period. I gave you reasons while having these would increase bitcoin's security in [2]

IF
	<maturity as block height + 10> CHECKLOCKTIMEVERIFY DROP
      <speculator?s key> CHECKSIGVERIFY
ELSE
	OP_DUP  <maturity as block height - 1> OP_CHECKBLOCKATHEIGHT OP_LESSTHANEQUAL OP_VERIFY
	OP_SWAP OP_CAT  OP_CAT  OP_HASH256 <contracted target> OP_LESSTHANEQUAL OP_VERIFY
	<miner?s key> CHECKSIGVERIFY
ENDIF

insurance premium could be collected by the seller of the insurance after maturity + 10 blocks if target difficulty was not reached

<speculator?s signature>

miner would get back its insurance premium plus collateral of the seller if target difficulty was not reached at maturity. Miner has 10 blocks time after maturity to claim with:

<maturity block header after prevhash> <maturity block version> <prevhash>

The stack would be in second case processed as:

1: after pushes
<maturity block prevhash>
<maturity block version>
<maturity block block header after prevhash>

2: after OP_DUP:
<maturity block prevhash>
<maturity block prevhash>
<maturity block version>
<maturity block block header after prevhash>

3: after push
<maturity as block height - 1>
<maturity block prevhash>
<maturity block prevhash>
<maturity block version>
<maturity block block header after prevhash>

4: after OP_CHECKBLOCKATHEIGHT OP_VERIFY is successful proving that prevhash is the block at maturity block height - 1
<maturity block prevhash>
<maturity block version>
<maturity block block header after prevhash>

5: after OP_SWAP
<block version>
<maturity block prevhash>
<block header after prevhash>

6: after OP_CAT
<maturity block version concatenated with maturity prevhash>
<maturity block block header after maturity prevhash>

7: after OP_CAT
<complete block header>

8: after OP_HASH256
<block hash computed for header>

9: after push
<contracted target>
<block hash computed for header>

10: after OP_GREATERTHANOREQUAL OP_VERIFY proves that contracted target was reached

Tamas Blummer


[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016966.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016966.html>
[2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017019.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017019.html>
[3] https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki <https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki>
[4] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016954.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016954.html>
[5] https://github.com/bitcoin/bitcoin/blob/master/src/script/script.h <https://github.com/bitcoin/bitcoin/blob/master/src/script/script.h>
> On May 22, 2019, at 23:01, Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Recently there have been some tapscript proposals, SIGHASH_ANYPREVOUT and OP_CHECKOUTPUTHASHVERIFY, that aim to enable particular new features for Bitcoin via new Script operations.  However, I think that these proposals miss the mark when it comes to how they approach Bitcoin Script and language features.
> 
> Bitcoin Script appears designed to be a flexible programmable system that provides generic features to be composed to achieve various purposes.  Thus, when we design new language features for Script, we should be striving, as much as possible, to similarly build general purpose tools which can in turn be used for a variety of purposes.
> 
> I feel the SIGHASH_ANYPREVOUT and OP_CHECKOUTPUTHASHVERIFY proposals fail to achieve these design goals.  They are both are designed with very narrow applications in mind, while also going out of their way to extend the semantic domain of the interpretation of Bitcoin operations in new ways that complicate their specification.  In the case of SIGHASH_ANYPREVOUT, the semantic domain is extended by adding new counters to track the use of various v0 and v2 signature types.  In the case of OP_CHECKOUTPUTHASHVERIFY, it employs a new context-sensitive operation that peeks at the value of surrounding opcodes.
> 
> Instead, I propose that, for the time being, we simply implement OP_CAT and OP_CHECKSIGFROMSTACKVERIFY.  OP_CAT pops two byte arrays off the stack and pushes their concatenation back onto the stack.  OP_CHECKSIGFROMSTACKVERIFY pops a signature, message, and pubkey off the stack and performs a bip-schnorr verification on the SHA256 hash of the message.
> 
> In concert, these two operations enable:
> 
> * Oracle signature verification, including discrete log contracts.
> * Amortized secure multiparty computations (see "Amortizing Secure Computation with Penalties" by Kumaresan and Bentov).
> * Transaction introspection including:
> + <> Simulated SIGHASH_ANYPREVOUT, which are necessarily chaperoned simply by the nature of the construction.
> + <> Decide if a transaction has exactly one input or not. (etc.)
> + Weak covenants, which can verify output scripts to see if they are among a set of predefined values or verify the output hash.
> 
> and presumably more applications as well.
> 
> For better or for worse, without an OP_PUBKEYTWEEK operation available, the more interesting recursive-covenants remain largely out of reach, with the exception of a recursive covenant that is only able to send back to its own address, possibly abusing its own TXO value as a state variable.
> 
> All this is accomplished by two straightforward opcodes whose semantics are pure computational operations on stack values.  The only semantic side-effect is that OP_CHECKSIGFROMSTACKVERIFY would count towards the existing 'sigops_passed' count.  Moreover, I feel that adding these operations does not preclude adding more specialized opcodes in the future as an optimization for whatever popular constructions come up, once we know what those are.
> 
> I feel that this style of generic building blocks truly embodies what is meant by "programmable money".
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190613/4583e8b3/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190613/4583e8b3/attachment-0001.sig>

From rusty at rustcorp.com.au  Fri Jun 14 05:50:17 2019
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Fri, 14 Jun 2019 15:20:17 +0930
Subject: [bitcoin-dev] [PROPOSAL] Emergency RBF (BIP 125)
In-Reply-To: <20190609140334.upcqalp24zrecwye@ganymede>
References: <871s0c1tvg.fsf@rustcorp.com.au>
	<F252D824-5BE6-4B03-B59D-D40EAFBAEE84@mattcorallo.com>
	<871s07nvi1.fsf@rustcorp.com.au>
	<20190609140334.upcqalp24zrecwye@ganymede>
Message-ID: <874l4spvfq.fsf@rustcorp.com.au>

"David A. Harding" <dave at dtrt.org> writes:
> On Thu, Jun 06, 2019 at 02:46:54PM +0930, Rusty Russell via bitcoin-dev wrote:
>> If that's true, I don't think this proposal makes it worse.
>
> Here's a scenario that I think shows it being at least 20x worse.

[ Snip ]

Indeed :(

To be fair, if I have a transaction of median size (250 bytes) and I use
the current estimatefee 2 of '0.00068325' I get to replace is 68 times;
that's $0 for an additional 1GB across all nodes.

So, I don't think the current rules are sufficient.  But I understand
the desire not to make things worse.  I'll roll in some changes and
re-propose.

> It's already hard for wallet software to determine whether or not its
> transactions have successfully been relayed.

As the deadline approaches, a lightning wallet would RBF with increasing
desparation until it gets into a block.  It doesn't really matter *why*
the tx isn't going through, there's nothing else it can do.

> This proposal requires LN
> wallets not only be able to guess where the next-block feerate boundary
> is in other nodes' individual mempools (now and in the future for the
> time it takes the transaction to propagate to ~100% of miners), but it
> possibly requires that under the condition that the LN wallet can't
> guess too low because it might not get another chance for relay in the
> limited time available before contract expiration.

I think you mean any proposal which relies on a deadline?  If so, that
bus has already left.

When you see a block you can guess the fees required for the next block.
You need some smoothing to avoid wild spikes, but in practice you can
start this "desperation mode" 10 blocks before your deadline.

Without RBF changes, it needs to assume that it needs to replace a
400kSipa tx @ feerate-for-next-block.  With some RBF change, it need
only replace @feerate-for-next-block.

> Considered that way, I worry that these constraints produce a recipe for
> paying extremely high feerates.  If that's an actual risk, is that
> actually significantly better than dealing with the existing transaction
> pinning issue where one needs to pay a high total fee in order to evict
> a bunch of junk descendents?  Paying lots of fees may not be the optimal
> solution to the problem of having to pay lots of fees.  :-)

I don't understand this at all, sorry.

Cheers,
Rusty.

From rsomsen at gmail.com  Fri Jun 14 07:18:27 2019
From: rsomsen at gmail.com (Ruben Somsen)
Date: Fri, 14 Jun 2019 09:18:27 +0200
Subject: [bitcoin-dev] Formalizing Blind Statechains as a minimalistic
 blind signing server
In-Reply-To: <xc6X8fAM-1Aow8xjcyCFL7Z5r0s7Vmr_FFo1Mjoz5Hh12I0_6VAU-mlX9nj0aNZjJZ3qq5ehICalNeOqgEh1ziaZiF-Zvz7s42HGK-LXoM0=@protonmail.com>
References: <CAPv7Tjb11yRix4ts76Rqz08yj=SOA1LBzq5E7gkxcrS26Sp=Ng@mail.gmail.com>
	<8XXMxGjO1b4bM90Khn3tl63lPEBVJ0at9iJa1gZrZbz7NMaA7ANITVbHOJkctvJlxDUwR6H6dhG34Ko8phlu4_h_GcSXvyuYzPyW4ukEdMY=@protonmail.com>
	<CAPv7TjYXwr7BLtMqh09QV6b_EZGjBBHw+pdq=3k90KV4j1hNJQ@mail.gmail.com>
	<L118b6Auac7OxL9DmyvXmFldcnSvb1xU807qtsPt6fGY0-fpg55U5VmEdAgC1T87r274UuqZ-iS0yDNBhZfvhsEW3ZHhdl1eb5Cg4I04ckE=@protonmail.com>
	<CAPv7Tja9BCtzh=yjOX0nCK8E2K2JRpp7huCw_AwBXVM6J3+VfQ@mail.gmail.com>
	<xc6X8fAM-1Aow8xjcyCFL7Z5r0s7Vmr_FFo1Mjoz5Hh12I0_6VAU-mlX9nj0aNZjJZ3qq5ehICalNeOqgEh1ziaZiF-Zvz7s42HGK-LXoM0=@protonmail.com>
Message-ID: <CAPv7TjZhXBfUB7MBY=gnxoUr8r0fV_usOfiuEeVnDYSPL5xTGw@mail.gmail.com>

Hi ZmnSCPxj,


>Basically, the "Stale Factory" and "Broken Factory" problems.

I see, I'll have to read up on those.


>Combining it via MuSig is probably best, as the server is now unable to recognize even the pubkey (assuming it never is informed `X`).

Yes, that's the current thinking. See also:
https://twitter.com/SomsenRuben/status/1138199578996555784 (sorry no
time to make a gist)


>As the server is blinded, it cannot determine anything about the message being signed.

Yes, you could build a non-blind variant with scripting, but that
would be quite different.


>a simple scripting that allows "if somebody provides x of H(x) plus signature A, sign a blinded message M1, else if after 2:30PM PST on Jun 24 2019 if somebody provides signature of B, sign a blinded message M2" could still potentially be useful

I believe adaptor signatures are enough to replace hashing. A time
lock could potentially be added with some very basic scripting, but my
feeling is still that this is better avoided. We're essentially
relying on the Bitcoin blockchain for that, because the off-chain
transactions can be encumbered by any script you like.


>anything that can be done with a UTXO onchain, can also be done offchain via any updateable offchain cryptocurrency system

You're right that I didn't properly point to the key difference, which
is transfer of UTXO ownership. Other off-chain systems don't allow you
to go from e.g. 2-of-2 to 3-of-3, but of course we're adding a
federation in order to make this happen, so it's not exactly a fair
comparison.


>(I should probably look up the authors of the Statechains paper to make my naming convention consistent)

That would be "Somsen". I am the sole author.


>By presenting those "further transactions" to the offchain system, we can provide an argument that the offchain system can just "append" those "further transactions" to the existing unilateral-case transactions, then cut-through the further transactions on its next update

That's an interesting way of looking at it. This is currently achieved
in Statechains by making the top-level on the Statechain N-of-N, so
all participants of the "further transactions" have to agree in order
to achieve full cut-through on the Statechain. In practice this would
mean that the final signature requested from the server is a
"cooperative close".


Cheers,
Ruben


On Thu, Jun 13, 2019 at 3:22 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>
> Good morning Ruben,
> > > an early draft
> >
> > I meant an early draft of Statechains, sorry if that was confusing.
> > But yes, it's essentially no different from channel factories without
> > eltoo.
>
> Sorry, I am referring to current issues with channel factories, which were not addressed in the original channel factories paper.
> Basically, the "Stale Factory" and "Broken Factory" problems.
> Broken factory seems unsolvable.
> Stale factory is fixable if the channels within the factory use `SIGHASH_NOINPUT` (assuming it gets into Bitcoin) for all unilateral paths (use `SIGHASH_ALL` for cooperative paths).
>
> >
> > > If `SIGHASH_ANYPREVOUT` ends up requiring a chaperone signature, it seems this transitory/common key can be used for the chaperone.
> >
> > That is a good point. One thing I have not yet fully analysed are the
> > privacy considerations. Perhaps we don't want to reveal X on-chain.
>
> On reflection, probably best not to.
> It requires a script that reveals the pubkeys.
> And it now becomes possible for the server to monitor the blockchain for revelation of server pubkey in a spend path.
> This will let the server know, after-the-fact, that it was signing blockchain transactions.
> This might not let it preemptively censor or otherwise disrupt, but it *could* sell the private fact that a statechain was used.
> Combining it via MuSig is probably best, as the server is now unable to recognize even the pubkey (assuming it never is informed `X`).
>
> >
> > > This would be nearer to my own Smart Contracts Unchained
> >
> > Adding scripting is not my preferred approach. The beauty of the
> > system is that the server doesn't evaluate any scripts whatsoever.
>
> On reflection, this is probably best.
> As the server is blinded, it cannot determine anything about the message being signed.
>
> On the other cognition sub-agent, however, a simple scripting that allows "if somebody provides x of H(x) plus signature A, sign a blinded message M1, else if after 2:30PM PST on Jun 24 2019 if somebody provides signature of B, sign a blinded message M2" could still potentially be useful, and might allow "programmable escrow" like I imagine Smart Contracts Unchained could allow.
>
> >
> > That being said, Smart Contracts Unchained (SCU) can be inserted quite
> > elegantly as a separate smart contracting layer.
> >
> > The observation is that anything that can be done with a UTXO
> > on-chain, can also be done off-chain via Statechains, including SCU.
>
> The Real (TM) observation is that anything that can be done with a UTXO onchain, can also be done offchain via any updateable offchain cryptocurrency system, whether Statechains, Spillman, Decker-Wattenhofer, Poon-Dryja, or Decker-Russell-Osuntokun.
> (I should probably look up the authors of the Statechains paper to make my naming convention consistent)
>
> One might observe that any updateable offchain cryptocurrency system worth its salt would have some way of unilaterally dropping transactions onchain.
> Those transactions would create new UTXOs that can be spent by further transactions.
> By presenting those "further transactions" to the offchain system, we can provide an argument that the offchain system can just "append" those "further transactions" to the existing unilateral-case transactions, then cut-through the further transactions on its next update (i.e. delete the current UTXOs spent and insert the new UTXOs introduced by the "further transactions").
> (In the case of Statechains, you would present this argument to the signers of the latest `userPubKey`, not to the server, who is unaware of the semantics of what it is signing)
>
>
> Regards,
> ZmnSCPxj

From elichai.turkel at gmail.com  Mon Jun 17 02:06:21 2019
From: elichai.turkel at gmail.com (Elichai Turkel)
Date: Sun, 16 Jun 2019 22:06:21 -0400
Subject: [bitcoin-dev] New BIP - v2 peer-to-peer message transport
	protocol
Message-ID: <CALN7hCKheiE374S6wOMJSTufmuQFxa-d_0x_aJbEPT=KuDc0nw@mail.gmail.com>

Hi everyone,
About the nonce being 64bit. (rfc7539 changed it to 96bit, which djb later
calls xchacha)

You suggest that we use the "message sequence number" as the nonce for
Chacha20, Is this number randomly generate or is this a counter?
And could it be reseted without rekeying?

If it is randomly generated then 64bit isn't secure enough. And we should
either move to the chacha20 from RFC7539 which has 96bit nonce and 32bit
counter or increment it manually every time.

If it's simply a counter then 64bit nonce should be fine :)

Thanks,
Elichai.

-- 
PGP: 5607C93B5F86650C
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190616/84c36142/attachment.html>

From pete at petertodd.org  Sun Jun 16 20:25:06 2019
From: pete at petertodd.org (Peter Todd)
Date: Sun, 16 Jun 2019 16:25:06 -0400
Subject: [bitcoin-dev] testnet4
In-Reply-To: <cbe4190d-ee49-b6f0-de99-c526fabff6ab@emilengler.com>
References: <205859a9-635a-e958-a03f-8d9a35e0da1a@emilengler.com>
	<CABaSBawPvOoTwQYQ0ZQc20b3g9GMp_fdz7cogHW25o40iF2UeA@mail.gmail.com>
	<cbe4190d-ee49-b6f0-de99-c526fabff6ab@emilengler.com>
Message-ID: <20190616202506.kjdpul473lutqhfw@petertodd.org>

On Sat, Jun 08, 2019 at 05:01:50PM +0200, Emil Engler via bitcoin-dev wrote:
> I don't get why the testnet shouldn't be resetted just because there is a
> (probably better) alternative for it. The testnet is still a thing and is
> also used.

Remember that the size of testnet itself is an important test; I've argued in
that past that we should consider making testnet *larger* than mainnet. There's
good arguments against that too, but I personally think the current size is a
reasonable compromise.

Of course, I personally tend to do all my testing on either internal regtest
nodes, or directly on mainnet. But the fact that works for me is specific to
the exact type of development I do and may not be applicable to you.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190616/8496db8e/attachment.sig>

From me at emilengler.com  Mon Jun 17 11:41:08 2019
From: me at emilengler.com (Emil Engler)
Date: Mon, 17 Jun 2019 13:41:08 +0200
Subject: [bitcoin-dev] testnet4
In-Reply-To: <20190616202506.kjdpul473lutqhfw@petertodd.org>
References: <205859a9-635a-e958-a03f-8d9a35e0da1a@emilengler.com>
	<CABaSBawPvOoTwQYQ0ZQc20b3g9GMp_fdz7cogHW25o40iF2UeA@mail.gmail.com>
	<cbe4190d-ee49-b6f0-de99-c526fabff6ab@emilengler.com>
	<20190616202506.kjdpul473lutqhfw@petertodd.org>
Message-ID: <733e1cd5-6511-ebea-fad4-6a5377ef9b25@emilengler.com>

Indeed a large testnet blockchain has advantages too.
But because it is the testnet and the testnet coins have no value, the
blockchain could be 'spammed' after a reset for some days/weeks until it
has a certain size.
Could this be realistic solution ?

Am 16.06.19 um 22:25 schrieb Peter Todd:
> On Sat, Jun 08, 2019 at 05:01:50PM +0200, Emil Engler via bitcoin-dev wrote:
>> I don't get why the testnet shouldn't be resetted just because there is a
>> (probably better) alternative for it. The testnet is still a thing and is
>> also used.
> 
> Remember that the size of testnet itself is an important test; I've argued in
> that past that we should consider making testnet *larger* than mainnet. There's
> good arguments against that too, but I personally think the current size is a
> reasonable compromise.
> 
> Of course, I personally tend to do all my testing on either internal regtest
> nodes, or directly on mainnet. But the fact that works for me is specific to
> the exact type of development I do and may not be applicable to you.
> 

-- 
https://www.emilengler.com
-------------- next part --------------
A non-text attachment was scrubbed...
Name: pEpkey.asc
Type: application/pgp-keys
Size: 3147 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190617/80546911/attachment.bin>

From dev at jonasschnelli.ch  Mon Jun 17 16:20:32 2019
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Mon, 17 Jun 2019 18:20:32 +0200
Subject: [bitcoin-dev] New BIP - v2 peer-to-peer message transport
 protocol
In-Reply-To: <CALN7hCKheiE374S6wOMJSTufmuQFxa-d_0x_aJbEPT=KuDc0nw@mail.gmail.com>
References: <CALN7hCKheiE374S6wOMJSTufmuQFxa-d_0x_aJbEPT=KuDc0nw@mail.gmail.com>
Message-ID: <76890B69-2004-41C4-B4E7-0C5D070142C3@jonasschnelli.ch>

Hi Elichai

> About the nonce being 64bit. (rfc7539 changed it to 96bit, which djb later calls xchacha)
> 
> You suggest that we use the "message sequence number" as the nonce for Chacha20, Is this number randomly generate or is this a counter?
> And could it be reseted without rekeying?

The in BIP324 (v2 message transport protocol) proposed AEAD, ChaCha20Poly1305 at Bitcoin [1], uses a ?message sequence number?. There is no such thing as random nonce described in the BIP (hence the term ?sequence number?). The message sequence number starts with 0 and the max traffic before a rekey must occur is 1GB. A nonce/key reuse is conceptually impossible (of course implementations could screw up at this point).

Using XChaCha20 with the possibility of a random nonce could be done, but I don?t see a reason to use it in our case since the usage of a sequence number as nonce seems perfectly save.

[1] https://gist.github.com/jonasschnelli/c530ea8421b8d0e80c51486325587c52#chacha20-poly1305bitcoin-cipher-suite
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190617/06f5efa8/attachment-0001.sig>

From elichai.turkel at gmail.com  Mon Jun 17 17:13:05 2019
From: elichai.turkel at gmail.com (Elichai Turkel)
Date: Mon, 17 Jun 2019 13:13:05 -0400
Subject: [bitcoin-dev] New BIP - v2 peer-to-peer message transport
	protocol
In-Reply-To: <76890B69-2004-41C4-B4E7-0C5D070142C3@jonasschnelli.ch>
References: <CALN7hCKheiE374S6wOMJSTufmuQFxa-d_0x_aJbEPT=KuDc0nw@mail.gmail.com>
	<76890B69-2004-41C4-B4E7-0C5D070142C3@jonasschnelli.ch>
Message-ID: <CALN7hCLP3JOpNbRhuaeEGU_L7Xop6A2QM9-Bv_m2TD8smqUHgQ@mail.gmail.com>

Thanks,
I just couldn't find where is the message sequence number comes from.
So if it's max 1GB and it's an incremental counter that cannot be reseted
without a rekeying than it's perfectly fine :).

Thanks for the answer!

On Mon, Jun 17, 2019 at 12:20 PM Jonas Schnelli <dev at jonasschnelli.ch>
wrote:

> Hi Elichai
>
> > About the nonce being 64bit. (rfc7539 changed it to 96bit, which djb
> later calls xchacha)
> >
> > You suggest that we use the "message sequence number" as the nonce for
> Chacha20, Is this number randomly generate or is this a counter?
> > And could it be reseted without rekeying?
>
> The in BIP324 (v2 message transport protocol) proposed AEAD,
> ChaCha20Poly1305 at Bitcoin [1], uses a ?message sequence number?. There is
> no such thing as random nonce described in the BIP (hence the term
> ?sequence number?). The message sequence number starts with 0 and the max
> traffic before a rekey must occur is 1GB. A nonce/key reuse is conceptually
> impossible (of course implementations could screw up at this point).
>
> Using XChaCha20 with the possibility of a random nonce could be done, but
> I don?t see a reason to use it in our case since the usage of a sequence
> number as nonce seems perfectly save.
>
> [1]
> https://gist.github.com/jonasschnelli/c530ea8421b8d0e80c51486325587c52#chacha20-poly1305bitcoin-cipher-suite
>


-- 
PGP: 5607C93B5F86650C
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190617/d7cf1656/attachment-0001.html>

From roconnor at blockstream.io  Tue Jun 18 20:57:34 2019
From: roconnor at blockstream.io (Russell O'Connor)
Date: Tue, 18 Jun 2019 16:57:34 -0400
Subject: [bitcoin-dev] OP_SECURETHEBAG (supersedes OP_CHECKOUTPUTSVERIFY)
In-Reply-To: <im0q8670MxshmvMLmoJU0dv4rFhwWZNvQeQYv7i4fBWJOx0ghAdH8fYuQSqNxO2z8uxXGV-kurinUDfl0FsLWD0knw_U_h3zVZ0xy7vmn8o=@protonmail.com>
References: <CAD5xwhjSj82YYuQHHbwgSLvUNV2RDY0b=yMYeLj-p6j7PpS9-Q@mail.gmail.com>
	<20190605093039.xfo7lcylqkhsfncv@erisian.com.au>
	<im0q8670MxshmvMLmoJU0dv4rFhwWZNvQeQYv7i4fBWJOx0ghAdH8fYuQSqNxO2z8uxXGV-kurinUDfl0FsLWD0knw_U_h3zVZ0xy7vmn8o=@protonmail.com>
Message-ID: <CAMZUoK=ZB06jwAbuX2D=aN8ztAqr_jSgEXS1z1ABjQYVawKCBQ@mail.gmail.com>

Just to be clear, while OP_CHECKTXDIGESTVERIFY would enable this style of
covenants if it pulled data from the stack, the OP_SECURETHEBAG probably
cannot create covenants even if it were to pull the data from the stack
unless some OP_TWEEKPUBKEY operation is added to Script because the
"commitment of the script itself" isn't part of the OP_SECURETHEBAG.

So with regards to OP_SECURETHEBAG, I am also "not really seeing any reason
to complicate the spec to ensure the digest is precommitted as part of the
opcode."

On Thu, Jun 6, 2019 at 3:33 AM ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Good morning aj,
>
>
> Sent with ProtonMail Secure Email.
>
> ??????? Original Message ???????
> On Wednesday, June 5, 2019 5:30 PM, Anthony Towns via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > On Fri, May 31, 2019 at 10:35:45PM -0700, Jeremy via bitcoin-dev wrote:
> >
> > > OP_CHECKOUTPUTSHASHVERIFY is retracted in favor of OP_SECURETHEBAG*.
> >
> > I think you could generalise that slightly and make it fit in
> > with the existing opcode naming by calling it something like
> > "OP_CHECKTXDIGESTVERIFY" and pull a 33-byte value from the stack,
> > consisting of a sha256 hash and a sighash-byte, and adding a new sighash
> > value corresponding to the set of info you want to include in the hash,
> > which I think sounds a bit like "SIGHASH_EXACTLY_ONE_INPUT | SIGHASH_ALL"
> >
> > FWIW, I'm not really seeing any reason to complicate the spec to ensure
> > the digest is precommitted as part of the opcode.
> >
>
> I believe in combination with `OP_LEFT` and `OP_CAT` this allows
> Turing-complete smart contracts, in much the same way as
> `OP_CHECKSIGFROMSTACK`?
>
> Pass in the spent transaction (serialised for txid) and the spending
> transaction (serialised for sighash) as part of the witness of the spending
> transaction.
>
> Script verifies that the spending transaction witness value is indeed the
> spending transaction by `OP_SHA256 <SIGHASH_ALL> OP_SWAP OP_CAT
> OP_CHECKTXDIGESTVERIFY`.
> Script verifies the spent transaction witness value is indeed the spent
> transaction by hashing it, then splitting up the hash with `OP_LEFT` into
> bytes, and comparing the bytes to the bytes in the input of the spending
> transaction witness value (txid being the bytes in reversed order).
>
> Then the Script can extract a commitment of itself by extracting the
> output of the spent transaction.
> This lets the Script check that the spending transaction also pays to the
> same script.
>
> The Script can then access a state value, for example from an `OP_RETURN`
> output of the spent transaction, and enforce that a correct next-state is
> used in the spending transaction.
> If the state is too large to fit in a standard `OP_RETURN`, then the
> current state can be passed in as a witness and validated against a hash
> commitment in an `OP_RETURN` output.
>
> I believe this is the primary reason against not pulling data from the
> stack.
>
> Regards,
> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190618/783d5ba9/attachment.html>

From aj at erisian.com.au  Thu Jun 20 22:05:52 2019
From: aj at erisian.com.au (Anthony Towns)
Date: Fri, 21 Jun 2019 08:05:52 +1000
Subject: [bitcoin-dev] OP_SECURETHEBAG (supersedes OP_CHECKOUTPUTSVERIFY)
In-Reply-To: <CAMZUoK=ZB06jwAbuX2D=aN8ztAqr_jSgEXS1z1ABjQYVawKCBQ@mail.gmail.com>
References: <CAD5xwhjSj82YYuQHHbwgSLvUNV2RDY0b=yMYeLj-p6j7PpS9-Q@mail.gmail.com>
	<20190605093039.xfo7lcylqkhsfncv@erisian.com.au>
	<im0q8670MxshmvMLmoJU0dv4rFhwWZNvQeQYv7i4fBWJOx0ghAdH8fYuQSqNxO2z8uxXGV-kurinUDfl0FsLWD0knw_U_h3zVZ0xy7vmn8o=@protonmail.com>
	<CAMZUoK=ZB06jwAbuX2D=aN8ztAqr_jSgEXS1z1ABjQYVawKCBQ@mail.gmail.com>
Message-ID: <20190620220552.metrqaul3iporwma@erisian.com.au>

On Tue, Jun 18, 2019 at 04:57:34PM -0400, Russell O'Connor wrote:
> So with regards to OP_SECURETHEBAG, I am also "not really seeing any reason to
> complicate the spec to ensure the digest is precommitted as part of the
> opcode."

Also, I think you can simulate OP_SECURETHEBAG with an ANYPREVOUT
(NOINPUT) sighash (Johnson Lau's mentioned this before, but not sure if
it's been spelled out anywhere); ie instead of constructing

  X = Hash_BagHash( version, locktime, [outputs], [sequences], num_in )

and having the script be "<X> OP_SECURETHEBAG" you calculate an
ANYPREVOUT sighash for SIGHASH_ANYPREVOUTANYSCRIPT | SIGHASH_ALL:

  Y = Hash_TapSighash( 0, 0xc1, version, locktime, [outputs], 0,
                       amount, sequence)

and calculate a signature sig = Schnorr(P,m) for some pubkey P, and
make your script be "<sig> <P> CHECKSIG".

That loses the ability to commit to the number of inputs or restrict
the nsequence of other inputs, and requires a bigger script (sig and P
are ~96 bytes instead of X's 32 bytes), but is otherwise pretty much the
same as far as I can tell. Both scripts are automatically satisfied when
revealed (with the correct set of outputs), and don't need any additional
witness data.

If you wanted to construct "X" via script instead of hardcoding a value
because it got you generalised covenants or whatever; I think you could
get the same effect with CAT,LEFT, and RIGHT: you'd construct Y in much
the same way you construct X, but you'd then need to turn that into a
signature. You could do so by using pubkey P=G and nonce R=G, which
means you need to calculate s=1+hash(G,G,Y)*1 -- calculating the hash
part is easy, multiplying it by 1 is easy, and to add 1 you can probably
do something along the lines of:

    OP_DUP 4 OP_RIGHT 1 OP_ADD OP_SWAP 28 OP_LEFT OP_SWAP OP_CAT

(ie, take the last 4 bytes, increment it using 4-byte arithmetic,
then cat the first 28 bytes and the result. There's overflow issues,
but I think they can be worked around either by allowing you to choose
different locktimes, or by more complicated script)

Cheers,
aj


From lists at coryfields.com  Fri Jun 21 02:56:21 2019
From: lists at coryfields.com (Cory Fields)
Date: Thu, 20 Jun 2019 22:56:21 -0400
Subject: [bitcoin-dev] Transcripts from coredev.tech Amsterdam 2019
	meeting
In-Reply-To: <CABaSBazFqeS6-jtAbhK7eyzihz=qUv6eKDWdWV9Tp4HZjqSWsQ@mail.gmail.com>
References: <CABaSBazFqeS6-jtAbhK7eyzihz=qUv6eKDWdWV9Tp4HZjqSWsQ@mail.gmail.com>
Message-ID: <CAApLimi80RrqgHL0yO8c_UvM8k=qPqjOGdyrsupc9VnVm1dq-g@mail.gmail.com>

A belated thanks (as always) for the great notes, Bryan. This is so
valuable!

Cory


On Fri, Jun 7, 2019 at 11:07 AM Bryan Bishop via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi,
>
> The following are some notes from the coredev.tech Amsterdam 2019 meeting.
> Any mistakes are my probably my own.
>
> Here is a conversation about the code review process in Bitcoin Core:
>
> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-05-code-review/
>
> Here is a conversation with some of the maintainers about what problems
> they are seeing:
>
> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-06-maintainers/
>
> Wallet re-architecture discussion
>
> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-05-wallet-architecture/
>
> Great consensus cleanup
>
> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-06-great-consensus-cleanup/
>
> SIGHASH_NOINPUT, OP_CHECKSIGFROMSTACK, OP_CHECKOUTPUTSHASHVERIFY,
> OP_SECURETHEBAG
>
> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-06-noinput-etc/
>
> Taproot discussion
> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-06-taproot/
>
> Utreexo
> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-06-utreexo/
>
> assumeutxo
>
> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-assumeutxo/
>
> Hardware wallets and HWI
>
> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-hardware-wallets/
>
> bip151, p2p encryption and v2 message format
>
> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-p2p-encryption/
>
> Signet for bitcoin test networks
> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-signet/
>
> Statechains overview
>
> http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2019-06-07-statechains/
>
> Thanks,
> - Bryan
> https://heybryan.org/
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190620/611c57f3/attachment.html>

From jlrubin at mit.edu  Sun Jun 23 06:43:22 2019
From: jlrubin at mit.edu (Jeremy)
Date: Sat, 22 Jun 2019 23:43:22 -0700
Subject: [bitcoin-dev] OP_SECURETHEBAG (supersedes OP_CHECKOUTPUTSVERIFY)
In-Reply-To: <20190620220552.metrqaul3iporwma@erisian.com.au>
References: <CAD5xwhjSj82YYuQHHbwgSLvUNV2RDY0b=yMYeLj-p6j7PpS9-Q@mail.gmail.com>
	<20190605093039.xfo7lcylqkhsfncv@erisian.com.au>
	<im0q8670MxshmvMLmoJU0dv4rFhwWZNvQeQYv7i4fBWJOx0ghAdH8fYuQSqNxO2z8uxXGV-kurinUDfl0FsLWD0knw_U_h3zVZ0xy7vmn8o=@protonmail.com>
	<CAMZUoK=ZB06jwAbuX2D=aN8ztAqr_jSgEXS1z1ABjQYVawKCBQ@mail.gmail.com>
	<20190620220552.metrqaul3iporwma@erisian.com.au>
Message-ID: <CAD5xwhgEQKdTCSLQn4-X_atT5_aE-1hEKk0xd1wm1m0qotwYXQ@mail.gmail.com>

This is insufficient: sequences must be committed to because they affect
TXID. As with scriptsigs (witness data fine to ignore). NUM_IN too.

Any malleability makes this much less useful.
--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>


On Fri, Jun 21, 2019 at 10:31 AM Anthony Towns via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Tue, Jun 18, 2019 at 04:57:34PM -0400, Russell O'Connor wrote:
> > So with regards to OP_SECURETHEBAG, I am also "not really seeing any
> reason to
> > complicate the spec to ensure the digest is precommitted as part of the
> > opcode."
>
> Also, I think you can simulate OP_SECURETHEBAG with an ANYPREVOUT
> (NOINPUT) sighash (Johnson Lau's mentioned this before, but not sure if
> it's been spelled out anywhere); ie instead of constructing
>
>   X = Hash_BagHash( version, locktime, [outputs], [sequences], num_in )
>
> and having the script be "<X> OP_SECURETHEBAG" you calculate an
> ANYPREVOUT sighash for SIGHASH_ANYPREVOUTANYSCRIPT | SIGHASH_ALL:
>
>   Y = Hash_TapSighash( 0, 0xc1, version, locktime, [outputs], 0,
>                        amount, sequence)
>
> and calculate a signature sig = Schnorr(P,m) for some pubkey P, and
> make your script be "<sig> <P> CHECKSIG".
>
> That loses the ability to commit to the number of inputs or restrict
> the nsequence of other inputs, and requires a bigger script (sig and P
> are ~96 bytes instead of X's 32 bytes), but is otherwise pretty much the
> same as far as I can tell. Both scripts are automatically satisfied when
> revealed (with the correct set of outputs), and don't need any additional
> witness data.
>
> If you wanted to construct "X" via script instead of hardcoding a value
> because it got you generalised covenants or whatever; I think you could
> get the same effect with CAT,LEFT, and RIGHT: you'd construct Y in much
> the same way you construct X, but you'd then need to turn that into a
> signature. You could do so by using pubkey P=G and nonce R=G, which
> means you need to calculate s=1+hash(G,G,Y)*1 -- calculating the hash
> part is easy, multiplying it by 1 is easy, and to add 1 you can probably
> do something along the lines of:
>
>     OP_DUP 4 OP_RIGHT 1 OP_ADD OP_SWAP 28 OP_LEFT OP_SWAP OP_CAT
>
> (ie, take the last 4 bytes, increment it using 4-byte arithmetic,
> then cat the first 28 bytes and the result. There's overflow issues,
> but I think they can be worked around either by allowing you to choose
> different locktimes, or by more complicated script)
>
> Cheers,
> aj
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190622/df90c3c4/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Sun Jun 23 13:11:03 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sun, 23 Jun 2019 13:11:03 +0000
Subject: [bitcoin-dev] OP_SECURETHEBAG (supersedes OP_CHECKOUTPUTSVERIFY)
In-Reply-To: <CAD5xwhj8o8Vbrk2KADBOFGfkD3fW3eMZo5aHJytGAj_5LLhYCg@mail.gmail.com>
References: <CAD5xwhjSj82YYuQHHbwgSLvUNV2RDY0b=yMYeLj-p6j7PpS9-Q@mail.gmail.com>
	<20190605093039.xfo7lcylqkhsfncv@erisian.com.au>
	<im0q8670MxshmvMLmoJU0dv4rFhwWZNvQeQYv7i4fBWJOx0ghAdH8fYuQSqNxO2z8uxXGV-kurinUDfl0FsLWD0knw_U_h3zVZ0xy7vmn8o=@protonmail.com>
	<CAMZUoK=ZB06jwAbuX2D=aN8ztAqr_jSgEXS1z1ABjQYVawKCBQ@mail.gmail.com>
	<CAD5xwhj8o8Vbrk2KADBOFGfkD3fW3eMZo5aHJytGAj_5LLhYCg@mail.gmail.com>
Message-ID: <MsareTP5GB7XCB4dHvikjqCwQZTs1EqMve7dZEciKCtlFTkne3B6xeSjM-kFP113aYGYeTDS35lXTP7PV3fEvGvFYWL0fRJk3WsncndRY10=@protonmail.com>

Good morning Jeremy,

While `OP_SECURETHEBAG` commits to the desired output script of the spending TX, what is being referred to here is the ability to verify the output script being spent, i.e. the script that actually contains the `OP_SECURETHEBAG`.
By this, we are able to create a contract that ensures that it is paid again (covenants), which in combination with a little more introspection of TX data, allows us to verify the execution of steps of a Turing-complete program.

It is surprisingly easy to make a language inadvertently Turing-complete, which is basically the argument here,
That is, with just a little more power and some additional operations that would appear reasonable to add by themselves (`OP_CAT`, `OP_LEFT`, `OP_TWEAKPUBKEY`) on top of some form of requiring a particular output script, it is possible to validate the execution of Turing-complete programs on the Bitcoin blockchain.

Thus, with quining (a script which gets the text of its own code as part of the static data it has), `OP_TWEAKPUBKEY`, and a `OP_SECURETHEBAG` that gets its argument from the stack, it will be possible to make Turing-complete Bitcoin SCRIPT.

I would mildly suggest that we might very well want to consider creating a well-designed way of injecting Turing-completeness into Bitcoin SCRIPT (requiring it to be behind a Taproot, so that bugs in Turing-complete code at least have a chance to be bugfixed by agreement of the Taproot signing set) since we might eventually find ourselves introducing it inadvertently later in any case.

Regards,
ZmnSCPxj


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Sunday, June 23, 2019 6:41 AM, Jeremy Rubin <jeremy.l.rubin at gmail.com> wrote:

> Can you clarify this comment?
>
> We do in fact commit to the script and scriptsig itself (not the witness stack) in OP_SECURETHEBAG (unless I'm missing what you meant)?
>
> On Thu, Jun 20, 2019, 10:59 AM Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > Just to be clear, while OP_CHECKTXDIGESTVERIFY would enable this style of covenants if it pulled data from the stack, the OP_SECURETHEBAG probably cannot create covenants even if it were to pull the data from the stack unless some OP_TWEEKPUBKEY operation is added to Script because the "commitment of the script itself" isn't part of the OP_SECURETHEBAG.
> >
> > So with regards to OP_SECURETHEBAG, I am also "not really seeing any reason to complicate the spec to ensure the digest is precommitted as part of the opcode."
> >
> > On Thu, Jun 6, 2019 at 3:33 AM ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> > > Good morning aj,
> > >
> > > Sent with ProtonMail Secure Email.
> > >
> > > ??????? Original Message ???????
> > > On Wednesday, June 5, 2019 5:30 PM, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > >
> > > > On Fri, May 31, 2019 at 10:35:45PM -0700, Jeremy via bitcoin-dev wrote:
> > > >
> > > > > OP_CHECKOUTPUTSHASHVERIFY is retracted in favor of OP_SECURETHEBAG*.
> > > >
> > > > I think you could generalise that slightly and make it fit in
> > > > with the existing opcode naming by calling it something like
> > > > "OP_CHECKTXDIGESTVERIFY" and pull a 33-byte value from the stack,
> > > > consisting of a sha256 hash and a sighash-byte, and adding a new sighash
> > > > value corresponding to the set of info you want to include in the hash,
> > > > which I think sounds a bit like "SIGHASH_EXACTLY_ONE_INPUT | SIGHASH_ALL"
> > > >
> > > > FWIW, I'm not really seeing any reason to complicate the spec to ensure
> > > > the digest is precommitted as part of the opcode.
> > > >
> > >
> > > I believe in combination with `OP_LEFT` and `OP_CAT` this allows Turing-complete smart contracts, in much the same way as `OP_CHECKSIGFROMSTACK`?
> > >
> > > Pass in the spent transaction (serialised for txid) and the spending transaction (serialised for sighash) as part of the witness of the spending transaction.
> > >
> > > Script verifies that the spending transaction witness value is indeed the spending transaction by `OP_SHA256 <SIGHASH_ALL> OP_SWAP OP_CAT OP_CHECKTXDIGESTVERIFY`.
> > > Script verifies the spent transaction witness value is indeed the spent transaction by hashing it, then splitting up the hash with `OP_LEFT` into bytes, and comparing the bytes to the bytes in the input of the spending transaction witness value (txid being the bytes in reversed order).
> > >
> > > Then the Script can extract a commitment of itself by extracting the output of the spent transaction.
> > > This lets the Script check that the spending transaction also pays to the same script.
> > >
> > > The Script can then access a state value, for example from an `OP_RETURN` output of the spent transaction, and enforce that a correct next-state is used in the spending transaction.
> > > If the state is too large to fit in a standard `OP_RETURN`, then the current state can be passed in as a witness and validated against a hash commitment in an `OP_RETURN` output.
> > >
> > > I believe this is the primary reason against not pulling data from the stack.
> > >
> > > Regards,
> > > ZmnSCPxj
> > > _______________________________________________
> > > bitcoin-dev mailing list
> > > bitcoin-dev at lists.linuxfoundation.org
> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From luke at dashjr.org  Sat Jun 22 23:42:52 2019
From: luke at dashjr.org (Luke Dashjr)
Date: Sat, 22 Jun 2019 23:42:52 +0000
Subject: [bitcoin-dev] PSA: Upcoming disclosure of pre-v0.17.1
	vulnerabilities
Message-ID: <201906222342.56016.luke@dashjr.org>

Two relatively minor vulnerabilities will likely be disclosed sometime soon.

The first vulnerability, CVE-2017-18350, was introduced in v0.7.0 (released in 
2012 September), and affects all versions released until the fix was included 
in v0.15.1 (released in 2017 November). No versions prior to v0.15.1 are 
expected to be fixed.

The second vulnerability, CVE-2018-20586, was introduced in v0.12.0 (released 
in 2016 February), and affects all versions released until the fix was 
included in v0.17.1 (released in 2018 December). As of today, this fix has 
NOT been backported to older versions. When/if v0.15.3 and v0.16.4 are 
released, they may also include a fix, but due to the minor severity of this 
vulnerability, it does not merit a dedicated release on its own. (The git 
branches are also NOT fixed at this time.)

Please be sure you have upgraded to a fixed version no later than August 1st.

From roconnor at blockstream.io  Mon Jun 24 14:34:54 2019
From: roconnor at blockstream.io (Russell O'Connor)
Date: Mon, 24 Jun 2019 10:34:54 -0400
Subject: [bitcoin-dev] OP_SECURETHEBAG (supersedes OP_CHECKOUTPUTSVERIFY)
In-Reply-To: <CAD5xwhj8o8Vbrk2KADBOFGfkD3fW3eMZo5aHJytGAj_5LLhYCg@mail.gmail.com>
References: <CAD5xwhjSj82YYuQHHbwgSLvUNV2RDY0b=yMYeLj-p6j7PpS9-Q@mail.gmail.com>
	<20190605093039.xfo7lcylqkhsfncv@erisian.com.au>
	<im0q8670MxshmvMLmoJU0dv4rFhwWZNvQeQYv7i4fBWJOx0ghAdH8fYuQSqNxO2z8uxXGV-kurinUDfl0FsLWD0knw_U_h3zVZ0xy7vmn8o=@protonmail.com>
	<CAMZUoK=ZB06jwAbuX2D=aN8ztAqr_jSgEXS1z1ABjQYVawKCBQ@mail.gmail.com>
	<CAD5xwhj8o8Vbrk2KADBOFGfkD3fW3eMZo5aHJytGAj_5LLhYCg@mail.gmail.com>
Message-ID: <CAMZUoKkPUn01V7WruMqoYtwJ__ai-QPvD81ceoYC7j4+hC99gg@mail.gmail.com>

OP_SECURETHEBAG doesn't include the script being executed (i.e the
scriptPubKey specified in the output that is redeemed by this input) in its
hash like ordinary signatures do
<https://github.com/bitcoin/bitcoin/blob/master/src/script/interpreter.cpp#L1271>.
Of course, this ScriptPubKey is indirectly committed to through the input's
prevoutpoint.  However Script isn't able to reconstruct this script being
executed from the prevoutpoint in tapscript without an implementation of
public key tweeking in Bitcoin Script.

On Sun, Jun 23, 2019 at 2:41 AM Jeremy Rubin <jeremy.l.rubin at gmail.com>
wrote:

> Can you clarify this comment?
>
> We do in fact commit to the script and scriptsig itself (not the witness
> stack) in OP_SECURETHEBAG (unless I'm missing what you meant)?
>
> On Thu, Jun 20, 2019, 10:59 AM Russell O'Connor via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Just to be clear, while OP_CHECKTXDIGESTVERIFY would enable this style
>> of covenants if it pulled data from the stack, the OP_SECURETHEBAG
>> probably cannot create covenants even if it were to pull the data from the
>> stack unless some OP_TWEEKPUBKEY operation is added to Script because the
>> "commitment of the script itself" isn't part of the OP_SECURETHEBAG.
>>
>> So with regards to OP_SECURETHEBAG, I am also "not really seeing any
>> reason to complicate the spec to ensure the digest is precommitted as part
>> of the opcode."
>>
>> On Thu, Jun 6, 2019 at 3:33 AM ZmnSCPxj via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> Good morning aj,
>>>
>>>
>>> Sent with ProtonMail Secure Email.
>>>
>>> ??????? Original Message ???????
>>> On Wednesday, June 5, 2019 5:30 PM, Anthony Towns via bitcoin-dev <
>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>> > On Fri, May 31, 2019 at 10:35:45PM -0700, Jeremy via bitcoin-dev wrote:
>>> >
>>> > > OP_CHECKOUTPUTSHASHVERIFY is retracted in favor of OP_SECURETHEBAG*.
>>> >
>>> > I think you could generalise that slightly and make it fit in
>>> > with the existing opcode naming by calling it something like
>>> > "OP_CHECKTXDIGESTVERIFY" and pull a 33-byte value from the stack,
>>> > consisting of a sha256 hash and a sighash-byte, and adding a new
>>> sighash
>>> > value corresponding to the set of info you want to include in the hash,
>>> > which I think sounds a bit like "SIGHASH_EXACTLY_ONE_INPUT |
>>> SIGHASH_ALL"
>>> >
>>> > FWIW, I'm not really seeing any reason to complicate the spec to ensure
>>> > the digest is precommitted as part of the opcode.
>>> >
>>>
>>> I believe in combination with `OP_LEFT` and `OP_CAT` this allows
>>> Turing-complete smart contracts, in much the same way as
>>> `OP_CHECKSIGFROMSTACK`?
>>>
>>> Pass in the spent transaction (serialised for txid) and the spending
>>> transaction (serialised for sighash) as part of the witness of the spending
>>> transaction.
>>>
>>> Script verifies that the spending transaction witness value is indeed
>>> the spending transaction by `OP_SHA256 <SIGHASH_ALL> OP_SWAP OP_CAT
>>> OP_CHECKTXDIGESTVERIFY`.
>>> Script verifies the spent transaction witness value is indeed the spent
>>> transaction by hashing it, then splitting up the hash with `OP_LEFT` into
>>> bytes, and comparing the bytes to the bytes in the input of the spending
>>> transaction witness value (txid being the bytes in reversed order).
>>>
>>> Then the Script can extract a commitment of itself by extracting the
>>> output of the spent transaction.
>>> This lets the Script check that the spending transaction also pays to
>>> the same script.
>>>
>>> The Script can then access a state value, for example from an
>>> `OP_RETURN` output of the spent transaction, and enforce that a correct
>>> next-state is used in the spending transaction.
>>> If the state is too large to fit in a standard `OP_RETURN`, then the
>>> current state can be passed in as a witness and validated against a hash
>>> commitment in an `OP_RETURN` output.
>>>
>>> I believe this is the primary reason against not pulling data from the
>>> stack.
>>>
>>> Regards,
>>> ZmnSCPxj
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190624/f738daa1/attachment-0001.html>

From jlrubin at mit.edu  Mon Jun 24 18:07:20 2019
From: jlrubin at mit.edu (Jeremy)
Date: Mon, 24 Jun 2019 11:07:20 -0700
Subject: [bitcoin-dev] OP_SECURETHEBAG (supersedes OP_CHECKOUTPUTSVERIFY)
In-Reply-To: <CAMZUoKkPUn01V7WruMqoYtwJ__ai-QPvD81ceoYC7j4+hC99gg@mail.gmail.com>
References: <CAD5xwhjSj82YYuQHHbwgSLvUNV2RDY0b=yMYeLj-p6j7PpS9-Q@mail.gmail.com>
	<20190605093039.xfo7lcylqkhsfncv@erisian.com.au>
	<im0q8670MxshmvMLmoJU0dv4rFhwWZNvQeQYv7i4fBWJOx0ghAdH8fYuQSqNxO2z8uxXGV-kurinUDfl0FsLWD0knw_U_h3zVZ0xy7vmn8o=@protonmail.com>
	<CAMZUoK=ZB06jwAbuX2D=aN8ztAqr_jSgEXS1z1ABjQYVawKCBQ@mail.gmail.com>
	<CAD5xwhj8o8Vbrk2KADBOFGfkD3fW3eMZo5aHJytGAj_5LLhYCg@mail.gmail.com>
	<CAMZUoKkPUn01V7WruMqoYtwJ__ai-QPvD81ceoYC7j4+hC99gg@mail.gmail.com>
Message-ID: <CAD5xwhi6QU5OZwSGMp4P3q7OYZMMZRUZgd2YOiUnv5tqgJxPSA@mail.gmail.com>

Do you think the following hypothesis is more or less true:

H: There is no set of pure extensions* to script E such that enabling E and
OP_SECURETHEBAG as proposed enables recursive covenants, but E alone does
not enable recursive covenants?

* Of course there are things that specifically are specifically designed to
switch on if OP_SECURETHEBAG, so pure means normal things like OP_CAT that
are a function of the arguments on the stack or hashed txn data.

This is the main draw of the design I proposed, it should be highly
improbable or impossible to accidentally introduce more behavior than
intended with a new opcode.

I think that given that H is not true for the stack reading version of the
opcode, we should avoid doing it unless strongly motivated, so as to permit
more flexibility for which opcodes we can add in the future without
introducing recursion unless it is explicitly intended.



On Mon, Jun 24, 2019, 7:35 AM Russell O'Connor <roconnor at blockstream.io>
wrote:

> OP_SECURETHEBAG doesn't include the script being executed (i.e the
> scriptPubKey specified in the output that is redeemed by this input) in its
> hash like ordinary signatures do
> <https://github.com/bitcoin/bitcoin/blob/master/src/script/interpreter.cpp#L1271>.
> Of course, this ScriptPubKey is indirectly committed to through the input's
> prevoutpoint.  However Script isn't able to reconstruct this script being
> executed from the prevoutpoint in tapscript without an implementation of
> public key tweeking in Bitcoin Script.
>
> On Sun, Jun 23, 2019 at 2:41 AM Jeremy Rubin <jeremy.l.rubin at gmail.com>
> wrote:
>
>> Can you clarify this comment?
>>
>> We do in fact commit to the script and scriptsig itself (not the witness
>> stack) in OP_SECURETHEBAG (unless I'm missing what you meant)?
>>
>> On Thu, Jun 20, 2019, 10:59 AM Russell O'Connor via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> Just to be clear, while OP_CHECKTXDIGESTVERIFY would enable this style
>>> of covenants if it pulled data from the stack, the OP_SECURETHEBAG
>>> probably cannot create covenants even if it were to pull the data from the
>>> stack unless some OP_TWEEKPUBKEY operation is added to Script because the
>>> "commitment of the script itself" isn't part of the OP_SECURETHEBAG.
>>>
>>> So with regards to OP_SECURETHEBAG, I am also "not really seeing any
>>> reason to complicate the spec to ensure the digest is precommitted as part
>>> of the opcode."
>>>
>>> On Thu, Jun 6, 2019 at 3:33 AM ZmnSCPxj via bitcoin-dev <
>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>>> Good morning aj,
>>>>
>>>>
>>>> Sent with ProtonMail Secure Email.
>>>>
>>>> ??????? Original Message ???????
>>>> On Wednesday, June 5, 2019 5:30 PM, Anthony Towns via bitcoin-dev <
>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>
>>>> > On Fri, May 31, 2019 at 10:35:45PM -0700, Jeremy via bitcoin-dev
>>>> wrote:
>>>> >
>>>> > > OP_CHECKOUTPUTSHASHVERIFY is retracted in favor of OP_SECURETHEBAG*.
>>>> >
>>>> > I think you could generalise that slightly and make it fit in
>>>> > with the existing opcode naming by calling it something like
>>>> > "OP_CHECKTXDIGESTVERIFY" and pull a 33-byte value from the stack,
>>>> > consisting of a sha256 hash and a sighash-byte, and adding a new
>>>> sighash
>>>> > value corresponding to the set of info you want to include in the
>>>> hash,
>>>> > which I think sounds a bit like "SIGHASH_EXACTLY_ONE_INPUT |
>>>> SIGHASH_ALL"
>>>> >
>>>> > FWIW, I'm not really seeing any reason to complicate the spec to
>>>> ensure
>>>> > the digest is precommitted as part of the opcode.
>>>> >
>>>>
>>>> I believe in combination with `OP_LEFT` and `OP_CAT` this allows
>>>> Turing-complete smart contracts, in much the same way as
>>>> `OP_CHECKSIGFROMSTACK`?
>>>>
>>>> Pass in the spent transaction (serialised for txid) and the spending
>>>> transaction (serialised for sighash) as part of the witness of the spending
>>>> transaction.
>>>>
>>>> Script verifies that the spending transaction witness value is indeed
>>>> the spending transaction by `OP_SHA256 <SIGHASH_ALL> OP_SWAP OP_CAT
>>>> OP_CHECKTXDIGESTVERIFY`.
>>>> Script verifies the spent transaction witness value is indeed the spent
>>>> transaction by hashing it, then splitting up the hash with `OP_LEFT` into
>>>> bytes, and comparing the bytes to the bytes in the input of the spending
>>>> transaction witness value (txid being the bytes in reversed order).
>>>>
>>>> Then the Script can extract a commitment of itself by extracting the
>>>> output of the spent transaction.
>>>> This lets the Script check that the spending transaction also pays to
>>>> the same script.
>>>>
>>>> The Script can then access a state value, for example from an
>>>> `OP_RETURN` output of the spent transaction, and enforce that a correct
>>>> next-state is used in the spending transaction.
>>>> If the state is too large to fit in a standard `OP_RETURN`, then the
>>>> current state can be passed in as a witness and validated against a hash
>>>> commitment in an `OP_RETURN` output.
>>>>
>>>> I believe this is the primary reason against not pulling data from the
>>>> stack.
>>>>
>>>> Regards,
>>>> ZmnSCPxj
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190624/1973d003/attachment-0001.html>

From roconnor at blockstream.io  Mon Jun 24 18:48:51 2019
From: roconnor at blockstream.io (Russell O'Connor)
Date: Mon, 24 Jun 2019 14:48:51 -0400
Subject: [bitcoin-dev] OP_SECURETHEBAG (supersedes OP_CHECKOUTPUTSVERIFY)
In-Reply-To: <CAD5xwhi6QU5OZwSGMp4P3q7OYZMMZRUZgd2YOiUnv5tqgJxPSA@mail.gmail.com>
References: <CAD5xwhjSj82YYuQHHbwgSLvUNV2RDY0b=yMYeLj-p6j7PpS9-Q@mail.gmail.com>
	<20190605093039.xfo7lcylqkhsfncv@erisian.com.au>
	<im0q8670MxshmvMLmoJU0dv4rFhwWZNvQeQYv7i4fBWJOx0ghAdH8fYuQSqNxO2z8uxXGV-kurinUDfl0FsLWD0knw_U_h3zVZ0xy7vmn8o=@protonmail.com>
	<CAMZUoK=ZB06jwAbuX2D=aN8ztAqr_jSgEXS1z1ABjQYVawKCBQ@mail.gmail.com>
	<CAD5xwhj8o8Vbrk2KADBOFGfkD3fW3eMZo5aHJytGAj_5LLhYCg@mail.gmail.com>
	<CAMZUoKkPUn01V7WruMqoYtwJ__ai-QPvD81ceoYC7j4+hC99gg@mail.gmail.com>
	<CAD5xwhi6QU5OZwSGMp4P3q7OYZMMZRUZgd2YOiUnv5tqgJxPSA@mail.gmail.com>
Message-ID: <CAMZUoKkorcO+CD6jcV5tyCtrKuHq_2hJhKE08FTrqJz7GgPM8Q@mail.gmail.com>

I suspect that your conjecture is true.  And given that it is plausible
that we would want to add an opcode to tweak public keys, it seems like a
reason design to avoid accidental covenants.
(That said, I strongly prefer that the SECURETHEBAG data be the 32-bytes
immediately following the opcode rather than a OP_PUSHDATA, and I'd be
willing to help code this up (see below)).

On Mon, Jun 24, 2019 at 2:07 PM Jeremy <jlrubin at mit.edu> wrote:

> Do you think the following hypothesis is more or less true:
>
> H: There is no set of pure extensions* to script E such that enabling E
> and OP_SECURETHEBAG as proposed enables recursive covenants, but E alone
> does not enable recursive covenants?
>
> * Of course there are things that specifically are specifically designed
> to switch on if OP_SECURETHEBAG, so pure means normal things like OP_CAT
> that are a function of the arguments on the stack or hashed txn data.
>
> This is the main draw of the design I proposed, it should be highly
> improbable or impossible to accidentally introduce more behavior than
> intended with a new opcode.
>
> I think that given that H is not true for the stack reading version of the
> opcode, we should avoid doing it unless strongly motivated, so as to permit
> more flexibility for which opcodes we can add in the future without
> introducing recursion unless it is explicitly intended.
>

On Sat, Jun 1, 2019 at 12:47 PM Jeremy via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> A particularly useful topic of discussion is how best to eliminate the
> PUSHDATA and treat OP_SECURETHEBAG like a pushdata directly. I thought
> about how the interpreter works and is implemented and couldn't come up
> with something noninvasive.
>

We shouldn't be using the complexity of the changes to the Bitcoin Core a
measure of the complexity of a proposal.  That is looking the issue from
the wrong side.  If we measure the complexity of Script proposals by how
hard it is to change Bitcoin Core, what will happen is more and more of the
incidental details of Bitcoin Core's implementation will be pulled into the
semantics of Script (e.g. the fact that surrounding opcode values are
readily available in Bitcoin Core's particular implementation of its Script
interpreter).  Instead we should use the complexity of how hard it is to
reason about the new Script semantics.

The peeking semantics of OP_SECURETHEBAG is particularly awful because it
more-or-less breaks the fact that Bitcoin Script can be decomposed into
individual units of "opcodes" whose semantics and be individually
described, and it harms the composability of Bitcoin Script where you can
divide the script between any opcodes and the semantics of the
concatenation of those two scripts is simply the composition of the
semantics of the two halves.  (For those interested in formal semantics,
what we have here is a monoid homomorphism from list of opcodes (syntax) to
stack transformation functions (with side-effects) under (Kleisli)
composition (semantics).) Being able to decompose a Bitcoin Script this way
and reasoning about components is how one would reason about Bitcoin Script
in practice.  (Technically the structure is more involved than a list of
opcodes due to OP_IF, and instead you get a railroad diagram
<https://en.wikipedia.org/wiki/Syntax_diagram>).

Putting the 32 bytes of data required by OP_SECURETHEBAG immediately after
the opcode, like how OP_PUSHDATA* works, is a superior design choice.  It
lets us treat the opcodes and its immediate data as an atomic unit when
reasoning about Script and removes the need to define what happens when
OP_SECURETHEBAG is not followed by an OP_PUSDATA.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190624/9d04f319/attachment-0001.html>

From jlrubin at mit.edu  Mon Jun 24 22:47:44 2019
From: jlrubin at mit.edu (Jeremy)
Date: Mon, 24 Jun 2019 15:47:44 -0700
Subject: [bitcoin-dev] OP_SECURETHEBAG (supersedes OP_CHECKOUTPUTSVERIFY)
In-Reply-To: <CAMZUoKkorcO+CD6jcV5tyCtrKuHq_2hJhKE08FTrqJz7GgPM8Q@mail.gmail.com>
References: <CAD5xwhjSj82YYuQHHbwgSLvUNV2RDY0b=yMYeLj-p6j7PpS9-Q@mail.gmail.com>
	<20190605093039.xfo7lcylqkhsfncv@erisian.com.au>
	<im0q8670MxshmvMLmoJU0dv4rFhwWZNvQeQYv7i4fBWJOx0ghAdH8fYuQSqNxO2z8uxXGV-kurinUDfl0FsLWD0knw_U_h3zVZ0xy7vmn8o=@protonmail.com>
	<CAMZUoK=ZB06jwAbuX2D=aN8ztAqr_jSgEXS1z1ABjQYVawKCBQ@mail.gmail.com>
	<CAD5xwhj8o8Vbrk2KADBOFGfkD3fW3eMZo5aHJytGAj_5LLhYCg@mail.gmail.com>
	<CAMZUoKkPUn01V7WruMqoYtwJ__ai-QPvD81ceoYC7j4+hC99gg@mail.gmail.com>
	<CAD5xwhi6QU5OZwSGMp4P3q7OYZMMZRUZgd2YOiUnv5tqgJxPSA@mail.gmail.com>
	<CAMZUoKkorcO+CD6jcV5tyCtrKuHq_2hJhKE08FTrqJz7GgPM8Q@mail.gmail.com>
Message-ID: <CAD5xwhjaC61jOLvPrMcsvL9ji5zUAP-=ai3NhBojeQcC4v8DpA@mail.gmail.com>

I agree in principal, but I think that's just a bit of 'how things are'
versus how they should be.

I disagree that we get composability semantics because of OP_IF. E.g., the
script "OP_IF .... " and "OP_END" are two scripts that separately are
invalid as parsed, but together are valid. OP_IF already imposes some
lookahead functionality... but as I understand it, it may be feasible to
get rid of OP_IF for tapscripts anyways. Also in this bucket are P2SH and
segwit, which I think breaks this because the concat of two p2sh scripts or
segwit scripts is not the same as them severally.

I also think that the OP_SECURETHEBAG use of pushdata is a backwards
compatible hack: we can always later redefine the parser to parse
OP_SECURETHEBAG as the 34 byte opcode, recapturing the purity of the
semantics. We can also fix it to not use an extra byte in a future tapleaf
version.

====

In any case, I don't disagree with figuring out what patching the parser to
handle multibyte opcodes would look like. If that sort of upgrade-path were
readily available when I wrote this, it's how I would have done it. There
are two approaches I looked at mostly:

1) Adding flags to GetOp to change how it parses
  a) Most of the same code paths used for new and old script
  b) Higher risk of breaking something in old script style/downstream
  c) Cleans up only one issue (multibyte opcodes) leaves other warts in
place
  d) less bikesheddable design (mostly same as old script)
  e) code not increased in size
2) Adding a completely new interpreter for Tapscript
  a) Fork the existing interpreter code
  b) For all places where scripts are run, switch based on if it is
tapscript or not
  c) Can clean up various semantics, can even do fancier things like
huffman encode opcodes to less than a byte
  d) Can clearly separate parsing the script from executing it
  e) Can improve versioning techniques
  f) Low risk of breaking something in old script style/downstream
  g) Increases amount of code substantially
  h) Bikesheddable design (everything is on the table).
  i) probably a better general mechanism for future changes to script
parsing, less consensus risk
  j) More compatible with templated script as well.

If not clear, I think that 2 is probably a better approach, but I'm worried
that 2.h means this would take a much longer time to implement.

2 can be segmented into two components:

1) the architecture of script parser versioning
2) the actual new script version

I think that component 1 can be relatively non controversial, thankfully,
using tapleaf versions (the architecture question is more around code
structure). A proof of concept of this would be to have a fork that uses
two independent, but identical, script parsers.

Part two of this plan would be to modify one of the versions substantially.
I'm not sure what exists on the laundry list, but I think it would be
possible to pick a few worthwhile cleanups. E.g.:

1) Multibyte opcodes
2) Templated scripts
3) Huffman Encoding opcodes
4) OP_IF handling (maybe just get rid of it in favor of conditional Verify
semantics)

And make it clear that because we can add future script versions fairly
easily, this is a sufficient step.


Does that seem in line with your understanding of how this might be done?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190624/86f6c9df/attachment-0001.html>

From roconnor at blockstream.io  Tue Jun 25 17:05:39 2019
From: roconnor at blockstream.io (Russell O'Connor)
Date: Tue, 25 Jun 2019 13:05:39 -0400
Subject: [bitcoin-dev] OP_SECURETHEBAG (supersedes OP_CHECKOUTPUTSVERIFY)
In-Reply-To: <CAD5xwhjaC61jOLvPrMcsvL9ji5zUAP-=ai3NhBojeQcC4v8DpA@mail.gmail.com>
References: <CAD5xwhjSj82YYuQHHbwgSLvUNV2RDY0b=yMYeLj-p6j7PpS9-Q@mail.gmail.com>
	<20190605093039.xfo7lcylqkhsfncv@erisian.com.au>
	<im0q8670MxshmvMLmoJU0dv4rFhwWZNvQeQYv7i4fBWJOx0ghAdH8fYuQSqNxO2z8uxXGV-kurinUDfl0FsLWD0knw_U_h3zVZ0xy7vmn8o=@protonmail.com>
	<CAMZUoK=ZB06jwAbuX2D=aN8ztAqr_jSgEXS1z1ABjQYVawKCBQ@mail.gmail.com>
	<CAD5xwhj8o8Vbrk2KADBOFGfkD3fW3eMZo5aHJytGAj_5LLhYCg@mail.gmail.com>
	<CAMZUoKkPUn01V7WruMqoYtwJ__ai-QPvD81ceoYC7j4+hC99gg@mail.gmail.com>
	<CAD5xwhi6QU5OZwSGMp4P3q7OYZMMZRUZgd2YOiUnv5tqgJxPSA@mail.gmail.com>
	<CAMZUoKkorcO+CD6jcV5tyCtrKuHq_2hJhKE08FTrqJz7GgPM8Q@mail.gmail.com>
	<CAD5xwhjaC61jOLvPrMcsvL9ji5zUAP-=ai3NhBojeQcC4v8DpA@mail.gmail.com>
Message-ID: <CAMZUoKk-WHk8xz0vSs+xoPKPeMWV16bfP+mCt80jCZk8BQqx=w@mail.gmail.com>

Bitcoin Core is somewhat outside my core competence, but the various
OP_PUSHDATA are already multi-byte opcodes and GetOp already has a data
return parameter that is suitable for returning the payload of an immediate
32-byte data variant of OP_SECURETHEBAG.  All that I expect is needed is to
ensure that nowhere else is using a non-empty data-field as a proxy for a
non-empty push operation and fixing any such occurrences if they exist.
(AFAIKT there are only a handful of calls to GetOp).

It is probably worth updating the tapscript implementation to better
prepare it for new uses of OP_SUCCESSx.  Parsing should halt when an
OP_SUCCESSx is encountered, by having GetScriptOp advance the pc to end
after encountering such a code (decoding Script is no longer meaningful
after an OP_SUCCESS is encountered).  However, that means that GetScriptOp
needs to know what version of script it is expected to be parsing.  This
could be done by sending down some versioning flags, possibly by adding a
versioning field to CScript that can be initialized @
https://github.com/sipa/bitcoin/blob/7ddc7027b2cbdd11416809400c588e585a8b44ed/src/script/interpreter.cpp#L1679
or some other mechanism (and at the same time perhaps having GetSigOpCount
return 0 for tapscript, since counting sigops is not really meaningful in
tapscript). There are probably other reasonable approaches too (e.g your
option 2 below).  I could write some code to illustrate what I'm thinking
if you feel that would be helpful and I do think such changes around
OP_SUCCESS should be implemented regardless of whether we move forward with
OP_SECURETHEBAG or not.

It is probably worth doing this properly the first time around if we are
going to do it at all.

P.S. OP_RESERVED1 has been renamed to OP_SUCCESS137 in bip-tapscript.


>
> On Mon, Jun 24, 2019 at 6:47 PM Jeremy <jlrubin at mit.edu> wrote:

> I agree in principal, but I think that's just a bit of 'how things are'
> versus how they should be.
>
> I disagree that we get composability semantics because of OP_IF. E.g., the
> script "OP_IF .... " and "OP_END" are two scripts that separately are
> invalid as parsed, but together are valid. OP_IF already imposes some
> lookahead functionality... but as I understand it, it may be feasible to
> get rid of OP_IF for tapscripts anyways. Also in this bucket are P2SH and
> segwit, which I think breaks this because the concat of two p2sh scripts or
> segwit scripts is not the same as them severally.
>
> I also think that the OP_SECURETHEBAG use of pushdata is a backwards
> compatible hack: we can always later redefine the parser to parse
> OP_SECURETHEBAG as the 34 byte opcode, recapturing the purity of the
> semantics. We can also fix it to not use an extra byte in a future tapleaf
> version.
>

> In any case, I don't disagree with figuring out what patching the parser
> to handle multibyte opcodes would look like. If that sort of upgrade-path
> were readily available when I wrote this, it's how I would have done it.
> There are two approaches I looked at mostly:
>
> 1) Adding flags to GetOp to change how it parses
>   a) Most of the same code paths used for new and old script
>   b) Higher risk of breaking something in old script style/downstream
>   c) Cleans up only one issue (multibyte opcodes) leaves other warts in
> place
>   d) less bikesheddable design (mostly same as old script)
>   e) code not increased in size
> 2) Adding a completely new interpreter for Tapscript
>   a) Fork the existing interpreter code
>   b) For all places where scripts are run, switch based on if it is
> tapscript or not
>   c) Can clean up various semantics, can even do fancier things like
> huffman encode opcodes to less than a byte
>   d) Can clearly separate parsing the script from executing it
>   e) Can improve versioning techniques
>   f) Low risk of breaking something in old script style/downstream
>   g) Increases amount of code substantially
>   h) Bikesheddable design (everything is on the table).
>   i) probably a better general mechanism for future changes to script
> parsing, less consensus risk
>   j) More compatible with templated script as well.
>
> If not clear, I think that 2 is probably a better approach, but I'm
> worried that 2.h means this would take a much longer time to implement.
>
> 2 can be segmented into two components:
>
> 1) the architecture of script parser versioning
> 2) the actual new script version
>
> I think that component 1 can be relatively non controversial, thankfully,
> using tapleaf versions (the architecture question is more around code
> structure). A proof of concept of this would be to have a fork that uses
> two independent, but identical, script parsers.
>
> Part two of this plan would be to modify one of the versions
> substantially. I'm not sure what exists on the laundry list, but I think it
> would be possible to pick a few worthwhile cleanups. E.g.:
>
> 1) Multibyte opcodes
> 2) Templated scripts
> 3) Huffman Encoding opcodes
> 4) OP_IF handling (maybe just get rid of it in favor of conditional Verify
> semantics)
>
> And make it clear that because we can add future script versions fairly
> easily, this is a sufficient step.
>
>
> Does that seem in line with your understanding of how this might be done?
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190625/870a1cdd/attachment-0001.html>

From roconnor at blockstream.io  Thu Jun 27 00:08:01 2019
From: roconnor at blockstream.io (Russell O'Connor)
Date: Wed, 26 Jun 2019 20:08:01 -0400
Subject: [bitcoin-dev] Taproot proposal
In-Reply-To: <CAPg+sBg6Gg8b7hPogC==fehY3ZTHHpQReqym2fb4XXWFpMM-pQ@mail.gmail.com>
References: <CAPg+sBg6Gg8b7hPogC==fehY3ZTHHpQReqym2fb4XXWFpMM-pQ@mail.gmail.com>
Message-ID: <CAMZUoKnniSEy4RM2DWCRxzVyYsGJ3Rbw4sbFv0zxuPi9gwoXYA@mail.gmail.com>

I have a comment about the 'input_index' of the transaction digest for
taproot signatures.  It is currently listed as 2 bytes.  I think it would
be better to expand that to 4 bytes.
The two byte limit is derived from the block size / weight limit, which
limits the maximum size of a transaction, which in turn, due to a minimum
size of an inputs, places a limit on the maximum number of inputs.

However, I think it is a mistake to mix limits from the block layer into
the transaction layer of the consensus rules.  For example, I believe that,
as it stands currently, if we wanted to hardfork an increase in the block
weight limit, doing so wouldn't have any impact on the transaction layer
and we could transparently manage larger transactions with the current
transaction format [2].  However if we start incorporating the block limits
into the transaction layer, then we run the risk of such a hard fork
needing to also make consensus changes in the transaction
format/interpretation if we wanted to handle larger transaction sizes,
which, while doable, wouldn't be so great.

The current transaction format limits the number of inputs (and the number
of outputs) to 2^32-1 or less [1].  So using 4 bytes for the 'input_index'
will suffice.

Given that adding 2 bytes to the signed transaction digest isn't a big
deal, it's probably better just to keep block limits and transaction limits
separate.

[1]The var-integer field for the number of inputs (and the number of
outputs) in a transaction looks like it should allow upto 2^64-1 inputs;
however this is an illusion.  The P2P rules dictate that these values are
immediately taken modulo 2^32 after decoding.  For example, if the number
of inputs is a var-integer encoding of 0x0100000001, it is actually just a
non-canonical way of encoding that there is 1 input.  Try this at home!

[2]If we were to hardfork an increase in the block weight limit, we would
probably want to still keep the limit on the size of transactions that
consume legacy UTXOs in order to avoid the quadratic computation problems
that plagues the legacy transaction digest.

On Mon, May 6, 2019 at 2:36 PM Pieter Wuille via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hello everyone,
>
> Here are two BIP drafts that specify a proposal for a Taproot
> softfork. A number of ideas are included:
>
> * Taproot to make all outputs and cooperative spends indistinguishable
> from eachother.
> * Merkle branches to hide the unexecuted branches in scripts.
> * Schnorr signatures enable wallet software to use key
> aggregation/thresholds within one input.
> * Improvements to the signature hashing algorithm (including signing
> all input amounts).
> * Replacing OP_CHECKMULTISIG(VERIFY) with OP_CHECKSIGADD, to support
> batch validation.
> * Tagged hashing for domain separation (avoiding issues like
> CVE-2012-2459 in Merkle trees).
> * Extensibility through leaf versions, OP_SUCCESS opcodes, and
> upgradable pubkey types.
>
> The BIP drafts can be found here:
> * https://github.com/sipa/bips/blob/bip-schnorr/bip-taproot.mediawiki
> specifies the transaction input spending rules.
> * https://github.com/sipa/bips/blob/bip-schnorr/bip-tapscript.mediawiki
> specifies the changes to Script inside such spends.
> * https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki
> is the Schnorr signature proposal that was discussed earlier on this
> list (See
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016203.html
> )
>
> An initial reference implementation of the consensus changes, plus
> preliminary construction/signing tests in the Python framework can be
> found on https://github.com/sipa/bitcoin/commits/taproot. All
> together, excluding the Schnorr signature module in libsecp256k1, the
> consensus changes are around 520 LoC.
>
> While many other ideas exist, not everything is incorporated. This
> includes several ideas that can be implemented separately without loss
> of effectiveness. One such idea is a way to integrate SIGHASH_NOINPUT,
> which we're working on as an independent proposal.
>
> The document explains basic wallet operations, such as constructing
> outputs and signing. However, a wide variety of more complex
> constructions exist. Standardizing these is useful, but out of scope
> for now. It is likely also desirable to define extensions to PSBT
> (BIP174) for interacting with Taproot. That too is not included here.
>
> Cheers,
>
> --
> Pieter
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190626/7223bf9f/attachment.html>

From junderwood at bitcoinbank.co.jp  Thu Jun 27 02:11:23 2019
From: junderwood at bitcoinbank.co.jp (Jonathan Underwood)
Date: Thu, 27 Jun 2019 11:11:23 +0900
Subject: [bitcoin-dev] BIP174 extension proposal (Global Type:
	PSBT_GLOBAL_XPUB_SIGNATURE)
Message-ID: <CAMpN3mLvY+kuUGqzMW6SAMZ=h46_g=XLhDPhSY=X6xhLxvi15Q@mail.gmail.com>

Hello all,

Just wanted to pick your brains about an idea for PSBT extension.

One problem we try to solve with cold -> warm and warm -> hot sends for our
exchange wallet is "How do I know that the address I am sending to is not a
hacker's address that was swapped in between unsigned tx creation and first
signature?"

We have a proprietary JSON based encoding system which we are looking to
move towards PSBT, but PSBT is missing this key functionality.

BIP32_DERIVATION does allow us to verify the address is from a certain
XPUB, but, for example, it can not allow us to verify a signature of that
xpub.

I have made a rough draft of the proposed key value specification.
https://github.com/junderw/bips/blob/addXpubSig/bip-0174.mediawiki#specification

The signing key path used in the spec is just randomly chosen 31 x 4 bits
shown as numbers with hardened paths.

Since this issue seems similar to the change address issue, I started from
that as a base. With the HW wallet case, I can verify the xpub by just
deriving it locally and comparing equality, however, in our case, we need
to verify an xpub that we do not have access to via derivation from our
cold key(s) (since we don't want to import our warm private key into our
cold signer)

So the flow would be:
1. Securely verify the xpub of the warm / hot wallet.
2. Using the airgap signing tool, sign the xpub with all cold keys.
3. Upload the signature/xpub pairs to the online unsigned transaction
generator.
4. Include one keyval pair per coldkey/xpub pairing.
5. When offline signing, if the wallet detects there is a global keyval
XPUB_SIGNATURE with its pubkey in the key, it must verify that all outputs
have BIP32_DERIVATION and that it can verify the outputs through the
derivation, to the xpub, and to the signature.

In my attempt to fitting this into PSBT, I am slightly altering our current
system, so don't take this as an indication 100% of how we work in the
backend.

However, I would like to hear any feedback on this proposal.

Thanks,
Jonathan

-- 
-----------------
Jonathan Underwood
??????? ??????????????
-----------------

???????????????????????????????

??: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190627/82c9ecc0/attachment.html>

From junderwood at bitcoinbank.co.jp  Thu Jun 27 05:07:47 2019
From: junderwood at bitcoinbank.co.jp (Jonathan Underwood)
Date: Thu, 27 Jun 2019 14:07:47 +0900
Subject: [bitcoin-dev] BIP174 extension proposal (Global Type:
	PSBT_GLOBAL_XPUB_SIGNATURE)
In-Reply-To: <20190627095031.4d5817b8@simplexum.com>
References: <CAMpN3mLvY+kuUGqzMW6SAMZ=h46_g=XLhDPhSY=X6xhLxvi15Q@mail.gmail.com>
	<20190627095031.4d5817b8@simplexum.com>
Message-ID: <CAMpN3mKPkCPtYkN-JVku1r217-aBK=Rh3UEhvRPS_Y6DixJ9Dw@mail.gmail.com>

Thanks for the reply.

The way we would do it is:

Let's say we have 3 cold keys for multisig: A B and C

Whose xpubs are: xA xB and xC

We all sign each other's xpubs, whose signatures are:
sAxB
sAxC
sBxA
sBxC
sCxA
sCxB

We can then create a wallet that says "when verifying change with 0x01
global type proposed by Andrew Chow, if the change is multisig, we MUST
require the other pubkeys to have signatures via my 0x02 proposal"

This way, all my PSBTs for my cold will have:
1. an 0x01 entry to tell me how to get my change.
2. All 6 of the signatures above.

And the signer will then look at the change, check my pubkey by deriving
the xpub and checking equality to the BIP_DERIVATION of the output... it
will then check the OTHER pubkeys via BIP32_DERIVATION to master
fingerprint, then link that fingerprint to a 0x02 sig from MY key,
verifying all pubkeys.

So this proposal of mine would not only fix the "send to address
verification" problem for HD, but also the multisig change problem with
0x01.

Cool.

Only thing that is kind of sad is having to include n! (of m-of-n)
signatures in every PSBT... but tbh, the PSBT size is not of much concern.

Thanks for the reply.
- Jonathan


2019?6?27?(?) 13:49 Dmitry Petukhov <dp at simplexum.com>:

> Hi!
>
> I wonder how your scheme handles multisig ?
>
> As I understand, you sign individual xpubs with cold keys, so that cold
> keys can check destination addresses are trusted.
>
> I seems to me that if you sign individual xpubs of a multisig warm
> wallet, and one key from that multisig is compromized, attackers can
> then create a single-sig destination address that they control, and
> move the coins in a chain of two transactions, first to this single-sig
> address, and then to an address that they independently control.
>
> My idea to prevent this [1] is to sign the whole 'xpub package' of the
> multisig wallet, but there is also an issue of 'partial compromize',
> where some of the keys in a multisig warm wallet is compromized, and
> you do not want to regard a particular 'xpub package' as trusted. My
> idea was [2] to use an auxiliary message that would be signed along with
> the 'xpub package', and that message can include specific 'epoch' word
> that hardware wallet can show prominently before signing, or have
> 'serial number' for xpub packages (but that will require to store last
> known serial inside hw wallet, making it stateful).
>
> I like the idea to extend PSBT to accomodate these schemes, but given
> that the huge number of possible schemes that each may probably
> require its own PSBT field type, I think that this is better dealt with
> outside of PSBT, as 'PSBT metainformation', or using some form of
> 'vendor-specific', or 'metainformation-specific' PSBT field. This way
> each usecase can be independently described in its own documentation,
> that would include the particulars of the format for the
> metainformation. This would also make it easier to implement PSBT for
> simple cases, because the 'core specification' would not grow that big.
>
> [1]
>
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016917.html
>
> [2]
>
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016926.html
>
>
> ? Thu, 27 Jun 2019 11:11:23 +0900 Jonathan Underwood via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > Hello all,
> >
> > Just wanted to pick your brains about an idea for PSBT extension.
> >
> > One problem we try to solve with cold -> warm and warm -> hot sends
> > for our exchange wallet is "How do I know that the address I am
> > sending to is not a hacker's address that was swapped in between
> > unsigned tx creation and first signature?"
> >
> > We have a proprietary JSON based encoding system which we are looking
> > to move towards PSBT, but PSBT is missing this key functionality.
> >
> > BIP32_DERIVATION does allow us to verify the address is from a certain
> > XPUB, but, for example, it can not allow us to verify a signature of
> > that xpub.
> >
> > I have made a rough draft of the proposed key value specification.
> >
> https://github.com/junderw/bips/blob/addXpubSig/bip-0174.mediawiki#specification
> >
> > The signing key path used in the spec is just randomly chosen 31 x 4
> > bits shown as numbers with hardened paths.
> >
> > Since this issue seems similar to the change address issue, I started
> > from that as a base. With the HW wallet case, I can verify the xpub
> > by just deriving it locally and comparing equality, however, in our
> > case, we need to verify an xpub that we do not have access to via
> > derivation from our cold key(s) (since we don't want to import our
> > warm private key into our cold signer)
> >
> > So the flow would be:
> > 1. Securely verify the xpub of the warm / hot wallet.
> > 2. Using the airgap signing tool, sign the xpub with all cold keys.
> > 3. Upload the signature/xpub pairs to the online unsigned transaction
> > generator.
> > 4. Include one keyval pair per coldkey/xpub pairing.
> > 5. When offline signing, if the wallet detects there is a global
> > keyval XPUB_SIGNATURE with its pubkey in the key, it must verify that
> > all outputs have BIP32_DERIVATION and that it can verify the outputs
> > through the derivation, to the xpub, and to the signature.
> >
> > In my attempt to fitting this into PSBT, I am slightly altering our
> > current system, so don't take this as an indication 100% of how we
> > work in the backend.
> >
> > However, I would like to hear any feedback on this proposal.
> >
> > Thanks,
> > Jonathan
> >
>
>

-- 
-----------------
Jonathan Underwood
??????? ??????????????
-----------------

???????????????????????????????

??: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190627/14367388/attachment-0001.html>

From junderwood at bitcoinbank.co.jp  Thu Jun 27 08:16:14 2019
From: junderwood at bitcoinbank.co.jp (Jonathan Underwood)
Date: Thu, 27 Jun 2019 17:16:14 +0900
Subject: [bitcoin-dev] BIP174 extension proposal (Global Type:
	PSBT_GLOBAL_XPUB_SIGNATURE)
In-Reply-To: <20190627122916.3b6c2c32@simplexum.com>
References: <CAMpN3mLvY+kuUGqzMW6SAMZ=h46_g=XLhDPhSY=X6xhLxvi15Q@mail.gmail.com>
	<20190627095031.4d5817b8@simplexum.com>
	<CAMpN3mKPkCPtYkN-JVku1r217-aBK=Rh3UEhvRPS_Y6DixJ9Dw@mail.gmail.com>
	<20190627122916.3b6c2c32@simplexum.com>
Message-ID: <CAMpN3mL8tyP-6-nwn6dorcq7-dad6wYz8_pXinqHhgzUnrr_tg@mail.gmail.com>

I see what you mean.

What about this?
https://github.com/junderw/bips/commit/57a57b4fae1ae14b77a2eebd99cd719148e3027e?short_path=82656c8#diff-82656c833e31e6751a412ce5e5c70920

Plus side: for single sig case, the key only increases by one byte (0x00
for the {m} value)

This way if it was 2 of 3 like before, you sign the whole "packet" so each
key only signs the packet once. Way better than n!

Anywho. Please send your feedback. Thanks.
Jonathan

2019?6?27?(?) 16:27 Dmitry Petukhov <dp at simplexum.com>:

> How would signer know that there _should_ be at least 3 signatures
> signed by the key owned by this signer ?
>
> If it does not know that it should enforce 2of3 multisig, for example,
> the attacker that control only one key A can fool signer B by
> sending to 1of1 single-sig that is derived from A's xpub, and providing
> only sBxA in PSBT.
>
> If the signer does not have a hardcoded configuration that
> will mandate a particular multisig scheme, it will allow sending to any
> scheme.
>
> If the signer has a rich enough state to store updatable configuration,
> it can just store the trusted xpubs directly.
>
> Alternatively, signer can sign not individual xpubs, but whole xpub
> packages that correspond to particular multisig configuration, and
> enforce that destination addresses correspond to this configuration.
>
> But this would not be possible with your PSBT scheme that uses
> individual key-xpub pairs.
>
> ? Thu, 27 Jun 2019 14:07:47 +0900
> Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:
>
> > Thanks for the reply.
> >
> > The way we would do it is:
> >
> > Let's say we have 3 cold keys for multisig: A B and C
> >
> > Whose xpubs are: xA xB and xC
> >
> > We all sign each other's xpubs, whose signatures are:
> > sAxB
> > sAxC
> > sBxA
> > sBxC
> > sCxA
> > sCxB
> >
> > We can then create a wallet that says "when verifying change with 0x01
> > global type proposed by Andrew Chow, if the change is multisig, we
> > MUST require the other pubkeys to have signatures via my 0x02
> > proposal"
> >
> > This way, all my PSBTs for my cold will have:
> > 1. an 0x01 entry to tell me how to get my change.
> > 2. All 6 of the signatures above.
> >
> > And the signer will then look at the change, check my pubkey by
> > deriving the xpub and checking equality to the BIP_DERIVATION of the
> > output... it will then check the OTHER pubkeys via BIP32_DERIVATION
> > to master fingerprint, then link that fingerprint to a 0x02 sig from
> > MY key, verifying all pubkeys.
> >
> > So this proposal of mine would not only fix the "send to address
> > verification" problem for HD, but also the multisig change problem
> > with 0x01.
> >
> > Cool.
> >
> > Only thing that is kind of sad is having to include n! (of m-of-n)
> > signatures in every PSBT... but tbh, the PSBT size is not of much
> > concern.
> >
> > Thanks for the reply.
> > - Jonathan
> >
> >
> > 2019?6?27?(?) 13:49 Dmitry Petukhov <dp at simplexum.com>:
> >
> > > Hi!
> > >
> > > I wonder how your scheme handles multisig ?
> > >
> > > As I understand, you sign individual xpubs with cold keys, so that
> > > cold keys can check destination addresses are trusted.
> > >
> > > I seems to me that if you sign individual xpubs of a multisig warm
> > > wallet, and one key from that multisig is compromized, attackers can
> > > then create a single-sig destination address that they control, and
> > > move the coins in a chain of two transactions, first to this
> > > single-sig address, and then to an address that they independently
> > > control.
> > >
> > > My idea to prevent this [1] is to sign the whole 'xpub package' of
> > > the multisig wallet, but there is also an issue of 'partial
> > > compromize', where some of the keys in a multisig warm wallet is
> > > compromized, and you do not want to regard a particular 'xpub
> > > package' as trusted. My idea was [2] to use an auxiliary message
> > > that would be signed along with the 'xpub package', and that
> > > message can include specific 'epoch' word that hardware wallet can
> > > show prominently before signing, or have 'serial number' for xpub
> > > packages (but that will require to store last known serial inside
> > > hw wallet, making it stateful).
> > >
> > > I like the idea to extend PSBT to accomodate these schemes, but
> > > given that the huge number of possible schemes that each may
> > > probably require its own PSBT field type, I think that this is
> > > better dealt with outside of PSBT, as 'PSBT metainformation', or
> > > using some form of 'vendor-specific', or 'metainformation-specific'
> > > PSBT field. This way each usecase can be independently described in
> > > its own documentation, that would include the particulars of the
> > > format for the metainformation. This would also make it easier to
> > > implement PSBT for simple cases, because the 'core specification'
> > > would not grow that big.
> > >
> > > [1]
> > >
> > >
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016917.html
> > >
> > > [2]
> > >
> > >
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016926.html
> > >
> > >
> > > ? Thu, 27 Jun 2019 11:11:23 +0900 Jonathan Underwood via bitcoin-dev
> > > <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > >
> > > > Hello all,
> > > >
> > > > Just wanted to pick your brains about an idea for PSBT extension.
> > > >
> > > > One problem we try to solve with cold -> warm and warm -> hot
> > > > sends for our exchange wallet is "How do I know that the address
> > > > I am sending to is not a hacker's address that was swapped in
> > > > between unsigned tx creation and first signature?"
> > > >
> > > > We have a proprietary JSON based encoding system which we are
> > > > looking to move towards PSBT, but PSBT is missing this key
> > > > functionality.
> > > >
> > > > BIP32_DERIVATION does allow us to verify the address is from a
> > > > certain XPUB, but, for example, it can not allow us to verify a
> > > > signature of that xpub.
> > > >
> > > > I have made a rough draft of the proposed key value specification.
> > > >
> > >
> https://github.com/junderw/bips/blob/addXpubSig/bip-0174.mediawiki#specification
>
> > > >
> > > > The signing key path used in the spec is just randomly chosen 31
> > > > x 4 bits shown as numbers with hardened paths.
> > > >
> > > > Since this issue seems similar to the change address issue, I
> > > > started from that as a base. With the HW wallet case, I can
> > > > verify the xpub by just deriving it locally and comparing
> > > > equality, however, in our case, we need to verify an xpub that we
> > > > do not have access to via derivation from our cold key(s) (since
> > > > we don't want to import our warm private key into our cold signer)
> > > >
> > > > So the flow would be:
> > > > 1. Securely verify the xpub of the warm / hot wallet.
> > > > 2. Using the airgap signing tool, sign the xpub with all cold
> > > > keys. 3. Upload the signature/xpub pairs to the online unsigned
> > > > transaction generator.
> > > > 4. Include one keyval pair per coldkey/xpub pairing.
> > > > 5. When offline signing, if the wallet detects there is a global
> > > > keyval XPUB_SIGNATURE with its pubkey in the key, it must verify
> > > > that all outputs have BIP32_DERIVATION and that it can verify the
> > > > outputs through the derivation, to the xpub, and to the signature.
> > > >
> > > > In my attempt to fitting this into PSBT, I am slightly altering
> > > > our current system, so don't take this as an indication 100% of
> > > > how we work in the backend.
> > > >
> > > > However, I would like to hear any feedback on this proposal.
> > > >
> > > > Thanks,
> > > > Jonathan
> > > >
> > >
> > >
> >
>
>

-- 
-----------------
Jonathan Underwood
??????? ??????????????
-----------------

???????????????????????????????

??: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190627/30b46b5a/attachment-0001.html>

From junderwood at bitcoinbank.co.jp  Thu Jun 27 08:59:44 2019
From: junderwood at bitcoinbank.co.jp (Jonathan Underwood)
Date: Thu, 27 Jun 2019 17:59:44 +0900
Subject: [bitcoin-dev] BIP174 extension proposal (Global Type:
	PSBT_GLOBAL_XPUB_SIGNATURE)
In-Reply-To: <CAMpN3m+LiSW=kRCQio+C_2To66o_SEq-d_0Z122j+BUxvh=LDQ@mail.gmail.com>
References: <CAMpN3mLvY+kuUGqzMW6SAMZ=h46_g=XLhDPhSY=X6xhLxvi15Q@mail.gmail.com>
	<20190627095031.4d5817b8@simplexum.com>
	<CAMpN3mKPkCPtYkN-JVku1r217-aBK=Rh3UEhvRPS_Y6DixJ9Dw@mail.gmail.com>
	<20190627122916.3b6c2c32@simplexum.com>
	<CAMpN3mL8tyP-6-nwn6dorcq7-dad6wYz8_pXinqHhgzUnrr_tg@mail.gmail.com>
	<20190627134628.4d131264@simplexum.com>
	<CAMpN3m+LiSW=kRCQio+C_2To66o_SEq-d_0Z122j+BUxvh=LDQ@mail.gmail.com>
Message-ID: <CAMpN3mKP=Se1fKYORy3y5zCQ+mxb6Mk__FOKfJDDV35L_4y=Bw@mail.gmail.com>

When I say order is not necessary I mean, I won't have to brute force order.

Either way, if we don't sort the xpubs in the key, it would be possible to
create multiple key value pairs for essentially the same group of pubkeys.
"I only want to sign if the multisig is in this order" is pointless.

And like I said, output PSBT includes redeemscript and witnessscript, so my
app can just say "if no redeemscript or witnessscript or BIP32_DERIVATION
for the output, fail"

- Jonathan

2019?6?27?(?) 17:56 Jonathan Underwood <junderwood at bitcoinbank.co.jp>:

> The output will have redeemscript and witnessscript so order is not
> necessary. I can just look at the multisig script and find the pubkey
> inside it.
>
> -Jonathan
>
> 2019?6?27?(?) 17:45 Dmitry Petukhov <dp at simplexum.com>:
>
>> > m value for a multisig (set 0 for non-multisig), followed by 1 or
>> > more 78 byte serialized extended public keys sorted in canonical
>> > order
>>
>> Sorting xpubs would work if the addresses also sort their pubkeys (like
>> in BIP67)
>>
>> But if the pubkey order in address creation is fixed, you better have
>> the fixed order for xpubs, otherwise you would need to try all
>> combinations of derived pubkeys when checking if the addresss match the
>> presented xpubs. That would be factorial of the number of keys, not
>> feasible beyond very small number of keys.
>>
>> Bitcoin Core, for example, currently does not support BIP67 and supports
>> only fixed pubkey positions in their script descriptors specification.
>>
>> You also need to include all xpubs to match the address, for m of n
>> standard multisig, you need to include n and check that number of keys
>> is exactly n.
>>
>> Otherwise your would not be able to construct the address to compare to
>> the destination address that you need to check, as you need all pubkesy
>> to construct P2SH or P2WSH address.
>>
>> With Shnorr-musig, you probably can interpolate the combined pubkey out
>> of m paticpant pubkeys (but don't cite me on this, I might be wrong)
>>
>> ? Thu, 27 Jun 2019 17:16:14 +0900
>> Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:
>>
>> > I see what you mean.
>> >
>> > What about this?
>> >
>> https://github.com/junderw/bips/commit/57a57b4fae1ae14b77a2eebd99cd719148e3027e?short_path=82656c8#diff-82656c833e31e6751a412ce5e5c70920
>> >
>> > Plus side: for single sig case, the key only increases by one byte
>> > (0x00 for the {m} value)
>> >
>> > This way if it was 2 of 3 like before, you sign the whole "packet" so
>> > each key only signs the packet once. Way better than n!
>> >
>> > Anywho. Please send your feedback. Thanks.
>> > Jonathan
>> >
>> > 2019?6?27?(?) 16:27 Dmitry Petukhov <dp at simplexum.com>:
>> >
>> > > How would signer know that there _should_ be at least 3 signatures
>> > > signed by the key owned by this signer ?
>> > >
>> > > If it does not know that it should enforce 2of3 multisig, for
>> > > example, the attacker that control only one key A can fool signer B
>> > > by sending to 1of1 single-sig that is derived from A's xpub, and
>> > > providing only sBxA in PSBT.
>> > >
>> > > If the signer does not have a hardcoded configuration that
>> > > will mandate a particular multisig scheme, it will allow sending to
>> > > any scheme.
>> > >
>> > > If the signer has a rich enough state to store updatable
>> > > configuration, it can just store the trusted xpubs directly.
>> > >
>> > > Alternatively, signer can sign not individual xpubs, but whole xpub
>> > > packages that correspond to particular multisig configuration, and
>> > > enforce that destination addresses correspond to this configuration.
>> > >
>> > > But this would not be possible with your PSBT scheme that uses
>> > > individual key-xpub pairs.
>> > >
>> > > ? Thu, 27 Jun 2019 14:07:47 +0900
>> > > Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:
>> > >
>> > > > Thanks for the reply.
>> > > >
>> > > > The way we would do it is:
>> > > >
>> > > > Let's say we have 3 cold keys for multisig: A B and C
>> > > >
>> > > > Whose xpubs are: xA xB and xC
>> > > >
>> > > > We all sign each other's xpubs, whose signatures are:
>> > > > sAxB
>> > > > sAxC
>> > > > sBxA
>> > > > sBxC
>> > > > sCxA
>> > > > sCxB
>> > > >
>> > > > We can then create a wallet that says "when verifying change with
>> > > > 0x01 global type proposed by Andrew Chow, if the change is
>> > > > multisig, we MUST require the other pubkeys to have signatures
>> > > > via my 0x02 proposal"
>> > > >
>> > > > This way, all my PSBTs for my cold will have:
>> > > > 1. an 0x01 entry to tell me how to get my change.
>> > > > 2. All 6 of the signatures above.
>> > > >
>> > > > And the signer will then look at the change, check my pubkey by
>> > > > deriving the xpub and checking equality to the BIP_DERIVATION of
>> > > > the output... it will then check the OTHER pubkeys via
>> > > > BIP32_DERIVATION to master fingerprint, then link that
>> > > > fingerprint to a 0x02 sig from MY key, verifying all pubkeys.
>> > > >
>> > > > So this proposal of mine would not only fix the "send to address
>> > > > verification" problem for HD, but also the multisig change problem
>> > > > with 0x01.
>> > > >
>> > > > Cool.
>> > > >
>> > > > Only thing that is kind of sad is having to include n! (of m-of-n)
>> > > > signatures in every PSBT... but tbh, the PSBT size is not of much
>> > > > concern.
>> > > >
>> > > > Thanks for the reply.
>> > > > - Jonathan
>> > > >
>> > > >
>> > > > 2019?6?27?(?) 13:49 Dmitry Petukhov <dp at simplexum.com>:
>> > > >
>> > > > > Hi!
>> > > > >
>> > > > > I wonder how your scheme handles multisig ?
>> > > > >
>> > > > > As I understand, you sign individual xpubs with cold keys, so
>> > > > > that cold keys can check destination addresses are trusted.
>> > > > >
>> > > > > I seems to me that if you sign individual xpubs of a multisig
>> > > > > warm wallet, and one key from that multisig is compromized,
>> > > > > attackers can then create a single-sig destination address that
>> > > > > they control, and move the coins in a chain of two
>> > > > > transactions, first to this single-sig address, and then to an
>> > > > > address that they independently control.
>> > > > >
>> > > > > My idea to prevent this [1] is to sign the whole 'xpub package'
>> > > > > of the multisig wallet, but there is also an issue of 'partial
>> > > > > compromize', where some of the keys in a multisig warm wallet is
>> > > > > compromized, and you do not want to regard a particular 'xpub
>> > > > > package' as trusted. My idea was [2] to use an auxiliary message
>> > > > > that would be signed along with the 'xpub package', and that
>> > > > > message can include specific 'epoch' word that hardware wallet
>> > > > > can show prominently before signing, or have 'serial number'
>> > > > > for xpub packages (but that will require to store last known
>> > > > > serial inside hw wallet, making it stateful).
>> > > > >
>> > > > > I like the idea to extend PSBT to accomodate these schemes, but
>> > > > > given that the huge number of possible schemes that each may
>> > > > > probably require its own PSBT field type, I think that this is
>> > > > > better dealt with outside of PSBT, as 'PSBT metainformation', or
>> > > > > using some form of 'vendor-specific', or
>> > > > > 'metainformation-specific' PSBT field. This way each usecase
>> > > > > can be independently described in its own documentation, that
>> > > > > would include the particulars of the format for the
>> > > > > metainformation. This would also make it easier to implement
>> > > > > PSBT for simple cases, because the 'core specification' would
>> > > > > not grow that big.
>> > > > >
>> > > > > [1]
>> > > > >
>> > > > >
>> > >
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016917.html
>>
>> > > > >
>> > > > > [2]
>> > > > >
>> > > > >
>> > >
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016926.html
>>
>> > > > >
>> > > > >
>> > > > > ? Thu, 27 Jun 2019 11:11:23 +0900 Jonathan Underwood via
>> > > > > bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> > > > >
>> > > > > > Hello all,
>> > > > > >
>> > > > > > Just wanted to pick your brains about an idea for PSBT
>> > > > > > extension.
>> > > > > >
>> > > > > > One problem we try to solve with cold -> warm and warm -> hot
>> > > > > > sends for our exchange wallet is "How do I know that the
>> > > > > > address I am sending to is not a hacker's address that was
>> > > > > > swapped in between unsigned tx creation and first signature?"
>> > > > > >
>> > > > > > We have a proprietary JSON based encoding system which we are
>> > > > > > looking to move towards PSBT, but PSBT is missing this key
>> > > > > > functionality.
>> > > > > >
>> > > > > > BIP32_DERIVATION does allow us to verify the address is from a
>> > > > > > certain XPUB, but, for example, it can not allow us to verify
>> > > > > > a signature of that xpub.
>> > > > > >
>> > > > > > I have made a rough draft of the proposed key value
>> > > > > > specification.
>> > > > >
>> > >
>> https://github.com/junderw/bips/blob/addXpubSig/bip-0174.mediawiki#specification
>> > >
>> > > > > >
>> > > > > > The signing key path used in the spec is just randomly chosen
>> > > > > > 31 x 4 bits shown as numbers with hardened paths.
>> > > > > >
>> > > > > > Since this issue seems similar to the change address issue, I
>> > > > > > started from that as a base. With the HW wallet case, I can
>> > > > > > verify the xpub by just deriving it locally and comparing
>> > > > > > equality, however, in our case, we need to verify an xpub
>> > > > > > that we do not have access to via derivation from our cold
>> > > > > > key(s) (since we don't want to import our warm private key
>> > > > > > into our cold signer)
>> > > > > >
>> > > > > > So the flow would be:
>> > > > > > 1. Securely verify the xpub of the warm / hot wallet.
>> > > > > > 2. Using the airgap signing tool, sign the xpub with all cold
>> > > > > > keys. 3. Upload the signature/xpub pairs to the online
>> > > > > > unsigned transaction generator.
>> > > > > > 4. Include one keyval pair per coldkey/xpub pairing.
>> > > > > > 5. When offline signing, if the wallet detects there is a
>> > > > > > global keyval XPUB_SIGNATURE with its pubkey in the key, it
>> > > > > > must verify that all outputs have BIP32_DERIVATION and that
>> > > > > > it can verify the outputs through the derivation, to the
>> > > > > > xpub, and to the signature.
>> > > > > >
>> > > > > > In my attempt to fitting this into PSBT, I am slightly
>> > > > > > altering our current system, so don't take this as an
>> > > > > > indication 100% of how we work in the backend.
>> > > > > >
>> > > > > > However, I would like to hear any feedback on this proposal.
>> > > > > >
>> > > > > > Thanks,
>> > > > > > Jonathan
>> > > > > >
>> > > > >
>> > > > >
>> > > >
>> > >
>> > >
>> >
>>
>>
>
> --
> -----------------
> Jonathan Underwood
> ??????? ??????????????
> -----------------
>
> ???????????????????????????????
>
> ??: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3
>


-- 
-----------------
Jonathan Underwood
??????? ??????????????
-----------------

???????????????????????????????

??: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190627/c0a55da6/attachment-0001.html>

From junderwood at bitcoinbank.co.jp  Thu Jun 27 09:32:46 2019
From: junderwood at bitcoinbank.co.jp (Jonathan Underwood)
Date: Thu, 27 Jun 2019 18:32:46 +0900
Subject: [bitcoin-dev] BIP174 extension proposal (Global Type:
	PSBT_GLOBAL_XPUB_SIGNATURE)
In-Reply-To: <20190627142120.2c24fddb@simplexum.com>
References: <CAMpN3mLvY+kuUGqzMW6SAMZ=h46_g=XLhDPhSY=X6xhLxvi15Q@mail.gmail.com>
	<20190627095031.4d5817b8@simplexum.com>
	<CAMpN3mKPkCPtYkN-JVku1r217-aBK=Rh3UEhvRPS_Y6DixJ9Dw@mail.gmail.com>
	<20190627122916.3b6c2c32@simplexum.com>
	<CAMpN3mL8tyP-6-nwn6dorcq7-dad6wYz8_pXinqHhgzUnrr_tg@mail.gmail.com>
	<20190627134628.4d131264@simplexum.com>
	<CAMpN3m+LiSW=kRCQio+C_2To66o_SEq-d_0Z122j+BUxvh=LDQ@mail.gmail.com>
	<20190627142120.2c24fddb@simplexum.com>
Message-ID: <CAMpN3m+0HJm+zZ81ZNP-BXpX_39BvHzwKRAPwpdHinJ13gdNeA@mail.gmail.com>

There is no need, as you can look at the number of xpubs and use that as n.

Your wallet will not allow {m=2}{xpub1}{xpub2} signed message to vouch for
2 of 4 because you signed 2 of 2 where the n is shown by the number of
xpubs signed.

There is no need to add the extra byte, except maybe to help people who are
implementing a wallet checking some features to remember to check for the
number of total keys.

----

The expire / revoke problem is a larger problem than this feature can
handle.

In general, if one of the cold keys is stolen, there is rarely a situation
where you are completely sure the other cold keys haven't been
compromised... so the best practice would be all signers generate new keys
and all funds are moved to a completely new multisig wallet (no common
xpubs).

- Jonathan

2019?6?27?(?) 18:20 Dmitry Petukhov <dp at simplexum.com>:

> You're right re order of the keys, I forgot that redeem/witness
> scripts are included in outputs.
>
> But regarding the number of the keys, you need to always include all of
> xpubs, because otherwise, if you only put `m` in PSBT, and you use
> 2of3, for example, attacker may put 2 as `m`, two of your xpubs, but
> then use redeem/witness scripts for 2of4, where two other keys are
> under attacker's control.
>
> If you only encode `n`, and allow any 'm of n' scheme, then in 2of3
> case, if the attackers have control of only one of the keys, they can
> use redeem/witness scripts for 1of3, where two other keys are under
> their control.
>
> It seems to me that you need to sign the whole configuration:
> `n`, `m`, and the xpubs.
>
> And then there's a question of how to conveniently `expire` the keys
> that were compromized. If the attackers have a signature of
> `n+n+xpubs` package for some configuration that include the keys that
> was compromized, they can use that old signed package to fool the
> signer.
>
> Signer would need to somehow distinguish between old and new
> configurations, or you would need to change the keys in all the signers
> even if one is compromized, so the already-signed packages would become
> invalid.
>
> You could do without changing all the keys when only one is compromized
> by including a serial number in the xpub package (but that means signer
> will need to have a state where it would store the latest serial
> number), or you need some message to be included in the package that a
> human can check when manually signing, to ensure that 'obsolete' xpub
> package was not used.
>
> ? Thu, 27 Jun 2019 17:56:06 +0900
> Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:
>
> > The output will have redeemscript and witnessscript so order is not
> > necessary. I can just look at the multisig script and find the pubkey
> > inside it.
> >
> > -Jonathan
> >
> > 2019?6?27?(?) 17:45 Dmitry Petukhov <dp at simplexum.com>:
> >
> > > > m value for a multisig (set 0 for non-multisig), followed by 1 or
> > > > more 78 byte serialized extended public keys sorted in canonical
> > > > order
> > >
> > > Sorting xpubs would work if the addresses also sort their pubkeys
> > > (like in BIP67)
> > >
> > > But if the pubkey order in address creation is fixed, you better
> > > have the fixed order for xpubs, otherwise you would need to try all
> > > combinations of derived pubkeys when checking if the addresss match
> > > the presented xpubs. That would be factorial of the number of keys,
> > > not feasible beyond very small number of keys.
> > >
> > > Bitcoin Core, for example, currently does not support BIP67 and
> > > supports only fixed pubkey positions in their script descriptors
> > > specification.
> > >
> > > You also need to include all xpubs to match the address, for m of n
> > > standard multisig, you need to include n and check that number of
> > > keys is exactly n.
> > >
> > > Otherwise your would not be able to construct the address to
> > > compare to the destination address that you need to check, as you
> > > need all pubkesy to construct P2SH or P2WSH address.
> > >
> > > With Shnorr-musig, you probably can interpolate the combined pubkey
> > > out of m paticpant pubkeys (but don't cite me on this, I might be
> > > wrong)
> > >
> > > ? Thu, 27 Jun 2019 17:16:14 +0900
> > > Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:
> > >
> > > > I see what you mean.
> > > >
> > > > What about this?
> > > >
> > >
> https://github.com/junderw/bips/commit/57a57b4fae1ae14b77a2eebd99cd719148e3027e?short_path=82656c8#diff-82656c833e31e6751a412ce5e5c70920
>
> > > >
> > > > Plus side: for single sig case, the key only increases by one byte
> > > > (0x00 for the {m} value)
> > > >
> > > > This way if it was 2 of 3 like before, you sign the whole
> > > > "packet" so each key only signs the packet once. Way better than
> > > > n!
> > > >
> > > > Anywho. Please send your feedback. Thanks.
> > > > Jonathan
> > > >
> > > > 2019?6?27?(?) 16:27 Dmitry Petukhov <dp at simplexum.com>:
> > > >
> > > > > How would signer know that there _should_ be at least 3
> > > > > signatures signed by the key owned by this signer ?
> > > > >
> > > > > If it does not know that it should enforce 2of3 multisig, for
> > > > > example, the attacker that control only one key A can fool
> > > > > signer B by sending to 1of1 single-sig that is derived from A's
> > > > > xpub, and providing only sBxA in PSBT.
> > > > >
> > > > > If the signer does not have a hardcoded configuration that
> > > > > will mandate a particular multisig scheme, it will allow
> > > > > sending to any scheme.
> > > > >
> > > > > If the signer has a rich enough state to store updatable
> > > > > configuration, it can just store the trusted xpubs directly.
> > > > >
> > > > > Alternatively, signer can sign not individual xpubs, but whole
> > > > > xpub packages that correspond to particular multisig
> > > > > configuration, and enforce that destination addresses
> > > > > correspond to this configuration.
> > > > >
> > > > > But this would not be possible with your PSBT scheme that uses
> > > > > individual key-xpub pairs.
> > > > >
> > > > > ? Thu, 27 Jun 2019 14:07:47 +0900
> > > > > Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:
> > > > >
> > > > > > Thanks for the reply.
> > > > > >
> > > > > > The way we would do it is:
> > > > > >
> > > > > > Let's say we have 3 cold keys for multisig: A B and C
> > > > > >
> > > > > > Whose xpubs are: xA xB and xC
> > > > > >
> > > > > > We all sign each other's xpubs, whose signatures are:
> > > > > > sAxB
> > > > > > sAxC
> > > > > > sBxA
> > > > > > sBxC
> > > > > > sCxA
> > > > > > sCxB
> > > > > >
> > > > > > We can then create a wallet that says "when verifying change
> > > > > > with 0x01 global type proposed by Andrew Chow, if the change
> > > > > > is multisig, we MUST require the other pubkeys to have
> > > > > > signatures via my 0x02 proposal"
> > > > > >
> > > > > > This way, all my PSBTs for my cold will have:
> > > > > > 1. an 0x01 entry to tell me how to get my change.
> > > > > > 2. All 6 of the signatures above.
> > > > > >
> > > > > > And the signer will then look at the change, check my pubkey
> > > > > > by deriving the xpub and checking equality to the
> > > > > > BIP_DERIVATION of the output... it will then check the OTHER
> > > > > > pubkeys via BIP32_DERIVATION to master fingerprint, then link
> > > > > > that fingerprint to a 0x02 sig from MY key, verifying all
> > > > > > pubkeys.
> > > > > >
> > > > > > So this proposal of mine would not only fix the "send to
> > > > > > address verification" problem for HD, but also the multisig
> > > > > > change problem with 0x01.
> > > > > >
> > > > > > Cool.
> > > > > >
> > > > > > Only thing that is kind of sad is having to include n! (of
> > > > > > m-of-n) signatures in every PSBT... but tbh, the PSBT size is
> > > > > > not of much concern.
> > > > > >
> > > > > > Thanks for the reply.
> > > > > > - Jonathan
> > > > > >
> > > > > >
> > > > > > 2019?6?27?(?) 13:49 Dmitry Petukhov <dp at simplexum.com>:
> > > > > >
> > > > > > > Hi!
> > > > > > >
> > > > > > > I wonder how your scheme handles multisig ?
> > > > > > >
> > > > > > > As I understand, you sign individual xpubs with cold keys,
> > > > > > > so that cold keys can check destination addresses are
> > > > > > > trusted.
> > > > > > >
> > > > > > > I seems to me that if you sign individual xpubs of a
> > > > > > > multisig warm wallet, and one key from that multisig is
> > > > > > > compromized, attackers can then create a single-sig
> > > > > > > destination address that they control, and move the coins
> > > > > > > in a chain of two transactions, first to this single-sig
> > > > > > > address, and then to an address that they independently
> > > > > > > control.
> > > > > > >
> > > > > > > My idea to prevent this [1] is to sign the whole 'xpub
> > > > > > > package' of the multisig wallet, but there is also an issue
> > > > > > > of 'partial compromize', where some of the keys in a
> > > > > > > multisig warm wallet is compromized, and you do not want to
> > > > > > > regard a particular 'xpub package' as trusted. My idea was
> > > > > > > [2] to use an auxiliary message that would be signed along
> > > > > > > with the 'xpub package', and that message can include
> > > > > > > specific 'epoch' word that hardware wallet can show
> > > > > > > prominently before signing, or have 'serial number' for
> > > > > > > xpub packages (but that will require to store last known
> > > > > > > serial inside hw wallet, making it stateful).
> > > > > > >
> > > > > > > I like the idea to extend PSBT to accomodate these schemes,
> > > > > > > but given that the huge number of possible schemes that
> > > > > > > each may probably require its own PSBT field type, I think
> > > > > > > that this is better dealt with outside of PSBT, as 'PSBT
> > > > > > > metainformation', or using some form of 'vendor-specific',
> > > > > > > or 'metainformation-specific' PSBT field. This way each
> > > > > > > usecase can be independently described in its own
> > > > > > > documentation, that would include the particulars of the
> > > > > > > format for the metainformation. This would also make it
> > > > > > > easier to implement PSBT for simple cases, because the
> > > > > > > 'core specification' would not grow that big.
> > > > > > >
> > > > > > > [1]
> > > > > > >
> > > > > > >
> > > > >
> > >
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016917.html
> > >
> > > > > > >
> > > > > > > [2]
> > > > > > >
> > > > > > >
> > > > >
> > >
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016926.html
> > >
> > > > > > >
> > > > > > >
> > > > > > > ? Thu, 27 Jun 2019 11:11:23 +0900 Jonathan Underwood via
> > > > > > > bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > > > > > >
> > > > > > > > Hello all,
> > > > > > > >
> > > > > > > > Just wanted to pick your brains about an idea for PSBT
> > > > > > > > extension.
> > > > > > > >
> > > > > > > > One problem we try to solve with cold -> warm and warm ->
> > > > > > > > hot sends for our exchange wallet is "How do I know that
> > > > > > > > the address I am sending to is not a hacker's address
> > > > > > > > that was swapped in between unsigned tx creation and
> > > > > > > > first signature?"
> > > > > > > >
> > > > > > > > We have a proprietary JSON based encoding system which we
> > > > > > > > are looking to move towards PSBT, but PSBT is missing
> > > > > > > > this key functionality.
> > > > > > > >
> > > > > > > > BIP32_DERIVATION does allow us to verify the address is
> > > > > > > > from a certain XPUB, but, for example, it can not allow
> > > > > > > > us to verify a signature of that xpub.
> > > > > > > >
> > > > > > > > I have made a rough draft of the proposed key value
> > > > > > > > specification.
> > > > > > >
> > > > >
> > >
> https://github.com/junderw/bips/blob/addXpubSig/bip-0174.mediawiki#specification
>
> > > > >
> > > > > > > >
> > > > > > > > The signing key path used in the spec is just randomly
> > > > > > > > chosen 31 x 4 bits shown as numbers with hardened paths.
> > > > > > > >
> > > > > > > > Since this issue seems similar to the change address
> > > > > > > > issue, I started from that as a base. With the HW wallet
> > > > > > > > case, I can verify the xpub by just deriving it locally
> > > > > > > > and comparing equality, however, in our case, we need to
> > > > > > > > verify an xpub that we do not have access to via
> > > > > > > > derivation from our cold key(s) (since we don't want to
> > > > > > > > import our warm private key into our cold signer)
> > > > > > > >
> > > > > > > > So the flow would be:
> > > > > > > > 1. Securely verify the xpub of the warm / hot wallet.
> > > > > > > > 2. Using the airgap signing tool, sign the xpub with all
> > > > > > > > cold keys. 3. Upload the signature/xpub pairs to the
> > > > > > > > online unsigned transaction generator.
> > > > > > > > 4. Include one keyval pair per coldkey/xpub pairing.
> > > > > > > > 5. When offline signing, if the wallet detects there is a
> > > > > > > > global keyval XPUB_SIGNATURE with its pubkey in the key,
> > > > > > > > it must verify that all outputs have BIP32_DERIVATION and
> > > > > > > > that it can verify the outputs through the derivation, to
> > > > > > > > the xpub, and to the signature.
> > > > > > > >
> > > > > > > > In my attempt to fitting this into PSBT, I am slightly
> > > > > > > > altering our current system, so don't take this as an
> > > > > > > > indication 100% of how we work in the backend.
> > > > > > > >
> > > > > > > > However, I would like to hear any feedback on this
> > > > > > > > proposal.
> > > > > > > >
> > > > > > > > Thanks,
> > > > > > > > Jonathan
> > > > > > > >
> > > > > > >
> > > > > > >
> > > > > >
> > > > >
> > > > >
> > > >
> > >
> > >
> >
>
>

-- 
-----------------
Jonathan Underwood
??????? ??????????????
-----------------

???????????????????????????????

??: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190627/6e5ce627/attachment-0001.html>

From junderwood at bitcoinbank.co.jp  Thu Jun 27 09:52:28 2019
From: junderwood at bitcoinbank.co.jp (Jonathan Underwood)
Date: Thu, 27 Jun 2019 18:52:28 +0900
Subject: [bitcoin-dev] BIP174 extension proposal (Global Type:
	PSBT_GLOBAL_XPUB_SIGNATURE)
In-Reply-To: <20190627144852.52c6d9e1@simplexum.com>
References: <CAMpN3mLvY+kuUGqzMW6SAMZ=h46_g=XLhDPhSY=X6xhLxvi15Q@mail.gmail.com>
	<20190627095031.4d5817b8@simplexum.com>
	<CAMpN3mKPkCPtYkN-JVku1r217-aBK=Rh3UEhvRPS_Y6DixJ9Dw@mail.gmail.com>
	<20190627122916.3b6c2c32@simplexum.com>
	<CAMpN3mL8tyP-6-nwn6dorcq7-dad6wYz8_pXinqHhgzUnrr_tg@mail.gmail.com>
	<20190627144852.52c6d9e1@simplexum.com>
Message-ID: <CAMpN3mLffLPFvuuLtd1=UuDSwStuk7g9WvLCrXe8SRDdc6fUHg@mail.gmail.com>

> By the way, why is this particular path ?

The signing key path used in the spec is just randomly chosen 31 x 4 bits
shown as numbers with hardened paths. Just wanted to make sure it wasn't a
key that people are likely to use for something else.

> It is not clear to me what public key this refers to

I just used the same sentence from the other proposal for 0x01 global tag.
It is kind of confusing, but "can be derived" implies that it is referring
to an xpub, since normal public keys can not "derive children"...

But I could change it if it would be clearer.

2019?6?27?(?) 18:47 Dmitry Petukhov <dp at simplexum.com>:

> " It should be the public key at the highest hardened derivation index
> so that the unhardened child keys used in the transaction can be
> derived."
>
> It is not clear to me what public key this refers to - does this
> refer to 'signing pubkey' ? - then the exact derivation indexes for that
> are given in the value section:
>
>    m/2042083607'/959190427'/1400854130'/990526201'
>
> By the way, why is this particular path ?
>
> ? Thu, 27 Jun 2019 17:16:14 +0900
> Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:
>
> > I see what you mean.
> >
> > What about this?
> >
> https://github.com/junderw/bips/commit/57a57b4fae1ae14b77a2eebd99cd719148e3027e?short_path=82656c8#diff-82656c833e31e6751a412ce5e5c70920
> >
> > Plus side: for single sig case, the key only increases by one byte
> > (0x00 for the {m} value)
> >
> > This way if it was 2 of 3 like before, you sign the whole "packet" so
> > each key only signs the packet once. Way better than n!
> >
> > Anywho. Please send your feedback. Thanks.
> > Jonathan
> >
> > 2019?6?27?(?) 16:27 Dmitry Petukhov <dp at simplexum.com>:
> >
> > > How would signer know that there _should_ be at least 3 signatures
> > > signed by the key owned by this signer ?
> > >
> > > If it does not know that it should enforce 2of3 multisig, for
> > > example, the attacker that control only one key A can fool signer B
> > > by sending to 1of1 single-sig that is derived from A's xpub, and
> > > providing only sBxA in PSBT.
> > >
> > > If the signer does not have a hardcoded configuration that
> > > will mandate a particular multisig scheme, it will allow sending to
> > > any scheme.
> > >
> > > If the signer has a rich enough state to store updatable
> > > configuration, it can just store the trusted xpubs directly.
> > >
> > > Alternatively, signer can sign not individual xpubs, but whole xpub
> > > packages that correspond to particular multisig configuration, and
> > > enforce that destination addresses correspond to this configuration.
> > >
> > > But this would not be possible with your PSBT scheme that uses
> > > individual key-xpub pairs.
> > >
> > > ? Thu, 27 Jun 2019 14:07:47 +0900
> > > Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:
> > >
> > > > Thanks for the reply.
> > > >
> > > > The way we would do it is:
> > > >
> > > > Let's say we have 3 cold keys for multisig: A B and C
> > > >
> > > > Whose xpubs are: xA xB and xC
> > > >
> > > > We all sign each other's xpubs, whose signatures are:
> > > > sAxB
> > > > sAxC
> > > > sBxA
> > > > sBxC
> > > > sCxA
> > > > sCxB
> > > >
> > > > We can then create a wallet that says "when verifying change with
> > > > 0x01 global type proposed by Andrew Chow, if the change is
> > > > multisig, we MUST require the other pubkeys to have signatures
> > > > via my 0x02 proposal"
> > > >
> > > > This way, all my PSBTs for my cold will have:
> > > > 1. an 0x01 entry to tell me how to get my change.
> > > > 2. All 6 of the signatures above.
> > > >
> > > > And the signer will then look at the change, check my pubkey by
> > > > deriving the xpub and checking equality to the BIP_DERIVATION of
> > > > the output... it will then check the OTHER pubkeys via
> > > > BIP32_DERIVATION to master fingerprint, then link that
> > > > fingerprint to a 0x02 sig from MY key, verifying all pubkeys.
> > > >
> > > > So this proposal of mine would not only fix the "send to address
> > > > verification" problem for HD, but also the multisig change problem
> > > > with 0x01.
> > > >
> > > > Cool.
> > > >
> > > > Only thing that is kind of sad is having to include n! (of m-of-n)
> > > > signatures in every PSBT... but tbh, the PSBT size is not of much
> > > > concern.
> > > >
> > > > Thanks for the reply.
> > > > - Jonathan
> > > >
> > > >
> > > > 2019?6?27?(?) 13:49 Dmitry Petukhov <dp at simplexum.com>:
> > > >
> > > > > Hi!
> > > > >
> > > > > I wonder how your scheme handles multisig ?
> > > > >
> > > > > As I understand, you sign individual xpubs with cold keys, so
> > > > > that cold keys can check destination addresses are trusted.
> > > > >
> > > > > I seems to me that if you sign individual xpubs of a multisig
> > > > > warm wallet, and one key from that multisig is compromized,
> > > > > attackers can then create a single-sig destination address that
> > > > > they control, and move the coins in a chain of two
> > > > > transactions, first to this single-sig address, and then to an
> > > > > address that they independently control.
> > > > >
> > > > > My idea to prevent this [1] is to sign the whole 'xpub package'
> > > > > of the multisig wallet, but there is also an issue of 'partial
> > > > > compromize', where some of the keys in a multisig warm wallet is
> > > > > compromized, and you do not want to regard a particular 'xpub
> > > > > package' as trusted. My idea was [2] to use an auxiliary message
> > > > > that would be signed along with the 'xpub package', and that
> > > > > message can include specific 'epoch' word that hardware wallet
> > > > > can show prominently before signing, or have 'serial number'
> > > > > for xpub packages (but that will require to store last known
> > > > > serial inside hw wallet, making it stateful).
> > > > >
> > > > > I like the idea to extend PSBT to accomodate these schemes, but
> > > > > given that the huge number of possible schemes that each may
> > > > > probably require its own PSBT field type, I think that this is
> > > > > better dealt with outside of PSBT, as 'PSBT metainformation', or
> > > > > using some form of 'vendor-specific', or
> > > > > 'metainformation-specific' PSBT field. This way each usecase
> > > > > can be independently described in its own documentation, that
> > > > > would include the particulars of the format for the
> > > > > metainformation. This would also make it easier to implement
> > > > > PSBT for simple cases, because the 'core specification' would
> > > > > not grow that big.
> > > > >
> > > > > [1]
> > > > >
> > > > >
> > >
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016917.html
>
> > > > >
> > > > > [2]
> > > > >
> > > > >
> > >
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016926.html
>
> > > > >
> > > > >
> > > > > ? Thu, 27 Jun 2019 11:11:23 +0900 Jonathan Underwood via
> > > > > bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > > > >
> > > > > > Hello all,
> > > > > >
> > > > > > Just wanted to pick your brains about an idea for PSBT
> > > > > > extension.
> > > > > >
> > > > > > One problem we try to solve with cold -> warm and warm -> hot
> > > > > > sends for our exchange wallet is "How do I know that the
> > > > > > address I am sending to is not a hacker's address that was
> > > > > > swapped in between unsigned tx creation and first signature?"
> > > > > >
> > > > > > We have a proprietary JSON based encoding system which we are
> > > > > > looking to move towards PSBT, but PSBT is missing this key
> > > > > > functionality.
> > > > > >
> > > > > > BIP32_DERIVATION does allow us to verify the address is from a
> > > > > > certain XPUB, but, for example, it can not allow us to verify
> > > > > > a signature of that xpub.
> > > > > >
> > > > > > I have made a rough draft of the proposed key value
> > > > > > specification.
> > > > >
> > >
> https://github.com/junderw/bips/blob/addXpubSig/bip-0174.mediawiki#specification
> > >
> > > > > >
> > > > > > The signing key path used in the spec is just randomly chosen
> > > > > > 31 x 4 bits shown as numbers with hardened paths.
> > > > > >
> > > > > > Since this issue seems similar to the change address issue, I
> > > > > > started from that as a base. With the HW wallet case, I can
> > > > > > verify the xpub by just deriving it locally and comparing
> > > > > > equality, however, in our case, we need to verify an xpub
> > > > > > that we do not have access to via derivation from our cold
> > > > > > key(s) (since we don't want to import our warm private key
> > > > > > into our cold signer)
> > > > > >
> > > > > > So the flow would be:
> > > > > > 1. Securely verify the xpub of the warm / hot wallet.
> > > > > > 2. Using the airgap signing tool, sign the xpub with all cold
> > > > > > keys. 3. Upload the signature/xpub pairs to the online
> > > > > > unsigned transaction generator.
> > > > > > 4. Include one keyval pair per coldkey/xpub pairing.
> > > > > > 5. When offline signing, if the wallet detects there is a
> > > > > > global keyval XPUB_SIGNATURE with its pubkey in the key, it
> > > > > > must verify that all outputs have BIP32_DERIVATION and that
> > > > > > it can verify the outputs through the derivation, to the
> > > > > > xpub, and to the signature.
> > > > > >
> > > > > > In my attempt to fitting this into PSBT, I am slightly
> > > > > > altering our current system, so don't take this as an
> > > > > > indication 100% of how we work in the backend.
> > > > > >
> > > > > > However, I would like to hear any feedback on this proposal.
> > > > > >
> > > > > > Thanks,
> > > > > > Jonathan
> > > > > >
> > > > >
> > > > >
> > > >
> > >
> > >
> >
>
>

-- 
-----------------
Jonathan Underwood
??????? ??????????????
-----------------

???????????????????????????????

??: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190627/e247bc0d/attachment.html>

From peter at coinkite.com  Thu Jun 27 15:07:45 2019
From: peter at coinkite.com (Peter D. Gray)
Date: Thu, 27 Jun 2019 11:07:45 -0400
Subject: [bitcoin-dev] BIP174 extension proposal (Global Type:
 PSBT_GLOBAL_XPUB_SIGNATURE)
In-Reply-To: <CAMpN3m+0HJm+zZ81ZNP-BXpX_39BvHzwKRAPwpdHinJ13gdNeA@mail.gmail.com>
References: <CAMpN3mLvY+kuUGqzMW6SAMZ=h46_g=XLhDPhSY=X6xhLxvi15Q@mail.gmail.com>
	<20190627095031.4d5817b8@simplexum.com>
	<CAMpN3mKPkCPtYkN-JVku1r217-aBK=Rh3UEhvRPS_Y6DixJ9Dw@mail.gmail.com>
	<20190627122916.3b6c2c32@simplexum.com>
	<CAMpN3mL8tyP-6-nwn6dorcq7-dad6wYz8_pXinqHhgzUnrr_tg@mail.gmail.com>
	<20190627134628.4d131264@simplexum.com>
	<CAMpN3m+LiSW=kRCQio+C_2To66o_SEq-d_0Z122j+BUxvh=LDQ@mail.gmail.com>
	<20190627142120.2c24fddb@simplexum.com>
	<CAMpN3m+0HJm+zZ81ZNP-BXpX_39BvHzwKRAPwpdHinJ13gdNeA@mail.gmail.com>
Message-ID: <20190627150745.GA1897@coinkite.com>

I haven't studied the new proposal in depth, but my first impression is:

Wouldn't it just be easier and better to just sign the entire "outputs" section of the PSBT?

The signature would cover every byte, and therefore would cover any
future BIP additions to the outputs area, and also help non-multisig
cases today.

---
Peter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG: A3A31BAD 5A2A5B10


From dp at simplexum.com  Thu Jun 27 15:29:32 2019
From: dp at simplexum.com (Dmitry Petukhov)
Date: Thu, 27 Jun 2019 20:29:32 +0500
Subject: [bitcoin-dev] BIP174 extension proposal (Global Type:
 PSBT_GLOBAL_XPUB_SIGNATURE)
In-Reply-To: <20190627181429.15dda570@simplexum.com>
References: <CAMpN3mLvY+kuUGqzMW6SAMZ=h46_g=XLhDPhSY=X6xhLxvi15Q@mail.gmail.com>
	<20190627095031.4d5817b8@simplexum.com>
	<CAMpN3mKPkCPtYkN-JVku1r217-aBK=Rh3UEhvRPS_Y6DixJ9Dw@mail.gmail.com>
	<20190627122916.3b6c2c32@simplexum.com>
	<CAMpN3mL8tyP-6-nwn6dorcq7-dad6wYz8_pXinqHhgzUnrr_tg@mail.gmail.com>
	<20190627181429.15dda570@simplexum.com>
Message-ID: <20190627202932.1cb4d727@simplexum.com>

Oh, I saw that you covered it in another mail:

> The expire / revoke problem is a larger problem than this feature can
> handle.

> In general, if one of the cold keys is stolen, there is rarely a
> situation where you are completely sure the other cold keys haven't
> been compromised... so the best practice would be all signers
> generate new keys and all funds are moved to a completely new
> multisig wallet (no common xpubs).

The setup might not be 'all cold keys', but the keys with different
levels of exposure to possible theft. In this config, compromise of one
of the 'warm' keys might not necessary require changing the 'cold' key.

I'm not sure whether this usecase warrants adding extra 'serial'
field, but on the other hand it is rather simple change, and those who
does not care can always set 0. 

? Thu, 27 Jun 2019 18:14:29 +0500
Dmitry Petukhov <dp at simplexum.com> wrote:

> What do you think about adding serial number to the xpub package ?
> 
> The key would be 
> 
> {0x02}|{signing_pubkey}|{serial}|{m}|{xpub}|...|{xpub}
> 
> and if the signer have the ability to store a counter, it can reject
> 'outdated' xpub packages, and only accept those that was signed using
> the serial number that it deems recent. This would allow a limited
> mechanism to 'revoke' previously signed packages that have compromized
> keys in them.
> 
> ? Thu, 27 Jun 2019 17:16:14 +0900
> Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:
> 
> > I see what you mean.
> > 
> > What about this?
> > https://github.com/junderw/bips/commit/57a57b4fae1ae14b77a2eebd99cd719148e3027e?short_path=82656c8#diff-82656c833e31e6751a412ce5e5c70920
> > 
> > Plus side: for single sig case, the key only increases by one byte
> > (0x00 for the {m} value)
> > 
> > This way if it was 2 of 3 like before, you sign the whole "packet"
> > so each key only signs the packet once. Way better than n!
> > 
> > Anywho. Please send your feedback. Thanks.
> > Jonathan
> > 
> > 2019?6?27?(?) 16:27 Dmitry Petukhov <dp at simplexum.com>:
> >   
> > > How would signer know that there _should_ be at least 3 signatures
> > > signed by the key owned by this signer ?
> > >
> > > If it does not know that it should enforce 2of3 multisig, for
> > > example, the attacker that control only one key A can fool signer
> > > B by sending to 1of1 single-sig that is derived from A's xpub, and
> > > providing only sBxA in PSBT.
> > >
> > > If the signer does not have a hardcoded configuration that
> > > will mandate a particular multisig scheme, it will allow sending
> > > to any scheme.
> > >
> > > If the signer has a rich enough state to store updatable
> > > configuration, it can just store the trusted xpubs directly.
> > >
> > > Alternatively, signer can sign not individual xpubs, but whole
> > > xpub packages that correspond to particular multisig
> > > configuration, and enforce that destination addresses correspond
> > > to this configuration.
> > >
> > > But this would not be possible with your PSBT scheme that uses
> > > individual key-xpub pairs.
> > >
> > > ? Thu, 27 Jun 2019 14:07:47 +0900
> > > Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:
> > >    
> > > > Thanks for the reply.
> > > >
> > > > The way we would do it is:
> > > >
> > > > Let's say we have 3 cold keys for multisig: A B and C
> > > >
> > > > Whose xpubs are: xA xB and xC
> > > >
> > > > We all sign each other's xpubs, whose signatures are:
> > > > sAxB
> > > > sAxC
> > > > sBxA
> > > > sBxC
> > > > sCxA
> > > > sCxB
> > > >
> > > > We can then create a wallet that says "when verifying change
> > > > with 0x01 global type proposed by Andrew Chow, if the change is
> > > > multisig, we MUST require the other pubkeys to have signatures
> > > > via my 0x02 proposal"
> > > >
> > > > This way, all my PSBTs for my cold will have:
> > > > 1. an 0x01 entry to tell me how to get my change.
> > > > 2. All 6 of the signatures above.
> > > >
> > > > And the signer will then look at the change, check my pubkey by
> > > > deriving the xpub and checking equality to the BIP_DERIVATION of
> > > > the output... it will then check the OTHER pubkeys via
> > > > BIP32_DERIVATION to master fingerprint, then link that
> > > > fingerprint to a 0x02 sig from MY key, verifying all pubkeys.
> > > >
> > > > So this proposal of mine would not only fix the "send to address
> > > > verification" problem for HD, but also the multisig change
> > > > problem with 0x01.
> > > >
> > > > Cool.
> > > >
> > > > Only thing that is kind of sad is having to include n! (of
> > > > m-of-n) signatures in every PSBT... but tbh, the PSBT size is
> > > > not of much concern.
> > > >
> > > > Thanks for the reply.
> > > > - Jonathan
> > > >
> > > >
> > > > 2019?6?27?(?) 13:49 Dmitry Petukhov <dp at simplexum.com>:
> > > >    
> > > > > Hi!
> > > > >
> > > > > I wonder how your scheme handles multisig ?
> > > > >
> > > > > As I understand, you sign individual xpubs with cold keys, so
> > > > > that cold keys can check destination addresses are trusted.
> > > > >
> > > > > I seems to me that if you sign individual xpubs of a multisig
> > > > > warm wallet, and one key from that multisig is compromized,
> > > > > attackers can then create a single-sig destination address
> > > > > that they control, and move the coins in a chain of two
> > > > > transactions, first to this single-sig address, and then to an
> > > > > address that they independently control.
> > > > >
> > > > > My idea to prevent this [1] is to sign the whole 'xpub
> > > > > package' of the multisig wallet, but there is also an issue
> > > > > of 'partial compromize', where some of the keys in a multisig
> > > > > warm wallet is compromized, and you do not want to regard a
> > > > > particular 'xpub package' as trusted. My idea was [2] to use
> > > > > an auxiliary message that would be signed along with the
> > > > > 'xpub package', and that message can include specific 'epoch'
> > > > > word that hardware wallet can show prominently before
> > > > > signing, or have 'serial number' for xpub packages (but that
> > > > > will require to store last known serial inside hw wallet,
> > > > > making it stateful).
> > > > >
> > > > > I like the idea to extend PSBT to accomodate these schemes,
> > > > > but given that the huge number of possible schemes that each
> > > > > may probably require its own PSBT field type, I think that
> > > > > this is better dealt with outside of PSBT, as 'PSBT
> > > > > metainformation', or using some form of 'vendor-specific', or
> > > > > 'metainformation-specific' PSBT field. This way each usecase
> > > > > can be independently described in its own documentation, that
> > > > > would include the particulars of the format for the
> > > > > metainformation. This would also make it easier to implement
> > > > > PSBT for simple cases, because the 'core specification' would
> > > > > not grow that big.
> > > > >
> > > > > [1]
> > > > >
> > > > >    
> > > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016917.html    
> > > > >
> > > > > [2]
> > > > >
> > > > >    
> > > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016926.html    
> > > > >
> > > > >
> > > > > ? Thu, 27 Jun 2019 11:11:23 +0900 Jonathan Underwood via
> > > > > bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > > > >    
> > > > > > Hello all,
> > > > > >
> > > > > > Just wanted to pick your brains about an idea for PSBT
> > > > > > extension.
> > > > > >
> > > > > > One problem we try to solve with cold -> warm and warm ->
> > > > > > hot sends for our exchange wallet is "How do I know that the
> > > > > > address I am sending to is not a hacker's address that was
> > > > > > swapped in between unsigned tx creation and first
> > > > > > signature?"
> > > > > >
> > > > > > We have a proprietary JSON based encoding system which we
> > > > > > are looking to move towards PSBT, but PSBT is missing this
> > > > > > key functionality.
> > > > > >
> > > > > > BIP32_DERIVATION does allow us to verify the address is
> > > > > > from a certain XPUB, but, for example, it can not allow us
> > > > > > to verify a signature of that xpub.
> > > > > >
> > > > > > I have made a rough draft of the proposed key value
> > > > > > specification.   
> > > > >    
> > > https://github.com/junderw/bips/blob/addXpubSig/bip-0174.mediawiki#specification
> > >    
> > > > > >
> > > > > > The signing key path used in the spec is just randomly
> > > > > > chosen 31 x 4 bits shown as numbers with hardened paths.
> > > > > >
> > > > > > Since this issue seems similar to the change address issue,
> > > > > > I started from that as a base. With the HW wallet case, I
> > > > > > can verify the xpub by just deriving it locally and
> > > > > > comparing equality, however, in our case, we need to verify
> > > > > > an xpub that we do not have access to via derivation from
> > > > > > our cold key(s) (since we don't want to import our warm
> > > > > > private key into our cold signer)
> > > > > >
> > > > > > So the flow would be:
> > > > > > 1. Securely verify the xpub of the warm / hot wallet.
> > > > > > 2. Using the airgap signing tool, sign the xpub with all
> > > > > > cold keys. 3. Upload the signature/xpub pairs to the online
> > > > > > unsigned transaction generator.
> > > > > > 4. Include one keyval pair per coldkey/xpub pairing.
> > > > > > 5. When offline signing, if the wallet detects there is a
> > > > > > global keyval XPUB_SIGNATURE with its pubkey in the key, it
> > > > > > must verify that all outputs have BIP32_DERIVATION and that
> > > > > > it can verify the outputs through the derivation, to the
> > > > > > xpub, and to the signature.
> > > > > >
> > > > > > In my attempt to fitting this into PSBT, I am slightly
> > > > > > altering our current system, so don't take this as an
> > > > > > indication 100% of how we work in the backend.
> > > > > >
> > > > > > However, I would like to hear any feedback on this proposal.
> > > > > >
> > > > > > Thanks,
> > > > > > Jonathan
> > > > > >    
> > > > >
> > > > >    
> > > >    
> > >
> > >    
> >   
> 


From junderwood at bitcoinbank.co.jp  Fri Jun 28 02:44:15 2019
From: junderwood at bitcoinbank.co.jp (Jonathan Underwood)
Date: Fri, 28 Jun 2019 11:44:15 +0900
Subject: [bitcoin-dev] BIP174 extension proposal (Global Type:
	PSBT_GLOBAL_XPUB_SIGNATURE)
In-Reply-To: <20190627150745.GA1897@coinkite.com>
References: <CAMpN3mLvY+kuUGqzMW6SAMZ=h46_g=XLhDPhSY=X6xhLxvi15Q@mail.gmail.com>
	<20190627095031.4d5817b8@simplexum.com>
	<CAMpN3mKPkCPtYkN-JVku1r217-aBK=Rh3UEhvRPS_Y6DixJ9Dw@mail.gmail.com>
	<20190627122916.3b6c2c32@simplexum.com>
	<CAMpN3mL8tyP-6-nwn6dorcq7-dad6wYz8_pXinqHhgzUnrr_tg@mail.gmail.com>
	<20190627134628.4d131264@simplexum.com>
	<CAMpN3m+LiSW=kRCQio+C_2To66o_SEq-d_0Z122j+BUxvh=LDQ@mail.gmail.com>
	<20190627142120.2c24fddb@simplexum.com>
	<CAMpN3m+0HJm+zZ81ZNP-BXpX_39BvHzwKRAPwpdHinJ13gdNeA@mail.gmail.com>
	<20190627150745.GA1897@coinkite.com>
Message-ID: <CAMpN3mKyKjSPs2SgC0pUbFMNXFZt7UOu4ktnbfBSDmLrDbafFA@mail.gmail.com>

Hi Peter,

tl;dr The problem this solves is "How can a signer verify an address with
HD changing the address every time?"

As an aside: (This is sort of explaining the current PR for the 0x01 global
field (separate from mine))
The problem is more easily understood with change addresses: If someone can
alter my PSBT before signing, they could replace my change address with
their address, and my signer would not know unless the signer just guesses
all the path sets it knows, then derives thousands of change addresses and
searches (most likely a signer is offline, so gap limit doesn't work since
we can't tell which change addresses have tx history. So the 0x01 global
tag will tell the signer "here's how you get from your master private key
to the xpub used in the change output's output BIP32_DERIVATION tag... you
can then derive the same key and check it is yours before signing."

Back to my proposal, this problem extends across wallets, since,
for example, if I want to send from my cold wallet to my warm wallet, I
don't want to give my cold signer my warm master key just so it can derive
and check the key. That's what signatures are for. So this proposal says "A
signer can be built to only sign if it sees a signature that itself has
signed, then from that signed xpub(s) derives the BIP32_DERIVATION in the
outputs, and if the output doesn't match it will reject and not sign"

This creates a sort of "chain of trust" for the wallet.

Currently the best way to prevent this (hacker swapping the send to
address) without using signatures is to reuse the same address every time
you want to send to the warm wallet, since after a few times, the signers
(people) will be able to remember the address.

This is a huge HD drawback for high security requirement environments.
Having this data in the PSBT standard will allow Trezor etc. to create an
enforceable whitelist feature.

Let me know if you have feedback on the details.

Thanks,
Jon

2019?6?28?(?) 0:07 Peter D. Gray <peter at coinkite.com>:

> I haven't studied the new proposal in depth, but my first impression is:
>
> Wouldn't it just be easier and better to just sign the entire "outputs"
> section of the PSBT?
>
> The signature would cover every byte, and therefore would cover any
> future BIP additions to the outputs area, and also help non-multisig
> cases today.
>
> ---
> Peter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG:
> A3A31BAD 5A2A5B10
>
>

-- 
-----------------
Jonathan Underwood
??????? ??????????????
-----------------

???????????????????????????????

??: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190628/eee0ccf7/attachment.html>

From aj at erisian.com.au  Fri Jun 28 09:49:37 2019
From: aj at erisian.com.au (Anthony Towns)
Date: Fri, 28 Jun 2019 19:49:37 +1000
Subject: [bitcoin-dev] Taproot proposal
In-Reply-To: <CAMZUoKnniSEy4RM2DWCRxzVyYsGJ3Rbw4sbFv0zxuPi9gwoXYA@mail.gmail.com>
References: <CAPg+sBg6Gg8b7hPogC==fehY3ZTHHpQReqym2fb4XXWFpMM-pQ@mail.gmail.com>
	<CAMZUoKnniSEy4RM2DWCRxzVyYsGJ3Rbw4sbFv0zxuPi9gwoXYA@mail.gmail.com>
Message-ID: <20190628094937.u5zisdhdyfc6g5ts@erisian.com.au>

On Wed, Jun 26, 2019 at 08:08:01PM -0400, Russell O'Connor via bitcoin-dev wrote:
> I have a comment about the 'input_index' of the transaction digest for taproot
> signatures.? It is currently listed as 2 bytes.? I think it would be better to
> expand that to 4 bytes.

FWIW, I think this would be essentially free, at least for the current
sighash modes, as (I think) all the non-ANYONECANPAY modes have at least
4 bytes of sha256 padding at present.

In addition to (or, perhaps, as a special case of) the reasons Russell
gives, I think this change would also better support proof-of-reserves
via taproot signatures (cf [0] or BIP 127), as it would allow the proof
tx to include more than 65k utxos with each utxo being signed with a
signature that commits to all inputs including the invalid placeholder.

[0] https://blockstream.com/2019/02/04/en-standardizing-bitcoin-proof-of-reserves/

If you didn't have this, but wanted to do proof-of-reserves over >65k
taproot UTXOs, you could use ANYONECANPAY signatures, and use the output
amounts to ensure the signatures can't be abused, something like:

   inputs:
     0: spend from txid 0000..0000 vout 0, no witness data
     1: utxo1, signed with ANYONECANPAY|ALL
     2: utxo2, signed with ANYONECANPAY|ALL
     3: utxo3, signed with ANYONECANPAY|ALL
     [etc]

   outputs:
     0: sum(utxo1..utxoN), pay to self
     1: 2099999997690001-sum(utxo1..utxo3), payable to whatever

The total output value is therefore one satoshi more bitcoin than there
could ever have been, so none of the utxoK signatures can be reused on the
blockchain (unless there's severe inflation due to bugs or hardforks),
but the values (and sums) all remain less than 21M BTC so it also won't
fail the current "amount too big" sanity checks.

That seems a bit more fragile/complicated than using SIGHASH_ALL for
everything, though it means your cold wallet doesn't have to serialize
your >65k transactions to verify it's signing what it thinks it is.

> [1]The var-integer field for the number of inputs (and the number of outputs)
> in a transaction looks like it should allow upto 2^64-1 inputs; however this is
> an illusion.? The P2P rules dictate that these values are immediately taken
> modulo 2^32 after decoding.? For example, if the number of inputs is a
> var-integer encoding of 0x0100000001, it is actually just a non-canonical way
> of encoding that there is 1 input.? Try this at home!

Hmm? If I'm following what you mean, that's not the P2P rules, it's the
Unserialize code, in particular:

  compat/assumptions.h:52:static_assert(sizeof(int) == 4, "32-bit int assumed");

  serialize.h:289:uint64_t ReadCompactSize(Stream& is)

  serialize.h-679-template<typename Stream, unsigned int N, typename T, typename V>
  serialize.h-680-void Unserialize_impl(Stream& is, prevector<N, T>& v, const V&)
  serialize.h-681-{
  serialize.h-682-    v.clear();
  serialize.h:683:    unsigned int nSize = ReadCompactSize(is);

  (and other Unserialize_impl implementations)

However, ReadCompactSize throws "size too large" if the return value is
greater than MAX_SIZE == 0x02000000 =~ 33.5M, which prior to the implicit
cast to 32 bits in Unserialize_impl. And it looks like that check's been
there since Satoshi...

So as far as I can see, that encoding's just unsupported/invalid, rather
than equivalent/non-canonical?

Cheers,
aj


From roconnor at blockstream.io  Fri Jun 28 11:16:46 2019
From: roconnor at blockstream.io (Russell O'Connor)
Date: Fri, 28 Jun 2019 07:16:46 -0400
Subject: [bitcoin-dev] Taproot proposal
In-Reply-To: <20190628094937.u5zisdhdyfc6g5ts@erisian.com.au>
References: <CAPg+sBg6Gg8b7hPogC==fehY3ZTHHpQReqym2fb4XXWFpMM-pQ@mail.gmail.com>
	<CAMZUoKnniSEy4RM2DWCRxzVyYsGJ3Rbw4sbFv0zxuPi9gwoXYA@mail.gmail.com>
	<20190628094937.u5zisdhdyfc6g5ts@erisian.com.au>
Message-ID: <CAMZUoK==mXiJQjcJO+KgxtCSf9qBan4tgsGzfPKLjP4CHcZ_iA@mail.gmail.com>

Hmm? If I'm following what you mean, that's not the P2P rules, it's the
> Unserialize code, in particular:
>
>   compat/assumptions.h:52:static_assert(sizeof(int) == 4, "32-bit int
> assumed");
>
>   serialize.h:289:uint64_t ReadCompactSize(Stream& is)
>
>   serialize.h-679-template<typename Stream, unsigned int N, typename T,
> typename V>
>   serialize.h-680-void Unserialize_impl(Stream& is, prevector<N, T>& v,
> const V&)
>   serialize.h-681-{
>   serialize.h-682-    v.clear();
>   serialize.h:683:    unsigned int nSize = ReadCompactSize(is);
>
>   (and other Unserialize_impl implementations)
>
> However, ReadCompactSize throws "size too large" if the return value is
> greater than MAX_SIZE == 0x02000000 =~ 33.5M, which prior to the implicit
> cast to 32 bits in Unserialize_impl. And it looks like that check's been
> there since Satoshi...
>
> So as far as I can see, that encoding's just unsupported/invalid, rather
> than equivalent/non-canonical?
>

Thanks for this correction!  I totally missed that MAX_SIZE == 0x02000000.
I think I mistook it for SIZE_MAX when reviewing this, or just didn't
notice it at all.

Cheers,
> aj
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190628/e7442a36/attachment.html>

From peter at coinkite.com  Fri Jun 28 14:37:55 2019
From: peter at coinkite.com (Peter D. Gray)
Date: Fri, 28 Jun 2019 10:37:55 -0400
Subject: [bitcoin-dev] BIP174 extension proposal (Global Type:
 PSBT_GLOBAL_XPUB_SIGNATURE)
In-Reply-To: <CAMpN3mKyKjSPs2SgC0pUbFMNXFZt7UOu4ktnbfBSDmLrDbafFA@mail.gmail.com>
References: <20190627095031.4d5817b8@simplexum.com>
	<CAMpN3mKPkCPtYkN-JVku1r217-aBK=Rh3UEhvRPS_Y6DixJ9Dw@mail.gmail.com>
	<20190627122916.3b6c2c32@simplexum.com>
	<CAMpN3mL8tyP-6-nwn6dorcq7-dad6wYz8_pXinqHhgzUnrr_tg@mail.gmail.com>
	<20190627134628.4d131264@simplexum.com>
	<CAMpN3m+LiSW=kRCQio+C_2To66o_SEq-d_0Z122j+BUxvh=LDQ@mail.gmail.com>
	<20190627142120.2c24fddb@simplexum.com>
	<CAMpN3m+0HJm+zZ81ZNP-BXpX_39BvHzwKRAPwpdHinJ13gdNeA@mail.gmail.com>
	<20190627150745.GA1897@coinkite.com>
	<CAMpN3mKyKjSPs2SgC0pUbFMNXFZt7UOu4ktnbfBSDmLrDbafFA@mail.gmail.com>
Message-ID: <20190628143755.GD1897@coinkite.com>

Thanks I get the idea better now: You want the PSBT creator to be
able to indicate to the signers that it (the PSBT creator) controls
specific outputs that don't otherwise look like change.

Some problems:

> extended private key of the current signer derived from the
> signer's root to m/2042083607'/959190427'/1400854130'/990526201'

1) The PSBT creator would need to know that private key, and the Coldcard, as a matter
   of policy, will never export a private subkey.

2) The 'm' in that path depends on who is reading the PSBT file, in the multisig
   case. Each cosigner would need a different version of the PSBT file.

3) XPUB's are big and hard to parse, and this addition is using lots of them.

4) Coinjoins, and more complex script types, will want to authorize
   outputs that the PSBT signer may not fully understand. Your proposal
   would only help P2PKH and M-of-N multisig users.

To fix, may I propose:

- the signer and PSBT creator must share a pubkey/private key out of band (setup time)
- the origin of that key is out of scope of this standard (but it could be derived via BIP32)
- the PSBT creator can, optionally, sign any or all output sections by number using that key

I would prefer the signatures are in the global section, and the
signature is over all the bytes in the indicated output section,
as originally serialized when it came into the signer's possession.

We should be able to support multiple signers for individual outputs,
and also multiple signatures for the same output section. That would
support different derived keys per co-signer, and also quorum
approval or other policies like that.

Afterthought: Might be good to allow signature over the unsigned transaction, or
maybe it should be part of the signature always.

---
Peter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG: A3A31BAD 5A2A5B10

On Fri, Jun 28, 2019 at 11:44:15AM +0900, Jonathan Underwood wrote:
> Hi Peter,
> 
> tl;dr The problem this solves is "How can a signer verify an address with
> HD changing the address every time?"
> 
> As an aside: (This is sort of explaining the current PR for the 0x01 global
> field (separate from mine))
> The problem is more easily understood with change addresses: If someone can
> alter my PSBT before signing, they could replace my change address with
> their address, and my signer would not know unless the signer just guesses
> all the path sets it knows, then derives thousands of change addresses and
> searches (most likely a signer is offline, so gap limit doesn't work since
> we can't tell which change addresses have tx history. So the 0x01 global
> tag will tell the signer "here's how you get from your master private key
> to the xpub used in the change output's output BIP32_DERIVATION tag... you
> can then derive the same key and check it is yours before signing."
> 
> Back to my proposal, this problem extends across wallets, since,
> for example, if I want to send from my cold wallet to my warm wallet, I
> don't want to give my cold signer my warm master key just so it can derive
> and check the key. That's what signatures are for. So this proposal says "A
> signer can be built to only sign if it sees a signature that itself has
> signed, then from that signed xpub(s) derives the BIP32_DERIVATION in the
> outputs, and if the output doesn't match it will reject and not sign"
> 
> This creates a sort of "chain of trust" for the wallet.
> 
> Currently the best way to prevent this (hacker swapping the send to
> address) without using signatures is to reuse the same address every time
> you want to send to the warm wallet, since after a few times, the signers
> (people) will be able to remember the address.
> 
> This is a huge HD drawback for high security requirement environments.
> Having this data in the PSBT standard will allow Trezor etc. to create an
> enforceable whitelist feature.
> 
> Let me know if you have feedback on the details.
> 
> Thanks,
> Jon
> 
> 2019?6?28?(?) 0:07 Peter D. Gray <peter at coinkite.com>:
> 
> > I haven't studied the new proposal in depth, but my first impression is:
> >
> > Wouldn't it just be easier and better to just sign the entire "outputs"
> > section of the PSBT?
> >
> > The signature would cover every byte, and therefore would cover any
> > future BIP additions to the outputs area, and also help non-multisig
> > cases today.
> >
> > ---
> > Peter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG:
> > A3A31BAD 5A2A5B10
> >
> >
> 
> -- 
> -----------------
> Jonathan Underwood
> ??????? ??????????????
> -----------------
> 
> ???????????????????????????????
> 
> ??: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3

From tamas.blummer at gmail.com  Fri Jun 28 08:27:16 2019
From: tamas.blummer at gmail.com (Tamas Blummer)
Date: Fri, 28 Jun 2019 10:27:16 +0200
Subject: [bitcoin-dev] Generalized covenants with taproot enable riskless or
 risky lending, prevent credit inflation through fractional reserve
Message-ID: <0DBC0DEA-C999-4AEE-B2E1-D5337ECD9405@gmail.com>

I start with a formalisation of loans as common in finance:

A zero bond is a contract between two parties Alice and Bob whereby Alice receives an amount less than P and has to pay back P at a later time point called maturity.
The difference between the amount received and P is the interest implied by the contract. E.g. receiving 1 Bitcoin (<P) and agree to pay back 1.1 (=P) in a year is the same as getting a loan with 10% p.a. interest.

The inherent risk in the contract is that Alice may not honor the agreement or be bankrupt by then.

If we could programmatically guarantee that Alice honors the contract then we would be able to create a riskless zero bond, the fundation of financial engineering.

A systemic problem with loans is that the lender might operate on fractional reserve, that is lending more than his capital.

Unchecked inflation of money supply through fractional reserve is creating a mess in the world we live in. Bitcoin could overcome this mess implementing this proposal!

I stop here with finance speak as the purpose of this mail is not to dive into finance, but to show how loans with full reserve check could be implemented in Bitcoin.

1. Receiving the loan is a payment from Bob to Alice, but we need a restriction how Alice can use the funds, so Bob can get them back unconditionally at maturity, so lending is riskless to him.
2. Bob wants to receive interest, since he gives up his control of the coins until maturity, he can not use them elsewhere until then. That interest could be paid in advance, this can be solved with Bitcoin as is.

How do we allow Alice to use the coins, that is: split/merge and transfer them to others, but still ensure Bob can claim them back at maturity?

We ensure that Alice can only send the coins to outputs that inherit a taproot path of validation (using http://bitcoin.sipa.be/miniscript/): 'and(time(100),pk(C))' where C is Bob?s key and 100 is maturity

This requires a generalization of the Bitcoin Covenants Idea[1] such that it nicely fits with taproot as follows:

1. A covenant in the form of '_ covenant C? on output means that it can be spent to an output that maches the covenant pattern with placeholder _  and the output(s) will be assigned 'covenant C'.
2. A covenant that mandates an output script with alternate validation paths can also assign alternate covernants to be inherited by the output(s) depending on which path was used to spend the input eg. 'covenant or(c covenant C, d covernant D)?
3. The resulting covenant of outputs should be reduced following boolean algebra, e.g. or(b,or(b,a)) to or(b, a)
4. express transitivity with 'covenant transitive? which means the output will have the same covenant as the input
5. allow to omit covenant on the output with 'covenant drop'

The covenant Bob would assign to the loan output sent to Alice is: 'covenant or(and(time(100),pk(Bob)) covenant drop, _ covenant transitive)' which means:
- Alice can send to an output script where she is free to chose the embedded script at the placeholder _ and that output will again have the same covenant as the input.
- After maturity Bob can claim any coin that is transitively rooted in the loan (more on this later) and the covenant will no longer be assigned to his new output(s).

Assuming Alice wants to send some of the borrowed coins to Charlie:

for shorter notation lets use b='and(time(100),pk(Bob)) covenant drop? for the script that gives Bob control after maturity.

Alice can not send to pk(Charlie), but she can send to or(b, pk(Charlie) covenant transitive)
Sending to pk(Charlie) would be sending cash, sending to or(b, pk(Charlie) covenant transitive) is a promissory note issued by Alice to Charlie, here is why:

If Charlie accepts an or(b, pk(Charlie) covenant transitive) output then he trusts, that Alice will offer a regular payment in exchange for it before maturity, since that output is worthless to Charlie after maturity as Bob can just take it.

It seems at the first sight that there is no value in these outputs for Charlie, since he still has to ensure Alice replaces them before maturity.

The value of these outputs to Charlie is the proof that he has exclusive control of the coins until maturity.
Alice can not issue promissory notes in excess of own capital or capital that she was able to borrow. No coin inflation or fractional reserve here, which also reduces the credit risk Charlie takes.

Due to the transitive covenant Charlie could pass on the coins to an other temporary owner until maturity when Bob would re-collect them unconditionally.

Should Charlie no longer be comfortable with Alice?s promise or need final coins (cash) immediatelly, then he could turn to Dan and do a re-purchase (repo) agreement with him.

Charlie would receive final coins from Dan in exchange for the temporarily controled coins and Charlie's promise to replace them with final coins before maturity.
Dan would thereby charge high interest through a discount since as he has to bear the credit risk of Charlie. This is not a riskless but a plain zero bond.

Why would Dan want to take temporary control of the coins at all? Again, to ensure Charlie is not doing yet another repo with Frank on the same coins, the sum of Charlie's repo deals are not in excess of his claims against others.
This again avoids lending in excess of coin supply and reduces the credit risk Dan takes.

Here are the sketches for the transacions for above alternate actions:

lets use shortcut c for 'or(and(time(100),pk(Bob)) covenant drop, _ covenant transitive)?

the transactions offer a fee of 0.0001

Bob gives a riskless credit to Alice:

Input			Output
1 pk(Bob) 		1 or(b,pk(Alice) covenant c)
0.1 pk(Alice)		0.9999 pk(Bob)

Alice could send a 0.5 promissory note to Charlie:

Input					Output
1 or(pk(Alice) covenant c)		0.5 or(b,pk(Charlie) covenant c)
1 pk(Alice)				0.5 or(b,pk(Alice) covenant c)
					0.9999 pk(Alice)

Alice could make good of the note before maturity, pay some interest and get back temporary control of the coins with:
Input						Output
0.5 or(b,pk(Charlie) covenant c)		0.5 or(b,pk(Alice) covenant c)
0.5101 pk(Alice)				0.51 pk(Charlie)

alternatively Charlie borrows from Dan at high interest:

Input						Output
0.5 or(b,pk(Charlie) covenant c)		0.5 or(b,pk(Dan) covenant c)
0.3001 pk(Dan)				0.3 pk(Charlie)

and Charlie re-purchases the temporary coins before maturity, making good of the repo with Dan:

Input							Output
0.5 or(b,pk(Dan) covenant c)			0.5 or(b,pk(Charlie) covenant c)
0.5001 pk(Charlie)					0.5 pk(Dan)

We need to define further transaction level validations for transactions spending inputs with covenants as follows:

1. If there are inputs without covenant before the input with covenant than inputs without covenant must be spent exactly with outputs preceeding the outputs with covenants.
2. A transaction can have inputs with different covenants, their allocation to outputs should follow input order.
3. For output(s) that share input(s) with covenant, the sum of covenant outputs must exactly add up to the input(s). This allows merging and splitting them.

Bob would re-collect his coins at maturity unconditionally. Who followed through promises or defaulted down the transitive chain is irrelevant to him.
Remark: we might also need a covenant attribute defining the minimum size of output, so Bob is not forced to collect dust, which would be expensive or even impossible. I am not yet happy with this solution, looking for better.

I am very excited about the possibilities this proposal would unlock and ask you verify usefulness of this scheme and join working out the details and how covenants would be integrated with taproot.

Tamas Blummer

[1] Malte Moser, Ittay Eyal, and Emin Gun Sirer. Bitcoin Covenants. URL: http://fc16.ifca.ai/bitcoin/papers/MES16.pdf
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190628/25fe4569/attachment-0001.sig>

From junderwood at bitcoinbank.co.jp  Fri Jun 28 15:00:22 2019
From: junderwood at bitcoinbank.co.jp (Jonathan Underwood)
Date: Sat, 29 Jun 2019 00:00:22 +0900
Subject: [bitcoin-dev] BIP174 extension proposal (Global Type:
	PSBT_GLOBAL_XPUB_SIGNATURE)
In-Reply-To: <20190628143755.GD1897@coinkite.com>
References: <20190627095031.4d5817b8@simplexum.com>
	<CAMpN3mKPkCPtYkN-JVku1r217-aBK=Rh3UEhvRPS_Y6DixJ9Dw@mail.gmail.com>
	<20190627122916.3b6c2c32@simplexum.com>
	<CAMpN3mL8tyP-6-nwn6dorcq7-dad6wYz8_pXinqHhgzUnrr_tg@mail.gmail.com>
	<20190627134628.4d131264@simplexum.com>
	<CAMpN3m+LiSW=kRCQio+C_2To66o_SEq-d_0Z122j+BUxvh=LDQ@mail.gmail.com>
	<20190627142120.2c24fddb@simplexum.com>
	<CAMpN3m+0HJm+zZ81ZNP-BXpX_39BvHzwKRAPwpdHinJ13gdNeA@mail.gmail.com>
	<20190627150745.GA1897@coinkite.com>
	<CAMpN3mKyKjSPs2SgC0pUbFMNXFZt7UOu4ktnbfBSDmLrDbafFA@mail.gmail.com>
	<20190628143755.GD1897@coinkite.com>
Message-ID: <CAMpN3mKZiQXrctWp9KxahdBHeeyu4pWPQP83LzRPLWXRWKBhAw@mail.gmail.com>

Thanks for the reply Peter. Comments inline:

2019?6?28?(?) 23:37 Peter D. Gray <peter at coinkite.com>:

> Thanks I get the idea better now: You want the PSBT creator to be
> able to indicate to the signers that it (the PSBT creator) controls
> specific outputs that don't otherwise look like change.
>
> Some problems:
>
> > extended private key of the current signer derived from the
> > signer's root to m/2042083607'/959190427'/1400854130'/990526201'
>
> 1) The PSBT creator would need to know that private key, and the Coldcard,
> as a matter
>    of policy, will never export a private subkey.
>

I think you have misunderstood. The signature inserted into this 0x02 field
is generated BY the signer (Coldkey) airgapped ahead of time. Then the
signature (and all the xpubs that were signed, since basically the "key"
value contains the "pubkey" and "message" while the "value" part has the
"signature". so all data items for verification are present.) will be
stored on the unsigned transaction preparing app. (MyTrezor dot com etc.
have an encrypted storage through Dropbox + encrypting with Trezor, so
they, for instance, could store the "whitelist signatures" on that dropbox
feature.


> 2) The 'm' in that path depends on who is reading the PSBT file, in the
> multisig
>    case. Each cosigner would need a different version of the PSBT file


Again, this is the m of the signer's root. The signer should have an xprv,
or some sort of seed (a la BIP39 or aezeed or Electrum phrase etc.) that
gets turned into a xprv. That xprv is m in this case... in the case that
some offline signer is storing the xprv of some path like "xprv/25'/42'" or
something, then the signer's "identity" is whatever xprv that signer holds
and not any of the xprvs derived from that first xprv.

The reason we want only one HD key to sign it is because we want the signer
to be able to generate that path from the root xprv they hold, check that
the pubkey matched the pubkey for verification, then verify. Now the signer
knows "oh, I have signed this xpub / multisig setup before, therefore I
trust it"


> 3) XPUB's are big and hard to parse, and this addition is using lots of
> them.
>

Any app requiring this level of security would gladly add a few millisecond
for parsing some xpubs.
Any HD wallet that can sign using HD derived keys already has the necessary
tools to parse an xpub.


> 4) Coinjoins, and more complex script types, will want to authorize
>    outputs that the PSBT signer may not fully understand. Your proposal
>    would only help P2PKH and M-of-N multisig users.
>

Yes. This proposal is not a requirement. It is just a reservation for a
slot in the key-value scheme for a use case that many exchanges and
hardware wallets should implement. We have implemented something similar to
this using JSON format internally, but since HW wallet makers seem to be
moving toward PSBT adoption, I would love for this info to be possible to
be sent into an HW wallet so that Trezor etc. can implement this
"whitelist" type situation in a way that the Trezor can trust. (remember, a
"whitelist" that just lives in my trezor dot com website cache etc. is
prone to modification, whereas with my proposal the worst case is a hacker
deletes a signature, so Trezor doesn't trust something it should have, and
fails signing. It can not add itself to the "whitelist" without the HW
wallet private key.)

To fix, may I propose:
>
>
The following suggestions seems to be predicated on a misunderstanding of
my proposal, so I will hold off for now.


> - the signer and PSBT creator must share a pubkey/private key out of band
> (setup time)
> - the origin of that key is out of scope of this standard (but it could be
> derived via BIP32)
> - the PSBT creator can, optionally, sign any or all output sections by
> number using that key
>
> I would prefer the signatures are in the global section, and the
> signature is over all the bytes in the indicated output section,
> as originally serialized when it came into the signer's possession.
>
> We should be able to support multiple signers for individual outputs,
> and also multiple signatures for the same output section. That would
> support different derived keys per co-signer, and also quorum
> approval or other policies like that.
>
> Afterthought: Might be good to allow signature over the unsigned
> transaction, or
> maybe it should be part of the signature always.
>
> ---
> Peter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG:
> A3A31BAD 5A2A5B10
>
> On Fri, Jun 28, 2019 at 11:44:15AM +0900, Jonathan Underwood wrote:
> > Hi Peter,
> >
> > tl;dr The problem this solves is "How can a signer verify an address with
> > HD changing the address every time?"
> >
> > As an aside: (This is sort of explaining the current PR for the 0x01
> global
> > field (separate from mine))
> > The problem is more easily understood with change addresses: If someone
> can
> > alter my PSBT before signing, they could replace my change address with
> > their address, and my signer would not know unless the signer just
> guesses
> > all the path sets it knows, then derives thousands of change addresses
> and
> > searches (most likely a signer is offline, so gap limit doesn't work
> since
> > we can't tell which change addresses have tx history. So the 0x01 global
> > tag will tell the signer "here's how you get from your master private key
> > to the xpub used in the change output's output BIP32_DERIVATION tag...
> you
> > can then derive the same key and check it is yours before signing."
> >
> > Back to my proposal, this problem extends across wallets, since,
> > for example, if I want to send from my cold wallet to my warm wallet, I
> > don't want to give my cold signer my warm master key just so it can
> derive
> > and check the key. That's what signatures are for. So this proposal says
> "A
> > signer can be built to only sign if it sees a signature that itself has
> > signed, then from that signed xpub(s) derives the BIP32_DERIVATION in the
> > outputs, and if the output doesn't match it will reject and not sign"
> >
> > This creates a sort of "chain of trust" for the wallet.
> >
> > Currently the best way to prevent this (hacker swapping the send to
> > address) without using signatures is to reuse the same address every time
> > you want to send to the warm wallet, since after a few times, the signers
> > (people) will be able to remember the address.
> >
> > This is a huge HD drawback for high security requirement environments.
> > Having this data in the PSBT standard will allow Trezor etc. to create an
> > enforceable whitelist feature.
> >
> > Let me know if you have feedback on the details.
> >
> > Thanks,
> > Jon
> >
> > 2019?6?28?(?) 0:07 Peter D. Gray <peter at coinkite.com>:
> >
> > > I haven't studied the new proposal in depth, but my first impression
> is:
> > >
> > > Wouldn't it just be easier and better to just sign the entire "outputs"
> > > section of the PSBT?
> > >
> > > The signature would cover every byte, and therefore would cover any
> > > future BIP additions to the outputs area, and also help non-multisig
> > > cases today.
> > >
> > > ---
> > > Peter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG:
> > > A3A31BAD 5A2A5B10
> > >
> > >
> >
> > --
> > -----------------
> > Jonathan Underwood
> > ??????? ??????????????
> > -----------------
> >
> > ???????????????????????????????
> >
> > ??: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3
>


-- 
-----------------
Jonathan Underwood
??????? ??????????????
-----------------

???????????????????????????????

??: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190629/4b55a1c7/attachment-0001.html>

From eric at voskuil.org  Fri Jun 28 17:25:22 2019
From: eric at voskuil.org (Eric Voskuil)
Date: Fri, 28 Jun 2019 10:25:22 -0700
Subject: [bitcoin-dev] Generalized covenants with taproot enable
	riskless or risky lending,
	prevent credit inflation through fractional reserve
In-Reply-To: <0DBC0DEA-C999-4AEE-B2E1-D5337ECD9405@gmail.com>
References: <0DBC0DEA-C999-4AEE-B2E1-D5337ECD9405@gmail.com>
Message-ID: <7A10C0F5-E206-43C1-853F-64AE04F57711@voskuil.org>

Hi Tamas,

There are a number of economic assumptions contained herein. While I understand you would like to focus on implementation, the worst bugs are requirements bugs. IMO these should be addressed first. I?ve addressed some possible issues inline.

> On Jun 28, 2019, at 01:27, Tamas Blummer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> I start with a formalisation of loans as common in finance:
> 
> A zero bond is a contract between two parties Alice and Bob whereby Alice receives an amount less than P and has to pay back P at a later time point called maturity.
> The difference between the amount received and P is the interest implied by the contract. E.g. receiving 1 Bitcoin (<P) and agree to pay back 1.1 (=P) in a year is the same as getting a loan with 10% p.a. interest.
> 
> The inherent risk in the contract is that Alice may not honor the agreement or be bankrupt by then.
> 
> If we could programmatically guarantee that Alice honors the contract then we would be able to create a riskless zero bond, the fundation of financial engineering.

I?m not aware of the basis of this statement. While people use the term ?risk free rate of return? there has never actually been such a thing. It?s not clear to me how a unicorn has been the foundation of ?financial engineering?, but I?m not also clear and what is intended by ?engineering? in this sense. Generally engineering is the implementation of higher level concepts. It is those concepts that constitute requirements here.

At a minimum, interest cannot be guaranteed by this proposal, which implies that at best it guarantees, setting aside changes in purchasing power, a return of principle minus economic interest on that principle (ie opportunity cost). Given that purchasing power changes over time, risk increases with the term of the loan. As such this is not riskless - both volatility and opportunity cost remain as risks.

> A systemic problem with loans is that the lender might operate on fractional reserve, that is lending more than his capital.

This is not a systemic problem, this is the very nature of lending. Fractional reserve is simply a state banking term used to describe the fact that people invest (lend) a fraction of their savings and hoard the rest. It matters not that banks or individuals do this, credit expansion is inherent in economy. Without it there is no investment and therefore no production whatsoever.

> Unchecked inflation of money supply through fractional reserve is creating a mess in the world we live in. Bitcoin could overcome this mess implementing this proposal!

You seem to be conflating state banking with the effects of investing. Taxpayer support for bank investment creates both a moral hazard (and the resulting misallocation of capital to state-favored projects, creating the famed economic ?business cycle?) and is a manifestation of persistent monetary inflation (ie seigniorage is a source taxation. Investment implies credit expansion, and the level of this expansion is controlled by time preference alone.

> I stop here with finance speak as the purpose of this mail is not to dive into finance, but to show how loans with full reserve check could be implemented in Bitcoin.
> 
> 1. Receiving the loan is a payment from Bob to Alice, but we need a restriction how Alice can use the funds, so Bob can get them back unconditionally at maturity, so lending is riskless to him.
> 2. Bob wants to receive interest, since he gives up his control of the coins until maturity, he can not use them elsewhere until then. That interest could be paid in advance, this can be solved with Bitcoin as is.

Interest cannot be paid in advance. This implies nothing more than a smaller amount of principle.

> How do we allow Alice to use the coins, that is: split/merge and transfer them to others, but still ensure Bob can claim them back at maturity?
> 
> We ensure that Alice can only send the coins to outputs that inherit a taproot path of validation (using http://bitcoin.sipa.be/miniscript/): 'and(time(100),pk(C))' where C is Bob?s key and 100 is maturity
> 
> This requires a generalization of the Bitcoin Covenants Idea[1] such that it nicely fits with taproot as follows:
> 
> 1. A covenant in the form of '_ covenant C? on output means that it can be spent to an output that maches the covenant pattern with placeholder _  and the output(s) will be assigned 'covenant C'.
> 2. A covenant that mandates an output script with alternate validation paths can also assign alternate covernants to be inherited by the output(s) depending on which path was used to spend the input eg. 'covenant or(c covenant C, d covernant D)?
> 3. The resulting covenant of outputs should be reduced following boolean algebra, e.g. or(b,or(b,a)) to or(b, a)
> 4. express transitivity with 'covenant transitive? which means the output will have the same covenant as the input
> 5. allow to omit covenant on the output with 'covenant drop'
> 
> The covenant Bob would assign to the loan output sent to Alice is: 'covenant or(and(time(100),pk(Bob)) covenant drop, _ covenant transitive)' which means:
> - Alice can send to an output script where she is free to chose the embedded script at the placeholder _ and that output will again have the same covenant as the input.
> - After maturity Bob can claim any coin that is transitively rooted in the loan (more on this later) and the covenant will no longer be assigned to his new output(s).
> 
> Assuming Alice wants to send some of the borrowed coins to Charlie:
> 
> for shorter notation lets use b='and(time(100),pk(Bob)) covenant drop? for the script that gives Bob control after maturity.
> 
> Alice can not send to pk(Charlie), but she can send to or(b, pk(Charlie) covenant transitive)
> Sending to pk(Charlie) would be sending cash, sending to or(b, pk(Charlie) covenant transitive) is a promissory note issued by Alice to Charlie, here is why:
> 
> If Charlie accepts an or(b, pk(Charlie) covenant transitive) output then he trusts, that Alice will offer a regular payment in exchange for it before maturity, since that output is worthless to Charlie after maturity as Bob can just take it.
> 
> It seems at the first sight that there is no value in these outputs for Charlie, since he still has to ensure Alice replaces them before maturity.
> 
> The value of these outputs to Charlie is the proof that he has exclusive control of the coins until maturity.

At a minimum, money that predictably depreciates (to zero in this case) must be discounted accordingly. How much is money worth today that is worth zero tomorrow? This can be observed with both inflation and demurrage money. This also implies that each encumbered coin is not fungible with any other of a distinct discount schedule.

What is the economic consequence of lending discounted money? Lower interest rates. How much lower? The rate of depreciation. This can also be observed with inflation and demurrage, but observation isn?t required. This is a necessary outcome.

So when one lends 1 demurrage coin for a term one cannot earn interest on 1 coin, one is earning interest on a fraction of a coin. That fraction creates credit expansion and reduces return in direct proportion to the risk that has been offset. In other words, the risk cost has been converted to opportunity cost. The discounted fraction earns no interest.

So credit expansion and risk remain, in the same proportions as without such a system. However lack of fungibility introduces an additional overhead cost.

e

> Alice can not issue promissory notes in excess of own capital or capital that she was able to borrow. No coin inflation or fractional reserve here, which also reduces the credit risk Charlie takes.
> 
> Due to the transitive covenant Charlie could pass on the coins to an other temporary owner until maturity when Bob would re-collect them unconditionally.
> 
> Should Charlie no longer be comfortable with Alice?s promise or need final coins (cash) immediatelly, then he could turn to Dan and do a re-purchase (repo) agreement with him.
> 
> Charlie would receive final coins from Dan in exchange for the temporarily controled coins and Charlie's promise to replace them with final coins before maturity.
> Dan would thereby charge high interest through a discount since as he has to bear the credit risk of Charlie. This is not a riskless but a plain zero bond.
> 
> Why would Dan want to take temporary control of the coins at all? Again, to ensure Charlie is not doing yet another repo with Frank on the same coins, the sum of Charlie's repo deals are not in excess of his claims against others.
> This again avoids lending in excess of coin supply and reduces the credit risk Dan takes.
> 
> Here are the sketches for the transacions for above alternate actions:
> 
> lets use shortcut c for 'or(and(time(100),pk(Bob)) covenant drop, _ covenant transitive)?
> 
> the transactions offer a fee of 0.0001
> 
> Bob gives a riskless credit to Alice:
> 
> Input            Output
> 1 pk(Bob)        1 or(b,pk(Alice) covenant c)
> 0.1 pk(Alice)        0.9999 pk(Bob)
> 
> Alice could send a 0.5 promissory note to Charlie:
> 
> Input                    Output
> 1 or(pk(Alice) covenant c)        0.5 or(b,pk(Charlie) covenant c)
> 1 pk(Alice)                0.5 or(b,pk(Alice) covenant c)
>                    0.9999 pk(Alice)
> 
> Alice could make good of the note before maturity, pay some interest and get back temporary control of the coins with:
> Input                        Output
> 0.5 or(b,pk(Charlie) covenant c)        0.5 or(b,pk(Alice) covenant c)
> 0.5101 pk(Alice)                0.51 pk(Charlie)
> 
> alternatively Charlie borrows from Dan at high interest:
> 
> Input                        Output
> 0.5 or(b,pk(Charlie) covenant c)        0.5 or(b,pk(Dan) covenant c)
> 0.3001 pk(Dan)                0.3 pk(Charlie)
> 
> and Charlie re-purchases the temporary coins before maturity, making good of the repo with Dan:
> 
> Input                            Output
> 0.5 or(b,pk(Dan) covenant c)            0.5 or(b,pk(Charlie) covenant c)
> 0.5001 pk(Charlie)                    0.5 pk(Dan)
> 
> We need to define further transaction level validations for transactions spending inputs with covenants as follows:
> 
> 1. If there are inputs without covenant before the input with covenant than inputs without covenant must be spent exactly with outputs preceeding the outputs with covenants.
> 2. A transaction can have inputs with different covenants, their allocation to outputs should follow input order.
> 3. For output(s) that share input(s) with covenant, the sum of covenant outputs must exactly add up to the input(s). This allows merging and splitting them.
> 
> Bob would re-collect his coins at maturity unconditionally. Who followed through promises or defaulted down the transitive chain is irrelevant to him.
> Remark: we might also need a covenant attribute defining the minimum size of output, so Bob is not forced to collect dust, which would be expensive or even impossible. I am not yet happy with this solution, looking for better.
> 
> I am very excited about the possibilities this proposal would unlock and ask you verify usefulness of this scheme and join working out the details and how covenants would be integrated with taproot.
> 
> Tamas Blummer
> 
> [1] Malte Moser, Ittay Eyal, and Emin Gun Sirer. Bitcoin Covenants. URL: http://fc16.ifca.ai/bitcoin/papers/MES16.pdf
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From tamas.blummer at gmail.com  Fri Jun 28 19:21:56 2019
From: tamas.blummer at gmail.com (Tamas Blummer)
Date: Fri, 28 Jun 2019 21:21:56 +0200
Subject: [bitcoin-dev] Generalized covenants with taproot enable
 riskless or risky lending,
 prevent credit inflation through fractional reserve
In-Reply-To: <7A10C0F5-E206-43C1-853F-64AE04F57711@voskuil.org>
References: <0DBC0DEA-C999-4AEE-B2E1-D5337ECD9405@gmail.com>
	<7A10C0F5-E206-43C1-853F-64AE04F57711@voskuil.org>
Message-ID: <EB743E28-8486-4CD5-B9AE-09B5693B27FA@gmail.com>

Hi Eric,

Thank you for your questions as they show what concepts need further explanation, so you understand the potential of this proposal and how it is helpful to the ecosystem.

Riskless zero bond is in fact the most basic concept of financial engineering. Yes, there are engineers of finance, those who create and price financial derivatives (e.g. options, swaps) and structure products such as e.g. ABS, CDO etc.
I used to be one of them.

A zero bond formalizes the observation that 1 unit of currency in the future has different value than 1 unit available now. It is called riskless if it is certain to receive the payment in the future.
If we put this difference of vaue in relation to the amount then we get the ?risk freee rate of return?, that you heard of.

E.g if one is willing to exchange 1 BTC unconditionally available now for 1.1 BTC certainly available in a year but not earlier, then the implied ?risk free rate of return? is apparently 10% pa. for Bitcoins.

The transaction I construct in the first example achives exactly this, because:

Bob forgoes his ability to use his unconditionally available coins by giving them to Alice with a covenant that ensures that Bob will receive them back later.
Bob does this because Alice pays for this in advance.

Alice can further transfer the coins encumbered by the covenant, but they will unconditionally return to Bob in the future.

The utility of these encumbered coins is that they prove that the loan is fully covered by reserves.

How valuable this utility is will be decided by the market and that value will be interest received by those who temporarily give up control. I am guess the value will be low but positive.

Lending does not mandate fractional or full reserves. These are choices the market or regulators enforce. Full reserve banking is not a fiction but is how things worked before introduction of gold receipts. A bank could only lend gold coins it possesed. Perils of fractional reserve were felt repeatedly by the Bitcoin ecnomy e.g. in the collaps of MtGox.

The idea to return to full reserve banking is not unique to gold bugs or Bitcoin but recently a popular vote was initiated in Switzerland to force Swiss banks to full reserves with respect to lending. This popular vote achived  24% support [1] which is quite remarkable if considered that the topic is not trivial as also our exchange shows.

I published today a writing in medium, that explains the concept of fractional vs. full reserve banking in conjunction with this proposal. Please read: https://medium.com/@tamas.blummer/full-reserve-banking-with-bitcoin-462b21ae9479 <https://medium.com/@tamas.blummer/full-reserve-banking-with-bitcoin-462b21ae9479>

I would welcome feedback on the generalized covenant construct or its implementation, as I think it can open up much more uses than the few examples I gave.

Tamas Blummer

[1] Vollgeld Initiative: https://www.bfs.admin.ch/bfs/de/home/statistiken/politik/abstimmungen/jahr-2018/2018-06-10/vollgeld-initiative.html <https://www.bfs.admin.ch/bfs/de/home/statistiken/politik/abstimmungen/jahr-2018/2018-06-10/vollgeld-initiative.html>
> On Jun 28, 2019, at 19:25, Eric Voskuil <eric at voskuil.org> wrote:
> 
> Hi Tamas,
> 
> There are a number of economic assumptions contained herein. While I understand you would like to focus on implementation, the worst bugs are requirements bugs. IMO these should be addressed first. I?ve addressed some possible issues inline.
> 
>> On Jun 28, 2019, at 01:27, Tamas Blummer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>> 
>> I start with a formalisation of loans as common in finance:
>> 
>> A zero bond is a contract between two parties Alice and Bob whereby Alice receives an amount less than P and has to pay back P at a later time point called maturity.
>> The difference between the amount received and P is the interest implied by the contract. E.g. receiving 1 Bitcoin (<P) and agree to pay back 1.1 (=P) in a year is the same as getting a loan with 10% p.a. interest.
>> 
>> The inherent risk in the contract is that Alice may not honor the agreement or be bankrupt by then.
>> 
>> If we could programmatically guarantee that Alice honors the contract then we would be able to create a riskless zero bond, the fundation of financial engineering.
> 
> I?m not aware of the basis of this statement. While people use the term ?risk free rate of return? there has never actually been such a thing. It?s not clear to me how a unicorn has been the foundation of ?financial engineering?, but I?m not also clear and what is intended by ?engineering? in this sense. Generally engineering is the implementation of higher level concepts. It is those concepts that constitute requirements here.
> 
> At a minimum, interest cannot be guaranteed by this proposal, which implies that at best it guarantees, setting aside changes in purchasing power, a return of principle minus economic interest on that principle (ie opportunity cost). Given that purchasing power changes over time, risk increases with the term of the loan. As such this is not riskless - both volatility and opportunity cost remain as risks.
> 
>> A systemic problem with loans is that the lender might operate on fractional reserve, that is lending more than his capital.
> 
> This is not a systemic problem, this is the very nature of lending. Fractional reserve is simply a state banking term used to describe the fact that people invest (lend) a fraction of their savings and hoard the rest. It matters not that banks or individuals do this, credit expansion is inherent in economy. Without it there is no investment and therefore no production whatsoever.
> 
>> Unchecked inflation of money supply through fractional reserve is creating a mess in the world we live in. Bitcoin could overcome this mess implementing this proposal!
> 
> You seem to be conflating state banking with the effects of investing. Taxpayer support for bank investment creates both a moral hazard (and the resulting misallocation of capital to state-favored projects, creating the famed economic ?business cycle?) and is a manifestation of persistent monetary inflation (ie seigniorage is a source taxation. Investment implies credit expansion, and the level of this expansion is controlled by time preference alone.
> 
>> I stop here with finance speak as the purpose of this mail is not to dive into finance, but to show how loans with full reserve check could be implemented in Bitcoin.
>> 
>> 1. Receiving the loan is a payment from Bob to Alice, but we need a restriction how Alice can use the funds, so Bob can get them back unconditionally at maturity, so lending is riskless to him.
>> 2. Bob wants to receive interest, since he gives up his control of the coins until maturity, he can not use them elsewhere until then. That interest could be paid in advance, this can be solved with Bitcoin as is.
> 
> Interest cannot be paid in advance. This implies nothing more than a smaller amount of principle.
> 
>> How do we allow Alice to use the coins, that is: split/merge and transfer them to others, but still ensure Bob can claim them back at maturity?
>> 
>> We ensure that Alice can only send the coins to outputs that inherit a taproot path of validation (using http://bitcoin.sipa.be/miniscript/): 'and(time(100),pk(C))' where C is Bob?s key and 100 is maturity
>> 
>> This requires a generalization of the Bitcoin Covenants Idea[1] such that it nicely fits with taproot as follows:
>> 
>> 1. A covenant in the form of '_ covenant C? on output means that it can be spent to an output that maches the covenant pattern with placeholder _  and the output(s) will be assigned 'covenant C'.
>> 2. A covenant that mandates an output script with alternate validation paths can also assign alternate covernants to be inherited by the output(s) depending on which path was used to spend the input eg. 'covenant or(c covenant C, d covernant D)?
>> 3. The resulting covenant of outputs should be reduced following boolean algebra, e.g. or(b,or(b,a)) to or(b, a)
>> 4. express transitivity with 'covenant transitive? which means the output will have the same covenant as the input
>> 5. allow to omit covenant on the output with 'covenant drop'
>> 
>> The covenant Bob would assign to the loan output sent to Alice is: 'covenant or(and(time(100),pk(Bob)) covenant drop, _ covenant transitive)' which means:
>> - Alice can send to an output script where she is free to chose the embedded script at the placeholder _ and that output will again have the same covenant as the input.
>> - After maturity Bob can claim any coin that is transitively rooted in the loan (more on this later) and the covenant will no longer be assigned to his new output(s).
>> 
>> Assuming Alice wants to send some of the borrowed coins to Charlie:
>> 
>> for shorter notation lets use b='and(time(100),pk(Bob)) covenant drop? for the script that gives Bob control after maturity.
>> 
>> Alice can not send to pk(Charlie), but she can send to or(b, pk(Charlie) covenant transitive)
>> Sending to pk(Charlie) would be sending cash, sending to or(b, pk(Charlie) covenant transitive) is a promissory note issued by Alice to Charlie, here is why:
>> 
>> If Charlie accepts an or(b, pk(Charlie) covenant transitive) output then he trusts, that Alice will offer a regular payment in exchange for it before maturity, since that output is worthless to Charlie after maturity as Bob can just take it.
>> 
>> It seems at the first sight that there is no value in these outputs for Charlie, since he still has to ensure Alice replaces them before maturity.
>> 
>> The value of these outputs to Charlie is the proof that he has exclusive control of the coins until maturity.
> 
> At a minimum, money that predictably depreciates (to zero in this case) must be discounted accordingly. How much is money worth today that is worth zero tomorrow? This can be observed with both inflation and demurrage money. This also implies that each encumbered coin is not fungible with any other of a distinct discount schedule.
> 
> What is the economic consequence of lending discounted money? Lower interest rates. How much lower? The rate of depreciation. This can also be observed with inflation and demurrage, but observation isn?t required. This is a necessary outcome.
> 
> So when one lends 1 demurrage coin for a term one cannot earn interest on 1 coin, one is earning interest on a fraction of a coin. That fraction creates credit expansion and reduces return in direct proportion to the risk that has been offset. In other words, the risk cost has been converted to opportunity cost. The discounted fraction earns no interest.
> 
> So credit expansion and risk remain, in the same proportions as without such a system. However lack of fungibility introduces an additional overhead cost.
> 
> e
> 
>> Alice can not issue promissory notes in excess of own capital or capital that she was able to borrow. No coin inflation or fractional reserve here, which also reduces the credit risk Charlie takes.
>> 
>> Due to the transitive covenant Charlie could pass on the coins to an other temporary owner until maturity when Bob would re-collect them unconditionally.
>> 
>> Should Charlie no longer be comfortable with Alice?s promise or need final coins (cash) immediatelly, then he could turn to Dan and do a re-purchase (repo) agreement with him.
>> 
>> Charlie would receive final coins from Dan in exchange for the temporarily controled coins and Charlie's promise to replace them with final coins before maturity.
>> Dan would thereby charge high interest through a discount since as he has to bear the credit risk of Charlie. This is not a riskless but a plain zero bond.
>> 
>> Why would Dan want to take temporary control of the coins at all? Again, to ensure Charlie is not doing yet another repo with Frank on the same coins, the sum of Charlie's repo deals are not in excess of his claims against others.
>> This again avoids lending in excess of coin supply and reduces the credit risk Dan takes.
>> 
>> Here are the sketches for the transacions for above alternate actions:
>> 
>> lets use shortcut c for 'or(and(time(100),pk(Bob)) covenant drop, _ covenant transitive)?
>> 
>> the transactions offer a fee of 0.0001
>> 
>> Bob gives a riskless credit to Alice:
>> 
>> Input            Output
>> 1 pk(Bob)        1 or(b,pk(Alice) covenant c)
>> 0.1 pk(Alice)        0.9999 pk(Bob)
>> 
>> Alice could send a 0.5 promissory note to Charlie:
>> 
>> Input                    Output
>> 1 or(pk(Alice) covenant c)        0.5 or(b,pk(Charlie) covenant c)
>> 1 pk(Alice)                0.5 or(b,pk(Alice) covenant c)
>>                   0.9999 pk(Alice)
>> 
>> Alice could make good of the note before maturity, pay some interest and get back temporary control of the coins with:
>> Input                        Output
>> 0.5 or(b,pk(Charlie) covenant c)        0.5 or(b,pk(Alice) covenant c)
>> 0.5101 pk(Alice)                0.51 pk(Charlie)
>> 
>> alternatively Charlie borrows from Dan at high interest:
>> 
>> Input                        Output
>> 0.5 or(b,pk(Charlie) covenant c)        0.5 or(b,pk(Dan) covenant c)
>> 0.3001 pk(Dan)                0.3 pk(Charlie)
>> 
>> and Charlie re-purchases the temporary coins before maturity, making good of the repo with Dan:
>> 
>> Input                            Output
>> 0.5 or(b,pk(Dan) covenant c)            0.5 or(b,pk(Charlie) covenant c)
>> 0.5001 pk(Charlie)                    0.5 pk(Dan)
>> 
>> We need to define further transaction level validations for transactions spending inputs with covenants as follows:
>> 
>> 1. If there are inputs without covenant before the input with covenant than inputs without covenant must be spent exactly with outputs preceeding the outputs with covenants.
>> 2. A transaction can have inputs with different covenants, their allocation to outputs should follow input order.
>> 3. For output(s) that share input(s) with covenant, the sum of covenant outputs must exactly add up to the input(s). This allows merging and splitting them.
>> 
>> Bob would re-collect his coins at maturity unconditionally. Who followed through promises or defaulted down the transitive chain is irrelevant to him.
>> Remark: we might also need a covenant attribute defining the minimum size of output, so Bob is not forced to collect dust, which would be expensive or even impossible. I am not yet happy with this solution, looking for better.
>> 
>> I am very excited about the possibilities this proposal would unlock and ask you verify usefulness of this scheme and join working out the details and how covenants would be integrated with taproot.
>> 
>> Tamas Blummer
>> 
>> [1] Malte Moser, Ittay Eyal, and Emin Gun Sirer. Bitcoin Covenants. URL: http://fc16.ifca.ai/bitcoin/papers/MES16.pdf
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190628/b6aef1d2/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190628/b6aef1d2/attachment-0001.sig>

From dp at simplexum.com  Fri Jun 28 21:48:16 2019
From: dp at simplexum.com (Dmitry Petukhov)
Date: Sat, 29 Jun 2019 02:48:16 +0500
Subject: [bitcoin-dev] BIP174 extension proposal (Global Type:
 PSBT_GLOBAL_XPUB_SIGNATURE)
In-Reply-To: <20190627202932.1cb4d727@simplexum.com>
References: <CAMpN3mLvY+kuUGqzMW6SAMZ=h46_g=XLhDPhSY=X6xhLxvi15Q@mail.gmail.com>
	<20190627095031.4d5817b8@simplexum.com>
	<CAMpN3mKPkCPtYkN-JVku1r217-aBK=Rh3UEhvRPS_Y6DixJ9Dw@mail.gmail.com>
	<20190627122916.3b6c2c32@simplexum.com>
	<CAMpN3mL8tyP-6-nwn6dorcq7-dad6wYz8_pXinqHhgzUnrr_tg@mail.gmail.com>
	<20190627181429.15dda570@simplexum.com>
	<20190627202932.1cb4d727@simplexum.com>
Message-ID: <20190629024816.2193363e@simplexum.com>

In your proposed field key format,

{0x02}|{signing_pubkey}|{m}|{xpub}|...|{xpub}

I think you can replace the signing pubkey with just a fingerprint of
the master key, that would save 29 bytes per 0x02 field.

If the only entity that is concerned about the validity of the
signature is those that possess the signing_privkey, it will check the
signature when it sees the 0x02 field starting with its own key
fingerprint, and will ignore the field if the signature does not match.

If someone other than the signer needs to check that this xpub-package
was signed by certain cold key, it will need to know signing_pubkey
anyway, before it parses PSBT, as it won't have the means to check if
certain pubkey found in 0x02 field in PSBT is related to certain
signer, without knowing anything about the pubkey beforehand.

I'm not sure if the ability of unrelated parties to verify that
xpub-package matches its signature is useful in practice. 29 bytes per
0x02 field is not a big saving of space, and if this ability is actually
useful, the saving may not be worh loosing this ability.

Other note: you have 'unused' value of 1 for `m` in your scheme, why
not require m=1 for single-sig case, and use 0 as indicator that there
are a serlal number following it?

The key for the field would be encoded as

{0x02}|{signing_pubkey}|{m}|{xpub}|...|{xpub}

for usual case, and

{0x02}|{signing_pubkey}|0x00|{serial}|{m}|{xpub}|...|{xpub}

for the case when the signing scheme actually cares about different
versions of xpub packages signed by certain cold key

Going back to the idea of moving 'complex' usecases outside of BIP174:
maybe we could have a 'BIP-specific' field, that would have the key as

{0x0?}|{BIP-number}|{bip-specific-suffix-data}

so that the different usecases that are not general enough to be
included in BIP174 itself, may have their own BIPs. Vendor-specific
fields may also be done as a separate BIP.

? Thu, 27 Jun 2019 20:29:32 +0500
Dmitry Petukhov <dp at simplexum.com> wrote:

> Oh, I saw that you covered it in another mail:
> 
> > The expire / revoke problem is a larger problem than this feature
> > can handle.  
> 
> > In general, if one of the cold keys is stolen, there is rarely a
> > situation where you are completely sure the other cold keys haven't
> > been compromised... so the best practice would be all signers
> > generate new keys and all funds are moved to a completely new
> > multisig wallet (no common xpubs).  
> 
> The setup might not be 'all cold keys', but the keys with different
> levels of exposure to possible theft. In this config, compromise of
> one of the 'warm' keys might not necessary require changing the
> 'cold' key.
> 
> I'm not sure whether this usecase warrants adding extra 'serial'
> field, but on the other hand it is rather simple change, and those who
> does not care can always set 0. 
> 
> ? Thu, 27 Jun 2019 18:14:29 +0500
> Dmitry Petukhov <dp at simplexum.com> wrote:
> 
> > What do you think about adding serial number to the xpub package ?
> > 
> > The key would be 
> > 
> > {0x02}|{signing_pubkey}|{serial}|{m}|{xpub}|...|{xpub}
> > 
> > and if the signer have the ability to store a counter, it can reject
> > 'outdated' xpub packages, and only accept those that was signed
> > using the serial number that it deems recent. This would allow a
> > limited mechanism to 'revoke' previously signed packages that have
> > compromized keys in them.
> > 
> > ? Thu, 27 Jun 2019 17:16:14 +0900
> > Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:
> >   
> > > I see what you mean.
> > > 
> > > What about this?
> > > https://github.com/junderw/bips/commit/57a57b4fae1ae14b77a2eebd99cd719148e3027e?short_path=82656c8#diff-82656c833e31e6751a412ce5e5c70920
> > > 
> > > Plus side: for single sig case, the key only increases by one byte
> > > (0x00 for the {m} value)
> > > 
> > > This way if it was 2 of 3 like before, you sign the whole "packet"
> > > so each key only signs the packet once. Way better than n!
> > > 
> > > Anywho. Please send your feedback. Thanks.
> > > Jonathan
> > > 
> > > 2019?6?27?(?) 16:27 Dmitry Petukhov <dp at simplexum.com>:
> > >     
> > > > How would signer know that there _should_ be at least 3
> > > > signatures signed by the key owned by this signer ?
> > > >
> > > > If it does not know that it should enforce 2of3 multisig, for
> > > > example, the attacker that control only one key A can fool
> > > > signer B by sending to 1of1 single-sig that is derived from A's
> > > > xpub, and providing only sBxA in PSBT.
> > > >
> > > > If the signer does not have a hardcoded configuration that
> > > > will mandate a particular multisig scheme, it will allow sending
> > > > to any scheme.
> > > >
> > > > If the signer has a rich enough state to store updatable
> > > > configuration, it can just store the trusted xpubs directly.
> > > >
> > > > Alternatively, signer can sign not individual xpubs, but whole
> > > > xpub packages that correspond to particular multisig
> > > > configuration, and enforce that destination addresses correspond
> > > > to this configuration.
> > > >
> > > > But this would not be possible with your PSBT scheme that uses
> > > > individual key-xpub pairs.
> > > >
> > > > ? Thu, 27 Jun 2019 14:07:47 +0900
> > > > Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:
> > > >      
> > > > > Thanks for the reply.
> > > > >
> > > > > The way we would do it is:
> > > > >
> > > > > Let's say we have 3 cold keys for multisig: A B and C
> > > > >
> > > > > Whose xpubs are: xA xB and xC
> > > > >
> > > > > We all sign each other's xpubs, whose signatures are:
> > > > > sAxB
> > > > > sAxC
> > > > > sBxA
> > > > > sBxC
> > > > > sCxA
> > > > > sCxB
> > > > >
> > > > > We can then create a wallet that says "when verifying change
> > > > > with 0x01 global type proposed by Andrew Chow, if the change
> > > > > is multisig, we MUST require the other pubkeys to have
> > > > > signatures via my 0x02 proposal"
> > > > >
> > > > > This way, all my PSBTs for my cold will have:
> > > > > 1. an 0x01 entry to tell me how to get my change.
> > > > > 2. All 6 of the signatures above.
> > > > >
> > > > > And the signer will then look at the change, check my pubkey
> > > > > by deriving the xpub and checking equality to the
> > > > > BIP_DERIVATION of the output... it will then check the OTHER
> > > > > pubkeys via BIP32_DERIVATION to master fingerprint, then link
> > > > > that fingerprint to a 0x02 sig from MY key, verifying all
> > > > > pubkeys.
> > > > >
> > > > > So this proposal of mine would not only fix the "send to
> > > > > address verification" problem for HD, but also the multisig
> > > > > change problem with 0x01.
> > > > >
> > > > > Cool.
> > > > >
> > > > > Only thing that is kind of sad is having to include n! (of
> > > > > m-of-n) signatures in every PSBT... but tbh, the PSBT size is
> > > > > not of much concern.
> > > > >
> > > > > Thanks for the reply.
> > > > > - Jonathan
> > > > >
> > > > >
> > > > > 2019?6?27?(?) 13:49 Dmitry Petukhov <dp at simplexum.com>:
> > > > >      
> > > > > > Hi!
> > > > > >
> > > > > > I wonder how your scheme handles multisig ?
> > > > > >
> > > > > > As I understand, you sign individual xpubs with cold keys,
> > > > > > so that cold keys can check destination addresses are
> > > > > > trusted.
> > > > > >
> > > > > > I seems to me that if you sign individual xpubs of a
> > > > > > multisig warm wallet, and one key from that multisig is
> > > > > > compromized, attackers can then create a single-sig
> > > > > > destination address that they control, and move the coins
> > > > > > in a chain of two transactions, first to this single-sig
> > > > > > address, and then to an address that they independently
> > > > > > control.
> > > > > >
> > > > > > My idea to prevent this [1] is to sign the whole 'xpub
> > > > > > package' of the multisig wallet, but there is also an issue
> > > > > > of 'partial compromize', where some of the keys in a
> > > > > > multisig warm wallet is compromized, and you do not want to
> > > > > > regard a particular 'xpub package' as trusted. My idea was
> > > > > > [2] to use an auxiliary message that would be signed along
> > > > > > with the 'xpub package', and that message can include
> > > > > > specific 'epoch' word that hardware wallet can show
> > > > > > prominently before signing, or have 'serial number' for
> > > > > > xpub packages (but that will require to store last known
> > > > > > serial inside hw wallet, making it stateful).
> > > > > >
> > > > > > I like the idea to extend PSBT to accomodate these schemes,
> > > > > > but given that the huge number of possible schemes that each
> > > > > > may probably require its own PSBT field type, I think that
> > > > > > this is better dealt with outside of PSBT, as 'PSBT
> > > > > > metainformation', or using some form of 'vendor-specific',
> > > > > > or 'metainformation-specific' PSBT field. This way each
> > > > > > usecase can be independently described in its own
> > > > > > documentation, that would include the particulars of the
> > > > > > format for the metainformation. This would also make it
> > > > > > easier to implement PSBT for simple cases, because the
> > > > > > 'core specification' would not grow that big.
> > > > > >
> > > > > > [1]
> > > > > >
> > > > > >      
> > > > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016917.html      
> > > > > >
> > > > > > [2]
> > > > > >
> > > > > >      
> > > > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016926.html      
> > > > > >
> > > > > >
> > > > > > ? Thu, 27 Jun 2019 11:11:23 +0900 Jonathan Underwood via
> > > > > > bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > > > > >      
> > > > > > > Hello all,
> > > > > > >
> > > > > > > Just wanted to pick your brains about an idea for PSBT
> > > > > > > extension.
> > > > > > >
> > > > > > > One problem we try to solve with cold -> warm and warm ->
> > > > > > > hot sends for our exchange wallet is "How do I know that
> > > > > > > the address I am sending to is not a hacker's address
> > > > > > > that was swapped in between unsigned tx creation and first
> > > > > > > signature?"
> > > > > > >
> > > > > > > We have a proprietary JSON based encoding system which we
> > > > > > > are looking to move towards PSBT, but PSBT is missing this
> > > > > > > key functionality.
> > > > > > >
> > > > > > > BIP32_DERIVATION does allow us to verify the address is
> > > > > > > from a certain XPUB, but, for example, it can not allow us
> > > > > > > to verify a signature of that xpub.
> > > > > > >
> > > > > > > I have made a rough draft of the proposed key value
> > > > > > > specification.     
> > > > > >      
> > > > https://github.com/junderw/bips/blob/addXpubSig/bip-0174.mediawiki#specification
> > > >      
> > > > > > >
> > > > > > > The signing key path used in the spec is just randomly
> > > > > > > chosen 31 x 4 bits shown as numbers with hardened paths.
> > > > > > >
> > > > > > > Since this issue seems similar to the change address
> > > > > > > issue, I started from that as a base. With the HW wallet
> > > > > > > case, I can verify the xpub by just deriving it locally
> > > > > > > and comparing equality, however, in our case, we need to
> > > > > > > verify an xpub that we do not have access to via
> > > > > > > derivation from our cold key(s) (since we don't want to
> > > > > > > import our warm private key into our cold signer)
> > > > > > >
> > > > > > > So the flow would be:
> > > > > > > 1. Securely verify the xpub of the warm / hot wallet.
> > > > > > > 2. Using the airgap signing tool, sign the xpub with all
> > > > > > > cold keys. 3. Upload the signature/xpub pairs to the
> > > > > > > online unsigned transaction generator.
> > > > > > > 4. Include one keyval pair per coldkey/xpub pairing.
> > > > > > > 5. When offline signing, if the wallet detects there is a
> > > > > > > global keyval XPUB_SIGNATURE with its pubkey in the key,
> > > > > > > it must verify that all outputs have BIP32_DERIVATION and
> > > > > > > that it can verify the outputs through the derivation, to
> > > > > > > the xpub, and to the signature.
> > > > > > >
> > > > > > > In my attempt to fitting this into PSBT, I am slightly
> > > > > > > altering our current system, so don't take this as an
> > > > > > > indication 100% of how we work in the backend.
> > > > > > >
> > > > > > > However, I would like to hear any feedback on this
> > > > > > > proposal.
> > > > > > >
> > > > > > > Thanks,
> > > > > > > Jonathan
> > > > > > >      
> > > > > >
> > > > > >      
> > > > >      
> > > >
> > > >      
> > >     
> >   
> 


From junderwood at bitcoinbank.co.jp  Sat Jun 29 00:19:41 2019
From: junderwood at bitcoinbank.co.jp (Jonathan Underwood)
Date: Sat, 29 Jun 2019 09:19:41 +0900
Subject: [bitcoin-dev] BIP174 extension proposal (Global Type:
	PSBT_GLOBAL_XPUB_SIGNATURE)
In-Reply-To: <20190629024816.2193363e@simplexum.com>
References: <CAMpN3mLvY+kuUGqzMW6SAMZ=h46_g=XLhDPhSY=X6xhLxvi15Q@mail.gmail.com>
	<20190627095031.4d5817b8@simplexum.com>
	<CAMpN3mKPkCPtYkN-JVku1r217-aBK=Rh3UEhvRPS_Y6DixJ9Dw@mail.gmail.com>
	<20190627122916.3b6c2c32@simplexum.com>
	<CAMpN3mL8tyP-6-nwn6dorcq7-dad6wYz8_pXinqHhgzUnrr_tg@mail.gmail.com>
	<20190627181429.15dda570@simplexum.com>
	<20190627202932.1cb4d727@simplexum.com>
	<20190629024816.2193363e@simplexum.com>
Message-ID: <CAMpN3m+Oa6oPzAmhoioOkuf8__NSPPNoSEMHJwo9PhjXosMwhg@mail.gmail.com>

replies in-line. Thanks!

2019?6?29?(?) 6:46 Dmitry Petukhov <dp at simplexum.com>:

> In your proposed field key format,
>
> {0x02}|{signing_pubkey}|{m}|{xpub}|...|{xpub}
>
> I think you can replace the signing pubkey with just a fingerprint of
> the master key, that would save 29 bytes per 0x02 field.
>

Good point.


> If the only entity that is concerned about the validity of the
> signature is those that possess the signing_privkey, it will check the
> signature when it sees the 0x02 field starting with its own key
> fingerprint, and will ignore the field if the signature does not match.
>
> If someone other than the signer needs to check that this xpub-package
> was signed by certain cold key, it will need to know signing_pubkey
> anyway, before it parses PSBT, as it won't have the means to check if
> certain pubkey found in 0x02 field in PSBT is related to certain
> signer, without knowing anything about the pubkey beforehand.
>
> I'm not sure if the ability of unrelated parties to verify that
> xpub-package matches its signature is useful in practice. 29 bytes per
> 0x02 field is not a big saving of space, and if this ability is actually
> useful, the saving may not be worh loosing this ability.
>

All good points, I think we'll just use the first 4 bytes of the hash160 of
the pubkey, aka fingerprint.


> Other note: you have 'unused' value of 1 for `m` in your scheme, why
> not require m=1 for single-sig case, and use 0 as indicator that there
> are a serlal number following it?
>

0x00 is single sig, aka, OP_CHECKSIG

0x01 is multisig, aka, 1-of-3, 1-of-2 OP_CHECKMULTISIG


> The key for the field would be encoded as
>
> {0x02}|{signing_pubkey}|{m}|{xpub}|...|{xpub}
>
> for usual case, and
>
> {0x02}|{signing_pubkey}|0x00|{serial}|{m}|{xpub}|...|{xpub}
>
> for the case when the signing scheme actually cares about different
> versions of xpub packages signed by certain cold key
>

since OP_CHECKMULTISIG only supports at most 15-of-15 due to stack item
size limitations, we could make 0xff into this serial marker.


> Going back to the idea of moving 'complex' usecases outside of BIP174:
> maybe we could have a 'BIP-specific' field, that would have the key as
>
> {0x0?}|{BIP-number}|{bip-specific-suffix-data}
>
> so that the different usecases that are not general enough to be
> included in BIP174 itself, may have their own BIPs. Vendor-specific
> fields may also be done as a separate BIP.
>

Definitely sounds good, but the currently proposed 0x01 global type is
being added to BIP174 directly under the assumption that it is useful for
all users of PSBT, and I would argue that 0x01 being an HD change verifying
method, it only seems logical to add a similar method of "verifying"
non-self keys, aka whitelisting for security purposes, and such a feature
would require this data be included into the PSBT sent into the device.

If the consensus is that this data is unneeded, 0x01 should probably also
be a separate BIP.

Though outside the scope of this BIP, one difficulty of a whitelist feature
would be revocation of signatures. If we pre-sign a revocation cert and
somehow make the wallet blacklist if seen... then the question is "if your
signer has a trustworthy store of state, why not store the whitelist
pubkeys?"

But that feature itself should be a separate BIP.

Also, POR_COMMITMENT being in BIP174 kind of set a precedent... :-/


> ? Thu, 27 Jun 2019 20:29:32 +0500
> Dmitry Petukhov <dp at simplexum.com> wrote:
>
> > Oh, I saw that you covered it in another mail:
> >
> > > The expire / revoke problem is a larger problem than this feature
> > > can handle.
> >
> > > In general, if one of the cold keys is stolen, there is rarely a
> > > situation where you are completely sure the other cold keys haven't
> > > been compromised... so the best practice would be all signers
> > > generate new keys and all funds are moved to a completely new
> > > multisig wallet (no common xpubs).
> >
> > The setup might not be 'all cold keys', but the keys with different
> > levels of exposure to possible theft. In this config, compromise of
> > one of the 'warm' keys might not necessary require changing the
> > 'cold' key.
> >
> > I'm not sure whether this usecase warrants adding extra 'serial'
> > field, but on the other hand it is rather simple change, and those who
> > does not care can always set 0.
> >
> > ? Thu, 27 Jun 2019 18:14:29 +0500
> > Dmitry Petukhov <dp at simplexum.com> wrote:
> >
> > > What do you think about adding serial number to the xpub package ?
> > >
> > > The key would be
> > >
> > > {0x02}|{signing_pubkey}|{serial}|{m}|{xpub}|...|{xpub}
> > >
> > > and if the signer have the ability to store a counter, it can reject
> > > 'outdated' xpub packages, and only accept those that was signed
> > > using the serial number that it deems recent. This would allow a
> > > limited mechanism to 'revoke' previously signed packages that have
> > > compromized keys in them.
> > >
> > > ? Thu, 27 Jun 2019 17:16:14 +0900
> > > Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:
> > >
> > > > I see what you mean.
> > > >
> > > > What about this?
> > > >
> https://github.com/junderw/bips/commit/57a57b4fae1ae14b77a2eebd99cd719148e3027e?short_path=82656c8#diff-82656c833e31e6751a412ce5e5c70920
> > > >
> > > > Plus side: for single sig case, the key only increases by one byte
> > > > (0x00 for the {m} value)
> > > >
> > > > This way if it was 2 of 3 like before, you sign the whole "packet"
> > > > so each key only signs the packet once. Way better than n!
> > > >
> > > > Anywho. Please send your feedback. Thanks.
> > > > Jonathan
> > > >
> > > > 2019?6?27?(?) 16:27 Dmitry Petukhov <dp at simplexum.com>:
> > > >
> > > > > How would signer know that there _should_ be at least 3
> > > > > signatures signed by the key owned by this signer ?
> > > > >
> > > > > If it does not know that it should enforce 2of3 multisig, for
> > > > > example, the attacker that control only one key A can fool
> > > > > signer B by sending to 1of1 single-sig that is derived from A's
> > > > > xpub, and providing only sBxA in PSBT.
> > > > >
> > > > > If the signer does not have a hardcoded configuration that
> > > > > will mandate a particular multisig scheme, it will allow sending
> > > > > to any scheme.
> > > > >
> > > > > If the signer has a rich enough state to store updatable
> > > > > configuration, it can just store the trusted xpubs directly.
> > > > >
> > > > > Alternatively, signer can sign not individual xpubs, but whole
> > > > > xpub packages that correspond to particular multisig
> > > > > configuration, and enforce that destination addresses correspond
> > > > > to this configuration.
> > > > >
> > > > > But this would not be possible with your PSBT scheme that uses
> > > > > individual key-xpub pairs.
> > > > >
> > > > > ? Thu, 27 Jun 2019 14:07:47 +0900
> > > > > Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:
> > > > >
> > > > > > Thanks for the reply.
> > > > > >
> > > > > > The way we would do it is:
> > > > > >
> > > > > > Let's say we have 3 cold keys for multisig: A B and C
> > > > > >
> > > > > > Whose xpubs are: xA xB and xC
> > > > > >
> > > > > > We all sign each other's xpubs, whose signatures are:
> > > > > > sAxB
> > > > > > sAxC
> > > > > > sBxA
> > > > > > sBxC
> > > > > > sCxA
> > > > > > sCxB
> > > > > >
> > > > > > We can then create a wallet that says "when verifying change
> > > > > > with 0x01 global type proposed by Andrew Chow, if the change
> > > > > > is multisig, we MUST require the other pubkeys to have
> > > > > > signatures via my 0x02 proposal"
> > > > > >
> > > > > > This way, all my PSBTs for my cold will have:
> > > > > > 1. an 0x01 entry to tell me how to get my change.
> > > > > > 2. All 6 of the signatures above.
> > > > > >
> > > > > > And the signer will then look at the change, check my pubkey
> > > > > > by deriving the xpub and checking equality to the
> > > > > > BIP_DERIVATION of the output... it will then check the OTHER
> > > > > > pubkeys via BIP32_DERIVATION to master fingerprint, then link
> > > > > > that fingerprint to a 0x02 sig from MY key, verifying all
> > > > > > pubkeys.
> > > > > >
> > > > > > So this proposal of mine would not only fix the "send to
> > > > > > address verification" problem for HD, but also the multisig
> > > > > > change problem with 0x01.
> > > > > >
> > > > > > Cool.
> > > > > >
> > > > > > Only thing that is kind of sad is having to include n! (of
> > > > > > m-of-n) signatures in every PSBT... but tbh, the PSBT size is
> > > > > > not of much concern.
> > > > > >
> > > > > > Thanks for the reply.
> > > > > > - Jonathan
> > > > > >
> > > > > >
> > > > > > 2019?6?27?(?) 13:49 Dmitry Petukhov <dp at simplexum.com>:
> > > > > >
> > > > > > > Hi!
> > > > > > >
> > > > > > > I wonder how your scheme handles multisig ?
> > > > > > >
> > > > > > > As I understand, you sign individual xpubs with cold keys,
> > > > > > > so that cold keys can check destination addresses are
> > > > > > > trusted.
> > > > > > >
> > > > > > > I seems to me that if you sign individual xpubs of a
> > > > > > > multisig warm wallet, and one key from that multisig is
> > > > > > > compromized, attackers can then create a single-sig
> > > > > > > destination address that they control, and move the coins
> > > > > > > in a chain of two transactions, first to this single-sig
> > > > > > > address, and then to an address that they independently
> > > > > > > control.
> > > > > > >
> > > > > > > My idea to prevent this [1] is to sign the whole 'xpub
> > > > > > > package' of the multisig wallet, but there is also an issue
> > > > > > > of 'partial compromize', where some of the keys in a
> > > > > > > multisig warm wallet is compromized, and you do not want to
> > > > > > > regard a particular 'xpub package' as trusted. My idea was
> > > > > > > [2] to use an auxiliary message that would be signed along
> > > > > > > with the 'xpub package', and that message can include
> > > > > > > specific 'epoch' word that hardware wallet can show
> > > > > > > prominently before signing, or have 'serial number' for
> > > > > > > xpub packages (but that will require to store last known
> > > > > > > serial inside hw wallet, making it stateful).
> > > > > > >
> > > > > > > I like the idea to extend PSBT to accomodate these schemes,
> > > > > > > but given that the huge number of possible schemes that each
> > > > > > > may probably require its own PSBT field type, I think that
> > > > > > > this is better dealt with outside of PSBT, as 'PSBT
> > > > > > > metainformation', or using some form of 'vendor-specific',
> > > > > > > or 'metainformation-specific' PSBT field. This way each
> > > > > > > usecase can be independently described in its own
> > > > > > > documentation, that would include the particulars of the
> > > > > > > format for the metainformation. This would also make it
> > > > > > > easier to implement PSBT for simple cases, because the
> > > > > > > 'core specification' would not grow that big.
> > > > > > >
> > > > > > > [1]
> > > > > > >
> > > > > > >
> > > > >
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016917.html
>
> > > > > > >
> > > > > > > [2]
> > > > > > >
> > > > > > >
> > > > >
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016926.html
>
> > > > > > >
> > > > > > >
> > > > > > > ? Thu, 27 Jun 2019 11:11:23 +0900 Jonathan Underwood via
> > > > > > > bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > > > > > >
> > > > > > > > Hello all,
> > > > > > > >
> > > > > > > > Just wanted to pick your brains about an idea for PSBT
> > > > > > > > extension.
> > > > > > > >
> > > > > > > > One problem we try to solve with cold -> warm and warm ->
> > > > > > > > hot sends for our exchange wallet is "How do I know that
> > > > > > > > the address I am sending to is not a hacker's address
> > > > > > > > that was swapped in between unsigned tx creation and first
> > > > > > > > signature?"
> > > > > > > >
> > > > > > > > We have a proprietary JSON based encoding system which we
> > > > > > > > are looking to move towards PSBT, but PSBT is missing this
> > > > > > > > key functionality.
> > > > > > > >
> > > > > > > > BIP32_DERIVATION does allow us to verify the address is
> > > > > > > > from a certain XPUB, but, for example, it can not allow us
> > > > > > > > to verify a signature of that xpub.
> > > > > > > >
> > > > > > > > I have made a rough draft of the proposed key value
> > > > > > > > specification.
> > > > > > >
> > > > >
> https://github.com/junderw/bips/blob/addXpubSig/bip-0174.mediawiki#specification
> > > > >
> > > > > > > >
> > > > > > > > The signing key path used in the spec is just randomly
> > > > > > > > chosen 31 x 4 bits shown as numbers with hardened paths.
> > > > > > > >
> > > > > > > > Since this issue seems similar to the change address
> > > > > > > > issue, I started from that as a base. With the HW wallet
> > > > > > > > case, I can verify the xpub by just deriving it locally
> > > > > > > > and comparing equality, however, in our case, we need to
> > > > > > > > verify an xpub that we do not have access to via
> > > > > > > > derivation from our cold key(s) (since we don't want to
> > > > > > > > import our warm private key into our cold signer)
> > > > > > > >
> > > > > > > > So the flow would be:
> > > > > > > > 1. Securely verify the xpub of the warm / hot wallet.
> > > > > > > > 2. Using the airgap signing tool, sign the xpub with all
> > > > > > > > cold keys. 3. Upload the signature/xpub pairs to the
> > > > > > > > online unsigned transaction generator.
> > > > > > > > 4. Include one keyval pair per coldkey/xpub pairing.
> > > > > > > > 5. When offline signing, if the wallet detects there is a
> > > > > > > > global keyval XPUB_SIGNATURE with its pubkey in the key,
> > > > > > > > it must verify that all outputs have BIP32_DERIVATION and
> > > > > > > > that it can verify the outputs through the derivation, to
> > > > > > > > the xpub, and to the signature.
> > > > > > > >
> > > > > > > > In my attempt to fitting this into PSBT, I am slightly
> > > > > > > > altering our current system, so don't take this as an
> > > > > > > > indication 100% of how we work in the backend.
> > > > > > > >
> > > > > > > > However, I would like to hear any feedback on this
> > > > > > > > proposal.
> > > > > > > >
> > > > > > > > Thanks,
> > > > > > > > Jonathan
> > > > > > > >
> > > > > > >
> > > > > > >
> > > > > >
> > > > >
> > > > >
> > > >
> > >
> >
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190629/aed02387/attachment-0001.html>

From dp at simplexum.com  Sat Jun 29 04:31:04 2019
From: dp at simplexum.com (Dmitry Petukhov)
Date: Sat, 29 Jun 2019 09:31:04 +0500
Subject: [bitcoin-dev] BIP174 extension proposal (Global Type:
 PSBT_GLOBAL_XPUB_SIGNATURE)
In-Reply-To: <CAMpN3m+Oa6oPzAmhoioOkuf8__NSPPNoSEMHJwo9PhjXosMwhg@mail.gmail.com>
References: <CAMpN3mLvY+kuUGqzMW6SAMZ=h46_g=XLhDPhSY=X6xhLxvi15Q@mail.gmail.com>
	<20190627095031.4d5817b8@simplexum.com>
	<CAMpN3mKPkCPtYkN-JVku1r217-aBK=Rh3UEhvRPS_Y6DixJ9Dw@mail.gmail.com>
	<20190627122916.3b6c2c32@simplexum.com>
	<CAMpN3mL8tyP-6-nwn6dorcq7-dad6wYz8_pXinqHhgzUnrr_tg@mail.gmail.com>
	<20190627181429.15dda570@simplexum.com>
	<20190627202932.1cb4d727@simplexum.com>
	<20190629024816.2193363e@simplexum.com>
	<CAMpN3m+Oa6oPzAmhoioOkuf8__NSPPNoSEMHJwo9PhjXosMwhg@mail.gmail.com>
Message-ID: <20190629093104.52f7a262@simplexum.com>

? Sat, 29 Jun 2019 09:19:41 +0900
Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:

> Though outside the scope of this BIP, one difficulty of a whitelist
> feature would be revocation of signatures. If we pre-sign a
> revocation cert and somehow make the wallet blacklist if seen... then
> the question is "if your signer has a trustworthy store of state, why
> not store the whitelist pubkeys?"

In principle, if the hardware wallet can permanently store at least one
counter, it can have rich state, stored externally. It would sign a
state stored in RAM, and give out the state + signature to the
supporting app. The state will include a serial number, corresponding to
the internal counter stored in the hardware wallet. Next time, the app
will give the signed state to the hardware wallet along with
transaction data. Hardware wallet checks its signature over the state,
checks that serial matches its internal counter, uses and modifies the
state, then updates the internal counter and the serial number of the
state, and gives out the signed new state to the app. If the app
loses the state blob, though, there should be some mechanism to securely
override the hw wallet internal state.

This approach might have other limitations, as processing and storing
big enough state in the RAM of a resource-constrained device might
present a problem in itself.

The 'add serial to xpub-package' idea is in the same vein: you can
store this xpub-package serial inside the hw wallet directly, or inside
its 'external rich state blob', but it can take only one byte (unlikely
to need more than 255 xpub-package 'revocations', at that point you
are probably OK to change your cold keys already)

From dp at simplexum.com  Sat Jun 29 04:46:23 2019
From: dp at simplexum.com (Dmitry Petukhov)
Date: Sat, 29 Jun 2019 09:46:23 +0500
Subject: [bitcoin-dev] BIP174 extension proposal (Global Type:
 PSBT_GLOBAL_XPUB_SIGNATURE)
In-Reply-To: <CAMpN3m+Oa6oPzAmhoioOkuf8__NSPPNoSEMHJwo9PhjXosMwhg@mail.gmail.com>
References: <CAMpN3mLvY+kuUGqzMW6SAMZ=h46_g=XLhDPhSY=X6xhLxvi15Q@mail.gmail.com>
	<20190627095031.4d5817b8@simplexum.com>
	<CAMpN3mKPkCPtYkN-JVku1r217-aBK=Rh3UEhvRPS_Y6DixJ9Dw@mail.gmail.com>
	<20190627122916.3b6c2c32@simplexum.com>
	<CAMpN3mL8tyP-6-nwn6dorcq7-dad6wYz8_pXinqHhgzUnrr_tg@mail.gmail.com>
	<20190627181429.15dda570@simplexum.com>
	<20190627202932.1cb4d727@simplexum.com>
	<20190629024816.2193363e@simplexum.com>
	<CAMpN3m+Oa6oPzAmhoioOkuf8__NSPPNoSEMHJwo9PhjXosMwhg@mail.gmail.com>
Message-ID: <20190629094623.0324d35c@simplexum.com>

? Sat, 29 Jun 2019 09:19:41 +0900
Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:

> > Other note: you have 'unused' value of 1 for `m` in your scheme, why
> > not require m=1 for single-sig case, and use 0 as indicator that
> > there are a serlal number following it?
> >  
> 
> 0x00 is single sig, aka, OP_CHECKSIG
> 
> 0x01 is multisig, aka, 1-of-3, 1-of-2 OP_CHECKMULTISIG

This informatin is available in per-output redeem/witness script,
signer will be able to distinguish between multisig/single-sig by
looking at this script. I think it only need to know the total number
of keys participating in the signing, and check that this number
matches the particulars of redeem/witness script.

From tamas.blummer at gmail.com  Sat Jun 29 05:53:57 2019
From: tamas.blummer at gmail.com (Tamas Blummer)
Date: Sat, 29 Jun 2019 07:53:57 +0200
Subject: [bitcoin-dev] Generalized covenant to implement side chains
 embedded into the bitcoin block chain
Message-ID: <7856AC5A-D2AD-4C94-99BC-AA0F948E2B40@gmail.com>

I introduced you to gerneralized covenants[1] earlier, but in a domain specific context that de-routed us from technical discussion. Let me demonstrate the concept in a more generic use:

A covenant

or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)

would put a coin under the alternative control of a Transfer and Exit keys together with the script in control of the current owner.
Additional transaction level validations of transactions spending input with covenants apply as in [1]

Owner of such coins would be able to transfer them to others provided an addtional Transfer signature, in which case the coin remains encumbered with the same covenant.
If Exit and owner signs the covenant is dropped on the output, it becomes a plain Bitcoin again.

The Thransfer and Exit signatures could be threshold signatures of a federation, whereby member decide if the proposed transfer transaction complies with whatever unique rules they impose.

The result is a federated side chain embedded into the Bitcoin block chain.

Bob could purchase some asset guarded by the federation with a transaction:

Inputs
100.0001 pk(Bob)

Outputs
0.1 or(and(pk(Transfer), pk(Bob)), and(pk(Exit), pk(Bob)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
99.9 pk(Transfer)

Transfer to Alice with consent of the transfer validators:

Inputs
0.1 or(and(pk(Transfer), pk(Bob)), and(pk(Exit), pk(Bob)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
100.001 pk(Alice)

Outputs
0.1 or(and(pk(Transfer), pk(Alice)), and(pk(Exit), pk(Alice)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
100 pk(Bob)

Alice might be approved to exit with the exit signature of the federation:

Inputs
0.1 or(and(pk(Transfer), pk(Alice)), and(pk(Exit), pk(Alice)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
99.9 pk(Transfer)

Outputs
99.9999 pk(Alice)

Tamas Blummer
[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017059.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017059.html>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190629/090fe907/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190629/090fe907/attachment.sig>

From junderwood at bitcoinbank.co.jp  Sat Jun 29 08:11:56 2019
From: junderwood at bitcoinbank.co.jp (Jonathan Underwood)
Date: Sat, 29 Jun 2019 17:11:56 +0900
Subject: [bitcoin-dev] BIP174 extension proposal (Global Type:
	PSBT_GLOBAL_XPUB_SIGNATURE)
In-Reply-To: <20190629094512.558ce181@simplexum.com>
References: <CAMpN3mLvY+kuUGqzMW6SAMZ=h46_g=XLhDPhSY=X6xhLxvi15Q@mail.gmail.com>
	<20190627095031.4d5817b8@simplexum.com>
	<CAMpN3mKPkCPtYkN-JVku1r217-aBK=Rh3UEhvRPS_Y6DixJ9Dw@mail.gmail.com>
	<20190627122916.3b6c2c32@simplexum.com>
	<CAMpN3mL8tyP-6-nwn6dorcq7-dad6wYz8_pXinqHhgzUnrr_tg@mail.gmail.com>
	<20190627181429.15dda570@simplexum.com>
	<20190627202932.1cb4d727@simplexum.com>
	<20190629024816.2193363e@simplexum.com>
	<CAMpN3m+Oa6oPzAmhoioOkuf8__NSPPNoSEMHJwo9PhjXosMwhg@mail.gmail.com>
	<20190629094512.558ce181@simplexum.com>
Message-ID: <CAMpN3mLmVwKwMwjjPGV3Z1JjeLmejMLkTN+3+c0Hu3K0-0GjyA@mail.gmail.com>

Even if the difference is apparent outside the signed data (in the output).
Signing the data explicitly is more secure.

ie. if some sort of vulnerability / way to break this system for 1-of-1
multisig is found, someone who signed a single sig xpub whitelist will not
be exposed.

2019?6?29?(?) 13:43 Dmitry Petukhov <dp at simplexum.com>:

> ? Sat, 29 Jun 2019 09:19:41 +0900
> Jonathan Underwood <junderwood at bitcoinbank.co.jp> ?????:
>
> > > Other note: you have 'unused' value of 1 for `m` in your scheme, why
> > > not require m=1 for single-sig case, and use 0 as indicator that
> > > there are a serlal number following it?
> > >
> >
> > 0x00 is single sig, aka, OP_CHECKSIG
> >
> > 0x01 is multisig, aka, 1-of-3, 1-of-2 OP_CHECKMULTISIG
>
> This informatin is available in per-output redeem/witness script,
> signer will be able to distinguish between multisig/single-sig by
> looking at this script. I think it only need to know the total number
> of keys participating in the signing, and check that this number
> matches the particulars of redeem/witness script.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190629/04fd8336/attachment.html>

From dave at dtrt.org  Sat Jun 29 18:21:03 2019
From: dave at dtrt.org (David A. Harding)
Date: Sat, 29 Jun 2019 14:21:03 -0400
Subject: [bitcoin-dev] Generalized covenants with taproot enable
 riskless or risky lending,
 prevent credit inflation through fractional reserve
In-Reply-To: <0DBC0DEA-C999-4AEE-B2E1-D5337ECD9405@gmail.com>
References: <0DBC0DEA-C999-4AEE-B2E1-D5337ECD9405@gmail.com>
Message-ID: <20190629182103.sbbm4z54svxircbl@ganymede>

On Fri, Jun 28, 2019 at 10:27:16AM +0200, Tamas Blummer via bitcoin-dev wrote:
> The value of these outputs to Charlie is the proof that he has
> exclusive control of the coins until maturity.
>
> Alice can not issue promissory notes in excess of own capital or
> capital that she was able to borrow. No coin inflation or fractional
> reserve here, which also reduces the credit risk Charlie takes.

I believe these goals are obtainable today without any consensus
changes.  Bob can provably timelock bitcoins using CLTV or CSV in a
script that commits to the outpoint (txid, vout) of an output that will
be used as a colored coin to track the debt instrument.  The colored
coin, which has no appreciable onchain value itself, can then be
trustlessly traded, e.g. from Alice to Charlie to Dan as you describe.  

Anyone with a copy of the script Bob paid, the confirmed transaction he
included it in, and the confirmed transaction history of the colored
coin can trustlessly verify the ownership record---including that no
inflation or fractional reserve occurred.

I believe the RGB working group has set for itself the goal[1] of making
trustless colored coin protocols more efficient when performed on top of
Bitcoin.  I'd also suggest reading about Peter Todd's concept of
single-use seals[2].  You may want to investigate these ideas and see
whether they can be integrated with your own.

[1] https://github.com/rgb-org/spec/blob/master/00-introduction.md
[2] https://petertodd.org/2016/commitments-and-single-use-seals#bitcoin-transaction-outputs-as-single-use-seals

-Dave

From ZmnSCPxj at protonmail.com  Sat Jun 29 20:25:07 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 29 Jun 2019 20:25:07 +0000
Subject: [bitcoin-dev] Generalized covenant to implement side chains
	embedded into the bitcoin block chain
In-Reply-To: <7856AC5A-D2AD-4C94-99BC-AA0F948E2B40@gmail.com>
References: <7856AC5A-D2AD-4C94-99BC-AA0F948E2B40@gmail.com>
Message-ID: <_H2l-XejXP1xbWnnuxmn6V6YlA6KYbN-7f_nYF32W609BvQANEiJYVq9z0DWvQVAFTmKHlzwVPiHiRBT0XETT7UJi0syxXMxXN4HskUDHW4=@protonmail.com>

Good morning Tamas,

While I think covenants for some kind of debt tool is mildly interesting and an appropriate solution, I wonder about this particular use-case.

It seems to me that, as either the `Transfer` signers or `Exit` signers are always involved, that the `Transfer` signers can be constrained so as to ensure that the rules are followed correctly, without requiring that covenants be used on the Bitcoin layer.
After all, the outputs of each transaction signed by the `Transfer` signers are part of the transaction that is being signed; surely the `Transfer` signers can validate that the output matches the contract expected, without requiring that fullnodes also validate this?

In particular, it seems to me that covenants are only useful if there exist some alternative that does not involve some kind of fixed `Transfer` signer set, but still requires a covenant.
Otherwise, the `Transfer` signer set could simply impose the rules by themselves.


Another thing is that, if my understanding is correct, the "sidechain" here is not in fact a sidechain; the "sidechain" transaction graph is published on the Bitcoin blockchain.
Instead, the `Transfer` signers simply validate some smart contract, most likely embedded as a pay-to-contract in the `pk(Alice)`/`pk(Bob)` public keys, and ensure that the smart contract is correctly executed.
In that case, it may be useful to consider Smart Contracts Unchained instead: https://zmnscpxj.github.io/bitcoin/unchained.html

It would be possible, under Smart Contracts Unchained, to keep the `Transfer`-signed transactions offchain, until `Exit`-signing.
Then, when this chain of transaction spends is presented to the participants, the participants can be convinced to sign a "cut-through" transaction that cuts through the offchain transactions, with the resulting cut-through being the one confirmed onchain, and signed only the participants, without the `Transfer` or `Exit` federation signatures appearing onchain.
This hides not only the smart contract being executed, but also the fact that a Smart Contracts Unchained technique was at all used.

Regards,
ZmnSCPxj


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Saturday, June 29, 2019 1:53 PM, Tamas Blummer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> I introduced you to gerneralized covenants[1] earlier, but in a domain specific context that de-routed us from technical discussion. Let me demonstrate the concept in a more generic use:
>
> A covenant?
>
> or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)?
>
> would put a coin under the alternative control of a Transfer and Exit keys together with the script in control of the current owner.?
> Additional transaction level validations of transactions spending input with covenants apply as in [1]
>
> Owner of such coins would be able to transfer them to others provided an addtional Transfer signature, in which case the coin remains encumbered with the same covenant.
> If Exit and owner signs the covenant is dropped on the output, it becomes a plain Bitcoin again.
>
> The Thransfer and Exit signatures could be threshold signatures of a federation, whereby member decide if the proposed transfer transaction complies with whatever unique rules they impose.?
>
> The result is a federated side chain embedded into the Bitcoin block chain.
>
> Bob could purchase some asset guarded by the federation with a transaction:
>
> Inputs
> 100.0001 pk(Bob)
>
> Outputs
> 0.1 or(and(pk(Transfer), pk(Bob)), and(pk(Exit), pk(Bob)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)?
> 99.9?pk(Transfer)
>
> Transfer to Alice with consent of the transfer validators:
>
> Inputs
> 0.1 or(and(pk(Transfer), pk(Bob)), and(pk(Exit), pk(Bob)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)?
> 100.001 pk(Alice)
>
> Outputs
> 0.1 or(and(pk(Transfer), pk(Alice)), and(pk(Exit), pk(Alice)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)?
> 100 pk(Bob)
>
> Alice might be approved to exit with the exit signature of the federation:
>
> Inputs
> 0.1 or(and(pk(Transfer), pk(Alice)), and(pk(Exit), pk(Alice)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)?
> 99.9 pk(Transfer)
>
> Outputs
> 99.9999 pk(Alice)
>
> Tamas Blummer
> [1]?https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017059.html



From eric at voskuil.org  Sat Jun 29 21:21:20 2019
From: eric at voskuil.org (Eric Voskuil)
Date: Sat, 29 Jun 2019 14:21:20 -0700
Subject: [bitcoin-dev] Generalized covenants with taproot enable
	riskless or risky lending,
	prevent credit inflation through fractional reserve
In-Reply-To: <EB743E28-8486-4CD5-B9AE-09B5693B27FA@gmail.com>
References: <0DBC0DEA-C999-4AEE-B2E1-D5337ECD9405@gmail.com>
	<7A10C0F5-E206-43C1-853F-64AE04F57711@voskuil.org>
	<EB743E28-8486-4CD5-B9AE-09B5693B27FA@gmail.com>
Message-ID: <708D14A9-D25E-4DD2-8B6E-39A1194A7A00@voskuil.org>


> On Jun 28, 2019, at 12:21, Tamas Blummer <tamas.blummer at gmail.com> wrote:
> 
> Hi Eric,
> 
> Thank you for your questions as they show what concepts need further explanation, so you understand the potential of this proposal and how it is helpful to the ecosystem.
> 
> Riskless zero bond is in fact the most basic concept of financial engineering. Yes, there are engineers of finance, those who create and price financial derivatives (e.g. options, swaps) and structure products such as e.g. ABS, CDO etc.
> I used to be one of them.
> 
> A zero bond formalizes the observation that 1 unit of currency in the future has different value than 1 unit available now. It is called riskless if it is certain to receive the payment in the future.
> If we put this difference of vaue in relation to the amount then we get the ?risk freee rate of return?, that you heard of.
> 
> E.g if one is willing to exchange 1 BTC unconditionally available now for 1.1 BTC certainly available in a year but not earlier, then the implied ?risk free rate of return? is apparently 10% pa. for Bitcoins.

As I implied, I am well aware of the concept of risk free rate of return, which is a hypothetical.

> The transaction I construct in the first example achives exactly this, because:

Which implies you have created an actual instance of this heretofore purely hypothetical concept.

> Bob forgoes his ability to use his unconditionally available coins by giving them to Alice with a covenant that ensures that Bob will receive them back later.
> Bob does this because Alice pays for this in advance. 
> 
> Alice can further transfer the coins encumbered by the covenant, but they will unconditionally return to Bob in the future. 

Why would Alice pay for this at all?

> The utility of these encumbered coins is that they prove that the loan is fully covered by reserves.

What loan? Alice has paid Bob for something of no possible utility to her, or anyone else.

Bitcoin is a money, not consumable in any way. Its utility arises strictly from the possibility of eventually being traded for something else. The only reason to accept it in trade is that expectation. Removing that possibility, even transitively and over time, removes all utility immediately. In my previous comments I described a necessary discount to NPV, but it?s safe to say that must be 100%.

> How valuable this utility is will be decided by the market

Value is of course subjective, and is determined by individual preferences. Yet what is the value one might place on something of no use? Economically speaking it must be zero, since value is a subjective evaluation of utility (i.e. service to a person).

Consider the case of the 1000 and 500 rupee demonetization. Long lines of people formed at banks to convert to notes to others of equivalent denomination.

https://en.m.wikipedia.org/wiki/2016_Indian_banknote_demonetisation

Of course, upon announcement of the demonetization, existing 1000/500 rupee notes were discounted for the cost/risk of accomplishing this conversion (several people are reported to have died in the effort). If there was no such conversion possible, making the notes worthless at the future date, the *immediate* effect would necessarily have been 100% discount.

This of course sets aside any consumable value of the ?paper? notes, such as burning for heat or trading as novelties (e.g. demonetized Zimbabwean 100T notes currently trading), as Bitcoin is not capable of being consumed. It also sets aside the possibility that some people were unaware of the demonetization.

Who would accept such a note today that was known to be worthless at a future date? If they did, who would would accept it from them? It?s literally an on-chain scamcoin, where the first sucker must find another, and he another, an so on, as soon as possible, before it expires, leaving the last sucker holding the bag. Given an efficient market (i.e perfect knowledge of the scam), zero initial value is implied.

> and that value will be interest received by those who temporarily give up control. I am guess the value will be low but positive.

Giving up control of money for a period does not imply the money is useful to someone else. Bob might as well lock his coins in a time capsule, for which he has the only key, and ask Alice to pay him for it.

> Lending does not mandate fractional or full reserves.

I didn?t say that it does. Lending implies no ?mandate?. But the nature of fractional reservation is inherent in every loan/investment. 

> These are choices the market or regulators enforce.

Fractional reservation is not a consequence of statutory or market controls. The level of hoarding vs. lending is a consequence of individual time preference.

> Full reserve banking is not a fiction but is how things worked before introduction of gold receipts. A bank could only lend gold coins it possesed. Perils of fractional reserve were felt repeatedly by the Bitcoin ecnomy e.g. in the collaps of MtGox.

I don?t believe I called full reserve a fiction. With full reserve there is no possible investment, production or products. Unlikely, and disastrous for humanity, but not provably impossible.

A hazard of viewing economic concepts through a financial lens is that those higher order concepts become obscured by a morass of economically-irrelevant regulation and implementation details.

At this point we are going to end up in a discussion on what fractional reserve actually is. I?d be happy to have a discussion on the topic, but this list is clearly not a good forum for that.

Furthermore the question of whether or not this proposal is relevant to fractional reserve is moot unless it can be shown that the assumed utility actually exists. So I suggest we take this interesting but secondary question on fractional reserve somewhere else.

> The idea to return to full reserve banking is not unique to gold bugs or Bitcoin but recently a popular vote was initiated in Switzerland to force Swiss banks to full reserves with respect to lending. This popular vote achived  24% support [1] which is quite remarkable if considered that the topic is not trivial as also our exchange shows.

It shows the breadth of economic ignorance which is not surprising given its counterintuitive nature.

Best,
Eric

> I published today a writing in medium, that explains the concept of fractional vs. full reserve banking in conjunction with this proposal. Please read: https://medium.com/@tamas.blummer/full-reserve-banking-with-bitcoin-462b21ae9479
> 
> I would welcome feedback on the generalized covenant construct or its implementation, as I think it can open up much more uses than the few examples I gave.
> 
> Tamas Blummer
> 
> [1] Vollgeld Initiative: https://www.bfs.admin.ch/bfs/de/home/statistiken/politik/abstimmungen/jahr-2018/2018-06-10/vollgeld-initiative.html
> 
>> On Jun 28, 2019, at 19:25, Eric Voskuil <eric at voskuil.org> wrote:
>> 
>> Hi Tamas,
>> 
>> There are a number of economic assumptions contained herein. While I understand you would like to focus on implementation, the worst bugs are requirements bugs. IMO these should be addressed first. I?ve addressed some possible issues inline.
>> 
>>> On Jun 28, 2019, at 01:27, Tamas Blummer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>> 
>>> I start with a formalisation of loans as common in finance:
>>> 
>>> A zero bond is a contract between two parties Alice and Bob whereby Alice receives an amount less than P and has to pay back P at a later time point called maturity.
>>> The difference between the amount received and P is the interest implied by the contract. E.g. receiving 1 Bitcoin (<P) and agree to pay back 1.1 (=P) in a year is the same as getting a loan with 10% p.a. interest.
>>> 
>>> The inherent risk in the contract is that Alice may not honor the agreement or be bankrupt by then.
>>> 
>>> If we could programmatically guarantee that Alice honors the contract then we would be able to create a riskless zero bond, the fundation of financial engineering.
>> 
>> I?m not aware of the basis of this statement. While people use the term ?risk free rate of return? there has never actually been such a thing. It?s not clear to me how a unicorn has been the foundation of ?financial engineering?, but I?m not also clear and what is intended by ?engineering? in this sense. Generally engineering is the implementation of higher level concepts. It is those concepts that constitute requirements here.
>> 
>> At a minimum, interest cannot be guaranteed by this proposal, which implies that at best it guarantees, setting aside changes in purchasing power, a return of principle minus economic interest on that principle (ie opportunity cost). Given that purchasing power changes over time, risk increases with the term of the loan. As such this is not riskless - both volatility and opportunity cost remain as risks.
>> 
>>> A systemic problem with loans is that the lender might operate on fractional reserve, that is lending more than his capital.
>> 
>> This is not a systemic problem, this is the very nature of lending. Fractional reserve is simply a state banking term used to describe the fact that people invest (lend) a fraction of their savings and hoard the rest. It matters not that banks or individuals do this, credit expansion is inherent in economy. Without it there is no investment and therefore no production whatsoever.
>> 
>>> Unchecked inflation of money supply through fractional reserve is creating a mess in the world we live in. Bitcoin could overcome this mess implementing this proposal!
>> 
>> You seem to be conflating state banking with the effects of investing. Taxpayer support for bank investment creates both a moral hazard (and the resulting misallocation of capital to state-favored projects, creating the famed economic ?business cycle?) and is a manifestation of persistent monetary inflation (ie seigniorage is a source taxation. Investment implies credit expansion, and the level of this expansion is controlled by time preference alone.
>> 
>>> I stop here with finance speak as the purpose of this mail is not to dive into finance, but to show how loans with full reserve check could be implemented in Bitcoin.
>>> 
>>> 1. Receiving the loan is a payment from Bob to Alice, but we need a restriction how Alice can use the funds, so Bob can get them back unconditionally at maturity, so lending is riskless to him.
>>> 2. Bob wants to receive interest, since he gives up his control of the coins until maturity, he can not use them elsewhere until then. That interest could be paid in advance, this can be solved with Bitcoin as is.
>> 
>> Interest cannot be paid in advance. This implies nothing more than a smaller amount of principle.
>> 
>>> How do we allow Alice to use the coins, that is: split/merge and transfer them to others, but still ensure Bob can claim them back at maturity?
>>> 
>>> We ensure that Alice can only send the coins to outputs that inherit a taproot path of validation (using http://bitcoin.sipa.be/miniscript/): 'and(time(100),pk(C))' where C is Bob?s key and 100 is maturity
>>> 
>>> This requires a generalization of the Bitcoin Covenants Idea[1] such that it nicely fits with taproot as follows:
>>> 
>>> 1. A covenant in the form of '_ covenant C? on output means that it can be spent to an output that maches the covenant pattern with placeholder _  and the output(s) will be assigned 'covenant C'.
>>> 2. A covenant that mandates an output script with alternate validation paths can also assign alternate covernants to be inherited by the output(s) depending on which path was used to spend the input eg. 'covenant or(c covenant C, d covernant D)?
>>> 3. The resulting covenant of outputs should be reduced following boolean algebra, e.g. or(b,or(b,a)) to or(b, a)
>>> 4. express transitivity with 'covenant transitive? which means the output will have the same covenant as the input
>>> 5. allow to omit covenant on the output with 'covenant drop'
>>> 
>>> The covenant Bob would assign to the loan output sent to Alice is: 'covenant or(and(time(100),pk(Bob)) covenant drop, _ covenant transitive)' which means:
>>> - Alice can send to an output script where she is free to chose the embedded script at the placeholder _ and that output will again have the same covenant as the input.
>>> - After maturity Bob can claim any coin that is transitively rooted in the loan (more on this later) and the covenant will no longer be assigned to his new output(s).
>>> 
>>> Assuming Alice wants to send some of the borrowed coins to Charlie:
>>> 
>>> for shorter notation lets use b='and(time(100),pk(Bob)) covenant drop? for the script that gives Bob control after maturity.
>>> 
>>> Alice can not send to pk(Charlie), but she can send to or(b, pk(Charlie) covenant transitive)
>>> Sending to pk(Charlie) would be sending cash, sending to or(b, pk(Charlie) covenant transitive) is a promissory note issued by Alice to Charlie, here is why:
>>> 
>>> If Charlie accepts an or(b, pk(Charlie) covenant transitive) output then he trusts, that Alice will offer a regular payment in exchange for it before maturity, since that output is worthless to Charlie after maturity as Bob can just take it.
>>> 
>>> It seems at the first sight that there is no value in these outputs for Charlie, since he still has to ensure Alice replaces them before maturity.
>>> 
>>> The value of these outputs to Charlie is the proof that he has exclusive control of the coins until maturity.
>> 
>> At a minimum, money that predictably depreciates (to zero in this case) must be discounted accordingly. How much is money worth today that is worth zero tomorrow? This can be observed with both inflation and demurrage money. This also implies that each encumbered coin is not fungible with any other of a distinct discount schedule.
>> 
>> What is the economic consequence of lending discounted money? Lower interest rates. How much lower? The rate of depreciation. This can also be observed with inflation and demurrage, but observation isn?t required. This is a necessary outcome.
>> 
>> So when one lends 1 demurrage coin for a term one cannot earn interest on 1 coin, one is earning interest on a fraction of a coin. That fraction creates credit expansion and reduces return in direct proportion to the risk that has been offset. In other words, the risk cost has been converted to opportunity cost. The discounted fraction earns no interest.
>> 
>> So credit expansion and risk remain, in the same proportions as without such a system. However lack of fungibility introduces an additional overhead cost.
>> 
>> e
>> 
>>> Alice can not issue promissory notes in excess of own capital or capital that she was able to borrow. No coin inflation or fractional reserve here, which also reduces the credit risk Charlie takes.
>>> 
>>> Due to the transitive covenant Charlie could pass on the coins to an other temporary owner until maturity when Bob would re-collect them unconditionally.
>>> 
>>> Should Charlie no longer be comfortable with Alice?s promise or need final coins (cash) immediatelly, then he could turn to Dan and do a re-purchase (repo) agreement with him.
>>> 
>>> Charlie would receive final coins from Dan in exchange for the temporarily controled coins and Charlie's promise to replace them with final coins before maturity.
>>> Dan would thereby charge high interest through a discount since as he has to bear the credit risk of Charlie. This is not a riskless but a plain zero bond.
>>> 
>>> Why would Dan want to take temporary control of the coins at all? Again, to ensure Charlie is not doing yet another repo with Frank on the same coins, the sum of Charlie's repo deals are not in excess of his claims against others.
>>> This again avoids lending in excess of coin supply and reduces the credit risk Dan takes.
>>> 
>>> Here are the sketches for the transacions for above alternate actions:
>>> 
>>> lets use shortcut c for 'or(and(time(100),pk(Bob)) covenant drop, _ covenant transitive)?
>>> 
>>> the transactions offer a fee of 0.0001
>>> 
>>> Bob gives a riskless credit to Alice:
>>> 
>>> Input            Output
>>> 1 pk(Bob)        1 or(b,pk(Alice) covenant c)
>>> 0.1 pk(Alice)        0.9999 pk(Bob)
>>> 
>>> Alice could send a 0.5 promissory note to Charlie:
>>> 
>>> Input                    Output
>>> 1 or(pk(Alice) covenant c)        0.5 or(b,pk(Charlie) covenant c)
>>> 1 pk(Alice)                0.5 or(b,pk(Alice) covenant c)
>>>                   0.9999 pk(Alice)
>>> 
>>> Alice could make good of the note before maturity, pay some interest and get back temporary control of the coins with:
>>> Input                        Output
>>> 0.5 or(b,pk(Charlie) covenant c)        0.5 or(b,pk(Alice) covenant c)
>>> 0.5101 pk(Alice)                0.51 pk(Charlie)
>>> 
>>> alternatively Charlie borrows from Dan at high interest:
>>> 
>>> Input                        Output
>>> 0.5 or(b,pk(Charlie) covenant c)        0.5 or(b,pk(Dan) covenant c)
>>> 0.3001 pk(Dan)                0.3 pk(Charlie)
>>> 
>>> and Charlie re-purchases the temporary coins before maturity, making good of the repo with Dan:
>>> 
>>> Input                            Output
>>> 0.5 or(b,pk(Dan) covenant c)            0.5 or(b,pk(Charlie) covenant c)
>>> 0.5001 pk(Charlie)                    0.5 pk(Dan)
>>> 
>>> We need to define further transaction level validations for transactions spending inputs with covenants as follows:
>>> 
>>> 1. If there are inputs without covenant before the input with covenant than inputs without covenant must be spent exactly with outputs preceeding the outputs with covenants.
>>> 2. A transaction can have inputs with different covenants, their allocation to outputs should follow input order.
>>> 3. For output(s) that share input(s) with covenant, the sum of covenant outputs must exactly add up to the input(s). This allows merging and splitting them.
>>> 
>>> Bob would re-collect his coins at maturity unconditionally. Who followed through promises or defaulted down the transitive chain is irrelevant to him.
>>> Remark: we might also need a covenant attribute defining the minimum size of output, so Bob is not forced to collect dust, which would be expensive or even impossible. I am not yet happy with this solution, looking for better.
>>> 
>>> I am very excited about the possibilities this proposal would unlock and ask you verify usefulness of this scheme and join working out the details and how covenants would be integrated with taproot.
>>> 
>>> Tamas Blummer
>>> 
>>> [1] Malte Moser, Ittay Eyal, and Emin Gun Sirer. Bitcoin Covenants. URL: http://fc16.ifca.ai/bitcoin/papers/MES16.pdf
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190629/52c9105b/attachment-0001.html>

From tamas.blummer at gmail.com  Sun Jun 30 10:56:46 2019
From: tamas.blummer at gmail.com (Tamas Blummer)
Date: Sun, 30 Jun 2019 12:56:46 +0200
Subject: [bitcoin-dev] Generalized covenants with taproot enable
 riskless or risky lending,
 prevent credit inflation through fractional reserve
In-Reply-To: <708D14A9-D25E-4DD2-8B6E-39A1194A7A00@voskuil.org>
References: <0DBC0DEA-C999-4AEE-B2E1-D5337ECD9405@gmail.com>
	<7A10C0F5-E206-43C1-853F-64AE04F57711@voskuil.org>
	<EB743E28-8486-4CD5-B9AE-09B5693B27FA@gmail.com>
	<708D14A9-D25E-4DD2-8B6E-39A1194A7A00@voskuil.org>
Message-ID: <1A808C88-63FD-4F45-8C95-2B8B4D99EDF5@gmail.com>

Hi Eric,

> On Jun 29, 2019, at 23:21, Eric Voskuil <eric at voskuil.org> wrote:
> 
> What loan? Alice has paid Bob for something of no possible utility to her, or anyone else.
> 

Coins encumbered with the described covenant represent temporary control of a scarce resource.

Can this obtain value? That depends on the availability of final control and ability to deal with temporary control.

An example where final control is not available are areas and jurisdictions where land can not be bought only long time rents are offered.
People pay high prices there to step in place of the renter in an existing long term rent contract and they figured out the contracts that work under these restrictions.

Bitcoin?s predominant use is already store of value. Many assume not only wealth preservation but that it would allow to purchase of more goods in the future than now.
This leads to unwillingnes to give up final control, which can resolve in two ways:

- Increasing fiat prices for final control. We see this, and is actually further reinforcing unwillingnes to give up final control.
- dealing with temporary control. We do not yet have the technical means of even representing this. Developing them is my goal.

I think you do not show the neccesary respect of the market.

Your rant reminds me of renowed economists who still argue final control Bitcoin can not have value, you do the same proclaiming that temporary control of Bitcoin can not have value.

I say, that temporary control does not have value until means dealing with it are offered, and that is I work on. Thereafter might obtain value if final control is deemed too expensive or not attainable, we shall see.

Tamas Blummer


-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190630/936be150/attachment.sig>

From tamas.blummer at gmail.com  Sun Jun 30 16:57:06 2019
From: tamas.blummer at gmail.com (Tamas Blummer)
Date: Sun, 30 Jun 2019 18:57:06 +0200
Subject: [bitcoin-dev] Generalized covenant to implement side chains
 embedded into the bitcoin block chain
In-Reply-To: <_H2l-XejXP1xbWnnuxmn6V6YlA6KYbN-7f_nYF32W609BvQANEiJYVq9z0DWvQVAFTmKHlzwVPiHiRBT0XETT7UJi0syxXMxXN4HskUDHW4=@protonmail.com>
References: <7856AC5A-D2AD-4C94-99BC-AA0F948E2B40@gmail.com>
	<_H2l-XejXP1xbWnnuxmn6V6YlA6KYbN-7f_nYF32W609BvQANEiJYVq9z0DWvQVAFTmKHlzwVPiHiRBT0XETT7UJi0syxXMxXN4HskUDHW4=@protonmail.com>
Message-ID: <A048BAB4-9166-40BD-BC70-7FCE47F00D72@gmail.com>

Hello ZmnSCPxj,

Yes, representation of debt is more interesting here as it requires the covenant, wheras this example, as you point out, was less convincing given alternatives.
I created this example to avoid discussion of topics not approriate on this list.

Thank you for the suggestion of unchained execution of transfers with cut-through exit transaction as this made the example much stronger:

The most important question for someone who trusts his coins to some unchained platform is probably the question of how exit is guaranteed if one is unhappy with what one gets.

With the exit covenant exit conditions are set in stone, since validated on-chain. If the exit key is owned by a trusted arbiter other than the federation governing the unchained platform
then one at least have the option to cut losses at some point by presenting the arbiter a chain of valid transactions and asking to sign the exit.

Participants in the unchained platform would also be interested to regularly snapshot the economic effect of offchain transactions with cut-through transactions as such cut-through shortens the chain of transactions
they would need to get on chain if chosing the exit without consent of the federation governing the transfers.

So the convenant needed is: 'covenant or(_ covenant transitive, and(pkExit, _) covenant drop)' which gives unrestricted flexibility to the unchained platform with the exception that it has to maintain the exit option.


Tamas Blummer


> On Jun 29, 2019, at 22:25, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
> 
> Good morning Tamas,
> 
> While I think covenants for some kind of debt tool is mildly interesting and an appropriate solution, I wonder about this particular use-case.
> 
> It seems to me that, as either the `Transfer` signers or `Exit` signers are always involved, that the `Transfer` signers can be constrained so as to ensure that the rules are followed correctly, without requiring that covenants be used on the Bitcoin layer.
> After all, the outputs of each transaction signed by the `Transfer` signers are part of the transaction that is being signed; surely the `Transfer` signers can validate that the output matches the contract expected, without requiring that fullnodes also validate this?
> 
> In particular, it seems to me that covenants are only useful if there exist some alternative that does not involve some kind of fixed `Transfer` signer set, but still requires a covenant.
> Otherwise, the `Transfer` signer set could simply impose the rules by themselves.
> 
> 
> Another thing is that, if my understanding is correct, the "sidechain" here is not in fact a sidechain; the "sidechain" transaction graph is published on the Bitcoin blockchain.
> Instead, the `Transfer` signers simply validate some smart contract, most likely embedded as a pay-to-contract in the `pk(Alice)`/`pk(Bob)` public keys, and ensure that the smart contract is correctly executed.
> In that case, it may be useful to consider Smart Contracts Unchained instead: https://zmnscpxj.github.io/bitcoin/unchained.html
> 
> It would be possible, under Smart Contracts Unchained, to keep the `Transfer`-signed transactions offchain, until `Exit`-signing.
> Then, when this chain of transaction spends is presented to the participants, the participants can be convinced to sign a "cut-through" transaction that cuts through the offchain transactions, with the resulting cut-through being the one confirmed onchain, and signed only the participants, without the `Transfer` or `Exit` federation signatures appearing onchain.
> This hides not only the smart contract being executed, but also the fact that a Smart Contracts Unchained technique was at all used.
> 
> Regards,
> ZmnSCPxj
> 
> 
> Sent with ProtonMail Secure Email.
> 
> ??????? Original Message ???????
> On Saturday, June 29, 2019 1:53 PM, Tamas Blummer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
>> I introduced you to gerneralized covenants[1] earlier, but in a domain specific context that de-routed us from technical discussion. Let me demonstrate the concept in a more generic use:
>> 
>> A covenant
>> 
>> or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
>> 
>> would put a coin under the alternative control of a Transfer and Exit keys together with the script in control of the current owner.
>> Additional transaction level validations of transactions spending input with covenants apply as in [1]
>> 
>> Owner of such coins would be able to transfer them to others provided an addtional Transfer signature, in which case the coin remains encumbered with the same covenant.
>> If Exit and owner signs the covenant is dropped on the output, it becomes a plain Bitcoin again.
>> 
>> The Thransfer and Exit signatures could be threshold signatures of a federation, whereby member decide if the proposed transfer transaction complies with whatever unique rules they impose.
>> 
>> The result is a federated side chain embedded into the Bitcoin block chain.
>> 
>> Bob could purchase some asset guarded by the federation with a transaction:
>> 
>> Inputs
>> 100.0001 pk(Bob)
>> 
>> Outputs
>> 0.1 or(and(pk(Transfer), pk(Bob)), and(pk(Exit), pk(Bob)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
>> 99.9 pk(Transfer)
>> 
>> Transfer to Alice with consent of the transfer validators:
>> 
>> Inputs
>> 0.1 or(and(pk(Transfer), pk(Bob)), and(pk(Exit), pk(Bob)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
>> 100.001 pk(Alice)
>> 
>> Outputs
>> 0.1 or(and(pk(Transfer), pk(Alice)), and(pk(Exit), pk(Alice)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
>> 100 pk(Bob)
>> 
>> Alice might be approved to exit with the exit signature of the federation:
>> 
>> Inputs
>> 0.1 or(and(pk(Transfer), pk(Alice)), and(pk(Exit), pk(Alice)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
>> 99.9 pk(Transfer)
>> 
>> Outputs
>> 99.9999 pk(Alice)
>> 
>> Tamas Blummer
>> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017059.html
> 
> 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190630/513968e9/attachment.sig>

From eric at voskuil.org  Sun Jun 30 17:41:33 2019
From: eric at voskuil.org (Eric Voskuil)
Date: Sun, 30 Jun 2019 10:41:33 -0700
Subject: [bitcoin-dev] Generalized covenants with taproot enable
	riskless or risky lending,
	prevent credit inflation through fractional reserve
In-Reply-To: <1A808C88-63FD-4F45-8C95-2B8B4D99EDF5@gmail.com>
References: <0DBC0DEA-C999-4AEE-B2E1-D5337ECD9405@gmail.com>
	<7A10C0F5-E206-43C1-853F-64AE04F57711@voskuil.org>
	<EB743E28-8486-4CD5-B9AE-09B5693B27FA@gmail.com>
	<708D14A9-D25E-4DD2-8B6E-39A1194A7A00@voskuil.org>
	<1A808C88-63FD-4F45-8C95-2B8B4D99EDF5@gmail.com>
Message-ID: <83705370-79FC-4006-BA04-4782AD5BE70B@voskuil.org>


> On Jun 30, 2019, at 03:56, Tamas Blummer <tamas.blummer at gmail.com> wrote:
> 
> Hi Eric,
> 
>> On Jun 29, 2019, at 23:21, Eric Voskuil <eric at voskuil.org> wrote:
>> 
>> What loan? Alice has paid Bob for something of no possible utility to her, or anyone else.
>> 
> 
> Coins encumbered with the described covenant represent temporary control of a scarce resource.
> 
> Can this obtain value? That depends on the availability of final control and ability to deal with temporary control.

For something to become property (and therefore have marketable value) requires that it be both scarce and useful. Bitcoin is useful only to the extent that it can be traded for something else that is useful. Above you are only dealing with scarcity, ignoring utility.

> An example where final control is not available are areas and jurisdictions where land can not be bought only long time rents are offered.
> People pay high prices there to step in place of the renter in an existing long term rent contract and they figured out the contracts that work under these restrictions.

I was careful to point out that bitcoin is not in any way consumable. Occupying scarce land is a service to people. Units of bitcoin encumbered such that they cannot be traded for something of service to a person do not constitute property. You cannot even polish them, stack them on the floor, and roll around on them.

> Bitcoin?s predominant use is already store of value. Many assume not only wealth preservation but that it would allow to purchase of more goods in the future than now.

Yet it has been established that these encumbered coins cannot purchase anything of value except to the extent that an imperfect market is unaware of the scam.

> This leads to unwillingnes to give up final control, which can resolve in two ways:
> 
> - Increasing fiat prices for final control. We see this, and is actually further reinforcing unwillingnes to give up final control.
> - dealing with temporary control. We do not yet have the technical means of even representing this. Developing them is my goal.

Your goal is clear and not at issue.

> I think you do not show the neccesary respect of the market.

I?m not sure what is meant here by respect, or how much of it is necessary. I am merely explaining the market.

> Your rant reminds me of renowed economists who still argue final control Bitcoin can not have value, you do the same proclaiming that temporary control of Bitcoin can not have value.

It seems to me you have reversed the meaning of temporary and final. Bitcoin is useful because of the presumption that there is no finality of control. One presumes an ability to trade control of it for something else. This is temporary control. Final control would be the case in which, at some point, it can no longer be traded, making it worthless at that point. If this is known to be the case it implies that it it worthless at all prior points as well.

These are distinct scenarios. The fact that temporary (in my usage) control implies the possibility of value does not imply that finality of control does as well. The fact that (renowned or otherwise) people have made errors does not imply that I am making an error. These are both non-sequiturs.

> I say, that temporary control does not have value until means dealing with it are offered, and that is I work on. Thereafter might obtain value if final control is deemed too expensive or not attainable, we shall see.

The analogy to rental of a consumable good does not apply to the case of a non-consumable good. If it cannot be traded and cannot be consumed it cannot obtain marketable value. To this point it matters not whether it exists.

Best,
Eric

> Tamas Blummer
> 
> 

From tamas.blummer at gmail.com  Sun Jun 30 17:50:21 2019
From: tamas.blummer at gmail.com (Tamas Blummer)
Date: Sun, 30 Jun 2019 19:50:21 +0200
Subject: [bitcoin-dev] Generalized covenant to implement side chains
 embedded into the bitcoin block chain
In-Reply-To: <A048BAB4-9166-40BD-BC70-7FCE47F00D72@gmail.com>
References: <7856AC5A-D2AD-4C94-99BC-AA0F948E2B40@gmail.com>
	<_H2l-XejXP1xbWnnuxmn6V6YlA6KYbN-7f_nYF32W609BvQANEiJYVq9z0DWvQVAFTmKHlzwVPiHiRBT0XETT7UJi0syxXMxXN4HskUDHW4=@protonmail.com>
	<A048BAB4-9166-40BD-BC70-7FCE47F00D72@gmail.com>
Message-ID: <E736009F-50EE-4A0E-BD1A-F963A7820FA1@gmail.com>

I made an error proposing the new covenant. It should be unchanged as in the original example:

?covenant or(and(_, pk(Transfer)) covenant transitive, and(pk(Exit), _) covenant drop)?

since the placeholder stays for the control of the rightful owner without transfer signature on or off chain.

The exit could be alternatively automatic allowing to exit a stalling unchained platform:

?covenant or(and(_, pk(Transfer)) covenant transitive, and(delay(100), _) covenant drop)?

There remains the question why the rightful owner is not enforcing the covenant instead of having it enforced by on-chain consensus.

I do not yet have a good answer for that as in contrast to the debt example, here it is aligned with the interest of the current owner to have the covenant.

Tamas Blummer

> On Jun 30, 2019, at 18:57, Tamas Blummer <tamas.blummer at gmail.com> wrote:
> 
> Hello ZmnSCPxj,
> 
> Yes, representation of debt is more interesting here as it requires the covenant, wheras this example, as you point out, was less convincing given alternatives.
> I created this example to avoid discussion of topics not approriate on this list.
> 
> Thank you for the suggestion of unchained execution of transfers with cut-through exit transaction as this made the example much stronger:
> 
> The most important question for someone who trusts his coins to some unchained platform is probably the question of how exit is guaranteed if one is unhappy with what one gets.
> 
> With the exit covenant exit conditions are set in stone, since validated on-chain. If the exit key is owned by a trusted arbiter other than the federation governing the unchained platform
> then one at least have the option to cut losses at some point by presenting the arbiter a chain of valid transactions and asking to sign the exit.
> 
> Participants in the unchained platform would also be interested to regularly snapshot the economic effect of offchain transactions with cut-through transactions as such cut-through shortens the chain of transactions
> they would need to get on chain if chosing the exit without consent of the federation governing the transfers.
> 
> So the convenant needed is: 'covenant or(_ covenant transitive, and(pkExit, _) covenant drop)' which gives unrestricted flexibility to the unchained platform with the exception that it has to maintain the exit option.
> 
> 
> Tamas Blummer
> 
> 
>> On Jun 29, 2019, at 22:25, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>> 
>> Good morning Tamas,
>> 
>> While I think covenants for some kind of debt tool is mildly interesting and an appropriate solution, I wonder about this particular use-case.
>> 
>> It seems to me that, as either the `Transfer` signers or `Exit` signers are always involved, that the `Transfer` signers can be constrained so as to ensure that the rules are followed correctly, without requiring that covenants be used on the Bitcoin layer.
>> After all, the outputs of each transaction signed by the `Transfer` signers are part of the transaction that is being signed; surely the `Transfer` signers can validate that the output matches the contract expected, without requiring that fullnodes also validate this?
>> 
>> In particular, it seems to me that covenants are only useful if there exist some alternative that does not involve some kind of fixed `Transfer` signer set, but still requires a covenant.
>> Otherwise, the `Transfer` signer set could simply impose the rules by themselves.
>> 
>> 
>> Another thing is that, if my understanding is correct, the "sidechain" here is not in fact a sidechain; the "sidechain" transaction graph is published on the Bitcoin blockchain.
>> Instead, the `Transfer` signers simply validate some smart contract, most likely embedded as a pay-to-contract in the `pk(Alice)`/`pk(Bob)` public keys, and ensure that the smart contract is correctly executed.
>> In that case, it may be useful to consider Smart Contracts Unchained instead: https://zmnscpxj.github.io/bitcoin/unchained.html
>> 
>> It would be possible, under Smart Contracts Unchained, to keep the `Transfer`-signed transactions offchain, until `Exit`-signing.
>> Then, when this chain of transaction spends is presented to the participants, the participants can be convinced to sign a "cut-through" transaction that cuts through the offchain transactions, with the resulting cut-through being the one confirmed onchain, and signed only the participants, without the `Transfer` or `Exit` federation signatures appearing onchain.
>> This hides not only the smart contract being executed, but also the fact that a Smart Contracts Unchained technique was at all used.
>> 
>> Regards,
>> ZmnSCPxj
>> 
>> 
>> Sent with ProtonMail Secure Email.
>> 
>> ??????? Original Message ???????
>> On Saturday, June 29, 2019 1:53 PM, Tamas Blummer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> 
>>> I introduced you to gerneralized covenants[1] earlier, but in a domain specific context that de-routed us from technical discussion. Let me demonstrate the concept in a more generic use:
>>> 
>>> A covenant
>>> 
>>> or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
>>> 
>>> would put a coin under the alternative control of a Transfer and Exit keys together with the script in control of the current owner.
>>> Additional transaction level validations of transactions spending input with covenants apply as in [1]
>>> 
>>> Owner of such coins would be able to transfer them to others provided an addtional Transfer signature, in which case the coin remains encumbered with the same covenant.
>>> If Exit and owner signs the covenant is dropped on the output, it becomes a plain Bitcoin again.
>>> 
>>> The Thransfer and Exit signatures could be threshold signatures of a federation, whereby member decide if the proposed transfer transaction complies with whatever unique rules they impose.
>>> 
>>> The result is a federated side chain embedded into the Bitcoin block chain.
>>> 
>>> Bob could purchase some asset guarded by the federation with a transaction:
>>> 
>>> Inputs
>>> 100.0001 pk(Bob)
>>> 
>>> Outputs
>>> 0.1 or(and(pk(Transfer), pk(Bob)), and(pk(Exit), pk(Bob)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
>>> 99.9 pk(Transfer)
>>> 
>>> Transfer to Alice with consent of the transfer validators:
>>> 
>>> Inputs
>>> 0.1 or(and(pk(Transfer), pk(Bob)), and(pk(Exit), pk(Bob)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
>>> 100.001 pk(Alice)
>>> 
>>> Outputs
>>> 0.1 or(and(pk(Transfer), pk(Alice)), and(pk(Exit), pk(Alice)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
>>> 100 pk(Bob)
>>> 
>>> Alice might be approved to exit with the exit signature of the federation:
>>> 
>>> Inputs
>>> 0.1 or(and(pk(Transfer), pk(Alice)), and(pk(Exit), pk(Alice)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
>>> 99.9 pk(Transfer)
>>> 
>>> Outputs
>>> 99.9999 pk(Alice)
>>> 
>>> Tamas Blummer
>>> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017059.html
>> 
>> 
> 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190630/25c90620/attachment-0001.sig>

From tamas.blummer at gmail.com  Sun Jun 30 18:35:33 2019
From: tamas.blummer at gmail.com (Tamas Blummer)
Date: Sun, 30 Jun 2019 20:35:33 +0200
Subject: [bitcoin-dev] Generalized covenants with taproot enable
 riskless or risky lending,
 prevent credit inflation through fractional reserve
In-Reply-To: <83705370-79FC-4006-BA04-4782AD5BE70B@voskuil.org>
References: <0DBC0DEA-C999-4AEE-B2E1-D5337ECD9405@gmail.com>
	<7A10C0F5-E206-43C1-853F-64AE04F57711@voskuil.org>
	<EB743E28-8486-4CD5-B9AE-09B5693B27FA@gmail.com>
	<708D14A9-D25E-4DD2-8B6E-39A1194A7A00@voskuil.org>
	<1A808C88-63FD-4F45-8C95-2B8B4D99EDF5@gmail.com>
	<83705370-79FC-4006-BA04-4782AD5BE70B@voskuil.org>
Message-ID: <BF027CD0-FE29-4DD1-AB96-DE92B597AD18@gmail.com>


> On Jun 30, 2019, at 19:41, Eric Voskuil <eric at voskuil.org> wrote:
> 
> 
>> On Jun 30, 2019, at 03:56, Tamas Blummer <tamas.blummer at gmail.com> wrote:
>> 
>> Hi Eric,
>> 
>>> On Jun 29, 2019, at 23:21, Eric Voskuil <eric at voskuil.org> wrote:
>>> 
>>> What loan? Alice has paid Bob for something of no possible utility to her, or anyone else.
>>> 
>> 
>> Coins encumbered with the described covenant represent temporary control of a scarce resource.
>> 
>> Can this obtain value? That depends on the availability of final control and ability to deal with temporary control.
> 
> For something to become property (and therefore have marketable value) requires that it be both scarce and useful. Bitcoin is useful only to the extent that it can be traded for something else that is useful. Above you are only dealing with scarcity, ignoring utility.

There is a deeper utility of Bitcoin than it can be traded for something else. That utility is to use its unforgeable register.
We have only one kind of units in this register and by having covenants we would create other kinds that are while encumbered not fungible with the common ones.

Units are certainly less desirable if encumbered with a debt covenant. You say no one would assign them any value.

I am not that sure as they still offer the utility of using the unforgeable register, in this case a register of debt covered by reserves.
You also doubt forcing debt to be covered by reserves is a good idea, I got that, but suppose we do not discuss this here.
If there are people who think it is a good idea, then they would find having an unforgeable register of it useful and therefore units needed to maintain that register valuable to some extent.

> 
>> I think you do not show the neccesary respect of the market.
> 
> I?m not sure what is meant here by respect, or how much of it is necessary. I am merely explaining the market.
> 

You are not explaining an existing market but claim that market that is not yet there will follow your arguments.

>> Your rant reminds me of renowed economists who still argue final control Bitcoin can not have value, you do the same proclaiming that temporary control of Bitcoin can not have value.
> 
> It seems to me you have reversed the meaning of temporary and final. Bitcoin is useful because of the presumption that there is no finality of control. One presumes an ability to trade control of it for something else. This is temporary control. Final control would be the case in which, at some point, it can no longer be traded, making it worthless at that point. If this is known to be the case it implies that it it worthless at all prior points as well.
> 
> These are distinct scenarios. The fact that temporary (in my usage) control implies the possibility of value does not imply that finality of control does as well. The fact that (renowned or otherwise) people have made errors does not imply that I am making an error. These are both non-sequiturs.
> 
>> I say, that temporary control does not have value until means dealing with it are offered, and that is I work on. Thereafter might obtain value if final control is deemed too expensive or not attainable, we shall see.
> 
> The analogy to rental of a consumable good does not apply to the case of a non-consumable good. If it cannot be traded and cannot be consumed it cannot obtain marketable value. To this point it matters not whether it exists.
> 

I meant with control the control of entries in the register which I think is the deeper utility of Bitcoin. Final control is meant to be the opposite of temporary which is the time limited control with some expiry.

Thank you for your thoughts as they help to sharpen my arguments.

Best,

Tamas Blummer

> Best,
> Eric
> 
>> Tamas Blummer
>> 
>> 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190630/cf9f6ebc/attachment.sig>

From eric at voskuil.org  Sun Jun 30 18:54:45 2019
From: eric at voskuil.org (Eric Voskuil)
Date: Sun, 30 Jun 2019 11:54:45 -0700
Subject: [bitcoin-dev] Generalized covenants with taproot enable
	riskless or risky lending,
	prevent credit inflation through fractional reserve
In-Reply-To: <BF027CD0-FE29-4DD1-AB96-DE92B597AD18@gmail.com>
References: <0DBC0DEA-C999-4AEE-B2E1-D5337ECD9405@gmail.com>
	<7A10C0F5-E206-43C1-853F-64AE04F57711@voskuil.org>
	<EB743E28-8486-4CD5-B9AE-09B5693B27FA@gmail.com>
	<708D14A9-D25E-4DD2-8B6E-39A1194A7A00@voskuil.org>
	<1A808C88-63FD-4F45-8C95-2B8B4D99EDF5@gmail.com>
	<83705370-79FC-4006-BA04-4782AD5BE70B@voskuil.org>
	<BF027CD0-FE29-4DD1-AB96-DE92B597AD18@gmail.com>
Message-ID: <3F46CDD5-DA80-49C8-A51F-8066680EF347@voskuil.org>

Could you please explain the meaning and utility of ?unforgeable register? as it pertains to such encumbered coins?

The meaning in terms of Bitcoin is clear - the ?owner? of outputs that represent value (i.e. in the ability to trade them for something else) is recorded publicly and, given Bitcoin security assumptions, cannot be faked. What is not clear is the utility of a record of outputs that cannot be traded for something else. You seem to imply that a record is valuable simply because it?s a record.

e

> On Jun 30, 2019, at 11:35, Tamas Blummer <tamas.blummer at gmail.com> wrote:
> 
> 
>> On Jun 30, 2019, at 19:41, Eric Voskuil <eric at voskuil.org> wrote:
>> 
>> 
>>> On Jun 30, 2019, at 03:56, Tamas Blummer <tamas.blummer at gmail.com> wrote:
>>> 
>>> Hi Eric,
>>> 
>>>> On Jun 29, 2019, at 23:21, Eric Voskuil <eric at voskuil.org> wrote:
>>>> 
>>>> What loan? Alice has paid Bob for something of no possible utility to her, or anyone else.
>>>> 
>>> 
>>> Coins encumbered with the described covenant represent temporary control of a scarce resource.
>>> 
>>> Can this obtain value? That depends on the availability of final control and ability to deal with temporary control.
>> 
>> For something to become property (and therefore have marketable value) requires that it be both scarce and useful. Bitcoin is useful only to the extent that it can be traded for something else that is useful. Above you are only dealing with scarcity, ignoring utility.
> 
> There is a deeper utility of Bitcoin than it can be traded for something else. That utility is to use its unforgeable register.
> We have only one kind of units in this register and by having covenants we would create other kinds that are while encumbered not fungible with the common ones.
> 
> Units are certainly less desirable if encumbered with a debt covenant. You say no one would assign them any value.
> 
> I am not that sure as they still offer the utility of using the unforgeable register, in this case a register of debt covered by reserves.
> You also doubt forcing debt to be covered by reserves is a good idea, I got that, but suppose we do not discuss this here.
> If there are people who think it is a good idea, then they would find having an unforgeable register of it useful and therefore units needed to maintain that register valuable to some extent.
> 
>> 
>>> I think you do not show the neccesary respect of the market.
>> 
>> I?m not sure what is meant here by respect, or how much of it is necessary. I am merely explaining the market.
>> 
> 
> You are not explaining an existing market but claim that market that is not yet there will follow your arguments.
> 
>>> Your rant reminds me of renowed economists who still argue final control Bitcoin can not have value, you do the same proclaiming that temporary control of Bitcoin can not have value.
>> 
>> It seems to me you have reversed the meaning of temporary and final. Bitcoin is useful because of the presumption that there is no finality of control. One presumes an ability to trade control of it for something else. This is temporary control. Final control would be the case in which, at some point, it can no longer be traded, making it worthless at that point. If this is known to be the case it implies that it it worthless at all prior points as well.
>> 
>> These are distinct scenarios. The fact that temporary (in my usage) control implies the possibility of value does not imply that finality of control does as well. The fact that (renowned or otherwise) people have made errors does not imply that I am making an error. These are both non-sequiturs.
>> 
>>> I say, that temporary control does not have value until means dealing with it are offered, and that is I work on. Thereafter might obtain value if final control is deemed too expensive or not attainable, we shall see.
>> 
>> The analogy to rental of a consumable good does not apply to the case of a non-consumable good. If it cannot be traded and cannot be consumed it cannot obtain marketable value. To this point it matters not whether it exists.
>> 
> 
> I meant with control the control of entries in the register which I think is the deeper utility of Bitcoin. Final control is meant to be the opposite of temporary which is the time limited control with some expiry.
> 
> Thank you for your thoughts as they help to sharpen my arguments.
> 
> Best,
> 
> Tamas Blummer
> 
>> Best,
>> Eric
>> 
>>> Tamas Blummer
>>> 
>>> 
> 

From tamas.blummer at gmail.com  Sun Jun 30 19:55:41 2019
From: tamas.blummer at gmail.com (Tamas Blummer)
Date: Sun, 30 Jun 2019 21:55:41 +0200
Subject: [bitcoin-dev] Generalized covenants with taproot enable
 riskless or risky lending,
 prevent credit inflation through fractional reserve
In-Reply-To: <3F46CDD5-DA80-49C8-A51F-8066680EF347@voskuil.org>
References: <0DBC0DEA-C999-4AEE-B2E1-D5337ECD9405@gmail.com>
	<7A10C0F5-E206-43C1-853F-64AE04F57711@voskuil.org>
	<EB743E28-8486-4CD5-B9AE-09B5693B27FA@gmail.com>
	<708D14A9-D25E-4DD2-8B6E-39A1194A7A00@voskuil.org>
	<1A808C88-63FD-4F45-8C95-2B8B4D99EDF5@gmail.com>
	<83705370-79FC-4006-BA04-4782AD5BE70B@voskuil.org>
	<BF027CD0-FE29-4DD1-AB96-DE92B597AD18@gmail.com>
	<3F46CDD5-DA80-49C8-A51F-8066680EF347@voskuil.org>
Message-ID: <A4A6099F-F115-4CBF-B7D5-F16581476126@gmail.com>


> On Jun 30, 2019, at 20:54, Eric Voskuil <eric at voskuil.org> wrote:
> 
> Could you please explain the meaning and utility of ?unforgeable register? as it pertains to such encumbered coins?

I guess we agree that some way of keeping track of ownership is prerequisite for something to aquire value.
We likely also agree that the security of that ownership register has great influence to the value.

The question remains if a register as utility in itself gives value to the thing needed to use that register.
I think it does, if people are interested in what it keeps track of, for whatever reason, even for reasons you find bogus.

It was not intentional, but I think I just explained why Ethereum aquired higher market value by being register of ICO tokens.

Now back to the coins encumbered with the debt covenant:
Transactions moving them constitute a register of covered debt and you need them to update that register.
Should some people find such a register useful then those coins needed to update this register will aquire value.
Does not matter if you think the concept of covered debt is just as bogus as ICOs.

Here some good news: If they aquire value then they offer a way to generate income for hodler by temporarily giving up control.

Tamas Blummer

> 
> The meaning in terms of Bitcoin is clear - the ?owner? of outputs that represent value (i.e. in the ability to trade them for something else) is recorded publicly and, given Bitcoin security assumptions, cannot be faked. What is not clear is the utility of a record of outputs that cannot be traded for something else. You seem to imply that a record is valuable simply because it?s a record.
> 
> e
> 
>> On Jun 30, 2019, at 11:35, Tamas Blummer <tamas.blummer at gmail.com> wrote:
>> 
>> 
>>> On Jun 30, 2019, at 19:41, Eric Voskuil <eric at voskuil.org> wrote:
>>> 
>>> 
>>>> On Jun 30, 2019, at 03:56, Tamas Blummer <tamas.blummer at gmail.com> wrote:
>>>> 
>>>> Hi Eric,
>>>> 
>>>>> On Jun 29, 2019, at 23:21, Eric Voskuil <eric at voskuil.org> wrote:
>>>>> 
>>>>> What loan? Alice has paid Bob for something of no possible utility to her, or anyone else.
>>>>> 
>>>> 
>>>> Coins encumbered with the described covenant represent temporary control of a scarce resource.
>>>> 
>>>> Can this obtain value? That depends on the availability of final control and ability to deal with temporary control.
>>> 
>>> For something to become property (and therefore have marketable value) requires that it be both scarce and useful. Bitcoin is useful only to the extent that it can be traded for something else that is useful. Above you are only dealing with scarcity, ignoring utility.
>> 
>> There is a deeper utility of Bitcoin than it can be traded for something else. That utility is to use its unforgeable register.
>> We have only one kind of units in this register and by having covenants we would create other kinds that are while encumbered not fungible with the common ones.
>> 
>> Units are certainly less desirable if encumbered with a debt covenant. You say no one would assign them any value.
>> 
>> I am not that sure as they still offer the utility of using the unforgeable register, in this case a register of debt covered by reserves.
>> You also doubt forcing debt to be covered by reserves is a good idea, I got that, but suppose we do not discuss this here.
>> If there are people who think it is a good idea, then they would find having an unforgeable register of it useful and therefore units needed to maintain that register valuable to some extent.
>> 
>>> 
>>>> I think you do not show the neccesary respect of the market.
>>> 
>>> I?m not sure what is meant here by respect, or how much of it is necessary. I am merely explaining the market.
>>> 
>> 
>> You are not explaining an existing market but claim that market that is not yet there will follow your arguments.
>> 
>>>> Your rant reminds me of renowed economists who still argue final control Bitcoin can not have value, you do the same proclaiming that temporary control of Bitcoin can not have value.
>>> 
>>> It seems to me you have reversed the meaning of temporary and final. Bitcoin is useful because of the presumption that there is no finality of control. One presumes an ability to trade control of it for something else. This is temporary control. Final control would be the case in which, at some point, it can no longer be traded, making it worthless at that point. If this is known to be the case it implies that it it worthless at all prior points as well.
>>> 
>>> These are distinct scenarios. The fact that temporary (in my usage) control implies the possibility of value does not imply that finality of control does as well. The fact that (renowned or otherwise) people have made errors does not imply that I am making an error. These are both non-sequiturs.
>>> 
>>>> I say, that temporary control does not have value until means dealing with it are offered, and that is I work on. Thereafter might obtain value if final control is deemed too expensive or not attainable, we shall see.
>>> 
>>> The analogy to rental of a consumable good does not apply to the case of a non-consumable good. If it cannot be traded and cannot be consumed it cannot obtain marketable value. To this point it matters not whether it exists.
>>> 
>> 
>> I meant with control the control of entries in the register which I think is the deeper utility of Bitcoin. Final control is meant to be the opposite of temporary which is the time limited control with some expiry.
>> 
>> Thank you for your thoughts as they help to sharpen my arguments.
>> 
>> Best,
>> 
>> Tamas Blummer
>> 
>>> Best,
>>> Eric
>>> 
>>>> Tamas Blummer
>>>> 
>>>> 
>> 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190630/cdfe49a4/attachment-0001.sig>

From eric at voskuil.org  Sun Jun 30 20:13:02 2019
From: eric at voskuil.org (Eric Voskuil)
Date: Sun, 30 Jun 2019 13:13:02 -0700
Subject: [bitcoin-dev] Generalized covenants with taproot enable
	riskless or risky lending,
	prevent credit inflation through fractional reserve
In-Reply-To: <A4A6099F-F115-4CBF-B7D5-F16581476126@gmail.com>
References: <0DBC0DEA-C999-4AEE-B2E1-D5337ECD9405@gmail.com>
	<7A10C0F5-E206-43C1-853F-64AE04F57711@voskuil.org>
	<EB743E28-8486-4CD5-B9AE-09B5693B27FA@gmail.com>
	<708D14A9-D25E-4DD2-8B6E-39A1194A7A00@voskuil.org>
	<1A808C88-63FD-4F45-8C95-2B8B4D99EDF5@gmail.com>
	<83705370-79FC-4006-BA04-4782AD5BE70B@voskuil.org>
	<BF027CD0-FE29-4DD1-AB96-DE92B597AD18@gmail.com>
	<3F46CDD5-DA80-49C8-A51F-8066680EF347@voskuil.org>
	<A4A6099F-F115-4CBF-B7D5-F16581476126@gmail.com>
Message-ID: <063D7C06-F5D8-425B-80CE-CAE03A1AAD0C@voskuil.org>

ICO tokens can be traded (indefinitely) for other things of value, so the comparison isn?t valid. I think we?ve both made our points clearly, so I?ll leave it at that.

Best,
Eric

> On Jun 30, 2019, at 12:55, Tamas Blummer <tamas.blummer at gmail.com> wrote:
> 
> 
>> On Jun 30, 2019, at 20:54, Eric Voskuil <eric at voskuil.org> wrote:
>> 
>> Could you please explain the meaning and utility of ?unforgeable register? as it pertains to such encumbered coins?
> 
> I guess we agree that some way of keeping track of ownership is prerequisite for something to aquire value.
> We likely also agree that the security of that ownership register has great influence to the value.
> 
> The question remains if a register as utility in itself gives value to the thing needed to use that register.
> I think it does, if people are interested in what it keeps track of, for whatever reason, even for reasons you find bogus.
> 
> It was not intentional, but I think I just explained why Ethereum aquired higher market value by being register of ICO tokens.
> 
> Now back to the coins encumbered with the debt covenant:
> Transactions moving them constitute a register of covered debt and you need them to update that register.
> Should some people find such a register useful then those coins needed to update this register will aquire value.
> Does not matter if you think the concept of covered debt is just as bogus as ICOs.
> 
> Here some good news: If they aquire value then they offer a way to generate income for hodler by temporarily giving up control.
> 
> Tamas Blummer
> 
>> 
>> The meaning in terms of Bitcoin is clear - the ?owner? of outputs that represent value (i.e. in the ability to trade them for something else) is recorded publicly and, given Bitcoin security assumptions, cannot be faked. What is not clear is the utility of a record of outputs that cannot be traded for something else. You seem to imply that a record is valuable simply because it?s a record.
>> 
>> e
>> 
>>> On Jun 30, 2019, at 11:35, Tamas Blummer <tamas.blummer at gmail.com> wrote:
>>> 
>>> 
>>>> On Jun 30, 2019, at 19:41, Eric Voskuil <eric at voskuil.org> wrote:
>>>> 
>>>> 
>>>>> On Jun 30, 2019, at 03:56, Tamas Blummer <tamas.blummer at gmail.com> wrote:
>>>>> 
>>>>> Hi Eric,
>>>>> 
>>>>>> On Jun 29, 2019, at 23:21, Eric Voskuil <eric at voskuil.org> wrote:
>>>>>> 
>>>>>> What loan? Alice has paid Bob for something of no possible utility to her, or anyone else.
>>>>>> 
>>>>> 
>>>>> Coins encumbered with the described covenant represent temporary control of a scarce resource.
>>>>> 
>>>>> Can this obtain value? That depends on the availability of final control and ability to deal with temporary control.
>>>> 
>>>> For something to become property (and therefore have marketable value) requires that it be both scarce and useful. Bitcoin is useful only to the extent that it can be traded for something else that is useful. Above you are only dealing with scarcity, ignoring utility.
>>> 
>>> There is a deeper utility of Bitcoin than it can be traded for something else. That utility is to use its unforgeable register.
>>> We have only one kind of units in this register and by having covenants we would create other kinds that are while encumbered not fungible with the common ones.
>>> 
>>> Units are certainly less desirable if encumbered with a debt covenant. You say no one would assign them any value.
>>> 
>>> I am not that sure as they still offer the utility of using the unforgeable register, in this case a register of debt covered by reserves.
>>> You also doubt forcing debt to be covered by reserves is a good idea, I got that, but suppose we do not discuss this here.
>>> If there are people who think it is a good idea, then they would find having an unforgeable register of it useful and therefore units needed to maintain that register valuable to some extent.
>>> 
>>>> 
>>>>> I think you do not show the neccesary respect of the market.
>>>> 
>>>> I?m not sure what is meant here by respect, or how much of it is necessary. I am merely explaining the market.
>>>> 
>>> 
>>> You are not explaining an existing market but claim that market that is not yet there will follow your arguments.
>>> 
>>>>> Your rant reminds me of renowed economists who still argue final control Bitcoin can not have value, you do the same proclaiming that temporary control of Bitcoin can not have value.
>>>> 
>>>> It seems to me you have reversed the meaning of temporary and final. Bitcoin is useful because of the presumption that there is no finality of control. One presumes an ability to trade control of it for something else. This is temporary control. Final control would be the case in which, at some point, it can no longer be traded, making it worthless at that point. If this is known to be the case it implies that it it worthless at all prior points as well.
>>>> 
>>>> These are distinct scenarios. The fact that temporary (in my usage) control implies the possibility of value does not imply that finality of control does as well. The fact that (renowned or otherwise) people have made errors does not imply that I am making an error. These are both non-sequiturs.
>>>> 
>>>>> I say, that temporary control does not have value until means dealing with it are offered, and that is I work on. Thereafter might obtain value if final control is deemed too expensive or not attainable, we shall see.
>>>> 
>>>> The analogy to rental of a consumable good does not apply to the case of a non-consumable good. If it cannot be traded and cannot be consumed it cannot obtain marketable value. To this point it matters not whether it exists.
>>>> 
>>> 
>>> I meant with control the control of entries in the register which I think is the deeper utility of Bitcoin. Final control is meant to be the opposite of temporary which is the time limited control with some expiry.
>>> 
>>> Thank you for your thoughts as they help to sharpen my arguments.
>>> 
>>> Best,
>>> 
>>> Tamas Blummer
>>> 
>>>> Best,
>>>> Eric
>>>> 
>>>>> Tamas Blummer
>>>>> 
>>>>> 
>>> 
> 

From tamas.blummer at gmail.com  Sun Jun 30 20:26:29 2019
From: tamas.blummer at gmail.com (Tamas Blummer)
Date: Sun, 30 Jun 2019 22:26:29 +0200
Subject: [bitcoin-dev] Generalized covenants with taproot enable
 riskless or risky lending,
 prevent credit inflation through fractional reserve
In-Reply-To: <063D7C06-F5D8-425B-80CE-CAE03A1AAD0C@voskuil.org>
References: <0DBC0DEA-C999-4AEE-B2E1-D5337ECD9405@gmail.com>
	<7A10C0F5-E206-43C1-853F-64AE04F57711@voskuil.org>
	<EB743E28-8486-4CD5-B9AE-09B5693B27FA@gmail.com>
	<708D14A9-D25E-4DD2-8B6E-39A1194A7A00@voskuil.org>
	<1A808C88-63FD-4F45-8C95-2B8B4D99EDF5@gmail.com>
	<83705370-79FC-4006-BA04-4782AD5BE70B@voskuil.org>
	<BF027CD0-FE29-4DD1-AB96-DE92B597AD18@gmail.com>
	<3F46CDD5-DA80-49C8-A51F-8066680EF347@voskuil.org>
	<A4A6099F-F115-4CBF-B7D5-F16581476126@gmail.com>
	<063D7C06-F5D8-425B-80CE-CAE03A1AAD0C@voskuil.org>
Message-ID: <0AA10217-E1CC-46D1-9B43-038CEEF942CD@gmail.com>

My argument does not need the comparison with ICOs.

They were just an example that people pay for the utility of register even though others think the tokens they keep track of are worthless.

Tamas Blummer


> On Jun 30, 2019, at 22:13, Eric Voskuil <eric at voskuil.org> wrote:
> 
> ICO tokens can be traded (indefinitely) for other things of value, so the comparison isn?t valid. I think we?ve both made our points clearly, so I?ll leave it at that.
> 
> Best,
> Eric
> 
>> On Jun 30, 2019, at 12:55, Tamas Blummer <tamas.blummer at gmail.com> wrote:
>> 
>> 
>>> On Jun 30, 2019, at 20:54, Eric Voskuil <eric at voskuil.org> wrote:
>>> 
>>> Could you please explain the meaning and utility of ?unforgeable register? as it pertains to such encumbered coins?
>> 
>> I guess we agree that some way of keeping track of ownership is prerequisite for something to aquire value.
>> We likely also agree that the security of that ownership register has great influence to the value.
>> 
>> The question remains if a register as utility in itself gives value to the thing needed to use that register.
>> I think it does, if people are interested in what it keeps track of, for whatever reason, even for reasons you find bogus.
>> 
>> It was not intentional, but I think I just explained why Ethereum aquired higher market value by being register of ICO tokens.
>> 
>> Now back to the coins encumbered with the debt covenant:
>> Transactions moving them constitute a register of covered debt and you need them to update that register.
>> Should some people find such a register useful then those coins needed to update this register will aquire value.
>> Does not matter if you think the concept of covered debt is just as bogus as ICOs.
>> 
>> Here some good news: If they aquire value then they offer a way to generate income for hodler by temporarily giving up control.
>> 
>> Tamas Blummer
>> 
>>> 
>>> The meaning in terms of Bitcoin is clear - the ?owner? of outputs that represent value (i.e. in the ability to trade them for something else) is recorded publicly and, given Bitcoin security assumptions, cannot be faked. What is not clear is the utility of a record of outputs that cannot be traded for something else. You seem to imply that a record is valuable simply because it?s a record.
>>> 
>>> e
>>> 
>>>> On Jun 30, 2019, at 11:35, Tamas Blummer <tamas.blummer at gmail.com> wrote:
>>>> 
>>>> 
>>>>> On Jun 30, 2019, at 19:41, Eric Voskuil <eric at voskuil.org> wrote:
>>>>> 
>>>>> 
>>>>>> On Jun 30, 2019, at 03:56, Tamas Blummer <tamas.blummer at gmail.com> wrote:
>>>>>> 
>>>>>> Hi Eric,
>>>>>> 
>>>>>>> On Jun 29, 2019, at 23:21, Eric Voskuil <eric at voskuil.org> wrote:
>>>>>>> 
>>>>>>> What loan? Alice has paid Bob for something of no possible utility to her, or anyone else.
>>>>>>> 
>>>>>> 
>>>>>> Coins encumbered with the described covenant represent temporary control of a scarce resource.
>>>>>> 
>>>>>> Can this obtain value? That depends on the availability of final control and ability to deal with temporary control.
>>>>> 
>>>>> For something to become property (and therefore have marketable value) requires that it be both scarce and useful. Bitcoin is useful only to the extent that it can be traded for something else that is useful. Above you are only dealing with scarcity, ignoring utility.
>>>> 
>>>> There is a deeper utility of Bitcoin than it can be traded for something else. That utility is to use its unforgeable register.
>>>> We have only one kind of units in this register and by having covenants we would create other kinds that are while encumbered not fungible with the common ones.
>>>> 
>>>> Units are certainly less desirable if encumbered with a debt covenant. You say no one would assign them any value.
>>>> 
>>>> I am not that sure as they still offer the utility of using the unforgeable register, in this case a register of debt covered by reserves.
>>>> You also doubt forcing debt to be covered by reserves is a good idea, I got that, but suppose we do not discuss this here.
>>>> If there are people who think it is a good idea, then they would find having an unforgeable register of it useful and therefore units needed to maintain that register valuable to some extent.
>>>> 
>>>>> 
>>>>>> I think you do not show the neccesary respect of the market.
>>>>> 
>>>>> I?m not sure what is meant here by respect, or how much of it is necessary. I am merely explaining the market.
>>>>> 
>>>> 
>>>> You are not explaining an existing market but claim that market that is not yet there will follow your arguments.
>>>> 
>>>>>> Your rant reminds me of renowed economists who still argue final control Bitcoin can not have value, you do the same proclaiming that temporary control of Bitcoin can not have value.
>>>>> 
>>>>> It seems to me you have reversed the meaning of temporary and final. Bitcoin is useful because of the presumption that there is no finality of control. One presumes an ability to trade control of it for something else. This is temporary control. Final control would be the case in which, at some point, it can no longer be traded, making it worthless at that point. If this is known to be the case it implies that it it worthless at all prior points as well.
>>>>> 
>>>>> These are distinct scenarios. The fact that temporary (in my usage) control implies the possibility of value does not imply that finality of control does as well. The fact that (renowned or otherwise) people have made errors does not imply that I am making an error. These are both non-sequiturs.
>>>>> 
>>>>>> I say, that temporary control does not have value until means dealing with it are offered, and that is I work on. Thereafter might obtain value if final control is deemed too expensive or not attainable, we shall see.
>>>>> 
>>>>> The analogy to rental of a consumable good does not apply to the case of a non-consumable good. If it cannot be traded and cannot be consumed it cannot obtain marketable value. To this point it matters not whether it exists.
>>>>> 
>>>> 
>>>> I meant with control the control of entries in the register which I think is the deeper utility of Bitcoin. Final control is meant to be the opposite of temporary which is the time limited control with some expiry.
>>>> 
>>>> Thank you for your thoughts as they help to sharpen my arguments.
>>>> 
>>>> Best,
>>>> 
>>>> Tamas Blummer
>>>> 
>>>>> Best,
>>>>> Eric
>>>>> 
>>>>>> Tamas Blummer
>>>>>> 
>>>>>> 
>>>> 
>> 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190630/b632dbbf/attachment.sig>

From tamas.blummer at gmail.com  Sun Jun 30 22:25:03 2019
From: tamas.blummer at gmail.com (Tamas Blummer)
Date: Mon, 1 Jul 2019 00:25:03 +0200
Subject: [bitcoin-dev] Generalized covenant to implement side chains
 embedded into the bitcoin block chain
In-Reply-To: <E736009F-50EE-4A0E-BD1A-F963A7820FA1@gmail.com>
References: <7856AC5A-D2AD-4C94-99BC-AA0F948E2B40@gmail.com>
	<_H2l-XejXP1xbWnnuxmn6V6YlA6KYbN-7f_nYF32W609BvQANEiJYVq9z0DWvQVAFTmKHlzwVPiHiRBT0XETT7UJi0syxXMxXN4HskUDHW4=@protonmail.com>
	<A048BAB4-9166-40BD-BC70-7FCE47F00D72@gmail.com>
	<E736009F-50EE-4A0E-BD1A-F963A7820FA1@gmail.com>
Message-ID: <A124C836-8EEC-49C6-9CF1-35A88170F040@gmail.com>

Any meaningful covenant must be one that is reducing control by the current owner.

I can think of countless predicates reducing control, but try to explore the least invasive first,
and see if they unlock a new use.

Offering alternate control paths is what taproot was designed for, therefore a covenant
that requires that a control path is inherited seems a fit. That is all the
debt covenant needs.

There are other predicates with exciting use, such as one on total work performed by miner
which I tried to explore earlier. Pieter Wuille said it could be a candidate for the annex.

Tamas Blummer


> On Jun 30, 2019, at 19:50, Tamas Blummer <tamas.blummer at gmail.com> wrote:
> 
> I made an error proposing the new covenant. It should be unchanged as in the original example:
> 
> ?covenant or(and(_, pk(Transfer)) covenant transitive, and(pk(Exit), _) covenant drop)?
> 
> since the placeholder stays for the control of the rightful owner without transfer signature on or off chain.
> 
> The exit could be alternatively automatic allowing to exit a stalling unchained platform:
> 
> ?covenant or(and(_, pk(Transfer)) covenant transitive, and(delay(100), _) covenant drop)?
> 
> There remains the question why the rightful owner is not enforcing the covenant instead of having it enforced by on-chain consensus.
> 
> I do not yet have a good answer for that as in contrast to the debt example, here it is aligned with the interest of the current owner to have the covenant.
> 
> Tamas Blummer
> 
>> On Jun 30, 2019, at 18:57, Tamas Blummer <tamas.blummer at gmail.com> wrote:
>> 
>> Hello ZmnSCPxj,
>> 
>> Yes, representation of debt is more interesting here as it requires the covenant, wheras this example, as you point out, was less convincing given alternatives.
>> I created this example to avoid discussion of topics not approriate on this list.
>> 
>> Thank you for the suggestion of unchained execution of transfers with cut-through exit transaction as this made the example much stronger:
>> 
>> The most important question for someone who trusts his coins to some unchained platform is probably the question of how exit is guaranteed if one is unhappy with what one gets.
>> 
>> With the exit covenant exit conditions are set in stone, since validated on-chain. If the exit key is owned by a trusted arbiter other than the federation governing the unchained platform
>> then one at least have the option to cut losses at some point by presenting the arbiter a chain of valid transactions and asking to sign the exit.
>> 
>> Participants in the unchained platform would also be interested to regularly snapshot the economic effect of offchain transactions with cut-through transactions as such cut-through shortens the chain of transactions
>> they would need to get on chain if chosing the exit without consent of the federation governing the transfers.
>> 
>> So the convenant needed is: 'covenant or(_ covenant transitive, and(pkExit, _) covenant drop)' which gives unrestricted flexibility to the unchained platform with the exception that it has to maintain the exit option.
>> 
>> 
>> Tamas Blummer
>> 
>> 
>>> On Jun 29, 2019, at 22:25, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>>> 
>>> Good morning Tamas,
>>> 
>>> While I think covenants for some kind of debt tool is mildly interesting and an appropriate solution, I wonder about this particular use-case.
>>> 
>>> It seems to me that, as either the `Transfer` signers or `Exit` signers are always involved, that the `Transfer` signers can be constrained so as to ensure that the rules are followed correctly, without requiring that covenants be used on the Bitcoin layer.
>>> After all, the outputs of each transaction signed by the `Transfer` signers are part of the transaction that is being signed; surely the `Transfer` signers can validate that the output matches the contract expected, without requiring that fullnodes also validate this?
>>> 
>>> In particular, it seems to me that covenants are only useful if there exist some alternative that does not involve some kind of fixed `Transfer` signer set, but still requires a covenant.
>>> Otherwise, the `Transfer` signer set could simply impose the rules by themselves.
>>> 
>>> 
>>> Another thing is that, if my understanding is correct, the "sidechain" here is not in fact a sidechain; the "sidechain" transaction graph is published on the Bitcoin blockchain.
>>> Instead, the `Transfer` signers simply validate some smart contract, most likely embedded as a pay-to-contract in the `pk(Alice)`/`pk(Bob)` public keys, and ensure that the smart contract is correctly executed.
>>> In that case, it may be useful to consider Smart Contracts Unchained instead: https://zmnscpxj.github.io/bitcoin/unchained.html
>>> 
>>> It would be possible, under Smart Contracts Unchained, to keep the `Transfer`-signed transactions offchain, until `Exit`-signing.
>>> Then, when this chain of transaction spends is presented to the participants, the participants can be convinced to sign a "cut-through" transaction that cuts through the offchain transactions, with the resulting cut-through being the one confirmed onchain, and signed only the participants, without the `Transfer` or `Exit` federation signatures appearing onchain.
>>> This hides not only the smart contract being executed, but also the fact that a Smart Contracts Unchained technique was at all used.
>>> 
>>> Regards,
>>> ZmnSCPxj
>>> 
>>> 
>>> Sent with ProtonMail Secure Email.
>>> 
>>> ??????? Original Message ???????
>>> On Saturday, June 29, 2019 1:53 PM, Tamas Blummer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>> 
>>>> I introduced you to gerneralized covenants[1] earlier, but in a domain specific context that de-routed us from technical discussion. Let me demonstrate the concept in a more generic use:
>>>> 
>>>> A covenant
>>>> 
>>>> or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
>>>> 
>>>> would put a coin under the alternative control of a Transfer and Exit keys together with the script in control of the current owner.
>>>> Additional transaction level validations of transactions spending input with covenants apply as in [1]
>>>> 
>>>> Owner of such coins would be able to transfer them to others provided an addtional Transfer signature, in which case the coin remains encumbered with the same covenant.
>>>> If Exit and owner signs the covenant is dropped on the output, it becomes a plain Bitcoin again.
>>>> 
>>>> The Thransfer and Exit signatures could be threshold signatures of a federation, whereby member decide if the proposed transfer transaction complies with whatever unique rules they impose.
>>>> 
>>>> The result is a federated side chain embedded into the Bitcoin block chain.
>>>> 
>>>> Bob could purchase some asset guarded by the federation with a transaction:
>>>> 
>>>> Inputs
>>>> 100.0001 pk(Bob)
>>>> 
>>>> Outputs
>>>> 0.1 or(and(pk(Transfer), pk(Bob)), and(pk(Exit), pk(Bob)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
>>>> 99.9 pk(Transfer)
>>>> 
>>>> Transfer to Alice with consent of the transfer validators:
>>>> 
>>>> Inputs
>>>> 0.1 or(and(pk(Transfer), pk(Bob)), and(pk(Exit), pk(Bob)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
>>>> 100.001 pk(Alice)
>>>> 
>>>> Outputs
>>>> 0.1 or(and(pk(Transfer), pk(Alice)), and(pk(Exit), pk(Alice)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
>>>> 100 pk(Bob)
>>>> 
>>>> Alice might be approved to exit with the exit signature of the federation:
>>>> 
>>>> Inputs
>>>> 0.1 or(and(pk(Transfer), pk(Alice)), and(pk(Exit), pk(Alice)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
>>>> 99.9 pk(Transfer)
>>>> 
>>>> Outputs
>>>> 99.9999 pk(Alice)
>>>> 
>>>> Tamas Blummer
>>>> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017059.html
>>> 
>>> 
>> 
> 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190701/783d02da/attachment.sig>

