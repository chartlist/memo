From erik at q32.com  Tue May  2 16:54:35 2017
From: erik at q32.com (Erik Aronesty)
Date: Tue, 2 May 2017 12:54:35 -0400
Subject: [bitcoin-dev] I do not support the BIP 148 UASF
In-Reply-To: <201704251846.10793.luke@dashjr.org>
References: <CAAS2fgRdSOu8N6L3+fBpnye+rM+W6+F=cePy=9oL4tJuCj=Jsw@mail.gmail.com>
	<X8k9ENqIddjVtibis1I8dLjHNxIUao0rLwZzpyoCNuWlc6Umgu7huGsbBWGhVY6Jd2XEUOVO8MxkgYKTyaNJ23nJbrE8dz7b8JKTBoE5Ljo=@protonmail.ch>
	<CAAS2fgQzd9J3iNMRfW+x1QnqMFAHx89+GTXEt0SWm6+USZniDA@mail.gmail.com>
	<201704251846.10793.luke@dashjr.org>
Message-ID: <CAJowKg+zdXgeBAmY4WhW-P3WWfqze7G+B3AAwxxVtKeTsoB81g@mail.gmail.com>

If the flag day for a wtxid commitment is timed before the current segwit
period end, I suspect segwit would activate within the current period.

On Tue, Apr 25, 2017 at 2:46 PM, Luke Dashjr via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Tuesday 25 April 2017 6:28:14 PM Gregory Maxwell via bitcoin-dev wrote:
> > > https://github.com/bitcoin/bitcoin/compare/master...
> shaolinfry:uasegwit-f
> > > lagday
> > >
> > > I believe this approach would satisfy the more measured approach
> expected
> > > for Bitcoin and does not have the issues you brought up about BIP148.
> >
> > I have not reviewed it carefully yet, but I agree that it addresses my
> > main concern!  I think this is a much better approach. Thanks.
>
> FWIW, I disagree in this case. I think given the circumstances, if we are
> going to do a UASF for segwit at all, we need a clearly decisive outcome,
> which is given by BIP 148. Using the approach in BIP 8 makes sense in many
> cases, but in this case, it is liable to simply create a prolonged
> uncertainty
> where nobody knows the outcome when segwit's rules are challenged by a
> malicious miner.
>
> If BIP 148 fails to achieve widespread support, we could do a BIP 8-based
> UASF
> with Segwit v2 (along with some other changes I suggested in the other
> thread), but I think the tradeoffs right now favour BIP 148 as the best
> UASF
> deployment.
>
> Luke
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170502/0cee5728/attachment.html>

From erik at q32.com  Wed May  3 14:03:58 2017
From: erik at q32.com (Erik Aronesty)
Date: Wed, 3 May 2017 10:03:58 -0400
Subject: [bitcoin-dev] Small Nodes: A Better Alternative to Pruned Nodes
In-Reply-To: <CAAS2fgT5pJh68xufv_81+N8K0asxH16WdX7PLLXGjRPmJOkYFQ@mail.gmail.com>
References: <CAFVRnypbQQ-vsSLqv48cYaqTCty4R1DmFRqfAvxe4mAqyQNXxQ@mail.gmail.com>
	<CAAS2fgT5pJh68xufv_81+N8K0asxH16WdX7PLLXGjRPmJOkYFQ@mail.gmail.com>
Message-ID: <CAJowKg+UTKeU0Dj5pJbtw+LZtO9kn5LBJum9Akd11zCsW+6o4Q@mail.gmail.com>

> But as you've observed, the failure probabilities are rather high,
> especially if an active attacker targets nodes carrying less commonly
> available blocks.

Wouldn't the solution be for nodes to use whatever mechanism an attacker
uses to determine less commonly available blocks and choose to store a
random percentage of them as well as their deterministic random set?

IE X blocks end of chain (spv bootstrap), Y% deterministic random set,  Z%
patch/fill set to deter attacks
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170503/f9489c19/attachment.html>

From natanael.l at gmail.com  Wed May  3 19:10:47 2017
From: natanael.l at gmail.com (Natanael)
Date: Wed, 3 May 2017 21:10:47 +0200
Subject: [bitcoin-dev] Small Nodes: A Better Alternative to Pruned Nodes
In-Reply-To: <CAJowKg+UTKeU0Dj5pJbtw+LZtO9kn5LBJum9Akd11zCsW+6o4Q@mail.gmail.com>
References: <CAFVRnypbQQ-vsSLqv48cYaqTCty4R1DmFRqfAvxe4mAqyQNXxQ@mail.gmail.com>
	<CAAS2fgT5pJh68xufv_81+N8K0asxH16WdX7PLLXGjRPmJOkYFQ@mail.gmail.com>
	<CAJowKg+UTKeU0Dj5pJbtw+LZtO9kn5LBJum9Akd11zCsW+6o4Q@mail.gmail.com>
Message-ID: <CAAt2M1_TH=1Xw=65QxxCHMZzE-fzC3UhRaEk+KkKY2SHkN6CbQ@mail.gmail.com>

Den 3 maj 2017 16:05 skrev "Erik Aronesty via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org>:

> But as you've observed, the failure probabilities are rather high,
> especially if an active attacker targets nodes carrying less commonly
> available blocks.

Wouldn't the solution be for nodes to use whatever mechanism an attacker
uses to determine less commonly available blocks and choose to store a
random percentage of them as well as their deterministic random set?

IE X blocks end of chain (spv bootstrap), Y% deterministic random set,  Z%
patch/fill set to deter attacks


Then he uses Sybil attacks to obscure what's actually rare and not. Even
proof of storage isn't enough, you need proof of INDEPENDENT storage, which
is essentially impossible, as well as a way of determining which nodes are
run by the same people (all the AWS nodes should essentially count as one).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170503/c4844326/attachment.html>

From erik at q32.com  Wed May  3 19:41:07 2017
From: erik at q32.com (Erik Aronesty)
Date: Wed, 3 May 2017 15:41:07 -0400
Subject: [bitcoin-dev] Transaction signalling
In-Reply-To: <CAJowKgK=B2=fSwz5cqPLzMtyo-uDiNCOy9q+C39DJkaQ5h8U_Q@mail.gmail.com>
References: <CAJowKgJ38kA_vPGF6KpKEnrRzStrk-Mj87bttaOw-dvLW675Jw@mail.gmail.com>
	<CAJowKgK4j=sL2vh1bxWh2WWw0vw1PuxfJ39JW7bQS-UDzKh6CQ@mail.gmail.com>
	<CAJowKgKAnrMKiLdONrXJtGQYhYgRSXq7JNWrY=zUEMvw4WSX9w@mail.gmail.com>
	<CAJowKgL-NB0zF-Ud52Jr6n0Fo-uV=bXzVAFMOKmhAVA0RdRVuQ@mail.gmail.com>
	<CAJowKgJGZJMondTmsdOLdqqY1mf9S+TaB8UmdCtsLF6PA2RSJw@mail.gmail.com>
	<CAJowKg+gZcNO+-sdmt55KOt+zuN+8m7Hiqh77s9=gYpyszDwmA@mail.gmail.com>
	<CAJowKgKC4+6vv0QUH_DRASVqU4jui-iXG6TDgEpGUHRkVwJFqg@mail.gmail.com>
	<CAJowKgKH2h1QwpEvZ30OuEUsTCg1OoD6JcuXdmS+d_pKpygFcQ@mail.gmail.com>
	<CAJowKg+EJGXA5=LjJhCo1YevQtBubEftSNPfnzE4b5ESCwrUMg@mail.gmail.com>
	<CAJowKgLQCqL37oCzkJc8gPnUCkPYtF6G8_7Ug4AP5FpTOonBWQ@mail.gmail.com>
	<CAJowKgJ-eoF6ZCKrWbJQDcMK8-jTZxD+J_6tGAyfXz+HYrqmXg@mail.gmail.com>
	<CAJowKgKEVxS9OCg=Lioc1gRAy1Ftc27bp3nr2R9MQX-VQ9PrhQ@mail.gmail.com>
	<CALxbBHVY6_Xuq4Si9yQ0+dL_9DTCdwiWLDFStzFO2xRvHzTyBQ@mail.gmail.com>
	<1492554557.1625.4.camel@mmci.uni-saarland.de>
	<CAJowKgK=B2=fSwz5cqPLzMtyo-uDiNCOy9q+C39DJkaQ5h8U_Q@mail.gmail.com>
Message-ID: <CAJowKgK1303atiQ8pKZkj2C2_eb_COU4eb3nc9uJNP2i2=-KCw@mail.gmail.com>

BIP XXXX : User activated features (ROUGH OVERVIEW)

A proposed change to a usage of the 'OP_RETURN' script opcode in Bitcoin
transactions, allowing multiple changes (features) to be deployed in
parallel. It relies on interpreting the output field as a bit vector, where
each bit can be used to track an independent change. Like BIP9, once a
consensus change succeeds or times out, there is a "fallow" pause after
which the bit can be reused for later changes.

==Motivation==

BIP 9 introduced a mechanism for doing soft-forking changes, relying on
measuring miner support indicated by version bits in block headers. As it
relies on miner support, any change which may conflict with miners but is
acceptable to users may be difficult to deploy.   The alternative, a
flag-day deployment can cause issues for users of a feature that has failed
to achieve adequate miner support.

BIP XXXX, if used for deployment, can be used in conjunction with BIP 9, in
order to more safely deploy soft-forking changes that do not require a
supermajority of miners, but do require a large percentage of active
users.

Alternatively, BIP XXXX signalling can be used to gauge user support for
"features" - independent of its use as a direct deployment mechanism.   In
this document a "feature" can be considered synonymous with "soft fork",
but since this mechanism is "user activated", it is not necessarily
restricted to soft-forks.

==Specification==

Each "feature" is specified by the sames set of per-chain parameters as in
BIP9, with the same usage and meaning (name, bit, starttime and timeout).

===Bit flags===

If the outputs contain a zero valued OP_RETURN, and the length of the key
is 2 bytes, and if the first byte (prefix) of that OP_RETURN's key
parameter is 0x012, then the remaining byte is to be interpreted as an
8-bit little-endian integer, and bits are selected within this integer as
values (1 << N) where N is the bit number.  This allows up to 8 features to
be in the STARTED state at a time.

===Array determination===

In order for this to successfully be used for deployment, a lightweight
UTXO must be maintained in memory.   For each bit in STARTED state, a
corresponding bit is set in a map entry for each input address.   Each
input address is hashed to a 24 bit value using SHA3-256(input)[0:24].  An
array with 16777216 2-byte entries (~32MB RAM) is used to record the
current activation state.   The first byte contains the bit flags most
recently associated with an entry.

The second byte contains the log base 2 of the number of "1/100th" bitcoins
most recently associated with this entry.   This is computed by taking the
value, multiplying by 100, converting to an unsigned 32 bit integer, and
using the log2_32 function below (.... log2_32 func defined below ....).

This array is initialized to zero.   The array must be stored and
maintained for each block.  When a block is in the STARTED state for any
bit, the array is updated for each transaction in the block according to
the rules above: a[i][0]=bits, a[i][1]=log2_32(....)

===State transitions===

State transitions work the same as BIP9, however, the determination of the
LOCKED_IN tally is as follows:

For each bit in STARTED state, using the array above, the values are
totaled (unsigned int)(2 << a[i][1]) for each entry where this bit is set
in a[i][0].  In addition the total of all the entries in a, irrespective of
bit, are computed.   This can be done in a single pass, resulting in a
vector of up to 8 32 bit entries containing the "feature totals" for the
array, and one extra 32 bit entry for the sum total of observations since
the start time.

The percentage of observations is computed for each bit.   Up to 8 features
can be computed at a time, with reuse similar to BIP9.

If 2016 sequential blocks have a value of 95% or greater, a feature is
"LOCKED_IN", (75% on testnet)
bit.

Similar to BIP9, a block's state never depends on its own transactions set;
only on that of its ancestors.  ACTIVE and FAILED are terminal states, etc.


On Thu, Apr 20, 2017 at 12:14 PM, Erik Aronesty <erik at q32.com> wrote:

> I agree, addresses create vulnerability, an OP_RETURN signal seems the
> safest way to go for UA signalling.   I can model a BIP after BIP9, with
> some discussion of how to properly collect statistics, and the ability for
> nodes to activate features based on an "economic majority" defined in this
> way.
>
> On Tue, Apr 18, 2017 at 6:29 PM, Tim Ruffing via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> I don't have an opinion on whether signaling is a good idea in general.
>>
>> However I don't think that using addresses is a good idea, because this
>> has privacy implications. For example, it makes it much easier to link
>> the addresses, e.g., inputs with change address. (The change address
>> votes for the same proposal as the input address.)
>>
>> Tim
>>
>> On Tue, 2017-04-18 at 18:07 +0000, Christian Decker via bitcoin-dev
>> wrote:
>> > I really like the idea of extending signalling capabilities to the
>> > end-users. It gives stakeholders a voice in the decisions we take in
>> > the network, and are a clear signal to all other involved parties. It
>> > reminds me of a student thesis I supervised some time ago [1], in
>> > which we explored various signalling ideas.
>> >
>> > I think we have a number of fields that may be used for such a
>> > signalling, e.g., OP_RETURN, locktime, and output scripts. I think
>> > OP_RETURN is probably not the field you'd want to use though since it
>> > adds data that needs to be transferred, stored for bootstrap, and
>> > outputs in the UTXO would need to be tagged with additional
>> > information. Locktime has the advantage of being mostly a freeform
>> > field for values in the past, but it clashes with other uses that may
>> > rely on it. Furthermore, it is the transaction creator that specifies
>> > the locktime, hence the signal trails one hop behind the current
>> > owner, i.e., the actual stakeholder.
>> >
>> > I think probably the best field to signal would be the output
>> > script. It is specified by the recipient of the funds, i.e., the
>> > current owner, and is already stored in the UTXO, so a single pass
>> > can
>> > tally up the votes. We could for example use the last 4 bits of the
>> > pubkey/pubkeyhash to opt in (3 leading 0 bits) and the vote (0/1
>> > depending on the stakeholders desired signal). We'd need to define
>> > similar semantics for other script types, but getting the standard
>> > scripts to be recognized should be simple.
>> >
>> > In the spirit of full disclosure I'd like to also mention some of the
>> > downsides of voting this way. Unlike the OP_RETURN proposal, users
>> > that do not intend to signal will also be included in the tally. I'd
>> > expect the signals of these users to be random with a 50% chance of
>> > either outcome, so they should not influence the final result, but
>> > may
>> > muddy the water depending on what part of the population is
>> > signalling. The opt-in should make sure that the majority of votes
>> > are
>> > actually voluntary votes, and not just users that randomly select a
>> > pubkey/pubkeyhash, and can be adjusted as desired, though higher
>> > values require more grinding on behalf of the users.
>> >
>> > The grinding may also exacerbate some problems we already have with
>> > the HD Wallet lookahead, since we now skip a number of addresses, so
>> > we should not require too many opt-in bits.
>> >
>> > So there are some problems we'd need to tackle, but I'm really
>> > excited
>> > about this, as it could provide data to make informed decisions, and
>> > should put an end to the endless speculation about the will of the
>> > economic majority.
>> >
>> > Cheers,
>> > Christian
>> >
>> > [1] http://pub.tik.ee.ethz.ch/students/2015-HS/SA-2015-30.pdf
>> > _______________________________________________
>> > bitcoin-dev mailing list
>> > bitcoin-dev at lists.linuxfoundation.org
>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170503/3d21c76d/attachment-0001.html>

From erik at q32.com  Wed May  3 21:08:35 2017
From: erik at q32.com (Erik Aronesty)
Date: Wed, 3 May 2017 17:08:35 -0400
Subject: [bitcoin-dev] Full node "tip" function
Message-ID: <CAJowKg+snAUjbCFkTybNqiJCy=d_M3s5k376y1B=rVqD8WCOXA@mail.gmail.com>

IDEA:

- Full nodes advertise a bitcoin address.   Users that need to download the
block chain from that node can be encouraged to send a tip to the peers
that served them (by % served).   Recommended tip of 10mbit should be fine.

- A full nodes can *require* a tip to download the blockchain.  If they do,
users that don't specify a tip cannot use them.

CONS:

For some people, this may represent a barrier to hosting their own full
node.   After all, if you have to pay $15 just to get a copy of the
blockchain, that just adds to the already expensive prospect of hosting a
full node.

PROS:

As long as you manage to stay online, you should get your money back and
more.   This is the an incentive for quality, long term hosting.

In the long term, this should cause stable nodes to stick around longer.
It also discourages "installation spam" attacks on the network.

Fees for other node operations can be considered if this is successful.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170503/64e38729/attachment.html>

From thompson.benedictjames at gmail.com  Wed May  3 21:43:16 2017
From: thompson.benedictjames at gmail.com (Ben Thompson)
Date: Wed, 03 May 2017 21:43:16 +0000
Subject: [bitcoin-dev] Full node "tip" function
In-Reply-To: <CAJowKg+snAUjbCFkTybNqiJCy=d_M3s5k376y1B=rVqD8WCOXA@mail.gmail.com>
References: <CAJowKg+snAUjbCFkTybNqiJCy=d_M3s5k376y1B=rVqD8WCOXA@mail.gmail.com>
Message-ID: <CAOxie=GNQtoJLEoY=aHGT5m1RFFmrqVi5p6BMnT-sRkHjkhGcw@mail.gmail.com>

I feel like this would be pointless as the vast majority of users would
likely download the blockchain from a node that was not enforcing a tip
requirement as it would seem like unnecessary cost as in protocol?s such as
BitTorrent there is no such tips in sharing files and the blockchain
distribution is in eccense the same thing. However perhaps I am
underestimating the generosity of node operators but I feel that adding a
cost to the blockchain (assuming that all users add a tip requirement)
would lead to centralisation.

On Wed, 3 May 2017, 22:21 Erik Aronesty via bitcoin-dev, <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> IDEA:
>
> - Full nodes advertise a bitcoin address.   Users that need to download
> the block chain from that node can be encouraged to send a tip to the peers
> that served them (by % served).   Recommended tip of 10mbit should be fine.
>
> - A full nodes can *require* a tip to download the blockchain.  If they
> do, users that don't specify a tip cannot use them.
>
> CONS:
>
> For some people, this may represent a barrier to hosting their own full
> node.   After all, if you have to pay $15 just to get a copy of the
> blockchain, that just adds to the already expensive prospect of hosting a
> full node.
>
> PROS:
>
> As long as you manage to stay online, you should get your money back and
> more.   This is the an incentive for quality, long term hosting.
>
> In the long term, this should cause stable nodes to stick around longer.
> It also discourages "installation spam" attacks on the network.
>
> Fees for other node operations can be considered if this is successful.
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170503/ac45bd6c/attachment.html>

From greg at xiph.org  Wed May  3 21:53:07 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Wed, 3 May 2017 21:53:07 +0000
Subject: [bitcoin-dev] Full node "tip" function
In-Reply-To: <CAJowKg+snAUjbCFkTybNqiJCy=d_M3s5k376y1B=rVqD8WCOXA@mail.gmail.com>
References: <CAJowKg+snAUjbCFkTybNqiJCy=d_M3s5k376y1B=rVqD8WCOXA@mail.gmail.com>
Message-ID: <CAAS2fgQYhi3oqncrNU+26E4JoHHfQMJAyTGtJY-ZD6J9O7NPsQ@mail.gmail.com>

On Wed, May 3, 2017 at 9:08 PM, Erik Aronesty via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> CONS:

The primary result would be paying people to sybil attack the network.
It's far cheaper to run one node behind thousands of IPs than it is to
run many nodes.

Suggestions like this have come up many times before.

From lf-lists at mattcorallo.com  Wed May  3 22:03:43 2017
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Wed, 03 May 2017 22:03:43 +0000
Subject: [bitcoin-dev] Full node "tip" function
In-Reply-To: <CAAS2fgQYhi3oqncrNU+26E4JoHHfQMJAyTGtJY-ZD6J9O7NPsQ@mail.gmail.com>
References: <CAJowKg+snAUjbCFkTybNqiJCy=d_M3s5k376y1B=rVqD8WCOXA@mail.gmail.com>
	<CAAS2fgQYhi3oqncrNU+26E4JoHHfQMJAyTGtJY-ZD6J9O7NPsQ@mail.gmail.com>
Message-ID: <AC8BC70A-D20E-4480-8414-49E2AF159423@mattcorallo.com>

If we ever have a problem getting blocks, we could consider adding something to pay to receive historical blocks but luckily that isn't a problem we have today - the available connection slots and bandwidth on the network today appears to be more than sufficient to saturate nearly any fully-validating node.

On May 3, 2017 5:53:07 PM EDT, Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>On Wed, May 3, 2017 at 9:08 PM, Erik Aronesty via bitcoin-dev
><bitcoin-dev at lists.linuxfoundation.org> wrote:
>> CONS:
>
>The primary result would be paying people to sybil attack the network.
>It's far cheaper to run one node behind thousands of IPs than it is to
>run many nodes.
>
>Suggestions like this have come up many times before.
>_______________________________________________
>bitcoin-dev mailing list
>bitcoin-dev at lists.linuxfoundation.org
>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From vitteaymeric at gmail.com  Wed May  3 22:45:40 2017
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Thu, 4 May 2017 00:45:40 +0200
Subject: [bitcoin-dev] Small Nodes: A Better Alternative to Pruned Nodes
In-Reply-To: <CAAt2M1_TH=1Xw=65QxxCHMZzE-fzC3UhRaEk+KkKY2SHkN6CbQ@mail.gmail.com>
References: <CAFVRnypbQQ-vsSLqv48cYaqTCty4R1DmFRqfAvxe4mAqyQNXxQ@mail.gmail.com>
	<CAAS2fgT5pJh68xufv_81+N8K0asxH16WdX7PLLXGjRPmJOkYFQ@mail.gmail.com>
	<CAJowKg+UTKeU0Dj5pJbtw+LZtO9kn5LBJum9Akd11zCsW+6o4Q@mail.gmail.com>
	<CAAt2M1_TH=1Xw=65QxxCHMZzE-fzC3UhRaEk+KkKY2SHkN6CbQ@mail.gmail.com>
Message-ID: <fbf666d7-40e1-f625-9bee-7f93e145cf6b@gmail.com>



Le 03/05/2017 ? 21:10, Natanael via bitcoin-dev a ?crit :
>
> Den 3 maj 2017 16:05 skrev "Erik Aronesty via bitcoin-dev"
> <bitcoin-dev at lists.linuxfoundation.org
> <mailto:bitcoin-dev at lists.linuxfoundation.org>>:
>
>     > But as you've observed, the failure probabilities are rather high,
>     > especially if an active attacker targets nodes carrying less
>     commonly
>     > available blocks. 
>
>     Wouldn't the solution be for nodes to use whatever mechanism an
>     attacker uses to determine less commonly available blocks and
>     choose to store a random percentage of them as well as their
>     deterministic random set? 
>
>     IE X blocks end of chain (spv bootstrap), Y% deterministic random
>     set,  Z% patch/fill set to deter attacks
>
>
> Then he uses Sybil attacks to obscure what's actually rare and not.

> Even proof of storage isn't enough,you need proof of INDEPENDENT storage

Yes

> , which is essentially impossible

No, the bittorrent network is a good example

> , as well as a way of determining which nodes are run by the same
> people (all the AWS nodes should essentially count as one).

No, this one is impossible and you don't care in fact, as long as the
system forbids the nodes to position themselves where they like and can
check that the nodes are behaving correctly, same people's nodes/IPs
would then just do the job

And if you add to this a rewarding system that is not necessarily
profitable then you eliminate the incentive for sybil attacking the
network (like the "tip" proposal today) while motivating those that have
the resources to run full nodes, then increasing independence


>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170504/134e4c1e/attachment-0001.html>

From luke at dashjr.org  Wed May  3 23:21:13 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Wed, 3 May 2017 23:21:13 +0000
Subject: [bitcoin-dev] Full node "tip" function
In-Reply-To: <CAJowKg+snAUjbCFkTybNqiJCy=d_M3s5k376y1B=rVqD8WCOXA@mail.gmail.com>
References: <CAJowKg+snAUjbCFkTybNqiJCy=d_M3s5k376y1B=rVqD8WCOXA@mail.gmail.com>
Message-ID: <201705032321.14356.luke@dashjr.org>

I think paying for services is in general a great idea, but one that Bitcoin 
can much better serve once Lightning is in production. Not only does it enable 
cost-effective micro-transactions, it also should allow nodes to initiate 
payments before they have a synced node (which is something impractical at 
present).

On Wednesday 03 May 2017 9:08:35 PM Erik Aronesty via bitcoin-dev wrote:
> IDEA:
> 
> - Full nodes advertise a bitcoin address.   Users that need to download the
> block chain from that node can be encouraged to send a tip to the peers
> that served them (by % served).   Recommended tip of 10mbit should be fine.
> 
> - A full nodes can *require* a tip to download the blockchain.  If they do,
> users that don't specify a tip cannot use them.
> 
> CONS:
> 
> For some people, this may represent a barrier to hosting their own full
> node.   After all, if you have to pay $15 just to get a copy of the
> blockchain, that just adds to the already expensive prospect of hosting a
> full node.
> 
> PROS:
> 
> As long as you manage to stay online, you should get your money back and
> more.   This is the an incentive for quality, long term hosting.
> 
> In the long term, this should cause stable nodes to stick around longer.
> It also discourages "installation spam" attacks on the network.
> 
> Fees for other node operations can be considered if this is successful.

From tomas at tomasvdw.nl  Thu May  4 10:38:29 2017
From: tomas at tomasvdw.nl (Tomas)
Date: Thu, 04 May 2017 12:38:29 +0200
Subject: [bitcoin-dev] Full node "tip" function
In-Reply-To: <CAOxie=GNQtoJLEoY=aHGT5m1RFFmrqVi5p6BMnT-sRkHjkhGcw@mail.gmail.com>
References: <CAJowKg+snAUjbCFkTybNqiJCy=d_M3s5k376y1B=rVqD8WCOXA@mail.gmail.com>
	<CAOxie=GNQtoJLEoY=aHGT5m1RFFmrqVi5p6BMnT-sRkHjkhGcw@mail.gmail.com>
Message-ID: <1493894309.1179269.965498864.6244705A@webmail.messagingengine.com>

The ones that *could* pay non-mining full nodes are miners/pools, by
outsourcing transaction selection using a different PoW.  By doing so
they could buy proof-of-uncensored-selection and proof-of-goodwill for a
small fee.
We would allow full nodes to generate and broadcast a template
block which:
* Does not contain a valid header yet
* Contains the transaction selection
* Contains a  coinbase output with a predetermined part of the block
  reward (say 0.5%) to themselves* Contains a nonce for PoW of a predetermined currently ASIC resistant
  hash function behind a OP_RETURN.
The template with the highest PoW since the last block would be leading.
A miner/pool can then choose to use this instead of their own, adding
the rest of the reward and the SHA nonce themselves. That way they would
set up a competition among full nodes.
This would of course be voluntary but provable, so maybe in a pool's
interest to do this via naming and shaming.
Tomas
bitcrust

On Wed, May 3, 2017, at 23:43, Ben Thompson via bitcoin-dev wrote:
> I feel like this would be pointless as the vast majority of users
> would likely download the blockchain from a node that was not
> enforcing a tip requirement as it would seem like unnecessary cost as
> in protocols such as BitTorrent there is no such tips in sharing files
> and the blockchain distribution is in eccense the same thing. However
> perhaps I am underestimating the generosity of node operators but I
> feel that adding a cost to the blockchain (assuming that all users add
> a tip requirement) would lead to centralisation.> 
> On Wed, 3 May 2017, 22:21 Erik Aronesty via bitcoin-dev, <bitcoin-
> dev at lists.linuxfoundation.org> wrote:>> IDEA:
>> - Full nodes advertise a bitcoin address.   Users that need to
>>   download the block chain from that node can be encouraged to send a
>>   tip to the peers that served them (by % served).   Recommended tip
>>   of 10mbit should be fine.>> 
>> - A full nodes can *require* a tip to download the blockchain.  If
>>   they do, users that don't specify a tip cannot use them.>> 
>> CONS:
>> 
>> For some people, this may represent a barrier to hosting their own
>> full node.   After all, if you have to pay $15 just to get a copy of
>> the blockchain, that just adds to the already expensive prospect of
>> hosting a full node.>> PROS: 
>> 
>> As long as you manage to stay online, you should get your money back
>> and more.   This is the an incentive for quality, long term hosting.>> In the long term, this should cause stable nodes to stick around
>> longer.   It also discourages "installation spam" attacks on the
>> network.>> Fees for other node operations can be considered if this is
>> successful.>> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170504/c4a0d32c/attachment.html>

From henning.kopp at uni-ulm.de  Thu May  4 12:51:39 2017
From: henning.kopp at uni-ulm.de (Henning Kopp)
Date: Thu, 4 May 2017 14:51:39 +0200
Subject: [bitcoin-dev] Combining SPV and Stealth addresses
Message-ID: <20170504125138.GA2027@banane.informatik.uni-ulm.de>

Hi all,

Recently I think a lot about combining Stealth addresses with SPV but
I did not come to a satisfying conclusion, so I post this as a
challenge to the wider community. Maybe you have an idea.

## Explanation of SPV
In SPV a thin client puts his public keys in a bloom filter
and asks a full node to give him Merkle proofs of all transactions
whose pubkey are in the bloom filter. Since a bloom filter has a lot
of false positives depending on the parameters, this gives privacy to
the thin client, since the full node cannot detect if a specific
transaction belongs to the thin client. This is cool if you want to
use Bitcoin on your smartphone.

## Explanation of Stealth Addresses
Stealth addresses on the other hand enable receiver privacy. The
sender of a transaction derives a one-time pubkey to which he sends the
money. The receiver can check if the money was sent to him and recover
the one-time private key. This is cool, since an observer cannot
decide if two payments belong to the same recipient. Further the
recipient needs only to have one pubkey.
For a more formal explanation see https://github.com/genjix/bips/blob/master/bip-stealth.mediawiki#Reuse_ScanPubkey
I will use their notation in the following.

## The Problem
My line of thought was to combine stealth addresses with spv, so that
I can use stealth addresses on my smart phone without losing privacy.

Basically to check if a payment belongs to a pubkey (Q,R), the full
node needs to check if R' = R + H(dP)*G for each transaction. For this
it needs the private scanning key d.
This sucks, since when I give my d to a full node, he can link all my
transactions. For an online-wallet this may be okay, but not for thin
client synchronisation.

## Ideas
In the following I detail some ideas of me which did not work.

It does not suffice to have a Bloom filter and check if d is
contained since there is no way to recompute d from the equation. If
there were a way to recompute d, the scheme would offer no privacy,
since anyone could compute the private scanning key d and scan for
payments.
So, if we modify the scheme we need to be sure that d is kept private.

Multiparty computation may be possible in theory. The full node and
the thin client could collaboratively check R' = R + H(dP)*G, where d
is the private input of the thin client and R, R',P is provided by the
full node. But this is costly and they need to do it for each
transaction. It may be more costly than simply setting up a full node.

I do not think that some kind of search functionality without leaking
the search pattern (PIR?) would work, since the full node needs to compute on the
data it has found. And further it needs to retrieve the whole Merkle
proofs.

Any better ideas?

Best,
Henning

-- 
Henning Kopp
Institute of Distributed Systems
Ulm University, Germany

Office: O27 - 3402
Phone: +49 731 50-24138
Web: http://www.uni-ulm.de/in/vs/~kopp

From erik at q32.com  Thu May  4 13:15:02 2017
From: erik at q32.com (Erik Aronesty)
Date: Thu, 4 May 2017 09:15:02 -0400
Subject: [bitcoin-dev] Full node "tip" function
In-Reply-To: <CAAS2fgQYhi3oqncrNU+26E4JoHHfQMJAyTGtJY-ZD6J9O7NPsQ@mail.gmail.com>
References: <CAJowKg+snAUjbCFkTybNqiJCy=d_M3s5k376y1B=rVqD8WCOXA@mail.gmail.com>
	<CAAS2fgQYhi3oqncrNU+26E4JoHHfQMJAyTGtJY-ZD6J9O7NPsQ@mail.gmail.com>
Message-ID: <CAJowKgKpiqeHAFn+tbZAqH9Oojhm8K+8EcJz9kMoU+qgK0PBHA@mail.gmail.com>

> Greg
> The primary result would be paying people to sybil attack the network.

I cannot imagine the benefit to replicating an ip address in this case,
except maybe you think that you would be more likely to be selected as a
peer?   But there would be no actual advantage since download peers are
selected based on throughput and actual blocks served.

Also, since this makes the network far more resistant to DDOS attacks, it
has added benefits.

> Luke:
> paying for services is in general a great idea, but one that Bitcoin
> can much better serve once Lightning is in production.

I agree, if lightning networks were baked in, then the tips could be as
granular as "per block downloaded", or even (outlandish seeming now, but
maybe not in a future where there is a "public rpc api") "per rpc call".
Miners and business users would certainly pay for high quality services.
Spinning up new nodes without a tip and relying on the "free network" would
probably take more time, for example.

I suspect that if income were even a small possibility the number of full
nodes would vastly increase.

Sybil attacks seem irrelevant as long as reasonable QOS metrics are stored
per peer.


On Wed, May 3, 2017 at 5:53 PM, Gregory Maxwell <greg at xiph.org> wrote:

> On Wed, May 3, 2017 at 9:08 PM, Erik Aronesty via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > CONS:
>
> The primary result would be paying people to sybil attack the network.
> It's far cheaper to run one node behind thousands of IPs than it is to
> run many nodes.
>
> Suggestions like this have come up many times before.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170504/fa4898df/attachment.html>

From vitteaymeric at gmail.com  Thu May  4 13:37:43 2017
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Thu, 4 May 2017 15:37:43 +0200
Subject: [bitcoin-dev] Full node "tip" function
In-Reply-To: <1493894309.1179269.965498864.6244705A@webmail.messagingengine.com>
References: <CAJowKg+snAUjbCFkTybNqiJCy=d_M3s5k376y1B=rVqD8WCOXA@mail.gmail.com>
	<CAOxie=GNQtoJLEoY=aHGT5m1RFFmrqVi5p6BMnT-sRkHjkhGcw@mail.gmail.com>
	<1493894309.1179269.965498864.6244705A@webmail.messagingengine.com>
Message-ID: <02b56878-c4e5-d1b9-07f4-317663f543b5@gmail.com>

Strange idea, incentiving people to run full nodes should certainly not
depend on miners, should certainly not involve another wasteful pow and
should certainly not encourage any collusion between participants like
miners are doing (ie full nodes pools for example or miners creating
full nodes pools)


Le 04/05/2017 ? 12:38, Tomas via bitcoin-dev a ?crit :
> The ones that *could* pay non-mining full nodes are miners/pools, by
> outsourcing transaction selection using a different PoW.  By doing so
> they could buy proof-of-uncensored-selection and proof-of-goodwill for
> a small fee.
>
> We would allow full nodes to generate and broadcast a template block
> which:
>
> * Does not contain a valid header yet
> * Contains the transaction selection
> * Contains a coinbase output with a predetermined part of the block
> reward (say 0.5%) to themselves
> * Contains a nonce for PoW of a predetermined currently ASIC resistant
> hash function behind a OP_RETURN.
>
> The template with the highest PoW since the last block would be
> leading. A miner/pool can then choose to use this instead of their
> own, adding the rest of the reward and the SHA nonce themselves. That
> way they would set up a competition among full nodes.
>
> This would of course be voluntary but provable, so maybe in a pool's
> interest to do this via naming and shaming.
>
> Tomas
> bitcrust
>
> On Wed, May 3, 2017, at 23:43, Ben Thompson via bitcoin-dev wrote:
>> I feel like this would be pointless as the vast majority of users
>> would likely download the blockchain from a node that was not
>> enforcing a tip requirement as it would seem like unnecessary cost as
>> in protocols such as BitTorrent there is no such tips in sharing
>> files and the blockchain distribution is in eccense the same thing.
>> However perhaps I am underestimating the generosity of node operators
>> but I feel that adding a cost to the blockchain (assuming that all
>> users add a tip requirement) would lead to centralisation.
>>
>> On Wed, 3 May 2017, 22:21 Erik Aronesty via bitcoin-dev,
>> <bitcoin-dev at lists.linuxfoundation.org
>> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>
>>     IDEA:
>>     - Full nodes advertise a bitcoin address.   Users that need to
>>     download the block chain from that node can be encouraged to send
>>     a tip to the peers that served them (by % served).   Recommended
>>     tip of 10mbit should be fine.
>>
>>     - A full nodes can *require* a tip to download the blockchain. 
>>     If they do, users that don't specify a tip cannot use them.
>>
>>     CONS:
>>
>>     For some people, this may represent a barrier to hosting their
>>     own full node.   After all, if you have to pay $15 just to get a
>>     copy of the blockchain, that just adds to the already expensive
>>     prospect of hosting a full node.  
>>     PROS:
>>
>>     As long as you manage to stay online, you should get your money
>>     back and more.   This is the an incentive for quality, long term
>>     hosting.
>>     In the long term, this should cause stable nodes to stick around
>>     longer.   It also discourages "installation spam" attacks on the
>>     network.
>>     Fees for other node operations can be considered if this is
>>     successful.
>>
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170504/37a1e95c/attachment-0001.html>

From vitteaymeric at gmail.com  Thu May  4 14:31:11 2017
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Thu, 4 May 2017 16:31:11 +0200
Subject: [bitcoin-dev] Full node "tip" function
In-Reply-To: <CAJowKgJiW4wZ_FnVPLLTYbA1B6xgswMD19-Tf1HmowpWqZEnPQ@mail.gmail.com>
References: <CAJowKg+snAUjbCFkTybNqiJCy=d_M3s5k376y1B=rVqD8WCOXA@mail.gmail.com>
	<CAOxie=GNQtoJLEoY=aHGT5m1RFFmrqVi5p6BMnT-sRkHjkhGcw@mail.gmail.com>
	<1493894309.1179269.965498864.6244705A@webmail.messagingengine.com>
	<02b56878-c4e5-d1b9-07f4-317663f543b5@gmail.com>
	<CAJowKgJiW4wZ_FnVPLLTYbA1B6xgswMD19-Tf1HmowpWqZEnPQ@mail.gmail.com>
Message-ID: <e38fd508-a6d6-acce-ba59-eaac4d69a42f@gmail.com>

Yes, as a whole, but I am sorry, your "tip" proposal is very very very
bad as it is, think a little bit more about your latest answer and you
will understand why

I am a bit perplexed sometimes about what is proposed on this list

Adding services paid by the miners is not a bad idea, like some
proposals that were posted here proposing some system to validate/format
the blocks for the miners

But, first, the highest priority is to scale the full nodes and this
cannot depend on miners, then once this is done we can imagine other
services on top of it paid by the miners or others (+lightning & co)

I have already explained many times my thoughts on the subject, I don't
pretend that they represent the perfect solution but at least it's
different from what we can read , so I think that the core dev team
should setup a task force/group to solve this quickly now, the
accumulation of strange proposals/workarounds here does not help

Because it's a real question for everybody in the current context
whether we can trust bitcoin or not, unfortunately the answer currently
tends toward the later, or please explain me why this statement could be
wrong


Le 04/05/2017 ? 15:47, Erik Aronesty a ?crit :
>  - Full nodes already perform many valuable services, and simply
> allowing people to pay for better service is something operators can
> do now - even without it being baked into bitcoind.   Paying for
> access to a higher-speed relay network, for example, is something that
> many operators would do.
>
> - Baking in the ability to add service fees could make more people
> *want* to run more high quality, highly available full nodes... which
> is really one of the most important things developers can be doing.
>
>
> On Thu, May 4, 2017 at 9:37 AM, Aymeric Vitte via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org
> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>
>     Strange idea, incentiving people to run full nodes should
>     certainly not depend on miners, should certainly not involve
>     another wasteful pow and should certainly not encourage any
>     collusion between participants like miners are doing (ie full
>     nodes pools for example or miners creating full nodes pools)
>
>
>     Le 04/05/2017 ? 12:38, Tomas via bitcoin-dev a ?crit :
>>     The ones that *could* pay non-mining full nodes are miners/pools,
>>     by outsourcing transaction selection using a different PoW.  By
>>     doing so they could buy proof-of-uncensored-selection and
>>     proof-of-goodwill for a small fee.
>>
>>     We would allow full nodes to generate and broadcast a template
>>     block which:
>>
>>     * Does not contain a valid header yet
>>     * Contains the transaction selection
>>     * Contains a coinbase output with a predetermined part of the
>>     block reward (say 0.5%) to themselves
>>     * Contains a nonce for PoW of a predetermined currently ASIC
>>     resistant hash function behind a OP_RETURN.
>>
>>     The template with the highest PoW since the last block would be
>>     leading. A miner/pool can then choose to use this instead of
>>     their own, adding the rest of the reward and the SHA nonce
>>     themselves. That way they would set up a competition among full
>>     nodes.
>>
>>     This would of course be voluntary but provable, so maybe in a
>>     pool's interest to do this via naming and shaming.
>>
>>     Tomas
>>     bitcrust
>>
>>     On Wed, May 3, 2017, at 23:43, Ben Thompson via bitcoin-dev wrote:
>>>     I feel like this would be pointless as the vast majority of
>>>     users would likely download the blockchain from a node that was
>>>     not enforcing a tip requirement as it would seem like
>>>     unnecessary cost as in protocols such as BitTorrent there is no
>>>     such tips in sharing files and the blockchain distribution is in
>>>     eccense the same thing. However perhaps I am underestimating the
>>>     generosity of node operators but I feel that adding a cost to
>>>     the blockchain (assuming that all users add a tip requirement)
>>>     would lead to centralisation.
>>>
>>>     On Wed, 3 May 2017, 22:21 Erik Aronesty via bitcoin-dev,
>>>     <bitcoin-dev at lists.linuxfoundation.org
>>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>>
>>>         IDEA:
>>>         - Full nodes advertise a bitcoin address.   Users that need
>>>         to download the block chain from that node can be encouraged
>>>         to send a tip to the peers that served them (by % served).  
>>>         Recommended tip of 10mbit should be fine.
>>>
>>>         - A full nodes can *require* a tip to download the
>>>         blockchain.  If they do, users that don't specify a tip
>>>         cannot use them.
>>>
>>>         CONS:
>>>
>>>         For some people, this may represent a barrier to hosting
>>>         their own full node.   After all, if you have to pay $15
>>>         just to get a copy of the blockchain, that just adds to the
>>>         already expensive prospect of hosting a full node.  
>>>         PROS:
>>>
>>>         As long as you manage to stay online, you should get your
>>>         money back and more.   This is the an incentive for quality,
>>>         long term hosting.
>>>         In the long term, this should cause stable nodes to stick
>>>         around longer.   It also discourages "installation spam"
>>>         attacks on the network.
>>>         Fees for other node operations can be considered if this is
>>>         successful.
>>>
>>
>>
>>
>>     _______________________________________________
>>     bitcoin-dev mailing list
>>     bitcoin-dev at lists.linuxfoundation.org
>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>     <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
>
>     -- 
>     Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
>     <https://github.com/Ayms/zcash-wallets>
>     Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
>     <https://github.com/Ayms/bitcoin-wallets>
>     Get the torrent dynamic blocklist: http://peersm.com/getblocklist
>     Check the 10 M passwords list: http://peersm.com/findmyass
>     Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
>     Peersm : http://www.peersm.com
>     torrent-live: https://github.com/Ayms/torrent-live
>     <https://github.com/Ayms/torrent-live>
>     node-Tor : https://www.github.com/Ayms/node-Tor
>     <https://www.github.com/Ayms/node-Tor>
>     GitHub : https://www.github.com/Ayms
>
>     _______________________________________________ bitcoin-dev
>     mailing list bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>     <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev> 
>
-- 
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170504/b35d9902/attachment.html>

From erik at q32.com  Thu May  4 13:47:45 2017
From: erik at q32.com (Erik Aronesty)
Date: Thu, 4 May 2017 09:47:45 -0400
Subject: [bitcoin-dev] Full node "tip" function
In-Reply-To: <02b56878-c4e5-d1b9-07f4-317663f543b5@gmail.com>
References: <CAJowKg+snAUjbCFkTybNqiJCy=d_M3s5k376y1B=rVqD8WCOXA@mail.gmail.com>
	<CAOxie=GNQtoJLEoY=aHGT5m1RFFmrqVi5p6BMnT-sRkHjkhGcw@mail.gmail.com>
	<1493894309.1179269.965498864.6244705A@webmail.messagingengine.com>
	<02b56878-c4e5-d1b9-07f4-317663f543b5@gmail.com>
Message-ID: <CAJowKgJiW4wZ_FnVPLLTYbA1B6xgswMD19-Tf1HmowpWqZEnPQ@mail.gmail.com>

 - Full nodes already perform many valuable services, and simply allowing
people to pay for better service is something operators can do now - even
without it being baked into bitcoind.   Paying for access to a higher-speed
relay network, for example, is something that many operators would do.

- Baking in the ability to add service fees could make more people *want*
to run more high quality, highly available full nodes... which is really
one of the most important things developers can be doing.


On Thu, May 4, 2017 at 9:37 AM, Aymeric Vitte via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Strange idea, incentiving people to run full nodes should certainly not
> depend on miners, should certainly not involve another wasteful pow and
> should certainly not encourage any collusion between participants like
> miners are doing (ie full nodes pools for example or miners creating full
> nodes pools)
>
> Le 04/05/2017 ? 12:38, Tomas via bitcoin-dev a ?crit :
>
> The ones that *could* pay non-mining full nodes are miners/pools, by
> outsourcing transaction selection using a different PoW.  By doing so they
> could buy proof-of-uncensored-selection and proof-of-goodwill for a small
> fee.
>
> We would allow full nodes to generate and broadcast a template block which:
>
> * Does not contain a valid header yet
> * Contains the transaction selection
> * Contains a coinbase output with a predetermined part of the block reward
> (say 0.5%) to themselves
> * Contains a nonce for PoW of a predetermined currently ASIC resistant
> hash function behind a OP_RETURN.
>
> The template with the highest PoW since the last block would be leading. A
> miner/pool can then choose to use this instead of their own, adding the
> rest of the reward and the SHA nonce themselves. That way they would set up
> a competition among full nodes.
>
> This would of course be voluntary but provable, so maybe in a pool's
> interest to do this via naming and shaming.
>
> Tomas
> bitcrust
>
> On Wed, May 3, 2017, at 23:43, Ben Thompson via bitcoin-dev wrote:
>
> I feel like this would be pointless as the vast majority of users would
> likely download the blockchain from a node that was not enforcing a tip
> requirement as it would seem like unnecessary cost as in protocols such as
> BitTorrent there is no such tips in sharing files and the blockchain
> distribution is in eccense the same thing. However perhaps I am
> underestimating the generosity of node operators but I feel that adding a
> cost to the blockchain (assuming that all users add a tip requirement)
> would lead to centralisation.
>
> On Wed, 3 May 2017, 22:21 Erik Aronesty via bitcoin-dev, <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> IDEA:
> - Full nodes advertise a bitcoin address.   Users that need to download
> the block chain from that node can be encouraged to send a tip to the peers
> that served them (by % served).   Recommended tip of 10mbit should be fine.
>
> - A full nodes can *require* a tip to download the blockchain.  If they
> do, users that don't specify a tip cannot use them.
>
> CONS:
>
> For some people, this may represent a barrier to hosting their own full
> node.   After all, if you have to pay $15 just to get a copy of the
> blockchain, that just adds to the already expensive prospect of hosting a
> full node.
> PROS:
>
> As long as you manage to stay online, you should get your money back and
> more.   This is the an incentive for quality, long term hosting.
> In the long term, this should cause stable nodes to stick around longer.
> It also discourages "installation spam" attacks on the network.
> Fees for other node operations can be considered if this is successful.
>
>
>
>
> _______________________________________________
> bitcoin-dev mailing listbitcoin-dev at lists.linuxfoundation.orghttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> --
> Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
> Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
> Get the torrent dynamic blocklist: http://peersm.com/getblocklist
> Check the 10 M passwords list: http://peersm.com/findmyass
> Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
> Peersm : http://www.peersm.com
> torrent-live: https://github.com/Ayms/torrent-live
> node-Tor : https://www.github.com/Ayms/node-Tor
> GitHub : https://www.github.com/Ayms
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170504/3858fae9/attachment-0001.html>

From tomz at freedommail.ch  Thu May  4 14:57:59 2017
From: tomz at freedommail.ch (Tom Zander)
Date: Thu, 04 May 2017 16:57:59 +0200
Subject: [bitcoin-dev] Full node "tip" function
In-Reply-To: <CAJowKgKpiqeHAFn+tbZAqH9Oojhm8K+8EcJz9kMoU+qgK0PBHA@mail.gmail.com>
References: <CAJowKg+snAUjbCFkTybNqiJCy=d_M3s5k376y1B=rVqD8WCOXA@mail.gmail.com>
	<CAAS2fgQYhi3oqncrNU+26E4JoHHfQMJAyTGtJY-ZD6J9O7NPsQ@mail.gmail.com>
	<CAJowKgKpiqeHAFn+tbZAqH9Oojhm8K+8EcJz9kMoU+qgK0PBHA@mail.gmail.com>
Message-ID: <67911104.PTmAhAhWMc@strawberry>

I agree with you here, Erik. Greg's standard answer doesn?t apply to your 
suggestion.
I think he was a bit too trigger happy because we have seen a lot of similar 
suggestions that have the Sybill issue he mentioned.


On Thursday, 4 May 2017 15:15:02 CEST Erik Aronesty via bitcoin-dev wrote:
> > Greg
> > The primary result would be paying people to sybil attack the network.
> 
> I cannot imagine the benefit to replicating an ip address in this case,
> except maybe you think that you would be more likely to be selected as a
> peer?   But there would be no actual advantage since download peers are
> selected based on throughput and actual blocks served.

-- 
Tom Zander
Blog: https://zander.github.io
Vlog: https://vimeo.com/channels/tomscryptochannel

From ctpacia at gmail.com  Thu May  4 16:23:27 2017
From: ctpacia at gmail.com (Chris Pacia)
Date: Thu, 4 May 2017 12:23:27 -0400
Subject: [bitcoin-dev] Combining SPV and Stealth addresses
In-Reply-To: <20170504125138.GA2027@banane.informatik.uni-ulm.de>
References: <20170504125138.GA2027@banane.informatik.uni-ulm.de>
Message-ID: <CAB+qUq56a7-6B=-WVYUC2xoYADg+pnwje7ZSff3T4XBdAdUMkg@mail.gmail.com>

Yes I've had it working using two pushes in op_return.

op_return op_pushdata <flag> op_pushdata <ephem_pubkey>

Flag goes in your filter. You anonymity set is all other transactions using
that same flag.

This is fairly decent privacy but the problem is you still need filter
matches on outgoing transactions to build a functioning wallet. So it might
not be an improvement over standard bloom filters but at least you can do
stealth if you want.

On May 4, 2017 9:00 AM, "Henning Kopp via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi all,
>
> Recently I think a lot about combining Stealth addresses with SPV but
> I did not come to a satisfying conclusion, so I post this as a
> challenge to the wider community. Maybe you have an idea.
>
> ## Explanation of SPV
> In SPV a thin client puts his public keys in a bloom filter
> and asks a full node to give him Merkle proofs of all transactions
> whose pubkey are in the bloom filter. Since a bloom filter has a lot
> of false positives depending on the parameters, this gives privacy to
> the thin client, since the full node cannot detect if a specific
> transaction belongs to the thin client. This is cool if you want to
> use Bitcoin on your smartphone.
>
> ## Explanation of Stealth Addresses
> Stealth addresses on the other hand enable receiver privacy. The
> sender of a transaction derives a one-time pubkey to which he sends the
> money. The receiver can check if the money was sent to him and recover
> the one-time private key. This is cool, since an observer cannot
> decide if two payments belong to the same recipient. Further the
> recipient needs only to have one pubkey.
> For a more formal explanation see https://github.com/genjix/
> bips/blob/master/bip-stealth.mediawiki#Reuse_ScanPubkey
> I will use their notation in the following.
>
> ## The Problem
> My line of thought was to combine stealth addresses with spv, so that
> I can use stealth addresses on my smart phone without losing privacy.
>
> Basically to check if a payment belongs to a pubkey (Q,R), the full
> node needs to check if R' = R + H(dP)*G for each transaction. For this
> it needs the private scanning key d.
> This sucks, since when I give my d to a full node, he can link all my
> transactions. For an online-wallet this may be okay, but not for thin
> client synchronisation.
>
> ## Ideas
> In the following I detail some ideas of me which did not work.
>
> It does not suffice to have a Bloom filter and check if d is
> contained since there is no way to recompute d from the equation. If
> there were a way to recompute d, the scheme would offer no privacy,
> since anyone could compute the private scanning key d and scan for
> payments.
> So, if we modify the scheme we need to be sure that d is kept private.
>
> Multiparty computation may be possible in theory. The full node and
> the thin client could collaboratively check R' = R + H(dP)*G, where d
> is the private input of the thin client and R, R',P is provided by the
> full node. But this is costly and they need to do it for each
> transaction. It may be more costly than simply setting up a full node.
>
> I do not think that some kind of search functionality without leaking
> the search pattern (PIR?) would work, since the full node needs to compute
> on the
> data it has found. And further it needs to retrieve the whole Merkle
> proofs.
>
> Any better ideas?
>
> Best,
> Henning
>
> --
> Henning Kopp
> Institute of Distributed Systems
> Ulm University, Germany
>
> Office: O27 - 3402
> Phone: +49 731 50-24138
> Web: http://www.uni-ulm.de/in/vs/~kopp
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170504/1b1ad9a5/attachment.html>

From erik at q32.com  Thu May  4 19:28:10 2017
From: erik at q32.com (Erik Aronesty)
Date: Thu, 4 May 2017 15:28:10 -0400
Subject: [bitcoin-dev] Full node "tip" function
In-Reply-To: <9335E0E0-F9D6-41AD-9FF9-5CDF2B1AF1F7@gmail.com>
References: <CAJowKg+snAUjbCFkTybNqiJCy=d_M3s5k376y1B=rVqD8WCOXA@mail.gmail.com>
	<201705032321.14356.luke@dashjr.org>
	<9335E0E0-F9D6-41AD-9FF9-5CDF2B1AF1F7@gmail.com>
Message-ID: <CAJowKgLzMZe1RcAW+FYsUZkvdZ5ZFf6cS5oJdZ=0apM0wMXc+g@mail.gmail.com>

>
> This is actually LN?s killer use case - not buying coffees ;)
>

Yes, micro-payments for online network services is precisely what LN is
best at.

Establishing a channel with each peer is too expensive.   But using LN to
micro-pay for high-quality peer services seems like it would aggregate very
well.

It would be great if this protocol was in-place and ready to go in or
around the same time LN is ready.   It would incentivize full nodes even
further than LN does, and allow the network to be strongly DDOS resistant.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170504/f40af52a/attachment.html>

From tomas at tomasvdw.nl  Fri May  5 08:49:35 2017
From: tomas at tomasvdw.nl (Tomas)
Date: Fri, 05 May 2017 10:49:35 +0200
Subject: [bitcoin-dev] Fraud Proofs with semi SPV
Message-ID: <1493974175.1405717.966643128.63AF4749@webmail.messagingengine.com>

I would like some feedback on the idea to use a node type a bit heavier
then SPV (dubbed FSPV) to solve Fraud Proofs.

An FSPV node not only downloads block headers, but also the "spend-tree
blocks", consisting of all TXIDs and all previous output indices and
TXIDs. The latter can be compacted using a scheme similar to Compact
Blocks, which will make the spend-tree block ~80kb in size.

ThIs way the FSPV can track the full transaction graph at little cost.

The advantage is, that Fraud Hint messages for absent/withheld
transactions become feasible. A normal SPV  is reduced to Full Node by
such (cheaply faked) hint, but for an FSPV the cost is almost zero.

All it needs to do is add a taint-bit in the tree and propagate the
taint to the transaction graph. It then knows it needs to request the
Fraud Hinted transaction to consider any descendant transaction valid.

This makes it sufficient to punish fraudulent fraud hints or withheld
transactions by normal "banscore" procedures.

All other fraud can be proven by transaction-sets.

More information here:  https://bitcrust.org/blog-fraud-proofs

Tomas
Bitcrust

From tomas at tomasvdw.nl  Fri May  5 11:24:49 2017
From: tomas at tomasvdw.nl (Tomas)
Date: Fri, 05 May 2017 13:24:49 +0200
Subject: [bitcoin-dev] Non-confirming block signalling
Message-ID: <1493983489.1448140.966773912.17FBAAC0@webmail.messagingengine.com>

I propose a method to mark blocks to indicate that they were generated
without verifying the previous block. This can be done by using a bit of
the version field.

This would counter the reduction of security caused by what is known as
"SPV-mining".

The BIP is here:
https://github.com/tomasvdw/bips/blob/master/bip-non-confirming-block-signalling.mediawiki

Tomas
bitcrust

From kanzure at gmail.com  Fri May  5 13:01:40 2017
From: kanzure at gmail.com (Bryan Bishop)
Date: Fri, 5 May 2017 08:01:40 -0500
Subject: [bitcoin-dev] Non-confirming block signalling
In-Reply-To: <1493983489.1448140.966773912.17FBAAC0@webmail.messagingengine.com>
References: <1493983489.1448140.966773912.17FBAAC0@webmail.messagingengine.com>
Message-ID: <CABaSBawLB+igz0Za18Risp1nhhG5s07Bv0jwKzqpXR=iq2kPiw@mail.gmail.com>

On Fri, May 5, 2017 at 6:24 AM, Tomas via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I propose a method to mark blocks to indicate that they were generated
> without verifying the previous block. This can be done by using a bit of
> the version field.
>

see also:
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-December/011853.html

- Bryan
http://heybryan.org/
1 512 203 0507
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170505/fbd6515d/attachment.html>

From tomas at tomasvdw.nl  Fri May  5 13:09:17 2017
From: tomas at tomasvdw.nl (Tomas)
Date: Fri, 05 May 2017 15:09:17 +0200
Subject: [bitcoin-dev] Non-confirming block signalling
Message-ID: <1493989757.1477512.966870152.4C72B056@webmail.messagingengine.com>

Sorry, I wasn't aware. This is indeed the same proposal.



On Fri, May 5, 2017, at 15:01, Bryan Bishop wrote:
> On Fri, May 5, 2017 at 6:24 AM, Tomas via bitcoin-dev <bitcoin-
> dev at lists.linuxfoundation.org> wrote:>> I propose a method to mark blocks to indicate that they were
>> generated>> without verifying the previous block. This can be done by using
>> a bit of>> the version field.
> 
> see also:
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-December/011853.html> 
> - Bryan
> http://heybryan.org/
> 1 512 203 0507

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170505/7da7d11e/attachment.html>

From henning.kopp at uni-ulm.de  Sat May  6 09:38:06 2017
From: henning.kopp at uni-ulm.de (Henning Kopp)
Date: Sat, 6 May 2017 11:38:06 +0200
Subject: [bitcoin-dev] Combining SPV and Stealth addresses
In-Reply-To: <CAB+qUq56a7-6B=-WVYUC2xoYADg+pnwje7ZSff3T4XBdAdUMkg@mail.gmail.com>
References: <20170504125138.GA2027@banane.informatik.uni-ulm.de>
	<CAB+qUq56a7-6B=-WVYUC2xoYADg+pnwje7ZSff3T4XBdAdUMkg@mail.gmail.com>
Message-ID: <4f96caa7-5150-b7da-45a5-bf8502b60205@uni-ulm.de>

Sorry, I cannot quite follow you. What do you mean with flag?

Best,
Henning


Am 04.05.2017 um 18:23 schrieb Chris Pacia:
> Yes I've had it working using two pushes in op_return.
>
> op_return op_pushdata <flag> op_pushdata <ephem_pubkey>
>
> Flag goes in your filter. You anonymity set is all other transactions using
> that same flag.
>
> This is fairly decent privacy but the problem is you still need filter
> matches on outgoing transactions to build a functioning wallet. So it might
> not be an improvement over standard bloom filters but at least you can do
> stealth if you want.
>
> On May 4, 2017 9:00 AM, "Henning Kopp via bitcoin-dev" <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Hi all,
>>
>> Recently I think a lot about combining Stealth addresses with SPV but
>> I did not come to a satisfying conclusion, so I post this as a
>> challenge to the wider community. Maybe you have an idea.
>>
>> ## Explanation of SPV
>> In SPV a thin client puts his public keys in a bloom filter
>> and asks a full node to give him Merkle proofs of all transactions
>> whose pubkey are in the bloom filter. Since a bloom filter has a lot
>> of false positives depending on the parameters, this gives privacy to
>> the thin client, since the full node cannot detect if a specific
>> transaction belongs to the thin client. This is cool if you want to
>> use Bitcoin on your smartphone.
>>
>> ## Explanation of Stealth Addresses
>> Stealth addresses on the other hand enable receiver privacy. The
>> sender of a transaction derives a one-time pubkey to which he sends the
>> money. The receiver can check if the money was sent to him and recover
>> the one-time private key. This is cool, since an observer cannot
>> decide if two payments belong to the same recipient. Further the
>> recipient needs only to have one pubkey.
>> For a more formal explanation see https://github.com/genjix/
>> bips/blob/master/bip-stealth.mediawiki#Reuse_ScanPubkey
>> I will use their notation in the following.
>>
>> ## The Problem
>> My line of thought was to combine stealth addresses with spv, so that
>> I can use stealth addresses on my smart phone without losing privacy.
>>
>> Basically to check if a payment belongs to a pubkey (Q,R), the full
>> node needs to check if R' = R + H(dP)*G for each transaction. For this
>> it needs the private scanning key d.
>> This sucks, since when I give my d to a full node, he can link all my
>> transactions. For an online-wallet this may be okay, but not for thin
>> client synchronisation.
>>
>> ## Ideas
>> In the following I detail some ideas of me which did not work.
>>
>> It does not suffice to have a Bloom filter and check if d is
>> contained since there is no way to recompute d from the equation. If
>> there were a way to recompute d, the scheme would offer no privacy,
>> since anyone could compute the private scanning key d and scan for
>> payments.
>> So, if we modify the scheme we need to be sure that d is kept private.
>>
>> Multiparty computation may be possible in theory. The full node and
>> the thin client could collaboratively check R' = R + H(dP)*G, where d
>> is the private input of the thin client and R, R',P is provided by the
>> full node. But this is costly and they need to do it for each
>> transaction. It may be more costly than simply setting up a full node.
>>
>> I do not think that some kind of search functionality without leaking
>> the search pattern (PIR?) would work, since the full node needs to compute
>> on the
>> data it has found. And further it needs to retrieve the whole Merkle
>> proofs.
>>
>> Any better ideas?
>>
>> Best,
>> Henning
>>
>> --
>> Henning Kopp
>> Institute of Distributed Systems
>> Ulm University, Germany
>>
>> Office: O27 - 3402
>> Phone: +49 731 50-24138
>> Web: http://www.uni-ulm.de/in/vs/~kopp
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>


From rx at awsomnet.org  Sun May  7 06:45:00 2017
From: rx at awsomnet.org (adiabat)
Date: Sun, 7 May 2017 02:45:00 -0400
Subject: [bitcoin-dev] Per-block non-interactive Schnorr signature
	aggregation
Message-ID: <CAKEeUhh3Rj3Dh8ab5FFR6dGKc2Ojm5Z0uyWtAtrPrh=7dvj-GA@mail.gmail.com>

If / when Schnorr signatures are deployed in a future witness version, it
may be possible to have non-interactive partial aggregation of the
signatures on a per-block basis.  This could save quite a bit of space.  It
*seems* not to have any security problems but this mailing list is very
good at finding vulnerabilities so that type of feedback is the main reason
I'm writing :) (A quick explanation of why this is horribly broken could
save me lots of time!)
(also sorry if this has been discussed; didn't see anything)

Quick recap / context of Schnorr sigs:

There are a bunch of private keys x1, x2, x3...
multiply by generator G to get x1G = P1, x2G = P2, x3G = P3

Everyone makes their sighash m1, m2, m3, and their random nonces k1, k2, k3.

To sign, people calculate s values:

s1 = k1 - h(m1, R1, P1)x1
s2 = k2 - h(m2, R2, P2)x2

(adding the P2 into the e hash value is not in most literature /
explanations but helps with some attacks; I beleive that's the current
thinking.  Anyway it doesn't matter for this idea)

Signature 1 is [R1, s1].  Verifiers check, given P1, m1, R1, s1:

s1G =? R1 - h(m1, R1, P1)P1

You can *interactively* make aggregate signatures, which requires
co-signers to build an aggregate R value by coming up with their own k
values, sharing their R with the co-signers, adding up the R's to get a
summed R, and using that to sign.

Non-interactively though, it seems like you can aggregate half the
signature.  The R values are unique to the [m, P] pair, but the s's can be
summed up:

s1 + s2 = k1 + k2 - h(m1, R1, P1)x1 - h(m2, R2, P2)x2

(s1 + s2)G = R1 + R2 - h(m1, R1, P1)P1 - h(m2, R2, P2)P2

To use this property in Bitcoin, when making transactions, wallets can sign
in the normal way, and the signature, consisting of [R, s] goes into the
witness stack.  When miners generate a block, they remove the s-value from
all compatible inputs, and commit to the aggregate s-value in the coinbase
transaction (either in a new OP_RETURN or alongside the existing witness
commitment structure).

The obvious advatage is that signatures go down to 32 bytes each, so you
can fit more of them in a block, and they take up less disk and network
space.  (In IBD; if a node maintains a mempool they'll need to receive all
the separate s-values)

Another advatage is that block verification is sped up.  For individual
signatures, the computation involves:

e = h(m1, R1, P1)           <- hash function, super fast
e*P                         <- point multiplication, slowest
R - e*P                     <- point addidion, pretty fast
s*G                         <- base point multiplication, pretty slow

with s-aggregate verification, the first three steps are still carried out
on each signature, but the s*G operation only needs to be done once.
Instead another point addition per signature is needed, where you have some
accumulator and add in the left side:
A += R - e*P
this can be parallelized pretty well as it's commutative.

The main downside I can see (assuming this actually works) is that it's
hard to cache signatures and quickly validate a block after it has come
in.  It might not be as bad as it first seems, as validation given chached
signatures looks possible without any elliptic curve operations.  Keep an
aggregate s-value (which is a scalar) for all the txs in your mempool.
When a block comes in, subtract all the s-values for txs not included in
the block.  If the block includes txs you weren't aware of, request them in
the same way compact blocks works, and get the full signature for those
txs.  It could be several thousand operations, but those are all bigInt
modular additions / subtractions which I believe are pretty quick in
comparison with point additions / multiplications.

There may be other complications due to the fact that the witness-txids
change when building a block.  TXIDs don't change though so should be
possible to keep track of things OK.

Also you can't "fail fast" for the signature verification; you have to add
everything up before you can tell if it's correct.  Probably not a big deal
as PoW check comes first, and invalid blocks are pretty uncommon and quite
costly.

Would be interested to hear if this idea looks promising.
Andrew Polestra mentioned something like this in the context of CT /
mimblewimble transactions a while ago, but it seems it may be applicable to
regular bitcoin Schnorr txs.

-Tadge
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170507/4f2f604d/attachment.html>

From sanch0panza at protonmail.com  Sun May  7 08:42:28 2017
From: sanch0panza at protonmail.com (Sancho Panza)
Date: Sun, 07 May 2017 04:42:28 -0400
Subject: [bitcoin-dev] Generalized versionbits BIP requesting number
	assignment
Message-ID: <OSA0fRQCK0EjpoZFiC5sFPPZmMWqAhQMwL4C0qcpGYmAM3v2xSerki-w6M7lpj4e1XyD269RP_ifcyMWpyF3aFkNhtFLhs4jBL1H3noH8Rk=@protonmail.com>

Hola,

I've submitted the generalized versionbits specification for BIP number assignment:

https://github.com/bitcoin/bips/pull/532

Your feedback and comments welcome.

The spec has been updated to include a link to the reference implementation.
I hope to find time soon to produce a similar reference implementation on Bitcoin Core.

Sancho
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170507/e3a5fded/attachment.html>

From pieter.wuille at gmail.com  Sun May  7 21:39:14 2017
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Sun, 7 May 2017 14:39:14 -0700
Subject: [bitcoin-dev] A BIP proposal for segwit addresses
In-Reply-To: <CAPg+sBh0sFA7b6a+48Oojwy655GB9W6Th8JiCpd+2ruQjPev8Q@mail.gmail.com>
References: <CAPg+sBh0sFA7b6a+48Oojwy655GB9W6Th8JiCpd+2ruQjPev8Q@mail.gmail.com>
Message-ID: <CAPg+sBiPiLHZFoYY=gs6LT+Q2Kb5NmbVU05u7c+0WRPjveBJhQ@mail.gmail.com>

On Mon, Mar 20, 2017 at 2:35 PM, Pieter Wuille <pieter.wuille at gmail.com>
wrote:

> Hello everyone,
>
> You can find the text here:
> https://github.com/sipa/bech32/blob/master/bip-witaddr.mediawiki
>

Responding to a few comments:

By Andreas Schildbach:

> I'm not convinced that transmitting addresses via voice should be a
usecase to target at

I think it should be. It's certainly not the most important way through
which addresses are communicated or verified, but I am trying to address
all places where humans interact with addresses. I have certainly tried to
verify addresses a few times through voice, when dealing with significant
amounts.

Regarding your QR code comments: it is certainly possible to find a more
compact QR code representation. That is not the goal of the BIP though -
it's trying to introduce one commonly recognizable format that has good
properties for all use cases, even if that means being suboptimal in
certain aspects for some.

> I don't understand your comment about non-english speaking users.
Obviously they cannot voice-communicate at all with only-english-speaking
users, so there is no need to communicate voice-communicate addresses
between them.

I assume that Peter Todd is talking about cases where English speakers are
interacting with non-native English speakers, who may know how to pronounce
numbers or alphabetical characters, but not all special characters.

> Speaking of URLs, actually Base 32 (as well as Base 43) makes QR codes
*bigger* because due to the characters used for URL parameters (?&=) those
QR codes are locked to binary mode.

I believe that is incorrect. Data in QR codes can switch from one mode to
another on a per-character basis (with an overhead of a few bits). I don't
know to what extent common QR encoders make intelligent decisions about
this, but it does not seem very hard.

By Lucas Ontivero:

> Here I think it could worth to mention that 58 requires mathematical
operations over big numbers. This is not very fast and most of the
programming languages don't provide support for big numbers OOB.

It's not that hard to emulate the bignum logic in languages that don't
support it. See for example this code in Bitcoin Core:
https://github.com/bitcoin/bitcoin/blob/v0.14.1/src/base58.cpp#L37L53. So I
think it's not necessary to go into all the possible ways Base58 can be
implemented in the document, and the existing language ("Base58 decoding is
complicated and relatively slow.") is sufficient.

> I understand that if a new generic encoding format is introduced that
could lead to some confusions but what if in the future there is a new type
of address that can also be encoded with bech32? Don't we need a address
type anyway?

I believe that it's likely that new types of outputs that may be introduced
in the future will most likely not be a simple constant byte sequence that
can be computed directly from addresses, but need some processing by the
sender. This is the case for example for Reusable/Stealth addresses and
Confidential Transactions addresses. Such outputs, if ever introduced on a
wide scale, should ideally not be representable as existing address types,
as that could not only lead to confusion, but also to lost privacy and
funds.

And, If there ever is a need for introducing a "constant scriptPubKey" type
address again, the encoding proposed in this document can be reused.
Currently, the header value can be at most 17. In the future new proposals
could give a meaning to values 18 through 31.


In general:

In the past weeks people have contributed two new reference implementations
(Haskell and Rust), and a C++ and Go one are underway (see
https://github.com/sipa/bech32).

I'd like to move forward and request a BIP number assignment for this
proposal.


Cheers,

-- 
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170507/926b2de1/attachment.html>

From pete at petertodd.org  Sun May  7 22:34:29 2017
From: pete at petertodd.org (Peter Todd)
Date: Sun, 7 May 2017 18:34:29 -0400
Subject: [bitcoin-dev] A BIP proposal for segwit addresses
In-Reply-To: <CAPg+sBiPiLHZFoYY=gs6LT+Q2Kb5NmbVU05u7c+0WRPjveBJhQ@mail.gmail.com>
References: <CAPg+sBh0sFA7b6a+48Oojwy655GB9W6Th8JiCpd+2ruQjPev8Q@mail.gmail.com>
	<CAPg+sBiPiLHZFoYY=gs6LT+Q2Kb5NmbVU05u7c+0WRPjveBJhQ@mail.gmail.com>
Message-ID: <20170507223429.GA23545@fedora-23-dvm>

On Sun, May 07, 2017 at 02:39:14PM -0700, Pieter Wuille via bitcoin-dev wrote:
> > I don't understand your comment about non-english speaking users.
> Obviously they cannot voice-communicate at all with only-english-speaking
> users, so there is no need to communicate voice-communicate addresses
> between them.
> 
> I assume that Peter Todd is talking about cases where English speakers are
> interacting with non-native English speakers, who may know how to pronounce
> numbers or alphabetical characters, but not all special characters.

Exactly - knowledge of the English language isn't a binary. Equally, I don't
remember ever learning names of special characters in French class back in
elementary school, but I do recall us drilling the alphabet and especially
numbers repeatedly.

If I were trying to tell a French speaker a BTC address, I'd probably be able
to succesfully do it with bech32, but not with any encoding using special
characters.

> In general:
> 
> In the past weeks people have contributed two new reference implementations
> (Haskell and Rust), and a C++ and Go one are underway (see
> https://github.com/sipa/bech32).

FWIW, I also did a partial rust implementation of just the Bech32 encoding for
a prototype non-BTC use-case. Other than the version number being it's own
"chunk" I found it very straight-forward to implement and I think it'll make
for a nice replacement for what otherwise would have been hex digests.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170507/9320e243/attachment.sig>

From karljohan-alm at garage.co.jp  Mon May  8 02:48:54 2017
From: karljohan-alm at garage.co.jp (Karl Johan Alm)
Date: Mon, 8 May 2017 11:48:54 +0900
Subject: [bitcoin-dev] BIP Proposal: Rate Limiting with server specified
	Proof of Work challenges
Message-ID: <CALJw2w7CBFU-xFnar6p4k+84Umh5rsuaQ6UA1-8E2_N3_AOSpQ@mail.gmail.com>

Hello,

I am proposing a new feature for rate limiting purposes where nodes
can make and solve arbitrary PoW challenges in return for connection
slots (to be expanded to cover e.g. bloom filters or other DoS risky
services).

The BIP currently includes two proofs of work (sha256 and
cuckoo-cycle) which can be combined (e.g. sha256(cuckoo-cycle) or
sha256(sha256(sha256)), etc).

Link: https://github.com/kallewoof/bips/blob/pow-connection-slots/bip-rate-limiting-via-pow.mediawiki

Feedback welcome.

From bitcoin42 at mail.com  Mon May  8 09:38:16 2017
From: bitcoin42 at mail.com (DJ Bitcoin)
Date: Mon, 8 May 2017 11:38:16 +0200
Subject: [bitcoin-dev] TXMempool and dirty entries
Message-ID: <trinity-a411f282-fb6a-4a08-9f17-55abd7762499-1494236296205@3capp-mailcom-lxa09>

An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170508/a2490e42/attachment.html>

From sdaftuar at gmail.com  Mon May  8 16:33:42 2017
From: sdaftuar at gmail.com (Suhas Daftuar)
Date: Mon, 8 May 2017 12:33:42 -0400
Subject: [bitcoin-dev] TXMempool and dirty entries
In-Reply-To: <trinity-a411f282-fb6a-4a08-9f17-55abd7762499-1494236296205@3capp-mailcom-lxa09>
References: <trinity-a411f282-fb6a-4a08-9f17-55abd7762499-1494236296205@3capp-mailcom-lxa09>
Message-ID: <CAFp6fsEDWR2n3QL8jyCxvmjbYNuk311UNkA=K4=otC4PVmuPXw@mail.gmail.com>

Hi,

I've moved the bitcoin-dev list to bcc:, as this question is better suited
to forums dedicated to Bitcoin Core implementation specifics, rather than
the general bitcoin development list.

Please feel free in the future to ask questions like this on the
bitcoin-core-dev mailing list (https://lists.linuxfoundation
.org/mailman/listinfo/bitcoin-core-dev) or on the #bitcoin-core-dev
freenode IRC channel.

The work limit (that was put in place in https://github.com/bitcoin/
bitcoin/pull/6654, when the concept of "dirty" entries was introduced) was
removed in https://github.com/bitcoin/bitcoin/pull/7594, in preparation for
ancestor-feerate-mining.  So those comments should have been cleaned up to
match the new code.

Please feel free to file an issue or open a PR to update those comments at
https://github.com/bitcoin/bitcoin.

Thanks,
Suhas


On Mon, May 8, 2017 at 5:38 AM, DJ Bitcoin via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi Guys,
>
> I have a question about the use of txmempool. find attached the code in
> txmempool.h
>
>
> ======================================================
> /* Adding transactions from a disconnected block can be very time
> consuming,
>  * because we don't have a way to limit the number of in-mempool
> descendants.
>  * To bound CPU processing, we limit the amount of work we're willing to do
>  * to properly update the descendant information for a tx being added from
>  * a disconnected block.  If we would exceed the limit, then we instead
> mark
>  * the entry as "dirty", and set the feerate for sorting purposes to be
> equal
>  * the feerate of the transaction without any descendants. */
>
> class CTxMemPoolEntry
> {
>    private:
>    // ...
>    // Information about descendants of this transaction that are in the
>    // mempool; if we remove this transaction we must remove all of these
>    // descendants as well. if nCountWithDescendants is 0, treat this entry
> as
>    // dirty, and nSizeWithDescendants and nModFeesWithDescendants will not
> be
>    // correct.
>
>    int64_t nCountWithDescendants; //!< number of descendant transactions
>    // ...
> ======================================================
>
>
> Now, the only place where nCountWithDescendants is modified is the
> following (txmempool.cpp):
>
>
> ======================================================
> void CTxMemPoolEntry::UpdateDescendantState(int64_t modifySize, CAmount
> modifyFee, int64_t modifyCount)
> {
>     nSizeWithDescendants += modifySize;
>     assert(int64_t(nSizeWithDescendants) > 0);
>     nModFeesWithDescendants += modifyFee;
>     nCountWithDescendants += modifyCount;
>     assert(int64_t(nCountWithDescendants) > 0);
> }
> ======================================================
>
>
> Therefore, nCountWithDescendants is never zero.
> Am i missing something? Where is this concept of "dirty" defined?
>
> Thanks a lot,
> DJ
>
>
>
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170508/dfb5c9f0/attachment.html>

From erik at q32.com  Mon May  8 18:58:54 2017
From: erik at q32.com (Erik Aronesty)
Date: Mon, 8 May 2017 14:58:54 -0400
Subject: [bitcoin-dev] BIP Proposal: Rate Limiting with server specified
 Proof of Work challenges
In-Reply-To: <CALJw2w7CBFU-xFnar6p4k+84Umh5rsuaQ6UA1-8E2_N3_AOSpQ@mail.gmail.com>
References: <CALJw2w7CBFU-xFnar6p4k+84Umh5rsuaQ6UA1-8E2_N3_AOSpQ@mail.gmail.com>
Message-ID: <CAJowKgJPZ=sQFXW631Czr7zYTX-ghg5ousjjkedJo-fXsefHvQ@mail.gmail.com>

- It would be cool if any rate-limiting POW was specified as bytecode ...
so nodes can plug in as many "machine-captcha" things as they please, and
solvers can choose to solve... or just say "nope too hard".

- Alternately, it would be a lot nicer if you just required people to pay a
nanobit .... that could prevent DDOS even better, and generate a revenue
stream for nodes.


On Sun, May 7, 2017 at 10:48 PM, Karl Johan Alm via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hello,
>
> I am proposing a new feature for rate limiting purposes where nodes
> can make and solve arbitrary PoW challenges in return for connection
> slots (to be expanded to cover e.g. bloom filters or other DoS risky
> services).
>
> The BIP currently includes two proofs of work (sha256 and
> cuckoo-cycle) which can be combined (e.g. sha256(cuckoo-cycle) or
> sha256(sha256(sha256)), etc).
>
> Link: https://github.com/kallewoof/bips/blob/pow-connection-
> slots/bip-rate-limiting-via-pow.mediawiki
>
> Feedback welcome.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170508/81601374/attachment.html>

From sergio.d.lerner at gmail.com  Mon May  8 21:00:10 2017
From: sergio.d.lerner at gmail.com (Sergio Demian Lerner)
Date: Mon, 8 May 2017 18:00:10 -0300
Subject: [bitcoin-dev] Full node "tip" function
In-Reply-To: <CAJowKgLzMZe1RcAW+FYsUZkvdZ5ZFf6cS5oJdZ=0apM0wMXc+g@mail.gmail.com>
References: <CAJowKg+snAUjbCFkTybNqiJCy=d_M3s5k376y1B=rVqD8WCOXA@mail.gmail.com>
	<201705032321.14356.luke@dashjr.org>
	<9335E0E0-F9D6-41AD-9FF9-5CDF2B1AF1F7@gmail.com>
	<CAJowKgLzMZe1RcAW+FYsUZkvdZ5ZFf6cS5oJdZ=0apM0wMXc+g@mail.gmail.com>
Message-ID: <CAKzdR-qbVAiXpuzAa+4VcBrq=h=65A-8ANTN3vOrVCV6fJ7yqQ@mail.gmail.com>

A full node provides several services to the network:

1?Broadcasts blocks (public service)
2?Broadcasts transactions (public/private service)
3?Increases privacy by hiding other node?s IPs
4?Increases network security by protecting it from global DoS.
5?Provides information filtering services to SPV nodes.
6?Provides historic blockchain and state information to new nodes.

With your tip idea you only encourages 6, and by increasing the number of
nodes, also 3 and 4.
The services 1 and 2 cannot be encouraged by tips.

However, it's a good way to start.

There was a way to encourage 2 I described in 2013. (
https://bitcointalk.org/index.php?topic=385528.msg4155300#msg4155300)

I'll soon present a solution to encourage full nodes to store the
blockchain based on Proof-of-Unique-Blockchain-Storage (PoUBS), a feature
that RSK will add to incentivize Bitcoin and RSK full nodes. This solution
encourages 6.



On Thu, May 4, 2017 at 4:28 PM, Erik Aronesty via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> This is actually LN?s killer use case - not buying coffees ;)
>>
>
> Yes, micro-payments for online network services is precisely what LN is
> best at.
>
> Establishing a channel with each peer is too expensive.   But using LN to
> micro-pay for high-quality peer services seems like it would aggregate very
> well.
>
> It would be great if this protocol was in-place and ready to go in or
> around the same time LN is ready.   It would incentivize full nodes even
> further than LN does, and allow the network to be strongly DDOS resistant.
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170508/02bf028a/attachment.html>

From natanael.l at gmail.com  Mon May  8 21:44:41 2017
From: natanael.l at gmail.com (Natanael)
Date: Mon, 8 May 2017 23:44:41 +0200
Subject: [bitcoin-dev] Full node "tip" function
In-Reply-To: <CAKzdR-qbVAiXpuzAa+4VcBrq=h=65A-8ANTN3vOrVCV6fJ7yqQ@mail.gmail.com>
References: <CAJowKg+snAUjbCFkTybNqiJCy=d_M3s5k376y1B=rVqD8WCOXA@mail.gmail.com>
	<201705032321.14356.luke@dashjr.org>
	<9335E0E0-F9D6-41AD-9FF9-5CDF2B1AF1F7@gmail.com>
	<CAJowKgLzMZe1RcAW+FYsUZkvdZ5ZFf6cS5oJdZ=0apM0wMXc+g@mail.gmail.com>
	<CAKzdR-qbVAiXpuzAa+4VcBrq=h=65A-8ANTN3vOrVCV6fJ7yqQ@mail.gmail.com>
Message-ID: <CAAt2M1-JC1CAkoYnEttaK_tKgGPFvm8f3-gQVvVm6EK4mKUz5g@mail.gmail.com>

Den 8 maj 2017 23:01 skrev "Sergio Demian Lerner via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org>:

I'll soon present a solution to encourage full nodes to store the
blockchain based on Proof-of-Unique-Blockchain-Storage (PoUBS)


Proving that you're holding your own copy of the blockchain, not shared
with other nodes? I don't think that's possible to do securely. It falls on
that the whole blockchain is both public and static, while any such proof
of independence needs to rely on unique capabilities per node.

All you can do with a challenge-response protocol is to prevent honest
nodes from being unwitting backends to dishonest transparent proxy nodes
(by binding the challenge to cryptographic node identities).

Even latency bounding protocols can't stop you from putting multiple
*seemingly independent* nodes in front of the same backend with one single
copy of the blockchain.

I believe best you can do is to force somebody to hold multiple copies
locally on multiple hardware units to not run out of memory I/O when
creating proofs for multiple remote nodes, through using memory heavy
functions for the proof of storage, forcing quick random access. However
somebody willing to put enough RAM in a server rack to hold the full
blockchain could still easily pretend to be multiple regular nodes with
independent copies.

Any kind of attempt at forcing the full copy of the blockchain to be in
memory close to the CPU will either rule out most nodes from passing or
will be cheatable.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170508/fd49c403/attachment-0001.html>

From sergio.d.lerner at gmail.com  Mon May  8 22:15:48 2017
From: sergio.d.lerner at gmail.com (Sergio Demian Lerner)
Date: Mon, 8 May 2017 19:15:48 -0300
Subject: [bitcoin-dev] Full node "tip" function
In-Reply-To: <CAAt2M1-JC1CAkoYnEttaK_tKgGPFvm8f3-gQVvVm6EK4mKUz5g@mail.gmail.com>
References: <CAJowKg+snAUjbCFkTybNqiJCy=d_M3s5k376y1B=rVqD8WCOXA@mail.gmail.com>
	<201705032321.14356.luke@dashjr.org>
	<9335E0E0-F9D6-41AD-9FF9-5CDF2B1AF1F7@gmail.com>
	<CAJowKgLzMZe1RcAW+FYsUZkvdZ5ZFf6cS5oJdZ=0apM0wMXc+g@mail.gmail.com>
	<CAKzdR-qbVAiXpuzAa+4VcBrq=h=65A-8ANTN3vOrVCV6fJ7yqQ@mail.gmail.com>
	<CAAt2M1-JC1CAkoYnEttaK_tKgGPFvm8f3-gQVvVm6EK4mKUz5g@mail.gmail.com>
Message-ID: <CAKzdR-qFXqPdRczxeQtmJVwBRx2QLNK1acAD1q1miLJthipsSA@mail.gmail.com>

Yes you practically can. No proxy can defeat the protocol investing less
money than buying storage space to store the blockchain.

Even with challenge-response delays of minutes.  That's why it will be
fully controlled by a RSK smart-contract, with no user intervention.
I'm will post about this soon.




On Mon, May 8, 2017 at 6:44 PM, Natanael <natanael.l at gmail.com> wrote:

>
> Den 8 maj 2017 23:01 skrev "Sergio Demian Lerner via bitcoin-dev" <
> bitcoin-dev at lists.linuxfoundation.org>:
>
> I'll soon present a solution to encourage full nodes to store the
> blockchain based on Proof-of-Unique-Blockchain-Storage (PoUBS)
>
>
> Proving that you're holding your own copy of the blockchain, not shared
> with other nodes? I don't think that's possible to do securely. It falls on
> that the whole blockchain is both public and static, while any such proof
> of independence needs to rely on unique capabilities per node.
>
> All you can do with a challenge-response protocol is to prevent honest
> nodes from being unwitting backends to dishonest transparent proxy nodes
> (by binding the challenge to cryptographic node identities).
>
> Even latency bounding protocols can't stop you from putting multiple
> *seemingly independent* nodes in front of the same backend with one single
> copy of the blockchain.
>
> I believe best you can do is to force somebody to hold multiple copies
> locally on multiple hardware units to not run out of memory I/O when
> creating proofs for multiple remote nodes, through using memory heavy
> functions for the proof of storage, forcing quick random access. However
> somebody willing to put enough RAM in a server rack to hold the full
> blockchain could still easily pretend to be multiple regular nodes with
> independent copies.
>
> Any kind of attempt at forcing the full copy of the blockchain to be in
> memory close to the CPU will either rule out most nodes from passing or
> will be cheatable.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170508/ae0f8ad0/attachment.html>

From sergio.d.lerner at gmail.com  Mon May  8 22:42:23 2017
From: sergio.d.lerner at gmail.com (Sergio Demian Lerner)
Date: Mon, 8 May 2017 19:42:23 -0300
Subject: [bitcoin-dev] Some real-world results about the current Segwit
	Discount
Message-ID: <CAKzdR-qojNn8OtUTPbxa0JauK9nmo2ZGm4ihKuyzsz_FAgokDw@mail.gmail.com>

I have processed 1000 blocks starting from Block #461653.

I computed several metrics, including the supposed size of witness data and
non-witness data (onchain), assuming all P2SH inputs/outputs are converted
to P2PWSH and all P2PKH inputs/outputs are converted to P2WPKH.

This takes into account that other types of transactions will not be
modified by Segwit (e.g. OP_RETURN outputs, or P2PK). This analysis doesn't
take into account that LN transactions may affect the current state,
 increasing the segwit/nosegwit ratio.

Among a lot of information, I've got the following real world results...

acMainChainSpace =352608924
acSegwitSpace =599400403
Ratio segwit/nosegwit=1.6999

This implies that the 75% that discount is not the best option to prevent
witness spam in a block of 4 MB, as stated in
https://segwit.org/why-a-discount-factor-of-4-why-not-2-or-8-bbcebe91721e.

The non-witness data weight factor should not be 4 but 2.35. The closest
integer value is 2, which leads to a 50% witness discount.

The Bitcoinj source code is available for anyone to review. I encourage
anyone to re-compute this with another utility to cross-check. Maybe
Antoine Le Calvez (p2sh.info) would like to double-check.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170508/aaeb7ba1/attachment.html>

From greg at xiph.org  Mon May  8 23:56:49 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Mon, 8 May 2017 23:56:49 +0000
Subject: [bitcoin-dev] Some real-world results about the current Segwit
	Discount
In-Reply-To: <CAKzdR-qojNn8OtUTPbxa0JauK9nmo2ZGm4ihKuyzsz_FAgokDw@mail.gmail.com>
References: <CAKzdR-qojNn8OtUTPbxa0JauK9nmo2ZGm4ihKuyzsz_FAgokDw@mail.gmail.com>
Message-ID: <CAAS2fgTMi8V3NsaueR72Ewy1V3C0PUvuR7Sv-kgS=oz7oiuSTA@mail.gmail.com>

On Mon, May 8, 2017 at 10:42 PM, Sergio Demian Lerner via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> The non-witness data weight factor should not be 4 but 2.35. The closest
> integer value is 2, which leads to a 50% witness discount.

Sergio, You've provided absolutely no information to qualify your
"should be".  It sounds like you are only measuring how much data is
witness vs non-witness while completely ignoring the relative cost of
UTXO bloat?  It's perfectly acceptable to increase the worst case in
one dimension while decreasing it in another-- and thats what segwit
does.

This sounds like a misunderstanding of what the factors should have
accomplish. The non-witness factor should be as large as possible
because the prunable witness data has little to no long term cost to
the system, no cost to lite clients, etc-- as eventually the system's
survival will require transitioning to starting from a state snapshot.
But it cannot be too large because of the hyperbolic increase in worst
case bandwidth.   Also, when starting from a state snapshot security
will require starting from an old one-- otherwise the whole system
becomes much closer to SPV security, so the cost of witness data
between there and the tip will still matter.

If I had any leaning to adjust it, it would be towards five-- not
towards even lower values.

> The Bitcoinj source code is available for anyone to review.

Where is it? (I have to say, I haven't found bitcoinj based things at
all readable but it would be worth seeing.)

From chjj at purse.io  Tue May  9 00:56:59 2017
From: chjj at purse.io (Christopher Jeffrey)
Date: Mon, 8 May 2017 17:56:59 -0700
Subject: [bitcoin-dev] Extension block proposal by Jeffrey et al
In-Reply-To: <F322F899-8748-407D-884F-95EFBD3C7F99@xbt.hk>
References: <20170405174343.GA7180@gmail.com>
	<F322F899-8748-407D-884F-95EFBD3C7F99@xbt.hk>
Message-ID: <20170509005659.GA1902@gmail.com>

Johnson,

Yeah, I do still see the issue. I think there are still some reasonable
ways to mitigate it.

I've started revising the extension block specification/code to coexist
with mainchain segwit. I think the benefit of this is that we can
require exiting outputs to only be witness programs. Presumably segwit
wallets will be more likely to be aware of a new output maturity rule
(I've opened a PR[1] which describes this in greater detail). I think
this probably reduces the likelihood of the legacy wallet issue,
assuming most segwit-supporting wallets would implement this rule before
the activation of segwit.

What's your opinion on whether this would have a great enough effect to
prevent the legacy wallet issue? I think switching to witness programs
only may be a good balance between fungibility and backward-compat,
probably better all around than creating a whole new
addr-type/wit-program just for exits.

[1] https://github.com/tothemoon-org/extension-blocks/pull/16

On Mon, Apr 10, 2017 at 06:14:36PM +0800, Johnson Lau wrote:
>
> > On 6 Apr 2017, at 01:43, Christopher Jeffrey <chjj at purse.io> wrote:
> >
> >
> >> This hits the biggest question I asked in my January post: do you want
> >> to allow direct exit payment to legacy addresses? As a block reorg
> >> will almost guarantee changing txid of the resolution tx, that will
> >> permanently invalidate all the child txs based on the resolution tx.
> >> This is a significant change to the current tx model. To fix this, you
> >> need to make exit outputs unspendable for up to 100 blocks. Doing
> >> this, however, will make legacy wallet users very confused as they do
> >> not anticipate funding being locked up for a long period of time. So
> >> you can?t let the money sent back to a legacy address directly, but
> >> sent to a new format address that only recognized by new wallet, which
> >> understands the lock up requirement. This way, however, introduces
> >> friction and some fungibility issues, and I?d expect people using
> >> cross chain atomic swap to exchange bitcoin and xbitcoin
> >
> > Yes, this issue is probably the biggest edge case in the proposal.
> >
> > I think there's two possible solutions:
> >
> > First solution:
> >
> > Like you said, add a maturity requirement for exiting outputs. Likely
> > lower than coinbase's 100 block requirement. To solve the issue of
> > non-upgraded wallets not being aware of this rule and spending early,
> > have upgraded mempool implementations accept/relay txs that contain
> > early spends of exits, but not mine them until they are mature. This way
> > non-upgraded wallets do not end up broadcasting transactions that are
> > considered invalid to the rest of the network.
>
> This won?t solve the problem. Think about the following conversation:
>
> Alice (not upgraded): Please pay 1 BTC to my address 1ALicExyz
> Bob (upgraded): ok, paid, please check
>
> 10 minutes later
>
> Alice: received and confirmed, thanks!
>
> 5 minutes later:
>
> Carol (not upgraded): Please pay 0.5BTC to my address 3CaroLXXX
> Alice: paid, please check
>
> 1 hour later:
>
> Carol: it?s not confirmed. Have you paid enough fees?
> Alice: ok, I?ll RBF/CPFP it
>
> 2 hours later:
>
> Carol: it?s still not confirmed.
> Alice: I have already paid double fees. Maybe the network is congested and I need to pay more?..
>
> Repeat until the lock up period ends.
>
> So this so-called ?softfork? actually made non-upgraded wallet totally unusable. If failed to meet the very important requirement of a softfork: backward compatibility
>
> More discussion:
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-April/013985.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-April/013985.html>
>
>
> >
> > Depending on how wallets handle reorgs, a non-upgraded wallet may put
> > reorg'd spend chains from exits back into an unconfirmed state, when in
> > reality they should probably delete them or mark them conflicted in some
> > way. This may be an acceptable compromise as the wallet will still see
> > the funds as unconfirmed when they really don't exist anymore, but maybe
> > unconfirmed is good enough. Users are pretty used to dropping
> > non-confirming txs from their wallet, and this is much better than
> > legacy wallets seeing there funds as confirmed when they could be
> > permanently reorged out at any moment.
> >
> > Second solution:
> >
> > Move all exiting outputs to the coinbase. This will enforce a 100 block
> > maturity requirement and non-upgraded wallets will be aware of this.
>
> This is also unacceptable.
>
> When someone says "Please pay 1 BTC to my address 1ALicExyz?, no one anticipates being paid by a coinbase output. Some exchanges like btc-e explicitly reject coinbase payment.
>
> Such deterioration in user experience is unacceptable. It basically forces everyone to upgrade, i.e. a hardfork with soft fork?s skin
>
>
>
> >
> > The first solution might require more implementation, but allows more
> > flexibility with the maturity requirement. The second solution is
> > possibly simpler, but sticks to a hard 100 block limit.
> >
> >> 1. Is it acceptable to have massive txid malleability and transaction
> >> chain invalidation for every natural happening reorg?  Yes: the
> >> current spec is ok; No: next question (I?d say no)
> >
> > Answered above.
> >
> >> 2. Is locking up exit outputs the best way to deal with the problem?
> >> (I tried really hard to find a better solution but failed)
> >
> > You've probably thought about this more than anyone, so I'd say yes, it
> > may be the only way. Painful, but necessary.
> >
> >> 3. How long the lock-up period should be? Answer could be anywhere
> >> from 1 to 100
> >
> > I imagine having something lower than 100 would be preferable to users,
> > maybe somewhere in the 5 to 15 range. A 15 block reorg on mainnet is
> > seriously unlikely unless something strange is happening. A 5 block
> > reorg is still pretty unlikely, but possible. The coinbase solution only
> > allows for 100 blocks though.
> >
> >> 4. With a lock-up period, should it allow direct exit to legacy
> >> address? (I think it?s ok if the lock-up is short, like 1-2 block. But
> >> is that safe enough?)
> >
> > I think so. Adding a kind of special address probably creates more
> > issues than it solves.
>
>
> As I explained above, no legacy wallet would anticipate a lock up. If you want to make a softfork, all burden of incompatibility must be taken by the upgraded system. Only allow exit to a new address guarantees that only upgraded wallet will see the locked-up tx:
>
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-January/013490.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-January/013490.html>
> >
> >> 5. Due to the fungibility issues, it may need a new name for the
> >> tokens in the ext-block
> >
> > I suppose the market will decide whether that's the case.
> >
> > It's worth noting, if segwit is not activated on the mainchain, it
> > creates a much bigger incentive to use the extension block, and
> > potentially ensures that users will have less of a reason to exit.
> >
>
> I think it?s unacceptable if malleability is not fixed in main chain, for 3 reasons:
>
> 1. a solution is *already* available and tested for > 1 year.
>
> 2. the deactivation design (which I think is an interesting idea) makes the ext block unsuitable for long-term storage of value.
>
> 3. LN over main chain allows instant exchange of main coin and xcoin without going through the ugly 2-way-peg process.
>
>
>

--
Christopher Jeffrey (JJ) <chjjeffrey at gmail.com>
CTO & Bitcoin Menace, purse.io
https://github.com/chjj
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170508/6eb88054/attachment-0001.sig>

From alp.bitcoin at gmail.com  Mon May  8 23:47:32 2017
From: alp.bitcoin at gmail.com (Alphonse Pace)
Date: Mon, 8 May 2017 18:47:32 -0500
Subject: [bitcoin-dev] Some real-world results about the current Segwit
	Discount
In-Reply-To: <CAKzdR-qojNn8OtUTPbxa0JauK9nmo2ZGm4ihKuyzsz_FAgokDw@mail.gmail.com>
References: <CAKzdR-qojNn8OtUTPbxa0JauK9nmo2ZGm4ihKuyzsz_FAgokDw@mail.gmail.com>
Message-ID: <CAMBsKS_j7Lso6fHoMPkrQ7UFwKfxOERAAqL=aUF83O4CqL+iFg@mail.gmail.com>

Sergio,

I'm not sure what the data you present has to do with the discount.  A 75%
discount prevents witness spam precisely because it is 75%, nothing more.
The current usage simply gives a guideline on how much capacity is gained
through a particular discount.  With the data you show, it would imply that
those blocks, with SegWit used where possible, would result in blocks of
~1.8MB.



On Mon, May 8, 2017 at 5:42 PM, Sergio Demian Lerner via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I have processed 1000 blocks starting from Block #461653.
>
> I computed several metrics, including the supposed size of witness data
> and non-witness data (onchain), assuming all P2SH inputs/outputs are
> converted to P2PWSH and all P2PKH inputs/outputs are converted to P2WPKH.
>
> This takes into account that other types of transactions will not be
> modified by Segwit (e.g. OP_RETURN outputs, or P2PK). This analysis doesn't
> take into account that LN transactions may affect the current state,
>  increasing the segwit/nosegwit ratio.
>
> Among a lot of information, I've got the following real world results...
>
> acMainChainSpace =352608924
> acSegwitSpace =599400403
> Ratio segwit/nosegwit=1.6999
>
> This implies that the 75% that discount is not the best option to prevent
> witness spam in a block of 4 MB, as stated in https://segwit.org/why-a-
> discount-factor-of-4-why-not-2-or-8-bbcebe91721e.
>
> The non-witness data weight factor should not be 4 but 2.35. The closest
> integer value is 2, which leads to a 50% witness discount.
>
> The Bitcoinj source code is available for anyone to review. I encourage
> anyone to re-compute this with another utility to cross-check. Maybe
> Antoine Le Calvez (p2sh.info) would like to double-check.
>
>
>
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170508/eda3ff72/attachment.html>

From karljohan-alm at garage.co.jp  Tue May  9 01:15:25 2017
From: karljohan-alm at garage.co.jp (Karl Johan Alm)
Date: Tue, 9 May 2017 10:15:25 +0900
Subject: [bitcoin-dev] BIP Proposal: Rate Limiting with server specified
 Proof of Work challenges
In-Reply-To: <CAJowKgJPZ=sQFXW631Czr7zYTX-ghg5ousjjkedJo-fXsefHvQ@mail.gmail.com>
References: <CALJw2w7CBFU-xFnar6p4k+84Umh5rsuaQ6UA1-8E2_N3_AOSpQ@mail.gmail.com>
	<CAJowKgJPZ=sQFXW631Czr7zYTX-ghg5ousjjkedJo-fXsefHvQ@mail.gmail.com>
Message-ID: <CALJw2w6TBpWXMGQXYcGLevLdYzfFQA_YMAr4Rn3qkQt=DNvDEA@mail.gmail.com>

Erik,

On Tue, May 9, 2017 at 3:58 AM, Erik Aronesty <erik at q32.com> wrote:
> - It would be cool if any rate-limiting POW was specified as bytecode ... so
> nodes can plug in as many "machine-captcha" things as they please, and
> solvers can choose to solve... or just say "nope too hard".

I'm not entirely sure what you mean, but right now you can make an
arbitrary chain of challenges, and the BIP includes methods for
determining an approximate time to solve (nodes will, at the very
least, discard any challenge which will on average take longer time to
solve than the expiration of the challenge itself, for example, i.e.
the "nope too hard" part).

> - Alternately, it would be a lot nicer if you just required people to pay a
> nanobit .... that could prevent DDOS even better, and generate a revenue
> stream for nodes.

Others mentioned this approach. I haven't given it much thought.
Admittedly it would be an effective way to prevent DoS but it also has
some unwanted side effects that need to be cleared up (e.g. in a
no-gains scenario like the BIP proposes, the node requesting PoW done
doesn't *gain* anything from lying to the node performing the work).

From sergio.d.lerner at gmail.com  Tue May  9 13:49:05 2017
From: sergio.d.lerner at gmail.com (Sergio Demian Lerner)
Date: Tue, 9 May 2017 10:49:05 -0300
Subject: [bitcoin-dev] Some real-world results about the current Segwit
	Discount
In-Reply-To: <CAMBsKS_j7Lso6fHoMPkrQ7UFwKfxOERAAqL=aUF83O4CqL+iFg@mail.gmail.com>
References: <CAKzdR-qojNn8OtUTPbxa0JauK9nmo2ZGm4ihKuyzsz_FAgokDw@mail.gmail.com>
	<CAMBsKS_j7Lso6fHoMPkrQ7UFwKfxOERAAqL=aUF83O4CqL+iFg@mail.gmail.com>
Message-ID: <CAKzdR-on-w9EF+2hLjchdyHB1gj7fi4QnybA=J4Cz7yyN3KKNA@mail.gmail.com>

This [1] article says the current discount prevents witness spam. Witness
spam is free space in the witness part of the block that can be filled by
miners to create bigger blocks with almost no cost for the benefit a
cluster of miners with low latency, increasing centralization.

The 75% discount does not prevent it, but on the contrary leaves a lot of
extra witness space for spam.

If the maximum block weight is set to 2.7M, each byte of non-witness block
costs 1.7, and each byte of witness costs 1, then a normal filled block
would be 2.7M bytes (1.7+1), and there will be no need to create ever a 4
Mbyte block. The worst case would be the average case, and the transaction
rate would be the maximum possible.

The current 75% discount can only achieve more transactions per second if
the type of transactions change. Therefore the current 75% discount only
makes the block size worst case worse (4 Mbytes when it should be 2.7
Mbytes).

80% of all inputs/outputs are P2PKH. The only way to make use of the extra
witness
space If most P2PKH transactions are replaced by multisigs (typically for
LN).

So it seems the 75% discount has been chosen with the idea that in the
future the current transaction pattern will shift towards multisigs. This
is not a bad idea, as it's the only direction Bitcoin can scale without a
HF.
But it's a bad idea if we end up doing, for example, a 2X blocksize
increase HF in the future. In that case it's much better to use a 50%
witness discount, and do not make scaling risky by making the worse case
block size 8 Mbytes, when it could have been 2*2.7=5.4 Mbytes.

I've uploaded the code here:
https://github.com/SergioDemianLerner/SegwitStats

 [1] https://segwit.org/why-a-discount-factor-of-4-why-not-
2-or-8-bbcebe91721e.


On Mon, May 8, 2017 at 8:47 PM, Alphonse Pace via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Sergio,
>
> I'm not sure what the data you present has to do with the discount.  A 75%
> discount prevents witness spam precisely because it is 75%, nothing more.
> The current usage simply gives a guideline on how much capacity is gained
> through a particular discount.  With the data you show, it would imply that
> those blocks, with SegWit used where possible, would result in blocks of
> ~1.8MB.
>
>
>
> On Mon, May 8, 2017 at 5:42 PM, Sergio Demian Lerner via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> I have processed 1000 blocks starting from Block #461653.
>>
>> I computed several metrics, including the supposed size of witness data
>> and non-witness data (onchain), assuming all P2SH inputs/outputs are
>> converted to P2PWSH and all P2PKH inputs/outputs are converted to P2WPKH.
>>
>> This takes into account that other types of transactions will not be
>> modified by Segwit (e.g. OP_RETURN outputs, or P2PK). This analysis doesn't
>> take into account that LN transactions may affect the current state,
>>  increasing the segwit/nosegwit ratio.
>>
>> Among a lot of information, I've got the following real world results...
>>
>> acMainChainSpace =352608924
>> acSegwitSpace =599400403
>> Ratio segwit/nosegwit=1.6999
>>
>> This implies that the 75% that discount is not the best option to prevent
>> witness spam in a block of 4 MB, as stated in
>> https://segwit.org/why-a-discount-factor-of-4-why-not-2-or-8-bbcebe91721e
>> .
>>
>> The non-witness data weight factor should not be 4 but 2.35. The closest
>> integer value is 2, which leads to a 50% witness discount.
>>
>> The Bitcoinj source code is available for anyone to review. I encourage
>> anyone to re-compute this with another utility to cross-check. Maybe
>> Antoine Le Calvez (p2sh.info) would like to double-check.
>>
>>
>>
>>
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170509/38a4f95e/attachment.html>

From james.hilliard1 at gmail.com  Tue May  9 14:33:34 2017
From: james.hilliard1 at gmail.com (James Hilliard)
Date: Tue, 9 May 2017 09:33:34 -0500
Subject: [bitcoin-dev] Some real-world results about the current Segwit
	Discount
In-Reply-To: <CAKzdR-on-w9EF+2hLjchdyHB1gj7fi4QnybA=J4Cz7yyN3KKNA@mail.gmail.com>
References: <CAKzdR-qojNn8OtUTPbxa0JauK9nmo2ZGm4ihKuyzsz_FAgokDw@mail.gmail.com>
	<CAMBsKS_j7Lso6fHoMPkrQ7UFwKfxOERAAqL=aUF83O4CqL+iFg@mail.gmail.com>
	<CAKzdR-on-w9EF+2hLjchdyHB1gj7fi4QnybA=J4Cz7yyN3KKNA@mail.gmail.com>
Message-ID: <CADvTj4pz9HauV7LD_uSnOJcrQ60W_2E76e16Ym4n6==NVffQvA@mail.gmail.com>

The discount is designed to reduce UTXO bloat primarily, witness spam
data would not make it into the UTXO set. The discount brings the fee
of a transaction more in line with the actual costs to the network for
the transaction. A miner spamming the network with 4MB witness blocks
would have very little impact on the UTXO size compared with 1MB
non-witness blocks. UTXO size is a bigger issue than blockchain size
since full nodes can't prune the UTXO set.

The discount of 75% for the SegWit softfork doesn't really have any
effect on future hard forks as it can always be adjusted as needed
later on as part of a HF.

On Tue, May 9, 2017 at 8:49 AM, Sergio Demian Lerner via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> This [1] article says the current discount prevents witness spam. Witness
> spam is free space in the witness part of the block that can be filled by
> miners to create bigger blocks with almost no cost for the benefit a cluster
> of miners with low latency, increasing centralization.
>
> The 75% discount does not prevent it, but on the contrary leaves a lot of
> extra witness space for spam.
>
> If the maximum block weight is set to 2.7M, each byte of non-witness block
> costs 1.7, and each byte of witness costs 1, then a normal filled block
> would be 2.7M bytes (1.7+1), and there will be no need to create ever a 4
> Mbyte block. The worst case would be the average case, and the transaction
> rate would be the maximum possible.
>
> The current 75% discount can only achieve more transactions per second if
> the type of transactions change. Therefore the current 75% discount only
> makes the block size worst case worse (4 Mbytes when it should be 2.7
> Mbytes).
>
> 80% of all inputs/outputs are P2PKH. The only way to make use of the extra
> witness
> space If most P2PKH transactions are replaced by multisigs (typically for
> LN).
>
> So it seems the 75% discount has been chosen with the idea that in the
> future the current transaction pattern will shift towards multisigs. This is
> not a bad idea, as it's the only direction Bitcoin can scale without a HF.
> But it's a bad idea if we end up doing, for example, a 2X blocksize increase
> HF in the future. In that case it's much better to use a 50% witness
> discount, and do not make scaling risky by making the worse case block size
> 8 Mbytes, when it could have been 2*2.7=5.4 Mbytes.
>
> I've uploaded the code here:
> https://github.com/SergioDemianLerner/SegwitStats
>
>  [1]
> https://segwit.org/why-a-discount-factor-of-4-why-not-2-or-8-bbcebe91721e.
>
>
> On Mon, May 8, 2017 at 8:47 PM, Alphonse Pace via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> Sergio,
>>
>> I'm not sure what the data you present has to do with the discount.  A 75%
>> discount prevents witness spam precisely because it is 75%, nothing more.
>> The current usage simply gives a guideline on how much capacity is gained
>> through a particular discount.  With the data you show, it would imply that
>> those blocks, with SegWit used where possible, would result in blocks of
>> ~1.8MB.
>>
>>
>>
>> On Mon, May 8, 2017 at 5:42 PM, Sergio Demian Lerner via bitcoin-dev
>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>> I have processed 1000 blocks starting from Block #461653.
>>>
>>> I computed several metrics, including the supposed size of witness data
>>> and non-witness data (onchain), assuming all P2SH inputs/outputs are
>>> converted to P2PWSH and all P2PKH inputs/outputs are converted to P2WPKH.
>>>
>>> This takes into account that other types of transactions will not be
>>> modified by Segwit (e.g. OP_RETURN outputs, or P2PK). This analysis doesn't
>>> take into account that LN transactions may affect the current state,
>>> increasing the segwit/nosegwit ratio.
>>>
>>> Among a lot of information, I've got the following real world results...
>>>
>>> acMainChainSpace =352608924
>>> acSegwitSpace =599400403
>>> Ratio segwit/nosegwit=1.6999
>>>
>>> This implies that the 75% that discount is not the best option to prevent
>>> witness spam in a block of 4 MB, as stated in
>>> https://segwit.org/why-a-discount-factor-of-4-why-not-2-or-8-bbcebe91721e.
>>>
>>> The non-witness data weight factor should not be 4 but 2.35. The closest
>>> integer value is 2, which leads to a 50% witness discount.
>>>
>>> The Bitcoinj source code is available for anyone to review. I encourage
>>> anyone to re-compute this with another utility to cross-check. Maybe Antoine
>>> Le Calvez (p2sh.info) would like to double-check.
>>>
>>>
>>>
>>>
>>>
>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From jl2012 at xbt.hk  Tue May  9 15:45:04 2017
From: jl2012 at xbt.hk (Johnson Lau)
Date: Tue, 9 May 2017 23:45:04 +0800
Subject: [bitcoin-dev] Some real-world results about the current Segwit
 Discount
In-Reply-To: <CAKzdR-on-w9EF+2hLjchdyHB1gj7fi4QnybA=J4Cz7yyN3KKNA@mail.gmail.com>
References: <CAKzdR-qojNn8OtUTPbxa0JauK9nmo2ZGm4ihKuyzsz_FAgokDw@mail.gmail.com>
	<CAMBsKS_j7Lso6fHoMPkrQ7UFwKfxOERAAqL=aUF83O4CqL+iFg@mail.gmail.com>
	<CAKzdR-on-w9EF+2hLjchdyHB1gj7fi4QnybA=J4Cz7yyN3KKNA@mail.gmail.com>
Message-ID: <7B918396-5968-4908-83C8-0F77DA8DB037@xbt.hk>


> On 9 May 2017, at 21:49, Sergio Demian Lerner via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> 
> So it seems the 75% discount has been chosen with the idea that in the future the current transaction pattern will shift towards multisigs. This is not a bad idea, as it's the only direction Bitcoin can scale without a HF. 
> But it's a bad idea if we end up doing, for example, a 2X blocksize increase HF in the future. In that case it's much better to use a 50% witness discount, and do not make scaling risky by making the worse case block size 8 Mbytes, when it could have been 2*2.7=5.4 Mbytes.
> 

As we could change any parameter in a hardfork, I don?t think this has any relation with the current BIP141 proposal. We could just use 75% in a softfork, and change that to a different value (or completely redefine the definition of weight) with a hardfork later.



From sergio.d.lerner at gmail.com  Tue May  9 16:19:13 2017
From: sergio.d.lerner at gmail.com (Sergio Demian Lerner)
Date: Tue, 9 May 2017 13:19:13 -0300
Subject: [bitcoin-dev] Some real-world results about the current Segwit
	Discount
In-Reply-To: <7B918396-5968-4908-83C8-0F77DA8DB037@xbt.hk>
References: <CAKzdR-qojNn8OtUTPbxa0JauK9nmo2ZGm4ihKuyzsz_FAgokDw@mail.gmail.com>
	<CAMBsKS_j7Lso6fHoMPkrQ7UFwKfxOERAAqL=aUF83O4CqL+iFg@mail.gmail.com>
	<CAKzdR-on-w9EF+2hLjchdyHB1gj7fi4QnybA=J4Cz7yyN3KKNA@mail.gmail.com>
	<7B918396-5968-4908-83C8-0F77DA8DB037@xbt.hk>
Message-ID: <CAKzdR-rKQaiKF18j44HjxuHY5pcmPwsce5ab-+zGRDnxjhBQdw@mail.gmail.com>

Thanks Johnson and Hampus for the clarifications.
However, I would rather do the opposite: soft-fork to 50% now, and
soft-fork again to 75% discount later if needed, because it doesn't affect
the max transactions/second.

Segwit as it is today should be activated. However if it is not before
November, then for the next Segwit attempt I would choose a more
conservative 50% discount.



On Tue, May 9, 2017 at 12:45 PM, Johnson Lau <jl2012 at xbt.hk> wrote:

>
> > On 9 May 2017, at 21:49, Sergio Demian Lerner via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> >
> > So it seems the 75% discount has been chosen with the idea that in the
> future the current transaction pattern will shift towards multisigs. This
> is not a bad idea, as it's the only direction Bitcoin can scale without a
> HF.
> > But it's a bad idea if we end up doing, for example, a 2X blocksize
> increase HF in the future. In that case it's much better to use a 50%
> witness discount, and do not make scaling risky by making the worse case
> block size 8 Mbytes, when it could have been 2*2.7=5.4 Mbytes.
> >
>
> As we could change any parameter in a hardfork, I don?t think this has any
> relation with the current BIP141 proposal. We could just use 75% in a
> softfork, and change that to a different value (or completely redefine the
> definition of weight) with a hardfork later.
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170509/e01b3062/attachment-0001.html>

From jl2012 at xbt.hk  Tue May  9 16:27:40 2017
From: jl2012 at xbt.hk (Johnson Lau)
Date: Wed, 10 May 2017 00:27:40 +0800
Subject: [bitcoin-dev] Some real-world results about the current Segwit
 Discount
In-Reply-To: <CAKzdR-rKQaiKF18j44HjxuHY5pcmPwsce5ab-+zGRDnxjhBQdw@mail.gmail.com>
References: <CAKzdR-qojNn8OtUTPbxa0JauK9nmo2ZGm4ihKuyzsz_FAgokDw@mail.gmail.com>
	<CAMBsKS_j7Lso6fHoMPkrQ7UFwKfxOERAAqL=aUF83O4CqL+iFg@mail.gmail.com>
	<CAKzdR-on-w9EF+2hLjchdyHB1gj7fi4QnybA=J4Cz7yyN3KKNA@mail.gmail.com>
	<7B918396-5968-4908-83C8-0F77DA8DB037@xbt.hk>
	<CAKzdR-rKQaiKF18j44HjxuHY5pcmPwsce5ab-+zGRDnxjhBQdw@mail.gmail.com>
Message-ID: <F5DCF911-5FCB-4FA7-8D42-86422CF366E8@xbt.hk>

No, changing from 50% to 75% is a hardfork. (75 -> 50 is a softfork). Unless you make it pre-scheduled, or leave a special ?backdoor? softfork to change the discount.

And that would certainly reduce the max tx/s with 50% discount, also reduce the incentive to spend witness UTXO. 

> On 10 May 2017, at 00:19, Sergio Demian Lerner <sergio.d.lerner at gmail.com> wrote:
> 
> Thanks Johnson and Hampus for the clarifications. 
> However, I would rather do the opposite: soft-fork to 50% now, and soft-fork again to 75% discount later if needed, because it doesn't affect the max transactions/second. 
> 
> Segwit as it is today should be activated. However if it is not before November, then for the next Segwit attempt I would choose a more conservative 50% discount.
> 
> 
> 
> On Tue, May 9, 2017 at 12:45 PM, Johnson Lau <jl2012 at xbt.hk <mailto:jl2012 at xbt.hk>> wrote:
> 
> > On 9 May 2017, at 21:49, Sergio Demian Lerner via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
> >
> >
> > So it seems the 75% discount has been chosen with the idea that in the future the current transaction pattern will shift towards multisigs. This is not a bad idea, as it's the only direction Bitcoin can scale without a HF.
> > But it's a bad idea if we end up doing, for example, a 2X blocksize increase HF in the future. In that case it's much better to use a 50% witness discount, and do not make scaling risky by making the worse case block size 8 Mbytes, when it could have been 2*2.7=5.4 Mbytes.
> >
> 
> As we could change any parameter in a hardfork, I don?t think this has any relation with the current BIP141 proposal. We could just use 75% in a softfork, and change that to a different value (or completely redefine the definition of weight) with a hardfork later.
> 
> 
> 


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170510/7cb9f0fc/attachment.html>

From james.hilliard1 at gmail.com  Tue May  9 16:27:59 2017
From: james.hilliard1 at gmail.com (James Hilliard)
Date: Tue, 9 May 2017 11:27:59 -0500
Subject: [bitcoin-dev] Some real-world results about the current Segwit
	Discount
In-Reply-To: <CAKzdR-rKQaiKF18j44HjxuHY5pcmPwsce5ab-+zGRDnxjhBQdw@mail.gmail.com>
References: <CAKzdR-qojNn8OtUTPbxa0JauK9nmo2ZGm4ihKuyzsz_FAgokDw@mail.gmail.com>
	<CAMBsKS_j7Lso6fHoMPkrQ7UFwKfxOERAAqL=aUF83O4CqL+iFg@mail.gmail.com>
	<CAKzdR-on-w9EF+2hLjchdyHB1gj7fi4QnybA=J4Cz7yyN3KKNA@mail.gmail.com>
	<7B918396-5968-4908-83C8-0F77DA8DB037@xbt.hk>
	<CAKzdR-rKQaiKF18j44HjxuHY5pcmPwsce5ab-+zGRDnxjhBQdw@mail.gmail.com>
Message-ID: <CADvTj4pSXxCirfFf_WU9x_TUmk7DmThM4a6yybOgq96hecc=Xg@mail.gmail.com>

Doing a second soft-fork from 50% to 75% sounds more difficult since
that's going from a more restrictive ruleset to less restrictive, you
might be able to hack around it but it wouldn't be a fully backwards
compatible change like going from 75% to 50% would be. 50% vs 75% does
affect max transactions/second in practice, the exact amount depends
on the real world usage of course though.

On Tue, May 9, 2017 at 11:19 AM, Sergio Demian Lerner via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Thanks Johnson and Hampus for the clarifications.
> However, I would rather do the opposite: soft-fork to 50% now, and soft-fork
> again to 75% discount later if needed, because it doesn't affect the max
> transactions/second.
>
> Segwit as it is today should be activated. However if it is not before
> November, then for the next Segwit attempt I would choose a more
> conservative 50% discount.
>
>
>
> On Tue, May 9, 2017 at 12:45 PM, Johnson Lau <jl2012 at xbt.hk> wrote:
>>
>>
>> > On 9 May 2017, at 21:49, Sergio Demian Lerner via bitcoin-dev
>> > <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> >
>> >
>> > So it seems the 75% discount has been chosen with the idea that in the
>> > future the current transaction pattern will shift towards multisigs. This is
>> > not a bad idea, as it's the only direction Bitcoin can scale without a HF.
>> > But it's a bad idea if we end up doing, for example, a 2X blocksize
>> > increase HF in the future. In that case it's much better to use a 50%
>> > witness discount, and do not make scaling risky by making the worse case
>> > block size 8 Mbytes, when it could have been 2*2.7=5.4 Mbytes.
>> >
>>
>> As we could change any parameter in a hardfork, I don?t think this has any
>> relation with the current BIP141 proposal. We could just use 75% in a
>> softfork, and change that to a different value (or completely redefine the
>> definition of weight) with a hardfork later.
>>
>>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From jl2012 at xbt.hk  Tue May  9 17:56:28 2017
From: jl2012 at xbt.hk (Johnson Lau)
Date: Wed, 10 May 2017 01:56:28 +0800
Subject: [bitcoin-dev] Extension block proposal by Jeffrey et al
In-Reply-To: <20170509005659.GA1902@gmail.com>
References: <20170405174343.GA7180@gmail.com>
	<F322F899-8748-407D-884F-95EFBD3C7F99@xbt.hk>
	<20170509005659.GA1902@gmail.com>
Message-ID: <BBB06F5F-4AC4-4FFD-AD1C-5304140E56C6@xbt.hk>

To make it completely transparent to unupgraded wallets, the return outputs have to be sent to something that is non-standard today, i.e. not P2PK, P2PKH, P2SH, bare multi-sig, and (with BIP141) v0 P2WPKH and v0 P2WSH.

Mainchain segwit is particularly important here, as that allows atomic swap between the bitcoin and xbitcoin. Only services with high liquidity (exchanges, payment processors) would need to occasionally settle between the chains.


> On 9 May 2017, at 08:56, Christopher Jeffrey <chjj at purse.io> wrote:
> 
> Johnson,
> 
> Yeah, I do still see the issue. I think there are still some reasonable
> ways to mitigate it.
> 
> I've started revising the extension block specification/code to coexist
> with mainchain segwit. I think the benefit of this is that we can
> require exiting outputs to only be witness programs. Presumably segwit
> wallets will be more likely to be aware of a new output maturity rule
> (I've opened a PR[1] which describes this in greater detail). I think
> this probably reduces the likelihood of the legacy wallet issue,
> assuming most segwit-supporting wallets would implement this rule before
> the activation of segwit.
> 
> What's your opinion on whether this would have a great enough effect to
> prevent the legacy wallet issue? I think switching to witness programs
> only may be a good balance between fungibility and backward-compat,
> probably better all around than creating a whole new
> addr-type/wit-program just for exits.
> 
> [1] https://github.com/tothemoon-org/extension-blocks/pull/16 <https://github.com/tothemoon-org/extension-blocks/pull/16>
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170510/5dfbf5ba/attachment-0001.html>

From raystonn at hotmail.com  Tue May  9 16:09:09 2017
From: raystonn at hotmail.com (Raystonn .)
Date: Tue, 9 May 2017 16:09:09 +0000
Subject: [bitcoin-dev] Network-layer attacks
Message-ID: <BN6PR18MB13483361D401D0A378BEBDCECDEF0@BN6PR18MB1348.namprd18.prod.outlook.com>

This study was released last week, detailing some attacks at the network layer: https://btc-hijack.ethz.ch/files/btc_hijack.pdf.  Of the countermeasures discussed in the paper, the use of encryption to secure communications between nodes looks like low hanging fruit.


Raystonn

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170509/6ad5633b/attachment.html>

From gsanders87 at gmail.com  Tue May  9 18:05:43 2017
From: gsanders87 at gmail.com (Greg Sanders)
Date: Tue, 9 May 2017 14:05:43 -0400
Subject: [bitcoin-dev] Network-layer attacks
In-Reply-To: <BN6PR18MB13483361D401D0A378BEBDCECDEF0@BN6PR18MB1348.namprd18.prod.outlook.com>
References: <BN6PR18MB13483361D401D0A378BEBDCECDEF0@BN6PR18MB1348.namprd18.prod.outlook.com>
Message-ID: <CAB3F3DvH_kVOOpoxOBxPQBnr+9jJfd8dd1D=P-Sdk_-an93Q0g@mail.gmail.com>

See https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki and
https://github.com/bitcoin/bips/blob/master/bip-0151.mediawiki

On Tue, May 9, 2017 at 12:09 PM, Raystonn . via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> This study was released last week, detailing some attacks at the network
> layer: https://btc-hijack.ethz.ch/files/btc_hijack.pdf.  Of the
> countermeasures discussed in the paper, the use of encryption
> to secure communications between nodes looks like low hanging fruit.
>
>
> Raystonn
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170509/573def94/attachment.html>

From lf-lists at mattcorallo.com  Tue May  9 18:15:45 2017
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Tue, 9 May 2017 18:15:45 +0000
Subject: [bitcoin-dev] Some real-world results about the current Segwit
 Discount
In-Reply-To: <CAKzdR-on-w9EF+2hLjchdyHB1gj7fi4QnybA=J4Cz7yyN3KKNA@mail.gmail.com>
References: <CAKzdR-qojNn8OtUTPbxa0JauK9nmo2ZGm4ihKuyzsz_FAgokDw@mail.gmail.com>
	<CAMBsKS_j7Lso6fHoMPkrQ7UFwKfxOERAAqL=aUF83O4CqL+iFg@mail.gmail.com>
	<CAKzdR-on-w9EF+2hLjchdyHB1gj7fi4QnybA=J4Cz7yyN3KKNA@mail.gmail.com>
Message-ID: <e86d9b29-f7dd-75da-e6c6-f55648bea104@mattcorallo.com>

I'm not sure who wrote segwit.org, but I wouldn't take it as
authoritative reasoning why we must do X over Y.

You seem to be claiming that there is not cost for a miner to fill
"extra witness space", but this is very untrue - in order to do so they
must forgo fees on other transactions. Your analysis on worst-case vs
normal-case blocks also seems flawed - there is a single limit, and not
a separate, secondary, witness limit.

You suggested "If the maximum block weight is set to 2.7M, each byte of
non-witness block costs 1.7", but these numbers dont work out - setting
the discount to 1.7 gets you a maximum block size of 1.7MB (in a soft
fork), not 2.7MB. If you set the max block weight to 2.7 with a 1.7x
discount, you have a hard fork. If you set the discount to 2.7x with a
2.7 weight limit, you dont get 2.7MB average-sized blocks, but smaller,
and still have the potential for padding blocks with pure-witness data
to create larger blocks.

Additionally, note that by padding blocks with larger witness data you
lose some of the CPU cost to validate as you no longer have as many
inputs (which have a maximal validation cost).

Further, I'm not sure why you're arguing for a given witness discount on
the basis of a future hardfork - it seems highly unlikely the community
is in a position to pull something like that off, and even if it were,
why set the witness discount with that assumption? If there were to be a
hardfork, we should probably tweak a bunch of parameters (see, eg, my
post from February of last year at
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-February/012403.html).

Maybe you could clarify your proposal a bit here, because the way I read
it you seem to have misunderstood SegWit's discount system.

On 05/09/17 13:49, Sergio Demian Lerner via bitcoin-dev wrote:
> This [1] article says the current discount prevents witness spam.
> Witness spam is free space in the witness part of the block that can be
> filled by miners to create bigger blocks with almost no cost for the
> benefit a cluster of miners with low latency, increasing centralization.
> 
> The 75% discount does not prevent it, but on the contrary leaves a lot
> of extra witness space for spam.
> 
> If the maximum block weight is set to 2.7M, each byte of non-witness
> block costs 1.7, and each byte of witness costs 1, then a normal filled
> block would be 2.7M bytes (1.7+1), and there will be no need to create
> ever a 4 Mbyte block. The worst case would be the average case, and the
> transaction rate would be the maximum possible.
> 
> The current 75% discount can only achieve more transactions per second
> if the type of transactions change. Therefore the current 75% discount
> only makes the block size worst case worse (4 Mbytes when it should be
> 2.7 Mbytes).
> 
> 80% of all inputs/outputs are P2PKH. The only way to make use of the
> extra witness 
> space If most P2PKH transactions are replaced by multisigs (typically
> for LN).
> 
> So it seems the 75% discount has been chosen with the idea that in the
> future the current transaction pattern will shift towards multisigs.
> This is not a bad idea, as it's the only direction Bitcoin can scale
> without a HF. 
> But it's a bad idea if we end up doing, for example, a 2X blocksize
> increase HF in the future. In that case it's much better to use a 50%
> witness discount, and do not make scaling risky by making the worse case
> block size 8 Mbytes, when it could have been 2*2.7=5.4 Mbytes.
> 
> I've uploaded the code here:
> https://github.com/SergioDemianLerner/SegwitStats
> 
>  [1] https://segwit.org/why-a-discount-factor-of-4-why-not-2-or-8-bbcebe91721e
> <https://segwit.org/why-a-discount-factor-of-4-why-not-2-or-8-bbcebe91721e>.
> 
> 
> On Mon, May 8, 2017 at 8:47 PM, Alphonse Pace via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org
> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
> 
>     Sergio,
> 
>     I'm not sure what the data you present has to do with the discount. 
>     A 75% discount prevents witness spam precisely because it is 75%,
>     nothing more.  The current usage simply gives a guideline on how
>     much capacity is gained through a particular discount.  With the
>     data you show, it would imply that those blocks, with SegWit used
>     where possible, would result in blocks of ~1.8MB.
> 
> 
> 
>     On Mon, May 8, 2017 at 5:42 PM, Sergio Demian Lerner via bitcoin-dev
>     <bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
> 
>         I have processed 1000 blocks starting from Block #461653.
> 
>         I computed several metrics, including the supposed size of
>         witness data and non-witness data (onchain), assuming all P2SH
>         inputs/outputs are converted to P2PWSH and all P2PKH
>         inputs/outputs are converted to P2WPKH.
> 
>         This takes into account that other types of transactions will
>         not be modified by Segwit (e.g. OP_RETURN outputs, or P2PK).
>         This analysis doesn't take into account that LN transactions may
>         affect the current state,  increasing the segwit/nosegwit ratio.
> 
>         Among a lot of information, I've got the following real world
>         results...
> 
>         acMainChainSpace =352608924
>         acSegwitSpace =599400403
>         Ratio segwit/nosegwit=1.6999
> 
>         This implies that the 75% that discount is not the best option
>         to prevent witness spam in a block of 4 MB, as stated in
>         https://segwit.org/why-a-discount-factor-of-4-why-not-2-or-8-bbcebe91721e
>         <https://segwit.org/why-a-discount-factor-of-4-why-not-2-or-8-bbcebe91721e>.
> 
>         The non-witness data weight factor should not be 4 but 2.35. The
>         closest integer value is 2, which leads to a 50% witness discount.
> 
>         The Bitcoinj source code is available for anyone to review. I
>         encourage anyone to re-compute this with another utility to
>         cross-check. Maybe Antoine Le Calvez (p2sh.info
>         <http://p2sh.info>) would like to double-check.
> 
> 
> 
> 
> 
> 
>         _______________________________________________
>         bitcoin-dev mailing list
>         bitcoin-dev at lists.linuxfoundation.org
>         <mailto:bitcoin-dev at lists.linuxfoundation.org>
>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>         <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
> 
> 
> 
>     _______________________________________________
>     bitcoin-dev mailing list
>     bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>     <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
> 
> 
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From sergio.d.lerner at gmail.com  Tue May  9 18:58:25 2017
From: sergio.d.lerner at gmail.com (Sergio Demian Lerner)
Date: Tue, 9 May 2017 15:58:25 -0300
Subject: [bitcoin-dev] Some real-world results about the current Segwit
	Discount
In-Reply-To: <e86d9b29-f7dd-75da-e6c6-f55648bea104@mattcorallo.com>
References: <CAKzdR-qojNn8OtUTPbxa0JauK9nmo2ZGm4ihKuyzsz_FAgokDw@mail.gmail.com>
	<CAMBsKS_j7Lso6fHoMPkrQ7UFwKfxOERAAqL=aUF83O4CqL+iFg@mail.gmail.com>
	<CAKzdR-on-w9EF+2hLjchdyHB1gj7fi4QnybA=J4Cz7yyN3KKNA@mail.gmail.com>
	<e86d9b29-f7dd-75da-e6c6-f55648bea104@mattcorallo.com>
Message-ID: <CAKzdR-pyE2f0jdsU+QGbJQ9gMepsyS880kntE9MRvDBLG_Nchg@mail.gmail.com>

>
>
>
> You suggested "If the maximum block weight is set to 2.7M, each byte of
> non-witness block costs 1.7", but these numbers dont work out - setting
> the discount to 1.7 gets you a maximum block size of 1.7MB (in a soft
> fork), not 2.7MB.


Yes. In a soft-fork is true.
I was thinking about what a HF could do to optimize the balance, and I
forgot I was in the context of a SF.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170509/473e88df/attachment.html>

From sergio.d.lerner at gmail.com  Tue May  9 19:15:32 2017
From: sergio.d.lerner at gmail.com (Sergio Demian Lerner)
Date: Tue, 9 May 2017 16:15:32 -0300
Subject: [bitcoin-dev] Some real-world results about the current Segwit
	Discount
In-Reply-To: <CAKzdR-pyE2f0jdsU+QGbJQ9gMepsyS880kntE9MRvDBLG_Nchg@mail.gmail.com>
References: <CAKzdR-qojNn8OtUTPbxa0JauK9nmo2ZGm4ihKuyzsz_FAgokDw@mail.gmail.com>
	<CAMBsKS_j7Lso6fHoMPkrQ7UFwKfxOERAAqL=aUF83O4CqL+iFg@mail.gmail.com>
	<CAKzdR-on-w9EF+2hLjchdyHB1gj7fi4QnybA=J4Cz7yyN3KKNA@mail.gmail.com>
	<e86d9b29-f7dd-75da-e6c6-f55648bea104@mattcorallo.com>
	<CAKzdR-pyE2f0jdsU+QGbJQ9gMepsyS880kntE9MRvDBLG_Nchg@mail.gmail.com>
Message-ID: <CAKzdR-pN0B-wjhPh3n6Jw7L6wsz9yQ=kyVX7NYx5ACZC3bg8OA@mail.gmail.com>

Let n be the non-segwit bytes. Let the seg/noseg ratio be 1.7.

Segwit with 75% discount: (let WITNESS_SCALE_FACTOR=4)
n*WITNESS_SCALE_FACTOR+n*1.7 = 4,000,000
Then n=4,000,000 / 5.7 = 701K
Average block size = 701K*(1+1.7)=1.8 Mbytes
Maximum block size = 4 MBytes

Segwit with 50% discount + 2MB HF: (let WITNESS_SCALE_FACTOR=2)
n*2+n*1.7 = 4,000,000
n = 4,000,000/ 3.7 = 1.08M
Average block size = 1.08M*(1+1.7)=2.9 Mbytes
Maximum block size = 4 MBytes

The capacity of Segwit(50%)+2MbHF is 50% more than Segwit, and the maximum
block size is the same.


On Tue, May 9, 2017 at 3:58 PM, Sergio Demian Lerner <
sergio.d.lerner at gmail.com> wrote:

>
>>
>> You suggested "If the maximum block weight is set to 2.7M, each byte of
>> non-witness block costs 1.7", but these numbers dont work out - setting
>> the discount to 1.7 gets you a maximum block size of 1.7MB (in a soft
>> fork), not 2.7MB.
>
>
> Yes. In a soft-fork is true.
> I was thinking about what a HF could do to optimize the balance, and I
> forgot I was in the context of a SF.
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170509/4a3d4465/attachment-0001.html>

From greg at xiph.org  Tue May  9 19:30:52 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Tue, 9 May 2017 19:30:52 +0000
Subject: [bitcoin-dev] Some real-world results about the current Segwit
	Discount
In-Reply-To: <CAKzdR-pN0B-wjhPh3n6Jw7L6wsz9yQ=kyVX7NYx5ACZC3bg8OA@mail.gmail.com>
References: <CAKzdR-qojNn8OtUTPbxa0JauK9nmo2ZGm4ihKuyzsz_FAgokDw@mail.gmail.com>
	<CAMBsKS_j7Lso6fHoMPkrQ7UFwKfxOERAAqL=aUF83O4CqL+iFg@mail.gmail.com>
	<CAKzdR-on-w9EF+2hLjchdyHB1gj7fi4QnybA=J4Cz7yyN3KKNA@mail.gmail.com>
	<e86d9b29-f7dd-75da-e6c6-f55648bea104@mattcorallo.com>
	<CAKzdR-pyE2f0jdsU+QGbJQ9gMepsyS880kntE9MRvDBLG_Nchg@mail.gmail.com>
	<CAKzdR-pN0B-wjhPh3n6Jw7L6wsz9yQ=kyVX7NYx5ACZC3bg8OA@mail.gmail.com>
Message-ID: <CAAS2fgQsT7c+CEfC+U9N+g-+V4s8WnQjRqDddfCKMb6+BkJ3-A@mail.gmail.com>

On Tue, May 9, 2017 at 7:15 PM, Sergio Demian Lerner via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> The capacity of Segwit(50%)+2MbHF is 50% more than Segwit, and the maximum
> block size is the same.

And the UTXO bloat potential is twice as large and the cost of that
UTXO bloat is significantly reduced.  So you're basically gutting the
most of the gain from weight, making something incompatible, etc.

I'm not sure what to explain-- even that page on segwit.org explains
that the values are selected to balance worst case costs not to
optimize one to the total exclusion of others. Raw size is not very
relevant in the long run, but if your goal were to optimize for it
(which it seems to be), then the limit should be pure size.

From lf-lists at mattcorallo.com  Tue May  9 19:42:56 2017
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Tue, 9 May 2017 19:42:56 +0000
Subject: [bitcoin-dev] Some real-world results about the current Segwit
 Discount
In-Reply-To: <CAAS2fgQsT7c+CEfC+U9N+g-+V4s8WnQjRqDddfCKMb6+BkJ3-A@mail.gmail.com>
References: <CAKzdR-qojNn8OtUTPbxa0JauK9nmo2ZGm4ihKuyzsz_FAgokDw@mail.gmail.com>
	<CAMBsKS_j7Lso6fHoMPkrQ7UFwKfxOERAAqL=aUF83O4CqL+iFg@mail.gmail.com>
	<CAKzdR-on-w9EF+2hLjchdyHB1gj7fi4QnybA=J4Cz7yyN3KKNA@mail.gmail.com>
	<e86d9b29-f7dd-75da-e6c6-f55648bea104@mattcorallo.com>
	<CAKzdR-pyE2f0jdsU+QGbJQ9gMepsyS880kntE9MRvDBLG_Nchg@mail.gmail.com>
	<CAKzdR-pN0B-wjhPh3n6Jw7L6wsz9yQ=kyVX7NYx5ACZC3bg8OA@mail.gmail.com>
	<CAAS2fgQsT7c+CEfC+U9N+g-+V4s8WnQjRqDddfCKMb6+BkJ3-A@mail.gmail.com>
Message-ID: <f4605b47-03be-7493-fa3a-19ad4def3fa8@mattcorallo.com>

There is something in between throwing the SegWit goals out the window
(as Sergio seems to be advocating for) and having a higher discount
ratio (which is required for the soft fork version to be useful).

When I first started looking at the problem I very much wanted to reduce
the worst-case block size (though have come around to caring a bit less
about that thanks to all the work in FIBRE and other similar systems
over the past year or two), but rapidly realized that just reducing the
Segwit discount wasn't really the right solution here.

You might as well take the real win and reduce the cost of the input
prevout itself so that average inputs are less expensive than outputs
(which SegWit doesn't quite achieve due to the large prevout size - 40
bytes). This way you can reduce the discount, still get the SegWit goal,
and get a lower ratio between worst-case and average-case block size,
though, frankly, I'm less interested in the last one these days, at
least for reasonable parameters. If you're gonna look at hard forks,
limiting yourself to just the parameters that we can tweak in a soft
fork seems short-sighted, at beast.

Matt

On 05/09/17 19:30, Gregory Maxwell wrote:
> On Tue, May 9, 2017 at 7:15 PM, Sergio Demian Lerner via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> The capacity of Segwit(50%)+2MbHF is 50% more than Segwit, and the maximum
>> block size is the same.
> 
> And the UTXO bloat potential is twice as large and the cost of that
> UTXO bloat is significantly reduced.  So you're basically gutting the
> most of the gain from weight, making something incompatible, etc.
> 
> I'm not sure what to explain-- even that page on segwit.org explains
> that the values are selected to balance worst case costs not to
> optimize one to the total exclusion of others. Raw size is not very
> relevant in the long run, but if your goal were to optimize for it
> (which it seems to be), then the limit should be pure size.
> 

From greg at xiph.org  Tue May  9 20:13:14 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Tue, 9 May 2017 20:13:14 +0000
Subject: [bitcoin-dev] Some real-world results about the current Segwit
	Discount
In-Reply-To: <f4605b47-03be-7493-fa3a-19ad4def3fa8@mattcorallo.com>
References: <CAKzdR-qojNn8OtUTPbxa0JauK9nmo2ZGm4ihKuyzsz_FAgokDw@mail.gmail.com>
	<CAMBsKS_j7Lso6fHoMPkrQ7UFwKfxOERAAqL=aUF83O4CqL+iFg@mail.gmail.com>
	<CAKzdR-on-w9EF+2hLjchdyHB1gj7fi4QnybA=J4Cz7yyN3KKNA@mail.gmail.com>
	<e86d9b29-f7dd-75da-e6c6-f55648bea104@mattcorallo.com>
	<CAKzdR-pyE2f0jdsU+QGbJQ9gMepsyS880kntE9MRvDBLG_Nchg@mail.gmail.com>
	<CAKzdR-pN0B-wjhPh3n6Jw7L6wsz9yQ=kyVX7NYx5ACZC3bg8OA@mail.gmail.com>
	<CAAS2fgQsT7c+CEfC+U9N+g-+V4s8WnQjRqDddfCKMb6+BkJ3-A@mail.gmail.com>
	<f4605b47-03be-7493-fa3a-19ad4def3fa8@mattcorallo.com>
Message-ID: <CAAS2fgQv84WgScOkAt_FttgQHjGbRMBmjXA8_EcmyL_K=WCCWA@mail.gmail.com>

On Tue, May 9, 2017 at 7:42 PM, Matt Corallo <lf-lists at mattcorallo.com> wrote:
> at beast.

Rawr.

From sergio.d.lerner at gmail.com  Tue May  9 20:58:35 2017
From: sergio.d.lerner at gmail.com (Sergio Demian Lerner)
Date: Tue, 9 May 2017 17:58:35 -0300
Subject: [bitcoin-dev] Some real-world results about the current Segwit
	Discount
In-Reply-To: <CAAS2fgQv84WgScOkAt_FttgQHjGbRMBmjXA8_EcmyL_K=WCCWA@mail.gmail.com>
References: <CAKzdR-qojNn8OtUTPbxa0JauK9nmo2ZGm4ihKuyzsz_FAgokDw@mail.gmail.com>
	<CAMBsKS_j7Lso6fHoMPkrQ7UFwKfxOERAAqL=aUF83O4CqL+iFg@mail.gmail.com>
	<CAKzdR-on-w9EF+2hLjchdyHB1gj7fi4QnybA=J4Cz7yyN3KKNA@mail.gmail.com>
	<e86d9b29-f7dd-75da-e6c6-f55648bea104@mattcorallo.com>
	<CAKzdR-pyE2f0jdsU+QGbJQ9gMepsyS880kntE9MRvDBLG_Nchg@mail.gmail.com>
	<CAKzdR-pN0B-wjhPh3n6Jw7L6wsz9yQ=kyVX7NYx5ACZC3bg8OA@mail.gmail.com>
	<CAAS2fgQsT7c+CEfC+U9N+g-+V4s8WnQjRqDddfCKMb6+BkJ3-A@mail.gmail.com>
	<f4605b47-03be-7493-fa3a-19ad4def3fa8@mattcorallo.com>
	<CAAS2fgQv84WgScOkAt_FttgQHjGbRMBmjXA8_EcmyL_K=WCCWA@mail.gmail.com>
Message-ID: <CAKzdR-qsj9Ag8o1UqcgZpKTVRwXm2+qJuHfxHu6keLgkWeEnAw@mail.gmail.com>

I agree with you Matt.
I'm artificially limiting myself to changing the parameters of Segwit as it
is..

This is motivated by the idea that a consensual HF in the current state
would have greater chance of acceptance if it changes the minimum number of
lines of code.



On Tue, May 9, 2017 at 5:13 PM, Gregory Maxwell <greg at xiph.org> wrote:

> On Tue, May 9, 2017 at 7:42 PM, Matt Corallo <lf-lists at mattcorallo.com>
> wrote:
> > at beast.
>
> Rawr.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170509/d8ac393a/attachment.html>

From eric at voskuil.org  Tue May  9 23:11:31 2017
From: eric at voskuil.org (Eric Voskuil)
Date: Tue, 9 May 2017 16:11:31 -0700
Subject: [bitcoin-dev] Network-layer attacks
In-Reply-To: <BN6PR18MB13483361D401D0A378BEBDCECDEF0@BN6PR18MB1348.namprd18.prod.outlook.com>
References: <BN6PR18MB13483361D401D0A378BEBDCECDEF0@BN6PR18MB1348.namprd18.prod.outlook.com>
Message-ID: <c78f6d0f-5eb4-31d2-1dbc-53eec5f70784@voskuil.org>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

On 05/09/2017 09:09 AM, Raystonn . via bitcoin-dev wrote:
> This study was released last week, detailing some attacks at the
> network layer: https://btc-hijack.ethz.ch/files/btc_hijack.pdf.  Of
> the countermeasures discussed in the paper, the use of encryption 
> to secure communications between nodes looks like low hanging
> fruit.

I draw a very different conclusion.

The paper states:

?Our work underscores the importance of proposed modifications which
argue for encrypting Bitcoin traffic or traffic exchanged among miners.?

The phrase, ?encrypting ... traffic exchanged among miners,? is not
merely about encryption, since if one cannot identify the peer as the
intended miner it could just as well be an attacker. This is about
(presumably encrypted) authenticated connections.

Indeed, encryption of traffic among miners is referred to again here:

?Finally, an attacker cannot intercept (possibly encrypted) private
connections, corresponding to peering agreements between mining pools.
- From the attacker?s point of view, these connections can be treated as
intra-pool connections and the corresponding pair of pools can be
considered as one larger pool.?

So the encryption-based defense for miners is to use authentication to
create, ?one larger pool,? consisting of, ?private connections.?

Additionally it states, ?we show that hijacking fewer than 100
prefixes is enough to isolate a large amount of the mining power due
to Bitcoin?s centralization.?

In other words the proposed solution, to what is largely a problem of
miner centralization, is to create one miner. The paper doesn?t
attempt to investigate the downside to that apparent centralization
spiral.

The paper investigates routing attacks on the p2p protocol,
specifically partitioning and delay. Regarding traffic encryption it
*stresses* the caution:

?Yet, we stress that not all routing attacks will be solved by such
measures since attackers can still disrupt connectivity and isolate
nodes by dropping Bitcoin packets instead of modifying them.?

In other words it recognizes that encryption is both centralizing and
ineffective. Along these lines it also observes:

* A smaller set of nodes will be easier to isolate for extended periods.
* All incoming connection slots can be occupied by connections from
attacker nodes.
* Outgoing connections can be biased via a traditional eclipse attack.

Notice that none of these issues are mitigated by encryption, since in
each case the encrypted connection may just as easily be the attacker.
The presumed powerful attacker (one with the ability to modify
Internet routing tables) is not deterred by encryption. Instead of
modifying or dropping packets he can simply redirect traffic to his
own node(s) and carry on the attack on an encrypted connection with
the victim. As such all calls for encryption in the P2P protocol
ultimately end in calls for authentication.

It is true that if all connections are authenticated these attacks are
mitigated. But as the ?one larger pool? discussion shows, this is
simply a regression to a private network.

As for the two scenarios analyzed, the summary on delay attacks includes
:

* Delay attackers intercepting 50% of a node?s connection can waste
63% of its mining power.
* Due to pools multi-homing, Bitcoin (as a whole) is not vulnerable to
delay attackers, even powerful ones.
* Even a small degree of multi-homing is enough to protect Bitcoin
from powerful attackers.

Furthermore, the delay attack scenario explicitly relies on, ?the fact
that a [Core] Bitcoin node waits for 20 minutes after having requested
a block from a peer before requesting it again from another peer.? The
waste of mining power above is a function of that delay. So delay is
not a material concern for the entire network, and there are
mitigations that hang much lower than making the network private.

Regarding partitioning, clearly neither encryption nor authentication
can ensure that one is seeing the strongest chain unless the network
is fully private (and trustworthy). The paper states, ?Increase
partition persistence: ... Intuitively, the attacker needs to suppress
the effect of churn in order to keep the victim nodes isolated.? In
other words, simply rotating connections is presumed to be effective.

There are other useful countermeasures listed in the paper:

* Increase the diversity of node connections
* Select Bitcoin peers while taking routing into account
* Monitor round-trip time (RTT)
* Monitor additional statistics
* Embrace churn
* Use gateways in different ASes
* Prefer peers hosted in the same AS and in /24 prefixes
* Use distinct control and data channels
* Use UDP heartbeats
* Request a block on multiple connections

The single recommendation that includes encryption is heavily qualified:

* Encrypt Bitcoin Communication and/or adopt MAC
"While encrypting Bitcoin connections would not prevent adversaries
from dropping packets, it would prevent them from eavesdropping
connections and modifying key messages. Alternatively, using a Message
Authentication Code (MAC) to validate that the content of each message
has not been changed would make delay attacks much more difficult."

First, it should be widely understood that eavesdropping on the relay
of public information is not an attack. Secondly, the paper clearly
states, ?attackers can still disrupt connectivity and isolate nodes by
dropping Bitcoin packets instead of modifying them.? So the
distinction between dropping and modifying messages is immaterial. And
thirdly, the paper recognizes that eclipse attacks remain effective
short of authentication.

Taken alongside the risk of centralization though the widespread use
of authentication, which the paper does not contemplate, encryption is
anything but low hanging fruit. Several of the other above mitigations
are described as effective, and it is the case that some nodes already
employ some of them. Libbitcoin for example embraces churn by
providing both configurable and partially-randomized connection
timeout and a configurable block withholding timeout.

The paper is a valuable contribution in assessing risks to the P2P
network and individual nodes, and suggesting mitigations, but it is
not comprehensive. As with block size, the most obvious answer is not
always the right answer. Bitcoin is a public cache of independently
verifiable information shared anonymously over a P2P network. The
primary threat is centralization. Authentication is a necessary aspect
of centralizing the network.

e
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (GNU/Linux)

iQEcBAEBCAAGBQJZEkyWAAoJEDzYwH8LXOFOwW4H/2icvGAiKmSSI8+TtiI52hDC
SouctpRXE/R0BSs1+KkSnj8c6nwNDqwpWWzKyDLVHT53FBk5cbUkUnTCev+MxZvm
srk63/nnI12/7RpEVoPVEiHXYd60hzNjN2Fod1ox+lN7Ln3nf22f+3ZP2evv8ETd
jZSnjVlOcnRrx/s67iE+n+IYPAtAENcxQhzZtGY1vLLgRrX7YbKlgjI8DNuSOgvZ
VugTU3NeahUpGJQ5tvBWt0eHE0StzvcoCpts58Eozs4rnp7FWWDNYH9dtyzgqM6/
qONC0MEHtO63PQ09DriHpAAUDw9xXCGOyv6aJ1TErzkJEXmkHn0QxUg/sYknL18=
=jAkv
-----END PGP SIGNATURE-----

From chjj at purse.io  Wed May 10 01:19:30 2017
From: chjj at purse.io (Christopher Jeffrey)
Date: Tue, 9 May 2017 18:19:30 -0700
Subject: [bitcoin-dev] Extension block proposal by Jeffrey et al
In-Reply-To: <BBB06F5F-4AC4-4FFD-AD1C-5304140E56C6@xbt.hk>
References: <20170405174343.GA7180@gmail.com>
	<F322F899-8748-407D-884F-95EFBD3C7F99@xbt.hk>
	<20170509005659.GA1902@gmail.com>
	<BBB06F5F-4AC4-4FFD-AD1C-5304140E56C6@xbt.hk>
Message-ID: <20170510011930.GA14666@gmail.com>

> To make it completely transparent to unupgraded wallets, the return outputs have to be sent to something that is non-standard today, i.e. not P2PK, P2PKH, P2SH, bare multi-sig, and (with BIP141) v0 P2WPKH and v0 P2WSH.

Johnson,

I feel that's not as much of an issue with v0 witness programs. Segwit
isn't activated yet, and segwit-capable wallets aren't as widely
deployed for production. Not to mention, they're all going to require
further development anyway: the address serialization for witness
programs only became a BIP this week. No segwit wallets should ever be
planning to receive money to naked witness programs right now, since
addresses are for it aren't even available.

I think we have the benefit of timing here. The state of segwit wallet
development incidentally creates a window of time where this maturity
rule can be implemented.

On Wed, May 10, 2017 at 01:56:28AM +0800, Johnson Lau wrote:
> To make it completely transparent to unupgraded wallets, the return outputs have to be sent to something that is non-standard today, i.e. not P2PK, P2PKH, P2SH, bare multi-sig, and (with BIP141) v0 P2WPKH and v0 P2WSH.
>
> Mainchain segwit is particularly important here, as that allows atomic swap between the bitcoin and xbitcoin. Only services with high liquidity (exchanges, payment processors) would need to occasionally settle between the chains.
>
>
> > On 9 May 2017, at 08:56, Christopher Jeffrey <chjj at purse.io> wrote:
> >
> > Johnson,
> >
> > Yeah, I do still see the issue. I think there are still some reasonable
> > ways to mitigate it.
> >
> > I've started revising the extension block specification/code to coexist
> > with mainchain segwit. I think the benefit of this is that we can
> > require exiting outputs to only be witness programs. Presumably segwit
> > wallets will be more likely to be aware of a new output maturity rule
> > (I've opened a PR[1] which describes this in greater detail). I think
> > this probably reduces the likelihood of the legacy wallet issue,
> > assuming most segwit-supporting wallets would implement this rule before
> > the activation of segwit.
> >
> > What's your opinion on whether this would have a great enough effect to
> > prevent the legacy wallet issue? I think switching to witness programs
> > only may be a good balance between fungibility and backward-compat,
> > probably better all around than creating a whole new
> > addr-type/wit-program just for exits.
> >
> > [1] https://github.com/tothemoon-org/extension-blocks/pull/16 <https://github.com/tothemoon-org/extension-blocks/pull/16>
> >
>

--
Christopher Jeffrey (JJ) <chjjeffrey at gmail.com>
CTO & Bitcoin Menace, purse.io
https://github.com/chjj
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170509/2360432a/attachment.sig>

From roconnor at blockstream.io  Wed May 10 01:59:06 2017
From: roconnor at blockstream.io (Russell O'Connor)
Date: Tue, 9 May 2017 21:59:06 -0400
Subject: [bitcoin-dev] Per-block non-interactive Schnorr signature
	aggregation
In-Reply-To: <CAKEeUhh3Rj3Dh8ab5FFR6dGKc2Ojm5Z0uyWtAtrPrh=7dvj-GA@mail.gmail.com>
References: <CAKEeUhh3Rj3Dh8ab5FFR6dGKc2Ojm5Z0uyWtAtrPrh=7dvj-GA@mail.gmail.com>
Message-ID: <CAMZUoK=iXXYkN64+T-haK=vXrd=L7eqbo3P-MOhrj6p35uaW0A@mail.gmail.com>

I'm a bit amateur at this sort of thing, but let me try to argue that this
proposal is in fact horribly broken ;)

Suppose Alice has some UTXO with some money Bob wants to steal.  Grant me
that the public key P0 protecting Alice's UTXO is public (say because the
public key has been reused elsewhere).

Bob going to spend Alice's UTXO by generating random values s0, k0 and R0
:= k0*G and thus creating a random signature for it, [R0, s0].  Now clearly
this signature isn't going to be valid by itself because it is just random.
Bob's goal will be to make a transaction with other inputs such that, while
the individual signatures are not valid, the aggregated signature will be
valid.

To do this Bob generates a set of random public keys P1 ... P_n of the form
P_i := P0 + r_i*G, and a bunch of random k1 ... k_n with R1 := k1*G ... R_n
:= k_n*G, such that

    h(m1, R1, P1) + ... + h(m_n, R_n, P_n) = -h(m0, R0 P0) (modulo the
order of the elliptic curve)

I understand that this can be done efficiently with Wagner's Generalized
Birthday attack.

The RHS aggregated signature equation on the private side is

    k0 + k1 + ... k_n - h(m0, R0, P0)x0 - h(m1, R1, P1)(x0 + r1) - ... -
h(m_n, R_n, P_n)(x0 + r_n)

with x0 unknown to Bob.  Rearranging the terms we get

    k0 + k1 + ... k_n - [h(m0, R0, P0) + h(m1, R1, P1) + ... + h(m_n, R_n,
P_n)]*x0 - [h(m1, R1, P1)*r1 + ... + h(m_n, R_n, P_n)*r_n]

However [h(m0, R0, P0) + h(m1, R1, P1) + ... + h(m_n, R_n, P_n)] is 0 so
cancelling that we are left with

    k0 + k1 + ... k_n - [h(m1, R1, P1)*r1 + ... + h(m_n, R_n, P_n)*r_n]

which no longer depends on the unknown value x0, so that is good.  Bob
knows what this value is.

Bob creates a set UTXOs by spending to the set of public keys P1 .. P_n.
Bob don't know what the private keys are for these public keys, but that is
going to be okay.

Bob creates a final transaction that takes as input the UTXO of Alice's
funds he wants to steal, with public key P0, and also his newly created
UTXOs with public keys P1 ... P_n.
For the signature on Alice's input he uses [R0,s0].  For the rest of the
signature he picks s1 ... s_n such that

    s0 + s1 + ... + sn = k0 + k1 + ... k_n - [h(m1, R1, P1)*r1 + ... +
h(m_n, R_n, P_n)*r_n] (which is equal to k0 + k1 + ... k_n - h(m0, R0,
P0)x0 - h(m1, R1, P1)(x0 + r1) - ... - h(m_n, R_n, P_n)(x0 + r_n)).

and uses signatures [R1, s1] ... [R_n, s_n] on his other inputs.

Thus, while none of the individual signatures are valid, the aggregated
signature does validate.

One wrinkles in this argument is that Bob needs to pick m1 ... m_n before
he knows what the transaction will be.  I think this can be mitigated by
using some combination of SIGHASH_ANYONECANPAY, but I'm not sure if that
works.  Even if my argument doesn't actually work, I think it is close
enough to be pretty scary.

Thanks goes to Pieter Wuille for helping explain things to me; however any
errors above are my own.

On Sun, May 7, 2017 at 2:45 AM, adiabat via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> If / when Schnorr signatures are deployed in a future witness version, it
> may be possible to have non-interactive partial aggregation of the
> signatures on a per-block basis.  This could save quite a bit of space.  It
> *seems* not to have any security problems but this mailing list is very
> good at finding vulnerabilities so that type of feedback is the main reason
> I'm writing :) (A quick explanation of why this is horribly broken could
> save me lots of time!)
> (also sorry if this has been discussed; didn't see anything)
>
> Quick recap / context of Schnorr sigs:
>
> There are a bunch of private keys x1, x2, x3...
> multiply by generator G to get x1G = P1, x2G = P2, x3G = P3
>
> Everyone makes their sighash m1, m2, m3, and their random nonces k1, k2,
> k3.
>
> To sign, people calculate s values:
>
> s1 = k1 - h(m1, R1, P1)x1
> s2 = k2 - h(m2, R2, P2)x2
>
> (adding the P2 into the e hash value is not in most literature /
> explanations but helps with some attacks; I beleive that's the current
> thinking.  Anyway it doesn't matter for this idea)
>
> Signature 1 is [R1, s1].  Verifiers check, given P1, m1, R1, s1:
>
> s1G =? R1 - h(m1, R1, P1)P1
>
> You can *interactively* make aggregate signatures, which requires
> co-signers to build an aggregate R value by coming up with their own k
> values, sharing their R with the co-signers, adding up the R's to get a
> summed R, and using that to sign.
>
> Non-interactively though, it seems like you can aggregate half the
> signature.  The R values are unique to the [m, P] pair, but the s's can be
> summed up:
>
> s1 + s2 = k1 + k2 - h(m1, R1, P1)x1 - h(m2, R2, P2)x2
>
> (s1 + s2)G = R1 + R2 - h(m1, R1, P1)P1 - h(m2, R2, P2)P2
>
> To use this property in Bitcoin, when making transactions, wallets can
> sign in the normal way, and the signature, consisting of [R, s] goes into
> the witness stack.  When miners generate a block, they remove the s-value
> from all compatible inputs, and commit to the aggregate s-value in the
> coinbase transaction (either in a new OP_RETURN or alongside the existing
> witness commitment structure).
>
> The obvious advatage is that signatures go down to 32 bytes each, so you
> can fit more of them in a block, and they take up less disk and network
> space.  (In IBD; if a node maintains a mempool they'll need to receive all
> the separate s-values)
>
> Another advatage is that block verification is sped up.  For individual
> signatures, the computation involves:
>
> e = h(m1, R1, P1)           <- hash function, super fast
> e*P                         <- point multiplication, slowest
> R - e*P                     <- point addidion, pretty fast
> s*G                         <- base point multiplication, pretty slow
>
> with s-aggregate verification, the first three steps are still carried out
> on each signature, but the s*G operation only needs to be done once.
> Instead another point addition per signature is needed, where you have some
> accumulator and add in the left side:
> A += R - e*P
> this can be parallelized pretty well as it's commutative.
>
> The main downside I can see (assuming this actually works) is that it's
> hard to cache signatures and quickly validate a block after it has come
> in.  It might not be as bad as it first seems, as validation given chached
> signatures looks possible without any elliptic curve operations.  Keep an
> aggregate s-value (which is a scalar) for all the txs in your mempool.
> When a block comes in, subtract all the s-values for txs not included in
> the block.  If the block includes txs you weren't aware of, request them in
> the same way compact blocks works, and get the full signature for those
> txs.  It could be several thousand operations, but those are all bigInt
> modular additions / subtractions which I believe are pretty quick in
> comparison with point additions / multiplications.
>
> There may be other complications due to the fact that the witness-txids
> change when building a block.  TXIDs don't change though so should be
> possible to keep track of things OK.
>
> Also you can't "fail fast" for the signature verification; you have to add
> everything up before you can tell if it's correct.  Probably not a big deal
> as PoW check comes first, and invalid blocks are pretty uncommon and quite
> costly.
>
> Would be interested to hear if this idea looks promising.
> Andrew Polestra mentioned something like this in the context of CT /
> mimblewimble transactions a while ago, but it seems it may be applicable to
> regular bitcoin Schnorr txs.
>
> -Tadge
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170509/75fc05c4/attachment.html>

From jtimon at jtimon.cc  Wed May 10 05:37:33 2017
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Wed, 10 May 2017 07:37:33 +0200
Subject: [bitcoin-dev] Some real-world results about the current Segwit
	Discount
In-Reply-To: <CAKzdR-qsj9Ag8o1UqcgZpKTVRwXm2+qJuHfxHu6keLgkWeEnAw@mail.gmail.com>
References: <CAKzdR-qojNn8OtUTPbxa0JauK9nmo2ZGm4ihKuyzsz_FAgokDw@mail.gmail.com>
	<CAMBsKS_j7Lso6fHoMPkrQ7UFwKfxOERAAqL=aUF83O4CqL+iFg@mail.gmail.com>
	<CAKzdR-on-w9EF+2hLjchdyHB1gj7fi4QnybA=J4Cz7yyN3KKNA@mail.gmail.com>
	<e86d9b29-f7dd-75da-e6c6-f55648bea104@mattcorallo.com>
	<CAKzdR-pyE2f0jdsU+QGbJQ9gMepsyS880kntE9MRvDBLG_Nchg@mail.gmail.com>
	<CAKzdR-pN0B-wjhPh3n6Jw7L6wsz9yQ=kyVX7NYx5ACZC3bg8OA@mail.gmail.com>
	<CAAS2fgQsT7c+CEfC+U9N+g-+V4s8WnQjRqDddfCKMb6+BkJ3-A@mail.gmail.com>
	<f4605b47-03be-7493-fa3a-19ad4def3fa8@mattcorallo.com>
	<CAAS2fgQv84WgScOkAt_FttgQHjGbRMBmjXA8_EcmyL_K=WCCWA@mail.gmail.com>
	<CAKzdR-qsj9Ag8o1UqcgZpKTVRwXm2+qJuHfxHu6keLgkWeEnAw@mail.gmail.com>
Message-ID: <CABm2gDoSKtgja5-=rARiZXos05JxJv8heUQ_3NNmeftJqE+1Zw@mail.gmail.com>

If there's a better factor than 0.25 I would change it now before deploying
segwit instead of leaving it to be changed later with a hf.

On 9 May 2017 10:59 pm, "Sergio Demian Lerner via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I agree with you Matt.
> I'm artificially limiting myself to changing the parameters of Segwit as
> it is..
>
> This is motivated by the idea that a consensual HF in the current state
> would have greater chance of acceptance if it changes the minimum number of
> lines of code.
>
>
>
> On Tue, May 9, 2017 at 5:13 PM, Gregory Maxwell <greg at xiph.org> wrote:
>
>> On Tue, May 9, 2017 at 7:42 PM, Matt Corallo <lf-lists at mattcorallo.com>
>> wrote:
>> > at beast.
>>
>> Rawr.
>>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170510/2a5e2c51/attachment-0001.html>

From apoelstra at wpsoftware.net  Wed May 10 07:55:42 2017
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Wed, 10 May 2017 07:55:42 +0000
Subject: [bitcoin-dev] Per-block non-interactive Schnorr signature
 aggregation
In-Reply-To: <CAMZUoK=iXXYkN64+T-haK=vXrd=L7eqbo3P-MOhrj6p35uaW0A@mail.gmail.com>
References: <CAKEeUhh3Rj3Dh8ab5FFR6dGKc2Ojm5Z0uyWtAtrPrh=7dvj-GA@mail.gmail.com>
	<CAMZUoK=iXXYkN64+T-haK=vXrd=L7eqbo3P-MOhrj6p35uaW0A@mail.gmail.com>
Message-ID: <20170510075542.GZ10783@boulet.lan>

On Tue, May 09, 2017 at 09:59:06PM -0400, Russell O'Connor via bitcoin-dev wrote:
> I'm a bit amateur at this sort of thing, but let me try to argue that this
> proposal is in fact horribly broken ;)
> 
> Suppose Alice has some UTXO with some money Bob wants to steal.  Grant me
> that the public key P0 protecting Alice's UTXO is public (say because the
> public key has been reused elsewhere).
> 
> Bob going to spend Alice's UTXO by generating random values s0, k0 and R0
> := k0*G and thus creating a random signature for it, [R0, s0].  Now clearly
> this signature isn't going to be valid by itself because it is just random.
> Bob's goal will be to make a transaction with other inputs such that, while
> the individual signatures are not valid, the aggregated signature will be
> valid.
>

If you seed the randomization with every R value (which would come for free
if you used, say, the witness root) then Wagner's attack no longer applies.

The idea is that no aggregation occurs until a miner produces a block. You
have a bunch of independent Schnorr sigs (s_i, R_i). Then the _miner_ multiples
each s_i by H(witness root || index) or whatever, sums up the s_i's, and commits
the sum somewhere where it doesn't affect the root.

Verifiers then multiply each R_i by the same multiplying factors and are able
to do a batch verification of them.


Verifiers who have seen a signature before and cached it as valid can save
themselves a bit of time by subtracting H(witness root || index)*s_i from
the summed s-value and then skipping R_i in the above step. These are scalar
operations and are extremely cheap.

They can recognize the signature given only the transaction it signs and R_i,
which uniquely determine a valid signature.


I believe this is what Tadge was referring to when he mentioned a talk of mine.
It's roughly what I've had in mind whenever I talk about non-interactive Schnorr
aggregation.



Cheers
Andrew


-- 
Andrew Poelstra
Mathematics Department, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

"A goose alone, I suppose, can know the loneliness of geese
 who can never find their peace,
 whether north or south or west or east"
       --Joanna Newsom

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170510/ab8b75e7/attachment.sig>

From lf-lists at mattcorallo.com  Wed May 10 14:05:30 2017
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Wed, 10 May 2017 14:05:30 +0000
Subject: [bitcoin-dev] Some real-world results about the current Segwit
 Discount
In-Reply-To: <CAKzdR-qsj9Ag8o1UqcgZpKTVRwXm2+qJuHfxHu6keLgkWeEnAw@mail.gmail.com>
References: <CAKzdR-qojNn8OtUTPbxa0JauK9nmo2ZGm4ihKuyzsz_FAgokDw@mail.gmail.com>
	<CAMBsKS_j7Lso6fHoMPkrQ7UFwKfxOERAAqL=aUF83O4CqL+iFg@mail.gmail.com>
	<CAKzdR-on-w9EF+2hLjchdyHB1gj7fi4QnybA=J4Cz7yyN3KKNA@mail.gmail.com>
	<e86d9b29-f7dd-75da-e6c6-f55648bea104@mattcorallo.com>
	<CAKzdR-pyE2f0jdsU+QGbJQ9gMepsyS880kntE9MRvDBLG_Nchg@mail.gmail.com>
	<CAKzdR-pN0B-wjhPh3n6Jw7L6wsz9yQ=kyVX7NYx5ACZC3bg8OA@mail.gmail.com>
	<CAAS2fgQsT7c+CEfC+U9N+g-+V4s8WnQjRqDddfCKMb6+BkJ3-A@mail.gmail.com>
	<f4605b47-03be-7493-fa3a-19ad4def3fa8@mattcorallo.com>
	<CAAS2fgQv84WgScOkAt_FttgQHjGbRMBmjXA8_EcmyL_K=WCCWA@mail.gmail.com>
	<CAKzdR-qsj9Ag8o1UqcgZpKTVRwXm2+qJuHfxHu6keLgkWeEnAw@mail.gmail.com>
Message-ID: <b24b84bf-315c-1463-acee-4b6edab41d52@mattcorallo.com>

I'm highly unconvinced of this point. Sure, you can change fewer lines
of code, but if the result is, lets be honest, shit, how do you believe
its going to have a higher chance of getting acceptance from the broader
community? I think you're over-optimizing in the wrong direction.

Matt

On 05/09/17 20:58, Sergio Demian Lerner wrote:
> I agree with you Matt. 
> I'm artificially limiting myself to changing the parameters of Segwit as
> it is.. 
> 
> This is motivated by the idea that a consensual HF in the current state
> would have greater chance of acceptance if it changes the minimum number
> of lines of code.
> 
> 
> 
> On Tue, May 9, 2017 at 5:13 PM, Gregory Maxwell <greg at xiph.org
> <mailto:greg at xiph.org>> wrote:
> 
>     On Tue, May 9, 2017 at 7:42 PM, Matt Corallo
>     <lf-lists at mattcorallo.com <mailto:lf-lists at mattcorallo.com>> wrote:
>     > at beast.
> 
>     Rawr.
> 
> 

From rx at awsomnet.org  Wed May 10 14:59:08 2017
From: rx at awsomnet.org (adiabat)
Date: Wed, 10 May 2017 10:59:08 -0400
Subject: [bitcoin-dev] Per-block non-interactive Schnorr signature
	aggregation
In-Reply-To: <20170510075542.GZ10783@boulet.lan>
References: <CAKEeUhh3Rj3Dh8ab5FFR6dGKc2Ojm5Z0uyWtAtrPrh=7dvj-GA@mail.gmail.com>
	<CAMZUoK=iXXYkN64+T-haK=vXrd=L7eqbo3P-MOhrj6p35uaW0A@mail.gmail.com>
	<20170510075542.GZ10783@boulet.lan>
Message-ID: <CAKEeUhhPpCVG5Y7Upp5SXm1g3aXgm4ggNNT6C=_Pcj46vKVc7w@mail.gmail.com>

I messed up and only replied to Russel O'Connor; my response is copied below.
And then there's a bit more.

-----
Aha, Wagner's generalized birthday attack, the bane of all clever tricks!
I didn't realize it applied in this case but looks like it in fact does.
 applies to this case.  It would have to be a miner performing the
attack as the s-value would only be aggregated in the coinbase tx, but
that's hardly an impediment.

In fact, sketching it out, it doesn't look like the need to know m1,
m2... m_n is a big problem.  Even if the m's are fixed after being
chosen based on the P1... Pn's, (in bitcoin, m always commits to P so
not sure why it's needed in the hash) there is still freedom to
collide the hashes.  The R values can be anything, so getting h(m1,
R1, P1) + h(m2, R2, P2)... to equal -h(m0, R0, P0) is doable with
Wagner's attack by varying R1, R2... to get different hashes.

I *think* there is a viable defense against this attack, but it does
make the whole aggregation setup less attractive.  The miner who
calculates s-aggregate could also aggregate all the public keys from
all the aggregated signatures in the block (P0, P1...), sort them and
hash the concatenated list of pubkeys.  They could then multiply s by
this combo-pubkey hash (call it h(c)).  Then when nodes verify the
aggregate signature, they need to go through all the pubkeys in the
block, create the same combo-pubkey hash, and multiply s by the
multiplicative inverse of the h(c) they calculate, then verify s.  I
believe this breaks the Wagner generalized birthday attack because
every h(m_i, R_i, P_i)*h(c) included or omitted affects the c part of
h(m0, R0, P0)*h(c).

I'm not sure how badly this impacts the verification speed.  It might
not be too bad for verification as it's amortized over the whole
block.  For the miner doing the aggregation it's a bit slower as they
need to re-sort and hash all the pubkeys every time a new signature is
added.  Might not be too slow.

I'm not super confident that this actually prevents the generalized
birthday attack though.  I missed that attack in the previous post so
I'm 0 for 1 against Wagner so far :)

-----

Andrew: Right, commiting to all the R values would also work; is there
an advantage to using the R's instead of the P's?  At first glance it
seems about the same.

Another possible optimization: instead of sorting, concatenate all the
R's or P's in the order they appear in the block.  Then have the miner
commit to s*h(c)^1, the multiplicative inverse of the hash of all
those values.  Then when nodes are verifying in IBD, they can just
multiply by h(c) and they don't have to compute the inverse.  A bit
more work for the miner and a bit less for the nodes.

-Tadge

From sergio.d.lerner at gmail.com  Wed May 10 15:25:27 2017
From: sergio.d.lerner at gmail.com (Sergio Demian Lerner)
Date: Wed, 10 May 2017 12:25:27 -0300
Subject: [bitcoin-dev] Some real-world results about the current Segwit
	Discount
In-Reply-To: <b24b84bf-315c-1463-acee-4b6edab41d52@mattcorallo.com>
References: <CAKzdR-qojNn8OtUTPbxa0JauK9nmo2ZGm4ihKuyzsz_FAgokDw@mail.gmail.com>
	<CAMBsKS_j7Lso6fHoMPkrQ7UFwKfxOERAAqL=aUF83O4CqL+iFg@mail.gmail.com>
	<CAKzdR-on-w9EF+2hLjchdyHB1gj7fi4QnybA=J4Cz7yyN3KKNA@mail.gmail.com>
	<e86d9b29-f7dd-75da-e6c6-f55648bea104@mattcorallo.com>
	<CAKzdR-pyE2f0jdsU+QGbJQ9gMepsyS880kntE9MRvDBLG_Nchg@mail.gmail.com>
	<CAKzdR-pN0B-wjhPh3n6Jw7L6wsz9yQ=kyVX7NYx5ACZC3bg8OA@mail.gmail.com>
	<CAAS2fgQsT7c+CEfC+U9N+g-+V4s8WnQjRqDddfCKMb6+BkJ3-A@mail.gmail.com>
	<f4605b47-03be-7493-fa3a-19ad4def3fa8@mattcorallo.com>
	<CAAS2fgQv84WgScOkAt_FttgQHjGbRMBmjXA8_EcmyL_K=WCCWA@mail.gmail.com>
	<CAKzdR-qsj9Ag8o1UqcgZpKTVRwXm2+qJuHfxHu6keLgkWeEnAw@mail.gmail.com>
	<b24b84bf-315c-1463-acee-4b6edab41d52@mattcorallo.com>
Message-ID: <CAKzdR-r=y=myz60v9FnYr3tJbW9LgNQkAoA9+F-+jaLScg2PJw@mail.gmail.com>

Jaja. But no shit. Not perfect maybe, but Bitcoin was never perfect. It has
always been good enough. And at the beginning it was quite simple. Simple
enough it allowed gradual improvements that anyone with some technical
background could understand. Now we need a full website to explain an
improvement.
But this is becoming more and more out of topic.


On Wed, May 10, 2017 at 11:05 AM, Matt Corallo <lf-lists at mattcorallo.com>
wrote:

> I'm highly unconvinced of this point. Sure, you can change fewer lines
> of code, but if the result is, lets be honest, shit, how do you believe
> its going to have a higher chance of getting acceptance from the broader
> community? I think you're over-optimizing in the wrong direction.
>
> Matt
>
> On 05/09/17 20:58, Sergio Demian Lerner wrote:
> > I agree with you Matt.
> > I'm artificially limiting myself to changing the parameters of Segwit as
> > it is..
> >
> > This is motivated by the idea that a consensual HF in the current state
> > would have greater chance of acceptance if it changes the minimum number
> > of lines of code.
> >
> >
> >
> > On Tue, May 9, 2017 at 5:13 PM, Gregory Maxwell <greg at xiph.org
> > <mailto:greg at xiph.org>> wrote:
> >
> >     On Tue, May 9, 2017 at 7:42 PM, Matt Corallo
> >     <lf-lists at mattcorallo.com <mailto:lf-lists at mattcorallo.com>> wrote:
> >     > at beast.
> >
> >     Rawr.
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170510/6ecb8e46/attachment.html>

From lf-lists at mattcorallo.com  Wed May 10 16:39:00 2017
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Wed, 10 May 2017 16:39:00 +0000
Subject: [bitcoin-dev] Some real-world results about the current Segwit
	Discount
In-Reply-To: <CAKzdR-r=y=myz60v9FnYr3tJbW9LgNQkAoA9+F-+jaLScg2PJw@mail.gmail.com>
References: <CAKzdR-qojNn8OtUTPbxa0JauK9nmo2ZGm4ihKuyzsz_FAgokDw@mail.gmail.com>
	<CAMBsKS_j7Lso6fHoMPkrQ7UFwKfxOERAAqL=aUF83O4CqL+iFg@mail.gmail.com>
	<CAKzdR-on-w9EF+2hLjchdyHB1gj7fi4QnybA=J4Cz7yyN3KKNA@mail.gmail.com>
	<e86d9b29-f7dd-75da-e6c6-f55648bea104@mattcorallo.com>
	<CAKzdR-pyE2f0jdsU+QGbJQ9gMepsyS880kntE9MRvDBLG_Nchg@mail.gmail.com>
	<CAKzdR-pN0B-wjhPh3n6Jw7L6wsz9yQ=kyVX7NYx5ACZC3bg8OA@mail.gmail.com>
	<CAAS2fgQsT7c+CEfC+U9N+g-+V4s8WnQjRqDddfCKMb6+BkJ3-A@mail.gmail.com>
	<f4605b47-03be-7493-fa3a-19ad4def3fa8@mattcorallo.com>
	<CAAS2fgQv84WgScOkAt_FttgQHjGbRMBmjXA8_EcmyL_K=WCCWA@mail.gmail.com>
	<CAKzdR-qsj9Ag8o1UqcgZpKTVRwXm2+qJuHfxHu6keLgkWeEnAw@mail.gmail.com>
	<b24b84bf-315c-1463-acee-4b6edab41d52@mattcorallo.com>
	<CAKzdR-r=y=myz60v9FnYr3tJbW9LgNQkAoA9+F-+jaLScg2PJw@mail.gmail.com>
Message-ID: <B067643A-FBFD-4F59-B7AE-77769B9A9ACE@mattcorallo.com>

I highly disagree about the "not shit" part.  You're advocating for throwing away one of the key features of Segwit, something that is very important for Bitcoin's long-term reliability! If you think doing so is going to somehow help get support in a divided community, I don't understand how - more likely you're only going to make things significantly worse.

On May 10, 2017 11:25:27 AM EDT, Sergio Demian Lerner <sergio.d.lerner at gmail.com> wrote:
>Jaja. But no shit. Not perfect maybe, but Bitcoin was never perfect. It
>has
>always been good enough. And at the beginning it was quite simple.
>Simple
>enough it allowed gradual improvements that anyone with some technical
>background could understand. Now we need a full website to explain an
>improvement.
>But this is becoming more and more out of topic.
>
>
>On Wed, May 10, 2017 at 11:05 AM, Matt Corallo
><lf-lists at mattcorallo.com>
>wrote:
>
>> I'm highly unconvinced of this point. Sure, you can change fewer
>lines
>> of code, but if the result is, lets be honest, shit, how do you
>believe
>> its going to have a higher chance of getting acceptance from the
>broader
>> community? I think you're over-optimizing in the wrong direction.
>>
>> Matt
>>
>> On 05/09/17 20:58, Sergio Demian Lerner wrote:
>> > I agree with you Matt.
>> > I'm artificially limiting myself to changing the parameters of
>Segwit as
>> > it is..
>> >
>> > This is motivated by the idea that a consensual HF in the current
>state
>> > would have greater chance of acceptance if it changes the minimum
>number
>> > of lines of code.
>> >
>> >
>> >
>> > On Tue, May 9, 2017 at 5:13 PM, Gregory Maxwell <greg at xiph.org
>> > <mailto:greg at xiph.org>> wrote:
>> >
>> >     On Tue, May 9, 2017 at 7:42 PM, Matt Corallo
>> >     <lf-lists at mattcorallo.com <mailto:lf-lists at mattcorallo.com>>
>wrote:
>> >     > at beast.
>> >
>> >     Rawr.
>> >
>> >
>>

From sergio.d.lerner at gmail.com  Wed May 10 19:40:12 2017
From: sergio.d.lerner at gmail.com (Sergio Demian Lerner)
Date: Wed, 10 May 2017 16:40:12 -0300
Subject: [bitcoin-dev] Some real-world results about the current Segwit
	Discount
In-Reply-To: <B067643A-FBFD-4F59-B7AE-77769B9A9ACE@mattcorallo.com>
References: <CAKzdR-qojNn8OtUTPbxa0JauK9nmo2ZGm4ihKuyzsz_FAgokDw@mail.gmail.com>
	<CAMBsKS_j7Lso6fHoMPkrQ7UFwKfxOERAAqL=aUF83O4CqL+iFg@mail.gmail.com>
	<CAKzdR-on-w9EF+2hLjchdyHB1gj7fi4QnybA=J4Cz7yyN3KKNA@mail.gmail.com>
	<e86d9b29-f7dd-75da-e6c6-f55648bea104@mattcorallo.com>
	<CAKzdR-pyE2f0jdsU+QGbJQ9gMepsyS880kntE9MRvDBLG_Nchg@mail.gmail.com>
	<CAKzdR-pN0B-wjhPh3n6Jw7L6wsz9yQ=kyVX7NYx5ACZC3bg8OA@mail.gmail.com>
	<CAAS2fgQsT7c+CEfC+U9N+g-+V4s8WnQjRqDddfCKMb6+BkJ3-A@mail.gmail.com>
	<f4605b47-03be-7493-fa3a-19ad4def3fa8@mattcorallo.com>
	<CAAS2fgQv84WgScOkAt_FttgQHjGbRMBmjXA8_EcmyL_K=WCCWA@mail.gmail.com>
	<CAKzdR-qsj9Ag8o1UqcgZpKTVRwXm2+qJuHfxHu6keLgkWeEnAw@mail.gmail.com>
	<b24b84bf-315c-1463-acee-4b6edab41d52@mattcorallo.com>
	<CAKzdR-r=y=myz60v9FnYr3tJbW9LgNQkAoA9+F-+jaLScg2PJw@mail.gmail.com>
	<B067643A-FBFD-4F59-B7AE-77769B9A9ACE@mattcorallo.com>
Message-ID: <CAKzdR-p-8=OA6_-vSyrNr3Ofqq5yL20WQCVkzMnrhwVM_AWEaw@mail.gmail.com>

I'm not advocating. I'm mediating.


This is out of

On Wed, May 10, 2017 at 1:39 PM, Matt Corallo <lf-lists at mattcorallo.com>
wrote:

> I highly disagree about the "not shit" part.  You're advocating for
> throwing away one of the key features of Segwit, something that is very
> important for Bitcoin's long-term reliability! If you think doing so is
> going to somehow help get support in a divided community, I don't
> understand how - more likely you're only going to make things significantly
> worse.
>
> On May 10, 2017 11:25:27 AM EDT, Sergio Demian Lerner <
> sergio.d.lerner at gmail.com> wrote:
> >Jaja. But no shit. Not perfect maybe, but Bitcoin was never perfect. It
> >has
> >always been good enough. And at the beginning it was quite simple.
> >Simple
> >enough it allowed gradual improvements that anyone with some technical
> >background could understand. Now we need a full website to explain an
> >improvement.
> >But this is becoming more and more out of topic.
> >
> >
> >On Wed, May 10, 2017 at 11:05 AM, Matt Corallo
> ><lf-lists at mattcorallo.com>
> >wrote:
> >
> >> I'm highly unconvinced of this point. Sure, you can change fewer
> >lines
> >> of code, but if the result is, lets be honest, shit, how do you
> >believe
> >> its going to have a higher chance of getting acceptance from the
> >broader
> >> community? I think you're over-optimizing in the wrong direction.
> >>
> >> Matt
> >>
> >> On 05/09/17 20:58, Sergio Demian Lerner wrote:
> >> > I agree with you Matt.
> >> > I'm artificially limiting myself to changing the parameters of
> >Segwit as
> >> > it is..
> >> >
> >> > This is motivated by the idea that a consensual HF in the current
> >state
> >> > would have greater chance of acceptance if it changes the minimum
> >number
> >> > of lines of code.
> >> >
> >> >
> >> >
> >> > On Tue, May 9, 2017 at 5:13 PM, Gregory Maxwell <greg at xiph.org
> >> > <mailto:greg at xiph.org>> wrote:
> >> >
> >> >     On Tue, May 9, 2017 at 7:42 PM, Matt Corallo
> >> >     <lf-lists at mattcorallo.com <mailto:lf-lists at mattcorallo.com>>
> >wrote:
> >> >     > at beast.
> >> >
> >> >     Rawr.
> >> >
> >> >
> >>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170510/cb1623ce/attachment-0001.html>

From dev at jonasschnelli.ch  Thu May 11 15:13:12 2017
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Thu, 11 May 2017 17:13:12 +0200
Subject: [bitcoin-dev] BIP proposal: NODE_NETWORK_LIMITED service bits
Message-ID: <E1313B4E-6061-49CA-9E8C-E5FD468531C0@jonasschnelli.ch>

Hi

Currently, pruned peers have no way how to signal their (valuable) service.
A BIP proposal to improve this (draft):
https://github.com/jonasschnelli/bips/wiki/NODE_NETWORK_LIMITED-BIP-DRAFT <https://github.com/jonasschnelli/bips/wiki/NODE_NETWORK_LIMITED-BIP-DRAFT>

Feedback is highly welcome.

</jonas>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170511/f520ab16/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170511/f520ab16/attachment.sig>

From greg at xiph.org  Thu May 11 18:17:19 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Thu, 11 May 2017 18:17:19 +0000
Subject: [bitcoin-dev] BIP proposal: NODE_NETWORK_LIMITED service bits
In-Reply-To: <E1313B4E-6061-49CA-9E8C-E5FD468531C0@jonasschnelli.ch>
References: <E1313B4E-6061-49CA-9E8C-E5FD468531C0@jonasschnelli.ch>
Message-ID: <CAAS2fgS01Saxb8AtZhSxVGH5XFmXDzaaB0gd+4Zhr3-ahUJbfQ@mail.gmail.com>

It probably should be stated in terms of what you're promising to do--
 288 and 1152 blocks, not what we hope it will accomplish. Then advise
clients to use peers with headroom because their estimates could be
wrong and reorgs.

Reorgs aren't the only concerns that drive larger numbers:  The peak
at syncing is at ~24 hours, but sometimes there are quite a few more
than 144 blocks in 24 hours. Also, new blocks show up in the chain:
you think you're 144 behind but by the time you connect you find
you're 146 behind from that peer's perspective.

I think it's a bit ambiguous what it's saying about the headers,
especially because it goes into detail about address relay. I believe
nodes with any of these settings should be willing to serve headers
for their entire best chain.  Perhaps you could say that this is
equivalent to NODE_NETWORK except that they aren't necessarily willing
to server historical blocks.

I'm unsure about the third depth level. Perhaps that should be left
undefined for sending right now and treated as least 1152 blocks by
receivers-- I don't have any reason to think 7056 is a particularly
useful choice, and we'll need another (longer) level for UTXO based
sync.   You could probably go further and say that nodes shouldn't
send it now, but if sent it means they intend to keep 2016*2 blocks.
(Not sending because the requirement for sending it may be that the
node is able to send you a UTXO data feed.)

> consider to switch a low percentage

That isn't grammatical, you want "switching".  But I think it would be
better to say that when a node believe it is in sync enough to use
NODE_NETWORK_LIMITED_X it should just treat them identically to
NODE_NETWORK in peer selection.   We don't really need any more
topology distortion than that.   In particular, I don't want to be in
a case where NODE_NETWORK peers suddenly find themselves far less well
connected.

In terms of making room, a node network peer could choose to
disconnect the least useful peers that aren't syncing from them to
make more room for ones that are.  This lets them decide what
connections they want, based on how full they are and what is useful
to them, rather than finding themselves all lonely because nodes
decided to avoid them to be "helpful", and we already use
disconnections to manage fullness.

On Thu, May 11, 2017 at 3:13 PM, Jonas Schnelli via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Hi
>
> Currently, pruned peers have no way how to signal their (valuable) service.
> A BIP proposal to improve this (draft):
> https://github.com/jonasschnelli/bips/wiki/NODE_NETWORK_LIMITED-BIP-DRAFT
>
> Feedback is highly welcome.
>
> </jonas>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From luke at dashjr.org  Thu May 11 19:24:21 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Thu, 11 May 2017 19:24:21 +0000
Subject: [bitcoin-dev] BIP proposal: NODE_NETWORK_LIMITED service bits
In-Reply-To: <E1313B4E-6061-49CA-9E8C-E5FD468531C0@jonasschnelli.ch>
References: <E1313B4E-6061-49CA-9E8C-E5FD468531C0@jonasschnelli.ch>
Message-ID: <201705111924.22055.luke@dashjr.org>

> A peer signaling NODE_NETWORK_LIMITED_LOW & NODE_NETWORK_LIMITED_HIGH MUST
> be capable of serving at least the last 7'056 blocks (~49 days)
> (NODE_NETWORK_LIMITED_HIGH's value ^2).

Is 49 days particularly useful? Would it be a problem to instead leave both-
bits undefined? I'm thinking this might be better as a way to indicate "7 
days, plus a deterministically chosen set of historical blocks"...

> Current Bitcoin-Core pruned full nodes guarantees a minimum of 288 blocks,
> thus allowing to signal NODE_NETWORK_LIMITED_LOW with the current minimum
> configuration.

This is technically true right now, but as soon as segwit activates, it will 
no longer be... Therefore, I suggest striking it from the BIP, expounding on 
it in greater detail, or making it true for the longer term.

> Peers following this BIP SHOULD connect a limited amount of their available
> outbound connections to peers signaling one or both of the
> NODE_NETWORK_LIMITED_* service bits if they expect to request less blocks
> than the signaled number.

This isn't entirely clear whether it refers to peers downloading blocks, or 
peers serving them. (I assume the former, but it should be clarified.)

> Light clients (and such) who are not checking the nServiceFlags (service
> bits) from a relayed addr-message may unwillingly connect to a pruned peer
> and ask for (filtered) blocks at a depth below their pruned depth.

Wouldn't this already be a problem, without the BIP?

Luke

From dev at jonasschnelli.ch  Thu May 11 20:10:08 2017
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Thu, 11 May 2017 22:10:08 +0200
Subject: [bitcoin-dev] BIP proposal: NODE_NETWORK_LIMITED service bits
In-Reply-To: <201705111924.22055.luke@dashjr.org>
References: <E1313B4E-6061-49CA-9E8C-E5FD468531C0@jonasschnelli.ch>
	<201705111924.22055.luke@dashjr.org>
Message-ID: <61C68F26-AD36-4AB4-A065-020BD549CEBC@jonasschnelli.ch>


> Is 49 days particularly useful? Would it be a problem to instead leave both-
> bits undefined? I'm thinking this might be better as a way to indicate "7
> days, plus a deterministically chosen set of historical blocks"?

I though two service bits allow three states and we should define all three combinations.
But I guess an adequate ?definition? would be to reserve it for future ?definitions?.
Or use Gregory's proposal of min 2016*2 blocks & keep it ?undefined? for now.

49 days was chosen to allow SPV peers to be ?offline? for a month and still be capable to catch-up with a peer pruned to a datadir of ~10GB.

> 
> This is technically true right now, but as soon as segwit activates, it will
> no longer be... Therefore, I suggest striking it from the BIP, expounding on
> it in greater detail, or making it true for the longer term.

AFAIK Core does also guaranteed the 288 blocks post segwit activation:
https://github.com/bitcoin/bitcoin/blob/08a7316c144f9f2516db8fa62400893f4358c5ae/src/validation.h#L204
But maybe I?m confused.

> 
>> Peers following this BIP SHOULD connect a limited amount of their available
>> outbound connections to peers signaling one or both of the
>> NODE_NETWORK_LIMITED_* service bits if they expect to request less blocks
>> than the signaled number.
> 
> This isn't entirely clear whether it refers to peers downloading blocks, or
> peers serving them. (I assume the former, but it should be clarified.)

Indeed. I?ll try to make that more clear.

> 
>> Light clients (and such) who are not checking the nServiceFlags (service
>> bits) from a relayed addr-message may unwillingly connect to a pruned peer
>> and ask for (filtered) blocks at a depth below their pruned depth.
> 
> Wouldn't this already be a problem, without the BIP?

AFAIK, Core does currently only relay NODE_NETWORK addresses.
But yes, It may be a problem already.

</jonas>

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170511/96f3a942/attachment.sig>

From vitteaymeric at gmail.com  Thu May 11 20:36:33 2017
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Thu, 11 May 2017 22:36:33 +0200
Subject: [bitcoin-dev] BIP proposal: NODE_NETWORK_LIMITED service bits
In-Reply-To: <61C68F26-AD36-4AB4-A065-020BD549CEBC@jonasschnelli.ch>
References: <E1313B4E-6061-49CA-9E8C-E5FD468531C0@jonasschnelli.ch>
	<201705111924.22055.luke@dashjr.org>
	<61C68F26-AD36-4AB4-A065-020BD549CEBC@jonasschnelli.ch>
Message-ID: <f0417e14-fb2c-3572-f8e9-06c7adbf3d2b@gmail.com>

Sorry again, is this discussion really serious?

In this thread, previous ones or others, the level of approximation is
obvious, often shadowed by useless maths/papers and strange calculations
that are not helping, at the end nobody knows what would happen "if",
how far the chain can roll back, etc

Then don't make pruning the default if it's the current concern, pruning
is of no use

Again, the priority should be to scale the full nodes


Le 11/05/2017 ? 22:10, Jonas Schnelli via bitcoin-dev a ?crit :
>> Is 49 days particularly useful? Would it be a problem to instead leave both-
>> bits undefined? I'm thinking this might be better as a way to indicate "7
>> days, plus a deterministically chosen set of historical blocks"?
> I though two service bits allow three states and we should define all three combinations.
> But I guess an adequate ?definition? would be to reserve it for future ?definitions?.
> Or use Gregory's proposal of min 2016*2 blocks & keep it ?undefined? for now.
>
> 49 days was chosen to allow SPV peers to be ?offline? for a month and still be capable to catch-up with a peer pruned to a datadir of ~10GB.
>
>> This is technically true right now, but as soon as segwit activates, it will
>> no longer be... Therefore, I suggest striking it from the BIP, expounding on
>> it in greater detail, or making it true for the longer term.
> AFAIK Core does also guaranteed the 288 blocks post segwit activation:
> https://github.com/bitcoin/bitcoin/blob/08a7316c144f9f2516db8fa62400893f4358c5ae/src/validation.h#L204
> But maybe I?m confused.
>
>>> Peers following this BIP SHOULD connect a limited amount of their available
>>> outbound connections to peers signaling one or both of the
>>> NODE_NETWORK_LIMITED_* service bits if they expect to request less blocks
>>> than the signaled number.
>> This isn't entirely clear whether it refers to peers downloading blocks, or
>> peers serving them. (I assume the former, but it should be clarified.)
> Indeed. I?ll try to make that more clear.
>
>>> Light clients (and such) who are not checking the nServiceFlags (service
>>> bits) from a relayed addr-message may unwillingly connect to a pruned peer
>>> and ask for (filtered) blocks at a depth below their pruned depth.
>> Wouldn't this already be a problem, without the BIP?
> AFAIK, Core does currently only relay NODE_NETWORK addresses.
> But yes, It may be a problem already.
>
> </jonas>
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170511/d4b6aaff/attachment-0001.html>

From eric at voskuil.org  Thu May 11 21:05:09 2017
From: eric at voskuil.org (Eric Voskuil)
Date: Thu, 11 May 2017 14:05:09 -0700
Subject: [bitcoin-dev] BIP proposal: NODE_NETWORK_LIMITED service bits
In-Reply-To: <f0417e14-fb2c-3572-f8e9-06c7adbf3d2b@gmail.com>
References: <E1313B4E-6061-49CA-9E8C-E5FD468531C0@jonasschnelli.ch>
	<201705111924.22055.luke@dashjr.org>
	<61C68F26-AD36-4AB4-A065-020BD549CEBC@jonasschnelli.ch>
	<f0417e14-fb2c-3572-f8e9-06c7adbf3d2b@gmail.com>
Message-ID: <b1bd85b6-a2c4-6243-ff41-a514eef1c334@voskuil.org>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

On 05/11/2017 01:36 PM, Aymeric Vitte via bitcoin-dev wrote:
> Sorry again, is this discussion really serious?
> 
> In this thread, previous ones or others, the level of approximation
> is obvious, often shadowed by useless maths/papers and strange
> calculations that are not helping, at the end nobody knows what
> would happen "if", how far the chain can roll back, etc
> 
> Then don't make pruning the default if it's the current concern,
> pruning is of no use
> 
> Again, the priority should be to scale the full nodes

I agree. Every full node operator should (and likely would at some
point) simply never connect to, or relay the address of, any "peer"
advertising itself as diminished. Why on earth would a full node
operator want to encourage shrinking support for bootstrapping and
deep reorgs, resulting in greater load for himself. That's a race to
the bottom.

We are literally talking about $7.50 for the *entire chain* with
breathing room. If someone wants to save a few dollars they are better
off attempting to hide their pruning.

e

> Le 11/05/2017 ? 22:10, Jonas Schnelli via bitcoin-dev a ?crit :
>>> Is 49 days particularly useful? Would it be a problem to
>>> instead leave both- bits undefined? I'm thinking this might be
>>> better as a way to indicate "7 days, plus a deterministically
>>> chosen set of historical blocks"?
>> I though two service bits allow three states and we should define
>> all three combinations. But I guess an adequate ?definition?
>> would be to reserve it for future ?definitions?. Or use Gregory's
>> proposal of min 2016*2 blocks & keep it ?undefined? for now.
>> 
>> 49 days was chosen to allow SPV peers to be ?offline? for a month
>> and still be capable to catch-up with a peer pruned to a datadir
>> of ~10GB.
>> 
>>> This is technically true right now, but as soon as segwit
>>> activates, it will no longer be... Therefore, I suggest
>>> striking it from the BIP, expounding on it in greater detail,
>>> or making it true for the longer term.
>> AFAIK Core does also guaranteed the 288 blocks post segwit
>> activation: 
>> https://github.com/bitcoin/bitcoin/blob/08a7316c144f9f2516db8fa624008
93f4358c5ae/src/validation.h#L204
>>
>> 
But maybe I?m confused.
>> 
>>>> Peers following this BIP SHOULD connect a limited amount of
>>>> their available outbound connections to peers signaling one
>>>> or both of the NODE_NETWORK_LIMITED_* service bits if they
>>>> expect to request less blocks than the signaled number.
>>> This isn't entirely clear whether it refers to peers
>>> downloading blocks, or peers serving them. (I assume the
>>> former, but it should be clarified.)
>> Indeed. I?ll try to make that more clear.
>> 
>>>> Light clients (and such) who are not checking the
>>>> nServiceFlags (service bits) from a relayed addr-message may
>>>> unwillingly connect to a pruned peer and ask for (filtered)
>>>> blocks at a depth below their pruned depth.
>>> Wouldn't this already be a problem, without the BIP?
>> AFAIK, Core does currently only relay NODE_NETWORK addresses. But
>> yes, It may be a problem already.
>> 
>> </jonas>
>> 
>> 
>> 
>> _______________________________________________ bitcoin-dev
>> mailing list bitcoin-dev at lists.linuxfoundation.org 
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> -- Zcash wallets made simple:
> https://github.com/Ayms/zcash-wallets Bitcoin wallets made simple:
> https://github.com/Ayms/bitcoin-wallets Get the torrent dynamic
> blocklist: http://peersm.com/getblocklist Check the 10 M passwords
> list: http://peersm.com/findmyass Anti-spies and private torrents,
> dynamic blocklist: http://torrent-live.org Peersm :
> http://www.peersm.com torrent-live:
> https://github.com/Ayms/torrent-live node-Tor :
> https://www.github.com/Ayms/node-Tor GitHub :
> https://www.github.com/Ayms
> 
> 
> 
> _______________________________________________ bitcoin-dev mailing
> list bitcoin-dev at lists.linuxfoundation.org 
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (GNU/Linux)

iQEcBAEBCAAGBQJZFNHtAAoJEDzYwH8LXOFOYRwH/0By+TNSgnV6m4c7g1ZrjboG
8fZSeGaz7FXmAUZ69XMdQ1H+wlP0e4OAz9eRCcVqcn3K9OZJn++hbzI2K+zijyxZ
cpQjg/2dcTc4B0Z3PZdnuZx5mnHzavr/1vPlgOYla7AbYqcKB5dkq/HqgD6tFsJP
HXPClbEkVRF6UFP/7sDfzW8FMJycMSVcbEpuWAhcx2d+NusywWhbkuc5NiT9J1Ug
/3OFhHVJtd+rDl2B4iRHXHOhysUGffvmmLANZpPMcOgplM6Xwv7nMT34FV4HCdgs
Gyxc9GSFsD6xsOshBRPICtEZe+IDDb0cnOLjDdAnUnKeolUljFY52djSa300Fp0=
=REyc
-----END PGP SIGNATURE-----

From greg at xiph.org  Fri May 12 02:22:15 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Fri, 12 May 2017 02:22:15 +0000
Subject: [bitcoin-dev] BIP proposal: NODE_NETWORK_LIMITED service bits
In-Reply-To: <E1313B4E-6061-49CA-9E8C-E5FD468531C0@jonasschnelli.ch>
References: <E1313B4E-6061-49CA-9E8C-E5FD468531C0@jonasschnelli.ch>
Message-ID: <CAAS2fgR7hpVE+G7NZWMfSd_2JF76_PT8FC51QQjS1gfq0YfEYw@mail.gmail.com>

On Thu, May 11, 2017 at 3:13 PM, Jonas Schnelli via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Hi
>
> Currently, pruned peers have no way how to signal their (valuable) service.
> A BIP proposal to improve this (draft):
> https://github.com/jonasschnelli/bips/wiki/NODE_NETWORK_LIMITED-BIP-DRAFT

The instructions for relay addresses should not instruct you to relay
these addresses but rather that you should relay addresses you would
connect to, under the generalized assumption that if it is useful to
you it will be useful to others.

This avoids instructing someone who might not consider
non-node-network peers useful from being directed by the BIP to relay
things that they don't find useful. (In particular, it means that the
obvious implementation of just throwing out the 'useless' information
works fine.)  I think would better reflect what people are likely to
actually do.

From luke at dashjr.org  Fri May 12 19:22:56 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Fri, 12 May 2017 19:22:56 +0000
Subject: [bitcoin-dev] BIP: Block signal enforcement via tx fees
Message-ID: <201705121922.57445.luke@dashjr.org>

I've written a new BIP draft for OP_CHECKBLOCKVERSION to allow the community 
to put economic pressure on miners to deploy softforks without the extreme of 
a UASF.

    https://github.com/luke-jr/bips/blob/bip-cbv/bip-cbv.mediawiki

Due to the potential for miners to maliciously block this softfork, it is 
suggested that we deploy it using BIP 8 to ensure it eventually activates even 
if encountering hostility.

This is intended to be an alternative to BIP 8 in the long term.
It is NOT intended to make BIP 148 obsolete, given the timeframes involved.

An implementation is available (based on top of BIP 115's implementation):

   https://github.com/luke-jr/bitcoin/compare/cbah...luke-jr:checkblockversion

Luke

From pete at petertodd.org  Fri May 12 22:22:14 2017
From: pete at petertodd.org (Peter Todd)
Date: Fri, 12 May 2017 18:22:14 -0400
Subject: [bitcoin-dev] BIP: Block signal enforcement via tx fees
In-Reply-To: <201705121922.57445.luke@dashjr.org>
References: <201705121922.57445.luke@dashjr.org>
Message-ID: <20170512222214.GA4462@fedora-23-dvm>

On Fri, May 12, 2017 at 07:22:56PM +0000, Luke Dashjr via bitcoin-dev wrote:
> I've written a new BIP draft for OP_CHECKBLOCKVERSION to allow the community 
> to put economic pressure on miners to deploy softforks without the extreme of 
> a UASF.
> 
>     https://github.com/luke-jr/bips/blob/bip-cbv/bip-cbv.mediawiki

I strongly disagree with this proposal.

nVersion signaling is already technically unenforceable, in the sense that we
don't have good ways of ensuring miners actually adopt the rules they're
claiming to signal. Equally, it's users who ultimately adopt rules, not miners,
and attempting to pay miners to signal certain bits will further confuse this
point.

Quite likely the outcome of users trying to anonymously pay anonymous miners to
signal certain bits will be the complete breakdown of the honesty of the
nVersion signalling system, currently enforced only by "gentlemans agreement".

A more productive direction would be a direct coin-owner signalling process,
with users taking action based on what provable coin-ownership has signalled.


Also, as an aside, this "specification" again shows the inadequacy and
unreadability of English language specifications. I'd strongly suggest you
delete it and instead mark the "reference implementation" as the specification.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170512/ff3215fe/attachment.sig>

From ZmnSCPxj at protonmail.com  Fri May 12 22:17:30 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 12 May 2017 18:17:30 -0400
Subject: [bitcoin-dev] BIP: Block signal enforcement via tx fees
In-Reply-To: <201705121922.57445.luke@dashjr.org>
References: <201705121922.57445.luke@dashjr.org>
Message-ID: <v_YlxaCGvHfFVkj0sy6c8Mt3vm7bSI1Yr-9sCkbO9SEXTBB5k9RlEh4fyD6fnQP-Wn5haxRcbFif5iYUDv7WjMiJebwBsqXj5EvjLFHLD_U=@protonmail.com>

Good morning Luke,

Minor editorial nitpick, this paragraph is repeated, maybe one of these should be Testnet?

For Bitcoin '''mainnet''', the BIP8 '''starttime''' will be TBD (Epoch timestamp TBD) and BIP8 '''timeout''' will be TBD (Epoch timestamp TBD).

For Bitcoin '''mainnet''', the BIP8 '''starttime''' will be TBD (Epoch timestamp TBD) and BIP8 '''timeout''' will be TBD (Epoch timestamp TBD).

Regards,
ZmnSCPxj
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170512/07779029/attachment.html>

From luke at dashjr.org  Sat May 13 00:49:33 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Sat, 13 May 2017 00:49:33 +0000
Subject: [bitcoin-dev] BIP: Block signal enforcement via tx fees
In-Reply-To: <20170512222214.GA4462@fedora-23-dvm>
References: <201705121922.57445.luke@dashjr.org>
	<20170512222214.GA4462@fedora-23-dvm>
Message-ID: <201705130049.33798.luke@dashjr.org>

On Friday 12 May 2017 10:22:14 PM Peter Todd wrote:
> nVersion signaling is already technically unenforceable, in the sense that
> we don't have good ways of ensuring miners actually adopt the rules
> they're claiming to signal. Equally, it's users who ultimately adopt
> rules, not miners, and attempting to pay miners to signal certain bits
> will further confuse this point.

This BIP doesn't change that. Enforcement remains primarily by users.

> Quite likely the outcome of users trying to anonymously pay anonymous
> miners to signal certain bits will be the complete breakdown of the
> honesty of the nVersion signalling system, currently enforced only by
> "gentlemans agreement".

You assume users will pay for signalling of softforks prematurely. So long as 
it waits until deployment of the softfork is widespread, this risk is minimal. 
At worst, it creates risks similar to a UASF. So long as UASF is the 
alternative, this way seems strictly better.

> Also, as an aside, this "specification" again shows the inadequacy and
> unreadability of English language specifications. I'd strongly suggest you
> delete it and instead mark the "reference implementation" as the
> specification.

How so?

On Friday 12 May 2017 10:17:30 PM ZmnSCPxj wrote:
> Minor editorial nitpick, this paragraph is repeated, maybe one of these
> should be Testnet?
> 
> For Bitcoin '''mainnet''', the BIP8 '''starttime''' will be TBD (Epoch
> timestamp TBD) and BIP8 '''timeout''' will be TBD (Epoch timestamp TBD).
> 
> For Bitcoin '''mainnet''', the BIP8 '''starttime''' will be TBD (Epoch
> timestamp TBD) and BIP8 '''timeout''' will be TBD (Epoch timestamp TBD).

Fixed, thanks.

Luke

From eric at voskuil.org  Sat May 13 03:26:08 2017
From: eric at voskuil.org (Eric Voskuil)
Date: Fri, 12 May 2017 20:26:08 -0700
Subject: [bitcoin-dev] BIP: Block signal enforcement via tx fees
In-Reply-To: <201705130049.33798.luke@dashjr.org>
References: <201705121922.57445.luke@dashjr.org>
	<20170512222214.GA4462@fedora-23-dvm>
	<201705130049.33798.luke@dashjr.org>
Message-ID: <c1a9b1d9-2810-0343-980d-45000c8600a8@voskuil.org>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

If people want to influence the decisions of miners, all they need to
do is mine.

I do not see why any person would want to pay, and then trust, another
to mine accordingly. Each person can mine and attain their level of
influence. This not only avoids the side payment, but earns the person
money.

There is nothing inherently wrong with paying people to run nodes or
signal "readiness", but there is no reason whatsoever to consider
these ideas beneficial from a personal/economic or
security/decentralization standpoint.

If you are not running a node you are not part of the economic
consensus. If you are not mining you have no say in transaction
ordering. The "solution" is both obvious and necessary to secure Bitcoin
.

If a person does not want to bother then he/she clearly does not have
a strong opinion. As developers we should be focused on reducing the
complexities of mining and of validation, not finding ways for people
to avoid participating in these necessarily distributed roles.

e

On 05/12/2017 05:49 PM, Luke Dashjr via bitcoin-dev wrote:
> On Friday 12 May 2017 10:22:14 PM Peter Todd wrote:
>> nVersion signaling is already technically unenforceable, in the 
>> sense that we don't have good ways of ensuring miners actually 
>> adopt the rules they're claiming to signal. Equally, it's users 
>> who ultimately adopt rules, not miners, and attempting to pay 
>> miners to signal certain bits will further confuse this point.
> 
> This BIP doesn't change that. Enforcement remains primarily by 
> users.
> 
>> Quite likely the outcome of users trying to anonymously pay 
>> anonymous miners to signal certain bits will be the complete 
>> breakdown of the honesty of the nVersion signalling system, 
>> currently enforced only by "gentlemans agreement".
> 
> You assume users will pay for signalling of softforks prematurely.
>  So long as it waits until deployment of the softfork is 
> widespread, this risk is minimal. At worst, it creates risks 
> similar to a UASF. So long as UASF is the alternative, this way 
> seems strictly better.
> 
>> Also, as an aside, this "specification" again shows the 
>> inadequacy and unreadability of English language specifications.
>>  I'd strongly suggest you delete it and instead mark the 
>> "reference implementation" as the specification.
> 
> How so?
> 
> On Friday 12 May 2017 10:17:30 PM ZmnSCPxj wrote:
>> Minor editorial nitpick, this paragraph is repeated, maybe one of
>> these should be Testnet?
>> 
>> For Bitcoin '''mainnet''', the BIP8 '''starttime''' will be TBD 
>> (Epoch timestamp TBD) and BIP8 '''timeout''' will be TBD (Epoch 
>> timestamp TBD).
>> 
>> For Bitcoin '''mainnet''', the BIP8 '''starttime''' will be TBD 
>> (Epoch timestamp TBD) and BIP8 '''timeout''' will be TBD (Epoch 
>> timestamp TBD).
> 
> Fixed, thanks.
> 
> Luke _______________________________________________ bitcoin-dev 
> mailing list bitcoin-dev at lists.linuxfoundation.org 
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (GNU/Linux)

iQEcBAEBCAAGBQJZFnzNAAoJEDzYwH8LXOFOlMsH/2Li7lDTr57EC2mSt4BuCf3Q
Q1sx21CBumm6OQKMxd207wgXTaxVJVmrGPXfJ6ZW8Bf+2tMKgc/LsZfzXdEo5+Fx
iTkdgJeW8QbKiEGzOFKMxWXH9jyCnd0WcDnKw/v7WqUhYfy2c9wz9RzCMY5iJqph
xd2+DeiEIjXIvE+l2TXGwjnB8Wp41QeY0I98kG3HHwNvNREbbGS/BjtLj5+eBygU
m+6dxkJoEttms31F47WFoZRzN7u5pe3BY5kDfZdVkbG7MOomSYwlhMvR3PtA1wrz
FeAUcHpp9MPj+qgHGwAGMfJiG/5WsVSrl/dJTm68zPOdwH60fMNNT/Srfbj1Ty8=
=9Xik
-----END PGP SIGNATURE-----

From roconnor at blockstream.io  Sat May 13 04:23:41 2017
From: roconnor at blockstream.io (Russell O'Connor)
Date: Sat, 13 May 2017 00:23:41 -0400
Subject: [bitcoin-dev] BIP: Block signal enforcement via tx fees
In-Reply-To: <201705121922.57445.luke@dashjr.org>
References: <201705121922.57445.luke@dashjr.org>
Message-ID: <CAMZUoKnzV9faJ+mBTTzTre05Ejwnx3tC4ozbiPoPUfS+7GLMTQ@mail.gmail.com>

I recall chatting about this idea recently and my conclusion was the same
as Peter Todd's conclusion: this will just encourage miners to false signal
readiness with undermines both BIP 9 and BIP 8.

I felt that rather than using script system for this construction, it would
be better to use the transaction version number instead by soft-forking in
a rule that says when the most significant bits of a transaction version
are 001 then the transaction can only be included in blocks whose lower 29
version bits are set at the same position as the lower 29 version bits set
in the transaction version.

That is to say, if we have block version blkVersion and transaction version
txVersion, we soft fork in a rule that requires that

(txVersion & 0xe0000000 != 0x020000000) || ((blkVersion & 0xe0000000 =
0x020000000) && (blkVersion & txVersion = txVersion))

While I think that making use of the transaction version number is superior
to adding an opcode, because it doesn't interfere with caching of script
validity and because it doesn't use any more transaction space by making
use of the otherwise useless transaction version number, I still think it
is a bad proposal.

On Fri, May 12, 2017 at 3:22 PM, Luke Dashjr via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I've written a new BIP draft for OP_CHECKBLOCKVERSION to allow the
> community
> to put economic pressure on miners to deploy softforks without the extreme
> of
> a UASF.
>
>     https://github.com/luke-jr/bips/blob/bip-cbv/bip-cbv.mediawiki
>
> Due to the potential for miners to maliciously block this softfork, it is
> suggested that we deploy it using BIP 8 to ensure it eventually activates
> even
> if encountering hostility.
>
> This is intended to be an alternative to BIP 8 in the long term.
> It is NOT intended to make BIP 148 obsolete, given the timeframes involved.
>
> An implementation is available (based on top of BIP 115's implementation):
>
>    https://github.com/luke-jr/bitcoin/compare/cbah...luke-
> jr:checkblockversion
>
> Luke
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170513/5ceec501/attachment-0001.html>

From luke at dashjr.org  Sat May 13 05:26:58 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Sat, 13 May 2017 05:26:58 +0000
Subject: [bitcoin-dev] BIP: Block signal enforcement via tx fees
In-Reply-To: <CAMZUoKnzV9faJ+mBTTzTre05Ejwnx3tC4ozbiPoPUfS+7GLMTQ@mail.gmail.com>
References: <201705121922.57445.luke@dashjr.org>
	<CAMZUoKnzV9faJ+mBTTzTre05Ejwnx3tC4ozbiPoPUfS+7GLMTQ@mail.gmail.com>
Message-ID: <201705130526.59467.luke@dashjr.org>

On Saturday 13 May 2017 4:23:41 AM Russell O'Connor wrote:
> I recall chatting about this idea recently and my conclusion was the same
> as Peter Todd's conclusion: this will just encourage miners to false signal
> readiness with undermines both BIP 9 and BIP 8.

I already explained why this isn't the case: If we're comparing MASF to 
MASF+CBV, then I agree. But MASF is not necessarily always on the table, so 
the comparison where this becomes relevant is MASF+CBV vs UASF.

> I felt that rather than using script system for this construction, it would
> be better to use the transaction version number instead by soft-forking in
> a rule that says when the most significant bits of a transaction version
> are 001 then the transaction can only be included in blocks whose lower 29
> version bits are set at the same position as the lower 29 version bits set
> in the transaction version.

Versionbits change/lose their meaning after the deployment timeout. For this 
reason, the timeout must be specified so the check is skipped when that 
occurs.

Also, doing it the way you describe would fail to enforce that BIP9 is 
actually in use for the block version; you could simply add that as an 
additional condition, but it seems pretty hacky since you wouldn't be able to 
upgrade versionbits anymore...

> While I think that making use of the transaction version number is superior
> to adding an opcode, because it doesn't interfere with caching of script
> validity

Script validity can still be cached with this: you would always allow the 
opcode to succeed at evaluation-time, and simply store the criteria checked 
separately. Then it would behave effectively the same as using the transaction 
version number.

Luke

From luke at dashjr.org  Sat May 13 05:45:24 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Sat, 13 May 2017 05:45:24 +0000
Subject: [bitcoin-dev] BIP: Block signal enforcement via tx fees
In-Reply-To: <c1a9b1d9-2810-0343-980d-45000c8600a8@voskuil.org>
References: <201705121922.57445.luke@dashjr.org>
	<201705130049.33798.luke@dashjr.org>
	<c1a9b1d9-2810-0343-980d-45000c8600a8@voskuil.org>
Message-ID: <201705130545.25398.luke@dashjr.org>

On Saturday 13 May 2017 3:26:08 AM Eric Voskuil wrote:
> If people want to influence the decisions of miners, all they need to
> do is mine.

Most people cannot mine except at a huge expense (profit is limited to few 
people via monopoly and electric costs). But more importantly, the profits 
from every miner you buy will go to pay for Bitmain growing their arsenal more 
than enough to offset your influence.

Mining is simply broken at this point.

> There is nothing inherently wrong with paying people to run nodes or
> signal "readiness", but there is no reason whatsoever to consider
> these ideas beneficial from a personal/economic or
> security/decentralization standpoint.

Running a node and mining are two very different things.

> The argument fails to recognize that mining for one's self may (or may
> not) result in a net loss, but donating to a miner in the hope of some
> action is comparatively a total loss. One is an expense in exchange
> for the intended social outcome, and the other is payment for
> representative government.
> 
> And in this form of representative government that you propose, if we
> assume that miners are somehow bound to honor the payments (votes), ...

First of all, this isn't donating to miners, but forbidding them from mining 
your transaction (and thereby collecting your transaction fee) unless they 
signal for the softfork.

Secondly, your argument here assumes miners are a government or control 
Bitcoin in some way. This is not correct. Miners are entrusted with 
enforcement of softforks *for old nodes only*, and therefore given the ability 
to trigger activation of the new rules via signalling. But entrusting them 
with this is NOT done by the system itself, but by the users, whose updated 
nodes are the primary mechanism for enforcing softforks. So miners are in fact 
already bound to honour the wishes of the greater economy, and their refusal 
to do so is an attack on the network.

Luke

From ZmnSCPxj at protonmail.com  Sat May 13 03:54:50 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 12 May 2017 23:54:50 -0400
Subject: [bitcoin-dev] BIP: Block signal enforcement via tx fees
In-Reply-To: <c1a9b1d9-2810-0343-980d-45000c8600a8@voskuil.org>
References: <201705121922.57445.luke@dashjr.org>
	<20170512222214.GA4462@fedora-23-dvm>
	<201705130049.33798.luke@dashjr.org>
	<c1a9b1d9-2810-0343-980d-45000c8600a8@voskuil.org>
Message-ID: <9wQ5nhkJrHXumjwhT4rUh4oqyVJXw1GaOgbfk3snTRms7BD_k39hfsNlpbs7sZ4hWpXzt1F0yzQeWky_INbTTLyCwybyVqUTdlvGBg8Qkpo=@protonmail.com>

Good morning,

>I do not see why any person would want to pay, and then trust, another
>to mine accordingly. Each person can mine and attain their level of
>influence. This not only avoids the side payment, but earns the person
>money.

The problem, is that, the rate of conversion of Bitcoin-> hashrate is different for different people.

For some, it's very cheap to convert Bitcoin -> hashrate. For others, it's very expensive. The reason, is the large difference in electricity rates depending on country.

It's all very well for those who can get electricity cheaply. But, for some, it is not.

Thus, paying someone with better Bitcoin->hashrate conversion via fees such as these is more economically logical, than to suffer a lower Bitcoin->hashrate conversion.

>If a person does not want to bother then he/she clearly does not have
>a strong opinion. As developers we should be focused on reducing the
>complexities of mining and of validation, not finding ways for people
>to avoid participating in these necessarily distributed roles.

It is also, very obviously, clear that you are operating under very strange assumptions, that all people are already equal somehow, or that someone who is paid x10 more is strictly superior, even though skill-wise and ability-wise, they are the same, and the one paid less is simply suffering due to the country where he or she is born in, through no fault of their own.

Regards,
ZmnSCPxj
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170512/2496484f/attachment.html>

From eric at voskuil.org  Sat May 13 05:36:43 2017
From: eric at voskuil.org (Eric Voskuil)
Date: Fri, 12 May 2017 22:36:43 -0700
Subject: [bitcoin-dev] BIP: Block signal enforcement via tx fees
In-Reply-To: <9wQ5nhkJrHXumjwhT4rUh4oqyVJXw1GaOgbfk3snTRms7BD_k39hfsNlpbs7sZ4hWpXzt1F0yzQeWky_INbTTLyCwybyVqUTdlvGBg8Qkpo=@protonmail.com>
References: <201705121922.57445.luke@dashjr.org>
	<20170512222214.GA4462@fedora-23-dvm>
	<201705130049.33798.luke@dashjr.org>
	<c1a9b1d9-2810-0343-980d-45000c8600a8@voskuil.org>
	<9wQ5nhkJrHXumjwhT4rUh4oqyVJXw1GaOgbfk3snTRms7BD_k39hfsNlpbs7sZ4hWpXzt1F0yzQeWky_INbTTLyCwybyVqUTdlvGBg8Qkpo=@protonmail.com>
Message-ID: <ba058f96-b113-f0d7-3a49-0f63336ac0b5@voskuil.org>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

On 05/12/2017 08:54 PM, ZmnSCPxj wrote:
> Good morning,
> 
>> I do not see why any person would want to pay, and then trust,
>> another to mine accordingly. Each person can mine and attain
>> their level of influence. This not only avoids the side payment,
>> but earns the person money.
> 
> The problem, is that, the rate of conversion of Bitcoin-> hashrate
> is different for different people.
> 
> For some, it's very cheap to convert Bitcoin -> hashrate.  For
> others, it's very expensive.  The reason, is the large difference
> in electricity rates depending on country.
> 
> It's all very well for those who can get electricity cheaply.  But,
> for some, it is not.
> 
> Thus, paying someone with better Bitcoin->hashrate conversion via
> fees such as these is more economically logical, than to suffer a
> lower Bitcoin->hashrate conversion.

Despite the tedious explanation of absolute advantage, this is simply
an argument for all people to pay one person to mine, as there is
presumably always one person who will be able to mine more efficiently
than all others.

The argument fails to recognize that mining for one's self may (or may
not) result in a net loss, but donating to a miner in the hope of some
action is comparatively a total loss. One is an expense in exchange
for the intended social outcome, and the other is payment for
representative government.

And in this form of representative government that you propose, if we
assume that miners are somehow bound to honor the payments (votes),
how are the votes distributed? Is this supposed to be democratic in
the sense of one person one vote? Your argument below is clearly based
on that idea. However the result would be very different. The
wealthier would of course exert the greater influence. So the idea
fails by its own standard.

>> If a person does not want to bother then he/she clearly does not
>> have a strong opinion. As developers we should be focused on
>> reducing the complexities of mining and of validation, not
>> finding ways for people to avoid participating in these
>> necessarily distributed roles.
> 
> It is also, very obviously, clear that you are operating under
> very strange assumptions, that all people are already equal
> somehow, or that someone who is paid x10 more is strictly superior,
> even though skill-wise and ability-wise, they are the same, and the
> one paid less is simply suffering due to the country where he or
> she is born in, through no fault of their own.

You are making a political argument wrapped in appeal to emotion. Both
are pointless in this context.

e
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (GNU/Linux)

iQEcBAEBCAAGBQJZFptnAAoJEDzYwH8LXOFOs34IAIciCyrn7FMq7leiQ6jAvr3g
sW9YRQ403IJd9BiBj3lI6xpsxtJ4zezkU2AFZUTf9X6AoIX/UJtPb8clb4RIpicf
ACK+iec4YM+15kgPcLyLij3aALvNNCNQ+XuXeHT1bHqfukP+bc/DBAnm48qGvW9o
ugRIFFWqtt8FB9MAh/VM6SsfaQc3D8hk6Dh3SyEVzohkrgWpRVQKNGD/FYY8odCA
8KPo/R3jrgO6JNR0EGxR3SatuKLYUgMcl3n63fanAOh8ESHGHHiP0SEpYoG3wOCt
eAyEcPI4SezJHBjJWcsPe0hhLg0HkvFaLwQe8tGHXrCzsZ18QTNBA0h9npWqqi4=
=LKcb
-----END PGP SIGNATURE-----

From eric at voskuil.org  Sat May 13 06:43:59 2017
From: eric at voskuil.org (Eric Voskuil)
Date: Fri, 12 May 2017 23:43:59 -0700
Subject: [bitcoin-dev] BIP: Block signal enforcement via tx fees
In-Reply-To: <201705130545.25398.luke@dashjr.org>
References: <201705121922.57445.luke@dashjr.org>
	<201705130049.33798.luke@dashjr.org>
	<c1a9b1d9-2810-0343-980d-45000c8600a8@voskuil.org>
	<201705130545.25398.luke@dashjr.org>
Message-ID: <b34279c2-7ee0-6959-0ef6-30c12b620ff3@voskuil.org>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

On 05/12/2017 10:45 PM, Luke Dashjr wrote:
> On Saturday 13 May 2017 3:26:08 AM Eric Voskuil wrote:
>> If people want to influence the decisions of miners, all they
>> need to do is mine.
> 
> Most people cannot mine except at a huge expense (profit is limited
> to few people via monopoly and electric costs). But more
> importantly, the profits from every miner you buy will go to pay
> for Bitmain growing their arsenal more than enough to offset your
> influence.

You seem to be suggesting that in order to decentralize mining nobody
should mine. I'm having a hard time making sense out of that.

> Mining is simply broken at this point.

So maybe you are just saying that nobody should mine because it's a
zero sum game that one miner will always win and therefore we should
not push up the hash rate by trying to compete because the same miner
just makes more money on the hardware. Apparently it is economically
impossible for anyone else to compete in hardware as well.

I agree that there is a serious problem of mining centralization (and
economic/validation centralization). If these problems are not solved
Bitcoin will fail. It will rise again, with people a little wiser, but
the disruption will be unfortunate for many.

I don't want to see that, so I tend to not advocate for solutions that
run counter to the security model. Many people must mine, there is no
way around it. And if people want a say with respect to mining, they
should mine. As a developer I would rather work toward fixing that
problem than putting a band-aid over it that basically tells people
that the way they get their say is by donating to the big mining
personality of their choice.

>> There is nothing inherently wrong with paying people to run nodes
>> or signal "readiness", but there is no reason whatsoever to
>> consider these ideas beneficial from a personal/economic or 
>> security/decentralization standpoint.
> 
> Running a node and mining are two very different things.

No, really?

If it wasn't clear, I was relating two sets of proposals. One aims to
find ways to fund node operation and the other aims to fund miner
signaling. The former fails to understand the economics and security
model of full node operation and the latter fails to understand that
distributed mining is as essential to Bitcoin survival as distributed
validation.

>> The argument fails to recognize that mining for one's self may
>> (or may not) result in a net loss, but donating to a miner in the
>> hope of some action is comparatively a total loss. One is an
>> expense in exchange for the intended social outcome, and the
>> other is payment for representative government.
>> 
>> And in this form of representative government that you propose,
>> if we assume that miners are somehow bound to honor the payments
>> (votes), ...
> 
> First of all, this isn't donating to miners, but forbidding them
> from mining your transaction (and thereby collecting your
> transaction fee) unless they signal for the softfork.

I assumed that people understand how markets work. Miners compete for
fees. By eliminating a subset of potential sellers (currently by ~70%)
the buyer raises his own price. Presumably the price is raised even
further by increasing the size of the transaction. This is either a
donation to the cause or a purchase of the signal, depending on how
you want to describe it (all donations are purchases of a sort).

So there is a cost increase that could alternatively be incurred by
mining (i.e. assuming a lossy operation). If one is going to spend
money on influencing mining one might as well not do it in a way that
contributes to centralization while training people to rely on it.

> Secondly, your argument here assumes miners are a government or
> control Bitcoin in some way. This is not correct.

Miners absolutely "control Bitcoin in some way" - that is their
purpose. They control the ordering of transactions, and with
sufficient hash power can double-spend and therefore make the network
unusable. Why would you bother to make me type this?

> So miners are in fact already bound to honour the wishes of the
> greater economy, and their refusal to do so is an attack on the
> network.

Absolute nonsense, a miner incurs no obligation to the "greater
economy". He is offering a service in voluntary trade. He is likely to
do what it takes to spend his coinbase, assuming he wants to. This
gives the economy strong economic control over his behavior. But
nothing whatsoever obligates him to signal soft forks (or not optimize
his operations).

Double spending is an attack, on the person who has been robbed. The
state enforcing a patent is an attack, on the person against whom it
is enforced. These are called attacks **because they are actually
theft**. You are conflating normal operation (despite disagreement
with some unmeasurable "wishes") with robbery.

e
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (GNU/Linux)

iQEcBAEBCAAGBQJZFqstAAoJEDzYwH8LXOFOsvsH/2aWlsfi5hB1IrnX1UBsMJl8
+R6BZE+d5C5uNkk6/yENHqwwgTv8yhOKav2Y7xYx/DedhVftX90h9CtdeKGgCS2H
cYNtoNauAvF2nlEMGGGcinLkYbS0dyQm07zwOI8gwuzbkslFGxLFClngFlFgMF4S
4/YCWvtRJ0O5dkrAZuKwG/7JQ1JNopbDTxssirA/OzwTGjq7BUv7INyR8nBbOp6I
xcrjq2bXja6Kxo08pr3+UrWc+0LO8fvX9z3rkm6USyin7TueS85gEUsk30h1Xng3
Al1QccJ9KKJ+iQKdGozeHD2OlTFC1zW2kZaWbhgxOewDlmf7cNwZXEUwfr4C4Hs=
=j5eo
-----END PGP SIGNATURE-----

From pete at petertodd.org  Sat May 13 12:48:48 2017
From: pete at petertodd.org (Peter Todd)
Date: Sat, 13 May 2017 08:48:48 -0400
Subject: [bitcoin-dev] BIP: Block signal enforcement via tx fees
In-Reply-To: <201705130049.33798.luke@dashjr.org>
References: <201705121922.57445.luke@dashjr.org>
	<20170512222214.GA4462@fedora-23-dvm>
	<201705130049.33798.luke@dashjr.org>
Message-ID: <20170513124848.GC8884@fedora-23-dvm>

On Sat, May 13, 2017 at 12:49:33AM +0000, Luke Dashjr wrote:
> On Friday 12 May 2017 10:22:14 PM Peter Todd wrote:
> > nVersion signaling is already technically unenforceable, in the sense that
> > we don't have good ways of ensuring miners actually adopt the rules
> > they're claiming to signal. Equally, it's users who ultimately adopt
> > rules, not miners, and attempting to pay miners to signal certain bits
> > will further confuse this point.
> 
> This BIP doesn't change that. Enforcement remains primarily by users.

I'm not arguing that it changes that; I'm arguing that it further confuses the
situation.

> > Quite likely the outcome of users trying to anonymously pay anonymous
> > miners to signal certain bits will be the complete breakdown of the
> > honesty of the nVersion signalling system, currently enforced only by
> > "gentlemans agreement".
> 
> You assume users will pay for signalling of softforks prematurely. So long as 
> it waits until deployment of the softfork is widespread, this risk is minimal. 
> At worst, it creates risks similar to a UASF. So long as UASF is the 
> alternative, this way seems strictly better.

I think you're assuming that the users paying for soft-fork signalling will
represent an economic majority; that's not necessarily the case.

For example, if miners decide there's no downside to false signalling, they may
take the extra fees provided by 1% of the users paying to signal a fork, while
the other 99% don't participate, resulting in a situation where we have blocks
violating the nVersion protocol, and an unknown % of that 99% rejecting those
blocks. At best that'd be no worse than a UASF, and at wost you're wrecked the
validity of the nVersion "gentlemans agreement"

> > Also, as an aside, this "specification" again shows the inadequacy and
> > unreadability of English language specifications. I'd strongly suggest you
> > delete it and instead mark the "reference implementation" as the
> > specification.
> 
> How so?

Just read it: you have ten separate lines of dense English text describing
something that could have been specified instead by ten lines of much more
formally defined C++. In particular, note how many of those lines of English
text refer to C++ code anyway, like the sentence "minimal-length 40-bit
CScriptNum"

I don't want to have to learn another language - formally defined English that
still fails to be formally defined - just to read Bitcoin's specification.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170513/b4e84f6e/attachment-0001.sig>

From luke at dashjr.org  Sat May 13 16:42:44 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Sat, 13 May 2017 16:42:44 +0000
Subject: [bitcoin-dev] BIP: Block signal enforcement via tx fees
In-Reply-To: <20170513124848.GC8884@fedora-23-dvm>
References: <201705121922.57445.luke@dashjr.org>
	<201705130049.33798.luke@dashjr.org>
	<20170513124848.GC8884@fedora-23-dvm>
Message-ID: <201705131642.45124.luke@dashjr.org>

On Saturday 13 May 2017 12:48:48 PM Peter Todd wrote:
> > You assume users will pay for signalling of softforks prematurely. So
> > long as it waits until deployment of the softfork is widespread, this
> > risk is minimal. At worst, it creates risks similar to a UASF. So long
> > as UASF is the alternative, this way seems strictly better.
> 
> I think you're assuming that the users paying for soft-fork signalling will
> represent an economic majority; that's not necessarily the case.

I'm assuming that if the economic majority hasn't consented to the softfork, 
at least as many users will make their transactions conditional on non-
signalling.


From roconnor at blockstream.io  Sat May 13 17:11:27 2017
From: roconnor at blockstream.io (Russell O'Connor)
Date: Sat, 13 May 2017 13:11:27 -0400
Subject: [bitcoin-dev] BIP: Block signal enforcement via tx fees
In-Reply-To: <201705130526.59467.luke@dashjr.org>
References: <201705121922.57445.luke@dashjr.org>
	<CAMZUoKnzV9faJ+mBTTzTre05Ejwnx3tC4ozbiPoPUfS+7GLMTQ@mail.gmail.com>
	<201705130526.59467.luke@dashjr.org>
Message-ID: <CAMZUoKnjc4ezVm4FeMFA-+=g13E5ZwZCAoAjd_yL89v7qf1gEA@mail.gmail.com>

On Sat, May 13, 2017 at 1:26 AM, Luke Dashjr <luke at dashjr.org> wrote:

> Versionbits change/lose their meaning after the deployment timeout. For
> this
> reason, the timeout must be specified so the check is skipped when that
> occurs.
>

To add a timeout a user can optionally bundle a pair of similar
transactions.  One with the transaction version bits set and a second with
a locktime set.  The effect is the same.

Also, doing it the way you describe would fail to enforce that BIP9 is
> actually in use for the block version; you could simply add that as an
> additional condition, but it seems pretty hacky since you wouldn't be able
> to
> upgrade versionbits anymore...
>


My formal condition does include a check for the block version (I've
corrected the constants below):

(txVersion & 0xe0000000 != 0x200000000) || (*(blkVersion & 0xe0000000 =
0x200000000)* && (blkVersion & txVersion = txVersion))

Nothing here prevents upgrading versionbits AFAICT.  Any txVersion that
does not begin with 0b001 is unconditionally acceptable and available for
further soft-forking.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170513/a5f8fe70/attachment.html>

From rusty at rustcorp.com.au  Mon May 15 01:14:13 2017
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Mon, 15 May 2017 10:44:13 +0930
Subject: [bitcoin-dev] BIP: Block signal enforcement via tx fees
In-Reply-To: <CAMZUoKnjc4ezVm4FeMFA-+=g13E5ZwZCAoAjd_yL89v7qf1gEA@mail.gmail.com>
References: <201705121922.57445.luke@dashjr.org>
	<CAMZUoKnzV9faJ+mBTTzTre05Ejwnx3tC4ozbiPoPUfS+7GLMTQ@mail.gmail.com>
	<201705130526.59467.luke@dashjr.org>
	<CAMZUoKnjc4ezVm4FeMFA-+=g13E5ZwZCAoAjd_yL89v7qf1gEA@mail.gmail.com>
Message-ID: <87tw4mly56.fsf@rustcorp.com.au>

Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
writes:
> On Sat, May 13, 2017 at 1:26 AM, Luke Dashjr <luke at dashjr.org> wrote:
>
>> Versionbits change/lose their meaning after the deployment timeout. For
>> this
>> reason, the timeout must be specified so the check is skipped when that
>> occurs.
>>
>
> To add a timeout a user can optionally bundle a pair of similar
> transactions.  One with the transaction version bits set and a second with
> a locktime set.  The effect is the same.

I have a similar proposal to Russell; use tx nVersion.  However, my
subset is simpler, and uses fewer precious nVersion bits:

1. Top version 26 bits must be 1 (say)
2. Next bit indicates positive (must have bit set) or negative (must NOT
   have bit set).
3. Bottom 5 bits refer to which BIP8/9 bit we're talking about.

This only allows specifying a single bit, and only support BIP8/9-style
signalling.

I believe we can skip the timeout: miners don't signal 100% either way
anyway.  If a BIP is in LOCKIN, wallets shouldn't set positive on that
bit (this gives them two weeks).  Similarly, if a BIP is close to
FAILED, don't set positive on your tx.  Wallets shouldn't signal until
any bit until see some minimal chance it's accepted (eg. 1 in 20 blocks).

> I recall chatting about this idea recently and my conclusion was the same
> as Peter Todd's conclusion: this will just encourage miners to false signal
> readiness with undermines both BIP 9 and BIP 8.

This is gentler on miners than a UASF flag day, and does offer some
harder-to-game signalling from bitcoin users.

False signalling miners still have the 2 week LOCKIN period to upgrade,
otherwise they can already lose money.  You could argue they're *more*
likely to upgrade with a signal that significant parts of the economy
have done so.

Cheers,
Rusty.

From ZmnSCPxj at protonmail.com  Sun May 14 12:18:18 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sun, 14 May 2017 08:18:18 -0400
Subject: [bitcoin-dev] BIP: Block signal enforcement via tx fees
In-Reply-To: <201705121922.57445.luke@dashjr.org>
References: <201705121922.57445.luke@dashjr.org>
Message-ID: <cTHMdT2aRie-f8IcK-95pSeLVd1aAuCrpLsN4lmuFITiOgnAb-pK_A9x1lKASZlWIS0VsOSJn3f-IJGCmnY_dBtiRmcr2TcT_uD2gWNdZSw=@protonmail.com>

Good morning Luke,

Considering the proposal as a whole, I think, it's a little imperfect.

The main problem, is that the end goal is activation, but what the opcode rewards is signalling.

Consider a miner who signals only if the number of non-signalling blocks in this retargeting time > 5% of 2016. Such a miner would still effectively block a softfork activation, while still has a chance (albeit reduced) of winning the transaction fees of the block-signalling-opcode, in proportion to the number of miners not signaling for a softfork or using a similar algorithm.

What we should reward should be activation.

How about an opcode which requires this stack (stack top at right)

<signature> <publickeyhash> <versionbit>

1. If the <versionbit> given is in state FAILED, then it checks if the given <signature> matches the given <publickeyhash>.

2. If the <versionbit> given is in state LOCKED_IN or ACTIVE, it checks if the given <signature> matches the block's coinbase transaction signature.

This creates an output which is refundable to the owner, if the softfork fails to activate, but which may be claimed by miners, if the softfork activates.

I don't know enough yet about Bitcoin's codebase to know if the above spec is actually workable.

But basically, I think we should create an assurance contract for activation of a softfork.

--

Also, this invites an inverse logic:

1. If the <versionbit> given is in state LOCKED_IN or ACTIVE, then it checks if the given <signature> matches the given <publickeyhash>.

2. If the <versionbit> given is in state FAILED, it checks if the given <signature> matches the block's coinbase transaction signature.

I think, your proposal allows an economic actor to pay fees if the miner is explicitly not signaling. This is supposed to allow a vote against a particular softfork.

Thus, it should also be possible to allow to vote against a softfork.

But in any case, I think, it's better to pay on activation or failure to activate, rather than mere signalling, as signalling is not the goal. Activation, or rejection of activation, is the goal.

Regards,
ZmnSCPxj
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170514/de6d19a9/attachment.html>

From pieter.wuille at gmail.com  Mon May 15 20:01:14 2017
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Mon, 15 May 2017 13:01:14 -0700
Subject: [bitcoin-dev] Rolling UTXO set hashes
Message-ID: <CAPg+sBgruEiXya6oFy6VpmR1KPDebjeGDtZZU+facZx5=L_a5w@mail.gmail.com>

Hello all,

I would like to discuss a way of computing a UTXO set hash that is
very efficient to update, but does not support any compact proofs of
existence or non-existence.

Much has been written on the topic of various data structures and
derived hashes for the UTXO/TXO set before (including Alan Reiner's
trust-free lite nodes [1], Peter Todd's TXO MMR commitments [2] [3],
or Bram Cohen's TXO bitfield [4]). They all provide interesting extra
functionality or tradeoffs, but require invasive changes to the P2P
protocol or how wallets work, or force nodes to maintain their
database in a normative fashion. Instead, here I focus on an efficient
hash that supports nothing but comparing two UTXO sets. However, it is
not incompatible with any of those other approaches, so we can gain
some of the advantages of a UTXO hash without adopting something that
may be incompatible with future protocol enhancements.

1. Incremental hashing

Computing a hash of the UTXO set is easy when it does not need
efficient updates, and when we can assume a fixed serialization with a
normative ordering for the data in it - just serialize the whole thing
and hash it. As different software or releases may use different
database models for the UTXO set, a solution that is order-independent
would seem preferable.

This brings us to the problem of computing a hash of unordered data.
Several approaches that accomplish this through incremental hashing
were suggested in [5], including XHASH, AdHash, and MuHash. XHASH
consists of first hashing all the set elements independently, and
XORing all those hashes together. This is insecure, as Gaussian
elimination can easily find a subset of random hashes that XOR to a
given value. AdHash/MuHash are similar, except addition/multiplication
modulo a large prime are used instead of XOR. Wagner [6] showed that
attacking XHASH or AdHash is an instance of a generalized birthday
problem (called the k-sum problem in his paper, with unrestricted k),
and gives a O(2^(2*sqrt(n)-1)) algorithm to attack it (for n-bit
hashes). As a result, AdHash with 256-bit hashes only has 31 bits of
security.

Thankfully, [6] also shows that the k-sum problem cannot be
efficiently solved in groups in which the discrete logarithm problem
is hard, as an efficient k-sum solver can be used to compute discrete
logarithms. As a result, MuHash modulo a sufficiently large safe prime
is provably secure under the DL assumption. Common guidelines on
security parameters [7] say that 3072-bit DL has about 128 bits of
security. A final 256-bit hash can be applied to the 3072-bit result
without loss of security to reduce the final size.

An alternative to multiplication modulo a prime is using an elliptic
curve group. Due to the ECDLP assumption, which the security of
Bitcoin signatures already relies on, this also results in security
against k-sum solving. This approach is used in the Elliptic Curve
Multiset Hash (ECMH) in [8]. For this to work, we must "hash onto a
curve point" in a way that results in points without known discrete
logarithm. The paper suggests using (controversial) binary elliptic
curves to make that operation efficient. If we only consider
secp256k1, one approach is just reading potential X coordinates from a
PRNG until one is found that has a corresponding Y coordinate
according to the curve equation. On average, 2 iterations are needed.
A constant time algorithm to hash onto the curve exists as well [9],
but it is only slightly faster and is much more complicated to
implement.

AdHash-like constructions with a sufficiently large intermediate hash
can be made secure against Wagner's algorithm, as suggested in [10].
4160-bit hashes would be needed for 128 bits of security. When
repetition is allowed, [8] gives a stronger attack against AdHash,
suggesting that as much as 400000 bits are needed. While repetition is
not directly an issue for our use case, it would be nice if
verification software would not be required to check for duplicated
entries.

2. Efficient addition and deletion

Interestingly, both ECMH and MuHash not only support adding set
elements in any order but also deleting in any order. As a result, we
can simply maintain a running sum for the UTXO set as a whole, and
add/subtract when creating/spending an output in it. In the case of
MuHash it is slightly more complicated, as computing an inverse is
relatively expensive. This can be solved by representing the running
value as a fraction, and multiplying created elements into the
numerator and spent elements into the denominator. Only when the final
hash is desired, a single modular inverse and multiplication is needed
to combine the two.

As the update operations are also associative, H(a)+H(b)+H(c)+H(d) can
in fact be computed as (H(a)+H(b)) + (H(c)+H(d)). This implies that
all of this is perfectly parallellizable: each thread can process an
arbitrary subset of the update operations, allowing them to be
efficiently combined later.

3. Comparison of approaches

Numbers below are based on preliminary benchmarks on a single thread
of a i7-6820HQ CPU running at 3.4GHz.

(1) (MuHash) Multiplying 3072-bit hashes mod 2^3072 - 1103717 (the
largest 3072-bit safe prime).
    * Needs a fast modular multiplication/inverse implementation.
    * Using SHA512 + ChaCha20 for generating the hashes takes 1.2us per element.
    * Modular multiplication using GMP takes 1.5us per element (2.5us
with a 60-line C+asm implementation).
    * 768 bytes for maintaining a running sum (384 for numerator, 384
for denominator)
    * Very common security assumption. Even if the DL assumption would
be broken (but no k-sum algorithm faster than Wagner's is found), this
still maintains 110 bits of security.

(2) (ECMH) Adding secp256k1 EC points
    * Much more complicated than the previous approaches when
implementing from scratch, but almost no extra complexity when ECDSA
secp256k1 signature validation is already implemented.
    * Using SHA512 + libsecp256k1's point decompression for generating
the points takes 11us per element on average.
    * Addition/subtracting of N points takes 5.25us + 0.25us*N.
    * 64 bytes for a running sum.
    * Identical security assumption as Bitcoin's signatures.

Using the numbers above, we find that:
* Computing the hash from just the UTXO set takes (1) 2m15s (2) 9m20s
* Processing all creations and spends in an average block takes (1)
24ms (2) 100ms
* Processing precomputed per-transaction aggregates in an average
block takes (1) 3ms (2) 0.5ms

Note that while (2) has higher CPU usage than (1) in general, it has
lower latency when using precomputed per-transaction aggregates. Using
such aggregates is also more feasible as they're only 64 bytes rather
than 768. Because of simplicity, (1) has my preference.

Overall, these numbers are sufficiently low (note that they can be
parallellized) that it would be reasonable for full nodes and/or other
software to always maintain one of them, and effectively have a
rolling cryptographical checksum of the UTXO set at all times.

4. Use cases

* Replacement for Bitcoin Core's gettxoutsetinfo RPC's hash
computation. This currently requires minutes of I/O and CPU, as it
serializes and hashes the entire UTXO set. A rolling set hash would
make this instant, making the whole RPC much more usable for sanity
checking.
* Assisting in implementation of fast sync methods with known good
blocks/UTXO sets.
* Database consistency checking: by remembering the UTXO set hash of
the past few blocks (computed on the fly), a consistency check can be
done that recomputes it based on the database.


  [1] https://bitcointalk.org/index.php?topic=88208.0
  [2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012715.html
  [3] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-February/013591.html
  [4] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013928.html
  [5] https://cseweb.ucsd.edu/~mihir/papers/inchash.pdf
  [6] https://people.eecs.berkeley.edu/~daw/papers/genbday.html
  [7] https://www.keylength.com/
  [8] https://arxiv.org/pdf/1601.06502.pdf
  [9] https://www.di.ens.fr/~fouque/pub/latincrypt12.pdf
  [10] http://csrc.nist.gov/groups/ST/hash/sha-3/Aug2014/documents/gligoroski_paper_sha3_2014_workshop.pdf

Cheers,

-- 
Pieter

From peter_r at gmx.com  Mon May 15 20:53:45 2017
From: peter_r at gmx.com (Peter R)
Date: Mon, 15 May 2017 13:53:45 -0700
Subject: [bitcoin-dev] Rolling UTXO set hashes
In-Reply-To: <CAPg+sBgruEiXya6oFy6VpmR1KPDebjeGDtZZU+facZx5=L_a5w@mail.gmail.com>
References: <CAPg+sBgruEiXya6oFy6VpmR1KPDebjeGDtZZU+facZx5=L_a5w@mail.gmail.com>
Message-ID: <553BA161-F60F-4278-914F-0E5F2D2E0A84@gmx.com>

Hi Pieter,

I wanted to say that I thought this write-up was excellent!  And efficiently hashing the UTXO set in this rolling fashion is a very exciting idea!! 

Peter R

> On May 15, 2017, at 1:01 PM, Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Hello all,
> 
> I would like to discuss a way of computing a UTXO set hash that is
> very efficient to update, but does not support any compact proofs of
> existence or non-existence.
> 
> Much has been written on the topic of various data structures and
> derived hashes for the UTXO/TXO set before (including Alan Reiner's
> trust-free lite nodes [1], Peter Todd's TXO MMR commitments [2] [3],
> or Bram Cohen's TXO bitfield [4]). They all provide interesting extra
> functionality or tradeoffs, but require invasive changes to the P2P
> protocol or how wallets work, or force nodes to maintain their
> database in a normative fashion. Instead, here I focus on an efficient
> hash that supports nothing but comparing two UTXO sets. However, it is
> not incompatible with any of those other approaches, so we can gain
> some of the advantages of a UTXO hash without adopting something that
> may be incompatible with future protocol enhancements.
> 
> 1. Incremental hashing
> 
> Computing a hash of the UTXO set is easy when it does not need
> efficient updates, and when we can assume a fixed serialization with a
> normative ordering for the data in it - just serialize the whole thing
> and hash it. As different software or releases may use different
> database models for the UTXO set, a solution that is order-independent
> would seem preferable.
> 
> This brings us to the problem of computing a hash of unordered data.
> Several approaches that accomplish this through incremental hashing
> were suggested in [5], including XHASH, AdHash, and MuHash. XHASH
> consists of first hashing all the set elements independently, and
> XORing all those hashes together. This is insecure, as Gaussian
> elimination can easily find a subset of random hashes that XOR to a
> given value. AdHash/MuHash are similar, except addition/multiplication
> modulo a large prime are used instead of XOR. Wagner [6] showed that
> attacking XHASH or AdHash is an instance of a generalized birthday
> problem (called the k-sum problem in his paper, with unrestricted k),
> and gives a O(2^(2*sqrt(n)-1)) algorithm to attack it (for n-bit
> hashes). As a result, AdHash with 256-bit hashes only has 31 bits of
> security.
> 
> Thankfully, [6] also shows that the k-sum problem cannot be
> efficiently solved in groups in which the discrete logarithm problem
> is hard, as an efficient k-sum solver can be used to compute discrete
> logarithms. As a result, MuHash modulo a sufficiently large safe prime
> is provably secure under the DL assumption. Common guidelines on
> security parameters [7] say that 3072-bit DL has about 128 bits of
> security. A final 256-bit hash can be applied to the 3072-bit result
> without loss of security to reduce the final size.
> 
> An alternative to multiplication modulo a prime is using an elliptic
> curve group. Due to the ECDLP assumption, which the security of
> Bitcoin signatures already relies on, this also results in security
> against k-sum solving. This approach is used in the Elliptic Curve
> Multiset Hash (ECMH) in [8]. For this to work, we must "hash onto a
> curve point" in a way that results in points without known discrete
> logarithm. The paper suggests using (controversial) binary elliptic
> curves to make that operation efficient. If we only consider
> secp256k1, one approach is just reading potential X coordinates from a
> PRNG until one is found that has a corresponding Y coordinate
> according to the curve equation. On average, 2 iterations are needed.
> A constant time algorithm to hash onto the curve exists as well [9],
> but it is only slightly faster and is much more complicated to
> implement.
> 
> AdHash-like constructions with a sufficiently large intermediate hash
> can be made secure against Wagner's algorithm, as suggested in [10].
> 4160-bit hashes would be needed for 128 bits of security. When
> repetition is allowed, [8] gives a stronger attack against AdHash,
> suggesting that as much as 400000 bits are needed. While repetition is
> not directly an issue for our use case, it would be nice if
> verification software would not be required to check for duplicated
> entries.
> 
> 2. Efficient addition and deletion
> 
> Interestingly, both ECMH and MuHash not only support adding set
> elements in any order but also deleting in any order. As a result, we
> can simply maintain a running sum for the UTXO set as a whole, and
> add/subtract when creating/spending an output in it. In the case of
> MuHash it is slightly more complicated, as computing an inverse is
> relatively expensive. This can be solved by representing the running
> value as a fraction, and multiplying created elements into the
> numerator and spent elements into the denominator. Only when the final
> hash is desired, a single modular inverse and multiplication is needed
> to combine the two.
> 
> As the update operations are also associative, H(a)+H(b)+H(c)+H(d) can
> in fact be computed as (H(a)+H(b)) + (H(c)+H(d)). This implies that
> all of this is perfectly parallellizable: each thread can process an
> arbitrary subset of the update operations, allowing them to be
> efficiently combined later.
> 
> 3. Comparison of approaches
> 
> Numbers below are based on preliminary benchmarks on a single thread
> of a i7-6820HQ CPU running at 3.4GHz.
> 
> (1) (MuHash) Multiplying 3072-bit hashes mod 2^3072 - 1103717 (the
> largest 3072-bit safe prime).
>    * Needs a fast modular multiplication/inverse implementation.
>    * Using SHA512 + ChaCha20 for generating the hashes takes 1.2us per element.
>    * Modular multiplication using GMP takes 1.5us per element (2.5us
> with a 60-line C+asm implementation).
>    * 768 bytes for maintaining a running sum (384 for numerator, 384
> for denominator)
>    * Very common security assumption. Even if the DL assumption would
> be broken (but no k-sum algorithm faster than Wagner's is found), this
> still maintains 110 bits of security.
> 
> (2) (ECMH) Adding secp256k1 EC points
>    * Much more complicated than the previous approaches when
> implementing from scratch, but almost no extra complexity when ECDSA
> secp256k1 signature validation is already implemented.
>    * Using SHA512 + libsecp256k1's point decompression for generating
> the points takes 11us per element on average.
>    * Addition/subtracting of N points takes 5.25us + 0.25us*N.
>    * 64 bytes for a running sum.
>    * Identical security assumption as Bitcoin's signatures.
> 
> Using the numbers above, we find that:
> * Computing the hash from just the UTXO set takes (1) 2m15s (2) 9m20s
> * Processing all creations and spends in an average block takes (1)
> 24ms (2) 100ms
> * Processing precomputed per-transaction aggregates in an average
> block takes (1) 3ms (2) 0.5ms
> 
> Note that while (2) has higher CPU usage than (1) in general, it has
> lower latency when using precomputed per-transaction aggregates. Using
> such aggregates is also more feasible as they're only 64 bytes rather
> than 768. Because of simplicity, (1) has my preference.
> 
> Overall, these numbers are sufficiently low (note that they can be
> parallellized) that it would be reasonable for full nodes and/or other
> software to always maintain one of them, and effectively have a
> rolling cryptographical checksum of the UTXO set at all times.
> 
> 4. Use cases
> 
> * Replacement for Bitcoin Core's gettxoutsetinfo RPC's hash
> computation. This currently requires minutes of I/O and CPU, as it
> serializes and hashes the entire UTXO set. A rolling set hash would
> make this instant, making the whole RPC much more usable for sanity
> checking.
> * Assisting in implementation of fast sync methods with known good
> blocks/UTXO sets.
> * Database consistency checking: by remembering the UTXO set hash of
> the past few blocks (computed on the fly), a consistency check can be
> done that recomputes it based on the database.
> 
> 
>  [1] https://bitcointalk.org/index.php?topic=88208.0
>  [2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012715.html
>  [3] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-February/013591.html
>  [4] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013928.html
>  [5] https://cseweb.ucsd.edu/~mihir/papers/inchash.pdf
>  [6] https://people.eecs.berkeley.edu/~daw/papers/genbday.html
>  [7] https://www.keylength.com/
>  [8] https://arxiv.org/pdf/1601.06502.pdf
>  [9] https://www.di.ens.fr/~fouque/pub/latincrypt12.pdf
>  [10] http://csrc.nist.gov/groups/ST/hash/sha-3/Aug2014/documents/gligoroski_paper_sha3_2014_workshop.pdf
> 
> Cheers,
> 
> -- 
> Pieter
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From ZmnSCPxj at protonmail.com  Mon May 15 23:04:01 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 15 May 2017 19:04:01 -0400
Subject: [bitcoin-dev] Rolling UTXO set hashes
In-Reply-To: <CAPg+sBgruEiXya6oFy6VpmR1KPDebjeGDtZZU+facZx5=L_a5w@mail.gmail.com>
References: <CAPg+sBgruEiXya6oFy6VpmR1KPDebjeGDtZZU+facZx5=L_a5w@mail.gmail.com>
Message-ID: <CT3GNfkLsQJyM0EmWXc3HBmnW1h2iptP0SohZnXZfZPffoVmcofD8fs_E3kV5PuFL0pQSQwwk_FyR-8-wdANf15NE8UElNWqcEcc5Ql3n8M=@protonmail.com>

Good morning Pieter,

>4. Use cases
>
>* Replacement for Bitcoin Core's gettxoutsetinfo RPC's hash
>computation. This currently requires minutes of I/O and CPU, as it
>serializes and hashes the entire UTXO set. A rolling set hash would
>make this instant, making the whole RPC much more usable for sanity
>checking.
>* Assisting in implementation of fast sync methods with known good
>blocks/UTXO sets.
>* Database consistency checking: by remembering the UTXO set hash of
>the past few blocks (computed on the fly), a consistency check can be
>done that recomputes it based on the database.

Another use case I can think of is a potential "chain-flip" hard fork of block header formats, where the UTXO hash rather than merkle tree root of transactions is in the header, which would let lite nodes download a UTXO set from any full node and verify it by verifying only block headers starting from genesis.

Regards,
ZmnSCPxj
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170515/7e39b541/attachment.html>

From greg at xiph.org  Mon May 15 23:30:59 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Mon, 15 May 2017 23:30:59 +0000
Subject: [bitcoin-dev] Validationless mining without transactions
Message-ID: <CAAS2fgSfx-sr8hQt_atFw0Qmu_cQFCAc2XCapoNsUuZrPU3O5Q@mail.gmail.com>

Today someone showed up on IRC suggesting a scheme for to improve the
ability of miners to mine without validation while including transactions
by shipping around an approximate sketch of the txins that were used by a
block.

I pointed out that what sounded like the exact same scheme had been
previously proposed by Anthony Towns over a year ago,  that it turned out
that it didn't need any consensus changes, but also wasn't very attractive
because the actual transmission of the block (at least with FBRP or Fibre)
didn't really take any longer...  And, of course, mining without validating
does a real number on SPV security assumptions.

But then realized the the conversation between Anthony and I was offlist.
So-- for posterity...

I think the most interesting thing about this thread is that it gives a
concrete proof that a restriction on collecting transaction fees does not
discourage validationless mining; nor to other proposed consensus changes
make it any easier to include transactions while mining without validation.


Forwarded conversation
Subject: Blockchain verification flag (BIP draft)
------------------------

From: Anthony Towns <aj at erisian.com.au>
Date: Mon, Feb 29, 2016 at 2:13 AM
To: Gregory Maxwell <greg at xiph.org>


On Fri, Dec 04, 2015 at 08:26:22AM +0000, Gregory Maxwell via bitcoin-dev
wrote:
> A significant fraction of hashrate currently mines blocks without
> verifying them for a span of time after a new block shows up on the
> network for economically rational reasons.

Two thoughts related to this. Are they obvious or daft?

a)

Would it make sense to require some demonstration that you've validated
prior blocks? eg, you could demonstrate you've done part of the work
to at least verify signatures from the previous block by including the
sha256 of the concatenation of all the sighash values in the coinbase
transaction -- if you'd already done the sig checking, calculating that
as you went would be pretty cheap, I think. Then make the rule be that
if you set the "validated" bit without including the demonstration of
validation, your block is invalid.

I guess this is more or less what Peter Todd proposed in:

https://lists.linuxfoundation.org/pipermail/bitcoin-dev/
2015-December/012105.html

b)

It occurred to me while emailing with Matt Corallo, that it's probably
possible to make it easy to generate actually useful blocks while doing
validationless mining, rather than only creating empty blocks.

When creating a block, you:

   - calculate a fixed size (7168 bytes?) bloom filter of the
     prevouts that the block is spending
   - include the sha256 of the final bloom filter as the last output
     in the coinbase
   - enforce the inclusion of that sha256 by soft-fork
   - as part of fast relaying, transmit:
       - 80 byte block header
       - 7168 byte bloom filter
       - < 416 (?) byte merkle path to the coinbase
       - 64 byte sha256 midstate for coinbase up to start of the
         final transaction
       - < 128 byte tail of coinbase including bloom commitment
     (total of 7856 bytes, so less than 8kB)

I think that would be enough to verify that the proof-of-work is
committing to the bloom filter, and the bloom filter will then let
you throw out any transactions that could have been included in a block
built on block n-1, but can't be included in block n+1 -- whether they're
included in the new block, or would be double spends. So given that
information you can safely build a new block that's actually full of
transactions on top of the new block, even prior to downloading it in
full, let alone validating it.

I've run that algorithm over the last couple of weeks' worth of
transactions (to see how many of the next block's transaction would have
been thrown away using that approach) and it appeared to work fine --
it throws away maybe a dozen transactions per block compared to accurate
validation, but that's only about a couple of kB out of a 1MB block,
so something like 0.2%.  (I'm seeing ~4500 prevouts per block roughly,
so that's the error rate you'd expect; doubling for 2MB's worth of txes
with segwit predicts 3.5%, doubling again would presumably result in 14%
of transactions being falsely identified as double spends prior to the
block actually validating)

I haven't checked the math in detail, but I think that could reasonably
give an immediate 20% increase in effective blocksize, given the number of
empty blocks that get mined... (There were only ~1571MB of transactions
in the last 2016 blocks, so bumping the average from 780kB per block to
940kB would be a 20% increase; which would bring the 1.7x segwit increase
up to 2x too...)

Also, as far as I can see, you could probably even just have bitcoin core
transmit that 8kB of data around as part of propogating headers first.
Once you've got the new header and bloom filter, the only extra bit
should be passing both those into getblocktemplate to update the
previousblockhash and transaction selection. Both those together and it
seems like you could be mining on top of the latest block seconds after
it was found, just by naively running a bitcoin node?

I saw the "Bitcoin Classic" roadmap includes:

  "Implement "headers-first" mining. As soon as a valid 80-byte block
   header that extends the most-work chain is received, relay the header
   (via a new p2p network message) and allow mining an empty block on top
   of it, for up to 20 seconds."

which seems like the same idea done worse...

Any thoughts? Pointers to the bitcointalk thread where this was proposed
two years ago? :)

Cheers,
aj


----------
From: Gregory Maxwell <gmaxwell at gmail.com>
Date: Mon, Feb 29, 2016 at 3:20 AM
To: Anthony Towns <aj at erisian.com.au>


On Mon, Feb 29, 2016 at 2:13 AM, Anthony Towns <aj at erisian.com.au> wrote:
> Would it make sense to require some demonstration that you've validated
> prior blocks? eg, you could demonstrate you've done part of the work

That information is easily shared/delegated... so it just creates
another centralized information source, and another source of
unfairness producing latency in the mining process. Without actually
preventing parties from mining. Doubly so in the context of how
validationless mining is actually done; the miners pull from other
miner's stratum servers; so they'll just see the commitments there.

So I don't see there being too much value there.

> if you set the "validated" bit without including the demonstration of
> validation, your block is invalid.

Pretty good incentive to not adopt the scheme, perhaps?

Moreover, this creates another way for a block to be invalid which has
no compact fraud proof. :(

> It occurred to me while emailing with Matt Corallo, that it's probably
> possible to make it easy to generate actually useful blocks while doing
> validationless mining, rather than only creating empty blocks.

I agree but:

I'm basically tired of repeating to people that there is no need for a
validationless block to be empty. So Yes, I agree with you on that
fact; it's possible for miners to do this already, with no protocol
changes (yes, it requires trusting each other but inherently
validationless mining already requires that). Miners only don't bother
right now because the funds left behind are insubstantial.

Its absolutely untrue that an empty block is not useful. Every block,
empty or not, mined against the best tip you know contributes to the
resolution of consensus and collapsing the network onto a single
state. Every block that was mined only after validating a block
amplifies security; by helping leave behind an invalid chain faster. A
block doesn't need to contain transactions to do these things.

>        - 7168 byte bloom filter

FWIW, thats significantly larger than the amount of data typically
needed to send the whole block using the fast block relay protocol.

Your estimates are assuming the empty blocks come purely from
transmission and verification, but because most verification is cached
and transmission compressed-- they don't. There are numerous latency
sources through the whole stack, some constant some
size-proportional... the mining without validation achieves its gains
not from skipping validation (at least not most of the time); but
mostly from short cutting a deep stack with many latency sources;
including ones that have nothing to do with bitcoin core or the
Bitcoin protocol.

High hardware latency also amplifies short periods of empty block
mining to longer periods.

Perhaps most importantly, VFM mining avoids needing to identify and
characterize these other delay sources, by short cutting right at the
end no one needs to even figure out that their pool server is
performing a DNS request before every time it contacts their bitcoind
RPC or whatnot.

>   "Implement "headers-first" mining. As soon as a valid 80-byte block

This BIP draft resulted in me relieving some pretty vicious attacks
from that community... funny.

> Any thoughts? Pointers to the bitcointalk thread where this was proposed
> two years ago? :)

Relevant to your interests: https://github.com/bitcoin/bitcoin/pull/1586

Lots of discussion on IRC.

----------
From: Anthony Towns <aj at erisian.com.au>
Date: Wed, Mar 2, 2016 at 9:55 PM
To: Gregory Maxwell <gmaxwell at gmail.com>


On Mon, Feb 29, 2016 at 03:20:01AM +0000, Gregory Maxwell wrote:
> On Mon, Feb 29, 2016 at 2:13 AM, Anthony Towns <aj at erisian.com.au> wrote:
> > Would it make sense to require some demonstration that you've validated
> > prior blocks? eg, you could demonstrate you've done part of the work
> That information is easily shared/delegated...

Yeah, I thought about that. It's a tradeoff -- you definitely want the
validation to be easily "shared" in the sense that you want one validation
run to suffice for billions of mining attempts; and you probably want
it to be easy to compute when you receive a block, so you don't have
to revalidate the previous one to validate the new one... But you don't
want it to be so easily shared that one person on the planet calculates
it and everyone else just leeches from them.

> so it just creates
> another centralized information source, and another source of
> unfairness producing latency in the mining process. Without actually
> preventing parties from mining. Doubly so in the context of how
> validationless mining is actually done; the miners pull from other
> miner's stratum servers; so they'll just see the commitments there.

I think you could make it hostile to accidental sharing by having it be:

  <n> ;
  sha256(
      sha256( current block's first <n>+1 coinbase outputs ;
               previous block's nonce )
      sha256( previous block's sighash values )
  )

If you skipped the internal sha256's (or just moved the nonce into the
final sha256), you'd be half-way forced to revalidate the previous block
every time you found a new block, which might be worthwhile.

> > if you set the "validated" bit without including the demonstration of
> > validation, your block is invalid.
> Pretty good incentive to not adopt the scheme, perhaps?

Well, my theory was once you have validated the block, then the
demonstration is trivially easy to provide.

I was thinking that you could add a positive incentive by making validated
blocks count for something like 1.6x the chainwork for choosing which
chain to build on; so if you have a chain with 3 unvalidated blocks in
a row, then a chain with 2 validated blocks in a row instead would be
preferred for building your next block.

> Moreover, this creates another way for a block to be invalid which has
> no compact fraud proof. :(

Hmmm. That's true. Is it true by definition though? If you're proving
you've validated 100% of a block, then is it even conceptually possible
to check that proof with less work than validating 100% of a block?
Sounds kind of SNARK-ish.

Oh, don't SNARKs (theoretically) give you a compact fraud proof, provided
the block size and sigops are bounded? The "secret" input is the block
data, public input is the block hash and the supposed validation proof
hash, program returns true if the block hash matches the block data,
and the calculated validation hash doesn't match the supposed validation
hash. Shudder to think how long generating the proof would take though,
or how hard it'd be to generate the circuit in the first place...

> > It occurred to me while emailing with Matt Corallo, that it's probably
> > possible to make it easy to generate actually useful blocks while doing
> > validationless mining, rather than only creating empty blocks.
> I agree but:
> I'm basically tired of repeating to people that there is no need for a
> validationless block to be empty. So Yes, I agree with you on that
> fact; it's possible for miners to do this already, with no protocol
> changes (yes, it requires trusting each other but inherently
> validationless mining already requires that).

If you're only mining an empty block, the only way someone else can
cause you to waste your time is by wasting their own time doing PoW on
an invalid block. If you're mining a block with transactions in it, and
they can mine a valid block, but trick you into mining something that
double spends, then they can make you waste your time without wasting
their own, which seems like a much worse attack to me.

The advantage of the consensus enforced bloom filter is you don't have
to trust anything more than that economic incentive. However if you just
sent an unverifiable bloom filter, it'd be trivial to trick you into
mining an invalid block.

(If you already have the 1MB of block data, then extracting the prevouts
for use as a blacklist would probably be plenty fast though)

(Of course, maybe 90% of current hashpower does trust each other
anyway, in which case requiring trust isn't a burden, but that's not
very decentralised...)

(Paragraphs deleted. My maths is probably wrong, but I think it is
actually economically rational to mine invalid blocks as chaff to distract
validationless miners? The numbers I get are something like "if 40% of
the network is doing validationless mining for 20 seconds out of every
10 minutes, then it's profitable to devote about 2% of your hashpower to
mining invalid blocks". Probably some pretty dodgy assumptions though,
so I'm not including any algebra. But having actual invalid blocks with
real proof of work appear in the wild seems like it'd be a good way to
encourage miners to do validation...)

> Miners only don't bother
> right now because the funds left behind are insubstantial.

Hey, fees are almost 1% of the block payout these days -- that's within
an order of magnitude of a rounding error!

> Its absolutely untrue that an empty block is not useful.

Yeah, I deleted "useless" for that reason then put it back in anyway...

> >        - 7168 byte bloom filter
> FWIW, thats significantly larger than the amount of data typically
> needed to send the whole block using the fast block relay protocol.

Really? Hmm, if you have 2-byte indexes into the most likely to be mined
60k transactions, by 2000 transactions per block is about 4000 bytes. So
I guess that makes sense. And weak blocks would make that generalisable
and only add maybe a 32B index to include on the wire, presumably.

It'd only take a dozen missed transactions to be longer though.

> Your estimates are assuming the empty blocks come purely from
> transmission and verification, but because most verification is cached
> and transmission compressed-- they don't. There are numerous latency
> sources through the whole stack, some constant some
> size-proportional... the mining without validation achieves its gains
> not from skipping validation (at least not most of the time); but
> mostly from short cutting a deep stack with many latency sources;
> including ones that have nothing to do with bitcoin core or the
> Bitcoin protocol.

Hmm, so my assumption is the "bitcoin core" side of the stack looks
something like:

   block header received by p2p or relay network
     |
     V
   block data received by p2p or relay network
     |
     V
   validation, UTXO set updates
     |
     V
   getblocktemplate (possible tx ordering recalculation)
     |
     V
   block header to do PoW on!
     |
     V
   vary and push to miners over the network
     |
     V
   push to ASICs

and the validationless "shortcut" just looks like:

   block header received by p2p or relay network
     |
     V
   hack hack
     |
     V
   new block header to do PoW on!
     |
     V
   vary and push to miners over the network
     |
     V
   push to ASICs

and so making the bitcoin core parts able to provide an unvalidated
header to push to miners/ASICs against "instantly" would be a win as
far as getting bitcoin proper back into the loop all the time... That
would mean removing validation from the critical path, and possibly more
optimisation of getblocktemplate to make it effectively instant too. But
those seem possible?

Having it be:

  header received by bitcoin core
    |
    V
  new block header to do (unverified) PoW on!
    |
    V
  ...

and

  header received by bitcoin core
    |
    V
  block data received by bitcoin core
    |
    V
  block data validated
    |
    V
  new block header to do (verified) PoW on!
    |
    V
  ...

with mining tools being able to just reliably and efficiently leave
bitcoin core in the loop seems like it ought to be a win to me...

> Perhaps most importantly, VFM mining avoids needing to identify and
> characterize these other delay sources, by short cutting right at the
> end no one needs to even figure out that their pool server is
> performing a DNS request before every time it contacts their bitcoind
> RPC or whatnot.

At least with longpoll, doing a DNS query before connection shouldn't
matter?

> >   "Implement "headers-first" mining. As soon as a valid 80-byte block
> This BIP draft resulted in me relieving some pretty vicious attacks
> from that community... funny.

I'm guessing you meant "receiving", which makes that a kinda weird
freudian slip? :) But yeah, technical consistency isn't something I've
seen much of from that area...

> > Any thoughts? Pointers to the bitcointalk thread where this was proposed
> > two years ago? :)
> Relevant to your interests: https://github.com/bitcoin/bitcoin/pull/1586

Tsk, 2 != 4...

Hmm, I'm not sure where this leaves my opinion on either of those ideas.

Cheers,
aj


----------
From: Anthony Towns <aj at erisian.com.au>
Date: Sun, Mar 13, 2016 at 3:58 AM
To: Gregory Maxwell <gmaxwell at gmail.com>


On Thu, Mar 03, 2016 at 07:55:06AM +1000, Anthony Towns wrote:
> > >        - 7168 byte bloom filter
> > FWIW, thats significantly larger than the amount of data typically
> > needed to send the whole block using the fast block relay protocol.
> Really? Hmm, if you have 2-byte indexes into the most likely to be mined
> 60k transactions, by 2000 transactions per block is about 4000 bytes. So
> I guess that makes sense. And weak blocks would make that generalisable
> and only add maybe a 32B index to include on the wire, presumably.
> It'd only take a dozen missed transactions to be longer though.

So I think there's two levels of withholding adversarial miners could
do:

 - block withholding, so they have more time to build on top of their
   own block, maybe increasing their effective hashrate if they have
   above average connectivity

 - transaction withholding, so an entire block can be invalidated
   after the fact, hitting SPV nodes. if there are SPV miners, this can
   invalidate their work (potentially profitably, if you've accidently
   orphaned yourself)

You could solve transaction withholding for miners just by saying
"a PoW isn't valid unless the merkle tree is valid", that way you
can't retroactively invalidate a block, but then you need fast relay
before starting to mine, not just the header and some hint as to what
transactions might be included, and therefore the bloom filter idea
is pointless...


Having actually tried the relay network now, it seems like:

 a) it gets less coding gain than it theoretically could; the day or
    so's worth of blocks from Lightsword only seemed to be ~8x less data,
    rather than ~125x-250x, and what I'm seeing seems similar. So still
    room for improvement?

 b) using "weak blocks" as a way of paying for adding "non-standard"
    transactions (large, low fee, actually non-standard, etc) to the
    mempool seems workable to me; so long as the only reason you're doing
    weak blocks is so miners can ensure the transactions they're mining
    are in mempools, and thus that their blocks will relay quickly, the
    incentives seem properly aligned. (I think you'd want to distinguish
    txns only relayed because they have a weak block, just to be nice to
    SPV clients -- weak block txns might only be mined by one miner, while
    standard, fee paying transactions are being mined by all/most miners)

 c) it seems like it would be possible to adapt the relay protocol into
    a p2p environment to me? I'm thinking that you provide a bidirectional
    mapping for (a subset of) your mempool for each connection you
    have, so that you can quickly go to/from a 2-byte index to a
    transaction. If you make it so that whoever was listening gets to
    decide what transactions are okay, then you'd just need 9 of these
    maps -- 1 for each of your outgoing connections (ie, 8 total), plus
    another 1 that covers all your incoming connections, and each map
    should only really need to use up to about a meg of memory, which
    seems pretty feasible.  Maybe it means up to 8x5MB of your mempool
    is controlled by other people's policies rather than your own,
    but that doesn't seem to bad either.

 d) I'm a bit confused how it compares to IBLT; it seems like IBLT has
    really strong ordering requirements to work correctly, but if you
    had that you could compress the fast relay protocol really well,
    since you could apply the same ordering to your shared mempool, and
    then just send "next tx, next tx, skip 1 tx, next tx, next tx, skip
    3 tx, next tx, here's one you missed, ...", which with compression
    would probably get you to just a few /bits/ per (previously seen)
    transaction...  [0] [1]

 e) for p2p relay, maybe it would make sense to have the protocol only
    allow sending blocks where all the transactions are "previously
    seen". that way if you get a block where some txes haven't been
    seen before, you stall that block, and start sending transactions
    through. if another block comes in in the meantime, that doesn't
    have any new transactions, you send that block through straight away.
    that encourages sending weak blocks through first, to ensure your
    transactions are already in mempools and no one else can sneak
    in first.

Hmm... So that all seems kind of plausible to me; in how many ways am I
mistaken? :)

Cheers,
aj

[0] A hard-fork change to have the block merkle tree be ordered by txid,
    and have the transactions topologically sorted before being validated
    would be kind-of interesting here -- apart from making sorting
    obvious, it'd make it easy to prove that a block doesn't contain a
    transaction. Bit altcoin-y though...

[1] Maybe having the shared mempool indexes be sorted rather than FIFO
    would make the data structures hard; I don't think so, but not sure.


----------
From: Gregory Maxwell <gmaxwell at gmail.com>
Date: Sun, Mar 13, 2016 at 5:06 AM
To: Anthony Towns <aj at erisian.com.au>


On Sun, Mar 13, 2016 at 3:58 AM, Anthony Towns <aj at erisian.com.au> wrote:
> On Thu, Mar 03, 2016 at 07:55:06AM +1000, Anthony Towns wrote:
>> > >        - 7168 byte bloom filter
>> > FWIW, thats significantly larger than the amount of data typically
>> > needed to send the whole block using the fast block relay protocol.
>> Really? Hmm, if you have 2-byte indexes into the most likely to be mined
>> 60k transactions, by 2000 transactions per block is about 4000 bytes. So
>> I guess that makes sense. And weak blocks would make that generalisable
>> and only add maybe a 32B index to include on the wire, presumably.
>> It'd only take a dozen missed transactions to be longer though.
>
> So I think there's two levels of withholding adversarial miners could
> do:
>
>  - block withholding, so they have more time to build on top of their
>    own block, maybe increasing their effective hashrate if they have
>    above average connectivity

Also called "selfish mining".

>  - transaction withholding, so an entire block can be invalidated
>    after the fact, hitting SPV nodes. if there are SPV miners, this can
>    invalidate their work (potentially profitably, if you've accidently
>    orphaned yourself)
> You could solve transaction withholding for miners just by saying
> "a PoW isn't valid unless the merkle tree is valid", that way you
> can't retroactively invalidate a block, but then you need fast relay
> before starting to mine, not just the header and some hint as to what
> transactions might be included, and therefore the bloom filter idea
> is pointless...

Right, this is how Bitcoin Core works (won't extend a chain it hasn't
validated)-- but some miners have shortcutted it to reduce latency.
(And not just bypassing validation, but the whole process, e.g.
transaction selection; which historically has taken more time than
propagation).

> Having actually tried the relay network now, it seems like:
>
>  a) it gets less coding gain than it theoretically could; the day or
>     so's worth of blocks from Lightsword only seemed to be ~8x less data,
>     rather than ~125x-250x, and what I'm seeing seems similar. So still
>     room for improvement?

It's pretty variable.  It depends a lot on consistency between the
transactions the server side selects and the client. When spam attacks
go on, or miners change their policy compression falls off until the
far end twiddles.

Go look at the distribution of the results.

>  c) it seems like it would be possible to adapt the relay protocol into
>     a p2p environment to me? I'm thinking that you provide a bidirectional
>     mapping for (a subset of) your mempool for each connection you
>     have, so that you can quickly go to/from a 2-byte index to a
>     transaction. If you make it so that whoever was listening gets to
>     decide what transactions are okay, then you'd just need 9 of these
>     maps -- 1 for each of your outgoing connections (ie, 8 total), plus
>     another 1 that covers all your incoming connections, and each map
>     should only really need to use up to about a meg of memory, which
>     seems pretty feasible.  Maybe it means up to 8x5MB of your mempool
>     is controlled by other people's policies rather than your own,
>     but that doesn't seem to bad either.

That is a bit kludgy, but yes-- it would work.

But the key thing about latency minimization is that you _must_ send a
block with no request; because otherwise the RTT for just the request
alone will totally dominate the transfer in most cases.  And having N
peers send you the whole block redundantly ends up hurting your
performance (esp because packet losses mean more round trips) even if
the compression is very high.

All these problems can be avoided; at least in theory. Optimal latency
mitigation would be achieved by something like block network coding
techniques:

https://en.bitcoin.it/wiki/User:Gmaxwell/block_network_coding

With these techniques peers could blindly send you data without you
requesting it, while every byte they send would usefully contribute to
your reconstruction. With extra effort and opportunistic forwarding
the entire network could, in theory, receive a block in the time it
took the original host to send only one block, while making use of a
significant fraction of the network's whole bisection bandwidth.

>  d) I'm a bit confused how it compares to IBLT; it seems like IBLT has
>     really strong ordering requirements to work correctly, but if you
>     had that you could compress the fast relay protocol really well,
>     since you could apply the same ordering to your shared mempool, and
>     then just send "next tx, next tx, skip 1 tx, next tx, next tx, skip
>     3 tx, next tx, here's one you missed, ...", which with compression
>     would probably get you to just a few /bits/ per (previously seen)
>     transaction...  [0] [1]

Latency of block relay easily ends up CPU bound; even when not doing
anything too smart (this is why Matt's relay protocol stuff has AVX
sha2 code in it). Prior IBLT implementation attempts have performance
so low that their decode time ends up dwarfing transmission time, and
plain uncoded blocks are faster for common host/bandwidth
configurations.

The ordering requirements stuff is not that relevant in my view; you
likely believe this because Gavin rat-holed himself on it trying to
spec out ordering requirements for miners...  The reality of it is
that a uniform permutation of, say, 4000 transactions can be stored in
log2(4000!)/8 bytes, or about 5.2kbytes (and this is easily achieved
just by using range coding to optimally pack integers in the range
[0..n_unpicked_txn) to pick transactions out of a lexagraphically
sorted list) ... and this is without any prediction at all-- randomly
ordered txn in the block would work just as well.

[E.g. using the uint coder from the daala video codec project can code
these values with about 1% overhead, and runs at about 12MB/sec doing
so on my slow laptop]

Recently some folks have been working privately on a block network
coding implementation... earlier attempts (even before IBLT became
trendy) were thwarted by the same thing that thwarts IBLT: the
decoding was so slow it dominated the latency. We've found some faster
coding schemes though... so it looks like it might be practical now. I
could send you more info if you read the block network coding page and
are interested in helping.

Both IBLT and BNC would both be more useful in the weakblocks model
because there the decode speed isn't latency critical-- so if it needs
100ms of cpu time to decode an efficiently encoded block, that is no
big deal.

>  e) for p2p relay, maybe it would make sense to have the protocol only
>     allow sending blocks where all the transactions are "previously
>     seen". that way if you get a block where some txes haven't been
>     seen before, you stall that block, and start sending transactions
>     through. if another block comes in in the meantime, that doesn't
>     have any new transactions, you send that block through straight away.
>     that encourages sending weak blocks through first, to ensure your
>     transactions are already in mempools and no one else can sneak
>     in first.

Yes, it's perfectly reasonable to do that for bandwidth minimization--
though it doesn't minimize latency.  "Seen" is complex, you have no
guarantee a peer will accept any transaction you've sent it, or even
that it will retain any it sent you. So multiple round trips are
required to resolve missing transactions.

We haven't bothered implementing this historically because the
bandwidth reduction is small overall, and it's not the right strategy
for reducing latency-- the vast majority of bandwidth is eaten by
relay. Right now maybe 15% is used by blocks... so at most you'd get a
15% improvement here.

I did some fairly informal measurements and posted about it:
https://bitcointalk.org/index.php?topic=1377345.0

I also point out there that the existing blocksonly mode achieves
bandwidth optimal transport already (ignoring things like transaction
format compression)... just so long as you don't care about learning
about unconfirmed transactions. :)

> [0] A hard-fork change to have the block merkle tree be ordered by txid,
>     and have the transactions topologically sorted before being validated
>     would be kind-of interesting here -- apart from making sorting
>     obvious, it'd make it easy to prove that a block doesn't contain a
>     transaction. Bit altcoin-y though...

If you sort by data (or ID) without requiring the verifier to
topologically sort then an efficient permutation coder would only
spend bits on places where dependencies push things out of the
expected order... which is fairly rare.

Seems like a reasonable cost for avoiding the hardfork, no? The
receiver topo sort requirement would also require more memory in a
block verifier; and would be more complex to fraud proof, I think.

Engineering wise it's not quite so simple. It's helpful for miners to
have blocks sorted by feerate so that later stages of the mining
process can drop the least profitable transactions simply by
truncating the block.

> [1] Maybe having the shared mempool indexes be sorted rather than FIFO
>     would make the data structures hard; I don't think so, but not sure.

I tried to get Matt to do that for his stuff previously; pointing out
the sorted indexes would be easier to efficiently code. His
counterargument was that for 2000 txn, the two bytes indexes take 4kb,
which is pretty insignificant... and that his time would be better
spent trying to get the hit-rate up. I found that hard to argue with.
:)

----------
From: Anthony Towns <aj at erisian.com.au>
Date: Mon, Mar 14, 2016 at 3:08 AM
To: Gregory Maxwell <gmaxwell at gmail.com>


On Sun, Mar 13, 2016 at 05:06:25AM +0000, Gregory Maxwell wrote:
> >  - block withholding, so they have more time to build on top of their
> >    own block, maybe increasing their effective hashrate if they have
> >    above average connectivity
> Also called "selfish mining".

Yup.

> >  c) it seems like it would be possible to adapt the relay protocol into
> >     a p2p environment to me? [...]
> That is a bit kludgy, but yes-- it would work.
> But the key thing about latency minimization is that you _must_ send a
> block with no request; because otherwise the RTT for just the request
> alone will totally dominate the transfer in most cases.  And having N
> peers send you the whole block redundantly ends up hurting your
> performance (esp because packet losses mean more round trips) even if
> the compression is very high.

If the block can be encoded fully, then it's up to maybe 10kB per block
max (at 1MB blocksize); I don't think multiple transmissions matter much
in that case? Hmm, maybe it does...

> All these problems can be avoided; at least in theory. Optimal latency
> mitigation would be achieved by something like block network coding
> techniques:
> https://en.bitcoin.it/wiki/User:Gmaxwell/block_network_coding

Ugh, patents. Interesting that the patents on turbo codes have expired,
last time I looked they hadn't.

> With these techniques peers could blindly send you data without you
> requesting it, while every byte they send would usefully contribute to
> your reconstruction.

Yeah, that makes sense I think. Pretty complicated though. The "someone
sent corrupt data" seems a little bit problematic to deal with too,
especially in the "optimistically forward stuff before you can validate
it" phase. At least if you're using error correcting codes anyway,
that's probably a self-solving problem.

What's with the switch from 32 bit faux ids in the original section
to 63 bits in the reimagination? I guess you use most of that for the
additional encoded length though...

Keying with the previous block's hash seems kind-of painful, doesn't it?
Once you receive the ids, you want to lookup the actual transactions
from your mempool, but since you can't decrypt anything useful with
only the first 50/60 bits of cyphertext, the only way to do that is
to have already cycled through all the transactions in your mempool
and pre-calculated what their network coded id for that block is, and
you have to do that everytime you receive a block (including orphans,
I guess). It'd make reorgs more expensive too, because you'd have to
reindex all the mempool then as well?

Maybe if you're only doing that predictively it's not so bad? The 5MB-20MB
of txes with highest fees get coded up, and you just download any other
transactions in full? If you're downloading large coinbase txes regularly
anyway, that's probably no big deal.

> Latency of block relay easily ends up CPU bound; even when not doing
> anything too smart (this is why Matt's relay protocol stuff has AVX
> sha2 code in it).

Yeah, that seemed a little odd to me; there shouldn't be that much
hashing to validate a block (1MB of transactions, then maybe 128kB to
get to sha256d, then another 2*128kB for the rest of the merkle tree?).
Matt's code seems like it's doing a linear search through the tx index
to find each tx though, which probably doesn't help.

> Prior IBLT implementation attempts have performance
> so low that their decode time ends up dwarfing transmission time, and
> plain uncoded blocks are faster for common host/bandwidth
> configurations.

Heh.

> The ordering requirements stuff is not that relevant in my view; you
> likely believe this because Gavin rat-holed himself on it trying to
> spec out ordering requirements for miners...  The reality of it is
> that a uniform permutation of, say, 4000 transactions can be stored in
> log2(4000!)/8 bytes, or about 5.2kbytes

Right, but 5.2 kB is a lot of overhead; at least compared to the cases
where Matt's stuff already works well :)

> Recently some folks have been working privately on a block network
> coding implementation... earlier attempts (even before IBLT became
> trendy) were thwarted by the same thing that thwarts IBLT: the
> decoding was so slow it dominated the latency. We've found some faster
> coding schemes though...  so it looks like it might be practical now. I
> could send you more info if you read the block network coding page and
> are interested in helping.

Sure. (Though, fair warning, I've already failed a few times at doing
anything useful with erasure coding...)

> >  e) for p2p relay, maybe it would make sense to have the protocol only
> >     allow sending blocks where all the transactions are "previously
> >     seen". that way if you get a block where some txes haven't been
> >     seen before, you stall that block, and start sending transactions
> >     through. if another block comes in in the meantime, that doesn't
> >     have any new transactions, you send that block through straight
away.
> >     that encourages sending weak blocks through first, to ensure your
> >     transactions are already in mempools and no one else can sneak
> >     in first.
> Yes, it's perfectly reasonable to do that for bandwidth minimization--
> though it doesn't minimize latency.  "Seen" is complex, you have no
> guarantee a peer will accept any transaction you've sent it, or even
> that it will retain any it sent you. So multiple round trips are
> required to resolve missing transactions.

The "p2p relay" in my head has "seen" meaning "the 5MB of transactions
the listening peer thinks is most likely to be mined", odds on both
peers have actually seen something like 145MB of additional transactions
too. You don't do round trips; you just start sending the "unseen"
transactions automatically (by id or in full?), then you send the
compressed block. The only round trip is if you sent the id, but they
actually needed the full tx.

In my head, you get good latency if you do weak blocks beforehand,
and somewhat poorer latency if you don't. Even in my head, I'm not sure
that's actually feasible, though: I'm not sure weak blocks for coinbase
transactions really work, and comparatively high latency on 5% of blocks
that didn't get any weak blocks beforehand isn't very attractive...

> We haven't bothered implementing this historically because the
> bandwidth reduction is small overall, and it's not the right strategy
> for reducing latency-- the vast majority of bandwidth is eaten by
> relay. Right now maybe 15% is used by blocks... so at most you'd get a
> 15% improvement here.

Yeah, I'm assuming a non-trivial increase in bandwidth usage compared
to current relay. Compared to relaying spam transactions (that don't
get mined prior to expiry), not sure it's significant though.

> > [0] A hard-fork change to have the block merkle tree be ordered by txid,
> >     and have the transactions topologically sorted before being
validated
> >     would be kind-of interesting here -- apart from making sorting
> >     obvious, it'd make it easy to prove that a block doesn't contain a
> >     transaction. Bit altcoin-y though...
> If you sort by data (or ID) without requiring the verifier to
> topologically sort then an efficient permutation coder would only
> spend bits on places where dependencies push things out of the
> expected order... which is fairly rare.

Really? I was seeing a lot of transaction chains in the couple of blocks I
looked at. Also, you wouldn't get short proofs that a transaction isn't
present in a block that way either afaics.

> Seems like a reasonable cost for avoiding the hardfork, no? The
> receiver topo sort requirement would also require more memory in a
> block verifier; and would be more complex to fraud proof, I think.

Hmm, I think it'd be easy to fraud proof -- just show adjacent merkle
paths where the results are in the wrong order. Maybe the same's true
with the id-order-but-toposorted too -- just show adjacent merkle paths
where the results are in the wrong order, and the later doesn't depend
on the former. I'm not sure that gives a unique sort though (but maybe
that doesn't actually matter).

> Engineering wise it's not quite so simple. It's helpful for miners to
> have blocks sorted by feerate so that later stages of the mining
> process can drop the least profitable transactions simply by
> truncating the block.

Yeah; not having ordering requirements seems far more practical.

> > [1] Maybe having the shared mempool indexes be sorted rather than FIFO
> >     would make the data structures hard; I don't think so, but not sure.
> I tried to get Matt to do that for his stuff previously; pointing out
> the sorted indexes would be easier to efficiently code. His
> counterargument was that for 2000 txn, the two bytes indexes take 4kb,
> which is pretty insignificant... and that his time would be better
> spent trying to get the hit-rate up. I found that hard to argue with.
> :)

Yeah. Having the bitcoin mempool and fee info (and heck, priority info)
more readily available when seeing new transactions and choosing what to
include seems like it'd be helpful here. Seems relatively painful to do
that outside of bitcoin though.

Cheers,
aj


----------
From: Gregory Maxwell <gmaxwell at gmail.com>
Date: Mon, May 15, 2017 at 8:03 PM
To: Anthony Towns <aj at erisian.com.au>


I ran into someone proposing the same thing as you. Can I share this
discussion with them? (with the public?)

----------
From: Anthony Towns <aj at erisian.com.au>
Date: Mon, May 15, 2017 at 11:00 PM
To: Gregory Maxwell <gmaxwell at gmail.com>


Yes, go ahead on both counts.
--
Sent from my phone.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170515/48773e42/attachment-0001.html>

From greg at xiph.org  Mon May 15 23:59:58 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Mon, 15 May 2017 23:59:58 +0000
Subject: [bitcoin-dev] Rolling UTXO set hashes
In-Reply-To: <CT3GNfkLsQJyM0EmWXc3HBmnW1h2iptP0SohZnXZfZPffoVmcofD8fs_E3kV5PuFL0pQSQwwk_FyR-8-wdANf15NE8UElNWqcEcc5Ql3n8M=@protonmail.com>
References: <CAPg+sBgruEiXya6oFy6VpmR1KPDebjeGDtZZU+facZx5=L_a5w@mail.gmail.com>
	<CT3GNfkLsQJyM0EmWXc3HBmnW1h2iptP0SohZnXZfZPffoVmcofD8fs_E3kV5PuFL0pQSQwwk_FyR-8-wdANf15NE8UElNWqcEcc5Ql3n8M=@protonmail.com>
Message-ID: <CAAS2fgTif+Y6VzFG+w7W+CY1+D_roCqGyy392qB2KcDPGpVeiw@mail.gmail.com>

On Mon, May 15, 2017 at 11:04 PM, ZmnSCPxj via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> transactions is in the header, which would let lite nodes download a UTXO
> set from any full node and verify it by verifying only block headers
> starting from genesis.

Ya, lite nodes with UTXO sets are one of the the oldest observed
advantages of a commitment to the UTXO data:

https://bitcointalk.org/index.php?topic=21995.0

But it requires a commitment. And for most of the arguments for those
you really want compact membership proofs.  The recent rise in
interest in full block lite clients (for privacy reasons), perhaps
complements the membership proofless usage.

Pieter describes some uses for doing something like this without a
commitment.  In my view, it's more interesting to first gain
experience with an operation without committing to it (which is a
consensus change and requires more care and consideration, which are
easier if people have implementation experience).

> rather than merkle tree root of transactions is in the header,

For audibility and engineering reasons it would need to be be in
addition to rather than rather than, because the proof of work needs
to commit to the witness data (in that kind of flip, the transactions
themselves become witnesses for UTXO deltas) or you get trivial DOS
attacks where people provide malleated blocks that have invalid
witnesses.

From pete at petertodd.org  Tue May 16 11:01:04 2017
From: pete at petertodd.org (Peter Todd)
Date: Tue, 16 May 2017 07:01:04 -0400
Subject: [bitcoin-dev] Rolling UTXO set hashes
In-Reply-To: <CAAS2fgTif+Y6VzFG+w7W+CY1+D_roCqGyy392qB2KcDPGpVeiw@mail.gmail.com>
References: <CAPg+sBgruEiXya6oFy6VpmR1KPDebjeGDtZZU+facZx5=L_a5w@mail.gmail.com>
	<CT3GNfkLsQJyM0EmWXc3HBmnW1h2iptP0SohZnXZfZPffoVmcofD8fs_E3kV5PuFL0pQSQwwk_FyR-8-wdANf15NE8UElNWqcEcc5Ql3n8M=@protonmail.com>
	<CAAS2fgTif+Y6VzFG+w7W+CY1+D_roCqGyy392qB2KcDPGpVeiw@mail.gmail.com>
Message-ID: <20170516110104.GA5564@fedora-23-dvm>

On Mon, May 15, 2017 at 11:59:58PM +0000, Gregory Maxwell via bitcoin-dev wrote:
> On Mon, May 15, 2017 at 11:04 PM, ZmnSCPxj via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > transactions is in the header, which would let lite nodes download a UTXO
> > set from any full node and verify it by verifying only block headers
> > starting from genesis.
> 
> Ya, lite nodes with UTXO sets are one of the the oldest observed
> advantages of a commitment to the UTXO data:
> 
> https://bitcointalk.org/index.php?topic=21995.0
> 
> But it requires a commitment. And for most of the arguments for those
> you really want compact membership proofs.  The recent rise in
> interest in full block lite clients (for privacy reasons), perhaps
> complements the membership proofless usage.
> 
> Pieter describes some uses for doing something like this without a
> commitment.  In my view, it's more interesting to first gain
> experience with an operation without committing to it (which is a
> consensus change and requires more care and consideration, which are
> easier if people have implementation experience).

To be clear, *none* of the previous (U)TXO commitment schemes require *miners*
to participate in generating a commitment. While that was previously thought to
be true by many, I've seen no counter-arguments to the argument I published I
few months ago(1) that (U)TXO commitments did not require a soft-fork to
deploy.

1) "[bitcoin-dev] TXO commitments do not need a soft-fork to be useful",
   Peter Todd, Feb 23 2017,
   https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-February/013591.html

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170516/8b074bc9/attachment.sig>

From alex.mizrahi at gmail.com  Tue May 16 12:15:17 2017
From: alex.mizrahi at gmail.com (Alex Mizrahi)
Date: Tue, 16 May 2017 15:15:17 +0300
Subject: [bitcoin-dev] TXO commitments do not need a soft-fork to be
	useful
In-Reply-To: <20170223011147.GB905@savin.petertodd.org>
References: <20170223011147.GB905@savin.petertodd.org>
Message-ID: <CAE28kUTxc4KPvijiaJQ6M=LDPf_Du1pFdehfTtXtqs0hOtyWTw@mail.gmail.com>

> Something I've recently realised is that TXO commitments do not need to be
> implemented as a consensus protocol change to be useful.


You're slow, Peter. I figured this out back in 2013:

https://bitcointalk.org/index.php?topic=153662.10
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170516/4294b4ce/attachment.html>

From pete at petertodd.org  Tue May 16 12:23:53 2017
From: pete at petertodd.org (Peter Todd)
Date: Tue, 16 May 2017 08:23:53 -0400
Subject: [bitcoin-dev] TXO commitments do not need a soft-fork to be
 useful
In-Reply-To: <CAE28kUTxc4KPvijiaJQ6M=LDPf_Du1pFdehfTtXtqs0hOtyWTw@mail.gmail.com>
References: <20170223011147.GB905@savin.petertodd.org>
	<CAE28kUTxc4KPvijiaJQ6M=LDPf_Du1pFdehfTtXtqs0hOtyWTw@mail.gmail.com>
Message-ID: <20170516122353.GA5808@fedora-23-dvm>

On Tue, May 16, 2017 at 03:15:17PM +0300, Alex Mizrahi via bitcoin-dev wrote:
> > Something I've recently realised is that TXO commitments do not need to be
> > implemented as a consensus protocol change to be useful.
> 
> 
> You're slow, Peter. I figured this out back in 2013:
> 
> https://bitcointalk.org/index.php?topic=153662.10

Lol, good job! And you even figured out that lovely "distributed file system"
explanation first.

Though, it does look like I'm still the person who made it 100% *clear* the
first time - you're explanation is easy to read the wrong way, particularly
when you say:

"Next time I will teach you how to implement a blockchain-based cryptocurrency
in such a way that new miners can start mining right away without downloading
whole blockchain, stay tuned..."

After all, at the time UTXO commitments had been already discussed. Also,
talking about a DHT in relation to this stuff probably made the explanation get
missed by some people.


Unfortunately, I think this is a good example of how important coming up with
good explanations and analogies is. :/

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170516/f98a72c8/attachment.sig>

From pieter.wuille at gmail.com  Tue May 16 18:17:19 2017
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Tue, 16 May 2017 11:17:19 -0700
Subject: [bitcoin-dev] Rolling UTXO set hashes
In-Reply-To: <20170516110104.GA5564@fedora-23-dvm>
References: <CAPg+sBgruEiXya6oFy6VpmR1KPDebjeGDtZZU+facZx5=L_a5w@mail.gmail.com>
	<CT3GNfkLsQJyM0EmWXc3HBmnW1h2iptP0SohZnXZfZPffoVmcofD8fs_E3kV5PuFL0pQSQwwk_FyR-8-wdANf15NE8UElNWqcEcc5Ql3n8M=@protonmail.com>
	<CAAS2fgTif+Y6VzFG+w7W+CY1+D_roCqGyy392qB2KcDPGpVeiw@mail.gmail.com>
	<20170516110104.GA5564@fedora-23-dvm>
Message-ID: <CAPg+sBjJLbhj71Epv=Qfc8HgJhSreN6BOmLkDkvcEGvPwxDNbg@mail.gmail.com>

On Tue, May 16, 2017 at 4:01 AM, Peter Todd via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> To be clear, *none* of the previous (U)TXO commitment schemes require *miners*
> to participate in generating a commitment. While that was previously thought to
> be true by many, I've seen no counter-arguments to the argument I published I
> few months ago(1) that (U)TXO commitments did not require a soft-fork to
> deploy.
>
> 1) "[bitcoin-dev] TXO commitments do not need a soft-fork to be useful",
>    Peter Todd, Feb 23 2017,
>    https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-February/013591.html

I'm aware, I agree, and I even referenced that mail in my original post.

However, all of those approaches still require a network wide choice
to be useful. A validating node that does not maintain a UTXO X must
get a proof of its unspentness from somewhere for at least the block
which contains a spend of X. In a world where such a model is deployed
network-wide, that proof information is generated by the wallet and
relayed wherever needed. In a partial deployment however, you need
nodes that can produce the proof for other nodes, and the ability to
produce a proof is significantly more expensive than running either an
old or a new full node.

This ability to produce proofs becomes even harder when there are
different models deployed at once. Even just having a different
criterion for which UTXOs need a proof (eg. "only outputs created more
than 1000 blocks ago") may already cause compatibility issues. Combine
that with the multitude of ideas about this (insertion-ordered TXO
trees, txid-ordered UTXO Patricia tries, AVL+ trees, append-only
bitfield, ...) with different trade-offs (in CPU, RAM for validators,
complexity for wallets/index services, ...), I don't think we're quite
ready to make that choice.

To be clear: I'm very much in favor of moving to a model where the
responsibilities of full nodes are reduced in the long term. But
before that can happen there will need to be implementations,
experiments, analysis, ...

Because of that, I think it is worthwhile to investigate solutions to
the "how can we efficiently compare UTXO sets" problem separately from
the "how do we reduce full node costs by sending proofs instead of it
maintaining the data". And rolling UTXO set hashes are a solution for
just the first - and one that has very low costs and no normative
datastructures at all.

-- 
Pieter

From ZmnSCPxj at protonmail.com  Tue May 16 00:15:58 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 15 May 2017 20:15:58 -0400
Subject: [bitcoin-dev] Rolling UTXO set hashes
In-Reply-To: <CAAS2fgTif+Y6VzFG+w7W+CY1+D_roCqGyy392qB2KcDPGpVeiw@mail.gmail.com>
References: <CAPg+sBgruEiXya6oFy6VpmR1KPDebjeGDtZZU+facZx5=L_a5w@mail.gmail.com>
	<CT3GNfkLsQJyM0EmWXc3HBmnW1h2iptP0SohZnXZfZPffoVmcofD8fs_E3kV5PuFL0pQSQwwk_FyR-8-wdANf15NE8UElNWqcEcc5Ql3n8M=@protonmail.com>
	<CAAS2fgTif+Y6VzFG+w7W+CY1+D_roCqGyy392qB2KcDPGpVeiw@mail.gmail.com>
Message-ID: <w4I6vriYS1XX4wAqk9LxneKCxEyPs4qy7Yhp8RaLazGNdgtkphKx8b95jZmaWL-NVnvdzBjgtwNiEm-0EosBuJ0tjND5lYkpmag_wREAFfs=@protonmail.com>

>On Mon, May 15, 2017 at 11:04 PM, ZmnSCPxj via bitcoin-dev
><bitcoin-dev at lists.linuxfoundation.org> wrote:
>> transactions is in the header, which would let lite nodes download a UTXO
>> set from any full node and verify it by verifying only block headers
>> starting from genesis.
>
>Ya, lite nodes with UTXO sets are one of the the oldest observed
>advantages of a commitment to the UTXO data:
>
>https://bitcointalk.org/index.php?topic=21995.0
>
>But it requires a commitment. And for most of the arguments for those
>you really want compact membership proofs. The recent rise in
>interest in full block lite clients (for privacy reasons), perhaps
>complements the membership proofless usage.
>
>Pieter describes some uses for doing something like this without a
>commitment. In my view, it's more interesting to first gain
>experience with an operation without committing to it (which is a
>consensus change and requires more care and consideration, which are
>easier if people have implementation experience).

I understand. Thank you for your explanation.

>> rather than merkle tree root of transactions is in the header,
>
>For audibility and engineering reasons it would need to be be in
>addition to rather than rather than, because the proof of work needs
>to commit to the witness data (in that kind of flip, the transactions
>themselves become witnesses for UTXO deltas) or you get trivial DOS
>attacks where people provide malleated blocks that have invalid
>witnesses.

Another thought I have, is that instead of committing to the UTXO of the block, to commit to the UTXO of the previous block, and the merkle tree root of the transactions in the current block.

My thought is that this would help reduce SPV mining, as a miner would need to actually scan any received new blocks in order to create the UTXO set of the previous block. An empty block would make things easier for the next block's miner, not the current block's miner. However, I'm not sure if my understanding is correct, or if there is some subtlety I missed in this regard.

Regards,
ZmnSCPxj
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170515/723c293e/attachment.html>

From greg at xiph.org  Tue May 16 18:20:00 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Tue, 16 May 2017 18:20:00 +0000
Subject: [bitcoin-dev] Rolling UTXO set hashes
In-Reply-To: <CAPg+sBjJLbhj71Epv=Qfc8HgJhSreN6BOmLkDkvcEGvPwxDNbg@mail.gmail.com>
References: <CAPg+sBgruEiXya6oFy6VpmR1KPDebjeGDtZZU+facZx5=L_a5w@mail.gmail.com>
	<CT3GNfkLsQJyM0EmWXc3HBmnW1h2iptP0SohZnXZfZPffoVmcofD8fs_E3kV5PuFL0pQSQwwk_FyR-8-wdANf15NE8UElNWqcEcc5Ql3n8M=@protonmail.com>
	<CAAS2fgTif+Y6VzFG+w7W+CY1+D_roCqGyy392qB2KcDPGpVeiw@mail.gmail.com>
	<20170516110104.GA5564@fedora-23-dvm>
	<CAPg+sBjJLbhj71Epv=Qfc8HgJhSreN6BOmLkDkvcEGvPwxDNbg@mail.gmail.com>
Message-ID: <CAAS2fgQKOKY6DEwY3ycMjysU5Xf2UUE+k=vg2ekkAMO7KG3Gsw@mail.gmail.com>

On Tue, May 16, 2017 at 6:17 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:
> just the first - and one that has very low costs and no normative
> datastructures at all.

The serialization of the txout itself is normative, but very minimal.

From zachlym at indolering.com  Wed May 17 17:01:04 2017
From: zachlym at indolering.com (Zach Lym)
Date: Wed, 17 May 2017 10:01:04 -0700
Subject: [bitcoin-dev] BIP39 (mnemonic seeds) Unicode normalization
	compatibility issue
Message-ID: <CABWuLVf6zUhyTSDkXv26WqUE43q7PHqtOtfm5SNs_LkbmGt9dQ@mail.gmail.com>

I am working on a replacement for BIP39 and noticed that the password
section mandates a Unicode normalization pass but does not prohibit
unassigned character points.

I believe that this is problematic as newer drafts of Unicode alter the
output of normalization passes.  So if a user assigned a password using a
wallet that linked to Unicode 9 but input a code point reserved in Unicode
10, updating the wallet to Unicode 10 could incorrectly remap that code
point [0].

Thank you,
-Zach Lym

P.S. The relevant RFC on this subject specifies a different normalization
procedure [1]

[BIP39]: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
[0]: http://unicode.org/reports/tr15/#Stabilized_Strings
[1]: https://tools.ietf.org/html/rfc7564
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170517/93410416/attachment.html>

From da2ce7 at gmail.com  Thu May 18 13:44:47 2017
From: da2ce7 at gmail.com (Cameron Garnham)
Date: Thu, 18 May 2017 16:44:47 +0300
Subject: [bitcoin-dev] =?utf-8?b?VHJlYXRpbmcg4oCYQVNJQ0JPT1NU4oCZIGFzIGEg?=
 =?utf-8?q?Security_Vulnerability?=
Message-ID: <4BA0FA5D-7B29-4A7F-BC5B-361ED00D5CB2@gmail.com>

Hello Bitcoin Development Mailing List,

I wish to explain why the current approach to ?ASICBOOST? dose not comply with our established best practices for security vulnerabilities and suggest what I consider to be an approach closer matching established industry best practices.


1.     Significant deviations from the Bitcoin Security Model have been acknowledged as security vulnerabilities.

The Bitcoin Security Model assumes that every input into the Proof-of-Work function should have the same difficulty of producing a desired output.


2.     General ASIC optimisation cannot be considered a Security Vulnerabilities.

Quickly being able to check inputs is not a vulnerability. However, being able to craft inputs that are significantly easier to check than alternative inputs is a vulnerability.


3.     We should assign a CVE to the vulnerability exploited by ?ASICBOOST?.

?ASICBOOST? is an attack on this Bitcoin?s security assumptions and should be considered an exploit of the Bitcoin Proof-of-Work Function.

For a more detailed look at ?ASICBOOST?, please have a look at this excellent document by Jeremy Rubin:
http://www.mit.edu/~jlrubin//public/pdfs/Asicboost.pdf

The Bitcoin Community should be able to track the progress of restoring the quality of the Bitcoin Proof-of-Work function to its original assumptions.


4.     Work should be taken to prudently and swiftly restore Bitcoins Security Properties.

I recommend the Bitcoin Community fix this vulnerability with expediency.



Cameron.

PS:

With a soft-fork it probably is possible to completely fix this Proof-of-Work vulnerability.

(Here is my working list of things to do):

1.     Include extra data in the Coinbase Transaction, such as the Witness Root.

2.     Lock the Version. (Use a space in the Coinbase Transaction for signalling future upgrades).

3.     Lock the lower-bits on the Timestamp: Block timestamps only need ~1minute granularity.

4.	Make a deterministic ordering of transaction chains within a block. (However, I believe this option is more difficult).

Of course, if we have a hard-fork, we should consider the Proof-of-Work internal merkle structure directly.

From james.hilliard1 at gmail.com  Thu May 18 13:57:08 2017
From: james.hilliard1 at gmail.com (James Hilliard)
Date: Thu, 18 May 2017 08:57:08 -0500
Subject: [bitcoin-dev]
	=?utf-8?b?VHJlYXRpbmcg4oCYQVNJQ0JPT1NU4oCZIGFzIGEg?=
	=?utf-8?q?Security_Vulnerability?=
In-Reply-To: <4BA0FA5D-7B29-4A7F-BC5B-361ED00D5CB2@gmail.com>
References: <4BA0FA5D-7B29-4A7F-BC5B-361ED00D5CB2@gmail.com>
Message-ID: <CADvTj4rdQVCYu=m9ymi4OP-Q0NaVmfaJS8eSBhuER=uKBzXpqA@mail.gmail.com>

Locking the lower bits on the timestamp will likely break existing
hardware that relies on being able to roll ntime.

On Thu, May 18, 2017 at 8:44 AM, Cameron Garnham via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Hello Bitcoin Development Mailing List,
>
> I wish to explain why the current approach to ?ASICBOOST? dose not comply with our established best practices for security vulnerabilities and suggest what I consider to be an approach closer matching established industry best practices.
>
>
> 1.     Significant deviations from the Bitcoin Security Model have been acknowledged as security vulnerabilities.
>
> The Bitcoin Security Model assumes that every input into the Proof-of-Work function should have the same difficulty of producing a desired output.
>
>
> 2.     General ASIC optimisation cannot be considered a Security Vulnerabilities.
>
> Quickly being able to check inputs is not a vulnerability. However, being able to craft inputs that are significantly easier to check than alternative inputs is a vulnerability.
>
>
> 3.     We should assign a CVE to the vulnerability exploited by ?ASICBOOST?.
>
> ?ASICBOOST? is an attack on this Bitcoin?s security assumptions and should be considered an exploit of the Bitcoin Proof-of-Work Function.
>
> For a more detailed look at ?ASICBOOST?, please have a look at this excellent document by Jeremy Rubin:
> http://www.mit.edu/~jlrubin//public/pdfs/Asicboost.pdf
>
> The Bitcoin Community should be able to track the progress of restoring the quality of the Bitcoin Proof-of-Work function to its original assumptions.
>
>
> 4.     Work should be taken to prudently and swiftly restore Bitcoins Security Properties.
>
> I recommend the Bitcoin Community fix this vulnerability with expediency.
>
>
>
> Cameron.
>
> PS:
>
> With a soft-fork it probably is possible to completely fix this Proof-of-Work vulnerability.
>
> (Here is my working list of things to do):
>
> 1.     Include extra data in the Coinbase Transaction, such as the Witness Root.
>
> 2.     Lock the Version. (Use a space in the Coinbase Transaction for signalling future upgrades).
>
> 3.     Lock the lower-bits on the Timestamp: Block timestamps only need ~1minute granularity.
>
> 4.      Make a deterministic ordering of transaction chains within a block. (However, I believe this option is more difficult).
>
> Of course, if we have a hard-fork, we should consider the Proof-of-Work internal merkle structure directly.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From tier.nolan at gmail.com  Thu May 18 14:59:50 2017
From: tier.nolan at gmail.com (Tier Nolan)
Date: Thu, 18 May 2017 15:59:50 +0100
Subject: [bitcoin-dev]
	=?utf-8?b?VHJlYXRpbmcg4oCYQVNJQ0JPT1NU4oCZIGFzIGEg?=
	=?utf-8?q?Security_Vulnerability?=
In-Reply-To: <4BA0FA5D-7B29-4A7F-BC5B-361ED00D5CB2@gmail.com>
References: <4BA0FA5D-7B29-4A7F-BC5B-361ED00D5CB2@gmail.com>
Message-ID: <CAE-z3OX2b4V+ERAYszokAUrSRPqpOCd2TovxBiqfeRTj4yuVpw@mail.gmail.com>

On Thu, May 18, 2017 at 2:44 PM, Cameron Garnham via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> 1.     Significant deviations from the Bitcoin Security Model have been
> acknowledged as security vulnerabilities.
>
> The Bitcoin Security Model assumes that every input into the Proof-of-Work
> function should have the same difficulty of producing a desired output.
>

This isn't really that clear.

Arguably as long as the effort to find a block is proportional to the block
difficulty parameter, then it isn't an exploit.  It is just an optimisation.

A quantum computer, for example, could find a block with effort
proportional to the square root of the difficulty parameter, so that would
count as an attack.  Though in that case, the fix would likely be to tweak
the difficulty parameter update calculation.

A better definition would be something like "when performing work, each
hash should be independent".

ASICBOOST does multiple checks in parallel, so would violate that.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170518/8af10956/attachment.html>

From bitcoin-dev at rgrant.org  Thu May 18 19:28:38 2017
From: bitcoin-dev at rgrant.org (Ryan Grant)
Date: Thu, 18 May 2017 15:28:38 -0400
Subject: [bitcoin-dev]
	=?utf-8?b?VHJlYXRpbmcg4oCYQVNJQ0JPT1NU4oCZIGFzIGEg?=
	=?utf-8?q?Security_Vulnerability?=
In-Reply-To: <4BA0FA5D-7B29-4A7F-BC5B-361ED00D5CB2@gmail.com>
References: <4BA0FA5D-7B29-4A7F-BC5B-361ED00D5CB2@gmail.com>
Message-ID: <CAMnpzfoe1jNu6Uj8uXTJeGNLHG1O9DGtvy=aMJd=6OBS+_weSw@mail.gmail.com>

On Thu, May 18, 2017 at 9:44 AM, Cameron Garnham via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> 3.     We should assign a CVE to the vulnerability exploited by ?ASICBOOST?.
>
> ?ASICBOOST? is an attack on this Bitcoin?s security assumptions and
> should be considered an exploit of the Bitcoin Proof-of-Work
> Function.

On Thu, May 18, 2017 at 10:59 AM, Tier Nolan via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Arguably as long as the effort to find a block is proportional to the block
> difficulty parameter, then it isn't an exploit.  It is just an optimisation.

One principled way to proceed would be to fault not the exploit, but
the protocol design.

Bits in the block header have been discovered which could be used for
dual meanings, and at least one meaning does not preserve the
incentive balances intended and assumed by others.  This unexpectedly
creates an incentive to block protocol improvements.  The protocol
must be repaired.

In this view, which focuses on covert-ASICBOOST, how work is done is
up to the implementation.  But if the hashing work specified possibly
could gain from blocking development work, then we have a
vulnerability.

I believe this is clear grounds for taking action without any delay.

From da2ce7 at gmail.com  Fri May 19 07:32:36 2017
From: da2ce7 at gmail.com (Cameron Garnham)
Date: Fri, 19 May 2017 10:32:36 +0300
Subject: [bitcoin-dev]
 =?utf-8?b?VHJlYXRpbmcg4oCYQVNJQ0JPT1NU4oCZIGFzIGEg?=
 =?utf-8?q?Security_Vulnerability?=
In-Reply-To: <CAE-z3OX2b4V+ERAYszokAUrSRPqpOCd2TovxBiqfeRTj4yuVpw@mail.gmail.com>
References: <4BA0FA5D-7B29-4A7F-BC5B-361ED00D5CB2@gmail.com>
	<CAE-z3OX2b4V+ERAYszokAUrSRPqpOCd2TovxBiqfeRTj4yuVpw@mail.gmail.com>
Message-ID: <B3FCB9B3-3E0F-48A4-82D9-61019B4672B5@gmail.com>

(message was originally sent off-list by mistake).

Hello Tier,

Thank-you for your insightful reply,

Am I correct that this suggest is that you think it is an optimisation to find some nonces having lower difficulty than other nonces?

I would agree with you if this was limited to a dedicated nonce area of the Bitcoin System.

However, in the case of Bitcoin it is a layer violation that the PoW function difficulty could be affected by the choice the transaction ordering, or the content of the Coinbase Transaction, etc.  Possibly giving unnatural and unintended incentives to other parts of the Bitcoin System.

I can see two issues at play here:

1.	The choice of input, outside of the dedicated nonce area, fed the PoW function should not change it?s difficulty to evaluate.
2.	Every PoW function execution should be independent.

I think that both of these are security assumptions of the Bitcoin PoW function.

I consider ASICBOOST as an attack upon both accounts.

Cameron.

> 
> On 18 May 2017, at 17:59 , Tier Nolan via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> On Thu, May 18, 2017 at 2:44 PM, Cameron Garnham via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 1.     Significant deviations from the Bitcoin Security Model have been acknowledged as security vulnerabilities.
> 
> The Bitcoin Security Model assumes that every input into the Proof-of-Work function should have the same difficulty of producing a desired output.
> 
> This isn't really that clear.
> 
> Arguably as long as the effort to find a block is proportional to the block difficulty parameter, then it isn't an exploit.  It is just an optimisation.
> 
> A quantum computer, for example, could find a block with effort proportional to the square root of the difficulty parameter, so that would count as an attack.  Though in that case, the fix would likely be to tweak the difficulty parameter update calculation.
> 
> A better definition would be something like "when performing work, each hash should be independent".  
> 
> ASICBOOST does multiple checks in parallel, so would violate that.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170519/e0038c2d/attachment-0001.html>

From earonesty at gmail.com  Fri May 19 07:16:20 2017
From: earonesty at gmail.com (Erik Aronesty)
Date: Fri, 19 May 2017 03:16:20 -0400
Subject: [bitcoin-dev]
	=?utf-8?b?VHJlYXRpbmcg4oCYQVNJQ0JPT1NU4oCZIGFzIGEg?=
	=?utf-8?q?Security_Vulnerability?=
In-Reply-To: <CAJowKg+LAcVCsH7gbuZhKnnv8p5=WXqNCs5oqub3bacRpQ7n9w@mail.gmail.com>
References: <4BA0FA5D-7B29-4A7F-BC5B-361ED00D5CB2@gmail.com>
	<CAMnpzfoe1jNu6Uj8uXTJeGNLHG1O9DGtvy=aMJd=6OBS+_weSw@mail.gmail.com>
	<CAJowKgLurok+bTKrt8EAAF0Q7u=cEDwfxOuQJkYNKieFpCPErQ@mail.gmail.com>
	<CAJowKg+r3XKaoN3ys3o3FWhpJ3w8An1q0oYMmu_KzDfNdzF8Vg@mail.gmail.com>
	<CAJowKgKf22b2jjRbmG+k53g4bOzXrk7AHVcR02xqXPU8ZLJhaQ@mail.gmail.com>
	<CAJowKg+LAcVCsH7gbuZhKnnv8p5=WXqNCs5oqub3bacRpQ7n9w@mail.gmail.com>
Message-ID: <CAJowKg+MZfdfSkZQQutKsFY=rcQSAhLtpRT7dAEH=qyYPNN67A@mail.gmail.com>

ASIC boost is definitely a protocol vulnerability.

It makes Bitcoin resistant to current and future modifications which are
necessary to preserve decentralization.

That alone should be enough to prioritize a swift preventative measure.

On May 18, 2017 3:29 PM, "Ryan Grant via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

On Thu, May 18, 2017 at 9:44 AM, Cameron Garnham via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> 3.     We should assign a CVE to the vulnerability exploited by
?ASICBOOST?.
>
> ?ASICBOOST? is an attack on this Bitcoin?s security assumptions and
> should be considered an exploit of the Bitcoin Proof-of-Work
> Function.

On Thu, May 18, 2017 at 10:59 AM, Tier Nolan via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Arguably as long as the effort to find a block is proportional to the
block
> difficulty parameter, then it isn't an exploit.  It is just an
optimisation.

One principled way to proceed would be to fault not the exploit, but
the protocol design.

Bits in the block header have been discovered which could be used for
dual meanings, and at least one meaning does not preserve the
incentive balances intended and assumed by others.  This unexpectedly
creates an incentive to block protocol improvements.  The protocol
must be repaired.

In this view, which focuses on covert-ASICBOOST, how work is done is
up to the implementation.  But if the hashing work specified possibly
could gain from blocking development work, then we have a
vulnerability.

I believe this is clear grounds for taking action without any delay.
_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170519/08fec7f0/attachment.html>

From karljohan-alm at garage.co.jp  Fri May 19 04:09:29 2017
From: karljohan-alm at garage.co.jp (Karl Johan Alm)
Date: Fri, 19 May 2017 13:09:29 +0900
Subject: [bitcoin-dev] BIP Proposal: Rate Limiting with server specified
	Proof of Work challenges
In-Reply-To: <CALJw2w7CBFU-xFnar6p4k+84Umh5rsuaQ6UA1-8E2_N3_AOSpQ@mail.gmail.com>
References: <CALJw2w7CBFU-xFnar6p4k+84Umh5rsuaQ6UA1-8E2_N3_AOSpQ@mail.gmail.com>
Message-ID: <CALJw2w70NnjKuuk3u+_H2JpMZfsZh=DfbepR0R9Gy2WF2uBzOg@mail.gmail.com>

Hello,

Some time has passed since this was initially posted, and I have not
received any negative feedback. If no objections are raised, I would
like to have a BIP number assigned.

On Mon, May 8, 2017 at 11:48 AM, Karl Johan Alm
<karljohan-alm at garage.co.jp> wrote:
> Hello,
>
> I am proposing a new feature for rate limiting purposes where nodes
> can make and solve arbitrary PoW challenges in return for connection
> slots (to be expanded to cover e.g. bloom filters or other DoS risky
> services).
>
> The BIP currently includes two proofs of work (sha256 and
> cuckoo-cycle) which can be combined (e.g. sha256(cuckoo-cycle) or
> sha256(sha256(sha256)), etc).
>
> Link: https://github.com/kallewoof/bips/blob/pow-connection-slots/bip-rate-limiting-via-pow.mediawiki
>
> Feedback welcome.

From markboldyrev at gmail.com  Fri May 19 06:07:41 2017
From: markboldyrev at gmail.com (Mark Boldyrev)
Date: Fri, 19 May 2017 09:07:41 +0300
Subject: [bitcoin-dev] A proposal to reintroduce the disabled script opcodes
Message-ID: <CAK9dXBSg+wzAZw7_xPXRVvx1uZzjAEE8nuvj0vkdSGD-yTfwhQ@mail.gmail.com>

Back in 2010, there was a bug found in Core which allowed denial-of-service
attacks due to the software crashing on some machines while executing a
script - see CVE-2010-537.
I believe the removed ("disabled") opcodes should be re-introduced along
with a standardized behavior definition.
For example, when execution of an opcode results in an arithmetic error,
such as OP_DIV with a zero divisor, the script should exit and fail.
The string splice opcodes should also check their arguments for
correctness, etc.

These opcodes would enhance the flexibility of scripts and allow
sophisticated native smart contracts to be created.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170519/6209b7a2/attachment.html>

From hampus.sjoberg at gmail.com  Fri May 19 13:13:03 2017
From: hampus.sjoberg at gmail.com (=?UTF-8?Q?Hampus_Sj=C3=B6berg?=)
Date: Fri, 19 May 2017 15:13:03 +0200
Subject: [bitcoin-dev] A proposal to reintroduce the disabled script
	opcodes
In-Reply-To: <CAK9dXBSg+wzAZw7_xPXRVvx1uZzjAEE8nuvj0vkdSGD-yTfwhQ@mail.gmail.com>
References: <CAK9dXBSg+wzAZw7_xPXRVvx1uZzjAEE8nuvj0vkdSGD-yTfwhQ@mail.gmail.com>
Message-ID: <CAFMkqK8u37rLfwdx_d2oX0a9p2J=vvGcmSkNfj-LS2krOb+f6w@mail.gmail.com>

AFAICT, re-enabling these old OP-codes would require a hardfork.

If we had SegWit enabled, we could via a soft fork allocate new OP-codes
for the same functionality (by introducing a new version of Script).
I believe the Elements alpha project has been experimenting with
re-enabling old OP-codes: https://elementsproject.org/elements/opcodes/

2017-05-19 8:07 GMT+02:00 Mark Boldyrev via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org>:

> Back in 2010, there was a bug found in Core which allowed
> denial-of-service attacks due to the software crashing on some machines
> while executing a script - see CVE-2010-537.
> I believe the removed ("disabled") opcodes should be re-introduced along
> with a standardized behavior definition.
> For example, when execution of an opcode results in an arithmetic error,
> such as OP_DIV with a zero divisor, the script should exit and fail.
> The string splice opcodes should also check their arguments for
> correctness, etc.
>
> These opcodes would enhance the flexibility of scripts and allow
> sophisticated native smart contracts to be created.
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170519/9dd5d326/attachment.html>

From aj at erisian.com.au  Sat May 20 05:05:43 2017
From: aj at erisian.com.au (Anthony Towns)
Date: Sat, 20 May 2017 15:05:43 +1000
Subject: [bitcoin-dev] BIP: Block signal enforcement via tx fees
In-Reply-To: <CAMZUoKnjc4ezVm4FeMFA-+=g13E5ZwZCAoAjd_yL89v7qf1gEA@mail.gmail.com>
References: <201705121922.57445.luke@dashjr.org>
	<CAMZUoKnzV9faJ+mBTTzTre05Ejwnx3tC4ozbiPoPUfS+7GLMTQ@mail.gmail.com>
	<201705130526.59467.luke@dashjr.org>
	<CAMZUoKnjc4ezVm4FeMFA-+=g13E5ZwZCAoAjd_yL89v7qf1gEA@mail.gmail.com>
Message-ID: <20170520050543.GA4334@erisian.com.au>

On Sat, May 13, 2017 at 01:11:27PM -0400, Russell O'Connor via bitcoin-dev wrote:
> On Sat, May 13, 2017 at 1:26 AM, Luke Dashjr <luke at dashjr.org> wrote:
> > Versionbits change/lose their meaning after the deployment timeout. For
> > this reason, the timeout must be specified so the check is skipped 
> > when that occurs.
> To add a timeout a user can optionally bundle a pair of similar transactions.?
> One with the transaction version bits set and a second with a locktime set.?
> The effect is the same.

Another approach to ensuring the timeout might be to simply use input 
height. ie:

  * if there is a BIP-9 soft-fork using bit N currently STARTED or
    LOCKED_IN phase. since the soft-fork is started, set the height of
    the first block after starttime as "S".

  * then a transaction is invalid in a block if:
     * the soft-fork has not timed out or activated
     * the block does not signal bit N
     * the transaction nversion does signal bit N (by whatever formula)
     * at least one input to the transaction has a height >= S

That's compatible with bit reuse: if a transaction designed to encourage
soft-fork foo with bit 1 does not get mined by the time foo finishes (by
timeout or success), then when soft-fork bar reaches STARTED phase while
reusing bit 1, the old transaction can be mined by either signalling
or non-signalling miners -- because all of the transaction inputs are
prior to bar's block S, the invalidation rule doesn't apply for bar, and
because foo has timed out or activated, it doesn't apply for foo either.

It means you can't directly use a bunch of old coins on their own to
incentivise miner signalling -- you need to include a coin from after
starttime. That doesn't seem terribly onerous though; and should be
easily solvable by just providing a coinjoin API anyway.  I think it's
compatible with using bitcoin days destroyed as a weighting measure too,
since only one of the coins needs to be relatively recent.

The above is a "fail-open" timeout rather than "fail-closed" -- if you
signal for foo, but your transaction doesn't get mined because too few
miners are signalling foo, and then foo fails to activate and times out,
your transaction can then be mined by the miners that didn't signal. If
this isn't what you want, double-spending should be fine: provide a double
spend at market rates that doesn't require signalling directly to miners
and their choice becomes "mine this thing now and get the fee directly"
versus "hope no one else mines it now, and that I get the chance to mine
the original higher fee transaction after activation, before anyone else
does", so at least the economically-rational choice should be to mine
the lower-fee double spend immediately. So it should be reasonable to
offer a higher fee for signalling, without risking that non-signalling
miners will be able to claim that high fee eventually.

I'm not sure the incentives about tying user-signalling for a soft-fork
to miner signalling for a soft-fork are entirely sound; but if they are
then just using nversion seems a lot more user-friendly than requiring
script changes to me. In particular, it doesn't require any setup or
teardown costs -- you don't have to get an input with a particular
script encoded that you can then spend to signal, and you don't have to
remember variations on output address when you want to spend a transaction
that was signalling; likewise changes to wallets are pretty simple and
don't have "you lost all your money" results if there's a bug. Well,
the above timeout procedure requires getting a recent coin as "setup",
but that's pretty trivial, at least.

Cheers,
aj


From pieter.wuille at gmail.com  Sat May 20 20:13:13 2017
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Sat, 20 May 2017 13:13:13 -0700
Subject: [bitcoin-dev] A BIP proposal for segwit addresses
In-Reply-To: <CAPg+sBiPiLHZFoYY=gs6LT+Q2Kb5NmbVU05u7c+0WRPjveBJhQ@mail.gmail.com>
References: <CAPg+sBh0sFA7b6a+48Oojwy655GB9W6Th8JiCpd+2ruQjPev8Q@mail.gmail.com>
	<CAPg+sBiPiLHZFoYY=gs6LT+Q2Kb5NmbVU05u7c+0WRPjveBJhQ@mail.gmail.com>
Message-ID: <CAPg+sBjFC98WzB+eCCcBOg0c-y+aj=_+-+PYyOO-7CA1xe7HAw@mail.gmail.com>

On Sun, May 7, 2017 at 2:39 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:
> I'd like to move forward and request a BIP number assignment for this
> proposal.

The proposal has been submitted as BIP173:
https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki

Cheers,

-- 
Pieter

From shaolinfry at protonmail.ch  Mon May 22 06:12:08 2017
From: shaolinfry at protonmail.ch (shaolinfry)
Date: Mon, 22 May 2017 02:12:08 -0400
Subject: [bitcoin-dev] Barry Silbert segwit agreement
Message-ID: <2zSehquWdVTgHhfHfQpAHZTGAyzv-XFias7rRsns0j6TpJryz6Fyvst3N0v_2_Q3KsYiyRn9qd9Gb1QLUxh5F11RAlVmvezYN8d4m8q5F-A=@protonmail.ch>

Someone sent me a copy of the Barry Silbert agreement, an agreement forged between a select number of participants https://pastebin.com/VuCYteJh

Participants agree to immediately activate Segwit, however, under a different activation proposal. Since I have spent the last few months researching various activation strategies of the current BIP141 deployment, as well as redeployment, I feel I am quite well placed to comment on the technicalities.

To be clear, the proposal as far as I can see does not activate BIP141, but is a completely new deployment which would be incompatible with the BIP141 deployment. I'm not sure how that can be considered "immediate" activation. Surely immediate activation would just be for miners to start signalling and segwit would be activated in 4-5 weeks. The proposal seems to require a lower 80% threshold, I assume because they were unable to convince 95% of the hashpower to go trigger activation.

There are a few options to activating segwit now, the first being for 95% of hashrate to signal. The second is for the community to deploy BIP148 UASF which will force miners to signal segwit. Being a UASF it is date triggered. The third option is a redeployment of segwit on a new bit, but requires waiting for the existing deployment to time out, because all the p2p messages and service bits related to segwit must be replaced too (which is what BIP149 does).

A fourth option, first suggested to me by James Hilliard, was to make BIP148 miner triggered (MASF) with a lower threshold, above 50%. I coded this up a few weeks ago https://github.com/bitcoin/bitcoin/compare/master...shaolinfry:segsignal but didnt get around to posting to the ML yet. This effectively lowers the threshold from 95% to 65% as coded, or could be upped to 80% or whatever was preferable.

I think this removes the primary risk of BIP148 causing the creation of two chains, and gives an improved chance to get segwit activated quickly (assuming a majority of miners wish to go this route). But hash a primary disadvantage of still leaving the activation in the hands of miners. If it doesn't work out, then BIP149 can then be used as proposed, but it'll be even safer because we'll have futher guaged support.

References:

SEGSIGNAL: https://github.com/bitcoin/bitcoin/compare/master...shaolinfry:segsignal
BIP148: https://github.com/bitcoin/bips/blob/master/bip-0148.mediawiki
BIP149: https://github.com/bitcoin/bips/blob/master/bip-0149.mediawiki

I think the Barry Silbert agreement is very ill considered, and clearly lacking peer review from the technical community. Suggestions of a HF in 4 months are completely unrealistic and without technical merits. But more importantly, closed door agreements between selected participants is not how to garner consensus to change a $30bn decentralized system. The purpose of my email is to try and assist in the "immediate activation of segwit" which only requires hashrate to participate; and to provide some techincal input since I have done a great deal of research and development into the topic.

Given the history we've already passed the point where we should be expecting miners to cooperate in lowering their own fee income with a capacity increase; but we should be open to all reasonable options in the interest in moving things forward in a safe and collaborative way.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/795810e9/attachment.html>

From pete at petertodd.org  Mon May 22 06:27:04 2017
From: pete at petertodd.org (Peter Todd)
Date: Mon, 22 May 2017 02:27:04 -0400
Subject: [bitcoin-dev] Barry Silbert segwit agreement
In-Reply-To: <2zSehquWdVTgHhfHfQpAHZTGAyzv-XFias7rRsns0j6TpJryz6Fyvst3N0v_2_Q3KsYiyRn9qd9Gb1QLUxh5F11RAlVmvezYN8d4m8q5F-A=@protonmail.ch>
References: <2zSehquWdVTgHhfHfQpAHZTGAyzv-XFias7rRsns0j6TpJryz6Fyvst3N0v_2_Q3KsYiyRn9qd9Gb1QLUxh5F11RAlVmvezYN8d4m8q5F-A=@protonmail.ch>
Message-ID: <20170522062704.GA29930@savin.petertodd.org>

On Mon, May 22, 2017 at 02:12:08AM -0400, shaolinfry via bitcoin-dev wrote:
> Someone sent me a copy of the Barry Silbert agreement, an agreement forged between a select number of participants https://pastebin.com/VuCYteJh

It's interesting how changing the bit used to signal could be used as a way to
try to trick people into changing node software ASAP to support the hard-fork
code. Basically, the narrative would be that other software *doesn't* support
segwit, so you have to upgrade right away.

> A fourth option, first suggested to me by James Hilliard, was to make BIP148 miner triggered (MASF) with a lower threshold, above 50%. I coded this up a few weeks ago https://github.com/bitcoin/bitcoin/compare/master...shaolinfry:segsignal but didnt get around to posting to the ML yet. This effectively lowers the threshold from 95% to 65% as coded, or could be upped to 80% or whatever was preferable.

In contrast this proposal wouldn't have that effect, because as you point out
it's compatibel with the existing segwit protocol once activated.

Smells like political engineering to me.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/69af6329/attachment.sig>

From roconnor at blockstream.io  Mon May 22 07:05:49 2017
From: roconnor at blockstream.io (Russell O'Connor)
Date: Mon, 22 May 2017 03:05:49 -0400
Subject: [bitcoin-dev] A Method for Computing Merkle Roots of Annotated
	Binary Trees
Message-ID: <CAMZUoK=f3hXHkqJBDfiLGSrgXi_ppgyH6+XWD9W54EYFWLm1+Q@mail.gmail.com>

## Introduction
This document aims to specify and justify a method for computing Merkle
roots for tree structures whose nodes are annotated with other data.  While
this proposal could be used to replace Bitcoin's Merkle root calculation,
it is primarily aimed at new applications such as MAST, (U)TXO commitments
or other Merklized structures.

## Background
Bitcoin uses a Merkle tree construction to build a commitment to a sequence
of transactions for a Bitcoin block.  The main operation for computing a
Merkle tree is one that takes the recursively computed Merkle roots of two
branches and combines them to compute the Merkle root of the tree with
those two branches.  In Bitcoin, a Merkle root is 256 bits and the
construction is

    MerkleRoot := SHA256(SHA256(LeftRoot ? RightRoot))

One problem with this construction is that it is unnecessarily expensive.
While the concatenation of the LeftRoot and the RightRoot fits in 512 bits,
the size of a SHA256 chunk, a second chunk is needed to fit SHA256's
padding.  This means that inner SHA256 call invokes the SHA256 compression
function twice, once for each chunk.  The outer SHA256 call invokes the
SHA256 compression function a third time.  Bitcoin's Merkle root procedure
calls the SHA256 compression function a total of three times per node.

The main purpose of composing two calls to the SHA256 hash function is to
protect against length extension attacks.  A length extension attack is
where an attacker has access to the hash of a message `HASH(msg)` and,
without knowing `msg`, is able to construct the hash of a new message
`HASH(msg ? attackerMsg)`.  This is attack is usually used against poorly
constructed MACs (Message Authentication Codes).  In the case of Bitcoin
there are no secret messages that are hashed, so the outer call to SHA256
is unnecessary.

As mentioned above, the inner call to SHA256 requires two chunks because of
SHA256's padding.  For the MerkleRoot construction added padding value is
always


0x80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000200

because the input is of a fixed length.  SHA256's padding function is
designed

1. to add bits to the message so that the resulting message size is a
multiple of the chunk size (which is 512-bits in the case of SHA256).
2. to satisfy the Merkle--Damg?rd property which says that if we can find a
hash collision in SHA256, which operates on variable length messages, then
we can find a hash collision in SHA256's compression function, which
operates on fixed length messages.

We could remove the second call to the SHA256 compression function and use
SHA256 without padding.  If we did, we would lose the Merkle--Damg?rd
property.  While this may be acceptable for some use cases, we are still
left with no room to add annotation data held at a node.  For Bitcoin's
Merkle tree this is not a problem, because its trees are not annotated.
However, for other applications, we would need to add another chunk to hold
the annotation, which would mean adding back the second call to the SHA256
compression function per node of the tree.

## A New Merkle Root Algorithm
Below is an algorithm for computing Merkle roots that directly uses the
SHA256 compression function.  This algorithm operates on binary trees and
supports per node annotations.  Furthermore this proposal satisfies the
Merkle--Damg?rd property and more.

#### Remark 1
Any finitely branching tree can be represented by a binary tree, so this
construction also applies to arbitrary finitely branching trees.

The SHA256 compression function takes two inputs:

1. A 256-bit value for the previous chunk in a chain, or an initial vector
in the case of the first chunk.
2. A 512-bit chunk of data.

    sha256Compress : Word256 ? Word512 -> Word256

In total, the SHA256 compression function compresses 768-bits into
256-bits.  The Merkle roots of two branches occupy 512 bits, and this
leaves another 256-bits of space available for tags.

Let us define a recursive type for binary trees annotated with tags.

    type Tree tag where
      Leaf   : tag                       -> Tree tag
      Unary  : tag ? Tree tag            -> Tree tag
      Binary : tag ? Tree tag ? Tree tag -> Tree tag

We define a recursive algorithm for trees whose tags are 256-bit Words (or
whose tags can be represented by 256-bit words).

    merkleRoot : Tree Word256 -> Word256
    merkleRoot (Leaf (t))                :=
sha256Compress(sha256(ApplicationName),
0b0^256 ? t)
    merkleRoot (Unary (t, child))        := sha256Compress(merkleRoot(child),
0b0^256 ? t)
    merkleRoot (Binary (t, left, right)) := sha256Compress(merkleRoot(left),
merkleRoot(right) ? t)

We need some initial value for the `Leaf` case.  This could be taken as the
initial vector for SHA256.  However, I suggest using the hash of an
application specific name.

    ApplicationName : BitString

We further require that the tags dictate the kind of node it is attached
to.  For example, if a given tag is used for Binary nodes, then it can only
appear in other Binary nodes.  One way this can be accomplished is by
requiring the first two bits of a tag follow a particular scheme (the
scheme below ensures that one of the first two bits is set, which will be
useful later when we define safe tags) such as

- 0b11 when the node is a Leaf node.
- 0b10 when the node is a Unary node.
- 0b01 when the node is a Binary node.

This condition suffices to provide the Merkle--Damg?rd property:

#### Theorem 2
Suppose `t_1` and `t_2` are two different `Tree Word256` values such that
any tag occurring in the two trees only occurs in one kind of node.  If
`merkleRoot(t_1) = merkleRoot(t_2)` then we can effectively find a
collision in the SHA256 compression function.

Proof.
We proceed by structural induction on `t_1`.  Assume `t_1` and `t_2` are
two different `Tree Word256` values such that `merkleRoot(t_1) =
merkleRoot(t_2)`.  Define a `tag` function to extract the tag name from the
root of a tree.

    tag : Tree Word256 -> Word256
    tag (Leaf (t))         := t
    tag (Unary (t, _))     := t
    tag (Binary (t, _, _)) := t

Case 1: Suppose `tag(t_1) =/= tag(t_2)`.
This means that the inputs to `sha256Compress` that produced
`merkleRoot(t_1)` and `merkleRoot(t_2)` are different and we have found a
collision in the SHA256 compression function.

Case 2: Suppose `tag(t_1) = tag(t_2)`.
Let `tg` be this tag.  By our requirement on tags, this means that `t_1`
and `t_2` are the same kind of node.  Suppose `t_1 = Binary (tg, t_(1l),
t_(1r))` and `t_2 = Binary (tg, t_(2l), t_(2r))`.  Since `t_1` and `t_2`
are different, then either `t_(1l) =/= t_(2l)` or `t_(1r) =/= t_(2r)`.
Without loss of generality, assume `t_(1l) =/= t_(2l)`.

Case 2a: Suppose `merkleRoot(t_(1l)) =/= merkleRoot(t_(2l))`.
This means that the inputs to `sha256Compress` that produced
`merkleRoot(t_1)` and `merkleRoot(t_2)` are different and we have found a
collision in the SHA256 compression function.

Case 2b: Suppose `merkleRoot(t_(1l)) = merkleRoot(t_(2l))`.
Then by induction we can find a collision in the SHA256 compression
function.

The cases where `t_1` and `t_2` are both `Unary` or `Leaf` nodes are
handled in a similar way.  The reader can verify the algorithm implied by
the above proof provides an effective method of finding a collision in the
SHA256 compression function.  QED

#### Remark 3
We have filled half of the chunk with `0b0^256` in for the `Unary` and
`Leaf `cases in the definition of `merkleRoot`.  The proof of Theorem 2
does not depend on this, and if we have extra ancillary data for these
types of nodes it can replace the `0b0^256` in this first half of the
chunk.  This is particularly useful for the `Leaf `case because `Leaf`
nodes often hold extra data.  We also remark that if this data is too large
to be represented by a `Word256`, it can instead be hashed with SHA256 and
the hash included instead.

Not all of the inputs to the SHA256 compression function are created
equal.  Only the second argument, the chunk data, is applied to the SHA256
expander.  `merkleRoot` is designed to ensure that the first argument of
the SHA256 compression function is only fed some output of the SHA256
compression function.  In fact, we can prove that the output of the
`merkleRoot` function is always the midstate of some SHA256 hash.  To see
this, let us explicitly separate the `sha256` function into the padding
step, `sha256Pad`, and the recursive hashing step, `unpaddedSha256`.

    sha256Pad : BitString -> List Word512

    sha256IV : Word256

    sha256Loop : Word256 ? List Word512 -> Word256
    sha256Loop (prev, Nil)                := prev
    sha256Loop (prev, Cons (chunk, rest)) := sha256Loop(sha256Compress(prev,
chunk), rest)

    unpaddedSha256 : List Word512 -> Word256
    unpaddedSha256 (chunks) := sha256Loop(sha256IV, chunks)

    sha256 : BitString -> Word256
    sha256 (s) := unpaddedSha256(sha256Pad(s))

Now we can state what we mean when we say that the output of the
`merkleRoot` function is always the midstate of some SHA256 hash.

#### Theorem 4
For all `t : Tree Word256` there exists some `l : List Word512` such that
`merkleRoot(t) = unpaddedSha256(l)`.

Proof.
We construct a function to transform a tree into the required list of
chunks.

    merkleChain : Tree Word256 -> List Word512
    merkleChain (Leaf (t))                := sha256Pad(ApplicationName) +
[0b0^256 ? t]
    merkleChain (Unary (t, child))        := merkleChain(child) + [0b0^256
? t]
    merkleChain (Binary (t, left, right)) := merkleChain(left) +
[merkleRoot(right) ? t]

The reader can verify by induction that

    forall t : Tree Word256. merkleRoot(t) = unpaddedSha256(merkleChain(t)).

QED

### Large Tag Space

If one's application cannot directly represent the space of tags with a
`Word256`, then one can hash the tags and still maintain the
Merkle--Damg?rd property given by Theorem 2, as long as we still have the
property that each tag uniquely determines the kind of node it applies to.

We first note that `Tree` is a functor.

    treeMap : (a -> b) -> Tree a -> Tree b
    treeMap f (Leaf (t))                := Leaf (f(t))
    treeMap f (Unary (t, child))        := Unary (f(t), child)
    treeMap f (Binary (t, left, right)) := Binary (f(t), left, right)

We can hash the tags of a tree.

    hash256Tags : Tree BitString -> Tree Word256
    hash256Tags (t) := treeMap sha256 t

Now we can compute the `merkleRoot` of the result of `hash256Tags`.

#### Theorem 5
Suppose `t_1` and `t_2` are two different `Tree BitString` values such that
any tag occurring in the two trees only occurs in one kind of node.  If
`merkleRoot(hash256Tags(t_1)) = merkleRoot(hash256Tags(t_2))`, then we can
effectively find a collision in the SHA256 compression function.

Proof.
Assume `t_1` and `t_2` are two different `Tree BitString` values such that
`merkleRoot(hash256Tags(t_1)) = merkleRoot(hash256Tags(t_2))`.

Case 1: Suppose `hash256Tags(t_1) = hash256Tags(t_2)`.
This means there must be a collision in the `sha256` function.  By the
Merkle--Damg?rd property of SHA256, this means we can effectively find a
collision in the SHA256 compression function.

Case 2: Suppose `hash256Tags(t_1) =/= hash256Tags(t_2)`.
If the SHA256 hashes of each tag in the two trees uniquely determines the
kinds of their nodes, then we can apply Theorem 2 to conclude that we can
effectively find a collision in the SHA256 compression function.  If the
SHA256 hashes of each tag in the two trees does not uniquely determine the
kinds of their nodes then there are two different tags among the two trees,
`tg_1` and `tg_2`, such that `sha256(tg_1) = sha256(tg_2)`.  Hence there is
a collision in the `sha256` function, and therefore we can effectively find
a collision in the SHA256 compression function.  QED

## Avoiding collisions between merkleRoot and sha256
For the moment, let us assume there is no effective way to find a collision
in the SHA256 compression function.  By the Merkle--Damg?rd property of
SHA256, we cannot effectively find a collision within the sha256 function.
We have shown, by Theorem 2, that merkleRoot has the same Merkle--Damg?rd
property and hence we cannot effectively find a collision within the
merkleRoot function.  However, we may have collisions between the `sha256`
and the `merkleRoot` functions.  That is, we may be able to effectively
find values `s : BitString` and `t : Tree Word256` such that `sha256(s) =
merkleRoot(t)`.

While this may not be a problem for most applications, it turns out that we
can place restrictions on the format of tags to ensure that there are never
collisions between `sha256` and `merkleRoot`.  Define a safe tag of type
`Word256` to be a a value such that one the first 192 bits is set and the
9th last bit is cleared.

#### Theorem 6
Let `t : Tree Word256` be a tree in which every tag is a safe tag.  Suppose
we have some `s : BitString` such that `sha256(s) = merkleRoot(t)`.  Then
we can effectively find a collision in the SHA256 compression function.

Proof.
The last chunk of `sha256Padding(s)` is a padding chunk as defined by the
SHA256 standard.  If we look at the second half of this last chunk, then
according to the padding rules, it can never be the case that one of the
first 192 bits is set and the 9^th last bit is cleared.  Because `t` only
contains safe tags, the inputs to their last compression function in the
computation of `sha256(s)` and `merkleRoot(t)` must be different.
Therefore if `sha256(s) = merkleRoot(t)` then we must have encountered a
collision in the final compression function of the two computations.  QED

#### Remark 7
If we use safe tags we can consider a modified `merkleRoot'` function.

    merkleRoot' : Tree Word256 -> Word256
    merkleRoot' (Leaf (t))                :=
sha256Compress(sha256(ApplicationName),
sha256("") ? t)
    merkleRoot' (Unary (t, child))        := sha256Compress(merkleRoot'(child),
sha256("") ? t)
    merkleRoot' (Binary (t, left, right)) := sha256Compress(merkleRoot'(left),
merkleRoot'(right) ? t)

If we use `merkleRoot'` we no longer require that tags uniquely define
their node types in order to ensure the Merkle--Damg?rd property.  Instead
we can rely on the safe tags to ensure that the use of `sha256(s)` will
never collide with `merkleRoot'(t)`, and therefore nodes of different types
will never collide with each other the `merkleRoot'` computation.  However,
I don't feel this is a particularly good approach, so I will not elaborate
on it further.

Unfortunately, there is no guarantee that the result of `hash256Tags` will
consist of only safe tags, so we cannot use it to avoid collisions between
`sha256` and `merkleRoot ? hash256Tags`.  To remedy this we define an
alternative to `hash256Tags`.

    hash224Tag : BitString -> Word256
    hash224Tag (s) := 0xFFFF ? sha224(s) ? 0x0000

    hash224Tags : Tree BitString -> Tree Word256
    hash224Tags (t) := treeMap hash224Tag t

We see that by appropriately padding the result of `sha224` we guarantee
that `hash224Tag(s)` is a safe tag.

#### Theorem 8
Suppose `t_1` and `t_2` are two different `Tree BitString` values such that
any tag occurring in the two trees only occurs in one kind of node.  If
`merkleRoot(hash224Tags(t_1)) = merkleRoot(hash224Tags(t_2))`, then we can
effectively find either a collision in the SHA256 compression function, or
a collision in SHA224.

#### Remark 9
We can safely replace the `0xFFFF` prefix in `hash224Tag` with one where
the first two bits determine the kind of node in accordance with our
previously defined scheme.

#### Remark 10
Rather than using SHA224 we could use SHA256 and tweak it afterwards to set
the first bit and clear the 9th last bit. This comes at the cost of
effectively using a non-standard hash function.

#### Remark 11
Most of this development not depend specifically on SHA256.  It all works
similarly for SHA512 and other hash functions that compress in a similar
manner.  SHA256 is used as the primary example because one can find
hardware support for it on commodity hardware (for example, see the Intel
SHA extensions).

## Conclusion
We have defined a merkleRoot function for computing Merkle roots of trees
that include annotations per node.  The resulting function uses one SHA256
compression function call per node and supports arbitrary 256-bit
annotations per node.  Arbitrary annotations can be supported at the cost
of more hashing.  We have also shown that by using safe tags we can
additionally get a property that the `merkleRoot` will not effectively
collide with `sha256` function.

## Further Reading
The article [Characterizing Padding Rules of MD Hash Functions Preserving
Collision Security](https://eprint.iacr.org/2009/325.pdf) by Mridul Nandi
provides a nice overview of various options for padding rules.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/c8eb4a67/attachment-0001.html>

From hampus.sjoberg at gmail.com  Mon May 22 09:23:22 2017
From: hampus.sjoberg at gmail.com (=?UTF-8?Q?Hampus_Sj=C3=B6berg?=)
Date: Mon, 22 May 2017 11:23:22 +0200
Subject: [bitcoin-dev] Barry Silbert segwit agreement
In-Reply-To: <2zSehquWdVTgHhfHfQpAHZTGAyzv-XFias7rRsns0j6TpJryz6Fyvst3N0v_2_Q3KsYiyRn9qd9Gb1QLUxh5F11RAlVmvezYN8d4m8q5F-A=@protonmail.ch>
References: <2zSehquWdVTgHhfHfQpAHZTGAyzv-XFias7rRsns0j6TpJryz6Fyvst3N0v_2_Q3KsYiyRn9qd9Gb1QLUxh5F11RAlVmvezYN8d4m8q5F-A=@protonmail.ch>
Message-ID: <CAFMkqK_8CfaPmZgwMqGWpRujmmyGKXhZyxK_tQ6f1OMHKdEMJA@mail.gmail.com>

I'm really happy to see people trying to cooperate to get SegWit activated.
But I'm really unsure about the technicalities about Silbert's proposal.

If we're going to do a hardfork, it makes most sense to assist Johnson in
his spoonnet/forcenet proposals.
Just doing a simple 2MB without fixing anything else is very uninteresting,
and a hardfork without addressing replay protection seems really
unprofessional to me.
And proposing a hardfork in 4 months in the future, is completely insane.
You cannot expect a 100% of all nodes in P2P network to upgrade in 4 months.

I think it's much better to activate BIP141 ASAP, and then hardfork to 2MB
September 2018, or 2019 (together with forcenet/spoonnet).
And if not, BIP148 is gaining momentum once again so that sounds much more
interesting.

Hampus

2017-05-22 8:12 GMT+02:00 shaolinfry via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org>:

> Someone sent me a copy of the Barry Silbert agreement, an agreement forged
> between a select number of participants https://pastebin.com/VuCYteJh
>
> Participants agree to immediately activate Segwit, however, under a
> different activation proposal. Since I have spent the last few months
> researching various activation strategies of the current BIP141 deployment,
> as well as redeployment, I feel I am quite well placed to comment on the
> technicalities.
>
> To be clear, the proposal as far as I can see does not activate BIP141,
> but is a completely new deployment which would be incompatible with the
> BIP141 deployment. I'm not sure how that can be considered "immediate"
> activation. Surely immediate activation would just be for miners to start
> signalling and segwit would be activated in 4-5 weeks. The proposal seems
> to require a lower 80% threshold, I assume because they were unable to
> convince 95% of the hashpower to go trigger activation.
>
> There are a few options to activating segwit now, the first being for 95%
> of hashrate to signal. The second is for the community to deploy BIP148
> UASF which will force miners to signal segwit. Being a UASF it is date
> triggered. The third option is a redeployment of segwit on a new bit, but
> requires waiting for the existing deployment to time out, because all the
> p2p messages and service bits related to segwit must be replaced too (which
> is what BIP149 does).
>
> A fourth option, first suggested to me by James Hilliard, was to make
> BIP148 miner triggered (MASF) with a lower threshold, above 50%. I coded
> this up a few weeks ago https://github.com/bitcoin/
> bitcoin/compare/master...shaolinfry:segsignal but didnt get around to
> posting to the ML yet. This effectively lowers the threshold from 95% to
> 65% as coded, or could be upped to 80% or whatever was preferable.
>
> I think this removes the primary risk of BIP148 causing the creation of
> two chains, and gives an improved chance to get segwit activated quickly
> (assuming a majority of miners wish to go this route). But hash a primary
> disadvantage of still leaving the activation in the hands of miners. If it
> doesn't work out, then BIP149 can then be used as proposed, but it'll be
> even safer because we'll have futher guaged support.
>
> References:
>
> SEGSIGNAL: https://github.com/bitcoin/bitcoin/compare/master...
> shaolinfry:segsignal
> BIP148: https://github.com/bitcoin/bips/blob/master/bip-0148.mediawiki
> BIP149: https://github.com/bitcoin/bips/blob/master/bip-0149.mediawiki
>
> I think the Barry Silbert agreement is very ill considered, and clearly
> lacking peer review from the technical community. Suggestions of a HF in 4
> months are completely unrealistic and without technical merits. But more
> importantly, closed door agreements between selected participants is not
> how to garner consensus to change a $30bn decentralized system. The purpose
> of my email is to try and assist in the "immediate activation of segwit"
> which only requires hashrate to participate; and to provide some techincal
> input since I have done a great deal of research and development into the
> topic.
>
> Given the history we've already passed the point where we should be
> expecting miners to cooperate in lowering their own fee income with a
> capacity increase; but we should be open to all reasonable options in the
> interest in moving things forward in a safe and collaborative way.
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/e17e2ba4/attachment.html>

From truthcoin at gmail.com  Mon May 22 06:17:07 2017
From: truthcoin at gmail.com (Paul Sztorc)
Date: Mon, 22 May 2017 02:17:07 -0400
Subject: [bitcoin-dev] Drivechain -- Request for Discussion
Message-ID: <24f2b447-a237-45eb-ef9f-1a62533fad5c@gmail.com>

Dear list,

I've been working on "drivechain", a sidechain enabling technology, for
some time.

* The technical info site is here: www.drivechain.info
* The changes to Bitcoin are here:
https://github.com/drivechain-project/bitcoin/tree/mainchainBMM
* A Blank sidechain template is here:
https://github.com/drivechain-project/bitcoin/tree/sidechainBMM

As many of you know, I've been seeking feedback in person, at various
conferences and meetups over the past year, most prominently Scaling
Milan. And I intend to continue to seek feedback at Consensus2017 this
week, so if you are in NYC please just walk up and start talking to me!

But I also wanted to ask the list for feedback. Initially, I was
hesitant because I try not to consume reviewers' scarce time until the
author has put in a serious effort. However, I may have waiting too
long, as today it is actually quite close to a working release.


Scaling Implications
---------------------

This upgrade would have significant scaling implications. Since it is
the case that sidechains can be added by soft fork, and since each of
these chains will have its own blockspace, this theoretically removes
the blocksize limit from "the Bitcoin system" (if one includes
sidechains as part of such a system). People who want a LargeBlock
bitcoin can just move their BTC over to such a network [1], and their
txns will have no longer have an impact on "Bitcoin Core". Thus, even
though this upgrade does not actually increase "scalability" per se, it
may in fact put an end to the scalability debate...forever.

This work includes the relatively new concept of "Blind Merged Mining"
[2] which I developed in January to allow SHA256^2 miners to merge-mine
these "drivechains", even if these miners aren't running the actual
sidechain software. The goal is to prevent sidechains from affecting the
levelness of the mining "playing field". BMM is conceptually similar to
ZooKeeV [3] which Peter Todd sketched out in mid-2013. BMM is not
required for drivechain, but it would address some of the last remaining
concerns.


Total Transaction Fees in the Far Future
-----------------------------------------

Some people feel that a maximum blocksize limit is needed to ensure that
future total equilibrium transaction fees are non-negligible. I
presented [4] on why I don't agree, 8 months ago. The reviewers I spoke
to over the last year have stopped bringing this complaint up, but I am
not sure everyone feels that way.


Juxtaposition with a recent "Scaling Compromise"
-------------------------------------------------

Recently, a scalability proposal began to circulate on social media. As
far as I could tell, it goes something like "immediately activate
SegWit, and then HF to double the nonwitness blockspace to 2MB within 12
months". But such a proposal is quite meager, compared to a "LargeBlock
Drivechain". The drivechain is better on both fronts, as it would not
require a hardfork, and could *almost immediately* add _any_ amount of
extra blockspace (specifically, I might expect a BIP101-like LargeBlock
chain that has an 8 MB maxblocksize, which doubles every two years).

In other words, I don't know why anyone would support that proposal over
mine. The only reasons would be either ignorance (ie, unfamiliarity with
drivechain) or because there are still nagging unspoken complaints about
drivechain which I apparently need to hear and address.


Other Thoughts
---------------

Unfortunately, anyone who worked on the "first generation" of sidechain
technology (the skiplist) or the "second generation" (federated /
Liquid), will find that this is very different.

I will admit that I am very pessimistic about any conversation that
involves scalability. It is often said that "talking politics lowers
your IQ by 25 points". Bitcoin scalability conversations seem to drain
50 points. (Instead of conversing, I think people should quietly work on
whatever they are passionate about until their problem either is solved,
or it goes away for some other reason, or until we all agree to just
stop talking about it.)

Cheers,
Paul

[1] http://www.drivechain.info/faq/#can-sidechains-really-help-with-scaling
[2] http://www.truthcoin.info/blog/blind-merged-mining/
[3] https://s3.amazonaws.com/peter.todd/bitcoin-wizards-13-10-17.log
[4]
https://www.youtube.com/watch?v=YErLEuOi3xU&list=PLw8-6ARlyVciNjgS_NFhAu-qt7HPf_dtg&index=4


From sanch0panza at protonmail.com  Sun May 21 11:57:10 2017
From: sanch0panza at protonmail.com (Sancho Panza)
Date: Sun, 21 May 2017 07:57:10 -0400
Subject: [bitcoin-dev] BIP135 implementation on Bitcoin Core available for
	review
Message-ID: <ePqp1RFJNIQRTkQfHBZlpRsStWoXlPCcEb5_IuW7nQOUN-gTEOXP_C94fDkL5HOqLuEA0bA2cUw09JuC5_tmYJRh2Kt_lujjj_VqC2PU15A=@protonmail.com>

I'm pleased to announce the completion of a Bitcoin Core implementation of BIP135:

https://github.com/bitcoin/bitcoin/pull/10437

Review comments appreciated, and happy to discuss / answer questions about the implementation in this thread or on Github.

Sancho

BIP135: https://github.com/bitcoin/bips/blob/master/bip-0135.mediawiki
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170521/8ec03f0b/attachment.html>

From daniele.pinna at gmail.com  Mon May 22 12:29:12 2017
From: daniele.pinna at gmail.com (Daniele Pinna)
Date: Mon, 22 May 2017 14:29:12 +0200
Subject: [bitcoin-dev] Barry Silbert segwit agreement
Message-ID: <CAEgR2PFGaTn8tqC8fMG9-9E31LauX2erUirx_6vURNrXSgYzLw@mail.gmail.com>

I couldn't agree more. It would require however for the Devs to throw their
weight behind this with a lot of momentum. Spoonnet has been under
development for quite some time now. Counter offering SegWit plus Spoonnet
12-24 months later would be a very progressive stance that I think would
catch the interest of large swaths of the community. I'd be curious to hear
Johnson's opinion on this. How much more testing would his proposal require?

Daniele


----------------------------------------------------------------------
>
> Message: 1
> Date: Mon, 22 May 2017 11:23:22 +0200
> From: Hampus Sj?berg <hampus.sjoberg at gmail.com>
> To: shaolinfry <shaolinfry at protonmail.ch>
> Cc: Bitcoin Protocol Discussion
>         <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] Barry Silbert segwit agreement
> Message-ID:
>         <CAFMkqK_8CfaPmZgwMqGWpRujmmyGKXhZyxK_
> tQ6f1OMHKdEMJA at mail.gmail.com>
> Content-Type: text/plain; charset="utf-8"
>
> I'm really happy to see people trying to cooperate to get SegWit activated.
> But I'm really unsure about the technicalities about Silbert's proposal.
>
> If we're going to do a hardfork, it makes most sense to assist Johnson in
> his spoonnet/forcenet proposals.
> Just doing a simple 2MB without fixing anything else is very uninteresting,
> and a hardfork without addressing replay protection seems really
> unprofessional to me.
> And proposing a hardfork in 4 months in the future, is completely insane.
> You cannot expect a 100% of all nodes in P2P network to upgrade in 4
> months.
>
> I think it's much better to activate BIP141 ASAP, and then hardfork to 2MB
> September 2018, or 2019 (together with forcenet/spoonnet).
> And if not, BIP148 is gaining momentum once again so that sounds much more
> interesting.
>
> Hampus
>
> 2017-05-22 8:12 GMT+02:00 shaolinfry via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org>:
>
> > Someone sent me a copy of the Barry Silbert agreement, an agreement
> forged
> > between a select number of participants https://pastebin.com/VuCYteJh
> >
> > Participants agree to immediately activate Segwit, however, under a
> > different activation proposal. Since I have spent the last few months
> > researching various activation strategies of the current BIP141
> deployment,
> > as well as redeployment, I feel I am quite well placed to comment on the
> > technicalities.
> >
> > To be clear, the proposal as far as I can see does not activate BIP141,
> > but is a completely new deployment which would be incompatible with the
> > BIP141 deployment. I'm not sure how that can be considered "immediate"
> > activation. Surely immediate activation would just be for miners to start
> > signalling and segwit would be activated in 4-5 weeks. The proposal seems
> > to require a lower 80% threshold, I assume because they were unable to
> > convince 95% of the hashpower to go trigger activation.
> >
> > There are a few options to activating segwit now, the first being for 95%
> > of hashrate to signal. The second is for the community to deploy BIP148
> > UASF which will force miners to signal segwit. Being a UASF it is date
> > triggered. The third option is a redeployment of segwit on a new bit, but
> > requires waiting for the existing deployment to time out, because all the
> > p2p messages and service bits related to segwit must be replaced too
> (which
> > is what BIP149 does).
> >
> > A fourth option, first suggested to me by James Hilliard, was to make
> > BIP148 miner triggered (MASF) with a lower threshold, above 50%. I coded
> > this up a few weeks ago https://github.com/bitcoin/
> > bitcoin/compare/master...shaolinfry:segsignal but didnt get around to
> > posting to the ML yet. This effectively lowers the threshold from 95% to
> > 65% as coded, or could be upped to 80% or whatever was preferable.
> >
> > I think this removes the primary risk of BIP148 causing the creation of
> > two chains, and gives an improved chance to get segwit activated quickly
> > (assuming a majority of miners wish to go this route). But hash a primary
> > disadvantage of still leaving the activation in the hands of miners. If
> it
> > doesn't work out, then BIP149 can then be used as proposed, but it'll be
> > even safer because we'll have futher guaged support.
> >
> > References:
> >
> > SEGSIGNAL: https://github.com/bitcoin/bitcoin/compare/master...
> > shaolinfry:segsignal
> > BIP148: https://github.com/bitcoin/bips/blob/master/bip-0148.mediawiki
> > BIP149: https://github.com/bitcoin/bips/blob/master/bip-0149.mediawiki
> >
> > I think the Barry Silbert agreement is very ill considered, and clearly
> > lacking peer review from the technical community. Suggestions of a HF in
> 4
> > months are completely unrealistic and without technical merits. But more
> > importantly, closed door agreements between selected participants is not
> > how to garner consensus to change a $30bn decentralized system. The
> purpose
> > of my email is to try and assist in the "immediate activation of segwit"
> > which only requires hashrate to participate; and to provide some
> techincal
> > input since I have done a great deal of research and development into the
> > topic.
> >
> > Given the history we've already passed the point where we should be
> > expecting miners to cooperate in lowering their own fee income with a
> > capacity increase; but we should be open to all reasonable options in the
> > interest in moving things forward in a safe and collaborative way.
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/7b48551a/attachment.html>

From pete at petertodd.org  Mon May 22 13:33:35 2017
From: pete at petertodd.org (Peter Todd)
Date: Mon, 22 May 2017 09:33:35 -0400
Subject: [bitcoin-dev] Drivechain -- Request for Discussion
In-Reply-To: <24f2b447-a237-45eb-ef9f-1a62533fad5c@gmail.com>
References: <24f2b447-a237-45eb-ef9f-1a62533fad5c@gmail.com>
Message-ID: <20170522133335.GA17194@fedora-23-dvm>

On Mon, May 22, 2017 at 02:17:07AM -0400, Paul Sztorc via bitcoin-dev wrote:
> This work includes the relatively new concept of "Blind Merged Mining"
> [2] which I developed in January to allow SHA256^2 miners to merge-mine
> these "drivechains", even if these miners aren't running the actual
> sidechain software. The goal is to prevent sidechains from affecting the
> levelness of the mining "playing field". BMM is conceptually similar to
> ZooKeeV [3] which Peter Todd sketched out in mid-2013. BMM is not
> required for drivechain, but it would address some of the last remaining
> concerns.

Thanks for the credit, although I think the security properties of what you're
proposing are very different - and much weaker - than what I proposed in
Zookeyv.

As you state in [2] "if miners never validate sidechains at all, whoever bids
the most for the chain (on a continuous basis), can spam a 3-month long stream
of invalid headers, and then withdraw all of the coins deposited to the
sidechain." and "Since the mining is blind, and the sidechain-withdrawal
security-level is SPV, miners who remain blind forever have no way of telling
who ?should? really get the funds."

Finally, you suggest that in this event, miners *do* have to upgrade to a full
node, an expensive and time-consuming operation (and one that may be impossible
for some miners if necessary data isn't available).

It's unclear to me what the incentive is for miners to do any of this. Could
you explain in more detail what that incentive is?


> [2] http://www.truthcoin.info/blog/blind-merged-mining/
> [3] https://s3.amazonaws.com/peter.todd/bitcoin-wizards-13-10-17.log

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/c4d63e2f/attachment.sig>

From pete at petertodd.org  Mon May 22 14:05:48 2017
From: pete at petertodd.org (Peter Todd)
Date: Mon, 22 May 2017 10:05:48 -0400
Subject: [bitcoin-dev] A Method for Computing Merkle Roots of Annotated
 Binary Trees
In-Reply-To: <CAMZUoK=f3hXHkqJBDfiLGSrgXi_ppgyH6+XWD9W54EYFWLm1+Q@mail.gmail.com>
References: <CAMZUoK=f3hXHkqJBDfiLGSrgXi_ppgyH6+XWD9W54EYFWLm1+Q@mail.gmail.com>
Message-ID: <20170522140548.GA17732@fedora-23-dvm>

On Mon, May 22, 2017 at 03:05:49AM -0400, Russell O'Connor via bitcoin-dev wrote:
>     MerkleRoot := SHA256(SHA256(LeftRoot ? RightRoot))
>     sha256Compress : Word256 ? Word512 -> Word256

To be clear, what math operations do you mean by "?" and "?"?

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/e3d797df/attachment-0001.sig>

From pete at petertodd.org  Mon May 22 14:09:19 2017
From: pete at petertodd.org (Peter Todd)
Date: Mon, 22 May 2017 10:09:19 -0400
Subject: [bitcoin-dev] A proposal to reintroduce the disabled script
 opcodes
In-Reply-To: <CAK9dXBSg+wzAZw7_xPXRVvx1uZzjAEE8nuvj0vkdSGD-yTfwhQ@mail.gmail.com>
References: <CAK9dXBSg+wzAZw7_xPXRVvx1uZzjAEE8nuvj0vkdSGD-yTfwhQ@mail.gmail.com>
Message-ID: <20170522140919.GA17878@fedora-23-dvm>

On Fri, May 19, 2017 at 09:07:41AM +0300, Mark Boldyrev via bitcoin-dev wrote:
> Back in 2010, there was a bug found in Core which allowed denial-of-service
> attacks due to the software crashing on some machines while executing a
> script - see CVE-2010-537.
> I believe the removed ("disabled") opcodes should be re-introduced along
> with a standardized behavior definition.
> For example, when execution of an opcode results in an arithmetic error,
> such as OP_DIV with a zero divisor, the script should exit and fail.
> The string splice opcodes should also check their arguments for
> correctness, etc.
> 
> These opcodes would enhance the flexibility of scripts and allow
> sophisticated native smart contracts to be created.

It'd help your case if you gave us some examples of such scripts being used.

See the CHECKSEQUENCEVERIFY and my own CHECKLOCKTIMEVERIFY bips for examples of
how to write up such use-cases.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/91bc394e/attachment.sig>

From eth3rs at gmail.com  Mon May 22 14:41:40 2017
From: eth3rs at gmail.com (Ethan Heilman)
Date: Mon, 22 May 2017 10:41:40 -0400
Subject: [bitcoin-dev] A proposal to reintroduce the disabled script
	opcodes
In-Reply-To: <20170522140919.GA17878@fedora-23-dvm>
References: <CAK9dXBSg+wzAZw7_xPXRVvx1uZzjAEE8nuvj0vkdSGD-yTfwhQ@mail.gmail.com>
	<20170522140919.GA17878@fedora-23-dvm>
Message-ID: <CAEM=y+XbHsCQ__u-oVqp8AjWoR29G45ZRDRDdFAMYJhqtRN0Pg@mail.gmail.com>

>It'd help your case if you gave us some examples of such scripts being
used.

I want OP_CAT so that I can securely and compactly verify many hashes and
hash preimages. This would shrink offchain Tumblebit transactions
significantly.

For instance if I want a transaction TxA which checks that a transaction
TxB releases preimages x1,x2,...,x10 such that
y1=H(x1), y2=H(x2),...,y10=H(x10). Currently I just put y1,...y10 and check
that the preimahes hash correctly. With OP_CAT I would only have to store
one hash in TxA, yhash

ytotal = H(OP_CAT(H(OP_CAT(y1, y2)),y3)...y10)

TxA could then just hash all the preimages supplied by TxB and confirm they
hash to TxA. This would reduce the size of TxA from approx 10*32B to
32+10*16B. I have a version which improves this further but it is more
complex.

Most of the math OP codes aren't particularly helpful due to their 32bit
nature and their strange overflow behavior.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/7a13e539/attachment.html>

From truthcoin at gmail.com  Mon May 22 15:30:46 2017
From: truthcoin at gmail.com (Paul Sztorc)
Date: Mon, 22 May 2017 17:30:46 +0200
Subject: [bitcoin-dev] Drivechain -- Request for Discussion
In-Reply-To: <20170522133335.GA17194@fedora-23-dvm>
References: <24f2b447-a237-45eb-ef9f-1a62533fad5c@gmail.com>
	<20170522133335.GA17194@fedora-23-dvm>
Message-ID: <CA+XQW1h22jmwq+qN69UgOhE0LZqmUDpnrmF0ZM-+2ZpoPsTrwQ@mail.gmail.com>

Charlie, I'll be mostly in the tech track, of course. And I've already
planned to meet RSK guys after their event tomorrow.

Ryan, the more review the better. We aren't in any direct rush, other than
the natural desire to have cool things as early as possible.

Peter, responses below:

On May 22, 2017 9:33 AM, "Peter Todd" <pete at petertodd.org> wrote:

On Mon, May 22, 2017 at 02:17:07AM -0400, Paul Sztorc via bitcoin-dev wrote:
> This work includes the relatively new concept of "Blind Merged Mining"
> [2] which I developed in January to allow SHA256^2 miners to merge-mine
> these "drivechains", even if these miners aren't running the actual
> sidechain software. The goal is to prevent sidechains from affecting the
> levelness of the mining "playing field". BMM is conceptually similar to
> ZooKeeV [3] which Peter Todd sketched out in mid-2013. BMM is not
> required for drivechain, but it would address some of the last remaining
> concerns.

Thanks for the credit, although I think the security properties of what
you're
proposing are very different - and much weaker - than what I proposed in
Zookeyv.


As you state in [2] "if miners never validate sidechains at all, whoever
bids
the most for the chain (on a continuous basis), can spam a 3-month long
stream
of invalid headers, and then withdraw all of the coins deposited to the
sidechain." and "Since the mining is blind, and the sidechain-withdrawal
security-level is SPV, miners who remain blind forever have no way of
telling
who ?should? really get the funds."

Finally, you suggest that in this event, miners *do* have to upgrade to a
full
node, an expensive and time-consuming operation (and one that may be
impossible
for some miners if necessary data isn't available).


Surprisingly, this requirement (or, more precisely, this incentive) does
not effect miners relative to each other. The incentive to upgrade is only
for the purpose of preventing a "theft" -- defined as: an improper
withdrawal from a sidechain. It is not about miner revenues or the ability
to mine generally (or conduct BMM specifically). The costs of such a theft
(decrease in market price, decrease in future transaction fee levels) would
be shared collectively by all future miners. Therefore, it would have no
effect on miners relative to each other.

Moreover, miners have other recourse if they are unable to run the node.
They can adopt a policy of simply rejecting ("downvoting") any withdrawals
that they don't understand. This would pause the withdraw process until
enough miners understand enough of what is going on to proceed with it.

Finally, the point in dispute is a single, infrequent, true/false question.
So miners may resort to semi-trusted methods to supplement their decision.
In other words, they can just ask people they trust, if the withdrawal is
correct or not. It is up to users to decide if they are comfortable with
these risks, if/when they decide to deposit to a sidechain.


It's unclear to me what the incentive is for miners to do any of this. Could
you explain in more detail what that incentive is?


It is a matter of comparing the costs and benefits. Ignoring theft, the
costs are near-zero, and the benefits are >0. Specifically, they are: a
higher BTC price and greater transaction fees. Theft is discouraged by
attempting to tie a theft to a loss of confidence in the miners, as
described in the spec/website.
In general the incentives are very similar to those of Bitcoin itself.

Paul



> [2] http://www.truthcoin.info/blog/blind-merged-mining/
> [3] https://s3.amazonaws.com/peter.todd/bitcoin-wizards-13-10-17.log

--
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/9bb81395/attachment.html>

From ZmnSCPxj at protonmail.com  Mon May 22 14:39:19 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 22 May 2017 10:39:19 -0400
Subject: [bitcoin-dev] Drivechain -- Request for Discussion
In-Reply-To: <24f2b447-a237-45eb-ef9f-1a62533fad5c@gmail.com>
References: <24f2b447-a237-45eb-ef9f-1a62533fad5c@gmail.com>
Message-ID: <dhstGQudLBiwjDlaRrmMfy-ixwvXcwMr1CzCkPKh285RLICGZixkbdwpTDc2Sgz8eYIqSem8lwxW6QeJCD7aFfwQjLDnZ2NmOw0Zzd-KgSs=@protonmail.com>

Good morning Paul,

I read only http://www.truthcoin.info/blog/blind-merged-mining/

From just this document, I can't see a good justification for believing that a main->side locking transaction can be safely spent into a side->main unlocking transaction. Do you have a better explanation?

OP_is_h_in_coinbase, as described, does not seem to protect against a sidechain reorg in your next section of the document. If I attempt to spend a main->side locking transaction on the basis of a "mistaken" side block #49, what prevents me from this sequence:

1. Put a side:side->main transaction into a block together with TheDAO's hacked money.
2. Wait for a reorg to revert TheDAO.
3. Spend my now-free-in-the-reorg funds on Lightning Network to get mainchain funds.
4. Create a main:side->main transaction with the side:side->main transaction in the TheDAO-hacked block as witness.
5. Get another set of mainchain funds from the same sidechain funds.

So far, the only good side->main transfer I know of is in Blockstream's original sidechains paper, with the main:side->main transaction spending into a timelocked transaction that may be burned if a reorg proof is submitted (i.e. you try to create a main:side->main transaction with the side:side->main transaction in the mistaken #49 and #50 as your proof, but someone else can come along and show a corrected #49, #50, #51 without your side:side->main transaction and burn your funds). Is your proposal at the technical level actually similar, or does it truly seem to be riskier? It seems to me that your OP_is_h_in_coinbase should scan a series of sidechain block headers backed by mainchain (meaning at the minimum that sidechains should have some common header format prefix), rather than just mainchain depth as your article seems to imply.

Also, blinded merge mining seems strictly inferior to proof-of-burn: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-December/007012.html

Proof-of-burn integrates a lottery to reduce the ability of a mainchain-rich attacker to reorg the sidechain by burning its greater funds. However it still seems to me that a rich attacker can simply make more bets in that scheme by some trivial modification of the side block. Blind merged mining seems strictly inferior as a rich attacker can simply reorg the sidechain outright without playing such games.

Or is your proposal strictly for centralized sidechains, where only one entity creates side blocks? How does your proposal handle multiple side block creators on the same sidechain, with the possibility that chain splits occur?

Regarding your dig about people who dislike data centers, the main issue with miners blindly accepting sidechain commitments is that it violates "Don't trust, verify", not that allows datacenters to be slightly smaller by not including side:nodes.

Regards,
ZmnSCPxj

Sent with ProtonMail Secure Email.

-------- Original Message --------
Subject: [bitcoin-dev] Drivechain -- Request for Discussion
Local Time: May 22, 2017 6:17 AM
UTC Time: May 22, 2017 6:17 AM
From: bitcoin-dev at lists.linuxfoundation.org
To: Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>

Dear list,

I've been working on "drivechain", a sidechain enabling technology, for
some time.

* The technical info site is here: www.drivechain.info
* The changes to Bitcoin are here:
https://github.com/drivechain-project/bitcoin/tree/mainchainBMM
* A Blank sidechain template is here:
https://github.com/drivechain-project/bitcoin/tree/sidechainBMM

As many of you know, I've been seeking feedback in person, at various
conferences and meetups over the past year, most prominently Scaling
Milan. And I intend to continue to seek feedback at Consensus2017 this
week, so if you are in NYC please just walk up and start talking to me!

But I also wanted to ask the list for feedback. Initially, I was
hesitant because I try not to consume reviewers' scarce time until the
author has put in a serious effort. However, I may have waiting too
long, as today it is actually quite close to a working release.

Scaling Implications
---------------------

This upgrade would have significant scaling implications. Since it is
the case that sidechains can be added by soft fork, and since each of
these chains will have its own blockspace, this theoretically removes
the blocksize limit from "the Bitcoin system" (if one includes
sidechains as part of such a system). People who want a LargeBlock
bitcoin can just move their BTC over to such a network [1], and their
txns will have no longer have an impact on "Bitcoin Core". Thus, even
though this upgrade does not actually increase "scalability" per se, it
may in fact put an end to the scalability debate...forever.

This work includes the relatively new concept of "Blind Merged Mining"
[2] which I developed in January to allow SHA256^2 miners to merge-mine
these "drivechains", even if these miners aren't running the actual
sidechain software. The goal is to prevent sidechains from affecting the
levelness of the mining "playing field". BMM is conceptually similar to
ZooKeeV [3] which Peter Todd sketched out in mid-2013. BMM is not
required for drivechain, but it would address some of the last remaining
concerns.

Total Transaction Fees in the Far Future
-----------------------------------------

Some people feel that a maximum blocksize limit is needed to ensure that
future total equilibrium transaction fees are non-negligible. I
presented [4] on why I don't agree, 8 months ago. The reviewers I spoke
to over the last year have stopped bringing this complaint up, but I am
not sure everyone feels that way.

Juxtaposition with a recent "Scaling Compromise"
-------------------------------------------------

Recently, a scalability proposal began to circulate on social media. As
far as I could tell, it goes something like "immediately activate
SegWit, and then HF to double the nonwitness blockspace to 2MB within 12
months". But such a proposal is quite meager, compared to a "LargeBlock
Drivechain". The drivechain is better on both fronts, as it would not
require a hardfork, and could *almost immediately* add _any_ amount of
extra blockspace (specifically, I might expect a BIP101-like LargeBlock
chain that has an 8 MB maxblocksize, which doubles every two years).

In other words, I don't know why anyone would support that proposal over
mine. The only reasons would be either ignorance (ie, unfamiliarity with
drivechain) or because there are still nagging unspoken complaints about
drivechain which I apparently need to hear and address.

Other Thoughts
---------------

Unfortunately, anyone who worked on the "first generation" of sidechain
technology (the skiplist) or the "second generation" (federated /
Liquid), will find that this is very different.

I will admit that I am very pessimistic about any conversation that
involves scalability. It is often said that "talking politics lowers
your IQ by 25 points". Bitcoin scalability conversations seem to drain
50 points. (Instead of conversing, I think people should quietly work on
whatever they are passionate about until their problem either is solved,
or it goes away for some other reason, or until we all agree to just
stop talking about it.)

Cheers,
Paul

[1] http://www.drivechain.info/faq/#can-sidechains-really-help-with-scaling
[2] http://www.truthcoin.info/blog/blind-merged-mining/
[3] https://s3.amazonaws.com/peter.todd/bitcoin-wizards-13-10-17.log
[4]
https://www.youtube.com/watch?v=YErLEuOi3xU&list=PLw8-6ARlyVciNjgS_NFhAu-qt7HPf_dtg&index=4

_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/b545bb82/attachment-0001.html>

From pete at petertodd.org  Mon May 22 16:14:04 2017
From: pete at petertodd.org (Peter Todd)
Date: Mon, 22 May 2017 12:14:04 -0400
Subject: [bitcoin-dev] A proposal to reintroduce the disabled script
 opcodes
In-Reply-To: <CAEM=y+XbHsCQ__u-oVqp8AjWoR29G45ZRDRDdFAMYJhqtRN0Pg@mail.gmail.com>
References: <CAK9dXBSg+wzAZw7_xPXRVvx1uZzjAEE8nuvj0vkdSGD-yTfwhQ@mail.gmail.com>
	<20170522140919.GA17878@fedora-23-dvm>
	<CAEM=y+XbHsCQ__u-oVqp8AjWoR29G45ZRDRDdFAMYJhqtRN0Pg@mail.gmail.com>
Message-ID: <20170522161404.GA18885@fedora-23-dvm>

On Mon, May 22, 2017 at 10:41:40AM -0400, Ethan Heilman wrote:
> >It'd help your case if you gave us some examples of such scripts being
> used.
> 
> I want OP_CAT so that I can securely and compactly verify many hashes and
> hash preimages. This would shrink offchain Tumblebit transactions
> significantly.
> 
> For instance if I want a transaction TxA which checks that a transaction
> TxB releases preimages x1,x2,...,x10 such that
> y1=H(x1), y2=H(x2),...,y10=H(x10). Currently I just put y1,...y10 and check
> that the preimahes hash correctly. With OP_CAT I would only have to store
> one hash in TxA, yhash
> 
> ytotal = H(OP_CAT(H(OP_CAT(y1, y2)),y3)...y10)
> 
> TxA could then just hash all the preimages supplied by TxB and confirm they
> hash to TxA. This would reduce the size of TxA from approx 10*32B to
> 32+10*16B. I have a version which improves this further but it is more
> complex.
> 
> Most of the math OP codes aren't particularly helpful due to their 32bit
> nature and their strange overflow behavior.

Great! That's exactly the type of justifying use-case we need for a BIP.

An OP_CAT will have to have limits on maximum output size; how big an output
does your application need?

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/5c5d8739/attachment.sig>

From truthcoin at gmail.com  Mon May 22 16:19:14 2017
From: truthcoin at gmail.com (Paul Sztorc)
Date: Mon, 22 May 2017 18:19:14 +0200
Subject: [bitcoin-dev] Drivechain -- Request for Discussion
In-Reply-To: <dhstGQudLBiwjDlaRrmMfy-ixwvXcwMr1CzCkPKh285RLICGZixkbdwpTDc2Sgz8eYIqSem8lwxW6QeJCD7aFfwQjLDnZ2NmOw0Zzd-KgSs=@protonmail.com>
References: <24f2b447-a237-45eb-ef9f-1a62533fad5c@gmail.com>
	<dhstGQudLBiwjDlaRrmMfy-ixwvXcwMr1CzCkPKh285RLICGZixkbdwpTDc2Sgz8eYIqSem8lwxW6QeJCD7aFfwQjLDnZ2NmOw0Zzd-KgSs=@protonmail.com>
Message-ID: <CA+XQW1jZpJ9wnEg47fouyywL09=_vU8dMP3owkkuNqRvzTZUDg@mail.gmail.com>

On May 22, 2017 10:39 AM, "ZmnSCPxj" <ZmnSCPxj at protonmail.com> wrote:

Good morning Paul,

I read only http://www.truthcoin.info/blog/blind-merged-mining/

>From just this document, I can't see a good justification for believing
that a main->side locking transaction can be safely spent into a side->main
unlocking transaction.  Do you have a better explanation?


Yes, a better explanation is in the drivechain spec, at:
http://www.truthcoin.info/blog/drivechain/

What you read is only an introduction of BMM. You may also consult the
notes (at the bottom of the BMM post) or the code, although this is time
consuming of course.


If I attempt to spend a main->side locking transaction on the basis of a
"mistaken" side block #49, what prevents me from this sequence:


The literal answer to your question is that mainchain Bitcoin will notice
that, for the second withdrawal, the sum of the inputs is less than the sum
of the outputs and they the transaction is therefore invalid.


1.  Put a side:side->main transaction into a block together with TheDAO's
hacked money.

So far, the only good side->main transfer I know of is in Blockstream's
original sidechains paper, with the main:side->main transaction ... Is your
proposal at the technical level actually similar, or does it truly seem to
be riskier?


I feel that my proposal is more secure, as it can operate healthily and
quickly while using spv proofs which are much slower and much much easier
to audit.


seems to me that your OP_is_h_in_coinbase should scan a series of sidechain
block headers backed by mainchain (meaning at the minimum that sidechains
should have some common header format prefix), rather than just mainchain
depth as your article seems to imply.


How would security be improved as a result? In either case, 51% of hashrate
can cause a reorg. The sidechain software itself does scan block headers,
of course.


Blind merged mining seems strictly inferior ... a rich attacker can simply
reorg the sidechain outright without playing such games.


In the future, when there is no block subsidy, a rich attacker can also do
that in mainchain Bitcoin.


Or is your proposal strictly for centralized sidechains, where only one
entity creates side blocks?


Not at all.

How does your proposal handle multiple side block creators on the same
sidechain, with the possibility that chain splits occur?


The side block is only "mined" if it is committed to in a mainchain Bitcoin
blog, and each mainchain block can only contain one block per sidechain. In
this way, drivechain sidechains are different from classical Namecoin
merged mining (where one _could_ run the entire system, mining included,
without interfacing with Bitcoin at all).


Regarding your dig about people who dislike data centers, the main issue
with miners blindly accepting sidechain commitments is that it violates
"Don't trust, verify", not that allows datacenters to be slightly smaller
by not including side:nodes.


As I explain early on, in earlier rounds of peer review, the focus was on
harms the sidechain technology might do to mainchain Bitcoin, and the
"datacenter point" was specifically the chief objection raised. So I am
afraid you are entirely incorrect.

In point of fact, the transactions *are* validated...by sidechain full
nodes, same as Bitcoin proper.

Paul


Regards,
ZmnSCPxj


Sent with ProtonMail Secure Email.

-------- Original Message --------
Subject: [bitcoin-dev] Drivechain -- Request for Discussion
Local Time: May 22, 2017 6:17 AM
UTC Time: May 22, 2017 6:17 AM
From: bitcoin-dev at lists.linuxfoundation.org
To: Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>

Dear list,

I've been working on "drivechain", a sidechain enabling technology, for
some time.

* The technical info site is here: www.drivechain.info
* The changes to Bitcoin are here:
https://github.com/drivechain-project/bitcoin/tree/mainchainBMM
* A Blank sidechain template is here:
https://github.com/drivechain-project/bitcoin/tree/sidechainBMM

As many of you know, I've been seeking feedback in person, at various
conferences and meetups over the past year, most prominently Scaling
Milan. And I intend to continue to seek feedback at Consensus2017 this
week, so if you are in NYC please just walk up and start talking to me!

But I also wanted to ask the list for feedback. Initially, I was
hesitant because I try not to consume reviewers' scarce time until the
author has put in a serious effort. However, I may have waiting too
long, as today it is actually quite close to a working release.


Scaling Implications
---------------------

This upgrade would have significant scaling implications. Since it is
the case that sidechains can be added by soft fork, and since each of
these chains will have its own blockspace, this theoretically removes
the blocksize limit from "the Bitcoin system" (if one includes
sidechains as part of such a system). People who want a LargeBlock
bitcoin can just move their BTC over to such a network [1], and their
txns will have no longer have an impact on "Bitcoin Core". Thus, even
though this upgrade does not actually increase "scalability" per se, it
may in fact put an end to the scalability debate...forever.

This work includes the relatively new concept of "Blind Merged Mining"
[2] which I developed in January to allow SHA256^2 miners to merge-mine
these "drivechains", even if these miners aren't running the actual
sidechain software. The goal is to prevent sidechains from affecting the
levelness of the mining "playing field". BMM is conceptually similar to
ZooKeeV [3] which Peter Todd sketched out in mid-2013. BMM is not
required for drivechain, but it would address some of the last remaining
concerns.


Total Transaction Fees in the Far Future
-----------------------------------------

Some people feel that a maximum blocksize limit is needed to ensure that
future total equilibrium transaction fees are non-negligible. I
presented [4] on why I don't agree, 8 months ago. The reviewers I spoke
to over the last year have stopped bringing this complaint up, but I am
not sure everyone feels that way.


Juxtaposition with a recent "Scaling Compromise"
-------------------------------------------------

Recently, a scalability proposal began to circulate on social media. As
far as I could tell, it goes something like "immediately activate
SegWit, and then HF to double the nonwitness blockspace to 2MB within 12
months". But such a proposal is quite meager, compared to a "LargeBlock
Drivechain". The drivechain is better on both fronts, as it would not
require a hardfork, and could *almost immediately* add _any_ amount of
extra blockspace (specifically, I might expect a BIP101-like LargeBlock
chain that has an 8 MB maxblocksize, which doubles every two years).

In other words, I don't know why anyone would support that proposal over
mine. The only reasons would be either ignorance (ie, unfamiliarity with
drivechain) or because there are still nagging unspoken complaints about
drivechain which I apparently need to hear and address.


Other Thoughts
---------------

Unfortunately, anyone who worked on the "first generation" of sidechain
technology (the skiplist) or the "second generation" (federated /
Liquid), will find that this is very different.

I will admit that I am very pessimistic about any conversation that
involves scalability. It is often said that "talking politics lowers
your IQ by 25 points". Bitcoin scalability conversations seem to drain
50 points. (Instead of conversing, I think people should quietly work on
whatever they are passionate about until their problem either is solved,
or it goes away for some other reason, or until we all agree to just
stop talking about it.)

Cheers,
Paul

[1] http://www.drivechain.info/faq/#can-sidechains-really-help-with-scaling
[2] http://www.truthcoin.info/blog/blind-merged-mining/
[3] https://s3.amazonaws.com/peter.todd/bitcoin-wizards-13-10-17.log
[4]
https://www.youtube.com/watch?v=YErLEuOi3xU&list=PLw8-
6ARlyVciNjgS_NFhAu-qt7HPf_dtg&index=4

_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/1d29ff66/attachment-0001.html>

From eth3rs at gmail.com  Mon May 22 16:43:11 2017
From: eth3rs at gmail.com (Ethan Heilman)
Date: Mon, 22 May 2017 12:43:11 -0400
Subject: [bitcoin-dev] A proposal to reintroduce the disabled script
	opcodes
In-Reply-To: <20170522161404.GA18885@fedora-23-dvm>
References: <CAK9dXBSg+wzAZw7_xPXRVvx1uZzjAEE8nuvj0vkdSGD-yTfwhQ@mail.gmail.com>
	<20170522140919.GA17878@fedora-23-dvm>
	<CAEM=y+XbHsCQ__u-oVqp8AjWoR29G45ZRDRDdFAMYJhqtRN0Pg@mail.gmail.com>
	<20170522161404.GA18885@fedora-23-dvm>
Message-ID: <CAEM=y+W5iPLkK3yXnGHG+EhMeL9D2K57kB418nHVD5ihRKKP0A@mail.gmail.com>

My OP_CAT usecase only needs to glue together hash outputs, so two 32
Bytes inputs generating a 64 Byte output. However increasing this
would enable additional space savings. I would push for an OP_CAT
which can generate an output of no greater than 512 Bytes. Is there
are maximum byte vectors size for script?

The ideal instruction for this usecase be an instruction that pops N
vectors of the stack, concatenates them together and hashes them.
OP_CATHASH256(N) --> OP_HASH256(v1||v2||..||vN)
where || denotes concatenation. You could do this in a streaming
fashion so that memory usage would never exceed 32 Bytes regardless of
the size of the input vectors.

However I recognize that OP_CAT is more generally useful and it
already in scripts but just disabled.




On Mon, May 22, 2017 at 12:14 PM, Peter Todd <pete at petertodd.org> wrote:
> On Mon, May 22, 2017 at 10:41:40AM -0400, Ethan Heilman wrote:
>> >It'd help your case if you gave us some examples of such scripts being
>> used.
>>
>> I want OP_CAT so that I can securely and compactly verify many hashes and
>> hash preimages. This would shrink offchain Tumblebit transactions
>> significantly.
>>
>> For instance if I want a transaction TxA which checks that a transaction
>> TxB releases preimages x1,x2,...,x10 such that
>> y1=H(x1), y2=H(x2),...,y10=H(x10). Currently I just put y1,...y10 and check
>> that the preimahes hash correctly. With OP_CAT I would only have to store
>> one hash in TxA, yhash
>>
>> ytotal = H(OP_CAT(H(OP_CAT(y1, y2)),y3)...y10)
>>
>> TxA could then just hash all the preimages supplied by TxB and confirm they
>> hash to TxA. This would reduce the size of TxA from approx 10*32B to
>> 32+10*16B. I have a version which improves this further but it is more
>> complex.
>>
>> Most of the math OP codes aren't particularly helpful due to their 32bit
>> nature and their strange overflow behavior.
>
> Great! That's exactly the type of justifying use-case we need for a BIP.
>
> An OP_CAT will have to have limits on maximum output size; how big an output
> does your application need?
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org

From tier.nolan at gmail.com  Mon May 22 19:12:54 2017
From: tier.nolan at gmail.com (Tier Nolan)
Date: Mon, 22 May 2017 20:12:54 +0100
Subject: [bitcoin-dev] Drivechain -- Request for Discussion
In-Reply-To: <CA+XQW1jZpJ9wnEg47fouyywL09=_vU8dMP3owkkuNqRvzTZUDg@mail.gmail.com>
References: <24f2b447-a237-45eb-ef9f-1a62533fad5c@gmail.com>
	<dhstGQudLBiwjDlaRrmMfy-ixwvXcwMr1CzCkPKh285RLICGZixkbdwpTDc2Sgz8eYIqSem8lwxW6QeJCD7aFfwQjLDnZ2NmOw0Zzd-KgSs=@protonmail.com>
	<CA+XQW1jZpJ9wnEg47fouyywL09=_vU8dMP3owkkuNqRvzTZUDg@mail.gmail.com>
Message-ID: <CAE-z3OUYuAXE2+h60A=r4UyGU4CSQuF98oFgHnD7iaj-=Z=yOw@mail.gmail.com>

On Mon, May 22, 2017 at 5:19 PM, Paul Sztorc via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> In the future, when there is no block subsidy, a rich attacker can also do
> that in mainchain Bitcoin.
>

I don't think they are the same.

With Bitcoin, you only get to reverse recent transactions.  If you actually
reversed 2-3 weeks of transactions, then the Bitcoin price would fall,
destroying the value of the additional coins you managed to obtain.  Even
if their was no price fall, you can only get a fraction of the total.

With BMM, you can "buy" the entire reserve of the sidechain by paying
(timeout) * (average tx fees).  If you destroy a side-chain's value, then
that doesn't affect the value of the bitcoins you manage to steal.

The incentive could be eliminated by restricting the amount of coin that
can be transferred from the side chain to the main chain to a fraction of
the transaction fee pay to the bitcoin miners.

If the side chain pays x in fees, then at most x/10 can be transferred from
the side chain to the main chain.  This means that someone who pays for
block creation can only get 10% of that value transferred to the main chain.

Main-chain miners could support fraud proofs.  A pool could easily run an
archive node for the side chain in a different data center.

This wouldn't harm the performance of their main operations, but would
guarantee that the side chain data is available for side chain validators.

The sidechain to main-chain timeout would be more than enough for fraud
proofs to be constructed.

This means that the miners would need to know what the rules are for the
side chain, so that they can process the fraud proofs.  They would also
need to run SPV nodes for the side chain, so they know which sidechain
headers to blacklist.


> In point of fact, the transactions *are* validated...by sidechain full
> nodes, same as Bitcoin proper.
>
>
The big difference is that Bitcoin holds no assets on another chain.  A
side-chain's value is directly linked to the fact that it has 100% reserves
on the Bitcoin main chain.  That can be targeted for theft.


> Paul
>
>
> Regards,
> ZmnSCPxj
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/56029b8c/attachment.html>

From sdaftuar at gmail.com  Mon May 22 19:23:22 2017
From: sdaftuar at gmail.com (Suhas Daftuar)
Date: Mon, 22 May 2017 15:23:22 -0400
Subject: [bitcoin-dev] I do not support the BIP 148 UASF
In-Reply-To: <CAAS2fgRdSOu8N6L3+fBpnye+rM+W6+F=cePy=9oL4tJuCj=Jsw@mail.gmail.com>
References: <CAAS2fgRdSOu8N6L3+fBpnye+rM+W6+F=cePy=9oL4tJuCj=Jsw@mail.gmail.com>
Message-ID: <CAFp6fsGcKip_R7OH217mXBQ8OK9N_3Ea-1HtRin3EtwzvJaBhQ@mail.gmail.com>

I also do not support the BIP 148 UASF, and I'd like to add to the points
that Greg has already raised in this thread.

BIP 148 would introduce a new consensus rule that softforks out non-segwit
signalling blocks in some time period.  I reject this consensus rule as
both arbitrary and needlessly disruptive.  Bitcoin's primary purpose is to
reach consensus on the state of a shared ledger, and even though I think
the Bitcoin network ought to adopt segwit, I don't think that concern
trumps the goal of not splitting the network.

Many BIP 148 advocates seem to start with the assumption that segwit
already has a lot of support, and suggest that BIP 148 does as well.
However I don't think it's fair or correct to separate the activation
proposal for segwit from the rest of the segwit proposal.  The deployment
parameters for segwit are consensus-critical; assuming that some other
deployment has consensus because it would result in the rest of the segwit
proposal activating is an unjustified leap.

Even if there were no feasible alternate segwit deployment method available
to us, I would hesitate to recommend that the network adopt a potentially
consensus-splitting approach, even though I firmly believe that the ideas
behind segwit are fundamentally good ones.  But fortunately that is not the
situation we are in; we have substantially less disruptive methods
available to us to activate it, even if the current BIP 9 deployment were
to fail -- such as another BIP 9 deployment in the future, or perhaps a BIP
149 deployment.

If we do pursue a "user-activated" deployment of segwit, I'd recommend that
we do so in a more careful way than BIP 148 or 149 currently suggest, which
as I understand would otherwise make very few changes to the current
implementation.  However, due to the BIP 9 activation assumption, the
Bitcoin Core 0.13.1 - 0.14.0 segwit implementation largely lumps together
the idea that miners would both enforce the rules and mine segwit blocks.
However, we can separate these concerns, as we started to do in the Bitcoin
Core 0.14.1 release, where mining segwit blocks is not required in order to
generally mine or signal for segwit in the software.  And we can go further
still: without too much work, we could make further improvements to
accommodate miners who, for whatever reason, don't want to upgrade their
systems, such as by improving block relay from pre-segwit peers [1], or
optimizing transaction selection for miners who are willing to enforce the
segwit rules but haven't upgraded their systems to mine segwit blocks [2].

If we would seek to activate a soft-fork with less clear miner signaling
(such as BIP 149), then I think such improvements are warranted to minimize
network disruption.  In general, we should not seek to censor hashpower on
the network unless we have a very important reason for doing so.  While the
issues here are nuanced, if I were to evaluate the BIP 148 soft-fork
proposal on the spectrum of "censorship attack on Bitcoin" to "benign
protocol upgrade", BIP 148 strikes me as closer to the former than the
latter.  There is simply no need here to orphan these non-signalling blocks
that could otherwise be used to secure the network.

To go further: I think BIP 148 is ill-conceived even for achieving its own
presumed goals -- the motivation for adding a consensus rule that applies
to the version bits on blocks is surely for the effect such bits have on
older software, such as Bitcoin Core releases 0.13.1 and later.  Yet in
trying to bring those implementations along as segwit-enforcing software,
BIP 148 would risk forking from such clients in the short term!  If one
really cared about maintaining consensus with older, segwit-enabled
software, it would make far more sense to seek segwit activation in a way
that didn't fork from them (such as BIP 149, or a new BIP 9 deployment
after this one times out).  And if one doesn't care about such consensus,
then it'd be far simpler to just set (e.g.) August 1 as the flag day
activation of segwit, and not play these contortionist games with block
version bits, which carry no useful or intrinsic meaning.  Either of these
two approaches should have the advantage of reduced fork risk, compared
with BIP 148.

Of course, everyone is free to run the software of their choosing.  I write
this to both generally convey my opposition to a careless proposal, which I
believe represents a way of thinking that is detrimental to Bitcoin's long
run success, and specifically explain why I oppose inclusion of this
proposal in the Bitcoin Core implementation [3].  The Bitcoin Core project
hasn't been, and shouldn't be, careless in deploying consensus changes.
Instead, I think the Bitcoin Core project ought to stand up for the best
practices that our community has learned about how to deploy such changes
(specifically for minimizing chain-split risk when deploying a soft fork!),
and I think we should all avoid adoption or encouragement of practices that
would depart from the high standards we are capable of achieving.


 [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017
-March/013811.html
 [2] https://github.com/bitcoin/bitcoin/pull/9955
 [3] https://github.com/bitcoin/bitcoin/pull/10428#issuecomment-303098925


--Suhas Daftuar


On Fri, Apr 14, 2017 at 3:56 AM, Gregory Maxwell via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I do not support the BIP148 UASF for some of the same reasons that I
> do support segwit:  Bitcoin is valuable in part because it has high
> security and stability, segwit was carefully designed to support and
> amplify that engineering integrity that people can count on now and
> into the future.
>
> I do not feel the the approach proposed in BIP148 really measures up
> to the standard set by segwit itself, or the existing best practices
> in protocol development in this community.
>
> The primary flaw in BIP148 is that by forcing the activation of the
> existing (non-UASF segwit) nodes it almost guarantees at a minor level
> of disruption.
>
> Segwit was carefully engineered so that older unmodified miners could
> continue operating _completely_ without interruption after segwit
> activates.
>
> Older nodes will not include segwit spends, and so their blocks will
> not be invalid even if they do not have segwit support. They can
> upgrade to it on their own schedule. The only risk non-participating
> miners take after segwit activation is that if someone else mines an
> invalid block they would extend it, a risk many miners already
> frequently take with spy-mining.
>
> I do not think it is a horrible proposal: it is better engineered than
> many things that many altcoins do, but just not up to our normal
> standards. I respect the motivations of the authors of BIP 148.  If
> your goal is the fastest possible segwit activation then it is very
> useful to exploit the >80% of existing nodes that already support the
> original version of segwit.
>
> But the fastest support should not be our goal, as a community-- there
> is always some reckless altcoin or centralized system that can support
> something faster than we can-- trying to match that would only erode
> our distinguishing value in being well engineered and stable.
>
> "First do no harm." We should use the least disruptive mechanisms
> available, and the BIP148 proposal does not meet that test.  To hear
> some people-- non-developers on reddit and such-- a few even see the
> forced orphaning of 148 as a virtue, that it's punitive for
> misbehaving miners. I could not not disagree with that perspective any
> more strongly.
>
> Of course, I do not oppose the general concept of a UASF but
> _generally_ a soft-fork (of any kind) does not need to risk disruption
> of mining, just as segwit's activation does not.  UASF are the
> original kind of soft-fork and were the only kind of fork practiced by
> Satoshi. P2SH was activated based on a date, and all prior ones were
> based on times or heights.  We introduced miner based activation as
> part of a process of making Bitcoin more stable in the common case
> where the ecosystem is all in harmony.  It's kind of weird to see UASF
> portrayed as something new.
>
> It's important the users not be at the mercy of any one part of the
> ecosystem to the extent that we can avoid it-- be it developers,
> exchanges, chat forums, or mining hardware makers.  Ultimately the
> rules of Bitcoin work because they're enforced by the users
> collectively-- that is what makes Bitcoin Bitcoin, it's what makes it
> something people can count on: the rules aren't easy to just change.
>
> There have been some other UASF proposals that avoid the forced
> disruption-- by just defining a new witness bit and allowing
> non-upgraded-to-uasf miners and nodes to continue as non-upgraded, I
> think they are vastly superior. They would be slower to deploy, but I
> do not think that is a flaw.
>
> We should have patience. Bitcoin is a system that should last for all
> ages and power mankind for a long time-- ten years from now a couple
> years of dispute will seem like nothing. But the reputation we earn
> for stability and integrity, for being a system of money people can
> count on will mean everything.
>
> If these discussions come up, they'll come up in the form of reminding
> people that Bitcoin isn't easily changed at a whim, even when the
> whims are obviously good, and how that protects it from being managed
> like all the competing systems of money that the world used to use
> were managed. :)
>
> So have patience, don't take short cuts.  Segwit is a good improvement
> and we should respect it by knowing that it's good enough to wait for,
> and for however its activated to be done the best way we know how.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/8cfe10a6/attachment-0001.html>

From truthcoin at gmail.com  Mon May 22 20:00:19 2017
From: truthcoin at gmail.com (Paul Sztorc)
Date: Mon, 22 May 2017 22:00:19 +0200
Subject: [bitcoin-dev] Drivechain -- Request for Discussion
In-Reply-To: <CAE-z3OUYuAXE2+h60A=r4UyGU4CSQuF98oFgHnD7iaj-=Z=yOw@mail.gmail.com>
References: <24f2b447-a237-45eb-ef9f-1a62533fad5c@gmail.com>
	<dhstGQudLBiwjDlaRrmMfy-ixwvXcwMr1CzCkPKh285RLICGZixkbdwpTDc2Sgz8eYIqSem8lwxW6QeJCD7aFfwQjLDnZ2NmOw0Zzd-KgSs=@protonmail.com>
	<CA+XQW1jZpJ9wnEg47fouyywL09=_vU8dMP3owkkuNqRvzTZUDg@mail.gmail.com>
	<CAE-z3OUYuAXE2+h60A=r4UyGU4CSQuF98oFgHnD7iaj-=Z=yOw@mail.gmail.com>
Message-ID: <CA+XQW1hRhcxJBoOJ57YG0t5y5j1Qm3RO4wr2eXV5V-UzDaiPPw@mail.gmail.com>

On May 22, 2017 3:13 PM, "Tier Nolan via bitcoin-dev" <bitcoin-dev at lists.
linuxfoundation.org> wrote:

On Mon, May 22, 2017 at 5:19 PM, Paul Sztorc via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> In the future, when there is no block subsidy, a rich attacker can also do
> that in mainchain Bitcoin.
>

I don't think they are the same.

With Bitcoin, you only get to reverse recent transactions.  If you actually
reversed 2-3 weeks of transactions, then the Bitcoin price would fall,
destroying the value of the additional coins you managed to obtain.  Even
if their was no price fall, you can only get a fraction of the total.


I would replace "Bitcoins you manage to steal" with "Bitcoins you manage to
double-spend". Then, it still seems the same to me.


With BMM, you can "buy" the entire reserve of the sidechain by paying
(timeout) * (average tx fees).  If you destroy a side-chain's value, then
that doesn't affect the value of the bitcoins you manage to steal.


It may destroy great value if it shakes confidence in the sidechain
infrastructure. Thus, the value of the stolen BTC may decrease, in addition
to the lost future tx fee revenues of the attacked chain.

http://www.truthcoin.info/blog/drivechain/#drivechains-security

In my view, sidechains should only exist at all if they positively impact
Bitcoin's value. It is therefore desirable for miners to steal from chains
that provide no value-add.




> In point of fact, the transactions *are* validated...by sidechain full
> nodes, same as Bitcoin proper.
>
>
The big difference is that Bitcoin holds no assets on another chain.  A
side-chain's value is directly linked to the fact that it has 100% reserves
on the Bitcoin main chain.  That can be targeted for theft.


Again, I don't really think it is that different. One could interchange
"recent txns" (those which could be double-spent within 2-3 weeks) with
"sidechain deposit tnxs".
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/8a42bd04/attachment.html>

From roconnor at blockstream.io  Mon May 22 22:32:38 2017
From: roconnor at blockstream.io (Russell O'Connor)
Date: Mon, 22 May 2017 18:32:38 -0400
Subject: [bitcoin-dev] A Method for Computing Merkle Roots of Annotated
 Binary Trees
In-Reply-To: <20170522140548.GA17732@fedora-23-dvm>
References: <CAMZUoK=f3hXHkqJBDfiLGSrgXi_ppgyH6+XWD9W54EYFWLm1+Q@mail.gmail.com>
	<20170522140548.GA17732@fedora-23-dvm>
Message-ID: <CAMZUoKk1fxOLgBfuxqXpxG-M5ZCPHZBb62_LZF7H4syQ-L7tCg@mail.gmail.com>

On May 22, 2017 23:05, "Peter Todd" <pete at petertodd.org> wrote:

On Mon, May 22, 2017 at 03:05:49AM -0400, Russell O'Connor via bitcoin-dev
wrote:
>     MerkleRoot := SHA256(SHA256(LeftRoot ? RightRoot))
>     sha256Compress : Word256 ? Word512 -> Word256

To be clear, what math operations do you mean by "?" and "?"?


By "?", I usually mean concatenation (though I also use it for function
composition in one instance).   By "?", I mean the Cartesian product.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/cdef9d9f/attachment.html>

From james.hilliard1 at gmail.com  Mon May 22 22:40:13 2017
From: james.hilliard1 at gmail.com (James Hilliard)
Date: Mon, 22 May 2017 18:40:13 -0400
Subject: [bitcoin-dev] Reduced signalling threshold activation of existing
	segwit deployment
Message-ID: <CADvTj4pQ8eJvzm9UOgC8bYm1ERGuTX7qq+a7etRe55S=KodrHQ@mail.gmail.com>

I would like to propose an implementation that accomplishes the first
part of the Barry Silbert proposal independently from the second:

"Activate Segregated Witness at an 80% threshold, signaling at bit 4"
in a way that

The goal here is to minimize chain split risk and network disruption
while maximizing backwards compatibility and still providing for rapid
activation of segwit at the 80% threshold using bit 4.

By activating segwit immediately and separately from any HF we can
scale quickly without risking a rushed combined segwit+HF that would
almost certainly cause widespread issues.

Draft proposal:
https://github.com/jameshilliard/bips/blob/bip-segsignal/bip-segsignal.mediawiki

Proposal text:
<pre>
  BIP: segsignal
  Layer: Consensus (soft fork)
  Title: Reduced signalling threshold activation of existing segwit deployment
  Author: James Hilliard <james.hilliard1 at gmail.com>
  Status: Draft
  Type: Standards Track
  Created: 2017-05-22
  License: BSD-3-Clause
           CC0-1.0
</pre>

==Abstract==

This document specifies a method to activate the existing BIP9 segwit
deployment with a majority hashpower less than 95%.

==Definitions==

"existing segwit deployment" refer to the BIP9 "segwit" deployment
using bit 1, between November 15th 2016 and November 15th 2017 to
activate BIP141, BIP143 and BIP147.

==Motivation==

Segwit increases the blocksize, fixes transaction malleability, and
makes scripting easier to upgrade as well as bringing many other
[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].

This BIP provides a way for a simple majority of miners to coordinate
activation of the existing segwit deployment with less than 95%
hashpower. For a number of reasons a complete redeployment of segwit
is difficulty to do until the existing deployment expires. This is due
to 0.13.1+ having many segwit related features active already,
including all the P2P components, the new network service flag, the
witness-tx and block messages, compact blocks v2 and preferential
peering. A redeployment of segwit will need to redefine all these
things and doing so before expiry would greatly complicate testing.

==Specification==

While this BIP is active, all blocks must set the nVersion header top
3 bits to 001 together with bit field (1<<1) (according to the
existing segwit deployment). Blocks that do not signal as required
will be rejected.

==Deployment==

This BIP will be deployed by a "version bits" with an 80%(this can be
adjusted if desired) activation threshold BIP9 with the name
"segsignal" and using bit 4.

This BIP will have a start time of midnight June 1st, 2017 (epoch time
1496275200) and timeout on midnight November 15th 2017 (epoch time
1510704000). This BIP will cease to be active when segwit is
locked-in.

=== Reference implementation ===

<pre>
// Check if Segregated Witness is Locked In
bool IsWitnessLockedIn(const CBlockIndex* pindexPrev, const
Consensus::Params& params)
{
    LOCK(cs_main);
    return (VersionBitsState(pindexPrev, params,
Consensus::DEPLOYMENT_SEGWIT, versionbitscache) ==
THRESHOLD_LOCKED_IN);
}

// SEGSIGNAL mandatory segwit signalling.
if ( VersionBitsState(pindex->pprev, chainparams.GetConsensus(),
Consensus::DEPLOYMENT_SEGSIGNAL, versionbitscache) == THRESHOLD_ACTIVE
&&
     !IsWitnessLockedIn(pindex->pprev, chainparams.GetConsensus()) &&
// Segwit is not locked in
     !IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) ) //
and is not active.
{
    bool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) ==
VERSIONBITS_TOP_BITS;
    bool fSegbit = (pindex->nVersion &
VersionBitsMask(chainparams.GetConsensus(),
Consensus::DEPLOYMENT_SEGWIT)) != 0;
    if (!(fVersionBits && fSegbit)) {
        return state.DoS(0, error("ConnectBlock(): relayed block must
signal for segwit, please upgrade"), REJECT_INVALID, "bad-no-segwit");
    }
}
</pre>

https://github.com/bitcoin/bitcoin/compare/0.14...jameshilliard:segsignal-v0.14.1

==Backwards Compatibility==

This deployment is compatible with the existing "segwit" bit 1
deployment scheduled between midnight November 15th, 2016 and midnight
November 15th, 2017. Miners will need to upgrade their nodes to
support segsignal otherwise they may build on top of an invalid block.
While this bip is active users should either upgrade to segsignal or
wait for additional confirmations when accepting payments.

==Rationale==

Historically we have used IsSuperMajority() to activate soft forks
such as BIP66 which has a mandatory signalling requirement for miners
once activated, this ensures that miners are aware of new rules being
enforced. This technique can be leveraged to lower the signalling
threshold of a soft fork while it is in the process of being deployed
in a backwards compatible way.

By orphaning non-signalling blocks during the BIP9 bit 1 "segwit"
deployment, this BIP can cause the existing "segwit" deployment to
activate without needing to release a new deployment.

==References==

*[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013714.html
Mailing list discussion]
*[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.cpp#L1281-L1283
P2SH flag day activation]
*[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]
*[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]
*[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]
*[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for
Version 0 Witness Program]]
*[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element malleability]]
*[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit deployment]]
*[[bip-0149.mediawiki|BIP149 Segregated Witness (second deployment)]]
*[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit benefits]

==Copyright==

This document is dual licensed as BSD 3-clause, and Creative Commons
CC0 1.0 Universal.

From lf-lists at mattcorallo.com  Mon May 22 22:43:00 2017
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Mon, 22 May 2017 22:43:00 +0000
Subject: [bitcoin-dev] Reduced signalling threshold activation of
	existing	segwit deployment
In-Reply-To: <CADvTj4pQ8eJvzm9UOgC8bYm1ERGuTX7qq+a7etRe55S=KodrHQ@mail.gmail.com>
References: <CADvTj4pQ8eJvzm9UOgC8bYm1ERGuTX7qq+a7etRe55S=KodrHQ@mail.gmail.com>
Message-ID: <76B73DE9-82D7-4EFA-866A-6531B1F6B480@mattcorallo.com>

Given the overwhelming support for SegWit across the ecosystem of businesses and users, this seems reasonable to me.

On May 22, 2017 6:40:13 PM EDT, James Hilliard via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>I would like to propose an implementation that accomplishes the first
>part of the Barry Silbert proposal independently from the second:
>
>"Activate Segregated Witness at an 80% threshold, signaling at bit 4"
>in a way that
>
>The goal here is to minimize chain split risk and network disruption
>while maximizing backwards compatibility and still providing for rapid
>activation of segwit at the 80% threshold using bit 4.
>
>By activating segwit immediately and separately from any HF we can
>scale quickly without risking a rushed combined segwit+HF that would
>almost certainly cause widespread issues.
>
>Draft proposal:
>https://github.com/jameshilliard/bips/blob/bip-segsignal/bip-segsignal.mediawiki
>
>Proposal text:
><pre>
>  BIP: segsignal
>  Layer: Consensus (soft fork)
>Title: Reduced signalling threshold activation of existing segwit
>deployment
>  Author: James Hilliard <james.hilliard1 at gmail.com>
>  Status: Draft
>  Type: Standards Track
>  Created: 2017-05-22
>  License: BSD-3-Clause
>           CC0-1.0
></pre>
>
>==Abstract==
>
>This document specifies a method to activate the existing BIP9 segwit
>deployment with a majority hashpower less than 95%.
>
>==Definitions==
>
>"existing segwit deployment" refer to the BIP9 "segwit" deployment
>using bit 1, between November 15th 2016 and November 15th 2017 to
>activate BIP141, BIP143 and BIP147.
>
>==Motivation==
>
>Segwit increases the blocksize, fixes transaction malleability, and
>makes scripting easier to upgrade as well as bringing many other
>[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].
>
>This BIP provides a way for a simple majority of miners to coordinate
>activation of the existing segwit deployment with less than 95%
>hashpower. For a number of reasons a complete redeployment of segwit
>is difficulty to do until the existing deployment expires. This is due
>to 0.13.1+ having many segwit related features active already,
>including all the P2P components, the new network service flag, the
>witness-tx and block messages, compact blocks v2 and preferential
>peering. A redeployment of segwit will need to redefine all these
>things and doing so before expiry would greatly complicate testing.
>
>==Specification==
>
>While this BIP is active, all blocks must set the nVersion header top
>3 bits to 001 together with bit field (1<<1) (according to the
>existing segwit deployment). Blocks that do not signal as required
>will be rejected.
>
>==Deployment==
>
>This BIP will be deployed by a "version bits" with an 80%(this can be
>adjusted if desired) activation threshold BIP9 with the name
>"segsignal" and using bit 4.
>
>This BIP will have a start time of midnight June 1st, 2017 (epoch time
>1496275200) and timeout on midnight November 15th 2017 (epoch time
>1510704000). This BIP will cease to be active when segwit is
>locked-in.
>
>=== Reference implementation ===
>
><pre>
>// Check if Segregated Witness is Locked In
>bool IsWitnessLockedIn(const CBlockIndex* pindexPrev, const
>Consensus::Params& params)
>{
>    LOCK(cs_main);
>    return (VersionBitsState(pindexPrev, params,
>Consensus::DEPLOYMENT_SEGWIT, versionbitscache) ==
>THRESHOLD_LOCKED_IN);
>}
>
>// SEGSIGNAL mandatory segwit signalling.
>if ( VersionBitsState(pindex->pprev, chainparams.GetConsensus(),
>Consensus::DEPLOYMENT_SEGSIGNAL, versionbitscache) == THRESHOLD_ACTIVE
>&&
>     !IsWitnessLockedIn(pindex->pprev, chainparams.GetConsensus()) &&
>// Segwit is not locked in
>     !IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) ) //
>and is not active.
>{
>    bool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) ==
>VERSIONBITS_TOP_BITS;
>    bool fSegbit = (pindex->nVersion &
>VersionBitsMask(chainparams.GetConsensus(),
>Consensus::DEPLOYMENT_SEGWIT)) != 0;
>    if (!(fVersionBits && fSegbit)) {
>        return state.DoS(0, error("ConnectBlock(): relayed block must
>signal for segwit, please upgrade"), REJECT_INVALID, "bad-no-segwit");
>    }
>}
></pre>
>
>https://github.com/bitcoin/bitcoin/compare/0.14...jameshilliard:segsignal-v0.14.1
>
>==Backwards Compatibility==
>
>This deployment is compatible with the existing "segwit" bit 1
>deployment scheduled between midnight November 15th, 2016 and midnight
>November 15th, 2017. Miners will need to upgrade their nodes to
>support segsignal otherwise they may build on top of an invalid block.
>While this bip is active users should either upgrade to segsignal or
>wait for additional confirmations when accepting payments.
>
>==Rationale==
>
>Historically we have used IsSuperMajority() to activate soft forks
>such as BIP66 which has a mandatory signalling requirement for miners
>once activated, this ensures that miners are aware of new rules being
>enforced. This technique can be leveraged to lower the signalling
>threshold of a soft fork while it is in the process of being deployed
>in a backwards compatible way.
>
>By orphaning non-signalling blocks during the BIP9 bit 1 "segwit"
>deployment, this BIP can cause the existing "segwit" deployment to
>activate without needing to release a new deployment.
>
>==References==
>
>*[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013714.html
>Mailing list discussion]
>*[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.cpp#L1281-L1283
>P2SH flag day activation]
>*[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]
>*[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]
>*[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]
>*[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for
>Version 0 Witness Program]]
>*[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element
>malleability]]
>*[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit
>deployment]]
>*[[bip-0149.mediawiki|BIP149 Segregated Witness (second deployment)]]
>*[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit
>benefits]
>
>==Copyright==
>
>This document is dual licensed as BSD 3-clause, and Creative Commons
>CC0 1.0 Universal.
>_______________________________________________
>bitcoin-dev mailing list
>bitcoin-dev at lists.linuxfoundation.org
>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From ZmnSCPxj at protonmail.com  Tue May 23 00:13:55 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 22 May 2017 20:13:55 -0400
Subject: [bitcoin-dev] Drivechain -- Request for Discussion
In-Reply-To: <CA+XQW1jZpJ9wnEg47fouyywL09=_vU8dMP3owkkuNqRvzTZUDg@mail.gmail.com>
References: <24f2b447-a237-45eb-ef9f-1a62533fad5c@gmail.com>
	<dhstGQudLBiwjDlaRrmMfy-ixwvXcwMr1CzCkPKh285RLICGZixkbdwpTDc2Sgz8eYIqSem8lwxW6QeJCD7aFfwQjLDnZ2NmOw0Zzd-KgSs=@protonmail.com>
	<CA+XQW1jZpJ9wnEg47fouyywL09=_vU8dMP3owkkuNqRvzTZUDg@mail.gmail.com>
Message-ID: <FSrvrfLYPlLQULODf79GXk7yzJHCRD8FOiLzLGZFS5BYuGn_WL8hRsqQD1BEQjT54RATE7hqlqjYthzJgNfZOdgy4hJMBB5osv3dspyIwX0=@protonmail.com>

Good morning,

>What you read is only an introduction of BMM. You may also consult the notes (at the bottom of the BMM post) or the code, although this is time consuming of course.

Looking over the code, I have a question: Is OP_BRIBE supposed to be softforked in, or hardforked? From my understanding, the code as published in your linked github cannot be softforked in, since it is not a softfork-compatible replacement for OP_NOP: it replaces the stack top value with a 0/1 value. Both CLTV and CSV do not touch the stack, only flag an error if they fail.

(What happens if the h* to be put in the coinbase, by chance - even very unlikely chance - is 0? Then <h*> OP_NOP4 is not the same as <h*> OP_BRIBE scripts in result - the former will be rejected by old nodes, the latter will be accepted by new nodes)

Does Drivechain require a hardfork? My understanding is that you want to use some kind of softforked anyone-can-spend transaction to use Drivechain. So I don't quite understand why OP_BRIBE is written the way it is.

Is OP_BRIBE the same as the OP_h_is_in_coinbase operation you described?

How is OP_BRIBE superior to just using a <h*> OP_RETURN script? Cannot a sidechain scan the block for OP_RETURN attesting that the block hash is present in the block? OP_BRIBE encodes <h*> twice (once in the transaction, once in the coinbase), OP_RETURN encodes it once (once in the transaction)

>The literal answer to your question is that mainchain Bitcoin will notice that, for the second withdrawal, the sum of the inputs is less than the sum of the outputs and they the transaction is therefore invalid.

You misunderstand. The first withdrawal was done by double-spending, and exchanging your sidechain funds for mainchain funds using some off-chain method. The second withdrawal is done on-chain.

That said, I confused OP_h_is_in_coinbase as your method of getting out of the sidechain into the mainchain. It seems, OP_h_is_in_coinbase is only for blind mining?

>I feel that my proposal is more secure, as it can operate healthily and quickly while using spv proofs which are much slower and much much easier to audit.

I don't quite understand how Drivechain handles sidechain reorgs, while keeping Bitcoin miners blinded. It seems sidechains need to be known ("seen") by the miner, so I don't see what is being blinded by blinded merge mining.

>>seems to me that your OP_is_h_in_coinbase should scan a series of sidechain block headers backed by mainchain (meaning at the minimum that sidechains should have some common header format prefix), rather than just mainchain depth as your article seems to imply.
>
>How would security be improved as a result? In either case, 51% of hashrate can cause a reorg. The sidechain software itself does scan block headers, of course.

I misunderstand the purpose of your OP_is_h_in_coinbase, sorry.

>>Blind merged mining seems strictly inferior ... a rich attacker can simply reorg the sidechain outright without playing such games.
>
>In the future, when there is no block subsidy, a rich attacker can also do that in mainchain Bitcoin.

I see. However, block subsidies will drop far in the future, do you mean to say, that sidechains will be used only in the far future?

>>How does your proposal handle multiple side block creators on the same sidechain, with the possibility that chain splits occur?
>
>The side block is only "mined" if it is committed to in a mainchain Bitcoin blog, and each mainchain block can only contain one block per sidechain. In this way, drivechain sidechains are different from classical Namecoin merged mining (where one _could_ run the entire system, mining included, without interfacing with Bitcoin at all).

I assume you mean "mainchain Bitcoin block" here.

What mechanism ensures only one mainchain block can contain only one sidechain block? It seems, this isn't implemented by OP_BRIBE yet. Can you elaborate on this mechanism?

>>Regarding your dig about people who dislike data centers, the main issue with miners blindly accepting sidechain commitments is that it violates "Don't trust, verify", not that allows datacenters to be slightly smaller by not including side:nodes.
>
>As I explain early on, in earlier rounds of peer review, the focus was on harms the sidechain technology might do to mainchain Bitcoin, and the "datacenter point" was specifically the chief objection raised. So I am afraid you are entirely incorrect.

I see. It seems, the main problem, is that sidechains can be used to sneak in block size increases. Of course, the advantage of sidechains, is that when it increases block size irresponsibly, only those who participated in the sidechain will suffer.

>In point of fact, the transactions *are* validated...by sidechain full nodes, same as Bitcoin proper.

But from blind merge mining by itself, how would the blinded merge miner know that there exists an actual sidechain full node that actually did validation?

It seems, that the "blinding" in merge mining does not seem to be at all useful without the miner actually seeing the sidechain. If you want miners to upgrade to side:fullnode as well, what would then be the point of blinding? Why not just ordinary merge mining?

Perhaps the datacenter point is simply that your proposal suggests to reduce the size of the datacenter by removing surge suppressors and UPS's, to avoid some definition of "datacenter is a room with >$XXX of equipment".

Regards,
ZmnSCPxj
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/55bb9433/attachment.html>

From rusty at rustcorp.com.au  Tue May 23 04:47:48 2017
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Tue, 23 May 2017 14:17:48 +0930
Subject: [bitcoin-dev] Rolling UTXO set hashes
In-Reply-To: <CAAS2fgQKOKY6DEwY3ycMjysU5Xf2UUE+k=vg2ekkAMO7KG3Gsw@mail.gmail.com>
References: <CAPg+sBgruEiXya6oFy6VpmR1KPDebjeGDtZZU+facZx5=L_a5w@mail.gmail.com>
	<CT3GNfkLsQJyM0EmWXc3HBmnW1h2iptP0SohZnXZfZPffoVmcofD8fs_E3kV5PuFL0pQSQwwk_FyR-8-wdANf15NE8UElNWqcEcc5Ql3n8M=@protonmail.com>
	<CAAS2fgTif+Y6VzFG+w7W+CY1+D_roCqGyy392qB2KcDPGpVeiw@mail.gmail.com>
	<20170516110104.GA5564@fedora-23-dvm>
	<CAPg+sBjJLbhj71Epv=Qfc8HgJhSreN6BOmLkDkvcEGvPwxDNbg@mail.gmail.com>
	<CAAS2fgQKOKY6DEwY3ycMjysU5Xf2UUE+k=vg2ekkAMO7KG3Gsw@mail.gmail.com>
Message-ID: <8760gs2n7v.fsf@rustcorp.com.au>

Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:
> On Tue, May 16, 2017 at 6:17 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:
>> just the first - and one that has very low costs and no normative
>> datastructures at all.
>
> The serialization of the txout itself is normative, but very minimal.

I do prefer the (2) approach, BTW, as it reuses existing primitives, but
I know "simpler" means a different thing to mathier brains :)

Since it wasn't explicit in the proposal, I think the txout information
placed in the hash here is worth discussing.

I prefer a simple txid||outnumber[1], because it allows simple validation
without knowing the UTXO set itself; even a lightweight node can assert
that UTXOhash for block N+1 is valid if the UTXOhash for block N is
valid (and vice versa!) given block N+1.  And miners can't really use
that even if they were to try not validating against UTXO (!) because
they need to know input amounts for fees (which are becoming
significant).

If I want to hand you the complete validatable UTXO set, I need to hand
you all the txs with any unspent output, and some bitfield to indicate
which ones are unspent.

OTOH, if you serialize more (eg. ...||amount||scriptPubKey ?), then the UTXO
set size needed to validate the utxohash is a little smaller: you need
to send the txid, but not the tx nVersion, nLocktime or inputs.  But in a
SegWit world, that's actually *bigger* AFAICT.

Thanks,
Rusty.

[1] I think you could actually use txid^outnumber, and if that's not a
    curve point SHA256() again, etc.  But I don't think that saves any
    real time, and may cause other issues.

From bram at bittorrent.com  Tue May 23 06:06:07 2017
From: bram at bittorrent.com (Bram Cohen)
Date: Mon, 22 May 2017 23:06:07 -0700
Subject: [bitcoin-dev] A Method for Computing Merkle Roots of Annotated
 Binary Trees
In-Reply-To: <CAMZUoK=f3hXHkqJBDfiLGSrgXi_ppgyH6+XWD9W54EYFWLm1+Q@mail.gmail.com>
References: <CAMZUoK=f3hXHkqJBDfiLGSrgXi_ppgyH6+XWD9W54EYFWLm1+Q@mail.gmail.com>
Message-ID: <CA+KqGkprA9XvaymW5VcpkcBQDp8s_M37r1K_9mbYScxMpV7cfQ@mail.gmail.com>

On Mon, May 22, 2017 at 12:05 AM, Russell O'Connor via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> The SHA256 compression function takes two inputs:
>
> 1. A 256-bit value for the previous chunk in a chain, or an initial vector
> in the case of the first chunk.
> 2. A 512-bit chunk of data.
>
>     sha256Compress : Word256 ? Word512 -> Word256
>
> In total, the SHA256 compression function compresses 768-bits into
> 256-bits.  The Merkle roots of two branches occupy 512 bits, and this
> leaves another 256-bits of space available for tags.
>

Ya know, when you're building a Merkle Trie that's exactly the primitive
you need.

In my own construction the assumption is that the values are already hashed
down to 256 bits when they're passed in, and the tags (which are currently
done by sacrificing bits instead of using tags, that needs to be fixed)
include three states for either side: empty, unary, or middle. Three of
those possibilities are unreachable (empty/empty, empty/unary, unary/empty)
so there are 6 possible tags needed. This approach essentially skips doing
the unary hashes, a further performance improvement. There doesn't appear
to be any downside in leveraging this trick as long as tags are cheap.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/1445b092/attachment-0001.html>

From steven.pine at gmail.com  Tue May 23 04:03:49 2017
From: steven.pine at gmail.com (Steven Pine)
Date: Tue, 23 May 2017 00:03:49 -0400
Subject: [bitcoin-dev] I do not support the BIP 148 UASF
In-Reply-To: <CAFp6fsGcKip_R7OH217mXBQ8OK9N_3Ea-1HtRin3EtwzvJaBhQ@mail.gmail.com>
References: <CAAS2fgRdSOu8N6L3+fBpnye+rM+W6+F=cePy=9oL4tJuCj=Jsw@mail.gmail.com>
	<CAFp6fsGcKip_R7OH217mXBQ8OK9N_3Ea-1HtRin3EtwzvJaBhQ@mail.gmail.com>
Message-ID: <CAAjy6kC43DX3wpaZ+3skBUO8hVrYt7uNZfw1Ep3GDJs8YA9Gxg@mail.gmail.com>

I'm glad some discussion has been moved back here.

Correct me if I am wrong, but currently core developers are arguing over
whether or not to allow an optional configuration switch which defaults off
but signals and enforces BIP148 when used. Who are we protecting users
from, themselves? Are you protecting core? from what? I am somewhat
genuinely befuddled by those who can't even allow a user config switch to
be set.

I guess I find it all incredibly silly, but perhaps I suffer from some
basic confusion.



On Mon, May 22, 2017 at 3:23 PM, Suhas Daftuar via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I also do not support the BIP 148 UASF, and I'd like to add to the points
> that Greg has already raised in this thread.
>
> BIP 148 would introduce a new consensus rule that softforks out non-segwit
> signalling blocks in some time period.  I reject this consensus rule as
> both arbitrary and needlessly disruptive.  Bitcoin's primary purpose is to
> reach consensus on the state of a shared ledger, and even though I think
> the Bitcoin network ought to adopt segwit, I don't think that concern
> trumps the goal of not splitting the network.
>
> Many BIP 148 advocates seem to start with the assumption that segwit
> already has a lot of support, and suggest that BIP 148 does as well.
> However I don't think it's fair or correct to separate the activation
> proposal for segwit from the rest of the segwit proposal.  The deployment
> parameters for segwit are consensus-critical; assuming that some other
> deployment has consensus because it would result in the rest of the segwit
> proposal activating is an unjustified leap.
>
> Even if there were no feasible alternate segwit deployment method
> available to us, I would hesitate to recommend that the network adopt a
> potentially consensus-splitting approach, even though I firmly believe that
> the ideas behind segwit are fundamentally good ones.  But fortunately that
> is not the situation we are in; we have substantially less disruptive
> methods available to us to activate it, even if the current BIP 9
> deployment were to fail -- such as another BIP 9 deployment in the future,
> or perhaps a BIP 149 deployment.
>
> If we do pursue a "user-activated" deployment of segwit, I'd recommend
> that we do so in a more careful way than BIP 148 or 149 currently suggest,
> which as I understand would otherwise make very few changes to the current
> implementation.  However, due to the BIP 9 activation assumption, the
> Bitcoin Core 0.13.1 - 0.14.0 segwit implementation largely lumps together
> the idea that miners would both enforce the rules and mine segwit blocks.
> However, we can separate these concerns, as we started to do in the Bitcoin
> Core 0.14.1 release, where mining segwit blocks is not required in order to
> generally mine or signal for segwit in the software.  And we can go further
> still: without too much work, we could make further improvements to
> accommodate miners who, for whatever reason, don't want to upgrade their
> systems, such as by improving block relay from pre-segwit peers [1], or
> optimizing transaction selection for miners who are willing to enforce the
> segwit rules but haven't upgraded their systems to mine segwit blocks [2].
>
> If we would seek to activate a soft-fork with less clear miner signaling
> (such as BIP 149), then I think such improvements are warranted to minimize
> network disruption.  In general, we should not seek to censor hashpower on
> the network unless we have a very important reason for doing so.  While the
> issues here are nuanced, if I were to evaluate the BIP 148 soft-fork
> proposal on the spectrum of "censorship attack on Bitcoin" to "benign
> protocol upgrade", BIP 148 strikes me as closer to the former than the
> latter.  There is simply no need here to orphan these non-signalling blocks
> that could otherwise be used to secure the network.
>
> To go further: I think BIP 148 is ill-conceived even for achieving its own
> presumed goals -- the motivation for adding a consensus rule that applies
> to the version bits on blocks is surely for the effect such bits have on
> older software, such as Bitcoin Core releases 0.13.1 and later.  Yet in
> trying to bring those implementations along as segwit-enforcing software,
> BIP 148 would risk forking from such clients in the short term!  If one
> really cared about maintaining consensus with older, segwit-enabled
> software, it would make far more sense to seek segwit activation in a way
> that didn't fork from them (such as BIP 149, or a new BIP 9 deployment
> after this one times out).  And if one doesn't care about such consensus,
> then it'd be far simpler to just set (e.g.) August 1 as the flag day
> activation of segwit, and not play these contortionist games with block
> version bits, which carry no useful or intrinsic meaning.  Either of these
> two approaches should have the advantage of reduced fork risk, compared
> with BIP 148.
>
> Of course, everyone is free to run the software of their choosing.  I
> write this to both generally convey my opposition to a careless proposal,
> which I believe represents a way of thinking that is detrimental to
> Bitcoin's long run success, and specifically explain why I oppose inclusion
> of this proposal in the Bitcoin Core implementation [3].  The Bitcoin Core
> project hasn't been, and shouldn't be, careless in deploying consensus
> changes.  Instead, I think the Bitcoin Core project ought to stand up for
> the best practices that our community has learned about how to deploy such
> changes (specifically for minimizing chain-split risk when deploying a soft
> fork!), and I think we should all avoid adoption or encouragement of
> practices that would depart from the high standards we are capable of
> achieving.
>
>
>  [1] https://lists.linuxfoundation.org/pipermail/
> bitcoin-dev/2017-March/013811.html
>  [2] https://github.com/bitcoin/bitcoin/pull/9955
>  [3] https://github.com/bitcoin/bitcoin/pull/10428#issuecomment-303098925
>
>
> --Suhas Daftuar
>
>
> On Fri, Apr 14, 2017 at 3:56 AM, Gregory Maxwell via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> I do not support the BIP148 UASF for some of the same reasons that I
>> do support segwit:  Bitcoin is valuable in part because it has high
>> security and stability, segwit was carefully designed to support and
>> amplify that engineering integrity that people can count on now and
>> into the future.
>>
>> I do not feel the the approach proposed in BIP148 really measures up
>> to the standard set by segwit itself, or the existing best practices
>> in protocol development in this community.
>>
>> The primary flaw in BIP148 is that by forcing the activation of the
>> existing (non-UASF segwit) nodes it almost guarantees at a minor level
>> of disruption.
>>
>> Segwit was carefully engineered so that older unmodified miners could
>> continue operating _completely_ without interruption after segwit
>> activates.
>>
>> Older nodes will not include segwit spends, and so their blocks will
>> not be invalid even if they do not have segwit support. They can
>> upgrade to it on their own schedule. The only risk non-participating
>> miners take after segwit activation is that if someone else mines an
>> invalid block they would extend it, a risk many miners already
>> frequently take with spy-mining.
>>
>> I do not think it is a horrible proposal: it is better engineered than
>> many things that many altcoins do, but just not up to our normal
>> standards. I respect the motivations of the authors of BIP 148.  If
>> your goal is the fastest possible segwit activation then it is very
>> useful to exploit the >80% of existing nodes that already support the
>> original version of segwit.
>>
>> But the fastest support should not be our goal, as a community-- there
>> is always some reckless altcoin or centralized system that can support
>> something faster than we can-- trying to match that would only erode
>> our distinguishing value in being well engineered and stable.
>>
>> "First do no harm." We should use the least disruptive mechanisms
>> available, and the BIP148 proposal does not meet that test.  To hear
>> some people-- non-developers on reddit and such-- a few even see the
>> forced orphaning of 148 as a virtue, that it's punitive for
>> misbehaving miners. I could not not disagree with that perspective any
>> more strongly.
>>
>> Of course, I do not oppose the general concept of a UASF but
>> _generally_ a soft-fork (of any kind) does not need to risk disruption
>> of mining, just as segwit's activation does not.  UASF are the
>> original kind of soft-fork and were the only kind of fork practiced by
>> Satoshi. P2SH was activated based on a date, and all prior ones were
>> based on times or heights.  We introduced miner based activation as
>> part of a process of making Bitcoin more stable in the common case
>> where the ecosystem is all in harmony.  It's kind of weird to see UASF
>> portrayed as something new.
>>
>> It's important the users not be at the mercy of any one part of the
>> ecosystem to the extent that we can avoid it-- be it developers,
>> exchanges, chat forums, or mining hardware makers.  Ultimately the
>> rules of Bitcoin work because they're enforced by the users
>> collectively-- that is what makes Bitcoin Bitcoin, it's what makes it
>> something people can count on: the rules aren't easy to just change.
>>
>> There have been some other UASF proposals that avoid the forced
>> disruption-- by just defining a new witness bit and allowing
>> non-upgraded-to-uasf miners and nodes to continue as non-upgraded, I
>> think they are vastly superior. They would be slower to deploy, but I
>> do not think that is a flaw.
>>
>> We should have patience. Bitcoin is a system that should last for all
>> ages and power mankind for a long time-- ten years from now a couple
>> years of dispute will seem like nothing. But the reputation we earn
>> for stability and integrity, for being a system of money people can
>> count on will mean everything.
>>
>> If these discussions come up, they'll come up in the form of reminding
>> people that Bitcoin isn't easily changed at a whim, even when the
>> whims are obviously good, and how that protects it from being managed
>> like all the competing systems of money that the world used to use
>> were managed. :)
>>
>> So have patience, don't take short cuts.  Segwit is a good improvement
>> and we should respect it by knowing that it's good enough to wait for,
>> and for however its activated to be done the best way we know how.
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>


-- 
Steven Pine
(510) 517-7075
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170523/6d4ec9c9/attachment.html>

From earonesty at gmail.com  Tue May 23 04:00:53 2017
From: earonesty at gmail.com (Erik Aronesty)
Date: Tue, 23 May 2017 00:00:53 -0400
Subject: [bitcoin-dev] Reduced signalling threshold activation of
 existing segwit deployment
In-Reply-To: <CAJowKgL0BgtKWQDsE7onygfuv8n2afbEdwotWNzfyV1t9_wxJA@mail.gmail.com>
References: <CADvTj4pQ8eJvzm9UOgC8bYm1ERGuTX7qq+a7etRe55S=KodrHQ@mail.gmail.com>
	<76B73DE9-82D7-4EFA-866A-6531B1F6B480@mattcorallo.com>
	<CAJowKgJyMKxOarUhnZ4yJLftranFCvOnxCGUMs6gDy0MuwS-MQ@mail.gmail.com>
	<CAJowKgL0BgtKWQDsE7onygfuv8n2afbEdwotWNzfyV1t9_wxJA@mail.gmail.com>
Message-ID: <CAJowKg+Mk3GWJZ0AxN5zGqNOc4sVgT7QdiMw3-5a5Se4VkrHzw@mail.gmail.com>

Seems like it would work fine.  But why would we expect 80pct to signal for
the exact same implementation - when we can't get 40pct.

It will be contingent on some HF code that allows him to continue using
asicboost,  or is too aggressive,  or some other unreasonable request.



On May 22, 2017 6:43 PM, "Matt Corallo via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

Given the overwhelming support for SegWit across the ecosystem of
businesses and users, this seems reasonable to me.

On May 22, 2017 6:40:13 PM EDT, James Hilliard via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:
>I would like to propose an implementation that accomplishes the first
>part of the Barry Silbert proposal independently from the second:
>
>"Activate Segregated Witness at an 80% threshold, signaling at bit 4"
>in a way that
>
>The goal here is to minimize chain split risk and network disruption
>while maximizing backwards compatibility and still providing for rapid
>activation of segwit at the 80% threshold using bit 4.
>
>By activating segwit immediately and separately from any HF we can
>scale quickly without risking a rushed combined segwit+HF that would
>almost certainly cause widespread issues.
>
>Draft proposal:
>https://github.com/jameshilliard/bips/blob/bip-segsignal/bip-segsignal.
mediawiki
>
>Proposal text:
><pre>
>  BIP: segsignal
>  Layer: Consensus (soft fork)
>Title: Reduced signalling threshold activation of existing segwit
>deployment
>  Author: James Hilliard <james.hilliard1 at gmail.com>
>  Status: Draft
>  Type: Standards Track
>  Created: 2017-05-22
>  License: BSD-3-Clause
>           CC0-1.0
></pre>
>
>==Abstract==
>
>This document specifies a method to activate the existing BIP9 segwit
>deployment with a majority hashpower less than 95%.
>
>==Definitions==
>
>"existing segwit deployment" refer to the BIP9 "segwit" deployment
>using bit 1, between November 15th 2016 and November 15th 2017 to
>activate BIP141, BIP143 and BIP147.
>
>==Motivation==
>
>Segwit increases the blocksize, fixes transaction malleability, and
>makes scripting easier to upgrade as well as bringing many other
>[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].
>
>This BIP provides a way for a simple majority of miners to coordinate
>activation of the existing segwit deployment with less than 95%
>hashpower. For a number of reasons a complete redeployment of segwit
>is difficulty to do until the existing deployment expires. This is due
>to 0.13.1+ having many segwit related features active already,
>including all the P2P components, the new network service flag, the
>witness-tx and block messages, compact blocks v2 and preferential
>peering. A redeployment of segwit will need to redefine all these
>things and doing so before expiry would greatly complicate testing.
>
>==Specification==
>
>While this BIP is active, all blocks must set the nVersion header top
>3 bits to 001 together with bit field (1<<1) (according to the
>existing segwit deployment). Blocks that do not signal as required
>will be rejected.
>
>==Deployment==
>
>This BIP will be deployed by a "version bits" with an 80%(this can be
>adjusted if desired) activation threshold BIP9 with the name
>"segsignal" and using bit 4.
>
>This BIP will have a start time of midnight June 1st, 2017 (epoch time
>1496275200) and timeout on midnight November 15th 2017 (epoch time
>1510704000). This BIP will cease to be active when segwit is
>locked-in.
>
>=== Reference implementation ===
>
><pre>
>// Check if Segregated Witness is Locked In
>bool IsWitnessLockedIn(const CBlockIndex* pindexPrev, const
>Consensus::Params& params)
>{
>    LOCK(cs_main);
>    return (VersionBitsState(pindexPrev, params,
>Consensus::DEPLOYMENT_SEGWIT, versionbitscache) ==
>THRESHOLD_LOCKED_IN);
>}
>
>// SEGSIGNAL mandatory segwit signalling.
>if ( VersionBitsState(pindex->pprev, chainparams.GetConsensus(),
>Consensus::DEPLOYMENT_SEGSIGNAL, versionbitscache) == THRESHOLD_ACTIVE
>&&
>     !IsWitnessLockedIn(pindex->pprev, chainparams.GetConsensus()) &&
>// Segwit is not locked in
>     !IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) ) //
>and is not active.
>{
>    bool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) ==
>VERSIONBITS_TOP_BITS;
>    bool fSegbit = (pindex->nVersion &
>VersionBitsMask(chainparams.GetConsensus(),
>Consensus::DEPLOYMENT_SEGWIT)) != 0;
>    if (!(fVersionBits && fSegbit)) {
>        return state.DoS(0, error("ConnectBlock(): relayed block must
>signal for segwit, please upgrade"), REJECT_INVALID, "bad-no-segwit");
>    }
>}
></pre>
>
>https://github.com/bitcoin/bitcoin/compare/0.14...
jameshilliard:segsignal-v0.14.1
>
>==Backwards Compatibility==
>
>This deployment is compatible with the existing "segwit" bit 1
>deployment scheduled between midnight November 15th, 2016 and midnight
>November 15th, 2017. Miners will need to upgrade their nodes to
>support segsignal otherwise they may build on top of an invalid block.
>While this bip is active users should either upgrade to segsignal or
>wait for additional confirmations when accepting payments.
>
>==Rationale==
>
>Historically we have used IsSuperMajority() to activate soft forks
>such as BIP66 which has a mandatory signalling requirement for miners
>once activated, this ensures that miners are aware of new rules being
>enforced. This technique can be leveraged to lower the signalling
>threshold of a soft fork while it is in the process of being deployed
>in a backwards compatible way.
>
>By orphaning non-signalling blocks during the BIP9 bit 1 "segwit"
>deployment, this BIP can cause the existing "segwit" deployment to
>activate without needing to release a new deployment.
>
>==References==
>
>*[https://lists.linuxfoundation.org/pipermail/
bitcoin-dev/2017-March/013714.html
>Mailing list discussion]
>*[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.cpp#L1281-L1283
>P2SH flag day activation]
>*[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]
>*[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]
>*[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]
>*[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for
>Version 0 Witness Program]]
>*[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element
>malleability]]
>*[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit
>deployment]]
>*[[bip-0149.mediawiki|BIP149 Segregated Witness (second deployment)]]
>*[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit
>benefits]
>
>==Copyright==
>
>This document is dual licensed as BSD 3-clause, and Creative Commons
>CC0 1.0 Universal.
>_______________________________________________
>bitcoin-dev mailing list
>bitcoin-dev at lists.linuxfoundation.org
>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170523/9ed12432/attachment-0001.html>

From hampus.sjoberg at gmail.com  Tue May 23 09:47:48 2017
From: hampus.sjoberg at gmail.com (=?UTF-8?Q?Hampus_Sj=C3=B6berg?=)
Date: Tue, 23 May 2017 11:47:48 +0200
Subject: [bitcoin-dev] I do not support the BIP 148 UASF
In-Reply-To: <CAAjy6kC43DX3wpaZ+3skBUO8hVrYt7uNZfw1Ep3GDJs8YA9Gxg@mail.gmail.com>
References: <CAAS2fgRdSOu8N6L3+fBpnye+rM+W6+F=cePy=9oL4tJuCj=Jsw@mail.gmail.com>
	<CAFp6fsGcKip_R7OH217mXBQ8OK9N_3Ea-1HtRin3EtwzvJaBhQ@mail.gmail.com>
	<CAAjy6kC43DX3wpaZ+3skBUO8hVrYt7uNZfw1Ep3GDJs8YA9Gxg@mail.gmail.com>
Message-ID: <CAFMkqK-Ed+8d41_MaCVQHtbapBYC8UnJQr7i_rh9sBHj+yyMXQ@mail.gmail.com>

> Who are we protecting users from, themselves? Are you protecting core?
from what? I am somewhat genuinely befuddled by those who can't even allow
a user config switch to be set.

Indeed. It seems silly. If you're activating the switch, you're most likely
fully aware of what you're doing.
I also saw some very harsh rhetoric being used against BIP148, which seems
unjustified as we have no idea yet how it all will play out. We can only
guess.

Hampus

2017-05-23 6:03 GMT+02:00 Steven Pine via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org>:

> I'm glad some discussion has been moved back here.
>
> Correct me if I am wrong, but currently core developers are arguing over
> whether or not to allow an optional configuration switch which defaults off
> but signals and enforces BIP148 when used. Who are we protecting users
> from, themselves? Are you protecting core? from what? I am somewhat
> genuinely befuddled by those who can't even allow a user config switch to
> be set.
>
> I guess I find it all incredibly silly, but perhaps I suffer from some
> basic confusion.
>
>
>
> On Mon, May 22, 2017 at 3:23 PM, Suhas Daftuar via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> I also do not support the BIP 148 UASF, and I'd like to add to the points
>> that Greg has already raised in this thread.
>>
>> BIP 148 would introduce a new consensus rule that softforks out
>> non-segwit signalling blocks in some time period.  I reject this consensus
>> rule as both arbitrary and needlessly disruptive.  Bitcoin's primary
>> purpose is to reach consensus on the state of a shared ledger, and even
>> though I think the Bitcoin network ought to adopt segwit, I don't think
>> that concern trumps the goal of not splitting the network.
>>
>> Many BIP 148 advocates seem to start with the assumption that segwit
>> already has a lot of support, and suggest that BIP 148 does as well.
>> However I don't think it's fair or correct to separate the activation
>> proposal for segwit from the rest of the segwit proposal.  The deployment
>> parameters for segwit are consensus-critical; assuming that some other
>> deployment has consensus because it would result in the rest of the segwit
>> proposal activating is an unjustified leap.
>>
>> Even if there were no feasible alternate segwit deployment method
>> available to us, I would hesitate to recommend that the network adopt a
>> potentially consensus-splitting approach, even though I firmly believe that
>> the ideas behind segwit are fundamentally good ones.  But fortunately that
>> is not the situation we are in; we have substantially less disruptive
>> methods available to us to activate it, even if the current BIP 9
>> deployment were to fail -- such as another BIP 9 deployment in the future,
>> or perhaps a BIP 149 deployment.
>>
>> If we do pursue a "user-activated" deployment of segwit, I'd recommend
>> that we do so in a more careful way than BIP 148 or 149 currently suggest,
>> which as I understand would otherwise make very few changes to the current
>> implementation.  However, due to the BIP 9 activation assumption, the
>> Bitcoin Core 0.13.1 - 0.14.0 segwit implementation largely lumps together
>> the idea that miners would both enforce the rules and mine segwit blocks.
>> However, we can separate these concerns, as we started to do in the Bitcoin
>> Core 0.14.1 release, where mining segwit blocks is not required in order to
>> generally mine or signal for segwit in the software.  And we can go further
>> still: without too much work, we could make further improvements to
>> accommodate miners who, for whatever reason, don't want to upgrade their
>> systems, such as by improving block relay from pre-segwit peers [1], or
>> optimizing transaction selection for miners who are willing to enforce the
>> segwit rules but haven't upgraded their systems to mine segwit blocks [2].
>>
>> If we would seek to activate a soft-fork with less clear miner signaling
>> (such as BIP 149), then I think such improvements are warranted to minimize
>> network disruption.  In general, we should not seek to censor hashpower on
>> the network unless we have a very important reason for doing so.  While the
>> issues here are nuanced, if I were to evaluate the BIP 148 soft-fork
>> proposal on the spectrum of "censorship attack on Bitcoin" to "benign
>> protocol upgrade", BIP 148 strikes me as closer to the former than the
>> latter.  There is simply no need here to orphan these non-signalling blocks
>> that could otherwise be used to secure the network.
>>
>> To go further: I think BIP 148 is ill-conceived even for achieving its
>> own presumed goals -- the motivation for adding a consensus rule that
>> applies to the version bits on blocks is surely for the effect such bits
>> have on older software, such as Bitcoin Core releases 0.13.1 and later.
>> Yet in trying to bring those implementations along as segwit-enforcing
>> software, BIP 148 would risk forking from such clients in the short term!
>> If one really cared about maintaining consensus with older, segwit-enabled
>> software, it would make far more sense to seek segwit activation in a way
>> that didn't fork from them (such as BIP 149, or a new BIP 9 deployment
>> after this one times out).  And if one doesn't care about such consensus,
>> then it'd be far simpler to just set (e.g.) August 1 as the flag day
>> activation of segwit, and not play these contortionist games with block
>> version bits, which carry no useful or intrinsic meaning.  Either of these
>> two approaches should have the advantage of reduced fork risk, compared
>> with BIP 148.
>>
>> Of course, everyone is free to run the software of their choosing.  I
>> write this to both generally convey my opposition to a careless proposal,
>> which I believe represents a way of thinking that is detrimental to
>> Bitcoin's long run success, and specifically explain why I oppose inclusion
>> of this proposal in the Bitcoin Core implementation [3].  The Bitcoin Core
>> project hasn't been, and shouldn't be, careless in deploying consensus
>> changes.  Instead, I think the Bitcoin Core project ought to stand up for
>> the best practices that our community has learned about how to deploy such
>> changes (specifically for minimizing chain-split risk when deploying a soft
>> fork!), and I think we should all avoid adoption or encouragement of
>> practices that would depart from the high standards we are capable of
>> achieving.
>>
>>
>>  [1] https://lists.linuxfoundation.org/pipermail/bitcoin-
>> dev/2017-March/013811.html
>>  [2] https://github.com/bitcoin/bitcoin/pull/9955
>>  [3] https://github.com/bitcoin/bitcoin/pull/10428#issuecomment-303098925
>>
>>
>> --Suhas Daftuar
>>
>>
>> On Fri, Apr 14, 2017 at 3:56 AM, Gregory Maxwell via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> I do not support the BIP148 UASF for some of the same reasons that I
>>> do support segwit:  Bitcoin is valuable in part because it has high
>>> security and stability, segwit was carefully designed to support and
>>> amplify that engineering integrity that people can count on now and
>>> into the future.
>>>
>>> I do not feel the the approach proposed in BIP148 really measures up
>>> to the standard set by segwit itself, or the existing best practices
>>> in protocol development in this community.
>>>
>>> The primary flaw in BIP148 is that by forcing the activation of the
>>> existing (non-UASF segwit) nodes it almost guarantees at a minor level
>>> of disruption.
>>>
>>> Segwit was carefully engineered so that older unmodified miners could
>>> continue operating _completely_ without interruption after segwit
>>> activates.
>>>
>>> Older nodes will not include segwit spends, and so their blocks will
>>> not be invalid even if they do not have segwit support. They can
>>> upgrade to it on their own schedule. The only risk non-participating
>>> miners take after segwit activation is that if someone else mines an
>>> invalid block they would extend it, a risk many miners already
>>> frequently take with spy-mining.
>>>
>>> I do not think it is a horrible proposal: it is better engineered than
>>> many things that many altcoins do, but just not up to our normal
>>> standards. I respect the motivations of the authors of BIP 148.  If
>>> your goal is the fastest possible segwit activation then it is very
>>> useful to exploit the >80% of existing nodes that already support the
>>> original version of segwit.
>>>
>>> But the fastest support should not be our goal, as a community-- there
>>> is always some reckless altcoin or centralized system that can support
>>> something faster than we can-- trying to match that would only erode
>>> our distinguishing value in being well engineered and stable.
>>>
>>> "First do no harm." We should use the least disruptive mechanisms
>>> available, and the BIP148 proposal does not meet that test.  To hear
>>> some people-- non-developers on reddit and such-- a few even see the
>>> forced orphaning of 148 as a virtue, that it's punitive for
>>> misbehaving miners. I could not not disagree with that perspective any
>>> more strongly.
>>>
>>> Of course, I do not oppose the general concept of a UASF but
>>> _generally_ a soft-fork (of any kind) does not need to risk disruption
>>> of mining, just as segwit's activation does not.  UASF are the
>>> original kind of soft-fork and were the only kind of fork practiced by
>>> Satoshi. P2SH was activated based on a date, and all prior ones were
>>> based on times or heights.  We introduced miner based activation as
>>> part of a process of making Bitcoin more stable in the common case
>>> where the ecosystem is all in harmony.  It's kind of weird to see UASF
>>> portrayed as something new.
>>>
>>> It's important the users not be at the mercy of any one part of the
>>> ecosystem to the extent that we can avoid it-- be it developers,
>>> exchanges, chat forums, or mining hardware makers.  Ultimately the
>>> rules of Bitcoin work because they're enforced by the users
>>> collectively-- that is what makes Bitcoin Bitcoin, it's what makes it
>>> something people can count on: the rules aren't easy to just change.
>>>
>>> There have been some other UASF proposals that avoid the forced
>>> disruption-- by just defining a new witness bit and allowing
>>> non-upgraded-to-uasf miners and nodes to continue as non-upgraded, I
>>> think they are vastly superior. They would be slower to deploy, but I
>>> do not think that is a flaw.
>>>
>>> We should have patience. Bitcoin is a system that should last for all
>>> ages and power mankind for a long time-- ten years from now a couple
>>> years of dispute will seem like nothing. But the reputation we earn
>>> for stability and integrity, for being a system of money people can
>>> count on will mean everything.
>>>
>>> If these discussions come up, they'll come up in the form of reminding
>>> people that Bitcoin isn't easily changed at a whim, even when the
>>> whims are obviously good, and how that protects it from being managed
>>> like all the competing systems of money that the world used to use
>>> were managed. :)
>>>
>>> So have patience, don't take short cuts.  Segwit is a good improvement
>>> and we should respect it by knowing that it's good enough to wait for,
>>> and for however its activated to be done the best way we know how.
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>
>
> --
> Steven Pine
> (510) 517-7075
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170523/0a7c89a0/attachment-0001.html>

From tier.nolan at gmail.com  Tue May 23 09:51:26 2017
From: tier.nolan at gmail.com (Tier Nolan)
Date: Tue, 23 May 2017 10:51:26 +0100
Subject: [bitcoin-dev] Drivechain -- Request for Discussion
In-Reply-To: <CA+XQW1hRhcxJBoOJ57YG0t5y5j1Qm3RO4wr2eXV5V-UzDaiPPw@mail.gmail.com>
References: <24f2b447-a237-45eb-ef9f-1a62533fad5c@gmail.com>
	<dhstGQudLBiwjDlaRrmMfy-ixwvXcwMr1CzCkPKh285RLICGZixkbdwpTDc2Sgz8eYIqSem8lwxW6QeJCD7aFfwQjLDnZ2NmOw0Zzd-KgSs=@protonmail.com>
	<CA+XQW1jZpJ9wnEg47fouyywL09=_vU8dMP3owkkuNqRvzTZUDg@mail.gmail.com>
	<CAE-z3OUYuAXE2+h60A=r4UyGU4CSQuF98oFgHnD7iaj-=Z=yOw@mail.gmail.com>
	<CA+XQW1hRhcxJBoOJ57YG0t5y5j1Qm3RO4wr2eXV5V-UzDaiPPw@mail.gmail.com>
Message-ID: <CAE-z3OVWXN58X-+nAFTm61G1=v_1xrniyrBy8x=VRG4N149aXQ@mail.gmail.com>

On Mon, May 22, 2017 at 9:00 PM, Paul Sztorc <truthcoin at gmail.com> wrote:

> I would replace "Bitcoins you manage to steal" with "Bitcoins you manage
> to double-spend". Then, it still seems the same to me.
>
>
With double spending, you can only get ownership of coins that you owned at
some point in the past.  Coins that are owned by someone else from coinbase
to their current owners cannot be stolen by a re-org (though they can be
moved around).

With BMM, you can take the entire reserve.  Creating a group of double
spenders can help increase the reward.


>
> It may destroy great value if it shakes confidence in the sidechain
> infrastructure. Thus, the value of the stolen BTC may decrease, in addition
> to the lost future tx fee revenues of the attacked chain.
>
> http://www.truthcoin.info/blog/drivechain/#drivechains-security
>
>
That is a fair point.  If sidechains are how Bitcoin is scaled, then
shaking confidence in a side-chain would shake confidence in Bitcoin's
future.

I wasn't thinking of a direct miner 51% attack.  It is enough to assume
that a majority of the miners go with the highest bidder each time.

If (average fees) * (timeout) is less than the total reserves, then it is
worth it for a 3rd party to just bid for his theft fork.  Miners don't have
to be assumed to be coordinating, they just have to be assumed to take the
highest bid.

Again, I don't really think it is that different. One could interchange
> "recent txns" (those which could be double-spent within 2-3 weeks) with
> "sidechain deposit tnxs".
>

It is not "recent txns", it is recent txns that you (or your group) have
the key for.  No coordination is required to steal the entire reserve from
the sidechain.

Recent txns and money on the sidechain have the property that they are
riskier than money deep on the main chain.  This is the inherent point
about sidechains, so maybe not that big a deal.

My concern is that you could have a situation where an attack is possible
and only need to assume that the miners are indifferent.

If the first attacker who tries it fails (say after creating a fork that is
90% of the length required, so losing a lot of money), then it would
discourage others.   If he succeeds, then it weakens sidechains as a
concept and that creates the incentive for miners to see that he fails.

I wonder how the incentives work out.  If a group had 25% of the money on
the sidechain, they could try to outbid the attacker.

In fact, since the attacker, by definition, creates an illegal fork, the
effect is that he reduces the block rate for the side chain (possibly to
zero, if he wins every auction).  This means that there are more
transactions per block, if there is space, or more fees per transaction, if
the blocks are full.

In both cases, this pushes up the total fees per block, so he has to pay
more per block, weakening his attack.  This is similar to where transaction
spam on Bitcoin is self-correcting by increasing the fees required to keep
the spam going.

Is there a description of the actual implementation you decided to go with,
other than the code?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170523/69551868/attachment.html>

From tomas at tomasvdw.nl  Tue May 23 10:50:37 2017
From: tomas at tomasvdw.nl (Tomas)
Date: Tue, 23 May 2017 12:50:37 +0200
Subject: [bitcoin-dev] Proposal to allow users to configure the maximum
 block weight based on a support threshold
Message-ID: <1495536637.1801543.985680712.6B788409@webmail.messagingengine.com>

I have a proposal that would allow each user to optionally configure the
maximum block weight at a support threshold.

It recognizes that there is no need for off chain bickering, by
providing a mechanism that lets each users freely choose their own
parameters while still maintaining full coordination of any changes.

The BIP can be found here: 

https://github.com/tomasvdw/bips/blob/master/bip-changing-the-maximum-block%20weight-based-on-a-support-threshold.mediawiki

It is worth noting that this proposal does neither gives more power to
miners nor reduces decentralization. Miners still rely on their blocks
being accepted by economic nodes to sell their minted coins. This
proposal doesn't change that. 

Regards,
Tomas van der Wansem
bitcrust

From karljohan-alm at garage.co.jp  Tue May 23 06:30:01 2017
From: karljohan-alm at garage.co.jp (Karl Johan Alm)
Date: Tue, 23 May 2017 15:30:01 +0900
Subject: [bitcoin-dev] I do not support the BIP 148 UASF
In-Reply-To: <CAAjy6kC43DX3wpaZ+3skBUO8hVrYt7uNZfw1Ep3GDJs8YA9Gxg@mail.gmail.com>
References: <CAAS2fgRdSOu8N6L3+fBpnye+rM+W6+F=cePy=9oL4tJuCj=Jsw@mail.gmail.com>
	<CAFp6fsGcKip_R7OH217mXBQ8OK9N_3Ea-1HtRin3EtwzvJaBhQ@mail.gmail.com>
	<CAAjy6kC43DX3wpaZ+3skBUO8hVrYt7uNZfw1Ep3GDJs8YA9Gxg@mail.gmail.com>
Message-ID: <CALJw2w54A_SL-p4iUX_bE3CJidPxNhb09On9XfUAYxmpV8ekpQ@mail.gmail.com>

On Tue, May 23, 2017 at 1:03 PM, Steven Pine via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Correct me if I am wrong, but currently core developers are arguing over
> whether or not to allow an optional configuration switch which defaults off
> but signals and enforces BIP148 when used. Who are we protecting users from,
> themselves? Are you protecting core? from what? I am somewhat genuinely
> befuddled by those who can't even allow a user config switch to be set.

Essentially, if we make a potentially very harmful option easy to
enable for users, we are putting them at risk, so yes, this is about
protecting users of the base Bitcoin Core implementation. Users have,
hopefully, come to appreciate this implementation for the peer
review-based strict development process, and making a hasty decision
due to time constraints (segwit activation expiration) may have
undesirable consequences. Opinions among the regular contributors are
split on the matter, which to me is an indication we should be
cautious and consider all aspects before making a decision on the
matter.

From kekcoin at protonmail.com  Tue May 23 09:51:19 2017
From: kekcoin at protonmail.com (Kekcoin)
Date: Tue, 23 May 2017 05:51:19 -0400
Subject: [bitcoin-dev] Reduced signalling threshold activation of
	existing segwit deployment
In-Reply-To: <CADvTj4pQ8eJvzm9UOgC8bYm1ERGuTX7qq+a7etRe55S=KodrHQ@mail.gmail.com>
References: <CADvTj4pQ8eJvzm9UOgC8bYm1ERGuTX7qq+a7etRe55S=KodrHQ@mail.gmail.com>
Message-ID: <W5v1NIvVzD9MK1pTmq3ybIYadLtHyqJR58hu4_Rl_02DDDq6gIvT8dAvPFagolqKaws4Up9ywMhyXS1sWqJ4t_TBr7od5RRqIMuk9jz_4W4=@protonmail.com>

I think there may be merit to this idea, allowing for political compromise without sacrificing the technological integrity of Bitcoin. There are a few mechanical problems I see with it, though.

1. It should change its activation logic from BIP9-style to BIP8-style with a flagday of August 1. This to maintain backwards compatibility with the current deployment of BIP148 nodes. This proposal seems to be a measure to prevent a chainsplit, so it must make sure to avoid triggering one.

2. This should be for miners only; non-miners should not enforce this. It severely weakens the block-signalling activation mechanism in several ways (lowered threshold, short deployment timeframe, no "locked in" delay before activation) and by doing so opens up attack vectors for consensus-partitioning attacks using malicious false signalling. For non-miners that seek to take their fate into their own hands, enforcing BIP148 is enough.

3. Even for miners this is more risky than usual; only 31% of hashrate is required to false-signal the activation to fork-off honest miners. This attack vector is magnified by the lack of "locked in" delay that would allow laggards to upgrade before activation. I suggest adding in at least a 1-week lock-in period (given the shorter timeframes 2 weeks may eat up too much of the available voting time before the brick wall of BIP148 activation on August 1).

Under the assumption that this is indeed compatible with the terms of the Silbert agreement, we can presume the involved miners are willing to trust eachother more than usual so such a short lock-in period should be acceptable.

-------- Original Message --------
Subject: [bitcoin-dev] Reduced signalling threshold activation of existing segwit deployment
Local Time: May 23, 2017 1:40 AM
UTC Time: May 22, 2017 10:40 PM
From: bitcoin-dev at lists.linuxfoundation.org
To: Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>

I would like to propose an implementation that accomplishes the first
part of the Barry Silbert proposal independently from the second:

"Activate Segregated Witness at an 80% threshold, signaling at bit 4"
in a way that

The goal here is to minimize chain split risk and network disruption
while maximizing backwards compatibility and still providing for rapid
activation of segwit at the 80% threshold using bit 4.

By activating segwit immediately and separately from any HF we can
scale quickly without risking a rushed combined segwit+HF that would
almost certainly cause widespread issues.

Draft proposal:
https://github.com/jameshilliard/bips/blob/bip-segsignal/bip-segsignal.mediawiki

Proposal text:
<pre>
BIP: segsignal
Layer: Consensus (soft fork)
Title: Reduced signalling threshold activation of existing segwit deployment
Author: James Hilliard <james.hilliard1 at gmail.com>
Status: Draft
Type: Standards Track
Created: 2017-05-22
License: BSD-3-Clause
CC0-1.0
</pre>

==Abstract==

This document specifies a method to activate the existing BIP9 segwit
deployment with a majority hashpower less than 95%.

==Definitions==

"existing segwit deployment" refer to the BIP9 "segwit" deployment
using bit 1, between November 15th 2016 and November 15th 2017 to
activate BIP141, BIP143 and BIP147.

==Motivation==

Segwit increases the blocksize, fixes transaction malleability, and
makes scripting easier to upgrade as well as bringing many other
[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].

This BIP provides a way for a simple majority of miners to coordinate
activation of the existing segwit deployment with less than 95%
hashpower. For a number of reasons a complete redeployment of segwit
is difficulty to do until the existing deployment expires. This is due
to 0.13.1+ having many segwit related features active already,
including all the P2P components, the new network service flag, the
witness-tx and block messages, compact blocks v2 and preferential
peering. A redeployment of segwit will need to redefine all these
things and doing so before expiry would greatly complicate testing.

==Specification==

While this BIP is active, all blocks must set the nVersion header top
3 bits to 001 together with bit field (1<<1) (according to the
existing segwit deployment). Blocks that do not signal as required
will be rejected.

==Deployment==

This BIP will be deployed by a "version bits" with an 80%(this can be
adjusted if desired) activation threshold BIP9 with the name
"segsignal" and using bit 4.

This BIP will have a start time of midnight June 1st, 2017 (epoch time
1496275200) and timeout on midnight November 15th 2017 (epoch time
1510704000). This BIP will cease to be active when segwit is
locked-in.

=== Reference implementation ===

<pre>
// Check if Segregated Witness is Locked In
bool IsWitnessLockedIn(const CBlockIndex* pindexPrev, const
Consensus::Params& params)
{
LOCK(cs_main);
return (VersionBitsState(pindexPrev, params,
Consensus::DEPLOYMENT_SEGWIT, versionbitscache) ==
THRESHOLD_LOCKED_IN);
}

// SEGSIGNAL mandatory segwit signalling.
if ( VersionBitsState(pindex->pprev, chainparams.GetConsensus(),
Consensus::DEPLOYMENT_SEGSIGNAL, versionbitscache) == THRESHOLD_ACTIVE
&&
!IsWitnessLockedIn(pindex->pprev, chainparams.GetConsensus()) &&
// Segwit is not locked in
!IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) ) //
and is not active.
{
bool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) ==
VERSIONBITS_TOP_BITS;
bool fSegbit = (pindex->nVersion &
VersionBitsMask(chainparams.GetConsensus(),
Consensus::DEPLOYMENT_SEGWIT)) != 0;
if (!(fVersionBits && fSegbit)) {
return state.DoS(0, error("ConnectBlock(): relayed block must
signal for segwit, please upgrade"), REJECT_INVALID, "bad-no-segwit");
}
}
</pre>

https://github.com/bitcoin/bitcoin/compare/0.14...jameshilliard:segsignal-v0.14.1

==Backwards Compatibility==

This deployment is compatible with the existing "segwit" bit 1
deployment scheduled between midnight November 15th, 2016 and midnight
November 15th, 2017. Miners will need to upgrade their nodes to
support segsignal otherwise they may build on top of an invalid block.
While this bip is active users should either upgrade to segsignal or
wait for additional confirmations when accepting payments.

==Rationale==

Historically we have used IsSuperMajority() to activate soft forks
such as BIP66 which has a mandatory signalling requirement for miners
once activated, this ensures that miners are aware of new rules being
enforced. This technique can be leveraged to lower the signalling
threshold of a soft fork while it is in the process of being deployed
in a backwards compatible way.

By orphaning non-signalling blocks during the BIP9 bit 1 "segwit"
deployment, this BIP can cause the existing "segwit" deployment to
activate without needing to release a new deployment.

==References==

*[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013714.html
Mailing list discussion]
*[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.cpp#L1281-L1283
P2SH flag day activation]
*[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]
*[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]
*[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]
*[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for
Version 0 Witness Program]]
*[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element malleability]]
*[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit deployment]]
*[[bip-0149.mediawiki|BIP149 Segregated Witness (second deployment)]]
*[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit benefits]

==Copyright==

This document is dual licensed as BSD 3-clause, and Creative Commons
CC0 1.0 Universal.
_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170523/803c74dc/attachment-0001.html>

From luke at dashjr.org  Tue May 23 12:55:26 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Tue, 23 May 2017 12:55:26 +0000
Subject: [bitcoin-dev] I do not support the BIP 148 UASF
In-Reply-To: <CALJw2w54A_SL-p4iUX_bE3CJidPxNhb09On9XfUAYxmpV8ekpQ@mail.gmail.com>
References: <CAAS2fgRdSOu8N6L3+fBpnye+rM+W6+F=cePy=9oL4tJuCj=Jsw@mail.gmail.com>
	<CAAjy6kC43DX3wpaZ+3skBUO8hVrYt7uNZfw1Ep3GDJs8YA9Gxg@mail.gmail.com>
	<CALJw2w54A_SL-p4iUX_bE3CJidPxNhb09On9XfUAYxmpV8ekpQ@mail.gmail.com>
Message-ID: <201705231255.27861.luke@dashjr.org>

On Tuesday 23 May 2017 6:30:01 AM Karl Johan Alm via bitcoin-dev wrote:
> Essentially, if we make a potentially very harmful option easy to
> enable for users, we are putting them at risk, so yes, this is about
> protecting users of the base Bitcoin Core implementation.

In this case, NOT enforcing BIP148 puts users at more risk. Since devs are 
divided in opinion, we should at the very least have an option to let users 
decide one way or the other.

Luke

From jtimon at jtimon.cc  Tue May 23 13:20:10 2017
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Tue, 23 May 2017 15:20:10 +0200
Subject: [bitcoin-dev] I do not support the BIP 148 UASF
In-Reply-To: <201705231255.27861.luke@dashjr.org>
References: <CAAS2fgRdSOu8N6L3+fBpnye+rM+W6+F=cePy=9oL4tJuCj=Jsw@mail.gmail.com>
	<CAAjy6kC43DX3wpaZ+3skBUO8hVrYt7uNZfw1Ep3GDJs8YA9Gxg@mail.gmail.com>
	<CALJw2w54A_SL-p4iUX_bE3CJidPxNhb09On9XfUAYxmpV8ekpQ@mail.gmail.com>
	<201705231255.27861.luke@dashjr.org>
Message-ID: <CABm2gDoebzbBHKQw66NzHwZPTwMONUZXo-mt3YoP03HPaxm1rA@mail.gmail.com>

On Tue, May 23, 2017 at 2:55 PM, Luke Dashjr via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> On Tuesday 23 May 2017 6:30:01 AM Karl Johan Alm via bitcoin-dev wrote:
>> Essentially, if we make a potentially very harmful option easy to
>> enable for users, we are putting them at risk, so yes, this is about
>> protecting users of the base Bitcoin Core implementation.
>
> In this case, NOT enforcing BIP148 puts users at more risk. Since devs are
> divided in opinion, we should at the very least have an option to let users
> decide one way or the other.

Well, it's putting users at more risk only if for those users who
actively decided to put themselves at risk.
I also feel bip148 is rushed and that makes it more risky. I don't
want to reiterate points other have made but I don't fully agree with
all of them.
I prefer the way it is over the way it was (just activating at a given
date without forcing mining signaling), but I still think it's rushed
and unnecessarily risky (unless activating segwit was urgent, which I
think it's not, no matter how much I want it to become active as soon
as possible).
On the other hand, I support uasf and bip8 to replace bip9 for future
deployments, since bip9 made assumptions that weren't correct (like
assuming miners would always signal changes that don't harm any user
and are good for some of them).
Perhaps bip149 can be modified to activate earlier if the current
proposal is perceived as unnecessarily cautious.

Luke, I've seen you say in other forums that "bip148 is less risky
than bip149", but I think that's clearly false.

As a reminder, one of my complains about bip109 was precisely that it
was also rushed in how fast it could activate.

From truthcoin at gmail.com  Tue May 23 14:12:24 2017
From: truthcoin at gmail.com (Paul Sztorc)
Date: Tue, 23 May 2017 10:12:24 -0400
Subject: [bitcoin-dev] Drivechain -- Request for Discussion
In-Reply-To: <FSrvrfLYPlLQULODf79GXk7yzJHCRD8FOiLzLGZFS5BYuGn_WL8hRsqQD1BEQjT54RATE7hqlqjYthzJgNfZOdgy4hJMBB5osv3dspyIwX0=@protonmail.com>
References: <24f2b447-a237-45eb-ef9f-1a62533fad5c@gmail.com>
	<dhstGQudLBiwjDlaRrmMfy-ixwvXcwMr1CzCkPKh285RLICGZixkbdwpTDc2Sgz8eYIqSem8lwxW6QeJCD7aFfwQjLDnZ2NmOw0Zzd-KgSs=@protonmail.com>
	<CA+XQW1jZpJ9wnEg47fouyywL09=_vU8dMP3owkkuNqRvzTZUDg@mail.gmail.com>
	<FSrvrfLYPlLQULODf79GXk7yzJHCRD8FOiLzLGZFS5BYuGn_WL8hRsqQD1BEQjT54RATE7hqlqjYthzJgNfZOdgy4hJMBB5osv3dspyIwX0=@protonmail.com>
Message-ID: <56d88784-9eb1-8883-0418-68aa98b74a6e@gmail.com>



On 5/22/2017 8:13 PM, ZmnSCPxj wrote:
> Good morning,
> 
> 
> 
>>What you read is only an introduction of BMM. You may also consult the
> notes (at the bottom of the BMM post) or the code, although this is time
> consuming of course.
> 
> Looking over the code, I have a question: Is OP_BRIBE supposed to be
> softforked in, or hardforked?

Softforked, of course.

  From my understanding, the code as
> published in your linked github cannot be softforked in, since it is not
> a softfork-compatible replacement for OP_NOP: it replaces the stack top
> value with a 0/1 value.  Both CLTV and CSV do not touch the stack, only
> flag an error if they fail.

Your understanding may exceed my own. I don't understand the principle
of your distinction, as it seems to me that one could add a new protocol
rule which says that the block is invalid unless the OP Code does
results in arbitrary-item-x. The intent is to mimic CLTV or CSV
behavior, by causing something that would otherwise succeed, to fail, if
arbitrary new conditions are met.

> 
> (What happens if the h* to be put in the coinbase, by chance - even very
> unlikely chance - is 0?  Then <h*> OP_NOP4 is not the same as <h*>
> OP_BRIBE scripts in result - the former will be rejected by old nodes,
> the latter will be accepted by new nodes)

That would indeed be a bug, if it happened as you described. I will
check when I get the chance, thanks.

> 
> Is OP_BRIBE the same as the OP_h_is_in_coinbase operation you described?

Yes. Sorry if that was confusing.

> 
> How is OP_BRIBE superior to just using a <h*> OP_RETURN script? Cannot
> a sidechain scan the block for OP_RETURN attesting that the block hash
> is present in the block?

The sidechain software can indeed, but the mainchain software cannot
(without making validation of both chains part of the mainchain, which
defeats the original purpose of sidechains).

The purpose of OP_BRIBE is to allow "Sam" (on the sidechain) and "Mary"
(a mainchain miner) to work together. Sam would pay X BTC to Mary, if
Mary could provide Sam with some guarantee that Sam's sidechain block
[defined by h*] would make it into the largest chain.

So, as I see it, this needs to be a mainchain consensus rule, but one
which enforces the bare minimum criteria.


> 
>>The literal answer to your question is that mainchain Bitcoin will
> notice that, for the second withdrawal, the sum of the inputs is less
> than the sum of the outputs and they the transaction is therefore invalid.
> 
> You misunderstand.  The first withdrawal was done by double-spending,
> and exchanging your sidechain funds for mainchain funds using some
> off-chain method.  The second withdrawal is done on-chain.

If A, B, and C are transacting, and each has an account on both chains.
Then your example would be something like:

1. main:A sends 100 to side:A, then transfers 100 to side:B in exchange
for B's good or service (provided on the sidechain)
2. side:B attempts to move side-to-main with the 100 BTC, using the
lightning network. He swaps 100 side:BTC for 100 of C's main:BTC.
3. C attempts to move side-to-main, using the slow, settlement method.
4. C's side-to-main sidechain tx (wt) is bundled with others and becomes
a withdrawal attempt (WT^)
5. The WT^ attempt is initiated on the mainchain.
6. After a waiting period, the WT^ begins to accumulate ACKs or NACKs
(upvotes / downvotes), on the mainchain.
7. The transaction either succeeds or fails.

I'm not sure, but your question seems to concern B, who exploits a reorg
that happens just after step 2. After the reorg, the sidechain chain
history will have a different side-to-main withdrawal in part 3. The
time between each of these step is very long, on the order of weeks
(summing to a length of time totaling months), for exactly this reason
(as well as to encourage people to avoid using this 'formal' method, in
favor of the cooperative LN and Atomic Swaps).

I think that this principle of scale (ie, very VERY slow withdrawals) is
important and actually makes the security categorically different.

For extraordinary DAO-like situations, disinterested mainchain miners
merely need a single bit of information (per sidechain), which is
"distress=true", and indicates to them to temporarily stop ACKing
withdrawals from the sidechain. This alone is enough to give the reorg
an unlimited amount of time to work itself out.


> 
> That said, I confused OP_h_is_in_coinbase as your method of getting out
> of the sidechain into the mainchain.  It seems, OP_h_is_in_coinbase is
> only for blind mining?

Correct

> 
> 
> 
>>I feel that my proposal is more secure, as it can operate healthily and
> quickly while using spv proofs which are much slower and much much
> easier to audit.
> 
> I don't quite understand how Drivechain handles sidechain reorgs, while
> keeping Bitcoin miners blinded.  It seems sidechains need to be known
> ("seen") by the miner, so I don't see what is being blinded by blinded
> merge mining.

Mainchain miners do need to maintain some data about the sidechains, but
this is very minimal, and certainly does not include the transaction
data (or arbitrary messages) of the sidechain.
> 
> 
>>>seems to me that your OP_is_h_in_coinbase should scan a series of
> sidechain block headers backed by mainchain (meaning at the minimum that
> sidechains should have some common header format prefix), rather than
> just mainchain depth as your article seems to imply.
>>
>>How would security be improved as a result? In either case, 51% of
> hashrate can cause a reorg. The sidechain software itself does scan
> block headers, of course. 
> 
> I misunderstand the purpose of your OP_is_h_in_coinbase, sorry.
> 

No problem.

> 
>>>Blind merged mining seems strictly inferior ... a rich attacker can
> simply reorg the sidechain outright without playing such games.
>>
>>In the future, when there is no block subsidy, a rich attacker can also
> do that in mainchain Bitcoin.
> 
> I see.  However, block subsidies will drop far in the future, do you
> mean to say, that sidechains will be used only in the far future?

In one sense, I mean "you have already endorsed this 'fees only will
work' premise, by endorsing Bitcoin".

In another sense I mean "isn't it great that you will get a tiny
preview, today, of future-Bitcoin's behavior?".

> 
>>>How does your proposal handle multiple side block creators on the same
> sidechain, with the possibility that chain splits occur?
>>
>>The side block is only "mined" if it is committed to in a mainchain
> Bitcoin blog, and each mainchain block can only contain one block per
> sidechain. In this way, drivechain sidechains are different from
> classical Namecoin merged mining (where one _could_ run the entire
> system, mining included, without interfacing with Bitcoin at all).
> 
> I assume you mean "mainchain Bitcoin block" here.
> 
> What mechanism ensures only one mainchain block can contain only one
> sidechain block?  It seems, this isn't implemented by OP_BRIBE yet.  Can
> you elaborate on this mechanism?

That mechanism is enforced by drivechain itself, not OP_BRIBE. (OP Bribe
is itself only ~half of BMM. I admit it is getting a little confusing.)

Drivechain requires a soft fork to add each new sidechain. It requires
this literally for a few good reasons...but the best is: there is an
implicit requirement that the miners not steal from the sidechain
anyway. In this way drivechain knows how to keep track of what it should
expect.

> 
> 
>>>Regarding your dig about people who dislike data centers, the main
> issue with miners blindly accepting sidechain commitments is that it
> violates "Don't trust, verify", not that allows datacenters to be
> slightly smaller by not including side:nodes.
>>
>>As I explain early on, in earlier rounds of peer review, the focus was
> on harms the sidechain technology might do to mainchain Bitcoin, and the
> "datacenter point" was specifically the chief objection raised. So I am
> afraid you are entirely incorrect.
> 
> I see.  It seems, the main problem, is that sidechains can be used to
> sneak in block size increases.  Of course, the advantage of sidechains,
> is that when it increases block size irresponsibly, only those who
> participated in the sidechain will suffer.

Precisely.

> 
>>In point of fact, the transactions *are* validated...by sidechain full
> nodes, same as Bitcoin proper.
> 
> But from blind merge mining by itself, how would the blinded merge miner
> know that there exists an actual sidechain full node that actually did
> validation?
> 
> It seems, that the "blinding" in merge mining does not seem to be at all
> useful without the miner actually seeing the sidechain.  If you want
> miners to upgrade to side:fullnode as well, what would then be the point
> of blinding?  Why not just ordinary merge mining?
> 
> Perhaps the datacenter point is simply that your proposal suggests to
> reduce the size of the datacenter by removing surge suppressors and
> UPS's, to avoid some definition of "datacenter is a room with >$XXX of
> equipment".

I hope that my replies above already help with these. If not, let me know.

Thanks for your attention,
Paul

From truthcoin at gmail.com  Tue May 23 14:22:43 2017
From: truthcoin at gmail.com (Paul Sztorc)
Date: Tue, 23 May 2017 10:22:43 -0400
Subject: [bitcoin-dev] Drivechain -- Request for Discussion
In-Reply-To: <CAE-z3OVWXN58X-+nAFTm61G1=v_1xrniyrBy8x=VRG4N149aXQ@mail.gmail.com>
References: <24f2b447-a237-45eb-ef9f-1a62533fad5c@gmail.com>
	<dhstGQudLBiwjDlaRrmMfy-ixwvXcwMr1CzCkPKh285RLICGZixkbdwpTDc2Sgz8eYIqSem8lwxW6QeJCD7aFfwQjLDnZ2NmOw0Zzd-KgSs=@protonmail.com>
	<CA+XQW1jZpJ9wnEg47fouyywL09=_vU8dMP3owkkuNqRvzTZUDg@mail.gmail.com>
	<CAE-z3OUYuAXE2+h60A=r4UyGU4CSQuF98oFgHnD7iaj-=Z=yOw@mail.gmail.com>
	<CA+XQW1hRhcxJBoOJ57YG0t5y5j1Qm3RO4wr2eXV5V-UzDaiPPw@mail.gmail.com>
	<CAE-z3OVWXN58X-+nAFTm61G1=v_1xrniyrBy8x=VRG4N149aXQ@mail.gmail.com>
Message-ID: <141a0cd1-9d4f-c137-a349-17248f9cafd4@gmail.com>



On 5/23/2017 5:51 AM, Tier Nolan via bitcoin-dev wrote:
> On Mon, May 22, 2017 at 9:00 PM, Paul Sztorc <truthcoin at gmail.com
> <mailto:truthcoin at gmail.com>> wrote:
> 
>     I would replace "Bitcoins you manage to steal" with "Bitcoins you
>     manage to double-spend". Then, it still seems the same to me.
> 
> 
> With double spending, you can only get ownership of coins that you owned
> at some point in the past.  Coins that are owned by someone else from
> coinbase to their current owners cannot be stolen by a re-org (though
> they can be moved around).

I'm not sure it makes much of a difference. First of all, in point of
fact, the miners themselves own the coins from the coinbase. But more
importantly, even if miners did not explicitly own the coins, they might
profit by being bribed -- these bribes would come from people who did
own the coins.

The principle is that value "v' has been taken from A and given to B.
This is effectively coercive activity, and therefore itself has value
proportional to 'v'.

> 
> With BMM, you can take the entire reserve.  Creating a group of double
> spenders can help increase the reward.
>  
> 
> 
>     It may destroy great value if it shakes confidence in the sidechain
>     infrastructure. Thus, the value of the stolen BTC may decrease, in
>     addition to the lost future tx fee revenues of the attacked chain.
> 
>     http://www.truthcoin.info/blog/drivechain/#drivechains-security
>     <http://www.truthcoin.info/blog/drivechain/#drivechains-security>
> 
> 
> That is a fair point.  If sidechains are how Bitcoin is scaled, then
> shaking confidence in a side-chain would shake confidence in Bitcoin's
> future.

Yes. The more value _on_ the sidechain, the more abhorrent the malfeasance.

> 
> I wasn't thinking of a direct miner 51% attack.  It is enough to assume
> that a majority of the miners go with the highest bidder each time.

What do you think of my argument, that we already labor under such an
assumption? An attacker could pay fees today equal to greater than
sum(blockreward_(last N block)). According to you this would force a
reorg, even on mainchain (pre-sidechain) Bitcoin. Yet this has never
happened.

It seems that this argument fully reduces to the "what will happen when
the block subsidy falls to zero" question.

> 
> If (average fees) * (timeout) is less than the total reserves, then it
> is worth it for a 3rd party to just bid for his theft fork.  Miners
> don't have to be assumed to be coordinating, they just have to be
> assumed to take the highest bid.
> 
>     Again, I don't really think it is that different. One could
>     interchange "recent txns" (those which could be double-spent within
>     2-3 weeks) with "sidechain deposit tnxs".
> 
> 
> It is not "recent txns", it is recent txns that you (or your group) have
> the key for.  No coordination is required to steal the entire reserve
> from the sidechain.

See above (?) for why I still feel they are comparable, if not identical.

> 
> Recent txns and money on the sidechain have the property that they are
> riskier than money deep on the main chain.  This is the inherent point
> about sidechains, so maybe not that big a deal. 

Yes. Sidechains have newer, more interesting features, and
simultaneously more risk.


> 
> My concern is that you could have a situation where an attack is
> possible and only need to assume that the miners are indifferent.

Again, I think that we _already_ need to eliminate any assumption of
"charitable miners".

> 
> If the first attacker who tries it fails (say after creating a fork that
> is 90% of the length required, so losing a lot of money), then it would
> discourage others.   If he succeeds, then it weakens sidechains as a
> concept and that creates the incentive for miners to see that he fails.
> 
> I wonder how the incentives work out.  If a group had 25% of the money
> on the sidechain, they could try to outbid the attacker.

Yes, we may see interesting behavior where people buy up these
liabilities using the LN. In my original post, I mention that miners
themselves may purchase these liabilities (at competitive rates, even if
these arent the idealized 1:1). At this point, miners would be paying
themselves and there would be no agency problem.

> 
> In fact, since the attacker, by definition, creates an illegal fork, the
> effect is that he reduces the block rate for the side chain (possibly to
> zero, if he wins every auction).  This means that there are more
> transactions per block, if there is space, or more fees per transaction,
> if the blocks are full. 
> 
> In both cases, this pushes up the total fees per block, so he has to pay
> more per block, weakening his attack.  This is similar to where
> transaction spam on Bitcoin is self-correcting by increasing the fees
> required to keep the spam going.
> 
> Is there a description of the actual implementation you decided to go
> with, other than the code?

If you haven't seen http://www.truthcoin.info/blog/drivechain/ , that is
probably the most human-readable description.

Cheers,
Paul

From veleslav.bips at protonmail.com  Tue May 23 15:30:58 2017
From: veleslav.bips at protonmail.com (=?UTF-8?B?0JLQtdC70LXRgdC70LDQsg==?=)
Date: Tue, 23 May 2017 11:30:58 -0400
Subject: [bitcoin-dev] A BIP proposal for conveniently referring to
	confirmed transactions
Message-ID: <jdM3MNvhFZPKmb5fGRhp7jvuZnOpa9vUsaOxnKBH4EiX8Gz8yeZuJZRbqYfW_YiRM6G0vdcXTbPd_q_2jwJ0OepZLahKSmX-e2XhGdviIKM=@protonmail.com>

Hello List,

I would like to propose a BIP that specifies a way of referring to transactions that have been successfully inserted into the blockchain.

The format makes use of the excellent Bech32 encoding, and is designed to be short and useful for human use. A C reference implementation is included.

Special care has been taken so this BIP is naturally extendable to support future upgrades to Bitcoin, Bitcoin Sidechains, or even from other blockchain projects. However, only support for the Bitcoin Main Chain, and the Test Network is specified in this draft.

I hope that the participants of the bitcoin-development mailing list find this draft BIP both interesting and useful. You are welcomed to read the full text here: https://github.com/veleslavs/bips/blob/Bech32_Encoded_TxRef/bip-XXXX-Bech32_Encoded_Transaction_Postion_References.mediawiki

If assigned with a BIP number some small updates to the specification will be made in accommodation.

? ?????????? ???????????,

????????
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170523/101898b8/attachment.html>

From james.hilliard1 at gmail.com  Tue May 23 16:56:51 2017
From: james.hilliard1 at gmail.com (James Hilliard)
Date: Tue, 23 May 2017 12:56:51 -0400
Subject: [bitcoin-dev] Reduced signalling threshold activation of
 existing segwit deployment
In-Reply-To: <W5v1NIvVzD9MK1pTmq3ybIYadLtHyqJR58hu4_Rl_02DDDq6gIvT8dAvPFagolqKaws4Up9ywMhyXS1sWqJ4t_TBr7od5RRqIMuk9jz_4W4=@protonmail.com>
References: <CADvTj4pQ8eJvzm9UOgC8bYm1ERGuTX7qq+a7etRe55S=KodrHQ@mail.gmail.com>
	<W5v1NIvVzD9MK1pTmq3ybIYadLtHyqJR58hu4_Rl_02DDDq6gIvT8dAvPFagolqKaws4Up9ywMhyXS1sWqJ4t_TBr7od5RRqIMuk9jz_4W4=@protonmail.com>
Message-ID: <CADvTj4phW9ovpnUBZnOosy30FB4opU0TB11R6itpkPsOsAkx+w@mail.gmail.com>

On Tue, May 23, 2017 at 5:51 AM, Kekcoin <kekcoin at protonmail.com> wrote:
> I think there may be merit to this idea, allowing for political compromise
> without sacrificing the technological integrity of Bitcoin. There are a few
> mechanical problems I see with it, though.
>
> 1. It should change its activation logic from BIP9-style to BIP8-style with
> a flagday of August 1. This to maintain backwards compatibility with the
> current deployment of BIP148 nodes. This proposal seems to be a measure to
> prevent a chainsplit, so it must make sure to avoid triggering one.
That can be done as a separate proposal, it's not mutually exclusive
to this one for those who intend to run BIP148.
>
> 2. This should be for miners only; non-miners should not enforce this. It
> severely weakens the block-signalling activation mechanism in several ways
> (lowered threshold, short deployment timeframe, no "locked in" delay before
> activation) and by doing so opens up attack vectors for
> consensus-partitioning attacks using malicious false signalling. For
> non-miners that seek to take their fate into their own hands, enforcing
> BIP148 is enough.
I disagree that it should be only run by miners, enforcement of
segsignal mandatory signalling by economic nodes strongly discourages
any false signaling.
>
> 3. Even for miners this is more risky than usual; only 31% of hashrate is
> required to false-signal the activation to fork-off honest miners. This
> attack vector is magnified by the lack of "locked in" delay that would allow
> laggards to upgrade before activation. I suggest adding in at least a 1-week
> lock-in period (given the shorter timeframes 2 weeks may eat up too much of
> the available voting time before the brick wall of BIP148 activation on
> August 1).
Those who can should still upgrade for segsignal, the more that
upgrade ahead of activation the more secure it is. Those who don't
upgrade would want to wait for more confirmations anyways. I didn't
think a lock in period was all that good an idea here due to the
fairly short deployment timeline.
>
> Under the assumption that this is indeed compatible with the terms of the
> Silbert agreement, we can presume the involved miners are willing to trust
> eachother more than usual so such a short lock-in period should be
> acceptable.
>
> -------- Original Message --------
> Subject: [bitcoin-dev] Reduced signalling threshold activation of existing
> segwit deployment
> Local Time: May 23, 2017 1:40 AM
> UTC Time: May 22, 2017 10:40 PM
> From: bitcoin-dev at lists.linuxfoundation.org
> To: Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>
>
> I would like to propose an implementation that accomplishes the first
> part of the Barry Silbert proposal independently from the second:
>
> "Activate Segregated Witness at an 80% threshold, signaling at bit 4"
> in a way that
>
> The goal here is to minimize chain split risk and network disruption
> while maximizing backwards compatibility and still providing for rapid
> activation of segwit at the 80% threshold using bit 4.
>
> By activating segwit immediately and separately from any HF we can
> scale quickly without risking a rushed combined segwit+HF that would
> almost certainly cause widespread issues.
>
> Draft proposal:
> https://github.com/jameshilliard/bips/blob/bip-segsignal/bip-segsignal.mediawiki
>
> Proposal text:
> <pre>
> BIP: segsignal
> Layer: Consensus (soft fork)
> Title: Reduced signalling threshold activation of existing segwit deployment
> Author: James Hilliard <james.hilliard1 at gmail.com>
> Status: Draft
> Type: Standards Track
> Created: 2017-05-22
> License: BSD-3-Clause
> CC0-1.0
> </pre>
>
> ==Abstract==
>
> This document specifies a method to activate the existing BIP9 segwit
> deployment with a majority hashpower less than 95%.
>
> ==Definitions==
>
> "existing segwit deployment" refer to the BIP9 "segwit" deployment
> using bit 1, between November 15th 2016 and November 15th 2017 to
> activate BIP141, BIP143 and BIP147.
>
> ==Motivation==
>
> Segwit increases the blocksize, fixes transaction malleability, and
> makes scripting easier to upgrade as well as bringing many other
> [https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].
>
> This BIP provides a way for a simple majority of miners to coordinate
> activation of the existing segwit deployment with less than 95%
> hashpower. For a number of reasons a complete redeployment of segwit
> is difficulty to do until the existing deployment expires. This is due
> to 0.13.1+ having many segwit related features active already,
> including all the P2P components, the new network service flag, the
> witness-tx and block messages, compact blocks v2 and preferential
> peering. A redeployment of segwit will need to redefine all these
> things and doing so before expiry would greatly complicate testing.
>
> ==Specification==
>
> While this BIP is active, all blocks must set the nVersion header top
> 3 bits to 001 together with bit field (1<<1) (according to the
> existing segwit deployment). Blocks that do not signal as required
> will be rejected.
>
> ==Deployment==
>
> This BIP will be deployed by a "version bits" with an 80%(this can be
> adjusted if desired) activation threshold BIP9 with the name
> "segsignal" and using bit 4.
>
> This BIP will have a start time of midnight June 1st, 2017 (epoch time
> 1496275200) and timeout on midnight November 15th 2017 (epoch time
> 1510704000). This BIP will cease to be active when segwit is
> locked-in.
>
> === Reference implementation ===
>
> <pre>
> // Check if Segregated Witness is Locked In
> bool IsWitnessLockedIn(const CBlockIndex* pindexPrev, const
> Consensus::Params& params)
> {
> LOCK(cs_main);
> return (VersionBitsState(pindexPrev, params,
> Consensus::DEPLOYMENT_SEGWIT, versionbitscache) ==
> THRESHOLD_LOCKED_IN);
> }
>
> // SEGSIGNAL mandatory segwit signalling.
> if ( VersionBitsState(pindex->pprev, chainparams.GetConsensus(),
> Consensus::DEPLOYMENT_SEGSIGNAL, versionbitscache) == THRESHOLD_ACTIVE
> &&
> !IsWitnessLockedIn(pindex->pprev, chainparams.GetConsensus()) &&
> // Segwit is not locked in
> !IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) ) //
> and is not active.
> {
> bool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) ==
> VERSIONBITS_TOP_BITS;
> bool fSegbit = (pindex->nVersion &
> VersionBitsMask(chainparams.GetConsensus(),
> Consensus::DEPLOYMENT_SEGWIT)) != 0;
> if (!(fVersionBits && fSegbit)) {
> return state.DoS(0, error("ConnectBlock(): relayed block must
> signal for segwit, please upgrade"), REJECT_INVALID, "bad-no-segwit");
> }
> }
> </pre>
>
> https://github.com/bitcoin/bitcoin/compare/0.14...jameshilliard:segsignal-v0.14.1
>
> ==Backwards Compatibility==
>
> This deployment is compatible with the existing "segwit" bit 1
> deployment scheduled between midnight November 15th, 2016 and midnight
> November 15th, 2017. Miners will need to upgrade their nodes to
> support segsignal otherwise they may build on top of an invalid block.
> While this bip is active users should either upgrade to segsignal or
> wait for additional confirmations when accepting payments.
>
> ==Rationale==
>
> Historically we have used IsSuperMajority() to activate soft forks
> such as BIP66 which has a mandatory signalling requirement for miners
> once activated, this ensures that miners are aware of new rules being
> enforced. This technique can be leveraged to lower the signalling
> threshold of a soft fork while it is in the process of being deployed
> in a backwards compatible way.
>
> By orphaning non-signalling blocks during the BIP9 bit 1 "segwit"
> deployment, this BIP can cause the existing "segwit" deployment to
> activate without needing to release a new deployment.
>
> ==References==
>
> *[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013714.html
> Mailing list discussion]
> *[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.cpp#L1281-L1283
> P2SH flag day activation]
> *[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]
> *[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]
> *[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]
> *[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for
> Version 0 Witness Program]]
> *[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element malleability]]
> *[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit deployment]]
> *[[bip-0149.mediawiki|BIP149 Segregated Witness (second deployment)]]
> *[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit benefits]
>
> ==Copyright==
>
> This document is dual licensed as BSD 3-clause, and Creative Commons
> CC0 1.0 Universal.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>

From greg at xiph.org  Tue May 23 17:50:12 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Tue, 23 May 2017 17:50:12 +0000
Subject: [bitcoin-dev] BIP149 timeout-- why so far in the future?
Message-ID: <CAAS2fgQNPvEuta0KubeDetgYxGhWvdGK10jig0y4ayv0EvZPLw@mail.gmail.com>

Based on how fast we saw segwit adoption, why is the BIP149 timeout so
far in the future?

It seems to me that it could be six months after release and hit the
kind of density required to make a stable transition.

(If it were a different proposal and not segwit where we already have
seen what network penetration looks like-- that would be another
matter.)

From luke at dashjr.org  Tue May 23 20:23:40 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Tue, 23 May 2017 20:23:40 +0000
Subject: [bitcoin-dev] Hypothetical 2 MB hardfork to follow BIP148
Message-ID: <201705232023.40588.luke@dashjr.org>

In light of some recent discussions, I wrote up this BIP for a real 2 MB block 
size hardfork following Segwit BIP148 activation. This is not part of any 
agreement I am party to, nor anything of that sort. Just something to throw 
out there as a possible (and realistic) option.

Note that I cannot recommend this to be adopted, since frankly 1 MB blocks 
really are still too large, and this blunt-style hardfork quite risky even 
with consensus. But if the community wishes to adopt (by unanimous consensus) 
a 2 MB block size hardfork, this is probably the best way to do it right now. 
The only possible way to improve on this IMO would be to integrate it into 
MMHF/"spoonnet" style hardfork (and/or add other unrelated-to-block-size HF 
improvements).

I have left Author blank, as I do not intend to personally champion this. 
Before it may be assigned a BIP number, someone else will need to step up to 
take on that role. Motivation and Rationale are blank because I do not 
personally think there is any legitimate rationale for such a hardfork at this 
time; if someone adopts this BIP, they should complete these sections. (I can 
push a git branch with the BIP text if someone wants to fork it.)

<pre>
BIP: ?
Layer: Consensus (hard fork)
Title: Post-segwit 2 MB block size hardfork
Author: FIXME
Comments-Summary: No comments yet.
Comments-URI: ?
Status: Draft
Type: Standards Track
Created: 2017-05-22
License: BSD-2-Clause
</pre>

==Abstract==

Legacy Bitcoin transactions are given the witness discount, and a block size 
limit of 2 MB is imposed.

==Copyright==

This BIP is licensed under the BSD 2-clause license.

==Specification==

Upon activation, a block size limit of 2000000 bytes is enforced.
The block weight limit remains at 4000000 WU.

The calculation of block weight is modified:
all witness data, including both scriptSig (used by pre-segwit inputs) and 
segwit witness data, is measured as 1 weight-unit (WU), while all other data 
in the block is measured as 4 WU.

The witness commitment in the generation transaction is no longer required, 
and instead the txid merkle root in the block header is replaced with a hash 
of:

1. The witness reserved value.
2. The witness merkle root hash.
3. The transaction ID merkle root hash.

The maximum size of a transaction stripped of witness data is limited to 1 MB.

===Deployment===

This BIP is deployed by flag day, in the block where the median-past time 
surpasses 1543503872 (2018 Nov 29 at 15:04:32 UTC).

It is assumed that when this flag day has been reached, Segwit has been 
activated via BIP141 and/or BIP148.

==Motivation==

FIXME

==Rationale==

FIXME

==Backwards compatibility==

This is a hardfork, and as such not backward compatible.
It should not be deployed without consent of the entire Bitcoin community.
Activation is scheduled for 18 months from the creation date of this BIP, 
intended to give 6 months to establish consensus, and 12 months for 
deployment.

==Reference implementation==

FIXME




From achow101-lists at achow101.com  Tue May 23 20:39:19 2017
From: achow101-lists at achow101.com (Andrew Chow)
Date: Tue, 23 May 2017 16:39:19 -0400
Subject: [bitcoin-dev] Reduced signalling threshold activation of
 existing segwit deployment
In-Reply-To: <CADvTj4pQ8eJvzm9UOgC8bYm1ERGuTX7qq+a7etRe55S=KodrHQ@mail.gmail.com>
References: <CADvTj4pQ8eJvzm9UOgC8bYm1ERGuTX7qq+a7etRe55S=KodrHQ@mail.gmail.com>
Message-ID: <c14039f3-637e-e56d-786a-2354b0f354e0@achow101.com>

Hi James,

>From what I understand, this proposal is incompatible with the current
segwit implementation with regards to the NODE_WITNESS service bit. I
believe it could cause network partitioning if the service bit is not
changed.

Andrew


On 5/22/2017 6:40 PM, James Hilliard via bitcoin-dev wrote:
> I would like to propose an implementation that accomplishes the first
> part of the Barry Silbert proposal independently from the second:
>
> "Activate Segregated Witness at an 80% threshold, signaling at bit 4"
> in a way that
>
> The goal here is to minimize chain split risk and network disruption
> while maximizing backwards compatibility and still providing for rapid
> activation of segwit at the 80% threshold using bit 4.
>
> By activating segwit immediately and separately from any HF we can
> scale quickly without risking a rushed combined segwit+HF that would
> almost certainly cause widespread issues.
>
> Draft proposal:
> https://github.com/jameshilliard/bips/blob/bip-segsignal/bip-segsignal.mediawiki
>
> Proposal text:
> <pre>
>   BIP: segsignal
>   Layer: Consensus (soft fork)
>   Title: Reduced signalling threshold activation of existing segwit deployment
>   Author: James Hilliard <james.hilliard1 at gmail.com>
>   Status: Draft
>   Type: Standards Track
>   Created: 2017-05-22
>   License: BSD-3-Clause
>            CC0-1.0
> </pre>
>
> ==Abstract==
>
> This document specifies a method to activate the existing BIP9 segwit
> deployment with a majority hashpower less than 95%.
>
> ==Definitions==
>
> "existing segwit deployment" refer to the BIP9 "segwit" deployment
> using bit 1, between November 15th 2016 and November 15th 2017 to
> activate BIP141, BIP143 and BIP147.
>
> ==Motivation==
>
> Segwit increases the blocksize, fixes transaction malleability, and
> makes scripting easier to upgrade as well as bringing many other
> [https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].
>
> This BIP provides a way for a simple majority of miners to coordinate
> activation of the existing segwit deployment with less than 95%
> hashpower. For a number of reasons a complete redeployment of segwit
> is difficulty to do until the existing deployment expires. This is due
> to 0.13.1+ having many segwit related features active already,
> including all the P2P components, the new network service flag, the
> witness-tx and block messages, compact blocks v2 and preferential
> peering. A redeployment of segwit will need to redefine all these
> things and doing so before expiry would greatly complicate testing.
>
> ==Specification==
>
> While this BIP is active, all blocks must set the nVersion header top
> 3 bits to 001 together with bit field (1<<1) (according to the
> existing segwit deployment). Blocks that do not signal as required
> will be rejected.
>
> ==Deployment==
>
> This BIP will be deployed by a "version bits" with an 80%(this can be
> adjusted if desired) activation threshold BIP9 with the name
> "segsignal" and using bit 4.
>
> This BIP will have a start time of midnight June 1st, 2017 (epoch time
> 1496275200) and timeout on midnight November 15th 2017 (epoch time
> 1510704000). This BIP will cease to be active when segwit is
> locked-in.
>
> === Reference implementation ===
>
> <pre>
> // Check if Segregated Witness is Locked In
> bool IsWitnessLockedIn(const CBlockIndex* pindexPrev, const
> Consensus::Params& params)
> {
>     LOCK(cs_main);
>     return (VersionBitsState(pindexPrev, params,
> Consensus::DEPLOYMENT_SEGWIT, versionbitscache) ==
> THRESHOLD_LOCKED_IN);
> }
>
> // SEGSIGNAL mandatory segwit signalling.
> if ( VersionBitsState(pindex->pprev, chainparams.GetConsensus(),
> Consensus::DEPLOYMENT_SEGSIGNAL, versionbitscache) == THRESHOLD_ACTIVE
> &&
>      !IsWitnessLockedIn(pindex->pprev, chainparams.GetConsensus()) &&
> // Segwit is not locked in
>      !IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) ) //
> and is not active.
> {
>     bool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) ==
> VERSIONBITS_TOP_BITS;
>     bool fSegbit = (pindex->nVersion &
> VersionBitsMask(chainparams.GetConsensus(),
> Consensus::DEPLOYMENT_SEGWIT)) != 0;
>     if (!(fVersionBits && fSegbit)) {
>         return state.DoS(0, error("ConnectBlock(): relayed block must
> signal for segwit, please upgrade"), REJECT_INVALID, "bad-no-segwit");
>     }
> }
> </pre>
>
> https://github.com/bitcoin/bitcoin/compare/0.14...jameshilliard:segsignal-v0.14.1
>
> ==Backwards Compatibility==
>
> This deployment is compatible with the existing "segwit" bit 1
> deployment scheduled between midnight November 15th, 2016 and midnight
> November 15th, 2017. Miners will need to upgrade their nodes to
> support segsignal otherwise they may build on top of an invalid block.
> While this bip is active users should either upgrade to segsignal or
> wait for additional confirmations when accepting payments.
>
> ==Rationale==
>
> Historically we have used IsSuperMajority() to activate soft forks
> such as BIP66 which has a mandatory signalling requirement for miners
> once activated, this ensures that miners are aware of new rules being
> enforced. This technique can be leveraged to lower the signalling
> threshold of a soft fork while it is in the process of being deployed
> in a backwards compatible way.
>
> By orphaning non-signalling blocks during the BIP9 bit 1 "segwit"
> deployment, this BIP can cause the existing "segwit" deployment to
> activate without needing to release a new deployment.
>
> ==References==
>
> *[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013714.html
> Mailing list discussion]
> *[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.cpp#L1281-L1283
> P2SH flag day activation]
> *[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]
> *[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]
> *[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]
> *[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for
> Version 0 Witness Program]]
> *[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element malleability]]
> *[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit deployment]]
> *[[bip-0149.mediawiki|BIP149 Segregated Witness (second deployment)]]
> *[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit benefits]
>
> ==Copyright==
>
> This document is dual licensed as BSD 3-clause, and Creative Commons
> CC0 1.0 Universal.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From james.hilliard1 at gmail.com  Tue May 23 20:42:46 2017
From: james.hilliard1 at gmail.com (James Hilliard)
Date: Tue, 23 May 2017 16:42:46 -0400
Subject: [bitcoin-dev] Reduced signalling threshold activation of
 existing segwit deployment
In-Reply-To: <c14039f3-637e-e56d-786a-2354b0f354e0@achow101.com>
References: <CADvTj4pQ8eJvzm9UOgC8bYm1ERGuTX7qq+a7etRe55S=KodrHQ@mail.gmail.com>
	<c14039f3-637e-e56d-786a-2354b0f354e0@achow101.com>
Message-ID: <CADvTj4oQsHe3jR2Bm9n0H64ouJbAy0NiXbcmFPxD_C7PSy6L0g@mail.gmail.com>

That is incorrect, it is compatible with the current segwit
implementation because it triggers a mandatory signalling period that
will activate segwit on existing nodes.

On Tue, May 23, 2017 at 4:39 PM, Andrew Chow via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Hi James,
>
> From what I understand, this proposal is incompatible with the current
> segwit implementation with regards to the NODE_WITNESS service bit. I
> believe it could cause network partitioning if the service bit is not
> changed.
>
> Andrew
>
>
> On 5/22/2017 6:40 PM, James Hilliard via bitcoin-dev wrote:
>> I would like to propose an implementation that accomplishes the first
>> part of the Barry Silbert proposal independently from the second:
>>
>> "Activate Segregated Witness at an 80% threshold, signaling at bit 4"
>> in a way that
>>
>> The goal here is to minimize chain split risk and network disruption
>> while maximizing backwards compatibility and still providing for rapid
>> activation of segwit at the 80% threshold using bit 4.
>>
>> By activating segwit immediately and separately from any HF we can
>> scale quickly without risking a rushed combined segwit+HF that would
>> almost certainly cause widespread issues.
>>
>> Draft proposal:
>> https://github.com/jameshilliard/bips/blob/bip-segsignal/bip-segsignal.mediawiki
>>
>> Proposal text:
>> <pre>
>>   BIP: segsignal
>>   Layer: Consensus (soft fork)
>>   Title: Reduced signalling threshold activation of existing segwit deployment
>>   Author: James Hilliard <james.hilliard1 at gmail.com>
>>   Status: Draft
>>   Type: Standards Track
>>   Created: 2017-05-22
>>   License: BSD-3-Clause
>>            CC0-1.0
>> </pre>
>>
>> ==Abstract==
>>
>> This document specifies a method to activate the existing BIP9 segwit
>> deployment with a majority hashpower less than 95%.
>>
>> ==Definitions==
>>
>> "existing segwit deployment" refer to the BIP9 "segwit" deployment
>> using bit 1, between November 15th 2016 and November 15th 2017 to
>> activate BIP141, BIP143 and BIP147.
>>
>> ==Motivation==
>>
>> Segwit increases the blocksize, fixes transaction malleability, and
>> makes scripting easier to upgrade as well as bringing many other
>> [https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].
>>
>> This BIP provides a way for a simple majority of miners to coordinate
>> activation of the existing segwit deployment with less than 95%
>> hashpower. For a number of reasons a complete redeployment of segwit
>> is difficulty to do until the existing deployment expires. This is due
>> to 0.13.1+ having many segwit related features active already,
>> including all the P2P components, the new network service flag, the
>> witness-tx and block messages, compact blocks v2 and preferential
>> peering. A redeployment of segwit will need to redefine all these
>> things and doing so before expiry would greatly complicate testing.
>>
>> ==Specification==
>>
>> While this BIP is active, all blocks must set the nVersion header top
>> 3 bits to 001 together with bit field (1<<1) (according to the
>> existing segwit deployment). Blocks that do not signal as required
>> will be rejected.
>>
>> ==Deployment==
>>
>> This BIP will be deployed by a "version bits" with an 80%(this can be
>> adjusted if desired) activation threshold BIP9 with the name
>> "segsignal" and using bit 4.
>>
>> This BIP will have a start time of midnight June 1st, 2017 (epoch time
>> 1496275200) and timeout on midnight November 15th 2017 (epoch time
>> 1510704000). This BIP will cease to be active when segwit is
>> locked-in.
>>
>> === Reference implementation ===
>>
>> <pre>
>> // Check if Segregated Witness is Locked In
>> bool IsWitnessLockedIn(const CBlockIndex* pindexPrev, const
>> Consensus::Params& params)
>> {
>>     LOCK(cs_main);
>>     return (VersionBitsState(pindexPrev, params,
>> Consensus::DEPLOYMENT_SEGWIT, versionbitscache) ==
>> THRESHOLD_LOCKED_IN);
>> }
>>
>> // SEGSIGNAL mandatory segwit signalling.
>> if ( VersionBitsState(pindex->pprev, chainparams.GetConsensus(),
>> Consensus::DEPLOYMENT_SEGSIGNAL, versionbitscache) == THRESHOLD_ACTIVE
>> &&
>>      !IsWitnessLockedIn(pindex->pprev, chainparams.GetConsensus()) &&
>> // Segwit is not locked in
>>      !IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) ) //
>> and is not active.
>> {
>>     bool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) ==
>> VERSIONBITS_TOP_BITS;
>>     bool fSegbit = (pindex->nVersion &
>> VersionBitsMask(chainparams.GetConsensus(),
>> Consensus::DEPLOYMENT_SEGWIT)) != 0;
>>     if (!(fVersionBits && fSegbit)) {
>>         return state.DoS(0, error("ConnectBlock(): relayed block must
>> signal for segwit, please upgrade"), REJECT_INVALID, "bad-no-segwit");
>>     }
>> }
>> </pre>
>>
>> https://github.com/bitcoin/bitcoin/compare/0.14...jameshilliard:segsignal-v0.14.1
>>
>> ==Backwards Compatibility==
>>
>> This deployment is compatible with the existing "segwit" bit 1
>> deployment scheduled between midnight November 15th, 2016 and midnight
>> November 15th, 2017. Miners will need to upgrade their nodes to
>> support segsignal otherwise they may build on top of an invalid block.
>> While this bip is active users should either upgrade to segsignal or
>> wait for additional confirmations when accepting payments.
>>
>> ==Rationale==
>>
>> Historically we have used IsSuperMajority() to activate soft forks
>> such as BIP66 which has a mandatory signalling requirement for miners
>> once activated, this ensures that miners are aware of new rules being
>> enforced. This technique can be leveraged to lower the signalling
>> threshold of a soft fork while it is in the process of being deployed
>> in a backwards compatible way.
>>
>> By orphaning non-signalling blocks during the BIP9 bit 1 "segwit"
>> deployment, this BIP can cause the existing "segwit" deployment to
>> activate without needing to release a new deployment.
>>
>> ==References==
>>
>> *[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013714.html
>> Mailing list discussion]
>> *[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.cpp#L1281-L1283
>> P2SH flag day activation]
>> *[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]
>> *[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]
>> *[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]
>> *[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for
>> Version 0 Witness Program]]
>> *[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element malleability]]
>> *[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit deployment]]
>> *[[bip-0149.mediawiki|BIP149 Segregated Witness (second deployment)]]
>> *[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit benefits]
>>
>> ==Copyright==
>>
>> This document is dual licensed as BSD 3-clause, and Creative Commons
>> CC0 1.0 Universal.
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From pieter.wuille at gmail.com  Tue May 23 20:43:45 2017
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Tue, 23 May 2017 13:43:45 -0700
Subject: [bitcoin-dev] Rolling UTXO set hashes
In-Reply-To: <8760gs2n7v.fsf@rustcorp.com.au>
References: <CAPg+sBgruEiXya6oFy6VpmR1KPDebjeGDtZZU+facZx5=L_a5w@mail.gmail.com>
	<CT3GNfkLsQJyM0EmWXc3HBmnW1h2iptP0SohZnXZfZPffoVmcofD8fs_E3kV5PuFL0pQSQwwk_FyR-8-wdANf15NE8UElNWqcEcc5Ql3n8M=@protonmail.com>
	<CAAS2fgTif+Y6VzFG+w7W+CY1+D_roCqGyy392qB2KcDPGpVeiw@mail.gmail.com>
	<20170516110104.GA5564@fedora-23-dvm>
	<CAPg+sBjJLbhj71Epv=Qfc8HgJhSreN6BOmLkDkvcEGvPwxDNbg@mail.gmail.com>
	<CAAS2fgQKOKY6DEwY3ycMjysU5Xf2UUE+k=vg2ekkAMO7KG3Gsw@mail.gmail.com>
	<8760gs2n7v.fsf@rustcorp.com.au>
Message-ID: <CAPg+sBgW7paof_rLunoDYJL_WXn7mYuHanuka8a_x0oE2LjwSQ@mail.gmail.com>

On Mon, May 22, 2017 at 9:47 PM, Rusty Russell <rusty at rustcorp.com.au> wrote:
> Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:
>> On Tue, May 16, 2017 at 6:17 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:
>>> just the first - and one that has very low costs and no normative
>>> datastructures at all.
>>
>> The serialization of the txout itself is normative, but very minimal.
>
> I do prefer the (2) approach, BTW, as it reuses existing primitives, but
> I know "simpler" means a different thing to mathier brains :)

Oh, I didn't mean it that way at all. (1) is simpler to get decent
performance out of. Implementing (1) using any language that has big
integer support or can link against GMP is likely going to be faster
than the fastest possible implementation of (2).

> Since it wasn't explicit in the proposal, I think the txout information
> placed in the hash here is worth discussing.
>
> I prefer a simple txid||outnumber[1], because it allows simple validation
> without knowing the UTXO set itself; even a lightweight node can assert
> that UTXOhash for block N+1 is valid if the UTXOhash for block N is
> valid (and vice versa!) given block N+1.  And miners can't really use
> that even if they were to try not validating against UTXO (!) because
> they need to know input amounts for fees (which are becoming
> significant).
>
> If I want to hand you the complete validatable UTXO set, I need to hand
> you all the txs with any unspent output, and some bitfield to indicate
> which ones are unspent.

That seems to completely defeat the purpose... if I want to give you a
UTXO set, and prove its correctness wrt the hash you know... I need to
remember the full transactions those outputs came from?

> OTOH, if you serialize more (eg. ...||amount||scriptPubKey ?), then the UTXO
> set size needed to validate the utxohash is a little smaller: you need
> to send the txid, but not the tx nVersion, nLocktime or inputs.  But in a
> SegWit world, that's actually *bigger* AFAICT.

That's an interesting idea, but I believe you're forgetting:
* The size of txin prevout/nsequence, which is typically larger than
txouts (even when excluding scriptSig/witness data).
* The size of spent txouts for transactions with unspent outputs left.
* The fact that you can deduplicate the txids for txn that have
multiple unspent outputs in the UTXO set serialization, even if that
txid is repeated in the rolling hash computation.

The construction I was considering and benchmarking is using 256-bit
truncated SHA512(256bit txid || 32bit voutindex || 1bit coinbase ||
31bit height || CTxOut output) as secp256k1 X coordinate, or as key to
seed a ChaCha20 PRNG whose outputs is the 3072-bit MuHash number. The
reason for using SHA512 is that it can process most UTXOs in a single
transformation (as opposed to SHA256 which will almost always need 2).
The reason for using ChaCha20 is that it's incredibly fast for
producing much data when a key is already known. An alternative is
using SHAKE256 for the whole construction (as it both takes an
arbitrary amount of data, and produces an arbitrary length hash) - but
it's a bit slower.

> Thanks,
> Rusty.
>
> [1] I think you could actually use txid^outnumber, and if that's not a
>     curve point SHA256() again, etc.  But I don't think that saves any
>     real time, and may cause other issues.

That just seems scary to me...

-- 
Pieter

From achow101-lists at achow101.com  Tue May 23 20:58:14 2017
From: achow101-lists at achow101.com (Andrew Chow)
Date: Tue, 23 May 2017 16:58:14 -0400
Subject: [bitcoin-dev] Reduced signalling threshold activation of
 existing segwit deployment
In-Reply-To: <CADvTj4oQsHe3jR2Bm9n0H64ouJbAy0NiXbcmFPxD_C7PSy6L0g@mail.gmail.com>
References: <CADvTj4pQ8eJvzm9UOgC8bYm1ERGuTX7qq+a7etRe55S=KodrHQ@mail.gmail.com>
	<c14039f3-637e-e56d-786a-2354b0f354e0@achow101.com>
	<CADvTj4oQsHe3jR2Bm9n0H64ouJbAy0NiXbcmFPxD_C7PSy6L0g@mail.gmail.com>
Message-ID: <cc20efe1-c5d4-0b79-48d9-65466834dbcf@achow101.com>

Ah. I see now. It wasn't very clear to me that that is what will happen.

Also, shouldn't the timeout date be set for before the BIP141 timeout?
Otherwise this could lock in but not have enough time for Segwit to be
locked in.


On 5/23/2017 4:42 PM, James Hilliard wrote:
> That is incorrect, it is compatible with the current segwit
> implementation because it triggers a mandatory signalling period that
> will activate segwit on existing nodes.
>
> On Tue, May 23, 2017 at 4:39 PM, Andrew Chow via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> Hi James,
>>
>> From what I understand, this proposal is incompatible with the current
>> segwit implementation with regards to the NODE_WITNESS service bit. I
>> believe it could cause network partitioning if the service bit is not
>> changed.
>>
>> Andrew
>>
>>
>> On 5/22/2017 6:40 PM, James Hilliard via bitcoin-dev wrote:
>>> I would like to propose an implementation that accomplishes the first
>>> part of the Barry Silbert proposal independently from the second:
>>>
>>> "Activate Segregated Witness at an 80% threshold, signaling at bit 4"
>>> in a way that
>>>
>>> The goal here is to minimize chain split risk and network disruption
>>> while maximizing backwards compatibility and still providing for rapid
>>> activation of segwit at the 80% threshold using bit 4.
>>>
>>> By activating segwit immediately and separately from any HF we can
>>> scale quickly without risking a rushed combined segwit+HF that would
>>> almost certainly cause widespread issues.
>>>
>>> Draft proposal:
>>> https://github.com/jameshilliard/bips/blob/bip-segsignal/bip-segsignal.mediawiki
>>>
>>> Proposal text:
>>> <pre>
>>>   BIP: segsignal
>>>   Layer: Consensus (soft fork)
>>>   Title: Reduced signalling threshold activation of existing segwit deployment
>>>   Author: James Hilliard <james.hilliard1 at gmail.com>
>>>   Status: Draft
>>>   Type: Standards Track
>>>   Created: 2017-05-22
>>>   License: BSD-3-Clause
>>>            CC0-1.0
>>> </pre>
>>>
>>> ==Abstract==
>>>
>>> This document specifies a method to activate the existing BIP9 segwit
>>> deployment with a majority hashpower less than 95%.
>>>
>>> ==Definitions==
>>>
>>> "existing segwit deployment" refer to the BIP9 "segwit" deployment
>>> using bit 1, between November 15th 2016 and November 15th 2017 to
>>> activate BIP141, BIP143 and BIP147.
>>>
>>> ==Motivation==
>>>
>>> Segwit increases the blocksize, fixes transaction malleability, and
>>> makes scripting easier to upgrade as well as bringing many other
>>> [https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].
>>>
>>> This BIP provides a way for a simple majority of miners to coordinate
>>> activation of the existing segwit deployment with less than 95%
>>> hashpower. For a number of reasons a complete redeployment of segwit
>>> is difficulty to do until the existing deployment expires. This is due
>>> to 0.13.1+ having many segwit related features active already,
>>> including all the P2P components, the new network service flag, the
>>> witness-tx and block messages, compact blocks v2 and preferential
>>> peering. A redeployment of segwit will need to redefine all these
>>> things and doing so before expiry would greatly complicate testing.
>>>
>>> ==Specification==
>>>
>>> While this BIP is active, all blocks must set the nVersion header top
>>> 3 bits to 001 together with bit field (1<<1) (according to the
>>> existing segwit deployment). Blocks that do not signal as required
>>> will be rejected.
>>>
>>> ==Deployment==
>>>
>>> This BIP will be deployed by a "version bits" with an 80%(this can be
>>> adjusted if desired) activation threshold BIP9 with the name
>>> "segsignal" and using bit 4.
>>>
>>> This BIP will have a start time of midnight June 1st, 2017 (epoch time
>>> 1496275200) and timeout on midnight November 15th 2017 (epoch time
>>> 1510704000). This BIP will cease to be active when segwit is
>>> locked-in.
>>>
>>> === Reference implementation ===
>>>
>>> <pre>
>>> // Check if Segregated Witness is Locked In
>>> bool IsWitnessLockedIn(const CBlockIndex* pindexPrev, const
>>> Consensus::Params& params)
>>> {
>>>     LOCK(cs_main);
>>>     return (VersionBitsState(pindexPrev, params,
>>> Consensus::DEPLOYMENT_SEGWIT, versionbitscache) ==
>>> THRESHOLD_LOCKED_IN);
>>> }
>>>
>>> // SEGSIGNAL mandatory segwit signalling.
>>> if ( VersionBitsState(pindex->pprev, chainparams.GetConsensus(),
>>> Consensus::DEPLOYMENT_SEGSIGNAL, versionbitscache) == THRESHOLD_ACTIVE
>>> &&
>>>      !IsWitnessLockedIn(pindex->pprev, chainparams.GetConsensus()) &&
>>> // Segwit is not locked in
>>>      !IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) ) //
>>> and is not active.
>>> {
>>>     bool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) ==
>>> VERSIONBITS_TOP_BITS;
>>>     bool fSegbit = (pindex->nVersion &
>>> VersionBitsMask(chainparams.GetConsensus(),
>>> Consensus::DEPLOYMENT_SEGWIT)) != 0;
>>>     if (!(fVersionBits && fSegbit)) {
>>>         return state.DoS(0, error("ConnectBlock(): relayed block must
>>> signal for segwit, please upgrade"), REJECT_INVALID, "bad-no-segwit");
>>>     }
>>> }
>>> </pre>
>>>
>>> https://github.com/bitcoin/bitcoin/compare/0.14...jameshilliard:segsignal-v0.14.1
>>>
>>> ==Backwards Compatibility==
>>>
>>> This deployment is compatible with the existing "segwit" bit 1
>>> deployment scheduled between midnight November 15th, 2016 and midnight
>>> November 15th, 2017. Miners will need to upgrade their nodes to
>>> support segsignal otherwise they may build on top of an invalid block.
>>> While this bip is active users should either upgrade to segsignal or
>>> wait for additional confirmations when accepting payments.
>>>
>>> ==Rationale==
>>>
>>> Historically we have used IsSuperMajority() to activate soft forks
>>> such as BIP66 which has a mandatory signalling requirement for miners
>>> once activated, this ensures that miners are aware of new rules being
>>> enforced. This technique can be leveraged to lower the signalling
>>> threshold of a soft fork while it is in the process of being deployed
>>> in a backwards compatible way.
>>>
>>> By orphaning non-signalling blocks during the BIP9 bit 1 "segwit"
>>> deployment, this BIP can cause the existing "segwit" deployment to
>>> activate without needing to release a new deployment.
>>>
>>> ==References==
>>>
>>> *[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013714.html
>>> Mailing list discussion]
>>> *[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.cpp#L1281-L1283
>>> P2SH flag day activation]
>>> *[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]
>>> *[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]
>>> *[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]
>>> *[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for
>>> Version 0 Witness Program]]
>>> *[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element malleability]]
>>> *[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit deployment]]
>>> *[[bip-0149.mediawiki|BIP149 Segregated Witness (second deployment)]]
>>> *[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit benefits]
>>>
>>> ==Copyright==
>>>
>>> This document is dual licensed as BSD 3-clause, and Creative Commons
>>> CC0 1.0 Universal.
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From ZmnSCPxj at protonmail.com  Tue May 23 23:26:52 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 23 May 2017 19:26:52 -0400
Subject: [bitcoin-dev] Drivechain -- Request for Discussion
In-Reply-To: <56d88784-9eb1-8883-0418-68aa98b74a6e@gmail.com>
References: <24f2b447-a237-45eb-ef9f-1a62533fad5c@gmail.com>
	<dhstGQudLBiwjDlaRrmMfy-ixwvXcwMr1CzCkPKh285RLICGZixkbdwpTDc2Sgz8eYIqSem8lwxW6QeJCD7aFfwQjLDnZ2NmOw0Zzd-KgSs=@protonmail.com>
	<CA+XQW1jZpJ9wnEg47fouyywL09=_vU8dMP3owkkuNqRvzTZUDg@mail.gmail.com>
	<FSrvrfLYPlLQULODf79GXk7yzJHCRD8FOiLzLGZFS5BYuGn_WL8hRsqQD1BEQjT54RATE7hqlqjYthzJgNfZOdgy4hJMBB5osv3dspyIwX0=@protonmail.com>
	<56d88784-9eb1-8883-0418-68aa98b74a6e@gmail.com>
Message-ID: <9ibRWf1SPT97wLBhIYNzyc74UsferW9O8DYaob5ryM3YcxOhk_dyN2XAudbCKZ35HPf6XjuKaPzmDdOBwnCXwz4h-LykpphfoQ0RoA-OYzs=@protonmail.com>

Good morning,

>> (What happens if the h* to be put in the coinbase, by chance - even very
>> unlikely chance - is 0? Then <h*> OP_NOP4 is not the same as <h*>
>> OP_BRIBE scripts in result - the former will be rejected by old nodes,
>> the latter will be accepted by new nodes)
>
>That would indeed be a bug, if it happened as you described. I will
>check when I get the chance, thanks.

Indeed, this is the reason why CLTV and CSV do not pop off their parameters when executed, and require a subsequent OP_DROP. I suggest, that OP_BRIBE should not manipulate stack (pop, then push 0/1); my understanding is that this requirement is necessary for compatibility with old nodes, which will not manipulate stack on OP_NOP4. Instead, OP_BRIBE should imitate CLTV and CSV code, and raise an error in script execution if the check fails.

>>
>> How is OP_BRIBE superior to just using a <h*> OP_RETURN script? Cannot
>> a sidechain scan the block for OP_RETURN attesting that the block hash
>> is present in the block?
>
>The sidechain software can indeed, but the mainchain software cannot
>(without making validation of both chains part of the mainchain, which
>defeats the original purpose of sidechains).
>
>The purpose of OP_BRIBE is to allow "Sam" (on the sidechain) and "Mary"
>(a mainchain miner) to work together. Sam would pay X BTC to Mary, if
>Mary could provide Sam with some guarantee that Sam's sidechain block
>[defined by h*] would make it into the largest chain.

Regarding "largest chain", do you mean mainchain or sidechain?

An OP_RETURN is still some guarantee that it will make it into the longest mainchain. If OP_RETURN tx is in a shorter mainchain but not on the longer mainchain, then on the longer mainchain, the utxo's funding the OP_RETURN tx is still unspent and the OP_RETURN tx will still be mineable by any miner following the longer mainchain. The X BTC would be the OP_RETURN transaction's fee, which Mary would still want to mine into the longest mainchain, as it is still money on the table if it is not mined on the longest mainchain.

Or, does OP_BRIBE somehow assure that Sam's block goes onto the longer sidechain? But then, do not side blocks refer to their previous side block to define the sidechain?

>1. main:A sends 100 to side:A, then transfers 100 to side:B in exchange
>for B's good or service (provided on the sidechain)
>2. side:B attempts to move side-to-main with the 100 BTC, using the
>lightning network. He swaps 100 side:BTC for 100 of C's main:BTC.
>3. C attempts to move side-to-main, using the slow, settlement method.
>4. C's side-to-main sidechain tx (wt) is bundled with others and becomes
>a withdrawal attempt (WT^)
>5. The WT^ attempt is initiated on the mainchain.
>6. After a waiting period, the WT^ begins to accumulate ACKs or NACKs
>(upvotes / downvotes), on the mainchain.
>7. The transaction either succeeds or fails.
>
>I'm not sure, but your question seems to concern B, who exploits a reorg
>that happens just after step 2. After the reorg, the sidechain chain
>history will have a different side-to-main withdrawal in part 3. The
>time between each of these step is very long, on the order of weeks
>(summing to a length of time totaling months), for exactly this reason
>(as well as to encourage people to avoid using this 'formal' method, in
>favor of the cooperative LN and Atomic Swaps).
>
>I think that this principle of scale (ie, very VERY slow withdrawals) is
>important and actually makes the security categorically different.

I see.

Is there some predictable schedule for side->main withdrawals? If a withdrawal is imminent, or if some actor can get "insider information" about whether a withdrawal is imminent, cannot some actor induce the above, with potentially shorter time to reach step 3?

From my reading, Blockstream's sidechains proposal supports a reorg proof after a side->main withdrawal on the mainchain side, with a reorg proof burn window after the main:side->main withdrawal, preventing its utxo from being used. If the reorg proof is published and shows that a sidechain reorg invalidates a particular side->main withdrawal, then the main:side->main withdrawal's utxo is burned.

>For extraordinary DAO-like situations, disinterested mainchain miners
>merely need a single bit of information (per sidechain), which is
>"distress=true", and indicates to them to temporarily stop ACKing
>withdrawals from the sidechain. This alone is enough to give the reorg
>an unlimited amount of time to work itself out.

Do you have some document containing these details? I cannot find this in the blog posts I've read so far.

>>>I feel that my proposal is more secure, as it can operate healthily and
>> quickly while using spv proofs which are much slower and much much
>> easier to audit.
>>
>> I don't quite understand how Drivechain handles sidechain reorgs, while
>> keeping Bitcoin miners blinded. It seems sidechains need to be known
>> ("seen") by the miner, so I don't see what is being blinded by blinded
>> merge mining.
>
>Mainchain miners do need to maintain some data about the sidechains, but
>this is very minimal, and certainly does not include the transaction
>data (or arbitrary messages) of the sidechain.

As above, do you have document containing what data mainchain needs to track?

>>>>Blind merged mining seems strictly inferior ... a rich attacker can
>> simply reorg the sidechain outright without playing such games.
>>>
>>>In the future, when there is no block subsidy, a rich attacker can also
>> do that in mainchain Bitcoin.
>>
>> I see. However, block subsidies will drop far in the future, do you
>> mean to say, that sidechains will be used only in the far future?
>
>In one sense, I mean "you have already endorsed this 'fees only will
>work' premise, by endorsing Bitcoin".

I endorse this on the basis of Greg Maxwell's analysis that a block size limit is necessary to have a fee market.

>That mechanism is enforced by drivechain itself, not OP_BRIBE. (OP Bribe
>is itself only ~half of BMM. I admit it is getting a little confusing.)

Can you provide the details of this mechanism? For example, does h* actually include some information identifying the sidechain and OP_BRIBE is supposed to do some additional checking not shown in your current code, or ....?

>Drivechain requires a soft fork to add each new sidechain

Oh.

My understanding is that with Blockstream's zk-SNARKs, a new sidechain would not require a soft fork at all (or even miner voting on the validity of WT^: the validity of side:side->main transactions is assured by proof that the zk-SNARK checking that transaction was executed correctly, and the lack of a reorg proof during the burn window after the main:side->main).

Is your model then, that each sidechain maintainer has to maintain a patchset or some plugin system to Core? And miners who want to support particular sidechains to modify their software, applying the patch for each sidechain they want to support?

It seems this is somewhat brittle and may cause sidechain coding problems to leak into mainchain.

I think, it is much less interesting to have to softfork in every sidechain, rather than to support a general mechanism (zk-SNARK) to allow sidechains to be launched without any modification to Core code.

>. It requires
>this literally for a few good reasons...but the best is: there is an
>implicit requirement that the miners not steal from the sidechain
>anyway. In this way drivechain knows how to keep track of what it should
>expect.

It seems to be, more of "completely sighted merged mining" than "blind merge mining".

>> Perhaps the datacenter point is simply that your proposal suggests to
>> reduce the size of the datacenter by removing surge suppressors and
>> UPS's, to avoid some definition of "datacenter is a room with >$XXX of
>> equipment".
>
>I hope that my replies above already help with these. If not, let me know.

I find this point now moot, as drivechains require a softfork for each sidechain, and the size of the datacenter is pointless if there is some need to softfork in every sidechain.

Regards,
ZmnXCPxj
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170523/f4a593fe/attachment.html>

From erik at q32.com  Tue May 23 23:07:41 2017
From: erik at q32.com (Erik Aronesty)
Date: Tue, 23 May 2017 19:07:41 -0400
Subject: [bitcoin-dev] Hypothetical 2 MB hardfork to follow BIP148
In-Reply-To: <201705232023.40588.luke@dashjr.org>
References: <201705232023.40588.luke@dashjr.org>
Message-ID: <CAJowKgJK9zBkVAM1NyOsjU04gvwV3zGnk+1ebfpt6rnbiKy6Og@mail.gmail.com>

Personally, I would prefer if a 2MB lock-in that uses BIP103 for the
timing.

I think up to 20% per year can be absorbed by averages in bandwidth/CPU/RAM
growth, of which bandwidth seems the most constraining.

- Erik


On Tue, May 23, 2017 at 4:23 PM, Luke Dashjr via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> In light of some recent discussions, I wrote up this BIP for a real 2 MB
> block
> size hardfork following Segwit BIP148 activation. This is not part of any
> agreement I am party to, nor anything of that sort. Just something to throw
> out there as a possible (and realistic) option.
>
> Note that I cannot recommend this to be adopted, since frankly 1 MB blocks
> really are still too large, and this blunt-style hardfork quite risky even
> with consensus. But if the community wishes to adopt (by unanimous
> consensus)
> a 2 MB block size hardfork, this is probably the best way to do it right
> now.
> The only possible way to improve on this IMO would be to integrate it into
> MMHF/"spoonnet" style hardfork (and/or add other unrelated-to-block-size HF
> improvements).
>
> I have left Author blank, as I do not intend to personally champion this.
> Before it may be assigned a BIP number, someone else will need to step up
> to
> take on that role. Motivation and Rationale are blank because I do not
> personally think there is any legitimate rationale for such a hardfork at
> this
> time; if someone adopts this BIP, they should complete these sections. (I
> can
> push a git branch with the BIP text if someone wants to fork it.)
>
> <pre>
> BIP: ?
> Layer: Consensus (hard fork)
> Title: Post-segwit 2 MB block size hardfork
> Author: FIXME
> Comments-Summary: No comments yet.
> Comments-URI: ?
> Status: Draft
> Type: Standards Track
> Created: 2017-05-22
> License: BSD-2-Clause
> </pre>
>
> ==Abstract==
>
> Legacy Bitcoin transactions are given the witness discount, and a block
> size
> limit of 2 MB is imposed.
>
> ==Copyright==
>
> This BIP is licensed under the BSD 2-clause license.
>
> ==Specification==
>
> Upon activation, a block size limit of 2000000 bytes is enforced.
> The block weight limit remains at 4000000 WU.
>
> The calculation of block weight is modified:
> all witness data, including both scriptSig (used by pre-segwit inputs) and
> segwit witness data, is measured as 1 weight-unit (WU), while all other
> data
> in the block is measured as 4 WU.
>
> The witness commitment in the generation transaction is no longer required,
> and instead the txid merkle root in the block header is replaced with a
> hash
> of:
>
> 1. The witness reserved value.
> 2. The witness merkle root hash.
> 3. The transaction ID merkle root hash.
>
> The maximum size of a transaction stripped of witness data is limited to 1
> MB.
>
> ===Deployment===
>
> This BIP is deployed by flag day, in the block where the median-past time
> surpasses 1543503872 (2018 Nov 29 at 15:04:32 UTC).
>
> It is assumed that when this flag day has been reached, Segwit has been
> activated via BIP141 and/or BIP148.
>
> ==Motivation==
>
> FIXME
>
> ==Rationale==
>
> FIXME
>
> ==Backwards compatibility==
>
> This is a hardfork, and as such not backward compatible.
> It should not be deployed without consent of the entire Bitcoin community.
> Activation is scheduled for 18 months from the creation date of this BIP,
> intended to give 6 months to establish consensus, and 12 months for
> deployment.
>
> ==Reference implementation==
>
> FIXME
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170523/3e593f57/attachment-0001.html>

From earonesty at gmail.com  Wed May 24 02:42:30 2017
From: earonesty at gmail.com (Erik Aronesty)
Date: Tue, 23 May 2017 22:42:30 -0400
Subject: [bitcoin-dev] Proposal to allow users to configure the maximum
 block weight based on a support threshold
In-Reply-To: <1495536637.1801543.985680712.6B788409@webmail.messagingengine.com>
References: <1495536637.1801543.985680712.6B788409@webmail.messagingengine.com>
Message-ID: <CAJowKgJs-cVR7w1QvSKr+ZXeQd4giq-aGLOEktqHn3a83tNGBA@mail.gmail.com>

Instead of block thresholds, use utxo bits to coordinate size changes
(larger and smaller should be allowed).

There is no reason for miners to be involved in a decision to change this
aspects of the protocol.   Plenty of other ways to coordinate.

Otherwise someone can make it seem to a miner like 99pct of nodes are ready
for a larger weight.... even though that's false.

On May 23, 2017 8:03 AM, "Tomas via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I have a proposal that would allow each user to optionally configure the
> maximum block weight at a support threshold.
>
> It recognizes that there is no need for off chain bickering, by
> providing a mechanism that lets each users freely choose their own
> parameters while still maintaining full coordination of any changes.
>
> The BIP can be found here:
>
> https://github.com/tomasvdw/bips/blob/master/bip-changing-
> the-maximum-block%20weight-based-on-a-support-threshold.mediawiki
>
> It is worth noting that this proposal does neither gives more power to
> miners nor reduces decentralization. Miners still rely on their blocks
> being accepted by economic nodes to sell their minted coins. This
> proposal doesn't change that.
>
> Regards,
> Tomas van der Wansem
> bitcrust
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170523/e6d5a95f/attachment.html>

From rusty at rustcorp.com.au  Wed May 24 04:26:56 2017
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Wed, 24 May 2017 13:56:56 +0930
Subject: [bitcoin-dev] BIP149 timeout-- why so far in the future?
In-Reply-To: <CAAS2fgQNPvEuta0KubeDetgYxGhWvdGK10jig0y4ayv0EvZPLw@mail.gmail.com>
References: <CAAS2fgQNPvEuta0KubeDetgYxGhWvdGK10jig0y4ayv0EvZPLw@mail.gmail.com>
Message-ID: <87r2ze2833.fsf@rustcorp.com.au>

Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
writes:
> Based on how fast we saw segwit adoption, why is the BIP149 timeout so
> far in the future?
>
> It seems to me that it could be six months after release and hit the
> kind of density required to make a stable transition.

Agreed, I would suggest 16th December, 2017 (otherwise, it should be
16th January 2018; during EOY holidays seems a bad idea).

This means this whole debacle has delayed segwit exactly 1 (2) month(s)
beyond what we'd have if it used BIP8 in the first place.

Cheers,
Rusty.

From tier.nolan at gmail.com  Wed May 24 08:50:22 2017
From: tier.nolan at gmail.com (Tier Nolan)
Date: Wed, 24 May 2017 09:50:22 +0100
Subject: [bitcoin-dev] Drivechain -- Request for Discussion
In-Reply-To: <141a0cd1-9d4f-c137-a349-17248f9cafd4@gmail.com>
References: <24f2b447-a237-45eb-ef9f-1a62533fad5c@gmail.com>
	<dhstGQudLBiwjDlaRrmMfy-ixwvXcwMr1CzCkPKh285RLICGZixkbdwpTDc2Sgz8eYIqSem8lwxW6QeJCD7aFfwQjLDnZ2NmOw0Zzd-KgSs=@protonmail.com>
	<CA+XQW1jZpJ9wnEg47fouyywL09=_vU8dMP3owkkuNqRvzTZUDg@mail.gmail.com>
	<CAE-z3OUYuAXE2+h60A=r4UyGU4CSQuF98oFgHnD7iaj-=Z=yOw@mail.gmail.com>
	<CA+XQW1hRhcxJBoOJ57YG0t5y5j1Qm3RO4wr2eXV5V-UzDaiPPw@mail.gmail.com>
	<CAE-z3OVWXN58X-+nAFTm61G1=v_1xrniyrBy8x=VRG4N149aXQ@mail.gmail.com>
	<141a0cd1-9d4f-c137-a349-17248f9cafd4@gmail.com>
Message-ID: <CAE-z3OXY2YiQ5fzxZBw4FooRsUzXricHmpv_+t+HbTf0MxP0kg@mail.gmail.com>

On Tue, May 23, 2017 at 3:22 PM, Paul Sztorc <truthcoin at gmail.com> wrote:

>
> If you haven't seen http://www.truthcoin.info/blog/drivechain/ , that is
> probably the most human-readable description.
>

I guess I was looking for the detail you get in the code, but without
having to read the code.

My quick reading gives that the sidechain codes (critical hashes) are added
when a coinbase is processed.

Any coinbase output that has the form "OP_RETURN <32 byte push>" counts as
a potential critical hash.

When the block is processed, the key value pair (hash, block_height) is
added to a hash map.

The OP_BRIBE opcode checks that the given hash is in the hash map and
replaces the top element on the stack with the pass/fail result.

It doesn't even check that the height matches the current block, though
there is a comment that that is a TODO.

I agree with ZmnSCPxj, when updating a nop, you can't change the stack.  It
has to fail the script or do nothing.

OP_BRIBE_VERIFY would cause the script to fail if the hash wasn't in the
coinbase, or cause a script failure otherwise.

Another concern is that you could have multiple bribes for the same chain
in a single coinbase.  That isn't fair and arguably what the sidechain
miner is paying for is to get his hash exclusively into the block.

I would suggest that the output is

OP_RETURN <sidechain_id> <critical hash>

Then add the rule that only the first hash with a particular sidechain id
actually counts.

This forces the miner to only accept the bribe from 1 miner for each
sidechain for each block.  If he tries to accept 2, then only the first one
counts.

OP_BRIBE_VERIFY could then operate as follows

<block height> <sidechain_id> <critical hash> OP_BRIBE_VERIFY

This causes the script to fail if
  <block height> does not match the block height, or
  <critical hash> is not the hash for the sidechain with <sidechain_id>, or
  there is no hash for that sidechain in the block's coinbase

If you want reduce the number of drops, you could serialize the info into a
single push.

This has the advantage that a sidechain miner only has to pay if his block
is accepted in the next bitcoin block.  Since he is the only miner for that
sidechain that gets into the main bitcoin block, he is pretty much
guaranteed to form the longest chain.

Without that rule, sidechain miners could end up having to pay even though
it doesn't make their chain the longest.

How are these transactions propagated over the network?  For relaying, you
could have the rule that the opcode passes as long as <block height> is
near the current block height.  Maybe require that they are in the future.
They should be removed from the memory pool once the block height has
arrived, so losing miners can re-spend those outputs.

This opcode can be validated without needing to look at other blocks, which
is good for validating historical blocks.

I am still looking at the deposit/withdrawal code.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170524/ac8f7126/attachment.html>

From tomas at tomasvdw.nl  Wed May 24 08:34:10 2017
From: tomas at tomasvdw.nl (Tomas)
Date: Wed, 24 May 2017 10:34:10 +0200
Subject: [bitcoin-dev] Proposal to allow users to configure the maximum
 block weight based on a support threshold
In-Reply-To: <CAJowKgJs-cVR7w1QvSKr+ZXeQd4giq-aGLOEktqHn3a83tNGBA@mail.gmail.com>
References: <1495536637.1801543.985680712.6B788409@webmail.messagingengine.com>
	<CAJowKgJs-cVR7w1QvSKr+ZXeQd4giq-aGLOEktqHn3a83tNGBA@mail.gmail.com>
Message-ID: <1495614850.2407540.986853224.2FB087C6@webmail.messagingengine.com>


On Wed, May 24, 2017, at 04:42, Erik Aronesty wrote:
> Instead of block thresholds, use utxo bits to coordinate size changes
> (larger and smaller should be allowed).> 
> There is no reason for miners to be involved in a decision to change
> this aspects of the protocol.   Plenty of other ways to coordinate.
Miners cannot change the block size or any other rule without support of
the users, because their blocks and coins would be rejected. This
mechanism that Bitcoin brought us, has been working fine and I see no
reason to change it with utxo bits.
I *only* propose an optional way  to synchronize changes without the
need of off chain agreements, which seems like a simple improvement over
the current situation.

> 
> Otherwise someone can make it seem to a miner like 99pct of nodes are
> ready for a larger weight.... even though that's false.
I agree that the user agent signalling isn't very important, and I think
that most of us aware that you cannot rely on counting them.
> 
> On May 23, 2017 8:03 AM, "Tomas via bitcoin-dev" <bitcoin-
> dev at lists.linuxfoundation.org> wrote:>> I have a proposal that would allow each user to optionally
>> configure the>>  maximum block weight at a support threshold.
>> 
>>  It recognizes that there is no need for off chain bickering, by
>>  providing a mechanism that lets each users freely choose their own
>>  parameters while still maintaining full coordination of any changes.>> 
>>  The BIP can be found here:
>> 
>> https://github.com/tomasvdw/bips/blob/master/bip-changing-the-maximum-block%20weight-based-on-a-support-threshold.mediawiki>> 
>>  It is worth noting that this proposal does neither gives more
>>  power to>>  miners nor reduces decentralization. Miners still rely on their
>>  blocks>>  being accepted by economic nodes to sell their minted coins. This
>>  proposal doesn't change that.
>> 
>>  Regards,
>>  Tomas van der Wansem
>>  bitcrust
>>  _______________________________________________
>>  bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170524/648bb861/attachment-0001.html>

From tier.nolan at gmail.com  Wed May 24 10:05:38 2017
From: tier.nolan at gmail.com (Tier Nolan)
Date: Wed, 24 May 2017 11:05:38 +0100
Subject: [bitcoin-dev] Drivechain -- Request for Discussion
In-Reply-To: <CAE-z3OXY2YiQ5fzxZBw4FooRsUzXricHmpv_+t+HbTf0MxP0kg@mail.gmail.com>
References: <24f2b447-a237-45eb-ef9f-1a62533fad5c@gmail.com>
	<dhstGQudLBiwjDlaRrmMfy-ixwvXcwMr1CzCkPKh285RLICGZixkbdwpTDc2Sgz8eYIqSem8lwxW6QeJCD7aFfwQjLDnZ2NmOw0Zzd-KgSs=@protonmail.com>
	<CA+XQW1jZpJ9wnEg47fouyywL09=_vU8dMP3owkkuNqRvzTZUDg@mail.gmail.com>
	<CAE-z3OUYuAXE2+h60A=r4UyGU4CSQuF98oFgHnD7iaj-=Z=yOw@mail.gmail.com>
	<CA+XQW1hRhcxJBoOJ57YG0t5y5j1Qm3RO4wr2eXV5V-UzDaiPPw@mail.gmail.com>
	<CAE-z3OVWXN58X-+nAFTm61G1=v_1xrniyrBy8x=VRG4N149aXQ@mail.gmail.com>
	<141a0cd1-9d4f-c137-a349-17248f9cafd4@gmail.com>
	<CAE-z3OXY2YiQ5fzxZBw4FooRsUzXricHmpv_+t+HbTf0MxP0kg@mail.gmail.com>
Message-ID: <CAE-z3OXLb0QOjACfvToxf9TfLJhBHiboAaieLA4V9gx6V4CjoQ@mail.gmail.com>

On Wed, May 24, 2017 at 9:50 AM, Tier Nolan <tier.nolan at gmail.com> wrote:

> OP_BRIBE_VERIFY could then operate as follows
>
> <block height> <sidechain_id> <critical hash> OP_BRIBE_VERIFY
>
> This causes the script to fail if
>   <block height> does not match the block height, or
>   <critical hash> is not the hash for the sidechain with <sidechain_id>, or
>   there is no hash for that sidechain in the block's coinbase
>
>
I was thinking more on the process for these transactions.

I assume that the process is

- sidechain miner broadcasts transaction with OP_BRIBE output
- this transaction ends up in the memory pool of miners
- Miners add the transaction to their next block
- Miners add a transaction which spends the output to one of their own
addresses

I think you need an additional rule that OP_BRIBE checks fails unless the
output is locked 100 or more blocks.

The output script would end up something like

IF
   <block height> <chain_id> <critical hash> OP_BRIBE_VERIFY
ELSE
  <public key> OP_CHECKSIG
ENDIF

This output acts like "anyone can spend" for the one block height.
Otherwise, only the sidechain miner can spend the output.

This allows the sidechain miner to reclaim their coins if the transaction
ends up in a different block.

OP_BRIBE_VERIFY would have an additional rule

The script to fails if
  one or more of the transaction outputs start with something other than
the template
  <block height> does not match the block height, or
  <critical hash> is not the hash for the sidechain with <sidechain_id>, or
  there is no hash for that sidechain in the block's coinbase

The template is
  <100> OP_CHECKSEQUENCE_VERIFY
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170524/02094798/attachment.html>

From truthcoin at gmail.com  Wed May 24 13:43:49 2017
From: truthcoin at gmail.com (Paul Sztorc)
Date: Wed, 24 May 2017 09:43:49 -0400
Subject: [bitcoin-dev] Fwd: Re:  Drivechain -- Request for Discussion
In-Reply-To: <3c744cf9-da15-00c2-dea1-f1f3a1f0b5d5@gmail.com>
References: <3c744cf9-da15-00c2-dea1-f1f3a1f0b5d5@gmail.com>
Message-ID: <b478efd3-2760-ebe3-869b-4308535aecb2@gmail.com>

Responses below.


On 5/23/2017 7:26 PM, ZmnSCPxj wrote:
> Good morning,
> 
> 
>>>
>>> How is OP_BRIBE superior to just using a <h*> OP_RETURN script? Cannot
>>> a sidechain scan the block for OP_RETURN attesting that the block hash
>>> is present in the block?
>>
>>The sidechain software can indeed, but the mainchain software cannot
>>(without making validation of both chains part of the mainchain, which
>>defeats the original purpose of sidechains).
>>
>>The purpose of OP_BRIBE is to allow "Sam" (on the sidechain) and "Mary"
>>(a mainchain miner) to work together. Sam would pay X BTC to Mary, if
>>Mary could provide Sam with some guarantee that Sam's sidechain block
>>[defined by h*] would make it into the largest chain.
> 
> Regarding "largest chain", do you mean mainchain or sidechain?

Sidechain. Sam is paying himself the revenues of the sidechain's block.
These are side:btc, that he gets, if this block is part of the largest
chain.
> 
> An OP_RETURN is still some guarantee that it will make it into the
> longest mainchain.  If OP_RETURN tx is in a shorter mainchain but not on
> the longer mainchain, then on the longer mainchain, the utxo's funding
> the OP_RETURN tx is still unspent and the OP_RETURN tx will still be
> mineable by any miner following the longer mainchain.  The X BTC would
> be the OP_RETURN transaction's fee, which Mary would still want to mine
> into the longest mainchain, as it is still money on the table if it is
> not mined on the longest mainchain.

As you say below, it is about the sidechain, not mainchain. (Anything
not in the longest mainchain is just discarded by everyone, as always.)
> 
> Or, does OP_BRIBE somehow assure that Sam's block goes onto the longer
> sidechain?  But then, do not side blocks refer to their previous side
> block to define the sidechain?

Yes, there is a new construction for this, which might be called "SPV
squared". Classical merged mining (ie Namecoin) does not require the
mainchain to do anything, except occasionally keep track of an ordered
list of hash commitments. BMM is different, it does require the
mainchain to keep track of a minimal amount of things. One is the total
number of sidechains, but the second is what you have hit on here.

In addition to a list of commitments (ideally, one commitment per
block), the mainchain also keeps track of the block number ( ..or, as
you'll see, perhaps "block number modulo x".. ) of recent sidechain
blocks (for the last x=65,536 mainchain blocks). It then subsets the
most recent y=4000 of these, and only allows new sidechain blocks to
appear if they have a blocknumber equal to a member of set Y', where Y'
is the set of all sidechain blocknumbers y blocks ago + 1.

Then, the sidechain nodes simply reject the block if the h* commitment
refers to a side:blockheader that has a different block number.

Perhaps these notes..

http://www.truthcoin.info/images/bmm-outline.txt

..would be helpful. Looking back, this is probably the hackiest part of
the entire system, by a wide margin, so it is good that you bring it up.

> 
> 
> Is there some predictable schedule for side->main withdrawals?  If a
> withdrawal is imminent, or if some actor can get "insider information"
> about whether a withdrawal is imminent, cannot some actor induce the
> above, with potentially shorter time to reach step 3?

Yes, these delays are parameters, which are defined per sidechain. So
once the sidechain has been 'added' to bitcoin, the schedule would be
fully predictable.

> 
> From my reading, Blockstream's sidechains proposal supports a reorg
> proof after a side->main withdrawal on the mainchain side, with a reorg
> proof burn window after the main:side->main withdrawal, preventing its
> utxo from being used.  If the reorg proof is published and shows that a
> sidechain reorg invalidates a particular side->main withdrawal, then the
> main:side->main withdrawal's utxo is burned.

In this, there is no reorg proof (the miners would simply prevent the
withdrawal from accumulating enough ACKs). A 51% miner coalition can
always filter any message they like from the blockchain, including the
reorg proofs.

> 
>>For extraordinary DAO-like situations, disinterested mainchain miners
>>merely need a single bit of information (per sidechain), which is
>>"distress=true", and indicates to them to temporarily stop ACKing
>>withdrawals from the sidechain. This alone is enough to give the reorg
>>an unlimited amount of time to work itself out.
> 
> Do you have some document containing these details?  I cannot find this
> in the blog posts I've read so far.

This specific detail is not documented. I feel it is comparable to, for
example, the March 2013 chain fork.

> 
>>>>I feel that my proposal is more secure, as it can operate healthily and
>>> quickly while using spv proofs which are much slower and much much
>>> easier to audit.
>>>
>>> I don't quite understand how Drivechain handles sidechain reorgs, while
>>> keeping Bitcoin miners blinded. It seems sidechains need to be known
>>> ("seen") by the miner, so I don't see what is being blinded by blinded
>>> merge mining.
>>
>>Mainchain miners do need to maintain some data about the sidechains, but
>>this is very minimal, and certainly does not include the transaction
>>data (or arbitrary messages) of the sidechain.
> 
> As above, do you have document containing what data mainchain needs to
> track?

Yes, I think the notes (above) may be helpful.

> 
>>>>>Blind merged mining seems strictly inferior ... a rich attacker can
>>> simply reorg the sidechain outright without playing such games.
>>>>
>>>>In the future, when there is no block subsidy, a rich attacker can also
>>> do that in mainchain Bitcoin.
>>>
>>> I see. However, block subsidies will drop far in the future, do you
>>> mean to say, that sidechains will be used only in the far future?
>>
>>In one sense, I mean "you have already endorsed this 'fees only will
>>work' premise, by endorsing Bitcoin".
> 
> I endorse this on the basis of Greg Maxwell's analysis that a block size
> limit is necessary to have a fee market.

Even were that the case, the limit does not need to be imposed by nodes.
Miners are likely to self-impose a limit, on nodes and each other, in
order to maximize their total revenues. In fact they will eventually be
required to do so (even though they do not now, beyond the naive
maximization of imposing minimum tx fee requirements).

In fact, in that case, the larger the range of possible blocksizes, the
greater the ability of miners to extract fees from users -- ie the less
limited the blocksize, the more hashpower security.

Simply, if revenue = R = f(demand, supply), and miners choose the supply
which argmax R , then R can only go down as supply is constrained.

And, the effect is even more beneficial to security than _that_ ...if
the sidechains are different from each other, such that blockspace in
one chain is _not_ a perfect substitute for blockspace in another. In
this case miners can choke up on some (or each) individual S_i, forcing
sum(R_i) to go even higher.


> 
> 
>>That mechanism is enforced by drivechain itself, not OP_BRIBE. (OP Bribe
>>is itself only ~half of BMM. I admit it is getting a little confusing.)
> 
> Can you provide the details of this mechanism?  For example, does h*
> actually include some information identifying the sidechain and OP_BRIBE
> is supposed to do some additional checking not shown in your current
> code, or ....?

Yes. Yes.

This is what we nicknamed the "ratchet", I cannot easily check the code
right now but will get back to you.

https://github.com/drivechain-project/bitcoin/commit/c4fe067e298f57252789c28161272db3d7483dca#diff-be5f6bb690c9898e44cbd7e78c465e43R83



> 
>>Drivechain requires a soft fork to add each new sidechain
> 
> Oh.
> 
> My understanding is that with Blockstream's zk-SNARKs, a new sidechain
> would not require a soft fork at all (or even miner voting on the
> validity of WT^: the validity of side:side->main transactions is assured
> by proof that the zk-SNARK checking that transaction was executed
> correctly, and the lack of a reorg proof during the burn window after
> the main:side->main).
> 
> Is your model then, that each sidechain maintainer has to maintain a
> patchset or some plugin system to Core?  And miners who want to support
> particular sidechains to modify their software, applying the patch for
> each sidechain they want to support?

Not necessarily, but I think "plugins" are a good metaphor.

> 
> It seems this is somewhat brittle and may cause sidechain coding
> problems to leak into mainchain.
> 
> I think, it is much less interesting to have to softfork in every
> sidechain, rather than to support a general mechanism (zk-SNARK) to
> allow sidechains to be launched without any modification to Core code.
> 

I completely disagree. Unrestrained smart contract execution will be the
death of most of the interesting applications of sidechains, and would
probably destabilize Bitcoin itself.

I would be as if your body "added" the ability to synthesize any
protein, including prions. Then you make one prion and your entire body
dies.

I thought this would come up, I have a presentation on this:
https://www.youtube.com/watch?v=xGu0o8HH10U&list=PLw8-6ARlyVciMH79ZyLOpImsMug3LgNc4&index=1

You don't need to watch the whole thing, maybe just parts 1 and 5.

> 
>>. It requires
>>this literally for a few good reasons...but the best is: there is an
>>implicit requirement that the miners not steal from the sidechain
>>anyway. In this way drivechain knows how to keep track of what it should
>>expect.
> 
> It seems to be, more of "completely sighted merged mining" than "blind
> merge mining".

You can call it microscope mining if you like..it attempts to address
the concerns that were raised earlier in the peer review process.

> 
> 
> 
>>> Perhaps the datacenter point is simply that your proposal suggests to
>>> reduce the size of the datacenter by removing surge suppressors and
>>> UPS's, to avoid some definition of "datacenter is a room with >$XXX of
>>> equipment".
>>
>>I hope that my replies above already help with these. If not, let me know.
> 
> I find this point now moot, as drivechains require a softfork for each
> sidechain, and the size of the datacenter is pointless if there is some
> need to softfork in every sidechain.

You might be confused...miners can soft fork in a sidechain that they
have *no* intention of merged mining, or BMM ing. I do not know why, as
they would be leaving money on the table, but it is possible. Perhaps
only 5% of miners want to bother with it. The point is that the other
90% hashpower has no inherent reason *not* to allow that the experiment
be run.

> 
> Regards,
> ZmnXCPxj

From 1240902 at gmail.com  Wed May 24 16:02:09 2017
From: 1240902 at gmail.com (Wang Chun)
Date: Thu, 25 May 2017 00:02:09 +0800
Subject: [bitcoin-dev] Reduced signalling threshold activation of
	existing segwit deployment
In-Reply-To: <cc20efe1-c5d4-0b79-48d9-65466834dbcf@achow101.com>
References: <CADvTj4pQ8eJvzm9UOgC8bYm1ERGuTX7qq+a7etRe55S=KodrHQ@mail.gmail.com>
	<c14039f3-637e-e56d-786a-2354b0f354e0@achow101.com>
	<CADvTj4oQsHe3jR2Bm9n0H64ouJbAy0NiXbcmFPxD_C7PSy6L0g@mail.gmail.com>
	<cc20efe1-c5d4-0b79-48d9-65466834dbcf@achow101.com>
Message-ID: <4C86CB4F-4ED2-4908-BF5D-6115891DA1D4@gmail.com>

I think we should go for 75%, same Litecoin. As I have said before, 95% threshold is too high even for unconventional soft forks.

> ? 2017?5?24??04:58?Andrew Chow via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> ???
> 
> Ah. I see now. It wasn't very clear to me that that is what will happen.
> 
> Also, shouldn't the timeout date be set for before the BIP141 timeout?
> Otherwise this could lock in but not have enough time for Segwit to be
> locked in.
> 
> 
>> On 5/23/2017 4:42 PM, James Hilliard wrote:
>> That is incorrect, it is compatible with the current segwit
>> implementation because it triggers a mandatory signalling period that
>> will activate segwit on existing nodes.
>> 
>> On Tue, May 23, 2017 at 4:39 PM, Andrew Chow via bitcoin-dev
>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>> Hi James,
>>> 
>>> From what I understand, this proposal is incompatible with the current
>>> segwit implementation with regards to the NODE_WITNESS service bit. I
>>> believe it could cause network partitioning if the service bit is not
>>> changed.
>>> 
>>> Andrew
>>> 
>>> 
>>>> On 5/22/2017 6:40 PM, James Hilliard via bitcoin-dev wrote:
>>>> I would like to propose an implementation that accomplishes the first
>>>> part of the Barry Silbert proposal independently from the second:
>>>> 
>>>> "Activate Segregated Witness at an 80% threshold, signaling at bit 4"
>>>> in a way that
>>>> 
>>>> The goal here is to minimize chain split risk and network disruption
>>>> while maximizing backwards compatibility and still providing for rapid
>>>> activation of segwit at the 80% threshold using bit 4.
>>>> 
>>>> By activating segwit immediately and separately from any HF we can
>>>> scale quickly without risking a rushed combined segwit+HF that would
>>>> almost certainly cause widespread issues.
>>>> 
>>>> Draft proposal:
>>>> https://github.com/jameshilliard/bips/blob/bip-segsignal/bip-segsignal.mediawiki
>>>> 
>>>> Proposal text:
>>>> <pre>
>>>>  BIP: segsignal
>>>>  Layer: Consensus (soft fork)
>>>>  Title: Reduced signalling threshold activation of existing segwit deployment
>>>>  Author: James Hilliard <james.hilliard1 at gmail.com>
>>>>  Status: Draft
>>>>  Type: Standards Track
>>>>  Created: 2017-05-22
>>>>  License: BSD-3-Clause
>>>>           CC0-1.0
>>>> </pre>
>>>> 
>>>> ==Abstract==
>>>> 
>>>> This document specifies a method to activate the existing BIP9 segwit
>>>> deployment with a majority hashpower less than 95%.
>>>> 
>>>> ==Definitions==
>>>> 
>>>> "existing segwit deployment" refer to the BIP9 "segwit" deployment
>>>> using bit 1, between November 15th 2016 and November 15th 2017 to
>>>> activate BIP141, BIP143 and BIP147.
>>>> 
>>>> ==Motivation==
>>>> 
>>>> Segwit increases the blocksize, fixes transaction malleability, and
>>>> makes scripting easier to upgrade as well as bringing many other
>>>> [https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].
>>>> 
>>>> This BIP provides a way for a simple majority of miners to coordinate
>>>> activation of the existing segwit deployment with less than 95%
>>>> hashpower. For a number of reasons a complete redeployment of segwit
>>>> is difficulty to do until the existing deployment expires. This is due
>>>> to 0.13.1+ having many segwit related features active already,
>>>> including all the P2P components, the new network service flag, the
>>>> witness-tx and block messages, compact blocks v2 and preferential
>>>> peering. A redeployment of segwit will need to redefine all these
>>>> things and doing so before expiry would greatly complicate testing.
>>>> 
>>>> ==Specification==
>>>> 
>>>> While this BIP is active, all blocks must set the nVersion header top
>>>> 3 bits to 001 together with bit field (1<<1) (according to the
>>>> existing segwit deployment). Blocks that do not signal as required
>>>> will be rejected.
>>>> 
>>>> ==Deployment==
>>>> 
>>>> This BIP will be deployed by a "version bits" with an 80%(this can be
>>>> adjusted if desired) activation threshold BIP9 with the name
>>>> "segsignal" and using bit 4.
>>>> 
>>>> This BIP will have a start time of midnight June 1st, 2017 (epoch time
>>>> 1496275200) and timeout on midnight November 15th 2017 (epoch time
>>>> 1510704000). This BIP will cease to be active when segwit is
>>>> locked-in.
>>>> 
>>>> === Reference implementation ===
>>>> 
>>>> <pre>
>>>> // Check if Segregated Witness is Locked In
>>>> bool IsWitnessLockedIn(const CBlockIndex* pindexPrev, const
>>>> Consensus::Params& params)
>>>> {
>>>>    LOCK(cs_main);
>>>>    return (VersionBitsState(pindexPrev, params,
>>>> Consensus::DEPLOYMENT_SEGWIT, versionbitscache) ==
>>>> THRESHOLD_LOCKED_IN);
>>>> }
>>>> 
>>>> // SEGSIGNAL mandatory segwit signalling.
>>>> if ( VersionBitsState(pindex->pprev, chainparams.GetConsensus(),
>>>> Consensus::DEPLOYMENT_SEGSIGNAL, versionbitscache) == THRESHOLD_ACTIVE
>>>> &&
>>>>     !IsWitnessLockedIn(pindex->pprev, chainparams.GetConsensus()) &&
>>>> // Segwit is not locked in
>>>>     !IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) ) //
>>>> and is not active.
>>>> {
>>>>    bool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) ==
>>>> VERSIONBITS_TOP_BITS;
>>>>    bool fSegbit = (pindex->nVersion &
>>>> VersionBitsMask(chainparams.GetConsensus(),
>>>> Consensus::DEPLOYMENT_SEGWIT)) != 0;
>>>>    if (!(fVersionBits && fSegbit)) {
>>>>        return state.DoS(0, error("ConnectBlock(): relayed block must
>>>> signal for segwit, please upgrade"), REJECT_INVALID, "bad-no-segwit");
>>>>    }
>>>> }
>>>> </pre>
>>>> 
>>>> https://github.com/bitcoin/bitcoin/compare/0.14...jameshilliard:segsignal-v0.14.1
>>>> 
>>>> ==Backwards Compatibility==
>>>> 
>>>> This deployment is compatible with the existing "segwit" bit 1
>>>> deployment scheduled between midnight November 15th, 2016 and midnight
>>>> November 15th, 2017. Miners will need to upgrade their nodes to
>>>> support segsignal otherwise they may build on top of an invalid block.
>>>> While this bip is active users should either upgrade to segsignal or
>>>> wait for additional confirmations when accepting payments.
>>>> 
>>>> ==Rationale==
>>>> 
>>>> Historically we have used IsSuperMajority() to activate soft forks
>>>> such as BIP66 which has a mandatory signalling requirement for miners
>>>> once activated, this ensures that miners are aware of new rules being
>>>> enforced. This technique can be leveraged to lower the signalling
>>>> threshold of a soft fork while it is in the process of being deployed
>>>> in a backwards compatible way.
>>>> 
>>>> By orphaning non-signalling blocks during the BIP9 bit 1 "segwit"
>>>> deployment, this BIP can cause the existing "segwit" deployment to
>>>> activate without needing to release a new deployment.
>>>> 
>>>> ==References==
>>>> 
>>>> *[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013714.html
>>>> Mailing list discussion]
>>>> *[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.cpp#L1281-L1283
>>>> P2SH flag day activation]
>>>> *[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]
>>>> *[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]
>>>> *[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]
>>>> *[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for
>>>> Version 0 Witness Program]]
>>>> *[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element malleability]]
>>>> *[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit deployment]]
>>>> *[[bip-0149.mediawiki|BIP149 Segregated Witness (second deployment)]]
>>>> *[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit benefits]
>>>> 
>>>> ==Copyright==
>>>> 
>>>> This document is dual licensed as BSD 3-clause, and Creative Commons
>>>> CC0 1.0 Universal.
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From james.hilliard1 at gmail.com  Wed May 24 16:36:03 2017
From: james.hilliard1 at gmail.com (James Hilliard)
Date: Wed, 24 May 2017 12:36:03 -0400
Subject: [bitcoin-dev] Reduced signalling threshold activation of
 existing segwit deployment
In-Reply-To: <4C86CB4F-4ED2-4908-BF5D-6115891DA1D4@gmail.com>
References: <CADvTj4pQ8eJvzm9UOgC8bYm1ERGuTX7qq+a7etRe55S=KodrHQ@mail.gmail.com>
	<c14039f3-637e-e56d-786a-2354b0f354e0@achow101.com>
	<CADvTj4oQsHe3jR2Bm9n0H64ouJbAy0NiXbcmFPxD_C7PSy6L0g@mail.gmail.com>
	<cc20efe1-c5d4-0b79-48d9-65466834dbcf@achow101.com>
	<4C86CB4F-4ED2-4908-BF5D-6115891DA1D4@gmail.com>
Message-ID: <CADvTj4q7oKiNsO6sLRmM-v=FFC=10MX2_k7+QuVrNq79t1Dy_w@mail.gmail.com>

I would be fine with that, since segwit is widely deployed on the
network already a lower activation threshold should be safe.

On Wed, May 24, 2017 at 12:02 PM, Wang Chun <1240902 at gmail.com> wrote:
> I think we should go for 75%, same Litecoin. As I have said before, 95% threshold is too high even for unconventional soft forks.
>
>> ? 2017?5?24??04:58?Andrew Chow via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> ???
>>
>> Ah. I see now. It wasn't very clear to me that that is what will happen.
>>
>> Also, shouldn't the timeout date be set for before the BIP141 timeout?
>> Otherwise this could lock in but not have enough time for Segwit to be
>> locked in.
>>
>>
>>> On 5/23/2017 4:42 PM, James Hilliard wrote:
>>> That is incorrect, it is compatible with the current segwit
>>> implementation because it triggers a mandatory signalling period that
>>> will activate segwit on existing nodes.
>>>
>>> On Tue, May 23, 2017 at 4:39 PM, Andrew Chow via bitcoin-dev
>>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>> Hi James,
>>>>
>>>> From what I understand, this proposal is incompatible with the current
>>>> segwit implementation with regards to the NODE_WITNESS service bit. I
>>>> believe it could cause network partitioning if the service bit is not
>>>> changed.
>>>>
>>>> Andrew
>>>>
>>>>
>>>>> On 5/22/2017 6:40 PM, James Hilliard via bitcoin-dev wrote:
>>>>> I would like to propose an implementation that accomplishes the first
>>>>> part of the Barry Silbert proposal independently from the second:
>>>>>
>>>>> "Activate Segregated Witness at an 80% threshold, signaling at bit 4"
>>>>> in a way that
>>>>>
>>>>> The goal here is to minimize chain split risk and network disruption
>>>>> while maximizing backwards compatibility and still providing for rapid
>>>>> activation of segwit at the 80% threshold using bit 4.
>>>>>
>>>>> By activating segwit immediately and separately from any HF we can
>>>>> scale quickly without risking a rushed combined segwit+HF that would
>>>>> almost certainly cause widespread issues.
>>>>>
>>>>> Draft proposal:
>>>>> https://github.com/jameshilliard/bips/blob/bip-segsignal/bip-segsignal.mediawiki
>>>>>
>>>>> Proposal text:
>>>>> <pre>
>>>>>  BIP: segsignal
>>>>>  Layer: Consensus (soft fork)
>>>>>  Title: Reduced signalling threshold activation of existing segwit deployment
>>>>>  Author: James Hilliard <james.hilliard1 at gmail.com>
>>>>>  Status: Draft
>>>>>  Type: Standards Track
>>>>>  Created: 2017-05-22
>>>>>  License: BSD-3-Clause
>>>>>           CC0-1.0
>>>>> </pre>
>>>>>
>>>>> ==Abstract==
>>>>>
>>>>> This document specifies a method to activate the existing BIP9 segwit
>>>>> deployment with a majority hashpower less than 95%.
>>>>>
>>>>> ==Definitions==
>>>>>
>>>>> "existing segwit deployment" refer to the BIP9 "segwit" deployment
>>>>> using bit 1, between November 15th 2016 and November 15th 2017 to
>>>>> activate BIP141, BIP143 and BIP147.
>>>>>
>>>>> ==Motivation==
>>>>>
>>>>> Segwit increases the blocksize, fixes transaction malleability, and
>>>>> makes scripting easier to upgrade as well as bringing many other
>>>>> [https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].
>>>>>
>>>>> This BIP provides a way for a simple majority of miners to coordinate
>>>>> activation of the existing segwit deployment with less than 95%
>>>>> hashpower. For a number of reasons a complete redeployment of segwit
>>>>> is difficulty to do until the existing deployment expires. This is due
>>>>> to 0.13.1+ having many segwit related features active already,
>>>>> including all the P2P components, the new network service flag, the
>>>>> witness-tx and block messages, compact blocks v2 and preferential
>>>>> peering. A redeployment of segwit will need to redefine all these
>>>>> things and doing so before expiry would greatly complicate testing.
>>>>>
>>>>> ==Specification==
>>>>>
>>>>> While this BIP is active, all blocks must set the nVersion header top
>>>>> 3 bits to 001 together with bit field (1<<1) (according to the
>>>>> existing segwit deployment). Blocks that do not signal as required
>>>>> will be rejected.
>>>>>
>>>>> ==Deployment==
>>>>>
>>>>> This BIP will be deployed by a "version bits" with an 80%(this can be
>>>>> adjusted if desired) activation threshold BIP9 with the name
>>>>> "segsignal" and using bit 4.
>>>>>
>>>>> This BIP will have a start time of midnight June 1st, 2017 (epoch time
>>>>> 1496275200) and timeout on midnight November 15th 2017 (epoch time
>>>>> 1510704000). This BIP will cease to be active when segwit is
>>>>> locked-in.
>>>>>
>>>>> === Reference implementation ===
>>>>>
>>>>> <pre>
>>>>> // Check if Segregated Witness is Locked In
>>>>> bool IsWitnessLockedIn(const CBlockIndex* pindexPrev, const
>>>>> Consensus::Params& params)
>>>>> {
>>>>>    LOCK(cs_main);
>>>>>    return (VersionBitsState(pindexPrev, params,
>>>>> Consensus::DEPLOYMENT_SEGWIT, versionbitscache) ==
>>>>> THRESHOLD_LOCKED_IN);
>>>>> }
>>>>>
>>>>> // SEGSIGNAL mandatory segwit signalling.
>>>>> if ( VersionBitsState(pindex->pprev, chainparams.GetConsensus(),
>>>>> Consensus::DEPLOYMENT_SEGSIGNAL, versionbitscache) == THRESHOLD_ACTIVE
>>>>> &&
>>>>>     !IsWitnessLockedIn(pindex->pprev, chainparams.GetConsensus()) &&
>>>>> // Segwit is not locked in
>>>>>     !IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) ) //
>>>>> and is not active.
>>>>> {
>>>>>    bool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) ==
>>>>> VERSIONBITS_TOP_BITS;
>>>>>    bool fSegbit = (pindex->nVersion &
>>>>> VersionBitsMask(chainparams.GetConsensus(),
>>>>> Consensus::DEPLOYMENT_SEGWIT)) != 0;
>>>>>    if (!(fVersionBits && fSegbit)) {
>>>>>        return state.DoS(0, error("ConnectBlock(): relayed block must
>>>>> signal for segwit, please upgrade"), REJECT_INVALID, "bad-no-segwit");
>>>>>    }
>>>>> }
>>>>> </pre>
>>>>>
>>>>> https://github.com/bitcoin/bitcoin/compare/0.14...jameshilliard:segsignal-v0.14.1
>>>>>
>>>>> ==Backwards Compatibility==
>>>>>
>>>>> This deployment is compatible with the existing "segwit" bit 1
>>>>> deployment scheduled between midnight November 15th, 2016 and midnight
>>>>> November 15th, 2017. Miners will need to upgrade their nodes to
>>>>> support segsignal otherwise they may build on top of an invalid block.
>>>>> While this bip is active users should either upgrade to segsignal or
>>>>> wait for additional confirmations when accepting payments.
>>>>>
>>>>> ==Rationale==
>>>>>
>>>>> Historically we have used IsSuperMajority() to activate soft forks
>>>>> such as BIP66 which has a mandatory signalling requirement for miners
>>>>> once activated, this ensures that miners are aware of new rules being
>>>>> enforced. This technique can be leveraged to lower the signalling
>>>>> threshold of a soft fork while it is in the process of being deployed
>>>>> in a backwards compatible way.
>>>>>
>>>>> By orphaning non-signalling blocks during the BIP9 bit 1 "segwit"
>>>>> deployment, this BIP can cause the existing "segwit" deployment to
>>>>> activate without needing to release a new deployment.
>>>>>
>>>>> ==References==
>>>>>
>>>>> *[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013714.html
>>>>> Mailing list discussion]
>>>>> *[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.cpp#L1281-L1283
>>>>> P2SH flag day activation]
>>>>> *[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]
>>>>> *[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]
>>>>> *[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]
>>>>> *[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for
>>>>> Version 0 Witness Program]]
>>>>> *[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element malleability]]
>>>>> *[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit deployment]]
>>>>> *[[bip-0149.mediawiki|BIP149 Segregated Witness (second deployment)]]
>>>>> *[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit benefits]
>>>>>
>>>>> ==Copyright==
>>>>>
>>>>> This document is dual licensed as BSD 3-clause, and Creative Commons
>>>>> CC0 1.0 Universal.
>>>>> _______________________________________________
>>>>> bitcoin-dev mailing list
>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From erik at q32.com  Wed May 24 16:44:55 2017
From: erik at q32.com (Erik Aronesty)
Date: Wed, 24 May 2017 12:44:55 -0400
Subject: [bitcoin-dev] Reduced signalling threshold activation of
 existing segwit deployment
In-Reply-To: <4C86CB4F-4ED2-4908-BF5D-6115891DA1D4@gmail.com>
References: <CADvTj4pQ8eJvzm9UOgC8bYm1ERGuTX7qq+a7etRe55S=KodrHQ@mail.gmail.com>
	<c14039f3-637e-e56d-786a-2354b0f354e0@achow101.com>
	<CADvTj4oQsHe3jR2Bm9n0H64ouJbAy0NiXbcmFPxD_C7PSy6L0g@mail.gmail.com>
	<cc20efe1-c5d4-0b79-48d9-65466834dbcf@achow101.com>
	<4C86CB4F-4ED2-4908-BF5D-6115891DA1D4@gmail.com>
Message-ID: <CAJowKg+bD675iC9FUAP82KVUZteox9MGnd-EXqKr2tuQsCC5nA@mail.gmail.com>

Yes, 75% seems fine - given that there is a already a wide deployment of
segwit enforcing nodes

This implementation is 100% compatible with a "UASF movement" since, if
triggered, it essentially turns all supporting miners into equivalent
BIP148 enforcers.   This should allay any fears that this would subvert a
UASF.

The proposed "agreement" which was reached without input from the
development community also apparently requires that a hard fork be locked
in on the same bit (bit 4).

Ideally, such a 2MB increase should be scheduled using BIP103-esqe logic:
Gradually increasing from 1MB to 2MB over the course of at least a couple
years, beginning 6 months from lock-in.

This will give developers ample time to evaluate and react to network
impacts.


On Wed, May 24, 2017 at 12:02 PM, Wang Chun via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I think we should go for 75%, same Litecoin. As I have said before, 95%
> threshold is too high even for unconventional soft forks.
>
> > ? 2017?5?24??04:58?Andrew Chow via bitcoin-dev <bitcoin-dev at lists.
> linuxfoundation.org> ???
> >
> > Ah. I see now. It wasn't very clear to me that that is what will happen.
> >
> > Also, shouldn't the timeout date be set for before the BIP141 timeout?
> > Otherwise this could lock in but not have enough time for Segwit to be
> > locked in.
> >
> >
> >> On 5/23/2017 4:42 PM, James Hilliard wrote:
> >> That is incorrect, it is compatible with the current segwit
> >> implementation because it triggers a mandatory signalling period that
> >> will activate segwit on existing nodes.
> >>
> >> On Tue, May 23, 2017 at 4:39 PM, Andrew Chow via bitcoin-dev
> >> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>> Hi James,
> >>>
> >>> From what I understand, this proposal is incompatible with the current
> >>> segwit implementation with regards to the NODE_WITNESS service bit. I
> >>> believe it could cause network partitioning if the service bit is not
> >>> changed.
> >>>
> >>> Andrew
> >>>
> >>>
> >>>> On 5/22/2017 6:40 PM, James Hilliard via bitcoin-dev wrote:
> >>>> I would like to propose an implementation that accomplishes the first
> >>>> part of the Barry Silbert proposal independently from the second:
> >>>>
> >>>> "Activate Segregated Witness at an 80% threshold, signaling at bit 4"
> >>>> in a way that
> >>>>
> >>>> The goal here is to minimize chain split risk and network disruption
> >>>> while maximizing backwards compatibility and still providing for rapid
> >>>> activation of segwit at the 80% threshold using bit 4.
> >>>>
> >>>> By activating segwit immediately and separately from any HF we can
> >>>> scale quickly without risking a rushed combined segwit+HF that would
> >>>> almost certainly cause widespread issues.
> >>>>
> >>>> Draft proposal:
> >>>> https://github.com/jameshilliard/bips/blob/bip-
> segsignal/bip-segsignal.mediawiki
> >>>>
> >>>> Proposal text:
> >>>> <pre>
> >>>>  BIP: segsignal
> >>>>  Layer: Consensus (soft fork)
> >>>>  Title: Reduced signalling threshold activation of existing segwit
> deployment
> >>>>  Author: James Hilliard <james.hilliard1 at gmail.com>
> >>>>  Status: Draft
> >>>>  Type: Standards Track
> >>>>  Created: 2017-05-22
> >>>>  License: BSD-3-Clause
> >>>>           CC0-1.0
> >>>> </pre>
> >>>>
> >>>> ==Abstract==
> >>>>
> >>>> This document specifies a method to activate the existing BIP9 segwit
> >>>> deployment with a majority hashpower less than 95%.
> >>>>
> >>>> ==Definitions==
> >>>>
> >>>> "existing segwit deployment" refer to the BIP9 "segwit" deployment
> >>>> using bit 1, between November 15th 2016 and November 15th 2017 to
> >>>> activate BIP141, BIP143 and BIP147.
> >>>>
> >>>> ==Motivation==
> >>>>
> >>>> Segwit increases the blocksize, fixes transaction malleability, and
> >>>> makes scripting easier to upgrade as well as bringing many other
> >>>> [https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].
> >>>>
> >>>> This BIP provides a way for a simple majority of miners to coordinate
> >>>> activation of the existing segwit deployment with less than 95%
> >>>> hashpower. For a number of reasons a complete redeployment of segwit
> >>>> is difficulty to do until the existing deployment expires. This is due
> >>>> to 0.13.1+ having many segwit related features active already,
> >>>> including all the P2P components, the new network service flag, the
> >>>> witness-tx and block messages, compact blocks v2 and preferential
> >>>> peering. A redeployment of segwit will need to redefine all these
> >>>> things and doing so before expiry would greatly complicate testing.
> >>>>
> >>>> ==Specification==
> >>>>
> >>>> While this BIP is active, all blocks must set the nVersion header top
> >>>> 3 bits to 001 together with bit field (1<<1) (according to the
> >>>> existing segwit deployment). Blocks that do not signal as required
> >>>> will be rejected.
> >>>>
> >>>> ==Deployment==
> >>>>
> >>>> This BIP will be deployed by a "version bits" with an 80%(this can be
> >>>> adjusted if desired) activation threshold BIP9 with the name
> >>>> "segsignal" and using bit 4.
> >>>>
> >>>> This BIP will have a start time of midnight June 1st, 2017 (epoch time
> >>>> 1496275200) and timeout on midnight November 15th 2017 (epoch time
> >>>> 1510704000). This BIP will cease to be active when segwit is
> >>>> locked-in.
> >>>>
> >>>> === Reference implementation ===
> >>>>
> >>>> <pre>
> >>>> // Check if Segregated Witness is Locked In
> >>>> bool IsWitnessLockedIn(const CBlockIndex* pindexPrev, const
> >>>> Consensus::Params& params)
> >>>> {
> >>>>    LOCK(cs_main);
> >>>>    return (VersionBitsState(pindexPrev, params,
> >>>> Consensus::DEPLOYMENT_SEGWIT, versionbitscache) ==
> >>>> THRESHOLD_LOCKED_IN);
> >>>> }
> >>>>
> >>>> // SEGSIGNAL mandatory segwit signalling.
> >>>> if ( VersionBitsState(pindex->pprev, chainparams.GetConsensus(),
> >>>> Consensus::DEPLOYMENT_SEGSIGNAL, versionbitscache) ==
> THRESHOLD_ACTIVE
> >>>> &&
> >>>>     !IsWitnessLockedIn(pindex->pprev, chainparams.GetConsensus()) &&
> >>>> // Segwit is not locked in
> >>>>     !IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) ) //
> >>>> and is not active.
> >>>> {
> >>>>    bool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) ==
> >>>> VERSIONBITS_TOP_BITS;
> >>>>    bool fSegbit = (pindex->nVersion &
> >>>> VersionBitsMask(chainparams.GetConsensus(),
> >>>> Consensus::DEPLOYMENT_SEGWIT)) != 0;
> >>>>    if (!(fVersionBits && fSegbit)) {
> >>>>        return state.DoS(0, error("ConnectBlock(): relayed block must
> >>>> signal for segwit, please upgrade"), REJECT_INVALID, "bad-no-segwit");
> >>>>    }
> >>>> }
> >>>> </pre>
> >>>>
> >>>> https://github.com/bitcoin/bitcoin/compare/0.14...
> jameshilliard:segsignal-v0.14.1
> >>>>
> >>>> ==Backwards Compatibility==
> >>>>
> >>>> This deployment is compatible with the existing "segwit" bit 1
> >>>> deployment scheduled between midnight November 15th, 2016 and midnight
> >>>> November 15th, 2017. Miners will need to upgrade their nodes to
> >>>> support segsignal otherwise they may build on top of an invalid block.
> >>>> While this bip is active users should either upgrade to segsignal or
> >>>> wait for additional confirmations when accepting payments.
> >>>>
> >>>> ==Rationale==
> >>>>
> >>>> Historically we have used IsSuperMajority() to activate soft forks
> >>>> such as BIP66 which has a mandatory signalling requirement for miners
> >>>> once activated, this ensures that miners are aware of new rules being
> >>>> enforced. This technique can be leveraged to lower the signalling
> >>>> threshold of a soft fork while it is in the process of being deployed
> >>>> in a backwards compatible way.
> >>>>
> >>>> By orphaning non-signalling blocks during the BIP9 bit 1 "segwit"
> >>>> deployment, this BIP can cause the existing "segwit" deployment to
> >>>> activate without needing to release a new deployment.
> >>>>
> >>>> ==References==
> >>>>
> >>>> *[https://lists.linuxfoundation.org/pipermail/
> bitcoin-dev/2017-March/013714.html
> >>>> Mailing list discussion]
> >>>> *[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.
> cpp#L1281-L1283
> >>>> P2SH flag day activation]
> >>>> *[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]
> >>>> *[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]
> >>>> *[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]
> >>>> *[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for
> >>>> Version 0 Witness Program]]
> >>>> *[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element
> malleability]]
> >>>> *[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit
> deployment]]
> >>>> *[[bip-0149.mediawiki|BIP149 Segregated Witness (second deployment)]]
> >>>> *[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit
> benefits]
> >>>>
> >>>> ==Copyright==
> >>>>
> >>>> This document is dual licensed as BSD 3-clause, and Creative Commons
> >>>> CC0 1.0 Universal.
> >>>> _______________________________________________
> >>>> bitcoin-dev mailing list
> >>>> bitcoin-dev at lists.linuxfoundation.org
> >>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >>> _______________________________________________
> >>> bitcoin-dev mailing list
> >>> bitcoin-dev at lists.linuxfoundation.org
> >>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170524/c635f01f/attachment.html>

From cryptaxe at gmail.com  Wed May 24 17:32:22 2017
From: cryptaxe at gmail.com (CryptAxe)
Date: Wed, 24 May 2017 10:32:22 -0700
Subject: [bitcoin-dev] Drivechain -- Request for Discussion
In-Reply-To: <CAE-z3OXLb0QOjACfvToxf9TfLJhBHiboAaieLA4V9gx6V4CjoQ@mail.gmail.com>
References: <24f2b447-a237-45eb-ef9f-1a62533fad5c@gmail.com>
	<dhstGQudLBiwjDlaRrmMfy-ixwvXcwMr1CzCkPKh285RLICGZixkbdwpTDc2Sgz8eYIqSem8lwxW6QeJCD7aFfwQjLDnZ2NmOw0Zzd-KgSs=@protonmail.com>
	<CA+XQW1jZpJ9wnEg47fouyywL09=_vU8dMP3owkkuNqRvzTZUDg@mail.gmail.com>
	<CAE-z3OUYuAXE2+h60A=r4UyGU4CSQuF98oFgHnD7iaj-=Z=yOw@mail.gmail.com>
	<CA+XQW1hRhcxJBoOJ57YG0t5y5j1Qm3RO4wr2eXV5V-UzDaiPPw@mail.gmail.com>
	<CAE-z3OVWXN58X-+nAFTm61G1=v_1xrniyrBy8x=VRG4N149aXQ@mail.gmail.com>
	<141a0cd1-9d4f-c137-a349-17248f9cafd4@gmail.com>
	<CAE-z3OXY2YiQ5fzxZBw4FooRsUzXricHmpv_+t+HbTf0MxP0kg@mail.gmail.com>
	<CAE-z3OXLb0QOjACfvToxf9TfLJhBHiboAaieLA4V9gx6V4CjoQ@mail.gmail.com>
Message-ID: <2b5567e1-2b6d-db4a-0f44-c66a24fe28ea@gmail.com>

Your assumptions of the bribe process are indeed correct you seem to
have a pretty good handle on all of that.

Hopefully I can clear up a few things. BMM among other things is still a
work in progress so you'll have to wait a
bit longer before any reorg code is on github. The "ratchet" system on
github right now just has the block hash
part of the critical hash script. The completed version needs to check
the sidechain number (ID) and the sidechain
block number in the script. Also the block number can only change by +1
or -1, so when a new h* is added to the
queue it must be compared to the most recent h* in the queue.
std::abs(queue.back().nHeight - ToAdd.nHeight) must equal 1.

Here's what the script looks like on github:
Note that the h* is just a block hash.

script << OP_RETURN << ToByteVector(h*);

Here's what I'm testing right now as I'm working on BMM:

script << OP_RETURN << CScriptNum::serialize(nSidechain) <<
CScriptNum(nSidechainHeight) << ToByteVector(sidechain blinded block
hash h*)

One other thing I want to make sure is clear enough is that the block
number in the critical hash script is
a sidechain block number, not a mainchain block number. That might mess
up the new format you have
suggested for bribes. And the reason a sidechain miner would want to
refund their bribe is if the h* doesn't
end up in a coinbase after a number of blocks, making their blinded
block on the sidechain invalid as tx's
will be spent in other blocks that do get their h* in a coinbase.

We were thinking about making bribe outputs have a maturity period like
generated coins. You
think that they should be locked for >100 blocks by having OP_BRIBE also
check the lock time?

I like all of your suggestions so far, thank you for taking a look!


On 05/24/2017 03:05 AM, Tier Nolan via bitcoin-dev wrote:
> On Wed, May 24, 2017 at 9:50 AM, Tier Nolan <tier.nolan at gmail.com
> <mailto:tier.nolan at gmail.com>> wrote:
>
>     OP_BRIBE_VERIFY could then operate as follows
>
>     <block height> <sidechain_id> <critical hash> OP_BRIBE_VERIFY
>
>     This causes the script to fail if
>       <block height> does not match the block height, or
>       <critical hash> is not the hash for the sidechain with
>     <sidechain_id>, or
>       there is no hash for that sidechain in the block's coinbase
>
>
> I was thinking more on the process for these transactions.
>
> I assume that the process is
>
> - sidechain miner broadcasts transaction with OP_BRIBE output
> - this transaction ends up in the memory pool of miners
> - Miners add the transaction to their next block
> - Miners add a transaction which spends the output to one of their own
> addresses
>
> I think you need an additional rule that OP_BRIBE checks fails unless
> the output is locked 100 or more blocks.
>
> The output script would end up something like
>
> IF
>    <block height> <chain_id> <critical hash> OP_BRIBE_VERIFY
> ELSE
>   <public key> OP_CHECKSIG
> ENDIF
>
> This output acts like "anyone can spend" for the one block height. 
> Otherwise, only the sidechain miner can spend the output.
>
> This allows the sidechain miner to reclaim their coins if the
> transaction ends up in a different block.
>
> OP_BRIBE_VERIFY would have an additional rule
>
> The script to fails if
>   one or more of the transaction outputs start with something other
> than the template
>   <block height> does not match the block height, or
>   <critical hash> is not the hash for the sidechain with
> <sidechain_id>, or
>   there is no hash for that sidechain in the block's coinbase
>
> The template is
>   <100> OP_CHECKSEQUENCE_VERIFY
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170524/6970f30f/attachment-0001.html>

From da2ce7 at gmail.com  Wed May 24 17:59:28 2017
From: da2ce7 at gmail.com (Cameron Garnham)
Date: Wed, 24 May 2017 20:59:28 +0300
Subject: [bitcoin-dev]
 =?utf-8?b?VHJlYXRpbmcg4oCYQVNJQ0JPT1NU4oCZIGFzIGEg?=
 =?utf-8?q?Security_Vulnerability?=
In-Reply-To: <CAJowKg+MZfdfSkZQQutKsFY=rcQSAhLtpRT7dAEH=qyYPNN67A@mail.gmail.com>
References: <4BA0FA5D-7B29-4A7F-BC5B-361ED00D5CB2@gmail.com>
	<CAMnpzfoe1jNu6Uj8uXTJeGNLHG1O9DGtvy=aMJd=6OBS+_weSw@mail.gmail.com>
	<CAJowKgLurok+bTKrt8EAAF0Q7u=cEDwfxOuQJkYNKieFpCPErQ@mail.gmail.com>
	<CAJowKg+r3XKaoN3ys3o3FWhpJ3w8An1q0oYMmu_KzDfNdzF8Vg@mail.gmail.com>
	<CAJowKgKf22b2jjRbmG+k53g4bOzXrk7AHVcR02xqXPU8ZLJhaQ@mail.gmail.com>
	<CAJowKg+LAcVCsH7gbuZhKnnv8p5=WXqNCs5oqub3bacRpQ7n9w@mail.gmail.com>
	<CAJowKg+MZfdfSkZQQutKsFY=rcQSAhLtpRT7dAEH=qyYPNN67A@mail.gmail.com>
Message-ID: <A2E37BF2-F1FF-4273-A0CE-08384D41E450@gmail.com>

Hello Bitcoin-Dev,

A quick update that CVE-2017-9230 has been assigned for the security vulnerability commonly called ?ASICBOOST?:

"The Bitcoin Proof-of-Work algorithm does not consider a certain attack methodology related to 80-byte block headers with a variety of initial 64-byte chunks followed by the same 16-byte chunk, multiple candidate root values ending with the same 4 bytes, and calculations involving sqrt numbers. This violates the security assumptions of (1) the choice of input, outside of the dedicated nonce area, fed into the Proof-of-Work function should not change its difficulty to evaluate and (2) every Proof-of-Work function execution should be independent.?

I would like to especially thank the CVE team at Mitre for their suggested description that was more appropriate than my proposed text.

https://cve.mitre.org/cgi-bin/cvename.cgi?name=+CVE-2017-9230

Cameron.



> Begin forwarded message:
> 
> From: <cve-request at mitre.org>
> Subject: Re: [scr-xxxxx] Bitcoin - All
> Date: 24 May 2017 at 18:52:22 GMT+3
> To: <da2ce7 at gmail.com>
> Cc: <cve-request at mitre.org>
> 
> Signed PGP part
> > [Suggested description]
> > The Bitcoin Proof-of-Work algorithm does not consider a certain attack
> > methodology related to 80-byte block headers with a variety of initial
> > 64-byte chunks followed by the same 16-byte chunk, multiple candidate
> > root values ending with the same 4 bytes, and calculations involving
> > sqrt numbers. This violates the security assumptions of (1) the choice
> > of input, outside of the dedicated nonce area, fed into the
> > Proof-of-Work function should not change its difficulty to evaluate
> > and (2) every Proof-of-Work function execution should be independent.
> >
> > ------------------------------------------
> >
> > [Additional Information]
> > ASICBOOST, originality promoted as a patented mining optimisation(1).
> > Has under detailed study (2), become regarded as an actively exploited
> > (3), security vulnerability (4), of Bitcoin.
> >
> > The Bitcoin Proof-of-Work Algorithm is dependent on the following two
> > security assumptions that are both broken by 'ASICBOOST':
> > 1. The choice of input, outside of the dedicated nonce area, fed into
> > the Proof-of-Work function should not change it's difficulty to
> > evaluate.
> > 2.  Every Proof-of-Work function execution should be independent.
> >
> > 'ASICBOOST' creates a layer-violation where the structure of the input
> > outside of the dedicated nonce area will change the performance of the
> > mining calculations (5). 'ASICBOOST' exploits a vulnerability where
> > the Proof-of-Work function execution is not independent (6).
> >
> > References:
> > (1) Original Whitepaper by Dr. Timo Hanke: https://arxiv.org/ftp/arxiv/papers/1604/1604.00575.pdf
> > (2) Academic Write-up by Jeremy Rubin: http://www.mit.edu/~jlrubin//public/pdfs/Asicboost.pdf
> > (3) Evidence of Active Exploit by Gregory Maxwell:
> >  https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-April/013996.html
> > (4) Discussion to assign a CVE Number, by Cameron Garnham:
> >   https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014349.html
> > (5) Discussion of the perverse incentives created by 'ASICBOOST' by Ryan Grant:
> >   https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014352.html
> > (6) Discussion of ASICBOOST's non-independent PoW calculation by Tier Nolan:
> >   https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014351.html
> >
> > The patent holder of this particular security vulnerability has a dedicated website: https://www.asicboost.com/
> >
> > ------------------------------------------
> >
> > [VulnerabilityType Other]
> > Cryptocurrency Mining Algorithm Weakness
> >
> > ------------------------------------------
> >
> > [Vendor of Product]
> > Bitcoin
> >
> > ------------------------------------------
> >
> > [Affected Product Code Base]
> > Bitcoin - All
> >
> > ------------------------------------------
> >
> > [Affected Component]
> > Bitcoin
> >
> > ------------------------------------------
> >
> > [Attack Type Other]
> > Cryptocurrency Proof-of-Work Algorithm Weakness
> >
> > ------------------------------------------
> >
> > [CVE Impact Other]
> > Creation of Perverse Incentives in a Cryptocurrency
> >
> > ------------------------------------------
> >
> > [Attack Vectors]
> > Bitcoin Mining Unfair Advantage
> > Bitcoin Layer-Violations Creating Perverse System Incentives
> >
> > ------------------------------------------
> >
> > [Reference]
> > https://arxiv.org/ftp/arxiv/papers/1604/1604.00575.pdf
> > http://www.mit.edu/~jlrubin//public/pdfs/Asicboost.pdf
> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-April/013996.html
> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014349.html
> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014352.html
> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014351.html
> >
> > ------------------------------------------
> >
> > [Has vendor confirmed or acknowledged the vulnerability?]
> > true
> >
> > ------------------------------------------
> >
> > [Discoverer]
> > Original Discovery: Dr. Timo Hanke and Sergio Lerner. Proof of Active
> > Exploit: Gregory Maxwell. CVE Reporter: Cameron Garnham
> 
> Use CVE-2017-9230.
> 
> 
> --
> CVE Assignment Team
> M/S M300, 202 Burlington Road, Bedford, MA 01730 USA
> [ A PGP key is available for encrypted communications at
>   http://cve.mitre.org/cve/request_id.html ]
> 


From jtimon at jtimon.cc  Thu May 25 19:53:29 2017
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Thu, 25 May 2017 21:53:29 +0200
Subject: [bitcoin-dev] Suggested changes to bip8
Message-ID: <CABm2gDrZV-dwsXc++NL6T6GgBsuVUsC9iTsXOjTbbsnfa9btVw@mail.gmail.com>

Hi, I didn't want to comment on
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-February/013643.html
because it seemed to me that thread was more broad.

I like bip8 very much as an extension to bip9, but I think it could be better.
With bip9, a bip9-ready node that sees a softfork activated that he is
not aware of will see a warning. See the implementation:

https://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp#L1832

But with bip8, if a deployment is made at the end of the period
instead of through 95% signaling, nodes that implement bip8 but don't
implement a certain deployment that is activated can't receive such a
warning.

The solution that comes to mind is to reserve one of the nVersion for
the specific purpose of requiring that the bit is active for one block
when a deployment is locked in in this way (or maybe also when it's
activated with miners' signaling too, maybe that can be used to
simplify the way the current warnings are checked).

I expect the code changes to do this to be simple, and I'm happy to
help with it.

From tier.nolan at gmail.com  Thu May 25 22:08:00 2017
From: tier.nolan at gmail.com (Tier Nolan)
Date: Thu, 25 May 2017 23:08:00 +0100
Subject: [bitcoin-dev] Drivechain -- Request for Discussion
In-Reply-To: <2b5567e1-2b6d-db4a-0f44-c66a24fe28ea@gmail.com>
References: <24f2b447-a237-45eb-ef9f-1a62533fad5c@gmail.com>
	<dhstGQudLBiwjDlaRrmMfy-ixwvXcwMr1CzCkPKh285RLICGZixkbdwpTDc2Sgz8eYIqSem8lwxW6QeJCD7aFfwQjLDnZ2NmOw0Zzd-KgSs=@protonmail.com>
	<CA+XQW1jZpJ9wnEg47fouyywL09=_vU8dMP3owkkuNqRvzTZUDg@mail.gmail.com>
	<CAE-z3OUYuAXE2+h60A=r4UyGU4CSQuF98oFgHnD7iaj-=Z=yOw@mail.gmail.com>
	<CA+XQW1hRhcxJBoOJ57YG0t5y5j1Qm3RO4wr2eXV5V-UzDaiPPw@mail.gmail.com>
	<CAE-z3OVWXN58X-+nAFTm61G1=v_1xrniyrBy8x=VRG4N149aXQ@mail.gmail.com>
	<141a0cd1-9d4f-c137-a349-17248f9cafd4@gmail.com>
	<CAE-z3OXY2YiQ5fzxZBw4FooRsUzXricHmpv_+t+HbTf0MxP0kg@mail.gmail.com>
	<CAE-z3OXLb0QOjACfvToxf9TfLJhBHiboAaieLA4V9gx6V4CjoQ@mail.gmail.com>
	<2b5567e1-2b6d-db4a-0f44-c66a24fe28ea@gmail.com>
Message-ID: <CAE-z3OWF8PabC3314Aj_9cyu+sjZnSe2N-Rfoh8T6vhPgrkn8Q@mail.gmail.com>

On Wed, May 24, 2017 at 6:32 PM, CryptAxe via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Also the block number can only change by +1 or -1, so when a new h* is
> added to the
> queue it must be compared to the most recent h* in the queue.
> std::abs(queue.back().nHeight - ToAdd.nHeight) must equal 1.
>

I think it is better to have it locked to a particular bitcoin height and
if it doesn't get included in that block, the sidechain miner can re-claim
it.

This could be taken to the extreme where the sidechain miner specifies a
particular parent of the claiming block.

The output should have a standard template, so miners can easily find bids.

The template on my previous post was:

IF
   <block height> <chain_id> <critical hash> OP_BRIBE_VERIFY
ELSE
  <public key> OP_CHECKSIG
ENDIF


If the output is spent by the miner for block <block height>, then the
sidechain miner has spent the funds.

Otherwise, the sidechain miner can use the else branch to reclaim his money.

The sidechain miner could also reclaim his money if the transaction was
included in an earlier block.  That would defeat the purpose of the bribe.
Bitcoin miners would have a (justified) incentive to not allow Bribe
outputs to be spent "early".

The bribe transactions could be created with no fees.  This would mean that
it is pointless for bitcoin miners to include them in blocks unless they
are claiming the outputs.

The relay rules would need to be modified to handle that.  Pools could
allow bids to be made directly, but that is less decentralized.

Here's what I'm testing right now as I'm working on BMM:
>
> script << OP_RETURN << CScriptNum::serialize(nSidechain) <<
> CScriptNum(nSidechainHeight) << ToByteVector(sidechain blinded block hash
> h*)
>

I don't think OP_BRIBE should care about info for the side chain.  The only
thing that is necessary is to indicate which sidechain.

You could just define the critical hash as

Hash( SideChainHeight | blinded h* )

For bribe payout release, it needs to give that particular miner an
advantage over all competitors, so their block forms the longest chain on
the sidechain (assuming their block is actually valid).

> One other thing I want to make sure is clear enough is that the block
> number in the critical hash script is
> a sidechain block number, not a mainchain block number.
>
The sidechain miner is saying that they will pay the bribe but only if
their block is included in the main chain.  The means that main chain
height is important.

They are paying for their block to be placed ahead of all competing blocks
for their chain.

It does mean that the side-chain can have at most the same number of blocks
as bitcoin.

>
> We were thinking about making bribe outputs have a maturity period like
> generated coins. You
> think that they should be locked for >100 blocks by having OP_BRIBE also
> check the lock time?
>

Well, it depends on the exact rules for OP_BRIBE.

The process I see is:

- sidechain miner submits a bribe transaction which pays to op bribe
- bitcoin miner includes that transaction in his block (or it could be
included in a previous block)
- bitcoin miner includes a claim transaction in his block

The claim transaction spends the outputs from the bribe transaction.  If
the claim transaction is block height locked, then it violates the rules
that previous soft-forks have followed.

For previous opcode changes there was a requirement that if a transaction
was accepted into block N, then it must also be acceptable in block (N+1).

The only (unavoidable) exceptions were double spends and coinbases outputs.

This means that the same protection should be added to your claim
transaction.

You could do it by requiring all outputs of the claim transaction to start
with

<100> CHECK_SEQUENCE_VERIFY DROP ...

This is only a few bytes extra at the start of the output script.

This means you can't use witness or P2SH output types for any of the
outputs, but that isn't that important.  The point of the transaction is to
make a payment.

An alternative would be to just add the rule as part of soft-fork
definition.  You could define a claim transaction as one that spends at
least one OP_BRIBE output and therefore, all its outputs have a 100 block
delay.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170525/f02cd841/attachment.html>

From da2ce7 at gmail.com  Fri May 26 06:30:08 2017
From: da2ce7 at gmail.com (Cameron Garnham)
Date: Fri, 26 May 2017 09:30:08 +0300
Subject: [bitcoin-dev] Emergency Deployment of SegWit as a partial
 mitigation of CVE-2017-9230
Message-ID: <D0299438-E848-4696-B323-8D0E810AE491@gmail.com>

Hello Bitcoin-Dev,

CVE-2017-9230 (1) (2), or commonly known as ?ASICBOOST? is a severe (3) (4) and actively exploited (5) security vulnerability.
 
To learn more about this vulnerability please read Jeremy Rubin?s detailed report:
http://www.mit.edu/~jlrubin//public/pdfs/Asicboost.pdf
 
Andreas Antonopoulos has an excellent presentation on why asicboost is dangerous:
https://www.youtube.com/watch?v=t6jJDD2Aj8k

In decisions on the #bitcoin-core-dev IRC channel; It was proposed, without negative feedback, that SegWit be used as a partial-mitigation of CVE-2017-9230.

SegWit partially mitigates asicboost with the common reasonable assumption that any block that doesn?t include a witness commit in it's coinbase transaction was mined using covert asicboost.  Making the use of covert asicboost far more conspicuous.

It was also proposed that this partial mitigation should be quickly strengthened via another soft-fork that makes the inclusion of witness commits mandatory, without negative feedback.

The security trade-offs of deploying a partial-mitigation to CVE-2017-9230 quickly vs more slowly but more conservatively is under intense debate.  The author of this post has a strong preference to the swiftest viable option.

Cameron.


(1) CVE Entry:
https://cve.mitre.org/cgi-bin/cvename.cgi?name=+CVE-2017-9230

(2) Announcement of CVE to Mailing List:
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014416.html

(3) Discussion of the perverse incentives created by 'ASICBOOST' by Ryan Grant:
 https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014352.html

(4) Discussion of ASICBOOST's non-independent PoW calculation by Tier Nolan:
 https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014351.html

(5) Evidence of Active Exploit by Gregory Maxwell:
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-April/013996.html


From da2ce7 at gmail.com  Fri May 26 08:02:27 2017
From: da2ce7 at gmail.com (Cameron Garnham)
Date: Fri, 26 May 2017 11:02:27 +0300
Subject: [bitcoin-dev] Emergency Deployment of SegWit as a partial
 mitigation of CVE-2017-9230
In-Reply-To: <CAFmyj8zNkPj3my3CLzkXdpJ1xkD0GQk8ODg09qYnnj_ONGUtsQ@mail.gmail.com>
References: <D0299438-E848-4696-B323-8D0E810AE491@gmail.com>
	<CAFmyj8zNkPj3my3CLzkXdpJ1xkD0GQk8ODg09qYnnj_ONGUtsQ@mail.gmail.com>
Message-ID: <2E6BB6FA-65FF-497F-8AEA-4CC8655BAE69@gmail.com>

Thank you for your reply Andreas,

I can assure you that I have many motivations for activating SegWit.

Before studding ASICBOOST I wanted to activate SegWit as it is a wonderful upgrade for Bitcoin. It seems to me that virtually the entire Bitcoin Ecosystem agrees with me.  Except for around 67% of the mining hash-rate who very conspicuously refuse to signal for it?s activation. 

So, I started searching for the motivations of such a large amount of the mining hash-rate holding a position that isn?t at-all represented in the wider Bitcoin Community. My study of ASICBOOST lead to a ?bingo? moment:  If one assumes that the 67% of the hash rate that refuse to signal for SegWit are using ASICBOOST. The entire picture of this political stalemate became much more understandable.

This only strengthened my resolve to activate SegWit: not only is SegWit great, it partially mitigates a very serious security vulnerability.

This is why I call into question why you would suggest:

?This proposal is unnecessarily conflating two contentious issues and will attract criticism of self serving motivation.?

1. I am not conflating the issues.  I would argue that very fact that SegWit has not been activated yet is directly because of CVE-2017-9230.
2. I have no reason to believe that SegWit is contentious, except for the attackers who it would frustrate.
3. I have no negative responses to my endeavours to get ASICBOOST as regarded as a legitimate security vulnerability.  This would suggest that it is not contentious in the wider technical community.

If SegWit is NOT contentious within the technical community and it is NOT contentious to regard CVE-2017-9230 as a credible security vulnerability. Then using it as partial security fix for a security vulnerability SHOULD NOT be contentious.

If you believe that SegWit is contentious within the technical community.  Or you believe CVE-2017-9230 should not be regarded as a credible security vulnerability. Then I would logically agree with you that we should separate the issues so that we may gain consensus. However, I just don?t see this as the case.

Cameron.


> On 26 May 2017, at 09:52 , Andreas M. Antonopoulos <andreas at antonopoulos.com> wrote:
> 
> I rarely post here, out of respect to the mailing list. But since my name was mentioned... 
> 
> I much prefer Gregory Maxwell's proposal to defuse covert ASICBOOST (only) with a segwit-like commitment to the coinbase which does not obligate miners to signal Segwit or implement Segwit, thus disarming any suspicion that the issue is being exploited only to activate Segwit.
> 
> This proposal is unnecessarily conflating two contentious issues and will attract criticism of self serving motivation.
> 
> Politicising CVE  is damaging to the long term bitcoin development and to its security. Not claiming that is the intent here, but the damage is done by the mere appearance of motive. 
> 
> 
> 
> On May 26, 2017 16:30, "Cameron Garnham via bitcoin-dev" <bitcoin-dev at lists.linuxfoundation.org> wrote:
> Hello Bitcoin-Dev,
> 
> CVE-2017-9230 (1) (2), or commonly known as ?ASICBOOST? is a severe (3) (4) and actively exploited (5) security vulnerability.
> 
> To learn more about this vulnerability please read Jeremy Rubin?s detailed report:
> http://www.mit.edu/~jlrubin//public/pdfs/Asicboost.pdf
> 
> Andreas Antonopoulos has an excellent presentation on why asicboost is dangerous:
> https://www.youtube.com/watch?v=t6jJDD2Aj8k
> 
> In decisions on the #bitcoin-core-dev IRC channel; It was proposed, without negative feedback, that SegWit be used as a partial-mitigation of CVE-2017-9230.
> 
> SegWit partially mitigates asicboost with the common reasonable assumption that any block that doesn?t include a witness commit in it's coinbase transaction was mined using covert asicboost.  Making the use of covert asicboost far more conspicuous.
> 
> It was also proposed that this partial mitigation should be quickly strengthened via another soft-fork that makes the inclusion of witness commits mandatory, without negative feedback.
> 
> The security trade-offs of deploying a partial-mitigation to CVE-2017-9230 quickly vs more slowly but more conservatively is under intense debate.  The author of this post has a strong preference to the swiftest viable option.
> 
> Cameron.
> 
> 
> (1) CVE Entry:
> https://cve.mitre.org/cgi-bin/cvename.cgi?name=+CVE-2017-9230
> 
> (2) Announcement of CVE to Mailing List:
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014416.html
> 
> (3) Discussion of the perverse incentives created by 'ASICBOOST' by Ryan Grant:
>  https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014352.html
> 
> (4) Discussion of ASICBOOST's non-independent PoW calculation by Tier Nolan:
>  https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014351.html
> 
> (5) Evidence of Active Exploit by Gregory Maxwell:
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-April/013996.html
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From andreas at antonopoulos.com  Fri May 26 06:52:26 2017
From: andreas at antonopoulos.com (Andreas M. Antonopoulos)
Date: Fri, 26 May 2017 16:52:26 +1000
Subject: [bitcoin-dev] Emergency Deployment of SegWit as a partial
 mitigation of CVE-2017-9230
In-Reply-To: <D0299438-E848-4696-B323-8D0E810AE491@gmail.com>
References: <D0299438-E848-4696-B323-8D0E810AE491@gmail.com>
Message-ID: <CAFmyj8zNkPj3my3CLzkXdpJ1xkD0GQk8ODg09qYnnj_ONGUtsQ@mail.gmail.com>

I rarely post here, out of respect to the mailing list. But since my name
was mentioned...

I much prefer Gregory Maxwell's proposal to defuse covert ASICBOOST (only)
with a segwit-like commitment to the coinbase which does not obligate
miners to signal Segwit or implement Segwit, thus disarming any suspicion
that the issue is being exploited only to activate Segwit.

This proposal is unnecessarily conflating two contentious issues and will
attract criticism of self serving motivation.

Politicising CVE  is damaging to the long term bitcoin development and to
its security. Not claiming that is the intent here, but the damage is done
by the mere appearance of motive.



On May 26, 2017 16:30, "Cameron Garnham via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hello Bitcoin-Dev,
>
> CVE-2017-9230 (1) (2), or commonly known as ?ASICBOOST? is a severe (3)
> (4) and actively exploited (5) security vulnerability.
>
> To learn more about this vulnerability please read Jeremy Rubin?s detailed
> report:
> http://www.mit.edu/~jlrubin//public/pdfs/Asicboost.pdf
>
> Andreas Antonopoulos has an excellent presentation on why asicboost is
> dangerous:
> https://www.youtube.com/watch?v=t6jJDD2Aj8k
>
> In decisions on the #bitcoin-core-dev IRC channel; It was proposed,
> without negative feedback, that SegWit be used as a partial-mitigation of
> CVE-2017-9230.
>
> SegWit partially mitigates asicboost with the common reasonable assumption
> that any block that doesn?t include a witness commit in it's coinbase
> transaction was mined using covert asicboost.  Making the use of covert
> asicboost far more conspicuous.
>
> It was also proposed that this partial mitigation should be quickly
> strengthened via another soft-fork that makes the inclusion of witness
> commits mandatory, without negative feedback.
>
> The security trade-offs of deploying a partial-mitigation to CVE-2017-9230
> quickly vs more slowly but more conservatively is under intense debate.
> The author of this post has a strong preference to the swiftest viable
> option.
>
> Cameron.
>
>
> (1) CVE Entry:
> https://cve.mitre.org/cgi-bin/cvename.cgi?name=+CVE-2017-9230
>
> (2) Announcement of CVE to Mailing List:
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> 2017-May/014416.html
>
> (3) Discussion of the perverse incentives created by 'ASICBOOST' by Ryan
> Grant:
>  https://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> 2017-May/014352.html
>
> (4) Discussion of ASICBOOST's non-independent PoW calculation by Tier
> Nolan:
>  https://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> 2017-May/014351.html
>
> (5) Evidence of Active Exploit by Gregory Maxwell:
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> 2017-April/013996.html
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170526/36b6ccb4/attachment.html>

From shaolinfry at protonmail.ch  Fri May 26 07:28:09 2017
From: shaolinfry at protonmail.ch (shaolinfry)
Date: Fri, 26 May 2017 03:28:09 -0400
Subject: [bitcoin-dev] BIP149 timeout-- why so far in the future?
In-Reply-To: <CAAS2fgQNPvEuta0KubeDetgYxGhWvdGK10jig0y4ayv0EvZPLw@mail.gmail.com>
References: <CAAS2fgQNPvEuta0KubeDetgYxGhWvdGK10jig0y4ayv0EvZPLw@mail.gmail.com>
Message-ID: <Lt8SJ3RgeodxsMVAVCQzbmruavXSCuDgYbS2hdqZ_vIVAcmvQpH0SgrhkVI51zK5YcNQIAXQD9YBVxcnpDmpGyvgkk5AsvaSrmtZl6a4_Zc=@protonmail.ch>

I agree the date can be brought forward. FWIW, I originally set the date far out enough that people wouldn't immediately fixate on the date and rather look at the meat of the proposal instead.

Given that we saw around 70% of nodes upgrade to BIP141 in around 5/6 months, I dont see any reason why we cant reduce the date to being 6 months or less from Nov. Given people are starving for segwit to the point of running BIP148, there is good evidence the community will upgrade in record time to BIP149.

Sent from [ProtonMail](https://protonmail.com), Swiss-based encrypted email.

-------- Original Message --------

Based on how fast we saw segwit adoption, why is the BIP149 timeout so
far in the future?

It seems to me that it could be six months after release and hit the
kind of density required to make a stable transition.

(If it were a different proposal and not segwit where we already have
seen what network penetration looks like-- that would be another
matter.)
_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170526/6d046307/attachment.html>

From eric at voskuil.org  Fri May 26 08:15:56 2017
From: eric at voskuil.org (Eric Voskuil)
Date: Fri, 26 May 2017 01:15:56 -0700
Subject: [bitcoin-dev] Emergency Deployment of SegWit as a partial
 mitigation of CVE-2017-9230
In-Reply-To: <2E6BB6FA-65FF-497F-8AEA-4CC8655BAE69@gmail.com>
References: <D0299438-E848-4696-B323-8D0E810AE491@gmail.com>
	<CAFmyj8zNkPj3my3CLzkXdpJ1xkD0GQk8ODg09qYnnj_ONGUtsQ@mail.gmail.com>
	<2E6BB6FA-65FF-497F-8AEA-4CC8655BAE69@gmail.com>
Message-ID: <c771e922-1121-e323-f4b8-ad99e0d930b8@voskuil.org>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Hi Cameron,

Presumably the "very serious security vulnerability" posed is one of
increased centralization of hash power. Would this danger exist
without the patent risk?

e

On 05/26/2017 01:02 AM, Cameron Garnham via bitcoin-dev wrote:
> Thank you for your reply Andreas,
> 
> I can assure you that I have many motivations for activating
> SegWit.
> 
> Before studding ASICBOOST I wanted to activate SegWit as it is a
wonderful upgrade for Bitcoin. It seems to me that virtually the
entire Bitcoin Ecosystem agrees with me.  Except for around 67% of the
mining hash-rate who very conspicuously refuse to signal for it?s
activation.
> 
> So, I started searching for the motivations of such a large amount
of the mining hash-rate holding a position that isn?t at-all
represented in the wider Bitcoin Community. My study of ASICBOOST lead
to a ?bingo? moment:  If one assumes that the 67% of the hash rate
that refuse to signal for SegWit are using ASICBOOST. The entire
picture of this political stalemate became much more understandable.
> 
> This only strengthened my resolve to activate SegWit: not only is
SegWit great, it partially mitigates a very serious security
vulnerability.
> 
> This is why I call into question why you would suggest:
> 
> ?This proposal is unnecessarily conflating two contentious issues
and will attract criticism of self serving motivation.?
> 
> 1. I am not conflating the issues.  I would argue that very fact
that SegWit has not been activated yet is directly because of
CVE-2017-9230.
> 2. I have no reason to believe that SegWit is contentious, except
for the attackers who it would frustrate.
> 3. I have no negative responses to my endeavours to get ASICBOOST
> as
regarded as a legitimate security vulnerability.  This would suggest
that it is not contentious in the wider technical community.
> 
> If SegWit is NOT contentious within the technical community and it
is NOT contentious to regard CVE-2017-9230 as a credible security
vulnerability. Then using it as partial security fix for a security
vulnerability SHOULD NOT be contentious.
> 
> If you believe that SegWit is contentious within the technical
community.  Or you believe CVE-2017-9230 should not be regarded as a
credible security vulnerability. Then I would logically agree with you
that we should separate the issues so that we may gain consensus.
However, I just don?t see this as the case.
> 
> Cameron.
> 
> 
>> On 26 May 2017, at 09:52 , Andreas M. Antonopoulos
<andreas at antonopoulos.com> wrote:
>> 
>> I rarely post here, out of respect to the mailing list. But
>> since
my name was mentioned...
>> 
>> I much prefer Gregory Maxwell's proposal to defuse covert
>> ASICBOOST
(only) with a segwit-like commitment to the coinbase which does not
obligate miners to signal Segwit or implement Segwit, thus disarming
any suspicion that the issue is being exploited only to activate Segwit.
>> 
>> This proposal is unnecessarily conflating two contentious issues
and will attract criticism of self serving motivation.
>> 
>> Politicising CVE  is damaging to the long term bitcoin
>> development
and to its security. Not claiming that is the intent here, but the
damage is done by the mere appearance of motive.
>> 
>> 
>> 
>> On May 26, 2017 16:30, "Cameron Garnham via bitcoin-dev"
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>> Hello Bitcoin-Dev,
>> 
>> CVE-2017-9230 (1) (2), or commonly known as ?ASICBOOST? is a
>> severe
(3) (4) and actively exploited (5) security vulnerability.
>> 
>> To learn more about this vulnerability please read Jeremy
>> Rubin?s
detailed report:
>> http://www.mit.edu/~jlrubin//public/pdfs/Asicboost.pdf
>> 
>> Andreas Antonopoulos has an excellent presentation on why
>> asicboost
is dangerous:
>> https://www.youtube.com/watch?v=t6jJDD2Aj8k
>> 
>> In decisions on the #bitcoin-core-dev IRC channel; It was
>> proposed,
without negative feedback, that SegWit be used as a partial-mitigation
of CVE-2017-9230.
>> 
>> SegWit partially mitigates asicboost with the common reasonable
assumption that any block that doesn?t include a witness commit in
it's coinbase transaction was mined using covert asicboost.  Making
the use of covert asicboost far more conspicuous.
>> 
>> It was also proposed that this partial mitigation should be
>> quickly
strengthened via another soft-fork that makes the inclusion of witness
commits mandatory, without negative feedback.
>> 
>> The security trade-offs of deploying a partial-mitigation to
CVE-2017-9230 quickly vs more slowly but more conservatively is under
intense debate.  The author of this post has a strong preference to
the swiftest viable option.
>> 
>> Cameron.
>> 
>> 
>> (1) CVE Entry: 
>> https://cve.mitre.org/cgi-bin/cvename.cgi?name=+CVE-2017-9230
>> 
>> (2) Announcement of CVE to Mailing List:
>> 
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014416.
html
>> 
>> (3) Discussion of the perverse incentives created by 'ASICBOOST'
>> by
Ryan Grant:
>> 
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014352.
html
>> 
>> (4) Discussion of ASICBOOST's non-independent PoW calculation by
Tier Nolan:
>> 
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014351.
html
>> 
>> (5) Evidence of Active Exploit by Gregory Maxwell:
>> 
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-April/01399
6.html


-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (GNU/Linux)

iQEcBAEBCAAGBQJZJ+Q1AAoJEDzYwH8LXOFOqakH/R1YCifIGjV07vnnsxeC/77x
d6w5tBmtEd5MLzrX/6VtMoI8UzgLEcDM1WfFox3jDVz/HurkTVorliyJrr14BVsc
rL2nTbfychYh1rAdTIsNwFt15Wgjcp/5eAq7Lw5TM5OJ3YbPn2zWJY19QmjEAJ+M
kGz26R+IJL1095yed5RN2JoN8O9x+HVdtIjaHJJRJzLsy+3g22zMWgN1nZN0olhX
mFQJZbvS0gQyiRGJmNku3zP5Qg2cFzWt+VBtFrzNu1QTTkbK2e1owHOmpgfygTD3
g3F4VoDfyA7pBnpMMMjjTaCaG34Am3CvYu8iYnZXy85s2ZjC+XeKgqMkBLj4+q8=
=A3ne
-----END PGP SIGNATURE-----

From tomz at freedommail.ch  Fri May 26 09:21:55 2017
From: tomz at freedommail.ch (Tom Zander)
Date: Fri, 26 May 2017 11:21:55 +0200
Subject: [bitcoin-dev] Emergency Deployment of SegWit as a partial
	mitigation of CVE-2017-9230
In-Reply-To: <2E6BB6FA-65FF-497F-8AEA-4CC8655BAE69@gmail.com>
References: <D0299438-E848-4696-B323-8D0E810AE491@gmail.com>
	<CAFmyj8zNkPj3my3CLzkXdpJ1xkD0GQk8ODg09qYnnj_ONGUtsQ@mail.gmail.com>
	<2E6BB6FA-65FF-497F-8AEA-4CC8655BAE69@gmail.com>
Message-ID: <2575282.hbjRTIzDqY@strawberry>

On Friday, 26 May 2017 10:02:27 CEST Cameron Garnham via bitcoin-dev wrote:
> So, I started searching for the motivations of such a large amount of the
> mining hash-rate holding a position that isn?t at-all represented in the
> wider Bitcoin Community. My study of ASICBOOST lead to a ?bingo? moment: 
> If one assumes that the 67% of the hash rate that refuse to signal for
> SegWit are using ASICBOOST. The entire picture of this political
> stalemate became much more understandable.

I?m uncomfortable with your ?bingo? moment, and your huge assumption to get 
to make it fit.
The reality is that we have seen repeatedly that the miners are stating they 
are Ok with an ASICBOOST disabling change.
The larger mining industry has just this week come to consensus about a 
better way to activate SegWit! Referring to the New York consensus meeting!!
https://medium.com/@DCGco/bitcoin-scaling-agreement-at-consensus-2017-133521fe9a77

I question your conclusions of miners not supporting SegWit because of 
ASICBOOST, the evidence shows this accusation to be false.

You openly admitting here that you use ASICBOOST as a tool to push SegWit is 
further making me uncomfortable. Your intention may be pure, but the methods 
are not.
And on that I agree with Andreas, that taints this proposal.

-- 
Tom Zander
Blog: https://zander.github.io
Vlog: https://vimeo.com/channels/tomscryptochannel

From erik at q32.com  Fri May 26 14:39:30 2017
From: erik at q32.com (Erik Aronesty)
Date: Fri, 26 May 2017 10:39:30 -0400
Subject: [bitcoin-dev] Emergency Deployment of SegWit as a partial
 mitigation of CVE-2017-9230
In-Reply-To: <2575282.hbjRTIzDqY@strawberry>
References: <D0299438-E848-4696-B323-8D0E810AE491@gmail.com>
	<CAFmyj8zNkPj3my3CLzkXdpJ1xkD0GQk8ODg09qYnnj_ONGUtsQ@mail.gmail.com>
	<2E6BB6FA-65FF-497F-8AEA-4CC8655BAE69@gmail.com>
	<2575282.hbjRTIzDqY@strawberry>
Message-ID: <CAJowKgKAN8ti8_BQj=7r=uAAegfg=0AisbhQghNA5L5t51c8PA@mail.gmail.com>

Linking a bit4 MASF with a bit4 "lock in of a hard fork in 6 months" is
something that will simply never happen for basic engineering reasons.

Spoonet, an oft-quoted hard fork that actually has some strong support, is
a much better candidate for the code base - but not of the supposed
supporters of bit4 MASF seem to be ready to roll up their sleeves and do
any work at all.   I mean, if they really had "millions" for development,
they could just hire dome developers and built it correctly, right?   But
they aren't ... instead they are pumping money into "bcoin", which doesn't
yet have any of the protections needed to get consensus.   Maybe it will
some day.

Claiming that miners support segwit is disingenuous ... considering that if
they supported it, they would be signaling for it today... instead of
distracting the community with fake proposals that have no peer-reviewed
code.


On Fri, May 26, 2017 at 5:21 AM, Tom Zander via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Friday, 26 May 2017 10:02:27 CEST Cameron Garnham via bitcoin-dev wrote:
> > So, I started searching for the motivations of such a large amount of the
> > mining hash-rate holding a position that isn?t at-all represented in the
> > wider Bitcoin Community. My study of ASICBOOST lead to a ?bingo? moment:
> > If one assumes that the 67% of the hash rate that refuse to signal for
> > SegWit are using ASICBOOST. The entire picture of this political
> > stalemate became much more understandable.
>
> I?m uncomfortable with your ?bingo? moment, and your huge assumption to get
> to make it fit.
> The reality is that we have seen repeatedly that the miners are stating
> they
> are Ok with an ASICBOOST disabling change.
> The larger mining industry has just this week come to consensus about a
> better way to activate SegWit! Referring to the New York consensus
> meeting!!
> https://medium.com/@DCGco/bitcoin-scaling-agreement-at-
> consensus-2017-133521fe9a77
>
> I question your conclusions of miners not supporting SegWit because of
> ASICBOOST, the evidence shows this accusation to be false.
>
> You openly admitting here that you use ASICBOOST as a tool to push SegWit
> is
> further making me uncomfortable. Your intention may be pure, but the
> methods
> are not.
> And on that I agree with Andreas, that taints this proposal.
>
> --
> Tom Zander
> Blog: https://zander.github.io
> Vlog: https://vimeo.com/channels/tomscryptochannel
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170526/848dfb63/attachment.html>

From tomz at freedommail.ch  Fri May 26 14:54:03 2017
From: tomz at freedommail.ch (Tom Zander)
Date: Fri, 26 May 2017 16:54:03 +0200
Subject: [bitcoin-dev] Emergency Deployment of SegWit as a partial
	mitigation of CVE-2017-9230
In-Reply-To: <CAJowKgKAN8ti8_BQj=7r=uAAegfg=0AisbhQghNA5L5t51c8PA@mail.gmail.com>
References: <D0299438-E848-4696-B323-8D0E810AE491@gmail.com>
	<2575282.hbjRTIzDqY@strawberry>
	<CAJowKgKAN8ti8_BQj=7r=uAAegfg=0AisbhQghNA5L5t51c8PA@mail.gmail.com>
Message-ID: <2558127.44xyt0tXJh@strawberry>

On Friday, 26 May 2017 16:39:30 CEST Erik Aronesty wrote:
> Linking a bit4 MASF with a bit4 "lock in of a hard fork in 6 months" is
> something that will simply never happen for basic engineering reasons.

The modifications to Bitcoin Core would take at most a day to do, plus a week 
to test.
I?m not very happy with the full compromise myself, but can we please not 
stomp on actual progress with nebulous problems?
I mean, you want SegWit, right?

> Claiming that miners support segwit is disingenuous ... considering that
> if they supported it, they would be signaling for it today... instead of
> distracting the community with fake proposals that have no peer-reviewed
> code.

The nature of a compromise like the one that happened in New York is that 
both parties do something they are not the most happy with in exchange for 
the thing they want.
Miners have agreed to the SegWit part of this compromise. Calling that 
disingenuous is not helpful...
-- 
Tom Zander
Blog: https://zander.github.io
Vlog: https://vimeo.com/channels/tomscryptochannel

From jacob.eliosoff at gmail.com  Fri May 26 17:47:11 2017
From: jacob.eliosoff at gmail.com (Jacob Eliosoff)
Date: Fri, 26 May 2017 13:47:11 -0400
Subject: [bitcoin-dev] Barry Silbert segwit agreement
Message-ID: <CAAUaCyiHUOQ-rhN5XiGyMc6ocfsNBuH_tzK_QWu7sg1=Qd-o=Q@mail.gmail.com>

Forgive me if this is a dumb question.  Suppose that rather than directly
activating segwit, the Silbert/NYC Segwit2MB proposal's lock-in just
triggered BIP141 signaling (plus later HF).  Would that avoid
incompatibility with existing BIP141 nodes, and get segwit activated
sooner?  Eg:

- Bit 4 (or bit 5 or whatever, now that BIP91 uses 4) signals support for
"segwit now, HF (TBD) at scheduled date (Nov 23?)"
- If bit 4 support reaches 80%, it locks in two things: the scheduled HF
(conditional on segwit), and *immediately* turning on bit 1 (BIP141 support)

I realize this would still leave problems like the aggressive HF schedule,
possible chain split at the HF date between Segwit2MB nodes and any
remaining BIP141 nodes, etc.  My focus here is how incompatibility with
existing nodes could be minimized.

(BIP91 could also be used if BIP141 support still fell short of 95%.  But
if Segwit2MB support reaches 80%, it seems likely that an additional 15%
will support BIP141-without-HF.)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170526/d6a31f4d/attachment.html>

From tomz at freedommail.ch  Fri May 26 18:48:32 2017
From: tomz at freedommail.ch (Tom Zander)
Date: Fri, 26 May 2017 20:48:32 +0200
Subject: [bitcoin-dev] Barry Silbert segwit agreement
In-Reply-To: <CAAUaCyiHUOQ-rhN5XiGyMc6ocfsNBuH_tzK_QWu7sg1=Qd-o=Q@mail.gmail.com>
References: <CAAUaCyiHUOQ-rhN5XiGyMc6ocfsNBuH_tzK_QWu7sg1=Qd-o=Q@mail.gmail.com>
Message-ID: <2134289.AMSES3raTP@strawberry>

On Friday, 26 May 2017 19:47:11 CEST Jacob Eliosoff via bitcoin-dev wrote:
> Forgive me if this is a dumb question.

Sorry for picking your email.

I understand people want something different for the agreement, I know I do 
too.
We have a specific agreement on the table, signed by a huge subsection of the 
industry.

Maybe the time for changing things is not to be *after* the signatures are 
set. I know I?d change some detials. But do we really want to go through 
another conference where all the important people are present to agree on a 
compromise? Or can we use the one we have?

The compromise is pretty simple;
https://medium.com/@DCGco/bitcoin-scaling-agreement-at-consensus-2017-133521fe9a77

*  Activate Segregated Witness at an 80% threshold, signaling at bit 4
*  Activate a 2 MB hard fork within six months

-- 
Tom Zander
Blog: https://zander.github.io
Vlog: https://vimeo.com/channels/tomscryptochannel

From da2ce7 at gmail.com  Fri May 26 19:20:42 2017
From: da2ce7 at gmail.com (Cameron Garnham)
Date: Fri, 26 May 2017 22:20:42 +0300
Subject: [bitcoin-dev] Emergency Deployment of SegWit as a partial
 mitigation of CVE-2017-9230
In-Reply-To: <c771e922-1121-e323-f4b8-ad99e0d930b8@voskuil.org>
References: <D0299438-E848-4696-B323-8D0E810AE491@gmail.com>
	<CAFmyj8zNkPj3my3CLzkXdpJ1xkD0GQk8ODg09qYnnj_ONGUtsQ@mail.gmail.com>
	<2E6BB6FA-65FF-497F-8AEA-4CC8655BAE69@gmail.com>
	<c771e922-1121-e323-f4b8-ad99e0d930b8@voskuil.org>
Message-ID: <7235D229-AB07-4CBE-AB69-1E6EBE0E2FDC@gmail.com>

Hello Eric,

Thank you for your question and your time off-list clarifying your position. I?m posting to the list so that a wider audience may benefit.

Original Question: ?Presumably the "very serious security vulnerability" posed is one of increased centralization of hash power. Would this danger exist without the patent risk??

I would postulate that if ASICBOOST was originally released without the patent risk, then much of the risk would have been avoided; all of the mining manufactures would have implemented ASICBOOST and had a similar advantage. However, now time has passed and the damage of the patent monopoly exploiting CVE-2017-9230 has been already done. If the ASICBOOST patent was released to the public for free today, while a good thing, it wouldn?t soften the severity of the vulnerability we face today.

The ASICBOOST PATENT provides a miner with a constant-factor advantage. This is a huge problem with zero-sum games, such as mining. In game-theory, a constant factor advantage gives an exponential advantage over the time period maintained.

This explains why the Bitcoin Community initially took very little notice to ASICBOOST: The effects of ASICBOOST stated at virtually nothing, and it took a while for the advantage to been seen over the normal variance of mining. However, it?s influence has been exponentially growing since then: creating an emergency problem that we now face.

The result of ASICBOOST going unchecked is that very quickly from now, surprisingly quickly, the only profitable miners will be the miners who make use of ASICBOOST.  This is a grave concern.

I will again reiterate that the virtue-signalling over perceived political motivations is ridiculous in the light what I consider a looming catastrophe, we should be judging by what is real not just perceived.

The catastrophe that I fear is one company (or a single politically connected group) gaining a virtual complete monopoly of Bitcoin Mining. This is more important to me than avoiding chain-splits.  Without a well-distributed set of miners Bitcoin isn?t Bitcoin.

Cameron.


PS.

This attack is part of a larger set of licensing attacks, where patens are just one form of licensing attack. These attacks are particularly damaging in competitive markets such as mining. We should be vigilant for other attempts to create state-enforced licensing around mathematical algorithms.  ASICBOOST is an illustrative example of what the Bitcoin Community needs to defend against.



> On 26 May 2017, at 11:15 , Eric Voskuil <eric at voskuil.org> wrote:
> 
> Signed PGP part
> Hi Cameron,
> 
> Presumably the "very serious security vulnerability" posed is one of
> increased centralization of hash power. Would this danger exist
> without the patent risk?
> 
> e
> 


From lf-lists at mattcorallo.com  Fri May 26 20:02:41 2017
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Fri, 26 May 2017 20:02:41 +0000
Subject: [bitcoin-dev] Barry Silbert segwit agreement
In-Reply-To: <CAAUaCyiHUOQ-rhN5XiGyMc6ocfsNBuH_tzK_QWu7sg1=Qd-o=Q@mail.gmail.com>
References: <CAAUaCyiHUOQ-rhN5XiGyMc6ocfsNBuH_tzK_QWu7sg1=Qd-o=Q@mail.gmail.com>
Message-ID: <9e2e7009-7bec-845a-bc9f-3ee03d4b4e7f@mattcorallo.com>

Your proposal seems to be simply BIP 91 tied to the
as-yet-entirely-undefined hard fork Barry et al proposed.

Using James' BIP 91 instead of the Barry-bit-4/5/whatever proposal, as
you propose, would make the deployment on the incredibly short timeline
Barry et al proposed slightly more realistic, though I would expect to
see hard fork code readily available and well-tested at this point in
order to meet that timeline.

Ultimately, due to their aggressive timeline, the Barry et al proposal
is incredibly unlikely to meet the requirements of a
multi-billion-dollar system, and continued research into meeting the
spirit, not the text, of their agreement seems warranted.

Matt

On 05/26/17 17:47, Jacob Eliosoff via bitcoin-dev wrote:
> Forgive me if this is a dumb question.  Suppose that rather than
> directly activating segwit, the Silbert/NYC Segwit2MB proposal's lock-in
> just triggered BIP141 signaling (plus later HF).  Would that avoid
> incompatibility with existing BIP141 nodes, and get segwit activated
> sooner?  Eg:
> 
> - Bit 4 (or bit 5 or whatever, now that BIP91 uses 4) signals support
> for "segwit now, HF (TBD) at scheduled date (Nov 23?)"
> - If bit 4 support reaches 80%, it locks in two things: the scheduled HF
> (conditional on segwit), and *immediately* turning on bit 1 (BIP141 support)
> 
> I realize this would still leave problems like the aggressive HF
> schedule, possible chain split at the HF date between Segwit2MB nodes
> and any remaining BIP141 nodes, etc.  My focus here is how
> incompatibility with existing nodes could be minimized.
> 
> (BIP91 could also be used if BIP141 support still fell short of 95%. 
> But if Segwit2MB support reaches 80%, it seems likely that an additional
> 15% will support BIP141-without-HF.)
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From lf-lists at mattcorallo.com  Fri May 26 20:04:58 2017
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Fri, 26 May 2017 20:04:58 +0000
Subject: [bitcoin-dev] BIP149 timeout-- why so far in the future?
In-Reply-To: <87r2ze2833.fsf@rustcorp.com.au>
References: <CAAS2fgQNPvEuta0KubeDetgYxGhWvdGK10jig0y4ayv0EvZPLw@mail.gmail.com>
	<87r2ze2833.fsf@rustcorp.com.au>
Message-ID: <63d03825-da9b-328d-56b8-0d062f3e0c62@mattcorallo.com>

A more important consideration than segwit's timeout is when code can be
released, which will no doubt be several months after SegWit's current
timeout.

Greg's proposed 6 months seems much more reasonable to me, assuming its
still many months after the formal release of code implementing it.

Matt

On 05/24/17 04:26, Rusty Russell via bitcoin-dev wrote:
> Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
> writes:
>> Based on how fast we saw segwit adoption, why is the BIP149 timeout so
>> far in the future?
>>
>> It seems to me that it could be six months after release and hit the
>> kind of density required to make a stable transition.
> 
> Agreed, I would suggest 16th December, 2017 (otherwise, it should be
> 16th January 2018; during EOY holidays seems a bad idea).
> 
> This means this whole debacle has delayed segwit exactly 1 (2) month(s)
> beyond what we'd have if it used BIP8 in the first place.
> 
> Cheers,
> Rusty.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From jacob.eliosoff at gmail.com  Fri May 26 20:10:38 2017
From: jacob.eliosoff at gmail.com (Jacob Eliosoff)
Date: Fri, 26 May 2017 16:10:38 -0400
Subject: [bitcoin-dev] Barry Silbert segwit agreement
In-Reply-To: <9e2e7009-7bec-845a-bc9f-3ee03d4b4e7f@mattcorallo.com>
References: <CAAUaCyiHUOQ-rhN5XiGyMc6ocfsNBuH_tzK_QWu7sg1=Qd-o=Q@mail.gmail.com>
	<9e2e7009-7bec-845a-bc9f-3ee03d4b4e7f@mattcorallo.com>
Message-ID: <CAAUaCyj1Yo+CpmwR40U711wknwerYeE_WkLERHuKf3uX-fcQjA@mail.gmail.com>

Just to clarify one thing, what I described differs from BIP91 in that
there's no orphaning.  Just when Segwit2MB support reaches 80%, those 80%
join everyone else in signaling for BIP141.  BIP91 orphaning is an optional
addition but my guess is it wouldn't be needed.


On May 26, 2017 4:02 PM, "Matt Corallo" <lf-lists at mattcorallo.com> wrote:

> Your proposal seems to be simply BIP 91 tied to the
> as-yet-entirely-undefined hard fork Barry et al proposed.
>
> Using James' BIP 91 instead of the Barry-bit-4/5/whatever proposal, as
> you propose, would make the deployment on the incredibly short timeline
> Barry et al proposed slightly more realistic, though I would expect to
> see hard fork code readily available and well-tested at this point in
> order to meet that timeline.
>
> Ultimately, due to their aggressive timeline, the Barry et al proposal
> is incredibly unlikely to meet the requirements of a
> multi-billion-dollar system, and continued research into meeting the
> spirit, not the text, of their agreement seems warranted.
>
> Matt
>
> On 05/26/17 17:47, Jacob Eliosoff via bitcoin-dev wrote:
> > Forgive me if this is a dumb question.  Suppose that rather than
> > directly activating segwit, the Silbert/NYC Segwit2MB proposal's lock-in
> > just triggered BIP141 signaling (plus later HF).  Would that avoid
> > incompatibility with existing BIP141 nodes, and get segwit activated
> > sooner?  Eg:
> >
> > - Bit 4 (or bit 5 or whatever, now that BIP91 uses 4) signals support
> > for "segwit now, HF (TBD) at scheduled date (Nov 23?)"
> > - If bit 4 support reaches 80%, it locks in two things: the scheduled HF
> > (conditional on segwit), and *immediately* turning on bit 1 (BIP141
> support)
> >
> > I realize this would still leave problems like the aggressive HF
> > schedule, possible chain split at the HF date between Segwit2MB nodes
> > and any remaining BIP141 nodes, etc.  My focus here is how
> > incompatibility with existing nodes could be minimized.
> >
> > (BIP91 could also be used if BIP141 support still fell short of 95%.
> > But if Segwit2MB support reaches 80%, it seems likely that an additional
> > 15% will support BIP141-without-HF.)
> >
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170526/b8000d3a/attachment.html>

From james.hilliard1 at gmail.com  Fri May 26 21:30:37 2017
From: james.hilliard1 at gmail.com (James Hilliard)
Date: Fri, 26 May 2017 17:30:37 -0400
Subject: [bitcoin-dev] Barry Silbert segwit agreement
In-Reply-To: <CAAUaCyj1Yo+CpmwR40U711wknwerYeE_WkLERHuKf3uX-fcQjA@mail.gmail.com>
References: <CAAUaCyiHUOQ-rhN5XiGyMc6ocfsNBuH_tzK_QWu7sg1=Qd-o=Q@mail.gmail.com>
	<9e2e7009-7bec-845a-bc9f-3ee03d4b4e7f@mattcorallo.com>
	<CAAUaCyj1Yo+CpmwR40U711wknwerYeE_WkLERHuKf3uX-fcQjA@mail.gmail.com>
Message-ID: <CADvTj4o2pFXZFHALfP-dJ10+AQxfFLVuohcpBn-tupf+CHRBYA@mail.gmail.com>

Mandatory signalling is the only way to lock in segwit with less than
95% hashpower without a full redeployment(which for a number of
technical reasons isn't feasible until after the existing segwit
deployment expires). There's no reason not to signal BIP141 bit 1
while also signalling bit 4, but you would want to use bit 4 to
coordinate bit 1 mandatory signalling.

It would not be feasible to schedule any HF until one can be
completely sure BIP141 is active(at least not without waiting for the
timeout and doing a redeployment) due to activation/p2p codepath
complexity. This is why the mandatory signalling period is needed.

Since it is likely a HF will take months of development and testing I
see this or something similar as the fastest safe path forward:
1. Use BIP91 or similar to activate BIP141 via mandatory signalling
ASAP(likely using bit 4)
2. Develop HF code based on assumption that BIP141 is active so that
you only have to test the BIP141->HF upgrade/activation codepath.
3. Deploy HF after BIP141 lock in(bit 4 can be reused again here since
this will be after BIP91 expiration)

When rolling out some features it often makes sense to combine them
into a single fork for example BIP's 68, 112, 113 were rolled out at
the same time as are BIP's 141, 143, 144, 145 for segwit, however a HF
has required features that would conflict with with features in the
segwit rollout which is why attempting to simultaneously deploy them
would cause major complexity/testing issues(you would have to deal
with feature conflict resolution for multiple potential activation
scenarios). By doing a staged rollout of segwit and then a HF you get
a single testable upgrade path.

Based on past development experiences I wouldn't expect a 6 month
timeline to be realistic for a properly tested HF, but this proposed
upgrade path should be the fastest available for both SegWit and a HF
regardless.

On Fri, May 26, 2017 at 4:10 PM, Jacob Eliosoff via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Just to clarify one thing, what I described differs from BIP91 in that
> there's no orphaning.  Just when Segwit2MB support reaches 80%, those 80%
> join everyone else in signaling for BIP141.  BIP91 orphaning is an optional
> addition but my guess is it wouldn't be needed.
>
>
> On May 26, 2017 4:02 PM, "Matt Corallo" <lf-lists at mattcorallo.com> wrote:
>>
>> Your proposal seems to be simply BIP 91 tied to the
>> as-yet-entirely-undefined hard fork Barry et al proposed.
>>
>> Using James' BIP 91 instead of the Barry-bit-4/5/whatever proposal, as
>> you propose, would make the deployment on the incredibly short timeline
>> Barry et al proposed slightly more realistic, though I would expect to
>> see hard fork code readily available and well-tested at this point in
>> order to meet that timeline.
>>
>> Ultimately, due to their aggressive timeline, the Barry et al proposal
>> is incredibly unlikely to meet the requirements of a
>> multi-billion-dollar system, and continued research into meeting the
>> spirit, not the text, of their agreement seems warranted.
>>
>> Matt
>>
>> On 05/26/17 17:47, Jacob Eliosoff via bitcoin-dev wrote:
>> > Forgive me if this is a dumb question.  Suppose that rather than
>> > directly activating segwit, the Silbert/NYC Segwit2MB proposal's lock-in
>> > just triggered BIP141 signaling (plus later HF).  Would that avoid
>> > incompatibility with existing BIP141 nodes, and get segwit activated
>> > sooner?  Eg:
>> >
>> > - Bit 4 (or bit 5 or whatever, now that BIP91 uses 4) signals support
>> > for "segwit now, HF (TBD) at scheduled date (Nov 23?)"
>> > - If bit 4 support reaches 80%, it locks in two things: the scheduled HF
>> > (conditional on segwit), and *immediately* turning on bit 1 (BIP141
>> > support)
>> >
>> > I realize this would still leave problems like the aggressive HF
>> > schedule, possible chain split at the HF date between Segwit2MB nodes
>> > and any remaining BIP141 nodes, etc.  My focus here is how
>> > incompatibility with existing nodes could be minimized.
>> >
>> > (BIP91 could also be used if BIP141 support still fell short of 95%.
>> > But if Segwit2MB support reaches 80%, it seems likely that an additional
>> > 15% will support BIP141-without-HF.)
>> >
>> >
>> > _______________________________________________
>> > bitcoin-dev mailing list
>> > bitcoin-dev at lists.linuxfoundation.org
>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> >
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From tomz at freedommail.ch  Fri May 26 22:12:49 2017
From: tomz at freedommail.ch (Tom Zander)
Date: Sat, 27 May 2017 00:12:49 +0200
Subject: [bitcoin-dev] Barry Silbert segwit agreement
In-Reply-To: <CADvTj4o2pFXZFHALfP-dJ10+AQxfFLVuohcpBn-tupf+CHRBYA@mail.gmail.com>
References: <CAAUaCyiHUOQ-rhN5XiGyMc6ocfsNBuH_tzK_QWu7sg1=Qd-o=Q@mail.gmail.com>
	<CAAUaCyj1Yo+CpmwR40U711wknwerYeE_WkLERHuKf3uX-fcQjA@mail.gmail.com>
	<CADvTj4o2pFXZFHALfP-dJ10+AQxfFLVuohcpBn-tupf+CHRBYA@mail.gmail.com>
Message-ID: <16817995.6UCILLkEDc@strawberry>

On Friday, 26 May 2017 23:30:37 CEST James Hilliard via bitcoin-dev wrote:
> It would not be feasible to schedule any HF until one can be
> completely sure BIP141 is active

why?

> Since it is likely a HF will take months of development and testing I
> see this or something similar as the fastest safe path forward

This should not be an issue, it started 2 years ago. Its tested.
-- 
Tom Zander
Blog: https://zander.github.io
Vlog: https://vimeo.com/channels/tomscryptochannel

From lf-lists at mattcorallo.com  Fri May 26 22:44:44 2017
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Fri, 26 May 2017 22:44:44 +0000
Subject: [bitcoin-dev] Barry Silbert segwit agreement
In-Reply-To: <CADvTj4o2pFXZFHALfP-dJ10+AQxfFLVuohcpBn-tupf+CHRBYA@mail.gmail.com>
References: <CAAUaCyiHUOQ-rhN5XiGyMc6ocfsNBuH_tzK_QWu7sg1=Qd-o=Q@mail.gmail.com>
	<9e2e7009-7bec-845a-bc9f-3ee03d4b4e7f@mattcorallo.com>
	<CAAUaCyj1Yo+CpmwR40U711wknwerYeE_WkLERHuKf3uX-fcQjA@mail.gmail.com>
	<CADvTj4o2pFXZFHALfP-dJ10+AQxfFLVuohcpBn-tupf+CHRBYA@mail.gmail.com>
Message-ID: <18D47015-A4F0-438C-8D46-812E3F20EE2B@mattcorallo.com>

While I'm not 100% convinced there are strict technical reasons for needing to wait till after segwit is active before a hard fork can be started (you can, after all, activate segwit as a part of the HF), there are useful design and conservatism reasons (not causing massive discontinuity in fee market, handling major system changes one at a time, etc).

Still, totally agree that attempting to design, code, and test a new hard fork in six months, let alone deploy it, let alone simultaneously with segwit, is a joke and fails to take seriously the investment many have made in the bitcoin system. Previous, rather simple, soft forks required similar if not more development time, not counting deployment and activation time.

If the community is unable to form consensus around segwit alone for political reasons, further research into hard fork design may help, but even forks tied together would nearly certainly need to activate months apart.

On May 26, 2017 5:30:37 PM EDT, James Hilliard <james.hilliard1 at gmail.com> wrote:
>Mandatory signalling is the only way to lock in segwit with less than
>95% hashpower without a full redeployment(which for a number of
>technical reasons isn't feasible until after the existing segwit
>deployment expires). There's no reason not to signal BIP141 bit 1
>while also signalling bit 4, but you would want to use bit 4 to
>coordinate bit 1 mandatory signalling.
>
>It would not be feasible to schedule any HF until one can be
>completely sure BIP141 is active(at least not without waiting for the
>timeout and doing a redeployment) due to activation/p2p codepath
>complexity. This is why the mandatory signalling period is needed.
>
>Since it is likely a HF will take months of development and testing I
>see this or something similar as the fastest safe path forward:
>1. Use BIP91 or similar to activate BIP141 via mandatory signalling
>ASAP(likely using bit 4)
>2. Develop HF code based on assumption that BIP141 is active so that
>you only have to test the BIP141->HF upgrade/activation codepath.
>3. Deploy HF after BIP141 lock in(bit 4 can be reused again here since
>this will be after BIP91 expiration)
>
>When rolling out some features it often makes sense to combine them
>into a single fork for example BIP's 68, 112, 113 were rolled out at
>the same time as are BIP's 141, 143, 144, 145 for segwit, however a HF
>has required features that would conflict with with features in the
>segwit rollout which is why attempting to simultaneously deploy them
>would cause major complexity/testing issues(you would have to deal
>with feature conflict resolution for multiple potential activation
>scenarios). By doing a staged rollout of segwit and then a HF you get
>a single testable upgrade path.
>
>Based on past development experiences I wouldn't expect a 6 month
>timeline to be realistic for a properly tested HF, but this proposed
>upgrade path should be the fastest available for both SegWit and a HF
>regardless.
>
>On Fri, May 26, 2017 at 4:10 PM, Jacob Eliosoff via bitcoin-dev
><bitcoin-dev at lists.linuxfoundation.org> wrote:
>> Just to clarify one thing, what I described differs from BIP91 in
>that
>> there's no orphaning.  Just when Segwit2MB support reaches 80%, those
>80%
>> join everyone else in signaling for BIP141.  BIP91 orphaning is an
>optional
>> addition but my guess is it wouldn't be needed.
>>
>>
>> On May 26, 2017 4:02 PM, "Matt Corallo" <lf-lists at mattcorallo.com>
>wrote:
>>>
>>> Your proposal seems to be simply BIP 91 tied to the
>>> as-yet-entirely-undefined hard fork Barry et al proposed.
>>>
>>> Using James' BIP 91 instead of the Barry-bit-4/5/whatever proposal,
>as
>>> you propose, would make the deployment on the incredibly short
>timeline
>>> Barry et al proposed slightly more realistic, though I would expect
>to
>>> see hard fork code readily available and well-tested at this point
>in
>>> order to meet that timeline.
>>>
>>> Ultimately, due to their aggressive timeline, the Barry et al
>proposal
>>> is incredibly unlikely to meet the requirements of a
>>> multi-billion-dollar system, and continued research into meeting the
>>> spirit, not the text, of their agreement seems warranted.
>>>
>>> Matt
>>>
>>> On 05/26/17 17:47, Jacob Eliosoff via bitcoin-dev wrote:
>>> > Forgive me if this is a dumb question.  Suppose that rather than
>>> > directly activating segwit, the Silbert/NYC Segwit2MB proposal's
>lock-in
>>> > just triggered BIP141 signaling (plus later HF).  Would that avoid
>>> > incompatibility with existing BIP141 nodes, and get segwit
>activated
>>> > sooner?  Eg:
>>> >
>>> > - Bit 4 (or bit 5 or whatever, now that BIP91 uses 4) signals
>support
>>> > for "segwit now, HF (TBD) at scheduled date (Nov 23?)"
>>> > - If bit 4 support reaches 80%, it locks in two things: the
>scheduled HF
>>> > (conditional on segwit), and *immediately* turning on bit 1
>(BIP141
>>> > support)
>>> >
>>> > I realize this would still leave problems like the aggressive HF
>>> > schedule, possible chain split at the HF date between Segwit2MB
>nodes
>>> > and any remaining BIP141 nodes, etc.  My focus here is how
>>> > incompatibility with existing nodes could be minimized.
>>> >
>>> > (BIP91 could also be used if BIP141 support still fell short of
>95%.
>>> > But if Segwit2MB support reaches 80%, it seems likely that an
>additional
>>> > 15% will support BIP141-without-HF.)
>>> >
>>> >
>>> > _______________________________________________
>>> > bitcoin-dev mailing list
>>> > bitcoin-dev at lists.linuxfoundation.org
>>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>> >
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>

From rusty at rustcorp.com.au  Sat May 27 01:19:33 2017
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Sat, 27 May 2017 10:49:33 +0930
Subject: [bitcoin-dev] BIP149 timeout-- why so far in the future?
In-Reply-To: <63d03825-da9b-328d-56b8-0d062f3e0c62@mattcorallo.com>
References: <CAAS2fgQNPvEuta0KubeDetgYxGhWvdGK10jig0y4ayv0EvZPLw@mail.gmail.com>
	<87r2ze2833.fsf@rustcorp.com.au>
	<63d03825-da9b-328d-56b8-0d062f3e0c62@mattcorallo.com>
Message-ID: <87inkn14gq.fsf@rustcorp.com.au>

Matt Corallo <lf-lists at mattcorallo.com> writes:
> A more important consideration than segwit's timeout is when code can be
> released, which will no doubt be several months after SegWit's current
> timeout.

I was assuming it would be included in the next point release.

Cheers,
Rusty.

From aj at erisian.com.au  Sat May 27 06:37:26 2017
From: aj at erisian.com.au (Anthony Towns)
Date: Sat, 27 May 2017 16:37:26 +1000
Subject: [bitcoin-dev] Emergency Deployment of SegWit as a partial
 mitigation of CVE-2017-9230
In-Reply-To: <2E6BB6FA-65FF-497F-8AEA-4CC8655BAE69@gmail.com>
References: <D0299438-E848-4696-B323-8D0E810AE491@gmail.com>
	<CAFmyj8zNkPj3my3CLzkXdpJ1xkD0GQk8ODg09qYnnj_ONGUtsQ@mail.gmail.com>
	<2E6BB6FA-65FF-497F-8AEA-4CC8655BAE69@gmail.com>
Message-ID: <20170527063726.GA12042@erisian.com.au>

On Fri, May 26, 2017 at 11:02:27AM +0300, Cameron Garnham via bitcoin-dev wrote:
> If one assumes that the 67% of the hash rate that refuse to signal
> for SegWit are using ASICBOOST. The entire picture of this political
> stalemate became much more understandable.

A couple of bits of math that might be of interest:

 * if 67% of the hash rate is running ASICBoost, and ASICBoost gives a
   20% performance improvement as stated on asicboost.com and in
   Greg's BIP proposal, then blocking ASICBoost would change the
   balance of miners from 67%/33% to 62.8%/37.2%; resulting in a 6.3%
   loss for income for ASICBoost miners (not 20%), and a 12.7% gain for
   non-ASICBoost miners.  In this case, total apparent hashrate reduces
   to 88.8% of what it originally was when ASICBoost is blocked (though
   the actual security either stays the same or increases, depending on
   your attack model) [0]

 * if ASICBoost use is lower than that, say 33% (eg made up of
   AntPool 18%, BTC.top 10%, ViaBTC 5%), then the shift is from 33%/67%
   to 29.1%/70.9%, and results in a 13% loss for ASICBoost miners,
   versus a 6% gain for non-ASICBoost miners. In these cases, a price
   rise in the region of 7% to 15% due to blocking ASICBoost would be
   enough to make everyone better off [1].

 * AIUI there are three feasible ways of doing ASICBoost: overt via
   the version field, semi-covert via mining an empty block and grinding
   the coinbase extra nonce, and fully covert by reordering the block
   transaction merkle tree. If the fully covert method is made infeasible
   via a secondary merkle commitment in the coinbase a la segwit, and for
   whatever reason overt ASICBoost isn't used, then empty block mining is
   still plausible, though presumably becomes unprofitable when the extra
   20% of block subsidy is less than the fees for a block.  That's adds
   up to fees per block totalling greater than 2.5BTC, and 2.5BTC/1MB is
   250 satoshis per byte, which actually seems to be where fees are these
   days, so unless they're getting more than the claimed 20% benefit,
   people mining empty blocks are already losing money compared to just
   mining normally... (Of course, 250 satoshis per byte is already fairly
   painful, and only gets more so as the price rises)

Personally, I expect any technical attempt to block ASICBoost use to fail
or result in a chain split -- 67% of miners losing 6% of income is on
the order of $5M a month at current prices. Having an approach that is as
simple as possible (ie, independent from segwit, carefully targetted, and
impossible to oppose for any reason other than wanting to use ASICBoost)
seems optimal to me, both in that it has the highest chance to succeed,
and provides the most conclusive information if/when it fails.

Cheers,
aj

[0] Assuming ASICBoost miners have hardware capable of doing A hashes with
    ASICBoost turned off, or A*B (B=1.2) with ASICBoost turned on, and
    the remainder of miners have a total hashrate of R. Then overall
    hashrate is currently H=A*B+R, and ASICBoost hashrate is a = A*B/(A*B+R),
    with a = 67% if the quoted claim is on the money. Rearranging:

           a = A*B/(A*B+R)
           a*(A*B+R) = A*B
           a*A*B + a*R = A*B
           a*R = (1-a)*A*B
           R = (1/a-1)*A*B

    So a' = A/(A+R), the ASICBoost miner's hashrate if they're forced to
    turn ASICBoost off, is:

           a' = A/(A+R)
           a' = A/(A+(1/a-1)*A*B)
              = 1/(1+(1/a-1)*B)

    But if a=0.67 and B=1.2, then a' = 0.628.

    The ratio of what they are getting to what they would getting is
    just a/a',

           a/a' = a*(1+(1/a-1)*B)
                = (a+(1-a)*B)

    and their loss is a/a'-1, which is:

         a/a'-1 = (a+(1-a)*B) - 1
                = (a+(1-a)*B) - (a+1-a)
                = (1-a)*(B-1)

    which is only 20% (B-1) when a is almost zero. When a increases (ie,
    there is a higher percentage of ASICBoost miners, as sure seems to
    be the case) the potential loss from disabling ASICBoost dwindles
    to nothing (because 1-a goes to zero and B-1 is just a constant).

    Note that this is the case even with mining centralisation -- if you
    have 99% of the hashrate with ASICBoost, you'll still have 98.8% of
    the hashrate without it, making a 0.2% loss (though of course your
    competitors with 1% hashrate will go to 1.2%, making a 20% gain).
    The reason is you're competing with all the ASICBoost miners,
    *including your own*, for the next block, and the size of the reward
    you'll get for winning doesn't change.

    Total apparent hashrate is A+R versus A*B+R, so

        (A+R)/(A*B+R) = 1/(A/(A+R)) * (A*B/(A*B+R))/B
                      = 1/a' * a/B
                      = a/a' / B
                      = (a+(1-a)*B) / B
                      = a/B + (1-a)

    (yeah, so that formula's kind of obvious...)

[1] Except maybe the patent holders (err, applicants). Though per the
    recent open letter it doesn't seem like anyone's actually paying for
    the patents in the first place. If miners were, then coordinated
    disarmament might already be profitable; if you're paying say 10%
    of your mining income in licensing fees or similar, that might seem
    sensible in order to make 20% more profit; but if blocking everyone
    from using ASICBoost would reduce your licensing fees by 10% of your
    income, but only reduce your income by 6.3%, then that adds up to
    a 3.7% gain and a bunch less hassle.

    I think if the ASICBoost patent holders were able to charge perfectly
    optimally, they'd charge royalty fees of about 8.3% of miner's
    income (so ASICBoost miners would make 10% net, rather than 20%),
    and allow no more than 50% of miners to use it (so the effective
    ASICBoost hashrate would be about 55%). That way the decision to
    block ASICBoost would be:

        X * 1.2 * (1-0.083) / (0.5 * 1.2 + 0.5)  -- ASICBoost allowed
      = X * 1.1004 / 1.1
      > X
    vs
        X / (0.5 + 0.5) -- ASICBoost banned
      = X

    and ASICBoost wouldn't be disabled, but the patent holders would
    still be receiving 4.15% (50%*8.3%) of all mining income. If more
    than 50% of hashpower was boosted, the formula would change to, eg,

        X * 1.2 * (1-0.083) / (0.51 * 1.2 + 0.49)
      = X * 1.1004 / 1.102
      < X

    and similarly if the fee was slightly increased, and in that case all
    miners would benefit from disabling ASICBoost. Around these figures
    ASICBoost miners would only gain/lose very slightly from ASICBoost
    getting blocked; the big losers would be the patent holders, who'd
    go from raking in 4.15% of all mining income to nothing, and the
    big winners would be the non-ASICBoost miners, who'd gain that 4.15%
    of income. The possibility of transfer payments from non-ASICBoost
    miners to ASICBoost miners to block ASICBoost might change that
    equation, probably towards lower fees and higher hashrate.

    For comparison, if 67% of hashrate is using ASICBoost, they can't
    charge them all more than 5.5% of their mining income, or miners
    would prefer to block ASICBoost, and that would only give the patent
    holders 3.7% of all mining income, much less.

    If patent holders can convince miners not to communicate with each
    other so that they think that a smaller amount of hashpower is using
    ASICBoost than actually is, that might also allow collecting more
    royalties without risking collective action to block ASICBoost.

    Of course, this is assuming they can charge all miners optimally
    and no one infringes patents, and that if you're prevented from
    using ASICBoost you don't have to keep paying royalties anyway,
    and so on. Just completely realistic, plausible assumptions like that.


From pete at petertodd.org  Sat May 27 17:41:38 2017
From: pete at petertodd.org (Peter Todd)
Date: Sat, 27 May 2017 13:41:38 -0400
Subject: [bitcoin-dev] A Method for Computing Merkle Roots of Annotated
 Binary Trees
In-Reply-To: <CAMZUoKk1fxOLgBfuxqXpxG-M5ZCPHZBb62_LZF7H4syQ-L7tCg@mail.gmail.com>
References: <CAMZUoK=f3hXHkqJBDfiLGSrgXi_ppgyH6+XWD9W54EYFWLm1+Q@mail.gmail.com>
	<20170522140548.GA17732@fedora-23-dvm>
	<CAMZUoKk1fxOLgBfuxqXpxG-M5ZCPHZBb62_LZF7H4syQ-L7tCg@mail.gmail.com>
Message-ID: <20170527174138.GA7610@fedora-23-dvm>

On Mon, May 22, 2017 at 06:32:38PM -0400, Russell O'Connor wrote:
> On May 22, 2017 23:05, "Peter Todd" <pete at petertodd.org> wrote:
> 
> On Mon, May 22, 2017 at 03:05:49AM -0400, Russell O'Connor via bitcoin-dev
> wrote:
> >     MerkleRoot := SHA256(SHA256(LeftRoot ? RightRoot))
> >     sha256Compress : Word256 ? Word512 -> Word256
> 
> To be clear, what math operations do you mean by "?" and "?"?
> 
> 
> By "?", I usually mean concatenation (though I also use it for function
> composition in one instance).   By "?", I mean the Cartesian product.

Cartesian product can mean a lot of things.

What specifically do you mean by "cartesian product" here?

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170527/37b53732/attachment.sig>

From eric at voskuil.org  Sat May 27 20:07:58 2017
From: eric at voskuil.org (Eric Voskuil)
Date: Sat, 27 May 2017 13:07:58 -0700
Subject: [bitcoin-dev] Emergency Deployment of SegWit as a partial
 mitigation of CVE-2017-9230
In-Reply-To: <20170527063726.GA12042@erisian.com.au>
References: <D0299438-E848-4696-B323-8D0E810AE491@gmail.com>
	<CAFmyj8zNkPj3my3CLzkXdpJ1xkD0GQk8ODg09qYnnj_ONGUtsQ@mail.gmail.com>
	<2E6BB6FA-65FF-497F-8AEA-4CC8655BAE69@gmail.com>
	<20170527063726.GA12042@erisian.com.au>
Message-ID: <f25dee23-4e92-d464-9fec-20d0c54c573b@voskuil.org>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Anthony,

For the sake of argument:

(1) What would the situation look like if there was no patent?

(2) Would the same essential formulation exist if there had been a
patent on bitcoin mining ASICs in general?

(3) Would an unforeseen future patented mining optimization exhibit
the same characteristics?

(4) Given that patent is a state grant of monopoly privilege, could a
state licensing regime for miners, applied in the same scope as a
patent, but absent any patent, have the same effect?

e

On 05/26/2017 11:37 PM, Anthony Towns via bitcoin-dev wrote:
> On Fri, May 26, 2017 at 11:02:27AM +0300, Cameron Garnham via
> bitcoin-dev wrote:
>> If one assumes that the 67% of the hash rate that refuse to
>> signal for SegWit are using ASICBOOST. The entire picture of this
>> political stalemate became much more understandable.
> 
> A couple of bits of math that might be of interest:
> 
> * if 67% of the hash rate is running ASICBoost, and ASICBoost gives
> a 20% performance improvement as stated on asicboost.com and in 
> Greg's BIP proposal, then blocking ASICBoost would change the 
> balance of miners from 67%/33% to 62.8%/37.2%; resulting in a 6.3% 
> loss for income for ASICBoost miners (not 20%), and a 12.7% gain
> for non-ASICBoost miners.  In this case, total apparent hashrate
> reduces to 88.8% of what it originally was when ASICBoost is
> blocked (though the actual security either stays the same or
> increases, depending on your attack model) [0]
> 
> * if ASICBoost use is lower than that, say 33% (eg made up of 
> AntPool 18%, BTC.top 10%, ViaBTC 5%), then the shift is from
> 33%/67% to 29.1%/70.9%, and results in a 13% loss for ASICBoost
> miners, versus a 6% gain for non-ASICBoost miners. In these cases,
> a price rise in the region of 7% to 15% due to blocking ASICBoost
> would be enough to make everyone better off [1].
> 
> * AIUI there are three feasible ways of doing ASICBoost: overt via 
> the version field, semi-covert via mining an empty block and
> grinding the coinbase extra nonce, and fully covert by reordering
> the block transaction merkle tree. If the fully covert method is
> made infeasible via a secondary merkle commitment in the coinbase a
> la segwit, and for whatever reason overt ASICBoost isn't used, then
> empty block mining is still plausible, though presumably becomes
> unprofitable when the extra 20% of block subsidy is less than the
> fees for a block.  That's adds up to fees per block totalling
> greater than 2.5BTC, and 2.5BTC/1MB is 250 satoshis per byte, which
> actually seems to be where fees are these days, so unless they're
> getting more than the claimed 20% benefit, people mining empty
> blocks are already losing money compared to just mining normally...
> (Of course, 250 satoshis per byte is already fairly painful, and
> only gets more so as the price rises)
> 
> Personally, I expect any technical attempt to block ASICBoost use
> to fail or result in a chain split -- 67% of miners losing 6% of
> income is on the order of $5M a month at current prices. Having an
> approach that is as simple as possible (ie, independent from
> segwit, carefully targetted, and impossible to oppose for any
> reason other than wanting to use ASICBoost) seems optimal to me,
> both in that it has the highest chance to succeed, and provides the
> most conclusive information if/when it fails.
> 
> Cheers, aj
> 
> [0] Assuming ASICBoost miners have hardware capable of doing A
> hashes with ASICBoost turned off, or A*B (B=1.2) with ASICBoost
> turned on, and the remainder of miners have a total hashrate of R.
> Then overall hashrate is currently H=A*B+R, and ASICBoost hashrate
> is a = A*B/(A*B+R), with a = 67% if the quoted claim is on the
> money. Rearranging:
> 
> a = A*B/(A*B+R) a*(A*B+R) = A*B a*A*B + a*R = A*B a*R = (1-a)*A*B R
> = (1/a-1)*A*B
> 
> So a' = A/(A+R), the ASICBoost miner's hashrate if they're forced
> to turn ASICBoost off, is:
> 
> a' = A/(A+R) a' = A/(A+(1/a-1)*A*B) = 1/(1+(1/a-1)*B)
> 
> But if a=0.67 and B=1.2, then a' = 0.628.
> 
> The ratio of what they are getting to what they would getting is 
> just a/a',
> 
> a/a' = a*(1+(1/a-1)*B) = (a+(1-a)*B)
> 
> and their loss is a/a'-1, which is:
> 
> a/a'-1 = (a+(1-a)*B) - 1 = (a+(1-a)*B) - (a+1-a) = (1-a)*(B-1)
> 
> which is only 20% (B-1) when a is almost zero. When a increases
> (ie, there is a higher percentage of ASICBoost miners, as sure
> seems to be the case) the potential loss from disabling ASICBoost
> dwindles to nothing (because 1-a goes to zero and B-1 is just a
> constant).
> 
> Note that this is the case even with mining centralisation -- if
> you have 99% of the hashrate with ASICBoost, you'll still have
> 98.8% of the hashrate without it, making a 0.2% loss (though of
> course your competitors with 1% hashrate will go to 1.2%, making a
> 20% gain). The reason is you're competing with all the ASICBoost
> miners, *including your own*, for the next block, and the size of
> the reward you'll get for winning doesn't change.
> 
> Total apparent hashrate is A+R versus A*B+R, so
> 
> (A+R)/(A*B+R) = 1/(A/(A+R)) * (A*B/(A*B+R))/B = 1/a' * a/B = a/a' /
> B = (a+(1-a)*B) / B = a/B + (1-a)
> 
> (yeah, so that formula's kind of obvious...)
> 
> [1] Except maybe the patent holders (err, applicants). Though per
> the recent open letter it doesn't seem like anyone's actually
> paying for the patents in the first place. If miners were, then
> coordinated disarmament might already be profitable; if you're
> paying say 10% of your mining income in licensing fees or similar,
> that might seem sensible in order to make 20% more profit; but if
> blocking everyone from using ASICBoost would reduce your licensing
> fees by 10% of your income, but only reduce your income by 6.3%,
> then that adds up to a 3.7% gain and a bunch less hassle.
> 
> I think if the ASICBoost patent holders were able to charge
> perfectly optimally, they'd charge royalty fees of about 8.3% of
> miner's income (so ASICBoost miners would make 10% net, rather than
> 20%), and allow no more than 50% of miners to use it (so the
> effective ASICBoost hashrate would be about 55%). That way the
> decision to block ASICBoost would be:
> 
> X * 1.2 * (1-0.083) / (0.5 * 1.2 + 0.5)  -- ASICBoost allowed = X *
> 1.1004 / 1.1
>> X
> vs X / (0.5 + 0.5) -- ASICBoost banned = X
> 
> and ASICBoost wouldn't be disabled, but the patent holders would 
> still be receiving 4.15% (50%*8.3%) of all mining income. If more 
> than 50% of hashpower was boosted, the formula would change to,
> eg,
> 
> X * 1.2 * (1-0.083) / (0.51 * 1.2 + 0.49) = X * 1.1004 / 1.102 < X
> 
> and similarly if the fee was slightly increased, and in that case
> all miners would benefit from disabling ASICBoost. Around these
> figures ASICBoost miners would only gain/lose very slightly from
> ASICBoost getting blocked; the big losers would be the patent
> holders, who'd go from raking in 4.15% of all mining income to
> nothing, and the big winners would be the non-ASICBoost miners,
> who'd gain that 4.15% of income. The possibility of transfer
> payments from non-ASICBoost miners to ASICBoost miners to block
> ASICBoost might change that equation, probably towards lower fees
> and higher hashrate.
> 
> For comparison, if 67% of hashrate is using ASICBoost, they can't 
> charge them all more than 5.5% of their mining income, or miners 
> would prefer to block ASICBoost, and that would only give the
> patent holders 3.7% of all mining income, much less.
> 
> If patent holders can convince miners not to communicate with each 
> other so that they think that a smaller amount of hashpower is
> using ASICBoost than actually is, that might also allow collecting
> more royalties without risking collective action to block
> ASICBoost.
> 
> Of course, this is assuming they can charge all miners optimally 
> and no one infringes patents, and that if you're prevented from 
> using ASICBoost you don't have to keep paying royalties anyway, and
> so on. Just completely realistic, plausible assumptions like that.
> 
> _______________________________________________ bitcoin-dev mailing
> list bitcoin-dev at lists.linuxfoundation.org 
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (GNU/Linux)

iQEcBAEBCAAGBQJZKdyaAAoJEDzYwH8LXOFO83IH/2FNwxjg1x9mlYMCLntShQZ+
2eA3M/0Hg+Zys9JfkHeRfaXr8qIC4inAJ88dDZ8EoVwKlAobmVk9iBEb/+3IS2ol
XKVSloe12AG3z0zi09bDtSu3b49Z11ZCw10uveHKbxxKqaiT1wohgX8eefHox1OJ
iGni8mGZhm3q4XTCtf5DrwTLAyplfHIeYtniXmlgkSpPjujJEB0H8viWs0QmghVc
udQqz5MfcBu1Rf9TukpT+lhOWDw189mTkomNy/npJaiJFalBIIzT6iMIU22FRS6j
xibIgdfq+3zAlZj4YAtyoIXSqdOnN2LKieY2hiLSjXwjk1xjnrqIc4ApDuW+dfk=
=NeOF
-----END PGP SIGNATURE-----

From roconnor at blockstream.io  Sat May 27 22:07:07 2017
From: roconnor at blockstream.io (Russell O'Connor)
Date: Sat, 27 May 2017 18:07:07 -0400
Subject: [bitcoin-dev] A Method for Computing Merkle Roots of Annotated
 Binary Trees
In-Reply-To: <CAMZUoKkS8azx7Gooo3D+H_gdGdTNiNtwwNVbvU0u7HzOfdUSBg@mail.gmail.com>
References: <CAMZUoK=f3hXHkqJBDfiLGSrgXi_ppgyH6+XWD9W54EYFWLm1+Q@mail.gmail.com>
	<20170522140548.GA17732@fedora-23-dvm>
	<CAMZUoKk1fxOLgBfuxqXpxG-M5ZCPHZBb62_LZF7H4syQ-L7tCg@mail.gmail.com>
	<20170527174138.GA7610@fedora-23-dvm>
	<CAMZUoKkS8azx7Gooo3D+H_gdGdTNiNtwwNVbvU0u7HzOfdUSBg@mail.gmail.com>
Message-ID: <CAMZUoKmAsxZFaLoOeAQT-YwCJBZ4z+qWJtRHPOXKTyqG7EAsfw@mail.gmail.com>

On May 28, 2017 06:09, "Russell O'Connor" <roconnor at blockstream.io> wrote:



On May 28, 2017 03:16, "Peter Todd" <pete at petertodd.org> wrote:

On Mon, May 22, 2017 at 06:32:38PM -0400, Russell O'Connor wrote:
> On May 22, 2017 23:05, "Peter Todd" <pete at petertodd.org> wrote:
>
> On Mon, May 22, 2017 at 03:05:49AM -0400, Russell O'Connor via bitcoin-dev
> wrote:
> >     MerkleRoot := SHA256(SHA256(LeftRoot ? RightRoot))
> >     sha256Compress : Word256 ? Word512 -> Word256
>
> To be clear, what math operations do you mean by "?" and "?"?
>
>
> By "?", I usually mean concatenation (though I also use it for function
> composition in one instance).   By "?", I mean the Cartesian product.

Cartesian product can mean a lot of things.

What specifically do you mean by "cartesian product" here?


Oops, I forgot to reply all.  Below is my reply.

Given two types A and B, then A ? B is the type of pairs of A and B in the
sense of type theory as used in Standard ML or Haskell or other typed
languages.


To follow up, by "sha256Compress : Word256 ? Word512 -> Word256" I mean
that sha256Compress is a function that takes two arguments, the first being
a 256 bit word and the second being a 512 bit word, and returns a 256 bit
word (or equivalently sha256Compress is a function that takes a pair as
input, the first component being a 256 bit word and the second component
being a 512 bit word, and returns a 256 bit word).

sha256Compress is meant to be the compression function defined by the
SHA256 standard, though nothing here depends on anything more that its type
signature.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170527/95aace99/attachment-0001.html>

From pete at petertodd.org  Sun May 28 08:26:24 2017
From: pete at petertodd.org (Peter Todd)
Date: Sun, 28 May 2017 04:26:24 -0400
Subject: [bitcoin-dev] A Method for Computing Merkle Roots of Annotated
 Binary Trees
In-Reply-To: <CAMZUoK=f3hXHkqJBDfiLGSrgXi_ppgyH6+XWD9W54EYFWLm1+Q@mail.gmail.com>
References: <CAMZUoK=f3hXHkqJBDfiLGSrgXi_ppgyH6+XWD9W54EYFWLm1+Q@mail.gmail.com>
Message-ID: <20170528082624.GA14552@fedora-23-dvm>

On Mon, May 22, 2017 at 03:05:49AM -0400, Russell O'Connor via bitcoin-dev wrote:
> Not all of the inputs to the SHA256 compression function are created
> equal.  Only the second argument, the chunk data, is applied to the SHA256
> expander.  `merkleRoot` is designed to ensure that the first argument of
> the SHA256 compression function is only fed some output of the SHA256
> compression function.  In fact, we can prove that the output of the
> `merkleRoot` function is always the midstate of some SHA256 hash.  To see
> this, let us explicitly separate the `sha256` function into the padding
> step, `sha256Pad`, and the recursive hashing step, `unpaddedSha256`.

This doesn't hold true in the case of pruned trees, as for the pruning to be
useful, you don't know what produced the left merkleRoot, and thus you can't
guarantee it is in fact a midstate of a genuine SHA256 hash.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170528/def153ff/attachment.sig>

From tomz at freedommail.ch  Sun May 28 20:51:46 2017
From: tomz at freedommail.ch (Tom Zander)
Date: Sun, 28 May 2017 22:51:46 +0200
Subject: [bitcoin-dev] Barry Silbert segwit agreement
In-Reply-To: <CADvTj4qdr2yGYFEWA7oVmL-KkrchYb5aQBRY9w0OK4ZVopSTSA@mail.gmail.com>
References: <CAAUaCyiHUOQ-rhN5XiGyMc6ocfsNBuH_tzK_QWu7sg1=Qd-o=Q@mail.gmail.com>
	<16817995.6UCILLkEDc@strawberry>
	<CADvTj4qdr2yGYFEWA7oVmL-KkrchYb5aQBRY9w0OK4ZVopSTSA@mail.gmail.com>
Message-ID: <1729851.ePRgbNd32q@strawberry>

On Saturday, 27 May 2017 01:09:10 CEST James Hilliard wrote:
> > why?
> 
> the main
> issue is due to 0.13.1+ having many segwit related features active
> already, including all the P2P components, the new network service
> flag, the witness-tx and block messages, compact blocks v2 and
> preferential peering. 

Hmm, the flags are identical in 0.13 and 0.14 clients.

Either way, this is rather trivial to solve. If bugs in older clients mean 
they can?t operate properly when SW is activated (via bit 4) but they don?t 
know its activated (since they only look at bit1), then just ban them when 
they misbehave.
And tell people to upgrade to a version where SegWit is less buggy.

> You would have to then have multiple activation
> codepaths to test for such as BIP141(active)->HF BIP141(inactive)->HF
> etc. By doing BIP141 first you then only have the BIP141(active)->HF
> activation codepath to test for, and you also can't be sure you can
> rely on BIP141(inactive)->HF activation codepath being the only one
> until segwit activation expires.

Heh, well, this is rather simple to solve by not having all those activation 
codepaths and just picking **one**.

You can safely replace the bit1 activation code with a bit4 activation 
logic, which is based on 80% and has no end-date.
We both know that the bip9 (bit1) based activation will not trigger before 
the expiration date anyway.

These worries are rather trivial to solve if you do a little bit of proper 
architecture of the solution.  This honestly can?t be a reason for saying NO 
to the majority of the mining hash power giving you a break and offering a 
better SegWit activation.

-- 
Tom Zander
Blog: https://zander.github.io
Vlog: https://vimeo.com/channels/tomscryptochannel

From pete at petertodd.org  Sun May 28 21:07:57 2017
From: pete at petertodd.org (Peter Todd)
Date: Sun, 28 May 2017 17:07:57 -0400
Subject: [bitcoin-dev] Drivechain -- Request for Discussion
In-Reply-To: <CA+XQW1h22jmwq+qN69UgOhE0LZqmUDpnrmF0ZM-+2ZpoPsTrwQ@mail.gmail.com>
References: <24f2b447-a237-45eb-ef9f-1a62533fad5c@gmail.com>
	<20170522133335.GA17194@fedora-23-dvm>
	<CA+XQW1h22jmwq+qN69UgOhE0LZqmUDpnrmF0ZM-+2ZpoPsTrwQ@mail.gmail.com>
Message-ID: <20170528210757.GA19450@fedora-23-dvm>

On Mon, May 22, 2017 at 05:30:46PM +0200, Paul Sztorc wrote:
> Surprisingly, this requirement (or, more precisely, this incentive) does
> not effect miners relative to each other. The incentive to upgrade is only
> for the purpose of preventing a "theft" -- defined as: an improper
> withdrawal from a sidechain. It is not about miner revenues or the ability
> to mine generally (or conduct BMM specifically). The costs of such a theft
> (decrease in market price, decrease in future transaction fee levels) would
> be shared collectively by all future miners. Therefore, it would have no
> effect on miners relative to each other.

That's not at all true. If I'm a miner with a better capability than another
miner to prevent that theft, I have reasons to induce it to happen to give me
political cover to pushing that other miner off the network.

This is a very similar problem to what we had with zeroconf double-spending,
where entities such as Coinbase tried to pay off miners to guarantee something
that wasn't possible in a geninely decrentralized system: safe zeroconf
transactions.

> Moreover, miners have other recourse if they are unable to run the node.
> They can adopt a policy of simply rejecting ("downvoting") any withdrawals
> that they don't understand. This would pause the withdraw process until
> enough miners understand enough of what is going on to proceed with it.

Why are you forcing miners to run this code at all?

Equally, you're opening up miners to huge political risks, as rejecting all
withdrawals is preventing users' from getting their money, which gives other
miners a rational for kicking those miners off of Bitcoin entirely.

> Finally, the point in dispute is a single, infrequent, true/false question.
> So miners may resort to semi-trusted methods to supplement their decision.
> In other words, they can just ask people they trust, if the withdrawal is
> correct or not. It is up to users to decide if they are comfortable with
> these risks, if/when they decide to deposit to a sidechain.

Why do you think this will be infrequent? Miners with a better ability to
validate the drivechain have every reason to make these events more frequent.

> It is a matter of comparing the costs and benefits. Ignoring theft, the
> costs are near-zero, and the benefits are >0. Specifically, they are: a
> higher BTC price and greater transaction fees. Theft is discouraged by
> attempting to tie a theft to a loss of confidence in the miners, as
> described in the spec/website.
> In general the incentives are very similar to those of Bitcoin itself.

This is also a very dubious security model - I would argue that Bitcoin is much
*more* valuable if miners do everything they can to ensure that drivechains
fail, given the huge risks involved. I would also argue that users should do
user-activated-soft-forks to ensure they fail.

By comparison, note Adam Back and my own efforts to ensure miners have a
smaller part in the ecosystem, with things like committed (encrypted)
transactions and my closed-seal-set/truth-list approach(1). We want to involve
miners as little as possible in the consensus, not more.

I have to ask: What use-cases do you actually see for drivechains? Why can't
those use-cases be done in the much safer client-side validation fashion?

1) https://petertodd.org/2016/closed-seal-sets-and-truth-lists-for-privacy

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170528/c960e00a/attachment.sig>

From james.hilliard1 at gmail.com  Sun May 28 23:28:11 2017
From: james.hilliard1 at gmail.com (James Hilliard)
Date: Sun, 28 May 2017 18:28:11 -0500
Subject: [bitcoin-dev] Barry Silbert segwit agreement
In-Reply-To: <1729851.ePRgbNd32q@strawberry>
References: <CAAUaCyiHUOQ-rhN5XiGyMc6ocfsNBuH_tzK_QWu7sg1=Qd-o=Q@mail.gmail.com>
	<16817995.6UCILLkEDc@strawberry>
	<CADvTj4qdr2yGYFEWA7oVmL-KkrchYb5aQBRY9w0OK4ZVopSTSA@mail.gmail.com>
	<1729851.ePRgbNd32q@strawberry>
Message-ID: <CADvTj4opFPA1CGaAyuy-qys4qF40ixStntNSWO9_OpbBmTE37g@mail.gmail.com>

On Sun, May 28, 2017 at 3:51 PM, Tom Zander via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> On Saturday, 27 May 2017 01:09:10 CEST James Hilliard wrote:
>> > why?
>>
>> the main
>> issue is due to 0.13.1+ having many segwit related features active
>> already, including all the P2P components, the new network service
>> flag, the witness-tx and block messages, compact blocks v2 and
>> preferential peering.
>
> Hmm, the flags are identical in 0.13 and 0.14 clients.
>
> Either way, this is rather trivial to solve. If bugs in older clients mean
> they can?t operate properly when SW is activated (via bit 4) but they don?t
> know its activated (since they only look at bit1), then just ban them when
> they misbehave.
> And tell people to upgrade to a version where SegWit is less buggy.
That would partition off those clients, which is not something we
would want to happen.
>
>> You would have to then have multiple activation
>> codepaths to test for such as BIP141(active)->HF BIP141(inactive)->HF
>> etc. By doing BIP141 first you then only have the BIP141(active)->HF
>> activation codepath to test for, and you also can't be sure you can
>> rely on BIP141(inactive)->HF activation codepath being the only one
>> until segwit activation expires.
>
> Heh, well, this is rather simple to solve by not having all those activation
> codepaths and just picking **one**.
This isn't possible until either BIP141 segwit is active or BIP141
segwit has expired.
>
> You can safely replace the bit1 activation code with a bit4 activation
> logic, which is based on 80% and has no end-date.
> We both know that the bip9 (bit1) based activation will not trigger before
> the expiration date anyway.
We don't know that since bip9 bit1 only needs 55% hashpower to be
triggered(see BIP91 activation method for how this can be done)
>
> These worries are rather trivial to solve if you do a little bit of proper
> architecture of the solution.  This honestly can?t be a reason for saying NO
> to the majority of the mining hash power giving you a break and offering a
> better SegWit activation.
BIP91 activation is clearly superior than trying to fully redeploy, it
is far simpler and can be done almost immediately with only miners
needing to upgrade.
>
> --
> Tom Zander
> Blog: https://zander.github.io
> Vlog: https://vimeo.com/channels/tomscryptochannel
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From calvinrechner at protonmail.com  Mon May 29 01:18:13 2017
From: calvinrechner at protonmail.com (CalvinRechner)
Date: Sun, 28 May 2017 21:18:13 -0400
Subject: [bitcoin-dev] Compatibility-Oriented Omnibus Proposal
Message-ID: <aC4avUiJPnHXxIxPlh4w2XA-SLB6ueTUlVTW7TreFwGV12L7L9CAGoB2E9msVYhV0M6xPTERpatAIeZO3kK-ikCRkwYQcJeEMHS7WWZKDAM=@protonmail.com>

This proposal is written under the assumption that the signatories to the Consensus 2017 Scaling Agreement[1] are genuinely committed to the terms of the agreement, and intend to enact the updates described therein. As such, criticisms pertaining to the chosen deployment timeline or hard fork upgrade path should be treated as out-of-scope during the initial discussion of this proposal.

Because it includes the activation of a hard fork for which community consensus does not yet exist, this proposal is not likely to be merged into Bitcoin Core in the immediate future, and must instead be maintained and reviewed in a separate downstream repository. However, it is written with the intent to remain cleanly compatible with future network updates and changes, to allow for the option of a straightforward upstream merge if community consensus for the proposal is successfully achieved in the following months.

<pre>
BIP: ?
Layer: Consensus
Title: Compatibility-oriented omnibus proposal
Author: Calvin Rechner <calvinrechner at protonmail.com>
Comments-Summary: No comments yet.
Comments-URI: ?
Status: Draft
Type: Standards Track
Created: 2017-05-28
License: PD
</pre>

===Abstract===

This document describes a virtuous combination of James Hilliard?s ?Reduced signalling threshold activation of existing segwit deployment?[2], Shaolin Fry?s ?Mandatory activation of segwit deployment?[3], Sergio Demian Lerner?s ?Segwit2Mb?[4] proposal, Luke Dashjr?s ?Post-segwit 2 MB block size hardfork?[5], and hard fork safety mechanisms from Johnson Lau?s ?Spoonnet?[6][7] into a single omnibus proposal and patchset.

===Motivation===

The Consensus 2017 Scaling Agreement[1] stipulated the following commitments:

? Activate Segregated Witness at an 80% threshold, signaling at bit 4
? Activate a 2 MB hard fork within six months

This proposal seeks to fulfill these criteria while retaining maximum compatibility with existing deployment approaches, thereby minimizing the risks of a destructive chain split. Additionally, subsequent indications of implied criteria and expectations of the Agreement[8][9] are satisfied.

The proposed hard fork incorporates a legacy witness discount and 2MB blocksize limit along with the enactment of Spoonnet-derived protectionary measures, to ensure the safest possible fork activation within the constraints of the requirements outlined in the Scaling Agreement.

===Rationale===

To the extent possible, this represents an effort at a best-of-all-worlds proposal, intended to provide a common foundation from which all mutually-inclusive goals can be achieved while risks are minimized.

The individual constituent proposals include the following respective rationales:

James Hilliard?s ?Reduced signalling threshold activation of existing segwit deployment?[2] explains:

> The goal here is to minimize chain split risk and network disruption while maximizing backwards compatibility and still providing for rapid activation of segwit at the 80% threshold using bit 4.

Shaolin Fry?s ?Mandatory activation of segwit deployment?[3] is included to:

> cause the existing "segwit" deployment to activate without needing to release a new deployment.

Both of the aforementioned activation options (?fast-activation? and ?flag-day activation?) serve to prevent unnecessary delays in the network upgrade process, addressing a common criticism of the Scaling Agreement and providing an opportunity for cooperation and unity instead.

Sergio Demian Lerner?s ?Segwit2Mb?[4] proposal explains the reasoning behind linking SegWit?s activation with that of a later hard fork block size increase:

> Segwit2Mb combines segwit as it is today in Bitcoin 0.14+ with a 2MB block size hard-fork activated ONLY if segwit activates (95% of miners signaling ... to re-unite the Bitcoin community and avoid a cryptocurrency split.

Luke Dashjr?s ?Post-segwit 2 MB block size hardfork?[5] suggestions are included to reduce the marginal risks that such an increase in the block size might introduce:

> if the community wishes to adopt (by unanimous consensus) a 2 MB block size hardfork, this is probably the best way to do it right now... Legacy Bitcoin transactions are given the witness discount, and a block size limit of 2 MB is imposed.

Johnson Lau?s anti-replay and network version updates[6][7] are included as general hard fork safety measures:

> In a blockchain split, however, since both forks share the same historical ledger, replay attack would be possible, unless some precautions are taken.

===Copyright===

This document is placed in the public domain.

===Specification===

###Proposal Signaling###

The string ?COOP? is included anywhere in the txn-input (scriptSig) of the coinbase-txn to signal compatibility and support.

###Soft Fork###

Fast-activation (segsignal): deployed by a "version bits" with an 80% activation threshold BIP9 with the name "segsignal" and using bit 4... [with a] start time of midnight June 1st, 2017 (epoch time 1496275200) and timeout on midnight November 15th 2017 (epoch time 1510704000). This BIP will cease to be active when segwit is locked-in.[2]

Flag-day activation (BIP148): While this BIP is active, all blocks must set the nVersion header top 3 bits to 001 together with bit field (1<<1) (according to the existing segwit deployment). Blocks that do not signal as required will be rejected... This BIP will be active between midnight August 1st 2017 (epoch time 1501545600) and midnight November 15th 2017 (epoch time 1510704000) if the existing segwit deployment is not locked-in or activated before epoch time 1501545600. This BIP will cease to be active when segwit is locked-in. While this BIP is active, all blocks must set the nVersion header top 3 bits to 001 together with bit field (1<<1) (according to the existing segwit deployment). Blocks that do not signal as required will be rejected.[3]

###Hard Fork###

The hard fork deployment is scheduled to occur 6 months after SegWit activates:

(HardForkHeight = SEGWIT_ACTIVE_BLOCK_HEIGHT + 26280)

For blocks equal to or higher than HardForkHeight, Luke-Jr?s legacy witness discount and 2MB limit are enacted, along with the following Spoonnet-based improvements[6][7]:

* A "hardfork signalling block" is a block with the sign bit of header nVersion is set [Clearly invalid for old nodes; easy opt-out for light wallets]

* If the median-time-past of the past 11 blocks is smaller than the HardForkHeight... a hardfork signalling block is invalid.

* Child of a hardfork signalling block MUST also be a hardfork signalling block

* Hardfork network version bit is 0x02000000. A tx is invalid if the highest nVersion byte is not zero, and the network version bit is not set.

===Deployment===

Deployment of the ?fast-activation? soft fork is exactly identical to Hilliard?s segsignal proposal[2]. Deployment of the ?flag-day? soft fork is exactly identical to Fry?s BIP148 proposal[3]. HardForkHeight is defined as 26280 blocks after SegWit is set to ACTIVE. All blocks with height greater than or equal to this value must adhere to the consensus rules of the 2MB hard fork.

===Backwards compatibility===

This deployment is compatible with the existing "segwit" bit 1 deployment scheduled between midnight November 15th, 2016 and midnight November 15th, 2017.

To prevent the risk of building on top of invalid blocks, miners should upgrade their nodes to support segsignal as well as BIP148.

The intent of this proposal is to maintain full legacy consensus compatibility for users up until the HardForkHeight block height, after which backwards compatibility is waived as enforcement of the hard fork consensus ruleset begins.

===References===

[1] https://medium.com/@DCGco/bitcoin-scaling-agreement-at-consensus-2017-133521fe9a77
[2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014380.html
[3] https://github.com/bitcoin/bips/blob/master/bip-0148.mediawiki
[4] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013921.html
[5] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014399.html
[6] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-February/013542.html
[7] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-January/013473.html
[8] https://twitter.com/sysmannet/status/867124645279006720
[9] https://twitter.com/JihanWu/status/867139046786465792
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170528/7696e13f/attachment-0001.html>

From earonesty at gmail.com  Mon May 29 05:54:34 2017
From: earonesty at gmail.com (Erik Aronesty)
Date: Mon, 29 May 2017 01:54:34 -0400
Subject: [bitcoin-dev] Drivechain -- Request for Discussion
In-Reply-To: <CAJowKgKFMXDE-yzEqYkY7c+80Mgn+iL9ZRNJbv9WhUBR32EvRg@mail.gmail.com>
References: <24f2b447-a237-45eb-ef9f-1a62533fad5c@gmail.com>
	<20170522133335.GA17194@fedora-23-dvm>
	<CA+XQW1h22jmwq+qN69UgOhE0LZqmUDpnrmF0ZM-+2ZpoPsTrwQ@mail.gmail.com>
	<20170528210757.GA19450@fedora-23-dvm>
	<CAJowKgJjNaoWVc=QXfOqH3OdBPoKm3qkfUNpKV6oKLSRx_fD0g@mail.gmail.com>
	<CAJowKgKFMXDE-yzEqYkY7c+80Mgn+iL9ZRNJbv9WhUBR32EvRg@mail.gmail.com>
Message-ID: <CAJowKgJDFrgvSvp8KW2oEDh+4xUTfV_HW0Ap2EHtgG7-1NY_Xg@mail.gmail.com>

Seems to me an obvious use case for drive chains are to have high speed
small transactions on a side chain, eventually cleared to the main chain.

Not sure why miners would want this to fail any more than any other side
chain, like Liquid or lightning.



On May 28, 2017 5:23 PM, "Peter Todd via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

On Mon, May 22, 2017 at 05:30:46PM +0200, Paul Sztorc wrote:
> Surprisingly, this requirement (or, more precisely, this incentive) does
> not effect miners relative to each other. The incentive to upgrade is only
> for the purpose of preventing a "theft" -- defined as: an improper
> withdrawal from a sidechain. It is not about miner revenues or the ability
> to mine generally (or conduct BMM specifically). The costs of such a theft
> (decrease in market price, decrease in future transaction fee levels)
would
> be shared collectively by all future miners. Therefore, it would have no
> effect on miners relative to each other.

That's not at all true. If I'm a miner with a better capability than another
miner to prevent that theft, I have reasons to induce it to happen to give
me
political cover to pushing that other miner off the network.

This is a very similar problem to what we had with zeroconf double-spending,
where entities such as Coinbase tried to pay off miners to guarantee
something
that wasn't possible in a geninely decrentralized system: safe zeroconf
transactions.

> Moreover, miners have other recourse if they are unable to run the node.
> They can adopt a policy of simply rejecting ("downvoting") any withdrawals
> that they don't understand. This would pause the withdraw process until
> enough miners understand enough of what is going on to proceed with it.

Why are you forcing miners to run this code at all?

Equally, you're opening up miners to huge political risks, as rejecting all
withdrawals is preventing users' from getting their money, which gives other
miners a rational for kicking those miners off of Bitcoin entirely.

> Finally, the point in dispute is a single, infrequent, true/false
question.
> So miners may resort to semi-trusted methods to supplement their decision.
> In other words, they can just ask people they trust, if the withdrawal is
> correct or not. It is up to users to decide if they are comfortable with
> these risks, if/when they decide to deposit to a sidechain.

Why do you think this will be infrequent? Miners with a better ability to
validate the drivechain have every reason to make these events more
frequent.

> It is a matter of comparing the costs and benefits. Ignoring theft, the
> costs are near-zero, and the benefits are >0. Specifically, they are: a
> higher BTC price and greater transaction fees. Theft is discouraged by
> attempting to tie a theft to a loss of confidence in the miners, as
> described in the spec/website.
> In general the incentives are very similar to those of Bitcoin itself.

This is also a very dubious security model - I would argue that Bitcoin is
much
*more* valuable if miners do everything they can to ensure that drivechains
fail, given the huge risks involved. I would also argue that users should do
user-activated-soft-forks to ensure they fail.

By comparison, note Adam Back and my own efforts to ensure miners have a
smaller part in the ecosystem, with things like committed (encrypted)
transactions and my closed-seal-set/truth-list approach(1). We want to
involve
miners as little as possible in the consensus, not more.

I have to ask: What use-cases do you actually see for drivechains? Why can't
those use-cases be done in the much safer client-side validation fashion?

1) https://petertodd.org/2016/closed-seal-sets-and-truth-lists-for-privacy

--
https://petertodd.org 'peter'[:-1]@petertodd.org

_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170529/f238957b/attachment.html>

From james.hilliard1 at gmail.com  Mon May 29 10:19:18 2017
From: james.hilliard1 at gmail.com (James Hilliard)
Date: Mon, 29 May 2017 05:19:18 -0500
Subject: [bitcoin-dev] Compatibility-Oriented Omnibus Proposal
In-Reply-To: <aC4avUiJPnHXxIxPlh4w2XA-SLB6ueTUlVTW7TreFwGV12L7L9CAGoB2E9msVYhV0M6xPTERpatAIeZO3kK-ikCRkwYQcJeEMHS7WWZKDAM=@protonmail.com>
References: <aC4avUiJPnHXxIxPlh4w2XA-SLB6ueTUlVTW7TreFwGV12L7L9CAGoB2E9msVYhV0M6xPTERpatAIeZO3kK-ikCRkwYQcJeEMHS7WWZKDAM=@protonmail.com>
Message-ID: <CADvTj4q2r7sxXfgkdXjgSD5KaEW010aLq8c3YBvqs50FM_ExGg@mail.gmail.com>

For the reasons listed
here(https://github.com/bitcoin/bips/blob/master/bip-0091.mediawiki#Motivation)
you should have it so that the HF can not lock in unless the existing
BIP141 segwit deployment is activated.

The biggest issue is that a safe HF is very unlikely to be able to be
coded and tested within 6 months.

On Sun, May 28, 2017 at 8:18 PM, CalvinRechner via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> This proposal is written under the assumption that the signatories to the
> Consensus 2017 Scaling Agreement[1] are genuinely committed to the terms of
> the agreement, and intend to enact the updates described therein. As such,
> criticisms pertaining to the chosen deployment timeline or hard fork upgrade
> path should be treated as out-of-scope during the initial discussion of this
> proposal.
>
> Because it includes the activation of a hard fork for which community
> consensus does not yet exist, this proposal is not likely to be merged into
> Bitcoin Core in the immediate future, and must instead be maintained and
> reviewed in a separate downstream repository. However, it is written with
> the intent to remain cleanly compatible with future network updates and
> changes, to allow for the option of a straightforward upstream merge if
> community consensus for the proposal is successfully achieved in the
> following months.
>
>
> <pre>
> BIP: ?
> Layer: Consensus
> Title: Compatibility-oriented omnibus proposal
> Author: Calvin Rechner <calvinrechner at protonmail.com>
> Comments-Summary: No comments yet.
> Comments-URI: ?
> Status: Draft
> Type: Standards Track
> Created: 2017-05-28
> License: PD
> </pre>
>
>
> ===Abstract===
>
> This document describes a virtuous combination of James Hilliard?s ?Reduced
> signalling threshold activation of existing segwit deployment?[2], Shaolin
> Fry?s ?Mandatory activation of segwit deployment?[3], Sergio Demian Lerner?s
> ?Segwit2Mb?[4] proposal, Luke Dashjr?s ?Post-segwit 2 MB block size
> hardfork?[5], and hard fork safety mechanisms from Johnson Lau?s
> ?Spoonnet?[6][7] into a single omnibus proposal and patchset.
>
>
> ===Motivation===
>
> The Consensus 2017 Scaling Agreement[1] stipulated the following
> commitments:
>
> ? Activate Segregated Witness at an 80% threshold, signaling at bit 4
> ? Activate a 2 MB hard fork within six months
>
> This proposal seeks to fulfill these criteria while retaining maximum
> compatibility with existing deployment approaches, thereby minimizing the
> risks of a destructive chain split. Additionally, subsequent indications of
> implied criteria and expectations of the Agreement[8][9] are satisfied.
>
> The proposed hard fork incorporates a legacy witness discount and 2MB
> blocksize limit along with the enactment of Spoonnet-derived protectionary
> measures, to ensure the safest possible fork activation within the
> constraints of the requirements outlined in the Scaling Agreement.
>
>
> ===Rationale===
>
> To the extent possible, this represents an effort at a best-of-all-worlds
> proposal, intended to provide a common foundation from which all
> mutually-inclusive goals can be achieved while risks are minimized.
>
> The individual constituent proposals include the following respective
> rationales:
>
> James Hilliard?s ?Reduced signalling threshold activation of existing segwit
> deployment?[2] explains:
>
>> The goal here is to minimize chain split risk and network disruption while
>> maximizing backwards compatibility and still providing for rapid activation
>> of segwit at the 80% threshold using bit 4.
>
> Shaolin Fry?s ?Mandatory activation of segwit deployment?[3] is included to:
>
>> cause the existing "segwit" deployment to activate without needing to
>> release a new deployment.
>
> Both of the aforementioned activation options (?fast-activation? and
> ?flag-day activation?) serve to prevent unnecessary delays in the network
> upgrade process, addressing a common criticism of the Scaling Agreement and
> providing an opportunity for cooperation and unity instead.
>
> Sergio Demian Lerner?s ?Segwit2Mb?[4] proposal explains the reasoning behind
> linking SegWit?s activation with that of a later hard fork block size
> increase:
>
>> Segwit2Mb combines segwit as it is today in Bitcoin 0.14+ with a 2MB block
>> size hard-fork activated ONLY if segwit activates (95% of miners signaling
>> ... to re-unite the Bitcoin community and avoid a cryptocurrency split.
>
> Luke Dashjr?s ?Post-segwit 2 MB block size hardfork?[5] suggestions are
> included to reduce the marginal risks that such an increase in the block
> size might introduce:
>
>> if the community wishes to adopt (by unanimous consensus) a 2 MB block
>> size hardfork, this is probably the best way to do it right now... Legacy
>> Bitcoin transactions are given the witness discount, and a block size limit
>> of 2 MB is imposed.
>
> Johnson Lau?s anti-replay and network version updates[6][7] are included as
> general hard fork safety measures:
>
>> In a blockchain split, however, since both forks share the same historical
>> ledger, replay attack would be possible, unless some precautions are taken.
>
>
> ===Copyright===
>
> This document is placed in the public domain.
>
>
> ===Specification===
>
> ###Proposal Signaling###
>
> The string ?COOP? is included anywhere in the txn-input (scriptSig) of the
> coinbase-txn to signal compatibility and support.
>
> ###Soft Fork###
>
> Fast-activation (segsignal):  deployed by a "version bits" with an 80%
> activation threshold BIP9 with the name "segsignal" and using bit 4... [with
> a] start time of midnight June 1st, 2017 (epoch time 1496275200) and timeout
> on midnight November 15th 2017 (epoch time 1510704000). This BIP will cease
> to be active when segwit is locked-in.[2]
>
> Flag-day activation (BIP148): While this BIP is active, all blocks must set
> the nVersion header top 3 bits to 001 together with bit field (1<<1)
> (according to the existing segwit deployment). Blocks that do not signal as
> required will be rejected... This BIP will be active between midnight August
> 1st 2017 (epoch time 1501545600) and midnight November 15th 2017 (epoch time
> 1510704000) if the existing segwit deployment is not locked-in or activated
> before epoch time 1501545600. This BIP will cease to be active when segwit
> is locked-in. While this BIP is active, all blocks must set the nVersion
> header top 3 bits to 001 together with bit field (1<<1) (according to the
> existing segwit deployment). Blocks that do not signal as required will be
> rejected.[3]
>
> ###Hard Fork###
>
> The hard fork deployment is scheduled to occur 6 months after SegWit
> activates:
>
> (HardForkHeight = SEGWIT_ACTIVE_BLOCK_HEIGHT + 26280)
>
> For blocks equal to or higher than HardForkHeight, Luke-Jr?s legacy witness
> discount and 2MB limit are enacted, along with the following Spoonnet-based
> improvements[6][7]:
>
> * A "hardfork signalling block" is a block with the sign bit of header
> nVersion is set [Clearly invalid for old nodes; easy opt-out for light
> wallets]
>
> * If the median-time-past of the past 11 blocks is smaller than the
> HardForkHeight... a hardfork signalling block is invalid.
>
> * Child of a hardfork signalling block MUST also be a hardfork signalling
> block
>
> * Hardfork network version bit is 0x02000000. A tx is invalid if the highest
> nVersion byte is not zero, and the network version bit is not set.
>
>
> ===Deployment===
>
> Deployment of the ?fast-activation? soft fork is exactly identical to
> Hilliard?s segsignal proposal[2]. Deployment of the ?flag-day? soft fork is
> exactly identical to Fry?s BIP148 proposal[3]. HardForkHeight is defined as
> 26280 blocks after SegWit is set to ACTIVE. All blocks with height greater
> than or equal to this value must adhere to the consensus rules of the 2MB
> hard fork.
>
>
> ===Backwards compatibility===
>
> This deployment is compatible with the existing "segwit" bit 1 deployment
> scheduled between midnight November 15th, 2016 and midnight November 15th,
> 2017.
>
> To prevent the risk of building on top of invalid blocks, miners should
> upgrade their nodes to support segsignal as well as BIP148.
>
> The intent of this proposal is to maintain full legacy consensus
> compatibility for users up until the HardForkHeight block height, after
> which backwards compatibility is waived as enforcement of the hard fork
> consensus ruleset begins.
>
>
> ===References===
>
> [1]
> https://medium.com/@DCGco/bitcoin-scaling-agreement-at-consensus-2017-133521fe9a77
> [2]
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014380.html
> [3] https://github.com/bitcoin/bips/blob/master/bip-0148.mediawiki
> [4]
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013921.html
> [5]
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014399.html
> [6]
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-February/013542.html
> [7]
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-January/013473.html
> [8] https://twitter.com/sysmannet/status/867124645279006720
> [9] https://twitter.com/JihanWu/status/867139046786465792
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From aj at erisian.com.au  Mon May 29 11:19:14 2017
From: aj at erisian.com.au (Anthony Towns)
Date: Mon, 29 May 2017 21:19:14 +1000
Subject: [bitcoin-dev] Emergency Deployment of SegWit as a partial
 mitigation of CVE-2017-9230
In-Reply-To: <f25dee23-4e92-d464-9fec-20d0c54c573b@voskuil.org>
References: <D0299438-E848-4696-B323-8D0E810AE491@gmail.com>
	<CAFmyj8zNkPj3my3CLzkXdpJ1xkD0GQk8ODg09qYnnj_ONGUtsQ@mail.gmail.com>
	<2E6BB6FA-65FF-497F-8AEA-4CC8655BAE69@gmail.com>
	<20170527063726.GA12042@erisian.com.au>
	<f25dee23-4e92-d464-9fec-20d0c54c573b@voskuil.org>
Message-ID: <20170529111914.GA21581@erisian.com.au>

On Sat, May 27, 2017 at 01:07:58PM -0700, Eric Voskuil via bitcoin-dev wrote:
> Anthony,
> For the sake of argument:

(That seems like the cue to move any further responses to bitcoin-discuss)

> (1) What would the situation look like if there was no patent?

If there were no patent, and it were easy enough to implement it, then
everyone would use it. So blocking ASICBoost would decrease everyone's
hashrate by the same amount, and you'd just have a single retarget period
with everyone earning a little less, and then everyone would be back to
making the same profit.

But even without a patent, entry costs might be high (redesigning an
ASIC, making software that shuffles transactions so you can use the
ASIC's features) and how that works out seems hard to analyse...

> (2) Would the same essential formulation exist if there had been a
> patent on bitcoin mining ASICs in general?

Not really; for the formulation to apply you'd have to have some way
to block ASIC use via consensus rules, in a way that doesn't just block
ASICs completely, but just removes their advantage, ie makes them perform
comparably to GPUs/FPGAs or whatever everyone else is using.

Reportedly, ASICBoost is an option you can turn on or off on some mining
hardware, so this seems valid (I'm assuming not using the option either
increases your electricity use by ~20% due to activating extra circuitry,
or decreases your hashrate by ~20% and maybe also decreases your
electricity use by less than that by not activating some circuitry); but
"being an ASIC" isn't something you can turn off and on in that manner.

> (3) Would an unforeseen future patented mining optimization exhibit
> the same characteristics?

Maybe? It depends on whether the optimisation's use (or lack thereof)
can be detected (enforced) via consensus rules. If you've got a patent
on a 10nm process, and you build a bitcoin ASIC with it, there's no way
to stop you via consensus rules that I can think of.

> (4) Given that patent is a state grant of monopoly privilege, could a
> state licensing regime for miners, applied in the same scope as a
> patent, but absent any patent, have the same effect?

I don't think that scenario's any different from charging miners income
tax, is it? If you don't pay the licensing fee / income tax, you get put
out of business; if you do, you have less profit. There's no way to block
either via consensus mechanisms, at least in general...

I think it's the case that any optional technology with license fees can't
be made available to all miners on equal terms, though, provided there is
any way for it to be blocked via consensus mechanisms. If it were, the
choice would be:

 my percentage of the hashrate is h (0<h, h much less than 1), total
 hashrate is 1=100%, licensing fee is uniform per hashrate, so h*X,
 advantage of using technology is a factor of r (0<r, r*h much less
 than 1)

 - technology allowed, I use it:
     I make r*h but pay X*h, so revenue is proportional to (r-X)*h
 - technology allowed, I don't use it:
     I make h, pay nothing, so revenue is proportional to h

 Provides the licensor sets X<r, of these choices I always chose to use
 the technology, and so does everyone else. So base hashrate if no one
 were to use the technology is H=1/r.

 - technology not allowed, no one uses it:
     I make h blocks, but total hashrate is 1/r, so revenue is proportional
     to h/(1/r)=rh

 But rh>(r-X)*h provided X>0, so all miners are better off if the
 technology is not allowed (because they all suffer equally in loss of
 hashrate, which is cancelled out in a retarget period; and they all
 benefit equally by not having to pay licensing fees).

Sadly, the solution to this argument is to use discriminatory terms,
either not offering the technology to everyone, or offering varying fees
for miners with different hashrates. Unless somehow it works to make it
more expensive for higher hashrate miners, this makes decentralisation
worse.

Cheers,
aj


From roconnor at blockstream.io  Mon May 29 14:55:37 2017
From: roconnor at blockstream.io (Russell O'Connor)
Date: Mon, 29 May 2017 10:55:37 -0400
Subject: [bitcoin-dev] A Method for Computing Merkle Roots of Annotated
 Binary Trees
In-Reply-To: <20170528082624.GA14552@fedora-23-dvm>
References: <CAMZUoK=f3hXHkqJBDfiLGSrgXi_ppgyH6+XWD9W54EYFWLm1+Q@mail.gmail.com>
	<20170528082624.GA14552@fedora-23-dvm>
Message-ID: <CAMZUoK=8xaVp2Qoc7kvx8FdPbpY0rEpSba8kQVRQGjX4p0haxg@mail.gmail.com>

On Sun, May 28, 2017 at 4:26 AM, Peter Todd <pete at petertodd.org> wrote:

> On Mon, May 22, 2017 at 03:05:49AM -0400, Russell O'Connor via bitcoin-dev
> wrote:
> > Not all of the inputs to the SHA256 compression function are created
> > equal.  Only the second argument, the chunk data, is applied to the
> SHA256
> > expander.  `merkleRoot` is designed to ensure that the first argument of
> > the SHA256 compression function is only fed some output of the SHA256
> > compression function.  In fact, we can prove that the output of the
> > `merkleRoot` function is always the midstate of some SHA256 hash.  To see
> > this, let us explicitly separate the `sha256` function into the padding
> > step, `sha256Pad`, and the recursive hashing step, `unpaddedSha256`.
>
> This doesn't hold true in the case of pruned trees, as for the pruning to
> be
> useful, you don't know what produced the left merkleRoot, and thus you
> can't
> guarantee it is in fact a midstate of a genuine SHA256 hash.
>

Thanks for the review Peter.  This does seem like a serious issue that I
hadn't considered yet.  As far as I understand, we have no reason to think
that the SHA-256 compression function will be secure with chosen initial
values.

Some of this proposal can be salvaged, I think, by putting the hash of the
tags into Sha256Compress's first argument:

    merkleRoot : Tree BitString -> Word256
    merkleRoot (Leaf (t))                := sha256Compress(sha256(t),
0b0^512)
    merkleRoot (Unary (t, child))        := sha256Compress(sha256(t),
merkleRoot(child) ? 0b0^256)
    merkleRoot (Binary (t, left, right)) := sha256Compress(sha256(t),
merkleRoot(left) ? merkleRoot(right))

The Merkle--Damg?rd property will still hold under the same conditions
about tags determining the type of node (Leaf, Unary, or Binary) while
avoiding the need for SHA256's padding.  If you have a small number of
tags, then you can pre-compute their hashes so that you only end up with
one call to SHA256 compress per node. If you have tags with a large amount
of data, you were going to be hashing them anyways.

Unfortunately we lose the ability to cleverly avoid collisions between the
Sha256 and MerkleRoot functions by using safe tags.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170529/8a3b421d/attachment.html>

From pete at petertodd.org  Mon May 29 16:10:59 2017
From: pete at petertodd.org (Peter Todd)
Date: Mon, 29 May 2017 12:10:59 -0400
Subject: [bitcoin-dev] A Method for Computing Merkle Roots of Annotated
 Binary Trees
In-Reply-To: <CAMZUoK=8xaVp2Qoc7kvx8FdPbpY0rEpSba8kQVRQGjX4p0haxg@mail.gmail.com>
References: <CAMZUoK=f3hXHkqJBDfiLGSrgXi_ppgyH6+XWD9W54EYFWLm1+Q@mail.gmail.com>
	<20170528082624.GA14552@fedora-23-dvm>
	<CAMZUoK=8xaVp2Qoc7kvx8FdPbpY0rEpSba8kQVRQGjX4p0haxg@mail.gmail.com>
Message-ID: <20170529161059.GA7698@fedora-23-dvm>

On Mon, May 29, 2017 at 10:55:37AM -0400, Russell O'Connor wrote:
> > This doesn't hold true in the case of pruned trees, as for the pruning to
> > be
> > useful, you don't know what produced the left merkleRoot, and thus you
> > can't
> > guarantee it is in fact a midstate of a genuine SHA256 hash.
> >
> 
> Thanks for the review Peter.  This does seem like a serious issue that I
> hadn't considered yet.  As far as I understand, we have no reason to think
> that the SHA-256 compression function will be secure with chosen initial
> values.

Well, it's an easy thing to forget, unless like me, you've written a general
purpose library to work with pruned data. :) (actually, soon to be two of
them!)

I also ran into the midstate issue with my OpenTimestamps protocol, as I was
looking into whether or not it was safe to have a SHA256 midstate commitment
operation, and couldn't find clear evidence that it was.

> Some of this proposal can be salvaged, I think, by putting the hash of the
> tags into Sha256Compress's first argument:
> 
>     merkleRoot : Tree BitString -> Word256
>     merkleRoot (Leaf (t))                := sha256Compress(sha256(t),
> 0b0^512)
>     merkleRoot (Unary (t, child))        := sha256Compress(sha256(t),
> merkleRoot(child) ? 0b0^256)
>     merkleRoot (Binary (t, left, right)) := sha256Compress(sha256(t),
> merkleRoot(left) ? merkleRoot(right))
> 
> The Merkle--Damg?rd property will still hold under the same conditions
> about tags determining the type of node (Leaf, Unary, or Binary) while
> avoiding the need for SHA256's padding.  If you have a small number of
> tags, then you can pre-compute their hashes so that you only end up with
> one call to SHA256 compress per node. If you have tags with a large amount
> of data, you were going to be hashing them anyways.

Notice how what you're proposing here is almost the same thing as using SHA256
directly, modulo the fact that you skip the final block containing the message
length.

Similarly, you don't need to compute sha256(t) - you can just as easily compute
the midstate sha256Compress(IV, t), and cache that midstate if you can reuse
tags. Again, the only difference is the last block.

> Unfortunately we lose the ability to cleverly avoid collisions between the
> Sha256 and MerkleRoot functions by using safe tags.

I think a better question to ask is why you want that property in the first
place?

My earlier python-proofmarshal(1) library had a scheme of per-use-case tags,
but I eventually realised that depending on tags being unique is a footgun. For
example, it's easy to see how two different systems could end up using the same
tag due to designers forgetting to create new tags while copying and pasting
old code. Similarly, if two such systems have to be integrated, you'll end up
with tags getting reused for two different purposes.

Now, if you design a system where that doesn't matter, then by extension it'll
also be true that collisions between the sha256 and merkleroot functions don't
matter either. And that system will be more robust to design mistakes, as tags
only need to be unique "locally" to distinguish between different sub-types in
a sum type (enum).


FWIW what I've done with my newer (and as yet unpublished) rust-proofmarshal
work is commitments are only valid for a specific type. Secondly, I use
blake2b, whose compression function processes up to 128 bytes of message on
each invocation.  That's large enough for four 32 byte hashes, which is by
itself more than sufficient for a summed merkle tree with three 32 byte hashes
(left right and sum) and a per-node-type tag.

Blake2b's documentations don't make it clear if it's resistant to collision if
the adversary can control the salt or personalization strings, so I don't
bother using them - the large block size by itself is enough to fit almost any
use-case into a single block, and it hashes blocks significantly faster than
SHA256. This also has the advantage that the actual primitive I'm using is 100%
standard blake2b, an aid to debugging and development.

1) https://github.com/proofchains/python-proofmarshal

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170529/22b1b0f7/attachment.sig>

From earonesty at gmail.com  Mon May 29 22:52:36 2017
From: earonesty at gmail.com (Erik Aronesty)
Date: Mon, 29 May 2017 18:52:36 -0400
Subject: [bitcoin-dev] Compatibility-Oriented Omnibus Proposal
In-Reply-To: <CADvTj4q2r7sxXfgkdXjgSD5KaEW010aLq8c3YBvqs50FM_ExGg@mail.gmail.com>
References: <aC4avUiJPnHXxIxPlh4w2XA-SLB6ueTUlVTW7TreFwGV12L7L9CAGoB2E9msVYhV0M6xPTERpatAIeZO3kK-ikCRkwYQcJeEMHS7WWZKDAM=@protonmail.com>
	<CADvTj4q2r7sxXfgkdXjgSD5KaEW010aLq8c3YBvqs50FM_ExGg@mail.gmail.com>
Message-ID: <CAJowKgJxCZruMKVESTbguWHDx5Y+KqJKUYDbiv+ZU_SvPdE3Ow@mail.gmail.com>

I can't think of any resistance to this, but the code, on a tight timeline,
isn't going to be easy.   Is anyone volunteering for this?

On May 29, 2017 6:19 AM, "James Hilliard via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> For the reasons listed
> here(https://github.com/bitcoin/bips/blob/master/bip-
> 0091.mediawiki#Motivation)
> you should have it so that the HF can not lock in unless the existing
> BIP141 segwit deployment is activated.
>
> The biggest issue is that a safe HF is very unlikely to be able to be
> coded and tested within 6 months.
>
> On Sun, May 28, 2017 at 8:18 PM, CalvinRechner via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > This proposal is written under the assumption that the signatories to the
> > Consensus 2017 Scaling Agreement[1] are genuinely committed to the terms
> of
> > the agreement, and intend to enact the updates described therein. As
> such,
> > criticisms pertaining to the chosen deployment timeline or hard fork
> upgrade
> > path should be treated as out-of-scope during the initial discussion of
> this
> > proposal.
> >
> > Because it includes the activation of a hard fork for which community
> > consensus does not yet exist, this proposal is not likely to be merged
> into
> > Bitcoin Core in the immediate future, and must instead be maintained and
> > reviewed in a separate downstream repository. However, it is written with
> > the intent to remain cleanly compatible with future network updates and
> > changes, to allow for the option of a straightforward upstream merge if
> > community consensus for the proposal is successfully achieved in the
> > following months.
> >
> >
> > <pre>
> > BIP: ?
> > Layer: Consensus
> > Title: Compatibility-oriented omnibus proposal
> > Author: Calvin Rechner <calvinrechner at protonmail.com>
> > Comments-Summary: No comments yet.
> > Comments-URI: ?
> > Status: Draft
> > Type: Standards Track
> > Created: 2017-05-28
> > License: PD
> > </pre>
> >
> >
> > ===Abstract===
> >
> > This document describes a virtuous combination of James Hilliard?s
> ?Reduced
> > signalling threshold activation of existing segwit deployment?[2],
> Shaolin
> > Fry?s ?Mandatory activation of segwit deployment?[3], Sergio Demian
> Lerner?s
> > ?Segwit2Mb?[4] proposal, Luke Dashjr?s ?Post-segwit 2 MB block size
> > hardfork?[5], and hard fork safety mechanisms from Johnson Lau?s
> > ?Spoonnet?[6][7] into a single omnibus proposal and patchset.
> >
> >
> > ===Motivation===
> >
> > The Consensus 2017 Scaling Agreement[1] stipulated the following
> > commitments:
> >
> > ? Activate Segregated Witness at an 80% threshold, signaling at bit 4
> > ? Activate a 2 MB hard fork within six months
> >
> > This proposal seeks to fulfill these criteria while retaining maximum
> > compatibility with existing deployment approaches, thereby minimizing the
> > risks of a destructive chain split. Additionally, subsequent indications
> of
> > implied criteria and expectations of the Agreement[8][9] are satisfied.
> >
> > The proposed hard fork incorporates a legacy witness discount and 2MB
> > blocksize limit along with the enactment of Spoonnet-derived
> protectionary
> > measures, to ensure the safest possible fork activation within the
> > constraints of the requirements outlined in the Scaling Agreement.
> >
> >
> > ===Rationale===
> >
> > To the extent possible, this represents an effort at a best-of-all-worlds
> > proposal, intended to provide a common foundation from which all
> > mutually-inclusive goals can be achieved while risks are minimized.
> >
> > The individual constituent proposals include the following respective
> > rationales:
> >
> > James Hilliard?s ?Reduced signalling threshold activation of existing
> segwit
> > deployment?[2] explains:
> >
> >> The goal here is to minimize chain split risk and network disruption
> while
> >> maximizing backwards compatibility and still providing for rapid
> activation
> >> of segwit at the 80% threshold using bit 4.
> >
> > Shaolin Fry?s ?Mandatory activation of segwit deployment?[3] is included
> to:
> >
> >> cause the existing "segwit" deployment to activate without needing to
> >> release a new deployment.
> >
> > Both of the aforementioned activation options (?fast-activation? and
> > ?flag-day activation?) serve to prevent unnecessary delays in the network
> > upgrade process, addressing a common criticism of the Scaling Agreement
> and
> > providing an opportunity for cooperation and unity instead.
> >
> > Sergio Demian Lerner?s ?Segwit2Mb?[4] proposal explains the reasoning
> behind
> > linking SegWit?s activation with that of a later hard fork block size
> > increase:
> >
> >> Segwit2Mb combines segwit as it is today in Bitcoin 0.14+ with a 2MB
> block
> >> size hard-fork activated ONLY if segwit activates (95% of miners
> signaling
> >> ... to re-unite the Bitcoin community and avoid a cryptocurrency split.
> >
> > Luke Dashjr?s ?Post-segwit 2 MB block size hardfork?[5] suggestions are
> > included to reduce the marginal risks that such an increase in the block
> > size might introduce:
> >
> >> if the community wishes to adopt (by unanimous consensus) a 2 MB block
> >> size hardfork, this is probably the best way to do it right now...
> Legacy
> >> Bitcoin transactions are given the witness discount, and a block size
> limit
> >> of 2 MB is imposed.
> >
> > Johnson Lau?s anti-replay and network version updates[6][7] are included
> as
> > general hard fork safety measures:
> >
> >> In a blockchain split, however, since both forks share the same
> historical
> >> ledger, replay attack would be possible, unless some precautions are
> taken.
> >
> >
> > ===Copyright===
> >
> > This document is placed in the public domain.
> >
> >
> > ===Specification===
> >
> > ###Proposal Signaling###
> >
> > The string ?COOP? is included anywhere in the txn-input (scriptSig) of
> the
> > coinbase-txn to signal compatibility and support.
> >
> > ###Soft Fork###
> >
> > Fast-activation (segsignal):  deployed by a "version bits" with an 80%
> > activation threshold BIP9 with the name "segsignal" and using bit 4...
> [with
> > a] start time of midnight June 1st, 2017 (epoch time 1496275200) and
> timeout
> > on midnight November 15th 2017 (epoch time 1510704000). This BIP will
> cease
> > to be active when segwit is locked-in.[2]
> >
> > Flag-day activation (BIP148): While this BIP is active, all blocks must
> set
> > the nVersion header top 3 bits to 001 together with bit field (1<<1)
> > (according to the existing segwit deployment). Blocks that do not signal
> as
> > required will be rejected... This BIP will be active between midnight
> August
> > 1st 2017 (epoch time 1501545600) and midnight November 15th 2017 (epoch
> time
> > 1510704000) if the existing segwit deployment is not locked-in or
> activated
> > before epoch time 1501545600. This BIP will cease to be active when
> segwit
> > is locked-in. While this BIP is active, all blocks must set the nVersion
> > header top 3 bits to 001 together with bit field (1<<1) (according to the
> > existing segwit deployment). Blocks that do not signal as required will
> be
> > rejected.[3]
> >
> > ###Hard Fork###
> >
> > The hard fork deployment is scheduled to occur 6 months after SegWit
> > activates:
> >
> > (HardForkHeight = SEGWIT_ACTIVE_BLOCK_HEIGHT + 26280)
> >
> > For blocks equal to or higher than HardForkHeight, Luke-Jr?s legacy
> witness
> > discount and 2MB limit are enacted, along with the following
> Spoonnet-based
> > improvements[6][7]:
> >
> > * A "hardfork signalling block" is a block with the sign bit of header
> > nVersion is set [Clearly invalid for old nodes; easy opt-out for light
> > wallets]
> >
> > * If the median-time-past of the past 11 blocks is smaller than the
> > HardForkHeight... a hardfork signalling block is invalid.
> >
> > * Child of a hardfork signalling block MUST also be a hardfork signalling
> > block
> >
> > * Hardfork network version bit is 0x02000000. A tx is invalid if the
> highest
> > nVersion byte is not zero, and the network version bit is not set.
> >
> >
> > ===Deployment===
> >
> > Deployment of the ?fast-activation? soft fork is exactly identical to
> > Hilliard?s segsignal proposal[2]. Deployment of the ?flag-day? soft fork
> is
> > exactly identical to Fry?s BIP148 proposal[3]. HardForkHeight is defined
> as
> > 26280 blocks after SegWit is set to ACTIVE. All blocks with height
> greater
> > than or equal to this value must adhere to the consensus rules of the 2MB
> > hard fork.
> >
> >
> > ===Backwards compatibility===
> >
> > This deployment is compatible with the existing "segwit" bit 1 deployment
> > scheduled between midnight November 15th, 2016 and midnight November
> 15th,
> > 2017.
> >
> > To prevent the risk of building on top of invalid blocks, miners should
> > upgrade their nodes to support segsignal as well as BIP148.
> >
> > The intent of this proposal is to maintain full legacy consensus
> > compatibility for users up until the HardForkHeight block height, after
> > which backwards compatibility is waived as enforcement of the hard fork
> > consensus ruleset begins.
> >
> >
> > ===References===
> >
> > [1]
> > https://medium.com/@DCGco/bitcoin-scaling-agreement-at-
> consensus-2017-133521fe9a77
> > [2]
> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> 2017-May/014380.html
> > [3] https://github.com/bitcoin/bips/blob/master/bip-0148.mediawiki
> > [4]
> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> 2017-March/013921.html
> > [5]
> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> 2017-May/014399.html
> > [6]
> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> 2017-February/013542.html
> > [7]
> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> 2017-January/013473.html
> > [8] https://twitter.com/sysmannet/status/867124645279006720
> > [9] https://twitter.com/JihanWu/status/867139046786465792
> >
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170529/7373974e/attachment-0001.html>

From opetruzel at gmail.com  Mon May 29 23:49:59 2017
From: opetruzel at gmail.com (Oliver Petruzel)
Date: Mon, 29 May 2017 19:49:59 -0400
Subject: [bitcoin-dev] Compatibility-Oriented Omnibus Proposal
In-Reply-To: <aC4avUiJPnHXxIxPlh4w2XA-SLB6ueTUlVTW7TreFwGV12L7L9CAGoB2E9msVYhV0M6xPTERpatAIeZO3kK-ikCRkwYQcJeEMHS7WWZKDAM=@protonmail.com>
References: <aC4avUiJPnHXxIxPlh4w2XA-SLB6ueTUlVTW7TreFwGV12L7L9CAGoB2E9msVYhV0M6xPTERpatAIeZO3kK-ikCRkwYQcJeEMHS7WWZKDAM=@protonmail.com>
Message-ID: <CALhpmH3sUxa=MYtCdNMGO3AMGgmT=Tc2kcJzzpoY84syjgtP_A@mail.gmail.com>

>>if the community wishes to adopt (by unanimous consensus) a 2 MB block
size hardfork, this is probably the best way to do it right now... Legacy
Bitcoin transactions are given the witness discount, and a block size limit
of 2 MB is imposed.<<


The above decision may quickly become very controversial. I don't think it's
what most users had/have in mind when they discuss a "2MB+SegWit" solution.

With the current 1MB+SegWit, testing has shown us that normal usage results
in ~2 or 2.1MB blocks.

I think most users will expect a linear increase when Base Size is
increased to 2000000 bytes and Total Weight is increased to 8000000 bytes.
With normal usage, the expected results would then be ~4 or 4.2MB blocks.

Am I missing something here, or does Luke's suggested 2MB cap completely
nullify that expected linear increase? If so, why? What's the logic behind
this decision?

I'd love to be armed with a good answer should my colleagues ask me the
same obvious question, so thank you ahead of time!

Respectfully,
Oliver Petruzel
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170529/069bfb26/attachment.html>

From truthcoin at gmail.com  Tue May 30 05:11:51 2017
From: truthcoin at gmail.com (Paul Sztorc)
Date: Tue, 30 May 2017 01:11:51 -0400
Subject: [bitcoin-dev] Drivechain -- Request for Discussion
In-Reply-To: <20170528210757.GA19450@fedora-23-dvm>
References: <24f2b447-a237-45eb-ef9f-1a62533fad5c@gmail.com>
	<20170522133335.GA17194@fedora-23-dvm>
	<CA+XQW1h22jmwq+qN69UgOhE0LZqmUDpnrmF0ZM-+2ZpoPsTrwQ@mail.gmail.com>
	<20170528210757.GA19450@fedora-23-dvm>
Message-ID: <b04f8c13-9358-303d-2335-f509cafb90a5@gmail.com>

Hi Peter,

Responses below.

On 5/28/2017 5:07 PM, Peter Todd wrote:
> On Mon, May 22, 2017 at 05:30:46PM +0200, Paul Sztorc wrote:
>> Surprisingly, this requirement (or, more precisely, this incentive) does
>> not effect miners relative to each other. The incentive to upgrade is only
>> for the purpose of preventing a "theft" -- defined as: an improper
>> withdrawal from a sidechain. It is not about miner revenues or the ability
>> to mine generally (or conduct BMM specifically). The costs of such a theft
>> (decrease in market price, decrease in future transaction fee levels) would
>> be shared collectively by all future miners. Therefore, it would have no
>> effect on miners relative to each other.
> 
> That's not at all true. If I'm a miner with a better capability than another
> miner to prevent that theft, I have reasons to induce it to happen to give me
> political cover to pushing that other miner off the network.

Miners can abstain from 'voting', which is politically neutral. Or, if
they wish, smaller miners could acquiesce to the coercion and just copy
the votes of the attacking 51% group. For users who are only running
Bitcoin Core, there is nothing bad about that.

As you say, a 51% group can arbitrarily start orphaning the blocks that
are mined by non-member rivals. This _may_ be a problem, or it may not,
but it is not exacerbated by drivechain.

So, what exactly is "not at all true"?


> 
> This is a very similar problem to what we had with zeroconf double-spending,
> where entities such as Coinbase tried to pay off miners to guarantee something
> that wasn't possible in a geninely decrentralized system: safe zeroconf
> transactions.

I don't see what you mean here. You can't stop Coinbase from donating
BTC to a subset of miners. That will always be possible, and it has
nothing to do with drivechain (as I see it).


> 
>> Moreover, miners have other recourse if they are unable to run the node.
>> They can adopt a policy of simply rejecting ("downvoting") any withdrawals
>> that they don't understand. This would pause the withdraw process until
>> enough miners understand enough of what is going on to proceed with it.
> 
> Why are you forcing miners to run this code at all?

Could we not say the same thing about the code behind CLTV?

The nature of a contract, is that people are happier to be bound by some
rules that they themselves construct (for example, a nuclear
non-proliferation treaty).

In this case, miners prefer sidechains to exist (as existence makes the
BTC they mine more valuable, and provides additional tx fee revenues),
and so they would like to run code which makes them possible.


> 
> Equally, you're opening up miners to huge political risks, as rejecting all
> withdrawals is preventing users' from getting their money, which gives other
> miners a rational for kicking those miners off of Bitcoin entirely.

As I explained above, miners can abstain from voting, which is
politically neutral, or else they can delegate their vote to an
aggressive miner. The "51% can orphan" concern could be raised, even in
a world without drivechain. All that is required, is for the miners to
be anonymous, or in private 'dark' pools (and to thereby escape censure).

But there is a much bigger issue here, which is that our threat models
are different.

As you may know, my threat model [1] does not include miners "pushing
each other off". It only cares about the miner-experience, to the extent
that it impacts the user-experience.

Moreover, I reject [2] the premise that we can even measure "miner
centralization", or even that such a concept exists. If someone has a
definition of this concept, which is both measurable and useful, I would
be interested to read it.

( For what it's worth, Satoshi did not care about this, either. For
example: "If a greedy attacker is able to assemble more CPU power than
all the honest nodes, he...ought to find it more profitable to play by
the rules." which implies robustness to 51% owned by one entity. )

[1] http://www.truthcoin.info/blog/mining-threat-equilibrium/
[2] http://www.truthcoin.info/blog/mirage-miner-centralization/


> 
>> Finally, the point in dispute is a single, infrequent, true/false question.
>> So miners may resort to semi-trusted methods to supplement their decision.
>> In other words, they can just ask people they trust, if the withdrawal is
>> correct or not. It is up to users to decide if they are comfortable with
>> these risks, if/when they decide to deposit to a sidechain.
> 
> Why do you think this will be infrequent? Miners with a better ability to
> validate the drivechain have every reason to make these events more frequent.

It is part of the spec. These timing parameters must be agreed upon when
the sidechain is added, ie _before_ users deposit to the sidechain. Once
the sidechain is created, the timing is enforced by nodes, the same as
with any other protocol rules. Miner-validation-ability has no effect on
the frequency.


> 
>> It is a matter of comparing the costs and benefits. Ignoring theft, the
>> costs are near-zero, and the benefits are >0. Specifically, they are: a
>> higher BTC price and greater transaction fees. Theft is discouraged by
>> attempting to tie a theft to a loss of confidence in the miners, as
>> described in the spec/website.
>> In general the incentives are very similar to those of Bitcoin itself.
> 
> This is also a very dubious security model - I would argue that Bitcoin is much
> *more* valuable if miners do everything they can to ensure that drivechains
> fail, given the huge risks involved.

I don't see how. Users are free to ignore the sidechain, so it can only
benefit them.

Fortunately for you, if that is actually what miners believe, then there
will be no problem, as miners will just filter out drivechains (so that
Bitcoin will be "much *more* valuable"), which they can easily do.


>                                      I would also argue that users should do
> user-activated-soft-forks to ensure they fail.

Again, I don't think that kind of UASF can succeed, because one option
strictly dominates the other. But the users get the final say, of course.

Empirically, I have observed overwhelming support for sidechains among
users, business, and other developers. The btc-investors I spoke to were
all very excited about the prospect of sidechains, even more so than
they were excited about SegWit.


> 
> By comparison, note Adam Back and my own efforts to ensure miners have a
> smaller part in the ecosystem, with things like committed (encrypted)
> transactions and my closed-seal-set/truth-list approach(1). We want to involve
> miners as little as possible in the consensus, not more.

I agree that miners should have as little influence as possible (and
they probably agree, as well). But a 51% group can filter any message
they like from the blockchain. For sidechains, there will need to be two
public networks, so concealment is not an option.

And, I repeat, for regular users of Bitcoin Core, drivechain does not
make a 51% group more dangerous than they already are.

Moreover, there are cases [1] where miner-involvement can make a big
_positive_ impact. Just as it can be beneficial (essential, in fact) for
Bitcoin to filter out harmful interactions among txns (in other words,
good for miners to filter out double spends), I have discovered
situations where it is beneficial and essential for miners to filter out
harmful interactions among multiple chains.

So I think I am actually hitting the "as little as possible" target.

[1] http://www.truthcoin.info/blog/wise-contracts/#wise-contracts


> 
> I have to ask: What use-cases do you actually see for drivechains? Why can't

Here is a tentative project list:
http://www.drivechain.info/projects/index.html

And, as I say on the FAQ, "If each individual user is free to sell
his/her BTC in exchange for an Altcoin (or for fiat), we can hardly deny
users the opportunity to move their money between two sidechains."

So, in a strong way, the entire altcoin market makes the case for a
usefulness of sidechains. Bitcoin is a form of money, and only one form
of money can exist per currency area. So, if Bitcoin is not the winner,
it will eventually cease to exist altogether. Altcoin-competition is an
existential threat to Bitcoin, one which is far more relevant than
anything you've presented so far.

Secondly, one important value of permissionless innovation is that one
doesn't really know, today, what cool ideas other people are going to
come up with tomorrow. If you did, they'd be today's ideas.

Third, Core's review process has two opposite problems: on one hand it
is slow and grueling, and on the other it is fraught with the
possibility of catastrophic error. It would be better, for everyone, to
allow people to try their own (non-aggressive) experiments, and to make
their own mistakes. Already, I have seen the review process abused to
create/maintain fiefdoms of expertise, so that the abusers can extract
money from clients/employers/VCs.

Just think of all of the free time you would have, Peter, if you didn't
have to spend it all reviewing these projects!


> those use-cases be done in the much safer client-side validation fashion?

? How is drivechain _not_ within the category of client-side validation?
With BMM, validation is only performed by those users ("clients") who
opt-in to the new features. The economic model of BMM is directly
comparable to that of Bitcoin's PoW -- the highest-bid chain should be
the healthiest one.

Can you post the Github link for your most up-to-date client-side
validation work so that we can compare the safety and other features?

Thanks,
Paul

> 
> 1) https://petertodd.org/2016/closed-seal-sets-and-truth-lists-for-privacy
> 

From jtimon at jtimon.cc  Tue May 30 13:27:58 2017
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Tue, 30 May 2017 15:27:58 +0200
Subject: [bitcoin-dev] Hypothetical 2 MB hardfork to follow BIP148
In-Reply-To: <CAJowKgJK9zBkVAM1NyOsjU04gvwV3zGnk+1ebfpt6rnbiKy6Og@mail.gmail.com>
References: <201705232023.40588.luke@dashjr.org>
	<CAJowKgJK9zBkVAM1NyOsjU04gvwV3zGnk+1ebfpt6rnbiKy6Og@mail.gmail.com>
Message-ID: <CABm2gDpet31gEcBY6NTxEG+xA4rvg8_c79L+J=mJySGbf7Ydbg@mail.gmail.com>

Why not simply remove the (redundant after sw activation) 1 mb size
limit check and increasing the weight limit without changing the
discount or having 2 limits?


On Wed, May 24, 2017 at 1:07 AM, Erik Aronesty via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Personally, I would prefer if a 2MB lock-in that uses BIP103 for the timing.
>
> I think up to 20% per year can be absorbed by averages in bandwidth/CPU/RAM
> growth, of which bandwidth seems the most constraining.
>
> - Erik
>
>
> On Tue, May 23, 2017 at 4:23 PM, Luke Dashjr via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> In light of some recent discussions, I wrote up this BIP for a real 2 MB
>> block
>> size hardfork following Segwit BIP148 activation. This is not part of any
>> agreement I am party to, nor anything of that sort. Just something to
>> throw
>> out there as a possible (and realistic) option.
>>
>> Note that I cannot recommend this to be adopted, since frankly 1 MB blocks
>> really are still too large, and this blunt-style hardfork quite risky even
>> with consensus. But if the community wishes to adopt (by unanimous
>> consensus)
>> a 2 MB block size hardfork, this is probably the best way to do it right
>> now.
>> The only possible way to improve on this IMO would be to integrate it into
>> MMHF/"spoonnet" style hardfork (and/or add other unrelated-to-block-size
>> HF
>> improvements).
>>
>> I have left Author blank, as I do not intend to personally champion this.
>> Before it may be assigned a BIP number, someone else will need to step up
>> to
>> take on that role. Motivation and Rationale are blank because I do not
>> personally think there is any legitimate rationale for such a hardfork at
>> this
>> time; if someone adopts this BIP, they should complete these sections. (I
>> can
>> push a git branch with the BIP text if someone wants to fork it.)
>>
>> <pre>
>> BIP: ?
>> Layer: Consensus (hard fork)
>> Title: Post-segwit 2 MB block size hardfork
>> Author: FIXME
>> Comments-Summary: No comments yet.
>> Comments-URI: ?
>> Status: Draft
>> Type: Standards Track
>> Created: 2017-05-22
>> License: BSD-2-Clause
>> </pre>
>>
>> ==Abstract==
>>
>> Legacy Bitcoin transactions are given the witness discount, and a block
>> size
>> limit of 2 MB is imposed.
>>
>> ==Copyright==
>>
>> This BIP is licensed under the BSD 2-clause license.
>>
>> ==Specification==
>>
>> Upon activation, a block size limit of 2000000 bytes is enforced.
>> The block weight limit remains at 4000000 WU.
>>
>> The calculation of block weight is modified:
>> all witness data, including both scriptSig (used by pre-segwit inputs) and
>> segwit witness data, is measured as 1 weight-unit (WU), while all other
>> data
>> in the block is measured as 4 WU.
>>
>> The witness commitment in the generation transaction is no longer
>> required,
>> and instead the txid merkle root in the block header is replaced with a
>> hash
>> of:
>>
>> 1. The witness reserved value.
>> 2. The witness merkle root hash.
>> 3. The transaction ID merkle root hash.
>>
>> The maximum size of a transaction stripped of witness data is limited to 1
>> MB.
>>
>> ===Deployment===
>>
>> This BIP is deployed by flag day, in the block where the median-past time
>> surpasses 1543503872 (2018 Nov 29 at 15:04:32 UTC).
>>
>> It is assumed that when this flag day has been reached, Segwit has been
>> activated via BIP141 and/or BIP148.
>>
>> ==Motivation==
>>
>> FIXME
>>
>> ==Rationale==
>>
>> FIXME
>>
>> ==Backwards compatibility==
>>
>> This is a hardfork, and as such not backward compatible.
>> It should not be deployed without consent of the entire Bitcoin community.
>> Activation is scheduled for 18 months from the creation date of this BIP,
>> intended to give 6 months to establish consensus, and 12 months for
>> deployment.
>>
>> ==Reference implementation==
>>
>> FIXME
>>
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From carlier at gmail.com  Tue May 30 13:48:30 2017
From: carlier at gmail.com (Yann Carlier)
Date: Tue, 30 May 2017 21:48:30 +0800
Subject: [bitcoin-dev] Improvement Proposal
Message-ID: <CAKcm3BxdnuoFwc_Af3thKB32nPH7g5vgQsGu+1+L3D2472uYRg@mail.gmail.com>

Improvement Proposal

To allow users devices  (including mobile and/or IoT devices). to connect
and some how participate in the same BTC bock chain network without mining.

The incentive for this participants can be a lottery schema, running in
"parallel to mining in the same network" and in the block-chain.
Rewarding some lucky participant user (and/or miner?) randomly every
specific period of time.

Participants will pay the price on each connection round.

Yann
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170530/ef3602d1/attachment.html>

From erik at q32.com  Tue May 30 15:51:17 2017
From: erik at q32.com (Erik Aronesty)
Date: Tue, 30 May 2017 11:51:17 -0400
Subject: [bitcoin-dev] Compatibility-Oriented Omnibus Proposal
In-Reply-To: <CALhpmH3sUxa=MYtCdNMGO3AMGgmT=Tc2kcJzzpoY84syjgtP_A@mail.gmail.com>
References: <aC4avUiJPnHXxIxPlh4w2XA-SLB6ueTUlVTW7TreFwGV12L7L9CAGoB2E9msVYhV0M6xPTERpatAIeZO3kK-ikCRkwYQcJeEMHS7WWZKDAM=@protonmail.com>
	<CALhpmH3sUxa=MYtCdNMGO3AMGgmT=Tc2kcJzzpoY84syjgtP_A@mail.gmail.com>
Message-ID: <CAJowKg+o87tT_5vc5cB4t5nPU-LtYYidN1JWKxDBtwNZoYEdoQ@mail.gmail.com>

- We now are witnessing this... COOP vs LukeJr COOP, vs BIP148 vs BIP149 vs
BIP91 ... how many are there?:

https://xkcd.com/927

- If some miners and exchanges collude to enact a rapid 2MB+Segwit hard
fork coin... and calling it "bitcoin" on major exchanges this could swiftly
fragment the network.

- If this fork fails to contain an ASICBOOST defense, then this is
essentially an example of core failing to appropriately respond to the CVE
security vulnerability in time.

- A swift BIP148 release in core seems necessary to defend against this.
I am no longer in favor of adding a BIP148 option with default "false"..
I think it should be merged in...enabled, and released ASAP to defend
against these attacks.


On Mon, May 29, 2017 at 7:49 PM, Oliver Petruzel via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> >>if the community wishes to adopt (by unanimous consensus) a 2 MB block
> size hardfork, this is probably the best way to do it right now... Legacy
> Bitcoin transactions are given the witness discount, and a block size limit
> of 2 MB is imposed.<<
>
>
> The above decision may quickly become very controversial. I don't think it's
> what most users had/have in mind when they discuss a "2MB+SegWit" solution.
>
> With the current 1MB+SegWit, testing has shown us that normal usage
> results in ~2 or 2.1MB blocks.
>
> I think most users will expect a linear increase when Base Size is
> increased to 2000000 bytes and Total Weight is increased to 8000000 bytes.
> With normal usage, the expected results would then be ~4 or 4.2MB blocks.
>
> Am I missing something here, or does Luke's suggested 2MB cap completely
> nullify that expected linear increase? If so, why? What's the logic behind
> this decision?
>
> I'd love to be armed with a good answer should my colleagues ask me the
> same obvious question, so thank you ahead of time!
>
> Respectfully,
> Oliver Petruzel
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170530/127b8af6/attachment-0001.html>

From praxeology_guy at protonmail.com  Tue May 30 17:30:55 2017
From: praxeology_guy at protonmail.com (praxeology_guy)
Date: Tue, 30 May 2017 13:30:55 -0400
Subject: [bitcoin-dev] Improvement Proposal
In-Reply-To: <CAKcm3BxdnuoFwc_Af3thKB32nPH7g5vgQsGu+1+L3D2472uYRg@mail.gmail.com>
References: <CAKcm3BxdnuoFwc_Af3thKB32nPH7g5vgQsGu+1+L3D2472uYRg@mail.gmail.com>
Message-ID: <tFrtxe0Y8wRifE9L1jQWS1xG-WihyoWqsNj0_rT9oot9Be2-mZQytJLVaAo0K3h2-KFWAa7bQM5f7K0DlOqMeddsElkAdNxSRP-kxeEQ3xE=@protonmail.com>

Yann, Unfortunately sybil attacks [[https://en.wikipedia.org/wiki/Sybil_attack#Description]](https://en.wikipedia.org/wiki/Sybil_attack#Description) would prevent this from working... even if there was some way to prove that an entity performed the transaction validation. Proving the relay of transaction data to others is also vulnerable to sybil attack.

-------- Original Message --------
Subject: [bitcoin-dev] Improvement Proposal
Local Time: May 30, 2017 8:48 AM
UTC Time: May 30, 2017 1:48 PM
From: bitcoin-dev at lists.linuxfoundation.org
To: bitcoin-dev at lists.linuxfoundation.org

Improvement Proposal

To allow users devices  (including mobile and/or IoT devices). to connect and some how participate in the same BTC bock chain network without mining.

The incentive for this participants can be a lottery schema, running in "parallel to mining in the same network" and in the block-chain.
Rewarding some lucky participant user (and/or miner?) randomly every specific period of time.

Participants will pay the price on each connection round.

Yann
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170530/773e2132/attachment-0001.html>

From jacob.eliosoff at gmail.com  Tue May 30 20:10:04 2017
From: jacob.eliosoff at gmail.com (Jacob Eliosoff)
Date: Tue, 30 May 2017 16:10:04 -0400
Subject: [bitcoin-dev] Hypothetical 2 MB hardfork to follow BIP148
In-Reply-To: <CABm2gDpet31gEcBY6NTxEG+xA4rvg8_c79L+J=mJySGbf7Ydbg@mail.gmail.com>
References: <201705232023.40588.luke@dashjr.org>
	<CAJowKgJK9zBkVAM1NyOsjU04gvwV3zGnk+1ebfpt6rnbiKy6Og@mail.gmail.com>
	<CABm2gDpet31gEcBY6NTxEG+xA4rvg8_c79L+J=mJySGbf7Ydbg@mail.gmail.com>
Message-ID: <CAAUaCyj2Syv-YHiAQGWoeOqvP7_wG_FFQg0630X9Ut0Y_qE3dw@mail.gmail.com>

I'd like to know this too.  Is it just that a 4MB blockmaxweight would
theoretically allow ~4MB blocks (if ~all witness data), which is too big?
Or is there a more subtle reason we still need blockmaxsize after a HF?


On May 30, 2017 9:28 AM, "Jorge Tim?n via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

Why not simply remove the (redundant after sw activation) 1 mb size
limit check and increasing the weight limit without changing the
discount or having 2 limits?


On Wed, May 24, 2017 at 1:07 AM, Erik Aronesty via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Personally, I would prefer if a 2MB lock-in that uses BIP103 for the
timing.
>
> I think up to 20% per year can be absorbed by averages in
bandwidth/CPU/RAM
> growth, of which bandwidth seems the most constraining.
>
> - Erik
>
>
> On Tue, May 23, 2017 at 4:23 PM, Luke Dashjr via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> In light of some recent discussions, I wrote up this BIP for a real 2 MB
>> block
>> size hardfork following Segwit BIP148 activation. This is not part of any
>> agreement I am party to, nor anything of that sort. Just something to
>> throw
>> out there as a possible (and realistic) option.
>>
>> Note that I cannot recommend this to be adopted, since frankly 1 MB
blocks
>> really are still too large, and this blunt-style hardfork quite risky
even
>> with consensus. But if the community wishes to adopt (by unanimous
>> consensus)
>> a 2 MB block size hardfork, this is probably the best way to do it right
>> now.
>> The only possible way to improve on this IMO would be to integrate it
into
>> MMHF/"spoonnet" style hardfork (and/or add other unrelated-to-block-size
>> HF
>> improvements).
>>
>> I have left Author blank, as I do not intend to personally champion this.
>> Before it may be assigned a BIP number, someone else will need to step up
>> to
>> take on that role. Motivation and Rationale are blank because I do not
>> personally think there is any legitimate rationale for such a hardfork at
>> this
>> time; if someone adopts this BIP, they should complete these sections. (I
>> can
>> push a git branch with the BIP text if someone wants to fork it.)
>>
>> <pre>
>> BIP: ?
>> Layer: Consensus (hard fork)
>> Title: Post-segwit 2 MB block size hardfork
>> Author: FIXME
>> Comments-Summary: No comments yet.
>> Comments-URI: ?
>> Status: Draft
>> Type: Standards Track
>> Created: 2017-05-22
>> License: BSD-2-Clause
>> </pre>
>>
>> ==Abstract==
>>
>> Legacy Bitcoin transactions are given the witness discount, and a block
>> size
>> limit of 2 MB is imposed.
>>
>> ==Copyright==
>>
>> This BIP is licensed under the BSD 2-clause license.
>>
>> ==Specification==
>>
>> Upon activation, a block size limit of 2000000 bytes is enforced.
>> The block weight limit remains at 4000000 WU.
>>
>> The calculation of block weight is modified:
>> all witness data, including both scriptSig (used by pre-segwit inputs)
and
>> segwit witness data, is measured as 1 weight-unit (WU), while all other
>> data
>> in the block is measured as 4 WU.
>>
>> The witness commitment in the generation transaction is no longer
>> required,
>> and instead the txid merkle root in the block header is replaced with a
>> hash
>> of:
>>
>> 1. The witness reserved value.
>> 2. The witness merkle root hash.
>> 3. The transaction ID merkle root hash.
>>
>> The maximum size of a transaction stripped of witness data is limited to
1
>> MB.
>>
>> ===Deployment===
>>
>> This BIP is deployed by flag day, in the block where the median-past time
>> surpasses 1543503872 (2018 Nov 29 at 15:04:32 UTC).
>>
>> It is assumed that when this flag day has been reached, Segwit has been
>> activated via BIP141 and/or BIP148.
>>
>> ==Motivation==
>>
>> FIXME
>>
>> ==Rationale==
>>
>> FIXME
>>
>> ==Backwards compatibility==
>>
>> This is a hardfork, and as such not backward compatible.
>> It should not be deployed without consent of the entire Bitcoin
community.
>> Activation is scheduled for 18 months from the creation date of this BIP,
>> intended to give 6 months to establish consensus, and 12 months for
>> deployment.
>>
>> ==Reference implementation==
>>
>> FIXME
>>
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170530/060fafbb/attachment.html>

From mark at friedenbach.org  Tue May 30 21:24:20 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Tue, 30 May 2017 14:24:20 -0700
Subject: [bitcoin-dev] Hypothetical 2 MB hardfork to follow BIP148
In-Reply-To: <CABm2gDpet31gEcBY6NTxEG+xA4rvg8_c79L+J=mJySGbf7Ydbg@mail.gmail.com>
References: <201705232023.40588.luke@dashjr.org>
	<CAJowKgJK9zBkVAM1NyOsjU04gvwV3zGnk+1ebfpt6rnbiKy6Og@mail.gmail.com>
	<CABm2gDpet31gEcBY6NTxEG+xA4rvg8_c79L+J=mJySGbf7Ydbg@mail.gmail.com>
Message-ID: <CAOG=w-uei5-c-Mpp_R6RrN29NTrSV+gpNd79FC3cB6QPG65sEw@mail.gmail.com>

The 1MB classic block size is not redundant after segwit activation.
Segwit prevents the quadratic hashing problems, but only for segwit
outputs. The 1MB classic block size prevents quadratic hashing
problems from being any worse than they are today.

Mark

On Tue, May 30, 2017 at 6:27 AM, Jorge Tim?n via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Why not simply remove the (redundant after sw activation) 1 mb size
> limit check and increasing the weight limit without changing the
> discount or having 2 limits?
>
>
> On Wed, May 24, 2017 at 1:07 AM, Erik Aronesty via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> Personally, I would prefer if a 2MB lock-in that uses BIP103 for the timing.
>>
>> I think up to 20% per year can be absorbed by averages in bandwidth/CPU/RAM
>> growth, of which bandwidth seems the most constraining.
>>
>> - Erik
>>
>>
>> On Tue, May 23, 2017 at 4:23 PM, Luke Dashjr via bitcoin-dev
>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>> In light of some recent discussions, I wrote up this BIP for a real 2 MB
>>> block
>>> size hardfork following Segwit BIP148 activation. This is not part of any
>>> agreement I am party to, nor anything of that sort. Just something to
>>> throw
>>> out there as a possible (and realistic) option.
>>>
>>> Note that I cannot recommend this to be adopted, since frankly 1 MB blocks
>>> really are still too large, and this blunt-style hardfork quite risky even
>>> with consensus. But if the community wishes to adopt (by unanimous
>>> consensus)
>>> a 2 MB block size hardfork, this is probably the best way to do it right
>>> now.
>>> The only possible way to improve on this IMO would be to integrate it into
>>> MMHF/"spoonnet" style hardfork (and/or add other unrelated-to-block-size
>>> HF
>>> improvements).
>>>
>>> I have left Author blank, as I do not intend to personally champion this.
>>> Before it may be assigned a BIP number, someone else will need to step up
>>> to
>>> take on that role. Motivation and Rationale are blank because I do not
>>> personally think there is any legitimate rationale for such a hardfork at
>>> this
>>> time; if someone adopts this BIP, they should complete these sections. (I
>>> can
>>> push a git branch with the BIP text if someone wants to fork it.)
>>>
>>> <pre>
>>> BIP: ?
>>> Layer: Consensus (hard fork)
>>> Title: Post-segwit 2 MB block size hardfork
>>> Author: FIXME
>>> Comments-Summary: No comments yet.
>>> Comments-URI: ?
>>> Status: Draft
>>> Type: Standards Track
>>> Created: 2017-05-22
>>> License: BSD-2-Clause
>>> </pre>
>>>
>>> ==Abstract==
>>>
>>> Legacy Bitcoin transactions are given the witness discount, and a block
>>> size
>>> limit of 2 MB is imposed.
>>>
>>> ==Copyright==
>>>
>>> This BIP is licensed under the BSD 2-clause license.
>>>
>>> ==Specification==
>>>
>>> Upon activation, a block size limit of 2000000 bytes is enforced.
>>> The block weight limit remains at 4000000 WU.
>>>
>>> The calculation of block weight is modified:
>>> all witness data, including both scriptSig (used by pre-segwit inputs) and
>>> segwit witness data, is measured as 1 weight-unit (WU), while all other
>>> data
>>> in the block is measured as 4 WU.
>>>
>>> The witness commitment in the generation transaction is no longer
>>> required,
>>> and instead the txid merkle root in the block header is replaced with a
>>> hash
>>> of:
>>>
>>> 1. The witness reserved value.
>>> 2. The witness merkle root hash.
>>> 3. The transaction ID merkle root hash.
>>>
>>> The maximum size of a transaction stripped of witness data is limited to 1
>>> MB.
>>>
>>> ===Deployment===
>>>
>>> This BIP is deployed by flag day, in the block where the median-past time
>>> surpasses 1543503872 (2018 Nov 29 at 15:04:32 UTC).
>>>
>>> It is assumed that when this flag day has been reached, Segwit has been
>>> activated via BIP141 and/or BIP148.
>>>
>>> ==Motivation==
>>>
>>> FIXME
>>>
>>> ==Rationale==
>>>
>>> FIXME
>>>
>>> ==Backwards compatibility==
>>>
>>> This is a hardfork, and as such not backward compatible.
>>> It should not be deployed without consent of the entire Bitcoin community.
>>> Activation is scheduled for 18 months from the creation date of this BIP,
>>> intended to give 6 months to establish consensus, and 12 months for
>>> deployment.
>>>
>>> ==Reference implementation==
>>>
>>> FIXME
>>>
>>>
>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From calvinrechner at protonmail.com  Tue May 30 22:20:25 2017
From: calvinrechner at protonmail.com (CalvinRechner)
Date: Tue, 30 May 2017 18:20:25 -0400
Subject: [bitcoin-dev] Compatibility-Oriented Omnibus Proposal
In-Reply-To: <CALhpmH3sUxa=MYtCdNMGO3AMGgmT=Tc2kcJzzpoY84syjgtP_A@mail.gmail.com>
References: <aC4avUiJPnHXxIxPlh4w2XA-SLB6ueTUlVTW7TreFwGV12L7L9CAGoB2E9msVYhV0M6xPTERpatAIeZO3kK-ikCRkwYQcJeEMHS7WWZKDAM=@protonmail.com>
	<CALhpmH3sUxa=MYtCdNMGO3AMGgmT=Tc2kcJzzpoY84syjgtP_A@mail.gmail.com>
Message-ID: <-r9BgtNAp6_SNVwmPiOER08eMpERnuWioUbNVIQJhyIas29hC5VpWmWP5z4hcC8xtWcAPcFqyxNl9I0Ile6mpY8-ZuHr8jxERXKXKo8WYQE=@protonmail.com>

In principle, there is complete flexibility when it comes to the specific consensus details of the hard fork. One common suggestion has been to phase in a gradual blocksize increase beyond the initial 2MB cap included in Luke-Jr's proposal (a la BIP103); this would certainly be a welcome inclusion in the Omnibus Proposal, provided that is what we want. The reasoning behind incorporating Luke-Jr's 2MB limit and discount-rebalancing was to satisfy the conditions of the Scaling Agreement while ensuring maximum safety, minimum code discrepancies, and minimum controversy among the community; these priorities seem imperative, considering the extreme timeline constraints we are working under and the goals of the proposal. To put it more simply, the intent of the proposal was to serve as a template for the minimum viable fork that can achieve true consensus. A gradual increase to a larger size cap, especially if it were reasonably conservative, would be wholly in accordance with the Omnibus Proposal if that is what it takes to achieve the cooperation between community, industry, and developers in this critical moment of Bitcoin's history.

The purpose of the Omnibus Proposal is singlefold: to achieve the goals of the Consensus 2017 Scaling Agreement in the most maximally-compatible way. We can minimize disruption and loss potential all around by solving these problems in a compatibility-oriented manner. It is possible to fulfill both the letter and the spirit of the Scaling Agreement, to the complete satisfaction of all involved, while preventing chain-split risks in the meantime.

There is no justification for incompatibility with existing deployment approaches, when there is the possibility to work together towards our mutual goals instead. The most rational option is to join forces and avoid any chain-split potential for as long as possible. Under the Omnibus Proposal, once SegWit is activated, the terms of the hard fork are locked in automatically, set to activate 6 months later. The proposal guarantees that a successful SegWit activation is followed by a hard fork. Beyond enforcing the hard fork rules beginning at block height HardForkHeight, the Omnibus Proposal simply represents compatibility with the existing SegWit-activation deployment approaches.

By committing to this proposal, we can ensure unity, at least for now. There do not appear to be any arguments to the contrary. Why squander this opportunity for consensus and harmony? We can leverage the momentum of several disparate movements, and perhaps enjoy some much-needed social solidarity. In a way, everyone can get what they want, and through cooperation, we avoid the risk of a costly fracture.

The Segwit2x Team has begun work on an implementation of the Consensus Scaling Agreement, their operational timeline including the publication of a BIP on June 16, 2017.[1] I call upon the developers and maintainers of this initiative to consider and honor the Omnibus Proposal, extended or modified as needed, as the guiding approach to your development effort. Almost every component of the code exists, in some form or fashion, in the various constituent proposals' reference implementations, most of which have already undergone a significant degree of peer review.

We cannot afford to delay, nor to reimplement; the launch timeline is aggressively optimistic as it is. The quickest and safest approach to achieving the goals set forth at Consensus 2017 is to leverage the existing tools and proposals for the job. We can solve our problems properly, cooperatively.

I humbly ask that Jeff Garzik, Barry Silbert, Mike Belshe, and all of the other wonderful, intelligent collaborators on this project step forward and support the cooperative, compatibility-oriented approach of the Omnibus Proposal.

This is the best way to maximize value for everyone. We have a real opportunity to collaborate and work together on the same team. The Omnibus Proposal, designed in exact accordance with a powerful industry agreement and incorporating the feedback and suggestions provided from within both the developer community and the community-at-large, stands the best chance of uniting everyone under a common front.

Please, for the love of Bitcoin, let us do our best to cooperate.

[1] https://imgur.com/a/a2oPs

Sent with [ProtonMail](https://protonmail.com) Secure Email.

-------- Original Message --------
Subject: Re: [bitcoin-dev] Compatibility-Oriented Omnibus Proposal
Local Time: May 29, 2017 6:49 PM
UTC Time: May 29, 2017 11:49 PM
From: opetruzel at gmail.com
To: CalvinRechner <calvinrechner at protonmail.com>
Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>

>>if the community wishes to adopt (by unanimous consensus) a 2 MB block size hardfork, this is probably the best way to do it right now... Legacy Bitcoin transactions are given the witness discount, and a block size limit of 2 MB is imposed.<<

The above decision may quickly become very controversial. I don't think it's what most users had/have in mind when they discuss a "2MB+SegWit" solution.

With the current 1MB+SegWit, testing has shown us that normal usage results in ~2 or 2.1MB blocks.

I think most users will expect a linear increase when Base Size is increased to 2000000 bytes and Total Weight is increased to 8000000 bytes. With normal usage, the expected results would then be ~4 or 4.2MB blocks.

Am I missing something here, or does Luke's suggested 2MB cap completely nullify that expected linear increase? If so, why? What's the logic behind this decision?

I'd love to be armed with a good answer should my colleagues ask me the same obvious question, so thank you ahead of time!

Respectfully,
Oliver Petruzel
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170530/8b73d5b3/attachment-0001.html>

From jtimon at jtimon.cc  Tue May 30 22:26:20 2017
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Wed, 31 May 2017 00:26:20 +0200
Subject: [bitcoin-dev] Hypothetical 2 MB hardfork to follow BIP148
In-Reply-To: <CAOG=w-uei5-c-Mpp_R6RrN29NTrSV+gpNd79FC3cB6QPG65sEw@mail.gmail.com>
References: <201705232023.40588.luke@dashjr.org>
	<CAJowKgJK9zBkVAM1NyOsjU04gvwV3zGnk+1ebfpt6rnbiKy6Og@mail.gmail.com>
	<CABm2gDpet31gEcBY6NTxEG+xA4rvg8_c79L+J=mJySGbf7Ydbg@mail.gmail.com>
	<CAOG=w-uei5-c-Mpp_R6RrN29NTrSV+gpNd79FC3cB6QPG65sEw@mail.gmail.com>
Message-ID: <CABm2gDr2YwHZ_=Ky4BX-zVL2YcUSk_DB=Vn9iCdDvvbsHx3h+A@mail.gmail.com>

My understanding is that you cannot possibly violate the 1 MB block
size rule without also violating the 4 MB weight rule.
Regarding size alone, the only check we care about if we accept segwit is:

https://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp#L2891 [size4]

If that doesn't fail due to excessive non-witness data, then there's no way that

https://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp#L2681 [size1]

would have failed before due to excessive non-witness data.
If I understood it correctly when I was explained, if I remember
correctly, that last check is really just an optimization or a
protection against DoS invalid blocks. If the size without any witness
data is bigger than 1/4 the max_weight, then the max_weight check is
certain to fail as well without having to look at any witness data at
that validation stage (assuming the failure is due to excessive
non-witness data).

I think you are not referring to the 1 mb size limit but to related
one for sigops:

https://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp#L2704
[sigops1]

whose segwit parallel is in:

https://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp#L1661
[sigops4]

I believe the situation is similar in checking before knowing anything
about the witness data just in case that's already too much. In fact,
here is clearer because MAX_BLOCK_SIGOPS_COST is used for both (and
WITNESS_SCALE_FACTOR is used for the optimization case).

So what I would do in a hardfork after segwit activation would be to
simply equal MAX_BLOCK_BASE_SIZE=MAX_BLOCK_WEIGHT/WITNESS_SCALE_FACTOR
for size1, and increase MAX_BLOCK_WEIGHT and MAX_BLOCK_ SIGOPS_COST
proportionally for size4 and sigops4 respectively (well, the sigops
const for sigops1 as well).

If I understood segwit correctly, I believe that even though it is not
activated yet, you could remove both the size1 and sigops1 checks and
your node would still not accept invalid blocks by pre-bip141 rules,
your node would just spend more time on invalid blocks due to
currently excessive size/sigops, because it would only realize at a
later validation stage. Sorry for the redundancy about the validation
stage.

But it is not unlikely that I'm missing something. If I am wrong about
this I am spreading misinformation about segwit in several channels,
so I'm very interested in corrections to my statements in this mail.

On Tue, May 30, 2017 at 11:24 PM, Mark Friedenbach <mark at friedenbach.org> wrote:
> The 1MB classic block size is not redundant after segwit activation.
> Segwit prevents the quadratic hashing problems, but only for segwit
> outputs. The 1MB classic block size prevents quadratic hashing
> problems from being any worse than they are today.
>
> Mark
>
> On Tue, May 30, 2017 at 6:27 AM, Jorge Tim?n via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> Why not simply remove the (redundant after sw activation) 1 mb size
>> limit check and increasing the weight limit without changing the
>> discount or having 2 limits?
>>
>>
>> On Wed, May 24, 2017 at 1:07 AM, Erik Aronesty via bitcoin-dev
>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>> Personally, I would prefer if a 2MB lock-in that uses BIP103 for the timing.
>>>
>>> I think up to 20% per year can be absorbed by averages in bandwidth/CPU/RAM
>>> growth, of which bandwidth seems the most constraining.
>>>
>>> - Erik
>>>
>>>
>>> On Tue, May 23, 2017 at 4:23 PM, Luke Dashjr via bitcoin-dev
>>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>
>>>> In light of some recent discussions, I wrote up this BIP for a real 2 MB
>>>> block
>>>> size hardfork following Segwit BIP148 activation. This is not part of any
>>>> agreement I am party to, nor anything of that sort. Just something to
>>>> throw
>>>> out there as a possible (and realistic) option.
>>>>
>>>> Note that I cannot recommend this to be adopted, since frankly 1 MB blocks
>>>> really are still too large, and this blunt-style hardfork quite risky even
>>>> with consensus. But if the community wishes to adopt (by unanimous
>>>> consensus)
>>>> a 2 MB block size hardfork, this is probably the best way to do it right
>>>> now.
>>>> The only possible way to improve on this IMO would be to integrate it into
>>>> MMHF/"spoonnet" style hardfork (and/or add other unrelated-to-block-size
>>>> HF
>>>> improvements).
>>>>
>>>> I have left Author blank, as I do not intend to personally champion this.
>>>> Before it may be assigned a BIP number, someone else will need to step up
>>>> to
>>>> take on that role. Motivation and Rationale are blank because I do not
>>>> personally think there is any legitimate rationale for such a hardfork at
>>>> this
>>>> time; if someone adopts this BIP, they should complete these sections. (I
>>>> can
>>>> push a git branch with the BIP text if someone wants to fork it.)
>>>>
>>>> <pre>
>>>> BIP: ?
>>>> Layer: Consensus (hard fork)
>>>> Title: Post-segwit 2 MB block size hardfork
>>>> Author: FIXME
>>>> Comments-Summary: No comments yet.
>>>> Comments-URI: ?
>>>> Status: Draft
>>>> Type: Standards Track
>>>> Created: 2017-05-22
>>>> License: BSD-2-Clause
>>>> </pre>
>>>>
>>>> ==Abstract==
>>>>
>>>> Legacy Bitcoin transactions are given the witness discount, and a block
>>>> size
>>>> limit of 2 MB is imposed.
>>>>
>>>> ==Copyright==
>>>>
>>>> This BIP is licensed under the BSD 2-clause license.
>>>>
>>>> ==Specification==
>>>>
>>>> Upon activation, a block size limit of 2000000 bytes is enforced.
>>>> The block weight limit remains at 4000000 WU.
>>>>
>>>> The calculation of block weight is modified:
>>>> all witness data, including both scriptSig (used by pre-segwit inputs) and
>>>> segwit witness data, is measured as 1 weight-unit (WU), while all other
>>>> data
>>>> in the block is measured as 4 WU.
>>>>
>>>> The witness commitment in the generation transaction is no longer
>>>> required,
>>>> and instead the txid merkle root in the block header is replaced with a
>>>> hash
>>>> of:
>>>>
>>>> 1. The witness reserved value.
>>>> 2. The witness merkle root hash.
>>>> 3. The transaction ID merkle root hash.
>>>>
>>>> The maximum size of a transaction stripped of witness data is limited to 1
>>>> MB.
>>>>
>>>> ===Deployment===
>>>>
>>>> This BIP is deployed by flag day, in the block where the median-past time
>>>> surpasses 1543503872 (2018 Nov 29 at 15:04:32 UTC).
>>>>
>>>> It is assumed that when this flag day has been reached, Segwit has been
>>>> activated via BIP141 and/or BIP148.
>>>>
>>>> ==Motivation==
>>>>
>>>> FIXME
>>>>
>>>> ==Rationale==
>>>>
>>>> FIXME
>>>>
>>>> ==Backwards compatibility==
>>>>
>>>> This is a hardfork, and as such not backward compatible.
>>>> It should not be deployed without consent of the entire Bitcoin community.
>>>> Activation is scheduled for 18 months from the creation date of this BIP,
>>>> intended to give 6 months to establish consensus, and 12 months for
>>>> deployment.
>>>>
>>>> ==Reference implementation==
>>>>
>>>> FIXME
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>>
>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From macwhyte at gmail.com  Tue May 30 23:50:01 2017
From: macwhyte at gmail.com (James MacWhyte)
Date: Tue, 30 May 2017 23:50:01 +0000
Subject: [bitcoin-dev] Hypothetical 2 MB hardfork to follow BIP148
In-Reply-To: <CAOG=w-uei5-c-Mpp_R6RrN29NTrSV+gpNd79FC3cB6QPG65sEw@mail.gmail.com>
References: <201705232023.40588.luke@dashjr.org>
	<CAJowKgJK9zBkVAM1NyOsjU04gvwV3zGnk+1ebfpt6rnbiKy6Og@mail.gmail.com>
	<CABm2gDpet31gEcBY6NTxEG+xA4rvg8_c79L+J=mJySGbf7Ydbg@mail.gmail.com>
	<CAOG=w-uei5-c-Mpp_R6RrN29NTrSV+gpNd79FC3cB6QPG65sEw@mail.gmail.com>
Message-ID: <CAH+Axy5yYQywpy0s9pBZt_fNoLPpWfra-cU9HrUwH71GDOchsQ@mail.gmail.com>

>  The 1MB classic block size prevents quadratic hashing
> problems from being any worse than they are today.
>
>
Add a transaction-size limit of, say, 10kb and the quadratic hashing
problem is a non-issue. Donezo.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170530/359bc4e6/attachment.html>

From jtimon at jtimon.cc  Wed May 31 01:22:44 2017
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Wed, 31 May 2017 03:22:44 +0200
Subject: [bitcoin-dev] Hypothetical 2 MB hardfork to follow BIP148
In-Reply-To: <CAH+Axy5yYQywpy0s9pBZt_fNoLPpWfra-cU9HrUwH71GDOchsQ@mail.gmail.com>
References: <201705232023.40588.luke@dashjr.org>
	<CAJowKgJK9zBkVAM1NyOsjU04gvwV3zGnk+1ebfpt6rnbiKy6Og@mail.gmail.com>
	<CABm2gDpet31gEcBY6NTxEG+xA4rvg8_c79L+J=mJySGbf7Ydbg@mail.gmail.com>
	<CAOG=w-uei5-c-Mpp_R6RrN29NTrSV+gpNd79FC3cB6QPG65sEw@mail.gmail.com>
	<CAH+Axy5yYQywpy0s9pBZt_fNoLPpWfra-cU9HrUwH71GDOchsQ@mail.gmail.com>
Message-ID: <CABm2gDoJ7S3pjdjdbKZ4-EuVXnEOj-gEPzSEvUGdtYovZaNK=g@mail.gmail.com>

On Wed, May 31, 2017 at 1:50 AM, James MacWhyte <macwhyte at gmail.com> wrote:
>
>>
>>  The 1MB classic block size prevents quadratic hashing
>> problems from being any worse than they are today.
>>
>
> Add a transaction-size limit of, say, 10kb and the quadratic hashing problem
> is a non-issue. Donezo.

Why is it https://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp#L1661
not enough at this point?
Why the need for a transaction size limit?

From jeanpaulkogelman at me.com  Wed May 31 01:09:26 2017
From: jeanpaulkogelman at me.com (Jean-Paul Kogelman)
Date: Tue, 30 May 2017 18:09:26 -0700
Subject: [bitcoin-dev] Hypothetical 2 MB hardfork to follow BIP148
In-Reply-To: <CAH+Axy5yYQywpy0s9pBZt_fNoLPpWfra-cU9HrUwH71GDOchsQ@mail.gmail.com>
References: <201705232023.40588.luke@dashjr.org>
	<CAJowKgJK9zBkVAM1NyOsjU04gvwV3zGnk+1ebfpt6rnbiKy6Og@mail.gmail.com>
	<CABm2gDpet31gEcBY6NTxEG+xA4rvg8_c79L+J=mJySGbf7Ydbg@mail.gmail.com>
	<CAOG=w-uei5-c-Mpp_R6RrN29NTrSV+gpNd79FC3cB6QPG65sEw@mail.gmail.com>
	<CAH+Axy5yYQywpy0s9pBZt_fNoLPpWfra-cU9HrUwH71GDOchsQ@mail.gmail.com>
Message-ID: <004E1123-8346-48B6-9BCB-94BAE00EC34B@me.com>

That would invalidate any pre-signed transactions that are currently out there. You can't just change the rules out from under people.


> On May 30, 2017, at 4:50 PM, James MacWhyte via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
>  
>>  The 1MB classic block size prevents quadratic hashing
>> problems from being any worse than they are today.
>> 
> 
> Add a transaction-size limit of, say, 10kb and the quadratic hashing problem is a non-issue. Donezo.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170530/aa4c361d/attachment.html>

From luke at dashjr.org  Wed May 31 04:14:25 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Wed, 31 May 2017 04:14:25 +0000
Subject: [bitcoin-dev] Hypothetical 2 MB hardfork to follow BIP148
In-Reply-To: <CABm2gDoJ7S3pjdjdbKZ4-EuVXnEOj-gEPzSEvUGdtYovZaNK=g@mail.gmail.com>
References: <201705232023.40588.luke@dashjr.org>
	<CAH+Axy5yYQywpy0s9pBZt_fNoLPpWfra-cU9HrUwH71GDOchsQ@mail.gmail.com>
	<CABm2gDoJ7S3pjdjdbKZ4-EuVXnEOj-gEPzSEvUGdtYovZaNK=g@mail.gmail.com>
Message-ID: <201705310414.26724.luke@dashjr.org>

On Wednesday 31 May 2017 1:22:44 AM Jorge Tim?n via bitcoin-dev wrote:
> Why is it
> https://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp#L1661
> not enough at this point?
> Why the need for a transaction size limit?

Because the bottleneck is hashing the transaction, which costs (in CPU time) 
based on its size. Maybe it would make sense to factor sigops into the limit, 
though?

On Wednesday 31 May 2017 1:09:26 AM Jean-Paul Kogelman via bitcoin-dev wrote:
> On May 30, 2017, at 4:50 PM, James MacWhyte wrote:
> > Add a transaction-size limit of, say, 10kb and the quadratic hashing
> > problem is a non-issue. Donezo.
>
> That would invalidate any pre-signed transactions that are currently out
> there. You can't just change the rules out from under people.

Make it 100kB and I think we'd be okay. Those have always been policy-
forbidden so there should be no expectation they'd be acceptable in the 
future.

While we're at it, I suggest also specifying a minimum transaction size as 
well. The raw minimum possible is 60 bytes, but any sane output would need at 
least a hash, so I'd say make the minimum be 8 (60 + 160-bit hash) bytes?

Luke

From eric at voskuil.org  Wed May 31 06:17:59 2017
From: eric at voskuil.org (Eric Voskuil)
Date: Tue, 30 May 2017 23:17:59 -0700
Subject: [bitcoin-dev] Emergency Deployment of SegWit as a partial
 mitigation of CVE-2017-9230
In-Reply-To: <20170529111914.GA21581@erisian.com.au>
References: <D0299438-E848-4696-B323-8D0E810AE491@gmail.com>
	<CAFmyj8zNkPj3my3CLzkXdpJ1xkD0GQk8ODg09qYnnj_ONGUtsQ@mail.gmail.com>
	<2E6BB6FA-65FF-497F-8AEA-4CC8655BAE69@gmail.com>
	<20170527063726.GA12042@erisian.com.au>
	<f25dee23-4e92-d464-9fec-20d0c54c573b@voskuil.org>
	<20170529111914.GA21581@erisian.com.au>
Message-ID: <ae8c6944-1af4-5ea8-a2a4-a18d0967302e@voskuil.org>

On 05/29/2017 04:19 AM, Anthony Towns wrote:
> On Sat, May 27, 2017 at 01:07:58PM -0700, Eric Voskuil via bitcoin-dev wrote:
>> Anthony,
>> For the sake of argument:
> 
> (That seems like the cue to move any further responses to bitcoin-discuss)

I didn't meant to imply that the point was academic, just to ask your
indulgence before making my point. Thanks for the detailed and
thoughtful reply.

>> (1) What would the situation look like if there was no patent?
> 
> If there were no patent, and it were easy enough to implement it, then
> everyone would use it. So blocking ASICBoost would decrease everyone's
> hashrate by the same amount, and you'd just have a single retarget period
> with everyone earning a little less, and then everyone would be back to
> making the same profit.
>...

I don't accept that the ease (absolute cost) of implementing the
ASICBOOST optimization is relevant. The cost of implementation is offset
by its returns. Given that people are presumed to be using it profitably
I consider this point settled.

The important point is that if people widely use the optimization, it
does not constitute any risk whatsoever.

>> (2) Would the same essential formulation exist if there had been a
>> patent on bitcoin mining ASICs in general?
> 
> Not really; for the formulation to apply you'd have to have some way
> to block ASIC use via consensus rules, in a way that doesn't just block
> ASICs completely, but just removes their advantage, ie makes them perform
> comparably to GPUs/FPGAs or whatever everyone else is using.
>...

I realize that the term "same essential formulation" was misleading, but
my aim was the *source* of harm (unblocked) in an ASIC patent as
compared to an ASICBOOST patent. It seems that you agree that this harm
in both cases results from the patent, not the optimization.

Nobody is suggesting that ASICs are a problem despite the significant
optimization. It is worth considering an alternate history where ASIC
mining had been patented, given that blocking it would not have been an
option. More on this below.

I agree that the optimizations differ in that there is no known way to
block the ASIC advantage, except for all people to use it. But correctly
attributing the source of harm is critical to useful threat modeling. As
the ASIC example is meant to show, it is very possible that an
unblockable patent advantage can arise in the future.

>> (3) Would an unforeseen future patented mining optimization exhibit
>> the same characteristics?
> 
> Maybe? It depends on whether the optimisation's use (or lack thereof)
> can be detected (enforced) via consensus rules. If you've got a patent
> on a 10nm process, and you build a bitcoin ASIC with it, there's no way
> to stop you via consensus rules that I can think of.

Quite clearly then there is a possibility (if not a certainty) that
Bitcoin will eventually be faced with an unblockable mining patent
advantage.

>> (4) Given that patent is a state grant of monopoly privilege, could a
>> state licensing regime for miners, applied in the same scope as a
>> patent, but absent any patent, have the same effect?
> 
> I don't think that scenario's any different from charging miners income
> tax, is it? If you don't pay the licensing fee / income tax, you get put
> out of business; if you do, you have less profit. There's no way to block
> either via consensus mechanisms, at least in general...

Precisely. This is a proper generalization of the threats above. A
patent is a state grant of monopoly privilege. The state's agent (patent
holder) extracts licensing fees from miners. The state does this for its
own perceived benefit (social, economic or otherwise). Extracting money
in exchange for permission to use an optimization is a tax on the
optimization.

> I think it's the case that any optional technology with license fees can't
> be made available to all miners on equal terms...

This is an important point. Consider also that a subsidy has the same
effect as a tax. A disproportionate tax on competing miners amounts to a
subsidy. A disproportionate subsidy amounts to a tax on competitors.

If the state wants to put its finger on the scale it can do so in either
direction. It can compel licensing fees from miners with no need for a
patent. It can also subsidize mining via subsidized energy costs (for
example), intentionally or otherwise.

> Sadly, the solution to this argument is to use discriminatory terms,
> either not offering the technology to everyone, or offering varying fees
> for miners with different hashrates...

That sounds more like a central authority than a solution.

So, my point:

Mis-attributing the threat is not helpful. This is not an issue of an
unforeseen bug, security vulnerability, bad miners, or evil
patent-holders. This is one narrow example of the general, foreseen,
primary threat to Bitcoin - or any hard money.

Bitcoin's sole defense is decentralization. People parrot this idea
without considering the implication. How does decentralization work? It
works by broadly spreading the risk of state attack. But this implies
that some people are actually taking the risk.

By analogy, BitTorrent is estimated to have 250 million active users in
a month, and 200,000 have been sued in the US since 2010.
Decentralization works because it reduces risk through risk-sharing.

Bitcoin cannot generally prevent state patent/licensing/tax regimes.
Licensing is a ban that is lifted in exchange for payment. What is the
Bitcoin solution to a global ban on mining? On wallets? On exchange?

The Bitcoin defense against a patent is to ignore the patent. Berating
people for doing so seems entirely counterproductive.

e

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170530/5be3c7bc/attachment.sig>

From jacob.eliosoff at gmail.com  Wed May 31 03:07:43 2017
From: jacob.eliosoff at gmail.com (Jacob Eliosoff)
Date: Tue, 30 May 2017 23:07:43 -0400
Subject: [bitcoin-dev] Hypothetical 2 MB hardfork to follow BIP148
In-Reply-To: <004E1123-8346-48B6-9BCB-94BAE00EC34B@me.com>
References: <201705232023.40588.luke@dashjr.org>
	<CAJowKgJK9zBkVAM1NyOsjU04gvwV3zGnk+1ebfpt6rnbiKy6Og@mail.gmail.com>
	<CABm2gDpet31gEcBY6NTxEG+xA4rvg8_c79L+J=mJySGbf7Ydbg@mail.gmail.com>
	<CAOG=w-uei5-c-Mpp_R6RrN29NTrSV+gpNd79FC3cB6QPG65sEw@mail.gmail.com>
	<CAH+Axy5yYQywpy0s9pBZt_fNoLPpWfra-cU9HrUwH71GDOchsQ@mail.gmail.com>
	<004E1123-8346-48B6-9BCB-94BAE00EC34B@me.com>
Message-ID: <CAAUaCyjbObcb1mJVmeEDmgzNddQCY3QhrHV3fgNbin-ZyqgfeA@mail.gmail.com>

Maybe there's some hole in Jorge's logic and scrapping blockmaxsize has
quadratic hashing risks, and maybe James' 10KB is too ambitious; but even
if so, a simple 1MB tx size limit would clearly do the trick.  The broader
point is that quadratic hashing is not a compelling reason to keep
blockmaxsize post-HF: does someone have a better one?


On May 30, 2017 9:46 PM, "Jean-Paul Kogelman via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> That would invalidate any pre-signed transactions that are currently out
> there. You can't just change the rules out from under people.
>
>
> On May 30, 2017, at 4:50 PM, James MacWhyte via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>
>
>>  The 1MB classic block size prevents quadratic hashing
>> problems from being any worse than they are today.
>>
>>
> Add a transaction-size limit of, say, 10kb and the quadratic hashing
> problem is a non-issue. Donezo.
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170530/a232820b/attachment.html>

