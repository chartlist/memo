From jlrubin at mit.edu  Sun Jan  5 01:58:00 2020
From: jlrubin at mit.edu (Jeremy)
Date: Sat, 4 Jan 2020 17:58:00 -0800
Subject: [bitcoin-dev] OP_CTV Workshop & CFP February 1st, 2020
Message-ID: <CAD5xwhixf+YGNiVZ2kB2zN+s2Wy_BscYVWQVgWXv+LEwrfgMEA@mail.gmail.com>

Dear Bitcoin Developers,

On February 1st, 2020 in San Francisco (location to be shared with
attendees only) I will be hosting a workshop to aid in reviewing and
advancing OP_CHECKTEMPLATEVERIFY.

The workshop will be from 10am-5pm. The basic schedule of events (subject
to change) is in the footer of this email.

If you would like to attend, please fill out the form
https://forms.gle/ex2WLYS319HFdpJYA . We should have capacity for everyone
who wants to come, but I'll need to know by January 15th if you plan to
attend. The primary audience for the event is Bitcoin developers, ecosystem
engineers (i.e., mining pools, wallets, exchanges, etc), and researchers.

If you have research or projects related to OP_CTV you would be interested
in presenting, please indicate in the application form with a brief summary
of your topic.

I may be able to sponsor travel for a few developers who would otherwise be
unable to attend. Please indicate on the form if you require such support.

If you're able to sponsor the event (for lunch/dinner, or for travel
subsidies), please reach out or indicate on the form.

If you cannot attend, I'll make a best effort to make all materials from
the event available online. The channel ##ctv-bip-review is also available
for general discussion about OP_CTV.

Happy New Year!

Jeremy

10:00 AM - 10:30 AM: coffee & registration

BIP SESSION
10:30 AM - 11:00 AM: CTV BIP Design Walkthrough & Basic Motivation
11:00 AM - 11:30 AM: Small Group Discussion & BIP Reading
11:30 AM - 12:00 PM: BIP Q&A

12pm: Lunch

IMPLEMENTATION SESSION
1:00 PM - 1:30 PM: BIP Implementation Walkthrough
1:30 PM - 2:00 PM: Q&A + silent review implementation review time

DEPLOYMENT SESSION
2:00 PM - 2:15 PM: Deployment Plan Proposal
2:15 PM - 2:45 PM: Deployment Plan Discussion

2:45-3pm: BREAK

ECOSYSTEM SUPPORT SESSION
3:00 PM - 3:30 PM: Mempool Updates Presentation & Discussion
3:30 PM - 4:00 PM: Package Relay Informational Updates

DEMO SESSION & APPLICATION TALKS
4:00 PM - 4:10 PM: SENDMANYCOMPACTED Demo
4:10 PM - 4:20 PM: Vault Wallet Demo
4:20 PM: - 4:30 PM: TBA
4:30 PM - 4:40PM: TBA
4:40 PM - 4:50 PM: TBA

WRAP UP
4:50 PM - 5:00 PM

DINNER:
5:00 PM - 7:00 PM Dinner & Drinks


--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200104/c57899f1/attachment.html>

From lf-lists at mattcorallo.com  Fri Jan 10 21:30:09 2020
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Fri, 10 Jan 2020 21:30:09 +0000
Subject: [bitcoin-dev] Modern Soft Fork Activation
Message-ID: <4a132f8a-22e3-8e31-e338-bed9ef46d2ef@mattcorallo.com>

There are a series of soft-fork designs which have recently been making
good progress towards implementation and future adoption. However, for
various reasons, activation methods therefor have gotten limited
discussion. I'd like to reopen that discussion here.

It is likely worth revisiting the goals both for soft forks and their
activation methods to start. I'm probably missing some, but some basic
requirements:

1) Avoid activating in the face of significant, reasonable, and directed
objection. Period. If someone has a well-accepted, reasonable use of
Bitcoin that is working today, have no reason to believe wouldn't work
long into the future without a change, and which would be made
impossible or significantly more difficult by a change, that change must
not happen. I certainly hope there is no objection on this point (see
the last point for an important caveat that I'm sure everyone will jump
to point out).

2) Avoid activating within a timeframe which does not make high
node-level-adoption likely. As with all "node" arguments, I'll note that
I mean "economically-used" nodes, not the thousand or so spy nodes on
Google Cloud and AWS. Rule changes don't make sense without nodes
enforcing them, whether they happen to be a soft fork, hard fork, or a
blue fork, so activating in a reduced timeframe that doesn't allow for
large-scale node adoption doesn't have any value, and may cause other
unintended side effects.

3) Don't (needlessly) lose hashpower to un-upgraded miners. As a part of
Bitcoin's security comes from miners, reducing the hashpower of the
network as a side effect of a rule change is a needless reduction in a
key security parameter of the network. This is why, in recent history,
soft forks required 95% of hashpower to indicate that they have upgraded
and are capable of enforcing the new rules. Further, this is why recent
soft forks have not included changes which would result in a standard
Bitcoin Core instance mining invalid-by-new-rules changes (by relying on
the standardness behavior of Bitcoin Core).

4) Use hashpower enforcement to de-risk the upgrade process, wherever
possible. As a corollary of the above, one of the primary reasons we use
soft forks is that hashpower-based enforcement of rules is an elegant
way to prevent network splits during the node upgrade process. While it
does not make sense to invest material value in systems protected by new
rules until a significant majority of "economic nodes" is enforcing said
rules, hashpower lets us neatly bridge the gap in time between
activation and then. By having a supermajority of miners enforce the new
rules, attempts at violating the new rules does not result in a
significant network split, disrupting existing users of the system. If
we aren't going to take advantage of this, we should do a hard fork
instead, with the necessarily slow timescale that entails.

5) Follow the will of the community, irrespective of individuals or
unreasoned objection, but without ever overruling any reasonable
objection. Recent history also includes "objection" to soft forks in the
form of "this is bad because it doesn't fix a different problem I want
fixed ASAP". I don't think anyone would argue this qualifies as a
reasonable objection to a change, and we should be in a place, as a
community (never as developers or purely one group), to ignore such
objections and make forward progress in spite of them. We don't make
good engineering decisions by "bundling" unrelated features together to
enable political football and compromise.

I think BIP 9 (plus a well-crafted softfork) pretty effectively checks
the boxes for #2-4 here, and when done carefully with lots of community
engagement and measurement, can effectively fulfill #1 as well. #5 is,
as I'm sure everyone is aware, where it starts to fall down pretty hard.

BIP 8 has been proposed as an alternative, largely in response to issues
with #5. However, a naive deployment of it, rather obviously, completely
fails #1, #3, and #4, and, in my view, fails #5 as well by both giving
an impression of, setting a precedent of, and possibly even in practice
increasing the ability of developers to decide the consensus rules of
the system. A BIP 8 deployment that more accurately measures community
support as a prerequisite could arguably fulfill #1 and #5, though I'm
unaware of any concrete proposals on how to accomplish that. Arguably, a
significantly longer activation window could also allow BIP 8 to fulfill
#3 and #4, but only by exploiting the "needlessly" and "wherever
possible" loopholes.

You may note that, from the point of view of achieving the critical
goals here, BIP 8 is only different from a flag-day activation in that,
if it takes the "happy-path" of activating before the flag day, it looks
like BIP 9, but isn't guaranteed to. It additionally has the
"nice-to-have" property that activation can occur before the flag-day in
the case of faster miner adoption, though there is a limit of how fast
is useful due to node adoption.

Thus, to strike a balance between the drawbacks of BIP 8 and BIP 9, the
Great Consensus Cleanup softfork proposal included this text in the
discussion section (with the spec describing a BIP 9 deployment):

> In spite of some suggestion that other activation methods be used, BIP
> 9 is proposed as ensuring miners have upgraded to enforce new rules is
> an important part of minimizing disruption. While previous BIP 9 soft-
> forks have resulted in political contention, this comparatively-
> unimportant soft-fork provides a good opportunity to attempt to return
> to utilizing BIP 9 to ensure miner upgrade prior to activation, which
> the authors believe is a critical goal. However, if there is broad
> agreement to activate these rules when the BIP 9 expiry time is
> reached, and miners have not yet signaled sufficient level of
> readiness, a later flag-day activation may be merited. For this
> reason, implementations may wish to provide a compatibility option
> which allows flag-day enforcement of these rules without an update.

Ultimately, through admittedly rather limited discussion, I still like
this model (though I cannot claim it as my own, the original proposal
came from Greg Maxwell). BIP 9 only falls apart in case of unreasonable
objection, which, naturally, should carry a high bar to ignore, given we
have to have some level of agreement that it is, in fact, unreasonable
(or untargeted). While I admit this is a possibility, I both find it
less likely than in previous soft-forks, and even if it is the case, it
only slows down the process, it doesn't necessarily stop it. In the case
that it does fail, BIP 9 process, in fact, provides a good learning
opportunity as to the level of community readiness and desire for a
given change. While we can (and should, and are) learning a lot about
community readiness for, and acceptability of a change through outreach
and discussion, there is something about a change with a timeframe that
forces people to more carefully consider it.

Thus, as something a bit more concrete, I think an activation method
which sets the right precedent and appropriately considers the above
goals, would be:

1) a standard BIP 9 deployment with a one-year time horizon for
activation with 95% miner readiness,
2) in the case that no activation occurs within a year, a six month
quieting period during which the community can analyze and discussion
the reasons for no activation and,
3) in the case that it makes sense, a simple command-line/bitcoin.conf
parameter which was supported since the original deployment release
would enable users to opt into a BIP 8 deployment with a 24-month
time-horizon for flag-day activation (as well as a new Bitcoin Core
release enabling the flag universally).

This provides a very long time horizon for more standard activation,
while still ensuring the goals in #5 are met, even if, in those cases,
the time horizon needs to be significantly extended to meet the goals of
#3. Developing Bitcoin is not a race. If we have to, waiting 42 months
ensures we're not setting a negative precedent that we'll come to regret
as Bitcoin continues to grow.

Matt

Thanks also to AJ for feedback on an earlier version of this rant.

From jtimon at jtimon.cc  Fri Jan 10 22:21:51 2020
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Fri, 10 Jan 2020 23:21:51 +0100
Subject: [bitcoin-dev] Modern Soft Fork Activation
In-Reply-To: <4a132f8a-22e3-8e31-e338-bed9ef46d2ef@mattcorallo.com>
References: <4a132f8a-22e3-8e31-e338-bed9ef46d2ef@mattcorallo.com>
Message-ID: <CABm2gDq3dAFmRkH2J7d7PcN0A6-F+ZOT22YsDpiORDARmpvu9g@mail.gmail.com>

Well, bip9 doesn't only fall apart in case of unreasonable objection,
it also fails simply with miners' apathy.
Anyway, your proposed plan should take care of that case too, I think.
Overall sounds good to me.

Regarding bip8-like activation, luke-jr suggested that instead of
simply activating on date x if failed to do so by miners' signaling, a
consensus rule could require the blocks to signal for activation in
the last activation window.
I see 2 main advantages for this:

1) Outdated nodes can implement warnings (like in bip9) and they can
see those warnings even if it's activated in the last activation
window. Of course this can become counterproductive if miners' squat
signaling bits for asicboost again.

2) It is easier for users to actively resist a given change they
oppose. Instead of requiring signaling, their nodes can be set to
ignore chains that activate it. This will result in a fork, but if
different groups of users want different things, this is arguably the
best behaviour: a "clean" split.

I assume many people won't like this, but I really think we should
consider how users should ideally resist an unwanted change, even if
the proponents had the best intentions in mind, there may be
legitimate reasons to resist it that they may not have considered.

On Fri, Jan 10, 2020 at 10:30 PM Matt Corallo via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> There are a series of soft-fork designs which have recently been making
> good progress towards implementation and future adoption. However, for
> various reasons, activation methods therefor have gotten limited
> discussion. I'd like to reopen that discussion here.
>
> It is likely worth revisiting the goals both for soft forks and their
> activation methods to start. I'm probably missing some, but some basic
> requirements:
>
> 1) Avoid activating in the face of significant, reasonable, and directed
> objection. Period. If someone has a well-accepted, reasonable use of
> Bitcoin that is working today, have no reason to believe wouldn't work
> long into the future without a change, and which would be made
> impossible or significantly more difficult by a change, that change must
> not happen. I certainly hope there is no objection on this point (see
> the last point for an important caveat that I'm sure everyone will jump
> to point out).
>
> 2) Avoid activating within a timeframe which does not make high
> node-level-adoption likely. As with all "node" arguments, I'll note that
> I mean "economically-used" nodes, not the thousand or so spy nodes on
> Google Cloud and AWS. Rule changes don't make sense without nodes
> enforcing them, whether they happen to be a soft fork, hard fork, or a
> blue fork, so activating in a reduced timeframe that doesn't allow for
> large-scale node adoption doesn't have any value, and may cause other
> unintended side effects.
>
> 3) Don't (needlessly) lose hashpower to un-upgraded miners. As a part of
> Bitcoin's security comes from miners, reducing the hashpower of the
> network as a side effect of a rule change is a needless reduction in a
> key security parameter of the network. This is why, in recent history,
> soft forks required 95% of hashpower to indicate that they have upgraded
> and are capable of enforcing the new rules. Further, this is why recent
> soft forks have not included changes which would result in a standard
> Bitcoin Core instance mining invalid-by-new-rules changes (by relying on
> the standardness behavior of Bitcoin Core).
>
> 4) Use hashpower enforcement to de-risk the upgrade process, wherever
> possible. As a corollary of the above, one of the primary reasons we use
> soft forks is that hashpower-based enforcement of rules is an elegant
> way to prevent network splits during the node upgrade process. While it
> does not make sense to invest material value in systems protected by new
> rules until a significant majority of "economic nodes" is enforcing said
> rules, hashpower lets us neatly bridge the gap in time between
> activation and then. By having a supermajority of miners enforce the new
> rules, attempts at violating the new rules does not result in a
> significant network split, disrupting existing users of the system. If
> we aren't going to take advantage of this, we should do a hard fork
> instead, with the necessarily slow timescale that entails.
>
> 5) Follow the will of the community, irrespective of individuals or
> unreasoned objection, but without ever overruling any reasonable
> objection. Recent history also includes "objection" to soft forks in the
> form of "this is bad because it doesn't fix a different problem I want
> fixed ASAP". I don't think anyone would argue this qualifies as a
> reasonable objection to a change, and we should be in a place, as a
> community (never as developers or purely one group), to ignore such
> objections and make forward progress in spite of them. We don't make
> good engineering decisions by "bundling" unrelated features together to
> enable political football and compromise.
>
> I think BIP 9 (plus a well-crafted softfork) pretty effectively checks
> the boxes for #2-4 here, and when done carefully with lots of community
> engagement and measurement, can effectively fulfill #1 as well. #5 is,
> as I'm sure everyone is aware, where it starts to fall down pretty hard.
>
> BIP 8 has been proposed as an alternative, largely in response to issues
> with #5. However, a naive deployment of it, rather obviously, completely
> fails #1, #3, and #4, and, in my view, fails #5 as well by both giving
> an impression of, setting a precedent of, and possibly even in practice
> increasing the ability of developers to decide the consensus rules of
> the system. A BIP 8 deployment that more accurately measures community
> support as a prerequisite could arguably fulfill #1 and #5, though I'm
> unaware of any concrete proposals on how to accomplish that. Arguably, a
> significantly longer activation window could also allow BIP 8 to fulfill
> #3 and #4, but only by exploiting the "needlessly" and "wherever
> possible" loopholes.
>
> You may note that, from the point of view of achieving the critical
> goals here, BIP 8 is only different from a flag-day activation in that,
> if it takes the "happy-path" of activating before the flag day, it looks
> like BIP 9, but isn't guaranteed to. It additionally has the
> "nice-to-have" property that activation can occur before the flag-day in
> the case of faster miner adoption, though there is a limit of how fast
> is useful due to node adoption.
>
> Thus, to strike a balance between the drawbacks of BIP 8 and BIP 9, the
> Great Consensus Cleanup softfork proposal included this text in the
> discussion section (with the spec describing a BIP 9 deployment):
>
> > In spite of some suggestion that other activation methods be used, BIP
> > 9 is proposed as ensuring miners have upgraded to enforce new rules is
> > an important part of minimizing disruption. While previous BIP 9 soft-
> > forks have resulted in political contention, this comparatively-
> > unimportant soft-fork provides a good opportunity to attempt to return
> > to utilizing BIP 9 to ensure miner upgrade prior to activation, which
> > the authors believe is a critical goal. However, if there is broad
> > agreement to activate these rules when the BIP 9 expiry time is
> > reached, and miners have not yet signaled sufficient level of
> > readiness, a later flag-day activation may be merited. For this
> > reason, implementations may wish to provide a compatibility option
> > which allows flag-day enforcement of these rules without an update.
>
> Ultimately, through admittedly rather limited discussion, I still like
> this model (though I cannot claim it as my own, the original proposal
> came from Greg Maxwell). BIP 9 only falls apart in case of unreasonable
> objection, which, naturally, should carry a high bar to ignore, given we
> have to have some level of agreement that it is, in fact, unreasonable
> (or untargeted). While I admit this is a possibility, I both find it
> less likely than in previous soft-forks, and even if it is the case, it
> only slows down the process, it doesn't necessarily stop it. In the case
> that it does fail, BIP 9 process, in fact, provides a good learning
> opportunity as to the level of community readiness and desire for a
> given change. While we can (and should, and are) learning a lot about
> community readiness for, and acceptability of a change through outreach
> and discussion, there is something about a change with a timeframe that
> forces people to more carefully consider it.
>
> Thus, as something a bit more concrete, I think an activation method
> which sets the right precedent and appropriately considers the above
> goals, would be:
>
> 1) a standard BIP 9 deployment with a one-year time horizon for
> activation with 95% miner readiness,
> 2) in the case that no activation occurs within a year, a six month
> quieting period during which the community can analyze and discussion
> the reasons for no activation and,
> 3) in the case that it makes sense, a simple command-line/bitcoin.conf
> parameter which was supported since the original deployment release
> would enable users to opt into a BIP 8 deployment with a 24-month
> time-horizon for flag-day activation (as well as a new Bitcoin Core
> release enabling the flag universally).
>
> This provides a very long time horizon for more standard activation,
> while still ensuring the goals in #5 are met, even if, in those cases,
> the time horizon needs to be significantly extended to meet the goals of
> #3. Developing Bitcoin is not a race. If we have to, waiting 42 months
> ensures we're not setting a negative precedent that we'll come to regret
> as Bitcoin continues to grow.
>
> Matt
>
> Thanks also to AJ for feedback on an earlier version of this rant.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From lf-lists at mattcorallo.com  Fri Jan 10 22:43:35 2020
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Fri, 10 Jan 2020 17:43:35 -0500
Subject: [bitcoin-dev] Modern Soft Fork Activation
In-Reply-To: <CABm2gDq3dAFmRkH2J7d7PcN0A6-F+ZOT22YsDpiORDARmpvu9g@mail.gmail.com>
References: <CABm2gDq3dAFmRkH2J7d7PcN0A6-F+ZOT22YsDpiORDARmpvu9g@mail.gmail.com>
Message-ID: <A0DE3A1A-CE90-427E-8D61-9F7DBE800532@mattcorallo.com>

I went back and forth with a few folks on this one. I think the fact that we lose goals 3/4 very explicitly in order to nudge miners seems like a poor trade off. I?ll note that your point 2 here seems a bit disconnected to me. If you want to fork yourself off the network, you can do it in easier ways, and if miners want to maliciously censors transactions to the detriment of users, rejecting a version bit doesn?t really help avoid that.

Your point about upgrade warnings is well-made, but I?m dubious of it?s value over the network chaos many large forks might otherwise cause.

Matt

> On Jan 10, 2020, at 17:22, Jorge Tim?n <jtimon at jtimon.cc> wrote:
> 
> ?Well, bip9 doesn't only fall apart in case of unreasonable objection,
> it also fails simply with miners' apathy.
> Anyway, your proposed plan should take care of that case too, I think.
> Overall sounds good to me.
> 
> Regarding bip8-like activation, luke-jr suggested that instead of
> simply activating on date x if failed to do so by miners' signaling, a
> consensus rule could require the blocks to signal for activation in
> the last activation window.
> I see 2 main advantages for this:
> 
> 1) Outdated nodes can implement warnings (like in bip9) and they can
> see those warnings even if it's activated in the last activation
> window. Of course this can become counterproductive if miners' squat
> signaling bits for asicboost again.
> 
> 2) It is easier for users to actively resist a given change they
> oppose. Instead of requiring signaling, their nodes can be set to
> ignore chains that activate it. This will result in a fork, but if
> different groups of users want different things, this is arguably the
> best behaviour: a "clean" split.
> 
> I assume many people won't like this, but I really think we should
> consider how users should ideally resist an unwanted change, even if
> the proponents had the best intentions in mind, there may be
> legitimate reasons to resist it that they may not have considered.
> 
>> On Fri, Jan 10, 2020 at 10:30 PM Matt Corallo via bitcoin-dev
>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> 
>> There are a series of soft-fork designs which have recently been making
>> good progress towards implementation and future adoption. However, for
>> various reasons, activation methods therefor have gotten limited
>> discussion. I'd like to reopen that discussion here.
>> 
>> It is likely worth revisiting the goals both for soft forks and their
>> activation methods to start. I'm probably missing some, but some basic
>> requirements:
>> 
>> 1) Avoid activating in the face of significant, reasonable, and directed
>> objection. Period. If someone has a well-accepted, reasonable use of
>> Bitcoin that is working today, have no reason to believe wouldn't work
>> long into the future without a change, and which would be made
>> impossible or significantly more difficult by a change, that change must
>> not happen. I certainly hope there is no objection on this point (see
>> the last point for an important caveat that I'm sure everyone will jump
>> to point out).
>> 
>> 2) Avoid activating within a timeframe which does not make high
>> node-level-adoption likely. As with all "node" arguments, I'll note that
>> I mean "economically-used" nodes, not the thousand or so spy nodes on
>> Google Cloud and AWS. Rule changes don't make sense without nodes
>> enforcing them, whether they happen to be a soft fork, hard fork, or a
>> blue fork, so activating in a reduced timeframe that doesn't allow for
>> large-scale node adoption doesn't have any value, and may cause other
>> unintended side effects.
>> 
>> 3) Don't (needlessly) lose hashpower to un-upgraded miners. As a part of
>> Bitcoin's security comes from miners, reducing the hashpower of the
>> network as a side effect of a rule change is a needless reduction in a
>> key security parameter of the network. This is why, in recent history,
>> soft forks required 95% of hashpower to indicate that they have upgraded
>> and are capable of enforcing the new rules. Further, this is why recent
>> soft forks have not included changes which would result in a standard
>> Bitcoin Core instance mining invalid-by-new-rules changes (by relying on
>> the standardness behavior of Bitcoin Core).
>> 
>> 4) Use hashpower enforcement to de-risk the upgrade process, wherever
>> possible. As a corollary of the above, one of the primary reasons we use
>> soft forks is that hashpower-based enforcement of rules is an elegant
>> way to prevent network splits during the node upgrade process. While it
>> does not make sense to invest material value in systems protected by new
>> rules until a significant majority of "economic nodes" is enforcing said
>> rules, hashpower lets us neatly bridge the gap in time between
>> activation and then. By having a supermajority of miners enforce the new
>> rules, attempts at violating the new rules does not result in a
>> significant network split, disrupting existing users of the system. If
>> we aren't going to take advantage of this, we should do a hard fork
>> instead, with the necessarily slow timescale that entails.
>> 
>> 5) Follow the will of the community, irrespective of individuals or
>> unreasoned objection, but without ever overruling any reasonable
>> objection. Recent history also includes "objection" to soft forks in the
>> form of "this is bad because it doesn't fix a different problem I want
>> fixed ASAP". I don't think anyone would argue this qualifies as a
>> reasonable objection to a change, and we should be in a place, as a
>> community (never as developers or purely one group), to ignore such
>> objections and make forward progress in spite of them. We don't make
>> good engineering decisions by "bundling" unrelated features together to
>> enable political football and compromise.
>> 
>> I think BIP 9 (plus a well-crafted softfork) pretty effectively checks
>> the boxes for #2-4 here, and when done carefully with lots of community
>> engagement and measurement, can effectively fulfill #1 as well. #5 is,
>> as I'm sure everyone is aware, where it starts to fall down pretty hard.
>> 
>> BIP 8 has been proposed as an alternative, largely in response to issues
>> with #5. However, a naive deployment of it, rather obviously, completely
>> fails #1, #3, and #4, and, in my view, fails #5 as well by both giving
>> an impression of, setting a precedent of, and possibly even in practice
>> increasing the ability of developers to decide the consensus rules of
>> the system. A BIP 8 deployment that more accurately measures community
>> support as a prerequisite could arguably fulfill #1 and #5, though I'm
>> unaware of any concrete proposals on how to accomplish that. Arguably, a
>> significantly longer activation window could also allow BIP 8 to fulfill
>> #3 and #4, but only by exploiting the "needlessly" and "wherever
>> possible" loopholes.
>> 
>> You may note that, from the point of view of achieving the critical
>> goals here, BIP 8 is only different from a flag-day activation in that,
>> if it takes the "happy-path" of activating before the flag day, it looks
>> like BIP 9, but isn't guaranteed to. It additionally has the
>> "nice-to-have" property that activation can occur before the flag-day in
>> the case of faster miner adoption, though there is a limit of how fast
>> is useful due to node adoption.
>> 
>> Thus, to strike a balance between the drawbacks of BIP 8 and BIP 9, the
>> Great Consensus Cleanup softfork proposal included this text in the
>> discussion section (with the spec describing a BIP 9 deployment):
>> 
>>> In spite of some suggestion that other activation methods be used, BIP
>>> 9 is proposed as ensuring miners have upgraded to enforce new rules is
>>> an important part of minimizing disruption. While previous BIP 9 soft-
>>> forks have resulted in political contention, this comparatively-
>>> unimportant soft-fork provides a good opportunity to attempt to return
>>> to utilizing BIP 9 to ensure miner upgrade prior to activation, which
>>> the authors believe is a critical goal. However, if there is broad
>>> agreement to activate these rules when the BIP 9 expiry time is
>>> reached, and miners have not yet signaled sufficient level of
>>> readiness, a later flag-day activation may be merited. For this
>>> reason, implementations may wish to provide a compatibility option
>>> which allows flag-day enforcement of these rules without an update.
>> 
>> Ultimately, through admittedly rather limited discussion, I still like
>> this model (though I cannot claim it as my own, the original proposal
>> came from Greg Maxwell). BIP 9 only falls apart in case of unreasonable
>> objection, which, naturally, should carry a high bar to ignore, given we
>> have to have some level of agreement that it is, in fact, unreasonable
>> (or untargeted). While I admit this is a possibility, I both find it
>> less likely than in previous soft-forks, and even if it is the case, it
>> only slows down the process, it doesn't necessarily stop it. In the case
>> that it does fail, BIP 9 process, in fact, provides a good learning
>> opportunity as to the level of community readiness and desire for a
>> given change. While we can (and should, and are) learning a lot about
>> community readiness for, and acceptability of a change through outreach
>> and discussion, there is something about a change with a timeframe that
>> forces people to more carefully consider it.
>> 
>> Thus, as something a bit more concrete, I think an activation method
>> which sets the right precedent and appropriately considers the above
>> goals, would be:
>> 
>> 1) a standard BIP 9 deployment with a one-year time horizon for
>> activation with 95% miner readiness,
>> 2) in the case that no activation occurs within a year, a six month
>> quieting period during which the community can analyze and discussion
>> the reasons for no activation and,
>> 3) in the case that it makes sense, a simple command-line/bitcoin.conf
>> parameter which was supported since the original deployment release
>> would enable users to opt into a BIP 8 deployment with a 24-month
>> time-horizon for flag-day activation (as well as a new Bitcoin Core
>> release enabling the flag universally).
>> 
>> This provides a very long time horizon for more standard activation,
>> while still ensuring the goals in #5 are met, even if, in those cases,
>> the time horizon needs to be significantly extended to meet the goals of
>> #3. Developing Bitcoin is not a race. If we have to, waiting 42 months
>> ensures we're not setting a negative precedent that we'll come to regret
>> as Bitcoin continues to grow.
>> 
>> Matt
>> 
>> Thanks also to AJ for feedback on an earlier version of this rant.
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From jtimon at jtimon.cc  Fri Jan 10 23:07:00 2020
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Sat, 11 Jan 2020 00:07:00 +0100
Subject: [bitcoin-dev] Modern Soft Fork Activation
In-Reply-To: <A0DE3A1A-CE90-427E-8D61-9F7DBE800532@mattcorallo.com>
References: <CABm2gDq3dAFmRkH2J7d7PcN0A6-F+ZOT22YsDpiORDARmpvu9g@mail.gmail.com>
 <A0DE3A1A-CE90-427E-8D61-9F7DBE800532@mattcorallo.com>
Message-ID: <CABm2gDoCR9JJ=FS1wCy0D3qtFR4=TTMJEDBXNJCo6JG29=Q85Q@mail.gmail.com>

I see how your approach doesn't lose goal 3 while "mine" does.
Regarding goal 4, I don't think any of the approaches loses it. "Use
hashpower enforcement to de-risk the upgrade process, wherever
possible".
Well, in the case of activation while there's "many" non upgrade
miners, they simply can't help to reduce upgrade risks unless they
upgrade. It doesn't matter if the activation is silent or with
mandatory signaling. Am I missing something?

>  in order to nudge miners

That's not the goal at all. All my arguments have been focused on
users, not miners.

> If you want to fork yourself off the network, you can do it in easier ways,

Well, it's not that you want to fork yourself off the network, is that
you don't want change X. Ideally change X wouldn't be activated, but
if it is, you prefer to be in a chain without change X.
Let's say we're using your system to deploy change X you oppose for
legitimate reasons.
What easier thing would you do as a user to resist change X with all
other users who also oppose it?

If there are simpler and better ways to do this, great. It's just
something to think about.





On Fri, Jan 10, 2020 at 11:43 PM Matt Corallo <lf-lists at mattcorallo.com> wrote:
>
> I went back and forth with a few folks on this one. I think the fact that we lose goals 3/4 very explicitly in order to nudge miners seems like a poor trade off. I?ll note that your point 2 here seems a bit disconnected to me. If you want to fork yourself off the network, you can do it in easier ways, and if miners want to maliciously censors transactions to the detriment of users, rejecting a version bit doesn?t really help avoid that.
>
> Your point about upgrade warnings is well-made, but I?m dubious of it?s value over the network chaos many large forks might otherwise cause.
>
> Matt
>
> > On Jan 10, 2020, at 17:22, Jorge Tim?n <jtimon at jtimon.cc> wrote:
> >
> > ?Well, bip9 doesn't only fall apart in case of unreasonable objection,
> > it also fails simply with miners' apathy.
> > Anyway, your proposed plan should take care of that case too, I think.
> > Overall sounds good to me.
> >
> > Regarding bip8-like activation, luke-jr suggested that instead of
> > simply activating on date x if failed to do so by miners' signaling, a
> > consensus rule could require the blocks to signal for activation in
> > the last activation window.
> > I see 2 main advantages for this:
> >
> > 1) Outdated nodes can implement warnings (like in bip9) and they can
> > see those warnings even if it's activated in the last activation
> > window. Of course this can become counterproductive if miners' squat
> > signaling bits for asicboost again.
> >
> > 2) It is easier for users to actively resist a given change they
> > oppose. Instead of requiring signaling, their nodes can be set to
> > ignore chains that activate it. This will result in a fork, but if
> > different groups of users want different things, this is arguably the
> > best behaviour: a "clean" split.
> >
> > I assume many people won't like this, but I really think we should
> > consider how users should ideally resist an unwanted change, even if
> > the proponents had the best intentions in mind, there may be
> > legitimate reasons to resist it that they may not have considered.
> >
> >> On Fri, Jan 10, 2020 at 10:30 PM Matt Corallo via bitcoin-dev
> >> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>
> >> There are a series of soft-fork designs which have recently been making
> >> good progress towards implementation and future adoption. However, for
> >> various reasons, activation methods therefor have gotten limited
> >> discussion. I'd like to reopen that discussion here.
> >>
> >> It is likely worth revisiting the goals both for soft forks and their
> >> activation methods to start. I'm probably missing some, but some basic
> >> requirements:
> >>
> >> 1) Avoid activating in the face of significant, reasonable, and directed
> >> objection. Period. If someone has a well-accepted, reasonable use of
> >> Bitcoin that is working today, have no reason to believe wouldn't work
> >> long into the future without a change, and which would be made
> >> impossible or significantly more difficult by a change, that change must
> >> not happen. I certainly hope there is no objection on this point (see
> >> the last point for an important caveat that I'm sure everyone will jump
> >> to point out).
> >>
> >> 2) Avoid activating within a timeframe which does not make high
> >> node-level-adoption likely. As with all "node" arguments, I'll note that
> >> I mean "economically-used" nodes, not the thousand or so spy nodes on
> >> Google Cloud and AWS. Rule changes don't make sense without nodes
> >> enforcing them, whether they happen to be a soft fork, hard fork, or a
> >> blue fork, so activating in a reduced timeframe that doesn't allow for
> >> large-scale node adoption doesn't have any value, and may cause other
> >> unintended side effects.
> >>
> >> 3) Don't (needlessly) lose hashpower to un-upgraded miners. As a part of
> >> Bitcoin's security comes from miners, reducing the hashpower of the
> >> network as a side effect of a rule change is a needless reduction in a
> >> key security parameter of the network. This is why, in recent history,
> >> soft forks required 95% of hashpower to indicate that they have upgraded
> >> and are capable of enforcing the new rules. Further, this is why recent
> >> soft forks have not included changes which would result in a standard
> >> Bitcoin Core instance mining invalid-by-new-rules changes (by relying on
> >> the standardness behavior of Bitcoin Core).
> >>
> >> 4) Use hashpower enforcement to de-risk the upgrade process, wherever
> >> possible. As a corollary of the above, one of the primary reasons we use
> >> soft forks is that hashpower-based enforcement of rules is an elegant
> >> way to prevent network splits during the node upgrade process. While it
> >> does not make sense to invest material value in systems protected by new
> >> rules until a significant majority of "economic nodes" is enforcing said
> >> rules, hashpower lets us neatly bridge the gap in time between
> >> activation and then. By having a supermajority of miners enforce the new
> >> rules, attempts at violating the new rules does not result in a
> >> significant network split, disrupting existing users of the system. If
> >> we aren't going to take advantage of this, we should do a hard fork
> >> instead, with the necessarily slow timescale that entails.
> >>
> >> 5) Follow the will of the community, irrespective of individuals or
> >> unreasoned objection, but without ever overruling any reasonable
> >> objection. Recent history also includes "objection" to soft forks in the
> >> form of "this is bad because it doesn't fix a different problem I want
> >> fixed ASAP". I don't think anyone would argue this qualifies as a
> >> reasonable objection to a change, and we should be in a place, as a
> >> community (never as developers or purely one group), to ignore such
> >> objections and make forward progress in spite of them. We don't make
> >> good engineering decisions by "bundling" unrelated features together to
> >> enable political football and compromise.
> >>
> >> I think BIP 9 (plus a well-crafted softfork) pretty effectively checks
> >> the boxes for #2-4 here, and when done carefully with lots of community
> >> engagement and measurement, can effectively fulfill #1 as well. #5 is,
> >> as I'm sure everyone is aware, where it starts to fall down pretty hard.
> >>
> >> BIP 8 has been proposed as an alternative, largely in response to issues
> >> with #5. However, a naive deployment of it, rather obviously, completely
> >> fails #1, #3, and #4, and, in my view, fails #5 as well by both giving
> >> an impression of, setting a precedent of, and possibly even in practice
> >> increasing the ability of developers to decide the consensus rules of
> >> the system. A BIP 8 deployment that more accurately measures community
> >> support as a prerequisite could arguably fulfill #1 and #5, though I'm
> >> unaware of any concrete proposals on how to accomplish that. Arguably, a
> >> significantly longer activation window could also allow BIP 8 to fulfill
> >> #3 and #4, but only by exploiting the "needlessly" and "wherever
> >> possible" loopholes.
> >>
> >> You may note that, from the point of view of achieving the critical
> >> goals here, BIP 8 is only different from a flag-day activation in that,
> >> if it takes the "happy-path" of activating before the flag day, it looks
> >> like BIP 9, but isn't guaranteed to. It additionally has the
> >> "nice-to-have" property that activation can occur before the flag-day in
> >> the case of faster miner adoption, though there is a limit of how fast
> >> is useful due to node adoption.
> >>
> >> Thus, to strike a balance between the drawbacks of BIP 8 and BIP 9, the
> >> Great Consensus Cleanup softfork proposal included this text in the
> >> discussion section (with the spec describing a BIP 9 deployment):
> >>
> >>> In spite of some suggestion that other activation methods be used, BIP
> >>> 9 is proposed as ensuring miners have upgraded to enforce new rules is
> >>> an important part of minimizing disruption. While previous BIP 9 soft-
> >>> forks have resulted in political contention, this comparatively-
> >>> unimportant soft-fork provides a good opportunity to attempt to return
> >>> to utilizing BIP 9 to ensure miner upgrade prior to activation, which
> >>> the authors believe is a critical goal. However, if there is broad
> >>> agreement to activate these rules when the BIP 9 expiry time is
> >>> reached, and miners have not yet signaled sufficient level of
> >>> readiness, a later flag-day activation may be merited. For this
> >>> reason, implementations may wish to provide a compatibility option
> >>> which allows flag-day enforcement of these rules without an update.
> >>
> >> Ultimately, through admittedly rather limited discussion, I still like
> >> this model (though I cannot claim it as my own, the original proposal
> >> came from Greg Maxwell). BIP 9 only falls apart in case of unreasonable
> >> objection, which, naturally, should carry a high bar to ignore, given we
> >> have to have some level of agreement that it is, in fact, unreasonable
> >> (or untargeted). While I admit this is a possibility, I both find it
> >> less likely than in previous soft-forks, and even if it is the case, it
> >> only slows down the process, it doesn't necessarily stop it. In the case
> >> that it does fail, BIP 9 process, in fact, provides a good learning
> >> opportunity as to the level of community readiness and desire for a
> >> given change. While we can (and should, and are) learning a lot about
> >> community readiness for, and acceptability of a change through outreach
> >> and discussion, there is something about a change with a timeframe that
> >> forces people to more carefully consider it.
> >>
> >> Thus, as something a bit more concrete, I think an activation method
> >> which sets the right precedent and appropriately considers the above
> >> goals, would be:
> >>
> >> 1) a standard BIP 9 deployment with a one-year time horizon for
> >> activation with 95% miner readiness,
> >> 2) in the case that no activation occurs within a year, a six month
> >> quieting period during which the community can analyze and discussion
> >> the reasons for no activation and,
> >> 3) in the case that it makes sense, a simple command-line/bitcoin.conf
> >> parameter which was supported since the original deployment release
> >> would enable users to opt into a BIP 8 deployment with a 24-month
> >> time-horizon for flag-day activation (as well as a new Bitcoin Core
> >> release enabling the flag universally).
> >>
> >> This provides a very long time horizon for more standard activation,
> >> while still ensuring the goals in #5 are met, even if, in those cases,
> >> the time horizon needs to be significantly extended to meet the goals of
> >> #3. Developing Bitcoin is not a race. If we have to, waiting 42 months
> >> ensures we're not setting a negative precedent that we'll come to regret
> >> as Bitcoin continues to grow.
> >>
> >> Matt
> >>
> >> Thanks also to AJ for feedback on an earlier version of this rant.
> >> _______________________________________________
> >> bitcoin-dev mailing list
> >> bitcoin-dev at lists.linuxfoundation.org
> >> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From luke at dashjr.org  Fri Jan 10 23:37:49 2020
From: luke at dashjr.org (Luke Dashjr)
Date: Fri, 10 Jan 2020 23:37:49 +0000
Subject: [bitcoin-dev] Modern Soft Fork Activation
In-Reply-To: <4a132f8a-22e3-8e31-e338-bed9ef46d2ef@mattcorallo.com>
References: <4a132f8a-22e3-8e31-e338-bed9ef46d2ef@mattcorallo.com>
Message-ID: <202001102337.53397.luke@dashjr.org>

I think BIP 9 is a proven failure, and flag day softforks have their own 
problems:

A) There is no way to unambiguously say "the rules for this chain are 
<x,y,z>". It leaves the chain in a kind of "quantum state" where the rules 
could be one thing, or could be another. Until the new rules are violated, we 
do not know if the softfork was a success or not. Because of this, people 
will rightly shy away from relying on the new rules. This problem is made 
worse by the fact that common node policies might not produce blocks which 
violate the rules. If we had gone with BIP149 for Segwit, it is IMO probable 
we would still not have a clear answer today to "Is Segwit active or not?"

B) Because of (A), there is also no clear way to intentionally reject the 
softfork. Those who do not consent to it are effectively compelled to accept 
it anyway. While it is usually possible to craft an opposing softfork, this 
should IMO be well-defined and simple to do (including a plan to do so in any 
BIP9-alike spec).

For these reasons, in 2017, I proposed revising BIP 8 with a mandatory signal, 
similar to how BIP148 worked: https://github.com/bitcoin/bips/pull/550
However, the author of BIP 8 has since vanished, and because we had no 
immediate softfork plans, efforts to move this forward were abandoned 
temporarily. It seems like a good time to resume this work.

In regard to your goal #3, I would like to note that after the mandatory 
signal period, old miners could resume mining unchanged. This means there is 
a temporary loss of hashrate to the network, but I think it is overall better 
than the alternatives. The temporary loss of income from invalid blocks will 
also give affected miners a last push to upgrade, hopefully improving the 
long run security of the network hashrate.

Luke

(P.S. As for your #1, I do think it is oversimplified in some cases, but we 
should leave that for later discussion when it actually becomes relevant.)



On Friday 10 January 2020 21:30:09 Matt Corallo via bitcoin-dev wrote:
> There are a series of soft-fork designs which have recently been making
> good progress towards implementation and future adoption. However, for
> various reasons, activation methods therefor have gotten limited
> discussion. I'd like to reopen that discussion here.
>
> It is likely worth revisiting the goals both for soft forks and their
> activation methods to start. I'm probably missing some, but some basic
> requirements:
>
> 1) Avoid activating in the face of significant, reasonable, and directed
> objection. Period. If someone has a well-accepted, reasonable use of
> Bitcoin that is working today, have no reason to believe wouldn't work
> long into the future without a change, and which would be made
> impossible or significantly more difficult by a change, that change must
> not happen. I certainly hope there is no objection on this point (see
> the last point for an important caveat that I'm sure everyone will jump
> to point out).
>
> 2) Avoid activating within a timeframe which does not make high
> node-level-adoption likely. As with all "node" arguments, I'll note that
> I mean "economically-used" nodes, not the thousand or so spy nodes on
> Google Cloud and AWS. Rule changes don't make sense without nodes
> enforcing them, whether they happen to be a soft fork, hard fork, or a
> blue fork, so activating in a reduced timeframe that doesn't allow for
> large-scale node adoption doesn't have any value, and may cause other
> unintended side effects.
>
> 3) Don't (needlessly) lose hashpower to un-upgraded miners. As a part of
> Bitcoin's security comes from miners, reducing the hashpower of the
> network as a side effect of a rule change is a needless reduction in a
> key security parameter of the network. This is why, in recent history,
> soft forks required 95% of hashpower to indicate that they have upgraded
> and are capable of enforcing the new rules. Further, this is why recent
> soft forks have not included changes which would result in a standard
> Bitcoin Core instance mining invalid-by-new-rules changes (by relying on
> the standardness behavior of Bitcoin Core).
>
> 4) Use hashpower enforcement to de-risk the upgrade process, wherever
> possible. As a corollary of the above, one of the primary reasons we use
> soft forks is that hashpower-based enforcement of rules is an elegant
> way to prevent network splits during the node upgrade process. While it
> does not make sense to invest material value in systems protected by new
> rules until a significant majority of "economic nodes" is enforcing said
> rules, hashpower lets us neatly bridge the gap in time between
> activation and then. By having a supermajority of miners enforce the new
> rules, attempts at violating the new rules does not result in a
> significant network split, disrupting existing users of the system. If
> we aren't going to take advantage of this, we should do a hard fork
> instead, with the necessarily slow timescale that entails.
>
> 5) Follow the will of the community, irrespective of individuals or
> unreasoned objection, but without ever overruling any reasonable
> objection. Recent history also includes "objection" to soft forks in the
> form of "this is bad because it doesn't fix a different problem I want
> fixed ASAP". I don't think anyone would argue this qualifies as a
> reasonable objection to a change, and we should be in a place, as a
> community (never as developers or purely one group), to ignore such
> objections and make forward progress in spite of them. We don't make
> good engineering decisions by "bundling" unrelated features together to
> enable political football and compromise.
>
> I think BIP 9 (plus a well-crafted softfork) pretty effectively checks
> the boxes for #2-4 here, and when done carefully with lots of community
> engagement and measurement, can effectively fulfill #1 as well. #5 is,
> as I'm sure everyone is aware, where it starts to fall down pretty hard.
>
> BIP 8 has been proposed as an alternative, largely in response to issues
> with #5. However, a naive deployment of it, rather obviously, completely
> fails #1, #3, and #4, and, in my view, fails #5 as well by both giving
> an impression of, setting a precedent of, and possibly even in practice
> increasing the ability of developers to decide the consensus rules of
> the system. A BIP 8 deployment that more accurately measures community
> support as a prerequisite could arguably fulfill #1 and #5, though I'm
> unaware of any concrete proposals on how to accomplish that. Arguably, a
> significantly longer activation window could also allow BIP 8 to fulfill
> #3 and #4, but only by exploiting the "needlessly" and "wherever
> possible" loopholes.
>
> You may note that, from the point of view of achieving the critical
> goals here, BIP 8 is only different from a flag-day activation in that,
> if it takes the "happy-path" of activating before the flag day, it looks
> like BIP 9, but isn't guaranteed to. It additionally has the
> "nice-to-have" property that activation can occur before the flag-day in
> the case of faster miner adoption, though there is a limit of how fast
> is useful due to node adoption.
>
> Thus, to strike a balance between the drawbacks of BIP 8 and BIP 9, the
> Great Consensus Cleanup softfork proposal included this text in the
>
> discussion section (with the spec describing a BIP 9 deployment):
> > In spite of some suggestion that other activation methods be used, BIP
> > 9 is proposed as ensuring miners have upgraded to enforce new rules is
> > an important part of minimizing disruption. While previous BIP 9 soft-
> > forks have resulted in political contention, this comparatively-
> > unimportant soft-fork provides a good opportunity to attempt to return
> > to utilizing BIP 9 to ensure miner upgrade prior to activation, which
> > the authors believe is a critical goal. However, if there is broad
> > agreement to activate these rules when the BIP 9 expiry time is
> > reached, and miners have not yet signaled sufficient level of
> > readiness, a later flag-day activation may be merited. For this
> > reason, implementations may wish to provide a compatibility option
> > which allows flag-day enforcement of these rules without an update.
>
> Ultimately, through admittedly rather limited discussion, I still like
> this model (though I cannot claim it as my own, the original proposal
> came from Greg Maxwell). BIP 9 only falls apart in case of unreasonable
> objection, which, naturally, should carry a high bar to ignore, given we
> have to have some level of agreement that it is, in fact, unreasonable
> (or untargeted). While I admit this is a possibility, I both find it
> less likely than in previous soft-forks, and even if it is the case, it
> only slows down the process, it doesn't necessarily stop it. In the case
> that it does fail, BIP 9 process, in fact, provides a good learning
> opportunity as to the level of community readiness and desire for a
> given change. While we can (and should, and are) learning a lot about
> community readiness for, and acceptability of a change through outreach
> and discussion, there is something about a change with a timeframe that
> forces people to more carefully consider it.
>
> Thus, as something a bit more concrete, I think an activation method
> which sets the right precedent and appropriately considers the above
> goals, would be:
>
> 1) a standard BIP 9 deployment with a one-year time horizon for
> activation with 95% miner readiness,
> 2) in the case that no activation occurs within a year, a six month
> quieting period during which the community can analyze and discussion
> the reasons for no activation and,
> 3) in the case that it makes sense, a simple command-line/bitcoin.conf
> parameter which was supported since the original deployment release
> would enable users to opt into a BIP 8 deployment with a 24-month
> time-horizon for flag-day activation (as well as a new Bitcoin Core
> release enabling the flag universally).
>
> This provides a very long time horizon for more standard activation,
> while still ensuring the goals in #5 are met, even if, in those cases,
> the time horizon needs to be significantly extended to meet the goals of
> #3. Developing Bitcoin is not a race. If we have to, waiting 42 months
> ensures we're not setting a negative precedent that we'll come to regret
> as Bitcoin continues to grow.
>
> Matt
>
> Thanks also to AJ for feedback on an earlier version of this rant.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From jlrubin at mit.edu  Sat Jan 11 00:54:06 2020
From: jlrubin at mit.edu (Jeremy)
Date: Fri, 10 Jan 2020 16:54:06 -0800
Subject: [bitcoin-dev] Modern Soft Fork Activation
In-Reply-To: <202001102337.53397.luke@dashjr.org>
References: <4a132f8a-22e3-8e31-e338-bed9ef46d2ef@mattcorallo.com>
 <202001102337.53397.luke@dashjr.org>
Message-ID: <CAD5xwhjMNtzsEgC515Q3ddy1=K=iMNt-r3CXpg_ctXzWjtNb8g@mail.gmail.com>

It's not at a "directly implementable policy state", but I think you might
be interested in checking out the spork protocol upgrade model I proposed a
while back. https://www.youtube.com/watch?v=J1CP7qbnpqA&feature=youtu.be

It has some interesting properties around the 5 properties you've mentioned.

1) Avoid activating in the face of significant, reasonable, and directed
objection. Period.

Up to miners to orphan spork-activating blocks.

2) Avoid activating within a timeframe which does not make high
node-level-adoption likely.

Mandatory minimum flag day for Spork initiation, statistically
improbable/impossible for even earlier adoption.

3) Don't (needlessly) lose hashpower to un-upgraded miners.

Difficulty adjustments make the missing spork'd block "go away" over time,
the additional difficulty of *not activating* a rejected spork fills in as
an additional PoW.


4) Use hashpower enforcement to de-risk the upgrade process, wherever
possible.

Miners choose to activate or build on activating blocks.

5) Follow the will of the community, irrespective of individuals or
unreasoned objection, but without ever overruling any reasonable
objection.

Honest signalling makes people be forced to "put their money where there
mouth is" on what the community wants.
--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200110/fd51faa2/attachment.html>

From aj at erisian.com.au  Sat Jan 11 14:42:07 2020
From: aj at erisian.com.au (Anthony Towns)
Date: Sun, 12 Jan 2020 00:42:07 +1000
Subject: [bitcoin-dev] Modern Soft Fork Activation
In-Reply-To: <CABm2gDq3dAFmRkH2J7d7PcN0A6-F+ZOT22YsDpiORDARmpvu9g@mail.gmail.com>
 <4a132f8a-22e3-8e31-e338-bed9ef46d2ef@mattcorallo.com>
Message-ID: <20200111144207.5xzspeptstspsbsf@erisian.com.au>

On Fri, Jan 10, 2020 at 09:30:09PM +0000, Matt Corallo via bitcoin-dev wrote:
> 1) a standard BIP 9 deployment with a one-year time horizon for
> activation with 95% miner readiness,
> 2) in the case that no activation occurs within a year, a six month
> quieting period during which the community can analyze and discussion
> the reasons for no activation and,
> 3) in the case that it makes sense, a simple command-line/bitcoin.conf
> parameter which was supported since the original deployment release
> would enable users to opt into a BIP 8 deployment with a 24-month
> time-horizon for flag-day activation (as well as a new Bitcoin Core
> release enabling the flag universally).

FWIW etc, but my perspective on this is that the way we want consensus
changes in Bitcoin to work is:

 - decentralised: we want everyone to be able to participate, in
   designing/promoting/reviewing changes, without decision making
   power getting centralised amongst one group or another

 - technical: we want changes to be judged on their objective technical
   merits; politics and animal spirits and the like are fine, especially
   for working out what to prioritise, but they shouldn't be part of the
   final yes/no decision on consensus changes

 - improvements: changes might not make everyone better off, but we
   don't want changes to screw anyone over either -- pareto
   improvements in economics, "first, do no harm", etc. (if we get this
   right, there's no need to make compromises and bundle multiple
   flawed proposals so that everyone's an equal mix of happy and
   miserable)

In particular, we don't want to misalign skills and responsibilities: it's
fine for developers to judge if a proposal has bugs or technical problems,
but we don't want want developers to have to decide if a proposal is
"sufficiently popular" or "economically sound" and the like, for instance.
Likewise we don't want to have miners or pool operators have to take
responsibility for managing the whole economy, rather than just keeping
their systems running.

So the way I hope this will work out is:

 - investors, industry, people in general work out priorities for what's
   valuable to work on; this is an economic/policy/subjective question,
   that everyone can participate in, and everyone can act on --
   either directly if they're developers who can work on proposals and
   implementations directly, or indirectly by persuading or paying other
   people to work on whatever's important

 - developers work on proposals, designing and implementing them to make
   (some subset of) bitcoin users better off, and to not make anyone worse
   off.

 - if someone discovers a good technical reason why a proposal does make
   people worse off, we don't try to keep pushing the proposal over the
   top of objections, but go back to the drawing board and try to fix
   the problems

 - once we've done as much development as we can, including setting up
   experimental testnet/signet style deployments for testing, we setup a
   deployment. the idea at this point is to make sure the live network
   upgrade works, and to retain the ability to abort if last minute
   problems come up. no doubt some review and testing will be left until
   the last minute and only done here, but *ideally* the focus should be
   on catching errors *well before* this point.

 - as a result, the activation strategy mostly needs to be about ensuring
   that the Bitcoin network stays in consensus, rather than checking
   popularity or voting -- the yes/no decisions should have mostly been
   made earlier already. so we have two strategies for locking in the
   upgrade: either 95%+ of hashpower signals that they've upgraded to
   software that will enforce the changes forever more, _or_ after a
   year of trying to deploy, we fail to find any technical problems,
   and then allow an additional 2.5 years to ensure all node software is
   upgraded to enforce the new rules before locking them in.

The strategy behind the last point is that we need to establish that
there's consensus amongst all of Bitcoin before we commit to a flag day,
and if we've found some method to establish consensus on that, then we're
done -- we've already got consensus, we don't need to put a blockchain
protocol on top of that and signal that we've got consensus. (Activating
via hashpower still needs signalling, because we need to coordinate on
*when* sufficient hashpower has upgraded)

This approach is obviously compatible with BIP-148 or BIP-91 style
forced-signalling UASFs if some upgrade does need to be done urgently
despite miner opposition; the forced signalling just needs to occur during
the BIP-9 or BIP-8 phases, and no during the "quiet period". Probably the
first period of BIP-8 after the quiet period would make the most sense.

But without that, this approach seems very friendly for miners: even
if they don't upgrade, they won't mine invalid blocks (unless the rules
activate and someone else deliberately mines an invalid block and they
build on top of it), and if a change is incompatible with, say 10%
of hashpower, it won't be forced on them for 3.5 years, by which point
it's probably a good bet that everyone's upgrading to a new generation
of mining hardware anyway. But even that's a backstop, because if a
change *is* incompatible with existing mining hardware, that's an easily
describable technical problem that should mean we go back to the drawing
board and fix it, not deploy the change despite the problems. [0]

On Fri, Jan 10, 2020 at 11:21:51PM +0100, Jorge Tim?n via bitcoin-dev wrote:
> Regarding bip8-like activation, luke-jr suggested that [..] a
> consensus rule could require the blocks to signal for activation in
> the last activation window.

FWIW, that had been my (strong) preference too, but I think I'm now
convinced it's not needed/useful.

> I see 2 main advantages for this:
> 1) Outdated nodes can implement warnings (like in bip9) and they can
> see those warnings even if it's activated in the last activation
> window.

The 3.5 year window from BIP-9-starttime to BIP-8-flagday means you'd
have to be using *very* out of date software to need to autodetect
unknown upgrades. If an upgrade starts on 2021-01-01 say, it'd be
supported by 0.21.x, 0.22.0, and 0.23.0 (with bip8 as an opt-in) and
0.24.0, 0.25.0, 0.26.0, 0.27.0, and 0.28.0 (with bip8 as always on)
before flag day activation on 2024-06-01.

0.21.x to 0.23.x could warn if they see potential early BIP-8 activation
via versionbits, and also warn if the flag day date is seen saying "flag
day activation may have happened, please check external sources and
consider upgrading your node software".

So you'd need to be running 0.20.x, released 4 years prior to the
activation to be outdated enough to not get warnings, I think.

> 2) It is easier for users to actively resist a given change they
> oppose. Instead of requiring signaling, their nodes can be set to
> ignore chains that activate it. This will result in a fork, but if
> different groups of users want different things, this is arguably the
> best behaviour: a "clean" split.

If you're knowingly doing a deliberate minority chain split, you'll
almost certainly change the PoW function, and trivially get a clean
split as a result of doing that.

But I think what we want is to move away from consensus decisions being a
"who has the most money/power/hashpower/nodes/reddit-accounts" contest
to being a question of "have we dealt with every reasonable technical
objection?" -- I think that's better for decentralisation in that anyone
can stop a bad proposal without having to be rich/powerful/persuasive,
and better for encouraging constructive contributions. 

The other side to this is that if it's just a matter of resolving
technical problems, then it's also straightforward for a small but skilled
group to get a consensus change through even if the vast majority doesn't
think it's a priority -- they just need to make a good proposal, make
sure it doesn't make people worse off, work through all the objections
people find, and be willing to wait for it to go through reviews and
upgrade steps which may take extra time if other people don't think it's
a high priority. But those are all just technical challenges, that can
be resolved with skill and patience, whoever you might be. So to me,
that's a win for decentralisation as well.

> I assume many people won't like this, but I really think we should
> consider how users should ideally resist an unwanted change, even if
> the proponents had the best intentions in mind, there may be
> legitimate reasons to resist it that they may not have considered.

For me, the focus there is on Matt's first point: "avoid activating
[or merging, or even proposing] in the face of significant, reasonable,
and directed objection". If you want to stop a change you should have to
do nothing more than describe the problems with it; and if there aren't
problems with it, you shouldn't be trying to stop the change.

(A benefit to having the BIP-8 settings defined simultaneously with
the initial activation attempt is that it means that if the core
devs/maintainers go crazy with power and try to force/prevent the BIP-8
activation despite clear community consensus going the other way, then
it will be easy to for the client, and set the parameter correctly --
literally just a matter of changing a value in chainparams.cpp, unlike the
difficulties of changing the blocksize from 1MB to 2MB. Other variations
of this overall approach have the same benefit)

Cheers,
aj (very grateful to Greg and Matt for explaining a lot of thing
    about this approach and helping resolve my concerns with it)

[0] Trigger warning, PTSD over the 2015-2017 blocksize wars...

    The segwit timeline was something like this:

     2015-05 - blocksize debate begins on bitcoin-dev
     2015-08 - bitcoin xt with bip101 hardfork released
     2015-09 - scaling bitcoin phase 1
     2015-12 - segwit proposal at scaling bitcoin phase 2
     2016-01 - segwit testnet launched
     2016-02 - bitcoin classic with bip109 hardfork released
     2016-04 - first release (0.12.1) with a bip9 deployment (csv)
     2016-06 - segwit merged
     2016-07 - csv activated
     2016-10 - first release (0.13.1) with segwit activation params
     2016-11 - segwit activation starttime
     2017-02 - UASF first proposed
     2017-03 - antpool to swith to bitcoin unlimited
     2017-04 - covert ASICBoost vs segwit conflict described
     2017-05 - NY segwit2x agreement, btc1 with bip102 hardfork started
     2017-05 - BIP-91 proposed
     2017-06 - UAHF proposal from bitmain that became BCH
     2017-07 - BIP-91 lockin
     2017-08 - BIP-148 activation
     2017-08 - BCH chainsplit
     2017-08 - segwit lockin and activation
     2017-11 - 2x fork called off; btc1 nodes stall; 2x chain stillborn
     2018-02 - first release (0.16.0) with segwit wallet support

    (That's about 33 months in total, compared to the 24 months we've
    already spent since taproot was first described in Jan 2018, or the
    42 months before flag-day activation in Matt's proposal)

    I don't think that timeline is a good example of how things should
    work, and would call out a few mistakes in particular:

     * too much urgency to increase the blocksize resulting in rushed
       decision making, especially for the hardfork implementations, but
       also for segwit

     * alternative clients attempted to activate forks without
       resolving technical problems (eventually resulting in the btc1
       client stalling prior to the expected hard fork block, eg)

     * a lot of emphasis was on numbers (market share, hashpower, etc)
       rather than technical merits, resulting in a lot of false
       signalling an political meaneuvering

     * the incompatibility between ASICBoost and segwit wasn't noticed
       prior to activation, and wasn't fixed when it was noticed
       (certainly you can justify this as a tit-for-tat response to the
       other errors having been made in bad faith, or as not being a real
       problem because everyone claimed that they weren't doing covert
       ASICBoost, but considered on its own I think the incompatibility
       should have been resolved)

     * the UASF approach had significant potential technical problems
       (potential for long reorgs, p2p network splits) that weren't
       resolved by the time it became active. happily, this was mitigated
       by hashpower enforcement of BIP-148 rules via BIP-91. neither
       BIP-148 or BIP-91 gained enough consensus to be supported in
       bitcoin core though

    I don't personally think we need to fix every problem we had with
    segwit's process -- it eventually mostly worked out okay, after all --
    but I think Matt's approach has a good chance of fixing a lot of
    them, while still leaving us flexibility to deal with whatever new
    problems we come up with in their place.


From peter at coinkite.com  Sat Jan 11 17:29:06 2020
From: peter at coinkite.com (Peter D. Gray)
Date: Sat, 11 Jan 2020 12:29:06 -0500
Subject: [bitcoin-dev] PSBT Addition (BIP 174) for authenticating
	source/output PSBT files
Message-ID: <20200111172906.GO10797@coinkite.com>

## Background

PSBT files in transit are at risk of MiTM changes. This isn't
supposed to matter, but as another layer of defence, I would like
to add two signatures to PSBT files when they are processed by the
PSBT Signer. These additional fields would be optional, and should
pass through existing PSBT processors transparently, assuming they
pass unknown key/values as BIP-174 specifies.

## Additional Key/Values

1) In the PSBT globals section, a signature over the "source" PSBT
file. It would cover all the bytes of the original PSBT file, as
it was received by the Signer. The key used for the signature may
be any one the keys that the Signer applied during its transaction
signing process. (This is flexible so that the Signer can make the
signature at any point in the signing process. On the Coldcard, we
would probably use the first key that we used for signing, so the
first key involved in the first input.)

The "key" of the global value will be pubkey value of the key which
was selected by the Signer.  If its BIP32 derivation is needed for
some reason, that is documented in the input section already.

The "value" will be 65(?) bytes of a standard Bitcoin signature.
The digest (hash) of the source PSBT is not provided, so any tool
that wants to verify this signature will need to have a copy of the
original PSBT. (I see that as a critical feature, not a limitation).

2) In the output section, specifically, the last key/value pair of
the last output of the transaction, I want to add a similar signature,
again signed by one of the keys used in the signing process. This
signature will cover all the bytes of the resulting (signed) PSBT
up to that point. Because it is the last output of the output
section, that signature will be the last few bytes of the PSBT file.
By "appending" the signature in this way, it's easier to validate
and create the signature, without blanking the signature area during
digest step.

## Role-Based View

The above additions can only be made by a PSBT processor in the Signer
role. No-one else has the keys needed. As for the other PSBT roles:

- Any tool that reads in a PSBT and finds a signature in the final output
  section can and should verify it:
    - check signature over a digest of the PSBT file up to the last X bytes
    - file must end at that point, with only the signature following it
    - also check the key used for signature is one of the input's keys

- PSBT processors in the "combining" role, should preserve the
signatures in the global section, accumulating them into the next
PSBT. (Of course they should validate them, if they have the original
PSBT on hand as well, but that's optional and could be done later
in the flow.) The Combiner should always check a signed PSBT was
not modified in transit via the signature in the final output
section, and then strip it out of the combined PSBT.

- At the end of the signing process, the Finalizer should check all
the Signers have worked from the same PSBT file (assuming that's
the flow expected), or the appropriate PSBT if it's a more complex
case. If the Finalizer is working on a file directly from a Signer,
then it can verify the signature in the output section as well.

## Open Questions

For the message digest, I propose simple SHA256(SHA256(bytes of PSBT)).
I'm not sure of the best way to serialize the signature, but to be
consistent with the rest of the file, it should probably be DER-encoded
and variable length.

## Next Steps

I'd like to get two officially-assigned BIP-174 key numbers assigned
for these two signatures, and then I will see that it gets added
into Coldcard's firmware immediately. In time, other tools are
welcome to take advantage of these checks. I will also write a BIP
for this, and/or make an addition to BIP-174.

I think with these changes, and assuming all the tools are verifying
properly, we can shutdown undetectable MiTM changes to PSBT contents.

---
Peter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG: A3A31BAD 5A2A5B10

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 529 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200111/51fab912/attachment.sig>

From dp at simplexum.com  Sat Jan 11 20:17:05 2020
From: dp at simplexum.com (Dmitry Petukhov)
Date: Sun, 12 Jan 2020 01:17:05 +0500
Subject: [bitcoin-dev] PSBT Addition (BIP 174) for authenticating
 source/output PSBT files
In-Reply-To: <20200111172906.GO10797@coinkite.com>
References: <20200111172906.GO10797@coinkite.com>
Message-ID: <20200112011705.6f6102dd@simplexum.com>

I am not sure that this particular task should be done with data
embedded in PSBT itself, and not with some sort of container that
includes PSBT and the authentication information.

The benefit seems to be in reusing PSBT structure for compatibilty, and
this might be a valid way, although I do not agree with some of your
points. I elaborate below:

> 1) In the PSBT globals section, a signature over the "source" PSBT
> file. It would cover all the bytes of the original PSBT file, as
> it was received by the Signer.

The problem of authenticating the contents of PSBT is independent of
the signing action. PSBT might be altered on the path from Creator to
Signer. Therefore you cannot always say that Signer will be an
authority over 'correctness' of PSBT.

> - At the end of the signing process, the Finalizer should check all
> the Signers have worked from the same PSBT file (assuming that's
> the flow expected)

If there is MitM, checking something at Finalizer is likely too
late - the party that can intercept PSBTs can finalize before the
legitimate Finalizer and broadcast the transaction.

Participants can work from the same PSBT file if they all receive the
same PSBT, and not working in chain where next particpant receives
updated PSBT from the previous participant. Otherwise they will need to
either pass two files (original and updated), or work out which fields
(key-value blobs) to remove to get the 'source' PSBT (which might not be
trivial with presense of proprietary and unknown fields). Even if you
know which key-value pairs to remove, there is no requirement for
ordering of the fields, and some signer can serialize them in different
order after dserialize/sign/add-signatures/re-serialize operation.

Introducing additional ordering or other structure requirements over
simple key-value structure will add complexity to PSBT processing, and
adding complexity on such a basic level should have really serious
reasons, because that increases effort required for even basic
implementations and increases chance of bugs.

If there is some authority on the 'correctness' of 'original' PSBT
(all particpants receive same PSBT at the start), particpants should
check the signature by that authority. That authority might use
the key used only for authentication, and not in the tx signing.

If particpants send PSBT in chain after adding their signatures, then
each participant can add their signature to say 'the contents
of PSBT after my updates should match this hash'.

The signatures of previous participants in the chain most likely do not
matter because of difficulty of restoring the contents of PSBT as it
was before the previous particpant, if you do not pass _all_ the PSBTs
(which is excessive). 
 
> 2) In the output section, specifically, the last key/value pair of
> the last output of the transaction, I want to add a similar signature,
> again signed by one of the keys used in the signing process. This
> signature will cover all the bytes of the resulting (signed) PSBT
> up to that point. Because it is the last output of the output
> section, that signature will be the last few bytes of the PSBT file.
> By "appending" the signature in this way, it's easier to validate
> and create the signature, without blanking the signature area during
> digest step.

This will introduce unnecessary higher-level structure to PSBT for the
reasons that I do not find strong enough for the amount of complexity
added.

Also, as I said above, you likely do not need more than one
signature - if this is 'fan-out' scheme, then participants need do
check the sig of authority that created PSBT; if this is piggy-back
chain, then only previous particpant's signature is easily verifiable.

> ## Next Steps
> 
> I'd like to get two officially-assigned BIP-174 key numbers assigned
> for these two signatures, and then I will see that it gets added
> into Coldcard's firmware immediately. In time, other tools are
> welcome to take advantage of these checks. I will also write a BIP
> for this, and/or make an addition to BIP-174.

I think you do not need to wait for officially-assigned key numbers,
and can just implement the scheme you envision with proprietary keys,
document and promote it. Then if it shows its usefulness, it will
either become de-facto standard with your proprietary keys (and
everyone will want to support 'Coldard PSBT auth' or whatever the name),
or the scheme will have serious grounds to be converted to standard and
have non-proprietary keys assigned.

// Dmitry.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 833 bytes
Desc: ???????????????? ?????????????? OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200112/1e8c2cc8/attachment-0001.sig>

From luke at dashjr.org  Sun Jan 12 05:58:33 2020
From: luke at dashjr.org (Luke Dashjr)
Date: Sun, 12 Jan 2020 05:58:33 +0000
Subject: [bitcoin-dev] Modern Soft Fork Activation
In-Reply-To: <20200111144207.5xzspeptstspsbsf@erisian.com.au>
References: <20200111144207.5xzspeptstspsbsf@erisian.com.au>
Message-ID: <202001120558.34256.luke@dashjr.org>

On Saturday 11 January 2020 14:42:07 Anthony Towns wrote:
>  the UASF approach had significant potential technical problems
> ? ? ? ?(potential for long reorgs, p2p network splits) that weren't
> ? ? ? ?resolved by the time it became active.

Long reorgs, only for old nodes, were a possibility, but not a problem.

The p2p network split issues WERE resolved well before activation.
(In fact, Bitcoin Knots still ships with the general p2p fixes.)

> ? ? ? ?neither 
> ? ? ? ?BIP-148 or BIP-91 gained enough consensus to be supported in
> ? ? ? ?bitcoin core though

There was no measurable difference in community support between BIP148 and 
Segwit itself, months before BIP148's activation. (There was about 20% that 
indicated they would support BIP148 "only if Bitcoin Core releases it", which 
IMO "counts" in this context.)

The only difference was in the opinions of developers. Basing the decision to 
exclude BIP148 as even an *option* on this basis was IMO improper and 
shouldn't be repeated. The community's readiness to switch to another 
fork/build for UASFs is also valuable, but shouldn't be necessary.

Luke

From robinlinus at protonmail.com  Sun Jan 12 18:54:57 2020
From: robinlinus at protonmail.com (Robin Linus)
Date: Sun, 12 Jan 2020 18:54:57 +0000
Subject: [bitcoin-dev] Coins: A trustless sidechain protocol
Message-ID: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>

Hi all,

I've been working on a sidechain protocol with no trusted third party. You can find the [whitepaper here](http://coins.github.io/coins.pdf).

Abstract. Coins is a Bitcoin extension designed for payments at scale. We propose an efficient solution to the double-spending problem using a bitcoin-backed proof-of-stake.  Validators vote on sidechain blocks with one-time signatures, forming a record that cannot be changed without destroying their collateral. Every user can become a validator by locking bitcoins. One-time signatures guarantee that validators loose their stake for publishing conflicting histories. Checkpoints can be additionally secured with a bitcoin-backed proof-of-burn. Assuming a rational majority of validators, the sidechain provides safety and liveness. The sidechain?s footprint within bitcoin?s blockchain is minimal. The protocol is a generic consensus mechanism allowing for arbitrary sidechain assets. Spawning multiple, independent instances scales horizontally.

Feedback is highly appreciated!

Thank you

- Robin

PS: [Here on Github you can find further research on scalability and usability](https://github.com/coins/coins.github.io).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200112/10bc934c/attachment.html>

From ZmnSCPxj at protonmail.com  Mon Jan 13 00:21:42 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 13 Jan 2020 00:21:42 +0000
Subject: [bitcoin-dev] Coins: A trustless sidechain protocol
In-Reply-To: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>
References: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>
Message-ID: <Qa9HJ5p2bYnXsjvgcTz-J_stEwJ80SU9UTZF5abv96i5eM_6y3pmy9Bu4tEnFXOc_lBs-y2BFoMh4xOGjl2US56hAFPvxDZM2eyhJkEdBLM=@protonmail.com>

Good morning Robin,

The reason why I stopped considering sidechains for scaling and have since moved to Lightning Network development was that, on reflection, I realized sidechains *still* do not scale, even with stakes anchored on the mainchain.
The issue is that sidechains, like any blockchain, still require that everyone interested in it to propagate all their transaction to everyone else interested in it.
Contrast this with Lightning Network, where you select only a tiny handful of nodes to inform about your payment, even if you have a gigantic Lightning Network.

Or, more blithely: Let me get this straight, you already know blockchains cannot scale, so your scaling proposal involves making ***more*** blockchains?

You might point to the use of large numbers of sidechains with limited userbase, and the use of cross-chain atomic swaps to convert between sidecoins.
I would then point out that Lightning Network channel are cryptocurrency systems with two users (with significantly better security than a 2-user sidechain would have), and that Lightning Network payment routing is just the use of cross-channel atomic swaps to convert between channelcoins.
Indeed, with a multiparticipant offchain updateable cryptocurrency system mechanism, like Decker-Wattenhofer or Decker-Russell-Osuntokun ("eltoo"), you could entirely replace sidechains with a mechanism that does not give custody to your funds to anyone else, since you can always insist on using n-of-n signing with you included in the signer set to prevent state changes that do not have your approval.

---

You could implement the collateral contract with a simple `<one year> OP_CHECKSEQUENCEVERIFY OP_DROP <A> OP_CHECKSIG`, with a single-sign signature used at the consensus layer for your sidechain.
`OP_CHECKSEQUENCEVERIFY` ensures, as a side effect, that the spending transaction opts in to RBF.
Thus, if the pubkey `<A>` is used in a single-sign signature scheme (which reveals the privkey if double-signed), then at the end of the period, anyone who saw the double-signing can claim that fund and thus act as "Bob".
Indeed, many "Bob"s will act and claim this fund, increasing the fee each time to try to get their version onchain.
Eventually, some "Bob" will just put the entire fund as fee and put a measly `OP_RETURN` as single output.
This "burns" the funds by donating it to miners.

>From the point of view of Alice this is hardly distinguishable from losing the fund right now, since Alice will have a vanishingly low chance of spending it after the collateral period ends, and Alice still cannot touch the funds now anyway.
Alice also cannot plausibly bribe a miner, since the miner could always get more funds by replacing the transaction internally with a spend-everything-on-fees `OP_RETURN` output transaction, and can only persuade the miner not to engage in this behavior by offering more than the collateral is worth (which is always worse than just losing the collateral).

A `OP_CHECKTEMPLATEVERIFY` would work better for this use-case, but even without it you do not need a *single* *tr\*sted* Bob to implement the collateral contract.

Regards,
ZmnSCPxj


From ZmnSCPxj at protonmail.com  Mon Jan 13 02:33:21 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 13 Jan 2020 02:33:21 +0000
Subject: [bitcoin-dev] Coins: A trustless sidechain protocol
In-Reply-To: <2mw_wd_ocLESpSG9ST3yJBsJriHf1l5LsdQ2jLamTUUKTMmwUpcjEeohClnMHJl4qjXNW9mHQJiK65jmDHfLG3-nVSRse9PdXnXokGZ2_ac=@protonmail.com>
References: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>
 <Qa9HJ5p2bYnXsjvgcTz-J_stEwJ80SU9UTZF5abv96i5eM_6y3pmy9Bu4tEnFXOc_lBs-y2BFoMh4xOGjl2US56hAFPvxDZM2eyhJkEdBLM=@protonmail.com>
 <2mw_wd_ocLESpSG9ST3yJBsJriHf1l5LsdQ2jLamTUUKTMmwUpcjEeohClnMHJl4qjXNW9mHQJiK65jmDHfLG3-nVSRse9PdXnXokGZ2_ac=@protonmail.com>
Message-ID: <P-QnOpNsFdehy_F3FJgAr0lSJ2xtmT5cwRsEC8VfnIUrSgfNDkLNizm2L1TG65AhKM430tzJ9p33WBnSmJ92ZTKEoaKXCTQzVKrZkH9vtn4=@protonmail.com>

Good morning Robin,


> Good morning ZmnSCPxj,
>
> Thank you for your detailed feedback! Two topics:
>
> Lightning vs Sidechains
>
> ------------------------
>
> Why an either-or-solution, if we can connect sidechains via the LN to get the best of both worlds?
>
> The LN works exceptionally great under the following conditions:
>
> -   you're always online
> -   you have BTC to manage your channels' inbound-capacity
> -   you can afford BTC transactions
>     -   in your channel is much more than the minimum on-chain TX fees
>
>         The next Billion users do not fit that category. They are on unreliable cell phone connections and do not have any BTC yet.
>         And the more popular Bitcoin becomes, the fewer people can afford LN channels. Even Eltoo requires your funds to be significantly higher than Bitcoin's TX fees, right?
>
>         Already today, more and more services like tippin.me, BlueWallet, etc, provide custodial solutions.
>         For small amounts, custody is an acceptable workaround. And I love their usability. Install it and immediately I can send you $0.01. Yet, scaling their approach globally does not lead to desirable outcomes, since we'd be back to trusting banks with their Excel sheets.
>
>         So let's make their internal ledgers public and trustless, via independent sidechains. Decentralized Blockchains do scale decently up to a couple Million UTXOs. So a couple thousand Sidechains is probably sufficient for a global medium of exchange. Cross-chain communication without requiring cross-chain validation is possible via atomic swaps and through Bitcoin's LN. That scales because it separates chain-validators from swap-validators.
>         Bitcoin's LN acts as the central settlement layer for efficient cross-chain transactions between all sidechains.
>
>         So Endusers "living" in sidechains instead of directly in the LN has many advantages:
>
> -   no bitcoin blockspace required for on-boarding new users
> -   no need to lock funds to provide inbound-capacity
> -   no need to stay online or pay watch towers
> -   no need to store channel histories
> -   account balances can be much smaller than BTC TX fees
>
>     Those are the exact same reasons why BlueWallet built their LndHub. But sidechains can be trustless. Also a generic protocol provides flexibility for sidechain innovations with arbitrary digital assets and consensus rules.


Which is why I brought up multiparticipant offchain updateable cryptocurrency systems.
The "channel factories" concepts does what you are looking for, except with better trust-minimization than sidechains can achieve.
Just replace "sidechain" with either Decker-Wattenhofer or Decker-Russell-Osuntokun constructions.
You can even use the Somsen "statechain" mechanism, which rides a Decker-Wattenhofer/Decker-Russell-Osuntokun construction, though its trust-minimization is only very very slightly better than federated sidechains.

It is helpful to remember that Poon-Dryja, Decker-Wattenhofer, Decker-Russell-Osuntokun, and all other future such constructions, can host any contract that its lower layer can support.
So if you ride a Poon-Dryja on top of the Bitcoin blockchain, you can host HTLCs inside the Poon-Dryja, since the Bitcoin blockchain can host HTLCs.
Similarly, if you ride a Decker-Wattenhofer on top of the Bitcoin blockchain, you can host a Poon-Dryja inside the Decker-Wattenhofer, since the Bitcoin blockchain can host Poon-Dryja channels.
This central insight leads one to conclude that anything you can put onchain, you an generally also put offchain, so why use a chain at all except as an ultimate anchor to reality?
Poon-Dryja is strictly two-participant, while Decker-Wattenhofer limits the practical number of updates due to its use of decrementing relative timelocks: so you put the payment layer in a bunch of Poon-Dryja channels which support tons of updates each but only two participants per channel, and create a layer that supports changes to the channel topology (where changes to the channel connectivity are expected to be much rarer than payments) and is multiparticipant so you can *actually* scale.

Instead of using sidechains, just use channel factories.
You do not need to broadcast the entire internal ledgers of those services, only their customers need to know those internal ledgers, and sign off on the updates of those ledgers.

Regards,
ZmnSCPxj

From robinlinus at protonmail.com  Mon Jan 13 02:02:53 2020
From: robinlinus at protonmail.com (Robin Linus)
Date: Mon, 13 Jan 2020 02:02:53 +0000
Subject: [bitcoin-dev] Coins: A trustless sidechain protocol
In-Reply-To: <Qa9HJ5p2bYnXsjvgcTz-J_stEwJ80SU9UTZF5abv96i5eM_6y3pmy9Bu4tEnFXOc_lBs-y2BFoMh4xOGjl2US56hAFPvxDZM2eyhJkEdBLM=@protonmail.com>
References: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>
 <Qa9HJ5p2bYnXsjvgcTz-J_stEwJ80SU9UTZF5abv96i5eM_6y3pmy9Bu4tEnFXOc_lBs-y2BFoMh4xOGjl2US56hAFPvxDZM2eyhJkEdBLM=@protonmail.com>
Message-ID: <2mw_wd_ocLESpSG9ST3yJBsJriHf1l5LsdQ2jLamTUUKTMmwUpcjEeohClnMHJl4qjXNW9mHQJiK65jmDHfLG3-nVSRse9PdXnXokGZ2_ac=@protonmail.com>

Good morning ZmnSCPxj,

Thank you for your detailed feedback! Two topics:



## Lightning vs Sidechains
Why an either-or-solution, if we can connect sidechains via the LN to get the best of both worlds?

The LN works exceptionally great under the following conditions:
- you're always online
- you have BTC to manage your channels' inbound-capacity
- you can afford BTC transactions
	- in your channel is much more than the minimum on-chain TX fees

The next Billion users do not fit that category. They are on unreliable cell phone connections and do not have any BTC yet.
And the more popular Bitcoin becomes, the fewer people can afford LN channels. Even Eltoo requires your funds to be significantly higher than Bitcoin's TX fees, right?

Already today, more and more services like tippin.me, BlueWallet, etc, provide custodial solutions.
For small amounts, custody is an acceptable workaround. And I love their usability. Install it and immediately I can send you $0.01. Yet, scaling their approach globally does not lead to desirable outcomes, since we'd be back to trusting banks with their Excel sheets.

So let's make their internal ledgers public and trustless, via independent sidechains. Decentralized Blockchains do scale decently up to a couple Million UTXOs. So a couple thousand Sidechains is probably sufficient for a global medium of exchange. Cross-chain communication without requiring cross-chain validation is possible via atomic swaps and through Bitcoin's LN. That scales because it separates chain-validators from swap-validators.
Bitcoin's LN acts as the central settlement layer for efficient cross-chain transactions between all sidechains.

So Endusers "living" in sidechains instead of directly in the LN has many advantages:
- no bitcoin blockspace required for on-boarding new users
- no need to lock funds to provide inbound-capacity
- no need to stay online or pay watch towers
- no need to store channel histories
- account balances can be much smaller than BTC TX fees

Those are the exact same reasons why BlueWallet built their LndHub. But sidechains can be trustless. Also a generic protocol provides flexibility for sidechain innovations with arbitrary digital assets and consensus rules.




## Collateral Contract
Thanks for mentioning that! I like the simplicity of your variant! It's better than my workarounds. I'll add it to the paper. However, in the long term, the cleanest solution is to destroy the funds. Giving it to miners assumes Alice does not control much Hash power, which is harder to reason about.


Regards,
robin




??????? Original Message ???????
On Monday, January 13, 2020 1:21 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Robin,
>
> The reason why I stopped considering sidechains for scaling and have since moved to Lightning Network development was that, on reflection, I realized sidechains still do not scale, even with stakes anchored on the mainchain.
> The issue is that sidechains, like any blockchain, still require that everyone interested in it to propagate all their transaction to everyone else interested in it.
> Contrast this with Lightning Network, where you select only a tiny handful of nodes to inform about your payment, even if you have a gigantic Lightning Network.
>
> Or, more blithely: Let me get this straight, you already know blockchains cannot scale, so your scaling proposal involves making more blockchains?
>
> You might point to the use of large numbers of sidechains with limited userbase, and the use of cross-chain atomic swaps to convert between sidecoins.
> I would then point out that Lightning Network channel are cryptocurrency systems with two users (with significantly better security than a 2-user sidechain would have), and that Lightning Network payment routing is just the use of cross-channel atomic swaps to convert between channelcoins.
> Indeed, with a multiparticipant offchain updateable cryptocurrency system mechanism, like Decker-Wattenhofer or Decker-Russell-Osuntokun ("eltoo"), you could entirely replace sidechains with a mechanism that does not give custody to your funds to anyone else, since you can always insist on using n-of-n signing with you included in the signer set to prevent state changes that do not have your approval.
>
>


>
> Regards,
> ZmnSCPxj



From achow101-lists at achow101.com  Mon Jan 13 06:39:28 2020
From: achow101-lists at achow101.com (Andrew Chow)
Date: Mon, 13 Jan 2020 06:39:28 +0000
Subject: [bitcoin-dev] PSBT Addition (BIP 174) for authenticating
	source/output PSBT files
In-Reply-To: <20200112011705.6f6102dd@simplexum.com>
References: <20200111172906.GO10797@coinkite.com>
 <20200112011705.6f6102dd@simplexum.com>
Message-ID: <78dbbce2-0372-2516-489f-ed6e839b1a6f@achow101.com>

I agree with Dimitry. I don't see the point of having the MiTM
protection within the PSBT structure itself, in addition to the fact
that adding new fields is largely unnecessary. In fact, I'm not quite
sure what kind of attack you are trying to defend against with this
proposal.

If there is a MiTM who can modify your PSBT, then they can just modify
the result the signed PSBT to drop the auth signatures. Furthermore, any
modifications to scripts or UTXOs would just result in an invalid
signature, so only time is wasted. But you'll just waste time anyways
when you see a failed auth sig.

Additionally, when a signer processes a PSBT, it will either accept the
PSBT and add a signature for its inputs, or reject it and do nothing.
Given this behavior (and I assume you aren't going to add auth sigs for
rejected PSBTs because that doesn't make any sense), then you already
have a signature there that covers everything your auth signature would
cover. So just verify those signatures instead; for any inputs with
signatures, everything you need to verify them are already there.

Lastly, IMO, if you want MiTM protection, then you should do your
protection with out of band communication. Just PGP sign the PSBT (or
something similar) and send the signature along separately.

Andrew

On 1/11/20 3:17 PM, Dmitry Petukhov via bitcoin-dev wrote:
> 
> I am not sure that this particular task should be done with data
> embedded in PSBT itself, and not with some sort of container that
> includes PSBT and the authentication information.
> 
> The benefit seems to be in reusing PSBT structure for compatibilty, and
> this might be a valid way, although I do not agree with some of your
> points. I elaborate below:
> 
>> 1) In the PSBT globals section, a signature over the "source" PSBT
>> file. It would cover all the bytes of the original PSBT file, as
>> it was received by the Signer.
> 
> The problem of authenticating the contents of PSBT is independent of
> the signing action. PSBT might be altered on the path from Creator to
> Signer. Therefore you cannot always say that Signer will be an
> authority over 'correctness' of PSBT.
> 
>> - At the end of the signing process, the Finalizer should check all
>> the Signers have worked from the same PSBT file (assuming that's
>> the flow expected)
> 
> If there is MitM, checking something at Finalizer is likely too
> late - the party that can intercept PSBTs can finalize before the
> legitimate Finalizer and broadcast the transaction.
> 
> Participants can work from the same PSBT file if they all receive the
> same PSBT, and not working in chain where next particpant receives
> updated PSBT from the previous participant. Otherwise they will need to
> either pass two files (original and updated), or work out which fields
> (key-value blobs) to remove to get the 'source' PSBT (which might not be
> trivial with presense of proprietary and unknown fields). Even if you
> know which key-value pairs to remove, there is no requirement for
> ordering of the fields, and some signer can serialize them in different
> order after dserialize/sign/add-signatures/re-serialize operation.
> 
> Introducing additional ordering or other structure requirements over
> simple key-value structure will add complexity to PSBT processing, and
> adding complexity on such a basic level should have really serious
> reasons, because that increases effort required for even basic
> implementations and increases chance of bugs.
> 
> If there is some authority on the 'correctness' of 'original' PSBT
> (all particpants receive same PSBT at the start), particpants should
> check the signature by that authority. That authority might use
> the key used only for authentication, and not in the tx signing.
> 
> If particpants send PSBT in chain after adding their signatures, then
> each participant can add their signature to say 'the contents
> of PSBT after my updates should match this hash'.
> 
> The signatures of previous participants in the chain most likely do not
> matter because of difficulty of restoring the contents of PSBT as it
> was before the previous particpant, if you do not pass _all_ the PSBTs
> (which is excessive).
> 
>> 2) In the output section, specifically, the last key/value pair of
>> the last output of the transaction, I want to add a similar signature,
>> again signed by one of the keys used in the signing process. This
>> signature will cover all the bytes of the resulting (signed) PSBT
>> up to that point. Because it is the last output of the output
>> section, that signature will be the last few bytes of the PSBT file.
>> By "appending" the signature in this way, it's easier to validate
>> and create the signature, without blanking the signature area during
>> digest step.
> 
> This will introduce unnecessary higher-level structure to PSBT for the
> reasons that I do not find strong enough for the amount of complexity
> added.
> 
> Also, as I said above, you likely do not need more than one
> signature - if this is 'fan-out' scheme, then participants need do
> check the sig of authority that created PSBT; if this is piggy-back
> chain, then only previous particpant's signature is easily verifiable.
> 
>> ## Next Steps
>>
>> I'd like to get two officially-assigned BIP-174 key numbers assigned
>> for these two signatures, and then I will see that it gets added
>> into Coldcard's firmware immediately. In time, other tools are
>> welcome to take advantage of these checks. I will also write a BIP
>> for this, and/or make an addition to BIP-174.
> 
> I think you do not need to wait for officially-assigned key numbers,
> and can just implement the scheme you envision with proprietary keys,
> document and promote it. Then if it shows its usefulness, it will
> either become de-facto standard with your proprietary keys (and
> everyone will want to support 'Coldard PSBT auth' or whatever the name),
> or the scheme will have serious grounds to be converted to standard and
> have non-proprietary keys assigned.
> 
> // Dmitry.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 


From asix at disroot.org  Mon Jan 13 08:34:24 2020
From: asix at disroot.org (Yosef)
Date: Mon, 13 Jan 2020 08:34:24 +0000
Subject: [bitcoin-dev]  Modern Soft Fork Activation
Message-ID: <415e793656ab4326b48d9dc050a85eb8@disroot.org>

tl;dr How about 80% ?

The fallback to BIP-8 makes sense, but it's not a graceful one and we absolutely prefer BIP-9 to succeed. A failure to reach 95% readiness signalling means 2.5 years delay, 3.5 years in total, not yet counting.

95% can prove difficult to achieve. Some % of negligent miners that forget to upgrade is expected. Completing that to 5% is not too difficult for a small malicious minority trying to delay the activation. This is the issue Matt's goal #5 aims to prevent, and while the fallback to BIP-8 helps, BIP-9?s 95% requirement makes it worse by allowing quite a neglected minority to force a dramatic delay. Also note how in such case it would have been better to skip BIP-9 altogether and maybe save 1.5 years.

Matt mentions the 95% requirement under goal #3 "Don't (needlessly) lose hashpower to un-upgraded miners". If that is the trade-off, I'd say 2.5 years delay is worse than a momentary loss of hashrate. The protocol is quiet resilient to hashrate fluctuations and, as others mentioned, at that point miners don?t just signal, but lose coins if they don't upgrade, so the hashpower loss is expected to shortly correct. This also means goal #4 is not really effected.

On Sat Jan 11 14:42:07 UTC 2020, Anthony Towns wrote:

> For me, the focus there is on Matt's first point: "avoid activating [or merging, or even proposing] in the face of significant, reasonable, and directed objection"

I agree, and believe the outreach and review process around taproot are maybe the best we had so far. Notably goal #1 should be mostly satisfied already at merge time, so risking 3.5 years delay after that, seems excessive.

BIP-91 ?Reduced threshold Segwit MASF? was deployed by miners specifically to reduce the 95% requirement down to 80% during the segwit drama. While hopefully taproot won?t produce any such excitements, the events around segwit activation and the weird ?hash wars? meme that later followed ? might encourage some to try similar games again.

The difference between `5% minus apathetic-miners` and `20% minus apathetic-miners` is dramatic and can make such attempts an order of magnitude more difficult.

The taproot process is looking great so far, I feel it will be a mistake to put it on a route that can easily extend to so many years. I suggest keeping Matt?s proposal as is but decrease BIP-9?s 95% threshold down to around 80%.

Yosef

From chris at suredbits.com  Mon Jan 13 12:27:34 2020
From: chris at suredbits.com (Chris Stewart)
Date: Mon, 13 Jan 2020 06:27:34 -0600
Subject: [bitcoin-dev] [Annoucement] Discreet Log Contract Protocol
	Specification
Message-ID: <CAFQwNuz5YtpWZh7UF_b5zVz2gspMnWfdaMRdVhobZSq6pcxybQ@mail.gmail.com>

Hi all,

Suredbits and Crypto Garage have begun to work on a specification for
using discreet
log contracts <https://adiabat.github.io/dlc.pdf> in a safe, private and
interoperable way. We are writing to the mailing list to inform and solicit
feedback for the protocol specification so that we can -- as a community --
agree on a common standard to use Bitcoin oracles.

Our goal is to end up with a set of documents like the BIPs (Bitcoin
Improvement Proposals) and BOLTs (Basis of Lightning Technology) so that
others that wish to use the technology can easily write software to
integrate into the protocol.

A secondary goal of ours is to remain compatible with standards used by
other bitcoin related protocols (like Lightning) so that every future
bitcoin related protocol can reach for a ?toolbox? of agreed standards for
things like funding transactions and closing transactions. We want to avoid
reinventing the wheel where possible and allow for library developers to
re-use software to hook into many bitcoin related protocols.

You can find the specification repository here:

https://github.com/discreetlogcontracts/dlcspecs/

For more information on DLCs:

[1] - https://adiabat.github.io/dlc.pdf

[2] - https://cryptogarage.co.jp/p2pd/

[3] -
https://suredbits.com/discreet-log-contracts-part-1-what-is-a-discreet-log-contract/

[4] -
https://blockstream.com/2019/04/19/en-transacting-bitcoin-based-p2p-derivatives/

[5] - https://dci.mit.edu/smart-contracts

-Chris
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200113/eca4ae73/attachment-0001.html>

From peter at coinkite.com  Mon Jan 13 14:28:17 2020
From: peter at coinkite.com (Peter D. Gray)
Date: Mon, 13 Jan 2020 09:28:17 -0500
Subject: [bitcoin-dev] PSBT Addition (BIP 174) for authenticating
 source/output PSBT files
In-Reply-To: <78dbbce2-0372-2516-489f-ed6e839b1a6f@achow101.com>
References: <20200111172906.GO10797@coinkite.com>
 <20200112011705.6f6102dd@simplexum.com>
 <78dbbce2-0372-2516-489f-ed6e839b1a6f@achow101.com>
Message-ID: <20200113142817.GQ10797@coinkite.com>

Thanks for the useful comments guys. I understand where you are
coming from, but my PoV is from the deep embedded side.

On Mon, Jan 13, 2020 at 06:39:28AM +0000, Andrew Chow wrote:
> ... In fact, I'm not quite
> sure what kind of attack you are trying to defend against with this
> proposal.

I don't have a specific attack in mind, but these signatures, if
adopted by the community at large, will allow detection of-, and
could mitigate damage from-, some broad "bug-classes".

Consider if the PSBT Signer (hardware wallet) has bugs. Perhaps if
you tweak the PSBT in some unnatural way it produces output that
reveals the private key (duplicate k-value perhaps), or corrupts
the display of the transaction in helpful (to the attacker) ways
(typically case: output hidden as change).

Seeing a corrupted file signature would alert you of the attempt
to do this. So maybe you don't transmit the transaction, maybe you
warn the user and so on. What happens next is up to you, but at
least we know something is happening.

There could also be bugs in the Combiner/Finalizer which the MiTM
wants to trigger. Legimate files, signed by the PSBT Signer, will not
contain those attacks, so are "safer" to process, even if your
Combiner's PSBT parser has bugs or is tragically dumb.

It's just another layer of security and confidence, on top of the
existing system-level security (which is already excellent).

> If there is a MiTM who can modify your PSBT, then they can just modify
> the result the signed PSBT to drop the auth signatures.

Yes, the MiTM can remove the signatures. However, if your tools expect
and require the signatures in place, then the feature is working
as intended, because the user will be alerted to the funny-business.

More importantly: nothing has been lost by implementing the feature,
and Coldcard (and other PSBT Signers) have to be first to implement it.

> ... then you already
> have a signature there that covers everything your auth signature would
> cover. So just verify those signatures instead; for any inputs with

That's just it, when we receive a signed PSBT, at present we don't
know *what* was signed without a complete understanding of the
transaction, the input UTXO (at least syntactially), and PSBT file
contents.  If there are bugs in that understanding (ie. checks we
all know are needed, but no-one actually implemented) then we might
transmit an harmful transaction, or continue to process a file
that has been corrupted-with-intent by a MiTM.

> Lastly, IMO, if you want MiTM protection, then you should do your
> protection with out of band communication. Just PGP sign the PSBT (or
> something similar) and send the signature along separately.

It's fine to say that, but in an embedded environment, with very
limited memory like the Coldcard, PGP isn't an option (signing vs.
signature verification). I want to leverage the existing crypto and
PKI that we already have in play.

> On 1/11/20 3:17 PM, Dmitry Petukhov via bitcoin-dev wrote:
... [many valid points, repeated by Andrew] ...
> > If there is MitM, checking something at Finalizer is likely too
> > late - the party that can intercept PSBTs can finalize before the
> > legitimate Finalizer and broadcast the transaction.

Yes, that is a problem which is proposal does not address. If the
MitM has control over both directions, in and out, then whatever
he or she was trying to do will still happen. Personally, I'm okay
with that as a limition, but using the same signatures features,
and a pre-shared public key between the PSBT Creator and the Signer,
we could block the Signer from looking at MitM'ed files. (The Signer
would require and verify incoming unsigned PSBT to contain the
last-output-section-signature thing.) I'm not planning on supporting
that on the Coldcard (at least not yet), but with the proposed
additions, it is possible to do without further changes to the PSBT
spec.

> > Participants can work from the same PSBT ...
> > either pass two files (original and updated), or work out which fields
> > (key-value blobs) to remove to get the 'source' PSBT (which might not be
> > trivial with presense of proprietary and unknown fields). Even if you
> > know which key-value pairs to remove, there is no requirement for
> > ordering of the fields, and some signer can serialize them in different
> > order after dserialize/sign/add-signatures/re-serialize operation.
...
> > Introducing additional ordering or other structure requirements over
> > simple key-value structure will add complexity to PSBT processing, and
> > adding complexity on such a basic level should have really serious
> > reasons, because that increases effort required for even basic
> > implementations and increases chance of bugs.

I want these signatures to protect against PSBT parsing bugs. That's
why they are byte-level on the whole file contents, and not based
on sub-sections of the file or various fields inside the file. Yes,
there are non-linear PSBT paths that will be difficult or impossible
to support with this approach. I would not expect implementations to
do anything fancy to reconstruct PSBT contents, I think they would
just track the complete file. In most setups today the Creator,
Combiner and Finalizer are the same device, and they are desktop
systems with gigs of memory.

> > If there is some authority on the 'correctness' of 'original' PSBT
> > (all particpants receive same PSBT at the start), particpants should
> > check the signature by that authority. That authority might use
> > the key used only for authentication, and not in the tx signing.

Yes, this can be acheived by pre-sharing a public key with the
Signer (described above). Only signed incoming PSBT's would be
accepted. That key doesn't have anything to do with the blockchain
or value transfer.

> > I think you do not need to wait for officially-assigned key numbers,
> > and can just implement the scheme you envision with proprietary keys,
> > document and promote it. Then if it shows its usefulness, it will
> > either become de-facto standard with your proprietary keys...

Yes, 100% ... but I value the list's feedback, and I would prefer to
start with a legitimate key number which I don't need to change later. It's
a non-breaking change and I wouldn't propose it otherwise.

---
Peter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG: A3A31BAD 5A2A5B10

On Mon, Jan 13, 2020 at 06:39:28AM +0000, Andrew Chow wrote:
> I agree with Dimitry. I don't see the point of having the MiTM
> protection within the PSBT structure itself, in addition to the fact
> that adding new fields is largely unnecessary. In fact, I'm not quite
> sure what kind of attack you are trying to defend against with this
> proposal.
> 
> If there is a MiTM who can modify your PSBT, then they can just modify
> the result the signed PSBT to drop the auth signatures. Furthermore, any
> modifications to scripts or UTXOs would just result in an invalid
> signature, so only time is wasted. But you'll just waste time anyways
> when you see a failed auth sig.
> 
> Additionally, when a signer processes a PSBT, it will either accept the
> PSBT and add a signature for its inputs, or reject it and do nothing.
> Given this behavior (and I assume you aren't going to add auth sigs for
> rejected PSBTs because that doesn't make any sense), then you already
> have a signature there that covers everything your auth signature would
> cover. So just verify those signatures instead; for any inputs with
> signatures, everything you need to verify them are already there.
> 
> Lastly, IMO, if you want MiTM protection, then you should do your
> protection with out of band communication. Just PGP sign the PSBT (or
> something similar) and send the signature along separately.
> 
> Andrew
> 
> On 1/11/20 3:17 PM, Dmitry Petukhov via bitcoin-dev wrote:
> > 
> > I am not sure that this particular task should be done with data
> > embedded in PSBT itself, and not with some sort of container that
> > includes PSBT and the authentication information.
> > 
> > The benefit seems to be in reusing PSBT structure for compatibilty, and
> > this might be a valid way, although I do not agree with some of your
> > points. I elaborate below:
> > 
> >> 1) In the PSBT globals section, a signature over the "source" PSBT
> >> file. It would cover all the bytes of the original PSBT file, as
> >> it was received by the Signer.
> > 
> > The problem of authenticating the contents of PSBT is independent of
> > the signing action. PSBT might be altered on the path from Creator to
> > Signer. Therefore you cannot always say that Signer will be an
> > authority over 'correctness' of PSBT.
> > 
> >> - At the end of the signing process, the Finalizer should check all
> >> the Signers have worked from the same PSBT file (assuming that's
> >> the flow expected)
> > 
> > If there is MitM, checking something at Finalizer is likely too
> > late - the party that can intercept PSBTs can finalize before the
> > legitimate Finalizer and broadcast the transaction.
> > 
> > Participants can work from the same PSBT file if they all receive the
> > same PSBT, and not working in chain where next particpant receives
> > updated PSBT from the previous participant. Otherwise they will need to
> > either pass two files (original and updated), or work out which fields
> > (key-value blobs) to remove to get the 'source' PSBT (which might not be
> > trivial with presense of proprietary and unknown fields). Even if you
> > know which key-value pairs to remove, there is no requirement for
> > ordering of the fields, and some signer can serialize them in different
> > order after dserialize/sign/add-signatures/re-serialize operation.
> > 
> > Introducing additional ordering or other structure requirements over
> > simple key-value structure will add complexity to PSBT processing, and
> > adding complexity on such a basic level should have really serious
> > reasons, because that increases effort required for even basic
> > implementations and increases chance of bugs.
> > 
> > If there is some authority on the 'correctness' of 'original' PSBT
> > (all particpants receive same PSBT at the start), particpants should
> > check the signature by that authority. That authority might use
> > the key used only for authentication, and not in the tx signing.
> > 
> > If particpants send PSBT in chain after adding their signatures, then
> > each participant can add their signature to say 'the contents
> > of PSBT after my updates should match this hash'.
> > 
> > The signatures of previous participants in the chain most likely do not
> > matter because of difficulty of restoring the contents of PSBT as it
> > was before the previous particpant, if you do not pass _all_ the PSBTs
> > (which is excessive).
> > 
> >> 2) In the output section, specifically, the last key/value pair of
> >> the last output of the transaction, I want to add a similar signature,
> >> again signed by one of the keys used in the signing process. This
> >> signature will cover all the bytes of the resulting (signed) PSBT
> >> up to that point. Because it is the last output of the output
> >> section, that signature will be the last few bytes of the PSBT file.
> >> By "appending" the signature in this way, it's easier to validate
> >> and create the signature, without blanking the signature area during
> >> digest step.
> > 
> > This will introduce unnecessary higher-level structure to PSBT for the
> > reasons that I do not find strong enough for the amount of complexity
> > added.
> > 
> > Also, as I said above, you likely do not need more than one
> > signature - if this is 'fan-out' scheme, then participants need do
> > check the sig of authority that created PSBT; if this is piggy-back
> > chain, then only previous particpant's signature is easily verifiable.
> > 
> >> ## Next Steps
> >>
> >> I'd like to get two officially-assigned BIP-174 key numbers assigned
> >> for these two signatures, and then I will see that it gets added
> >> into Coldcard's firmware immediately. In time, other tools are
> >> welcome to take advantage of these checks. I will also write a BIP
> >> for this, and/or make an addition to BIP-174.
> > 
> > I think you do not need to wait for officially-assigned key numbers,
> > and can just implement the scheme you envision with proprietary keys,
> > document and promote it. Then if it shows its usefulness, it will
> > either become de-facto standard with your proprietary keys (and
> > everyone will want to support 'Coldard PSBT auth' or whatever the name),
> > or the scheme will have serious grounds to be converted to standard and
> > have non-proprietary keys assigned.
> > 
> > // Dmitry.
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> > 
> 
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 529 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200113/2ad4e27c/attachment-0001.sig>

From achow101-lists at achow101.com  Mon Jan 13 17:05:10 2020
From: achow101-lists at achow101.com (Andrew Chow)
Date: Mon, 13 Jan 2020 17:05:10 +0000
Subject: [bitcoin-dev] PSBT Addition (BIP 174) for authenticating
	source/output PSBT files
In-Reply-To: <20200113142817.GQ10797@coinkite.com>
References: <20200111172906.GO10797@coinkite.com>
 <20200112011705.6f6102dd@simplexum.com>
 <78dbbce2-0372-2516-489f-ed6e839b1a6f@achow101.com>
 <20200113142817.GQ10797@coinkite.com>
Message-ID: <4adabcd3-e2ce-d143-0193-8a8581a318aa@achow101.com>


On 1/13/20 9:28 AM, Peter D. Gray wrote:
> I don't have a specific attack in mind, but these signatures, if
> adopted by the community at large, will allow detection of-, and
> could mitigate damage from-, some broad "bug-classes".
> 
> Consider if the PSBT Signer (hardware wallet) has bugs. Perhaps if
> you tweak the PSBT in some unnatural way it produces output that
> reveals the private key (duplicate k-value perhaps), or corrupts
> the display of the transaction in helpful (to the attacker) ways
> (typically case: output hidden as change).

Since the PSBT is to be signed by one of the Signers for the PSBT, I
don't see how this is useful. If it is mutated and the signer has bugs,
especially parsing bugs, the Signer also adding its signature won't
help. In your proposal, it is the Signer who adds the signature, so it
will receive a PSBT without auth sigs and thus that could be mutated to
trigger those bugs anyways.

> There could also be bugs in the Combiner/Finalizer which the MiTM
> wants to trigger. Legimate files, signed by the PSBT Signer, will not
> contain those attacks, so are "safer" to process, even if your
> Combiner's PSBT parser has bugs or is tragically dumb.

The job of Combiners is fairly limited and is really just related to
parsing the PSBT into some internal object then shuffling those fields
around. In that case, any bugs an attacker would want to exploit have to
be deserialization bugs, in which case, your auth sigs don't help. The
Combiner still has to deserialize the PSBT to get the signature, then it
needs to re-serialize the PSBT to check that signature. An attacker
could insert bad bytes into the PSBT which causes problems during
deserialization, before the Combiner is able to check the signature.

For Finalizers, since its job is to construct the final
scriptSig/scriptWitness, at worst, all it can do is produce an invalid
transaction. Finalizers don't have access to the private keys so there's
no bug possible that can result in a Finalizer producing a transaction
that reveals the private key.

> 
> That's just it, when we receive a signed PSBT, at present we don't
> know *what* was signed without a complete understanding of the
> transaction, the input UTXO (at least syntactially), and PSBT file
> contents.  If there are bugs in that understanding (ie. checks we
> all know are needed, but no-one actually implemented) then we might
> transmit an harmful transaction, or continue to process a file
> that has been corrupted-with-intent by a MiTM.

ISTM the same is true of your proposal. You need to deserialize the PSBT
and then figure out which fields were "original" and in what order. If
there is a bug in your deserialization, an attacker can still exploit
that. And if there is a bug in your reconstruction of "original", you'll
have false positives.

> It's fine to say that, but in an embedded environment, with very
> limited memory like the Coldcard, PGP isn't an option (signing vs.
> signature verification). I want to leverage the existing crypto and
> PKI that we already have in play.

My point was that you can achieve your MiTM protection by having the
signature separate from the PSBT. You can still make your ECDSA
signature and send it along with the PSBT, and you can do it with fixed
or exchanged keys, no need for parsing the PSBT itself. It can be part
of the transport protocol, not part of the data that is being transferred.

Andrew

> 
>> On 1/11/20 3:17 PM, Dmitry Petukhov via bitcoin-dev wrote:
> ... [many valid points, repeated by Andrew] ...
>>> If there is MitM, checking something at Finalizer is likely too
>>> late - the party that can intercept PSBTs can finalize before the
>>> legitimate Finalizer and broadcast the transaction.
> 
> Yes, that is a problem which is proposal does not address. If the
> MitM has control over both directions, in and out, then whatever
> he or she was trying to do will still happen. Personally, I'm okay
> with that as a limition, but using the same signatures features,
> and a pre-shared public key between the PSBT Creator and the Signer,
> we could block the Signer from looking at MitM'ed files. (The Signer
> would require and verify incoming unsigned PSBT to contain the
> last-output-section-signature thing.) I'm not planning on supporting
> that on the Coldcard (at least not yet), but with the proposed
> additions, it is possible to do without further changes to the PSBT
> spec.
> 
>>> Participants can work from the same PSBT ...
>>> either pass two files (original and updated), or work out which fields
>>> (key-value blobs) to remove to get the 'source' PSBT (which might not be
>>> trivial with presense of proprietary and unknown fields). Even if you
>>> know which key-value pairs to remove, there is no requirement for
>>> ordering of the fields, and some signer can serialize them in different
>>> order after dserialize/sign/add-signatures/re-serialize operation.
> ...
>>> Introducing additional ordering or other structure requirements over
>>> simple key-value structure will add complexity to PSBT processing, and
>>> adding complexity on such a basic level should have really serious
>>> reasons, because that increases effort required for even basic
>>> implementations and increases chance of bugs.
> 
> I want these signatures to protect against PSBT parsing bugs. That's
> why they are byte-level on the whole file contents, and not based
> on sub-sections of the file or various fields inside the file. Yes,
> there are non-linear PSBT paths that will be difficult or impossible
> to support with this approach. I would not expect implementations to
> do anything fancy to reconstruct PSBT contents, I think they would
> just track the complete file. In most setups today the Creator,
> Combiner and Finalizer are the same device, and they are desktop
> systems with gigs of memory.
> 
>>> If there is some authority on the 'correctness' of 'original' PSBT
>>> (all particpants receive same PSBT at the start), particpants should
>>> check the signature by that authority. That authority might use
>>> the key used only for authentication, and not in the tx signing.
> 
> Yes, this can be acheived by pre-sharing a public key with the
> Signer (described above). Only signed incoming PSBT's would be
> accepted. That key doesn't have anything to do with the blockchain
> or value transfer.
> 
>>> I think you do not need to wait for officially-assigned key numbers,
>>> and can just implement the scheme you envision with proprietary keys,
>>> document and promote it. Then if it shows its usefulness, it will
>>> either become de-facto standard with your proprietary keys...
> 
> Yes, 100% ... but I value the list's feedback, and I would prefer to
> start with a legitimate key number which I don't need to change later. It's
> a non-breaking change and I wouldn't propose it otherwise.
> 
> ---
> Peter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG: A3A31BAD 5A2A5B10
> 
> On Mon, Jan 13, 2020 at 06:39:28AM +0000, Andrew Chow wrote:
>> I agree with Dimitry. I don't see the point of having the MiTM
>> protection within the PSBT structure itself, in addition to the fact
>> that adding new fields is largely unnecessary. In fact, I'm not quite
>> sure what kind of attack you are trying to defend against with this
>> proposal.
>>
>> If there is a MiTM who can modify your PSBT, then they can just modify
>> the result the signed PSBT to drop the auth signatures. Furthermore, any
>> modifications to scripts or UTXOs would just result in an invalid
>> signature, so only time is wasted. But you'll just waste time anyways
>> when you see a failed auth sig.
>>
>> Additionally, when a signer processes a PSBT, it will either accept the
>> PSBT and add a signature for its inputs, or reject it and do nothing.
>> Given this behavior (and I assume you aren't going to add auth sigs for
>> rejected PSBTs because that doesn't make any sense), then you already
>> have a signature there that covers everything your auth signature would
>> cover. So just verify those signatures instead; for any inputs with
>> signatures, everything you need to verify them are already there.
>>
>> Lastly, IMO, if you want MiTM protection, then you should do your
>> protection with out of band communication. Just PGP sign the PSBT (or
>> something similar) and send the signature along separately.
>>
>> Andrew
>>
>> On 1/11/20 3:17 PM, Dmitry Petukhov via bitcoin-dev wrote:
>>>
>>> I am not sure that this particular task should be done with data
>>> embedded in PSBT itself, and not with some sort of container that
>>> includes PSBT and the authentication information.
>>>
>>> The benefit seems to be in reusing PSBT structure for compatibilty, and
>>> this might be a valid way, although I do not agree with some of your
>>> points. I elaborate below:
>>>
>>>> 1) In the PSBT globals section, a signature over the "source" PSBT
>>>> file. It would cover all the bytes of the original PSBT file, as
>>>> it was received by the Signer.
>>>
>>> The problem of authenticating the contents of PSBT is independent of
>>> the signing action. PSBT might be altered on the path from Creator to
>>> Signer. Therefore you cannot always say that Signer will be an
>>> authority over 'correctness' of PSBT.
>>>
>>>> - At the end of the signing process, the Finalizer should check all
>>>> the Signers have worked from the same PSBT file (assuming that's
>>>> the flow expected)
>>>
>>> If there is MitM, checking something at Finalizer is likely too
>>> late - the party that can intercept PSBTs can finalize before the
>>> legitimate Finalizer and broadcast the transaction.
>>>
>>> Participants can work from the same PSBT file if they all receive the
>>> same PSBT, and not working in chain where next particpant receives
>>> updated PSBT from the previous participant. Otherwise they will need to
>>> either pass two files (original and updated), or work out which fields
>>> (key-value blobs) to remove to get the 'source' PSBT (which might not be
>>> trivial with presense of proprietary and unknown fields). Even if you
>>> know which key-value pairs to remove, there is no requirement for
>>> ordering of the fields, and some signer can serialize them in different
>>> order after dserialize/sign/add-signatures/re-serialize operation.
>>>
>>> Introducing additional ordering or other structure requirements over
>>> simple key-value structure will add complexity to PSBT processing, and
>>> adding complexity on such a basic level should have really serious
>>> reasons, because that increases effort required for even basic
>>> implementations and increases chance of bugs.
>>>
>>> If there is some authority on the 'correctness' of 'original' PSBT
>>> (all particpants receive same PSBT at the start), particpants should
>>> check the signature by that authority. That authority might use
>>> the key used only for authentication, and not in the tx signing.
>>>
>>> If particpants send PSBT in chain after adding their signatures, then
>>> each participant can add their signature to say 'the contents
>>> of PSBT after my updates should match this hash'.
>>>
>>> The signatures of previous participants in the chain most likely do not
>>> matter because of difficulty of restoring the contents of PSBT as it
>>> was before the previous particpant, if you do not pass _all_ the PSBTs
>>> (which is excessive).
>>>
>>>> 2) In the output section, specifically, the last key/value pair of
>>>> the last output of the transaction, I want to add a similar signature,
>>>> again signed by one of the keys used in the signing process. This
>>>> signature will cover all the bytes of the resulting (signed) PSBT
>>>> up to that point. Because it is the last output of the output
>>>> section, that signature will be the last few bytes of the PSBT file.
>>>> By "appending" the signature in this way, it's easier to validate
>>>> and create the signature, without blanking the signature area during
>>>> digest step.
>>>
>>> This will introduce unnecessary higher-level structure to PSBT for the
>>> reasons that I do not find strong enough for the amount of complexity
>>> added.
>>>
>>> Also, as I said above, you likely do not need more than one
>>> signature - if this is 'fan-out' scheme, then participants need do
>>> check the sig of authority that created PSBT; if this is piggy-back
>>> chain, then only previous particpant's signature is easily verifiable.
>>>
>>>> ## Next Steps
>>>>
>>>> I'd like to get two officially-assigned BIP-174 key numbers assigned
>>>> for these two signatures, and then I will see that it gets added
>>>> into Coldcard's firmware immediately. In time, other tools are
>>>> welcome to take advantage of these checks. I will also write a BIP
>>>> for this, and/or make an addition to BIP-174.
>>>
>>> I think you do not need to wait for officially-assigned key numbers,
>>> and can just implement the scheme you envision with proprietary keys,
>>> document and promote it. Then if it shows its usefulness, it will
>>> either become de-facto standard with your proprietary keys (and
>>> everyone will want to support 'Coldard PSBT auth' or whatever the name),
>>> or the scheme will have serious grounds to be converted to standard and
>>> have non-proprietary keys assigned.
>>>
>>> // Dmitry.
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>


From joachimstr at protonmail.com  Mon Jan 13 17:34:17 2020
From: joachimstr at protonmail.com (=?UTF-8?Q?Joachim_Str=C3=B6mbergson?=)
Date: Mon, 13 Jan 2020 17:34:17 +0000
Subject: [bitcoin-dev] Coins: A trustless sidechain protocol
In-Reply-To: <P-QnOpNsFdehy_F3FJgAr0lSJ2xtmT5cwRsEC8VfnIUrSgfNDkLNizm2L1TG65AhKM430tzJ9p33WBnSmJ92ZTKEoaKXCTQzVKrZkH9vtn4=@protonmail.com>
References: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>
 <Qa9HJ5p2bYnXsjvgcTz-J_stEwJ80SU9UTZF5abv96i5eM_6y3pmy9Bu4tEnFXOc_lBs-y2BFoMh4xOGjl2US56hAFPvxDZM2eyhJkEdBLM=@protonmail.com>
 <2mw_wd_ocLESpSG9ST3yJBsJriHf1l5LsdQ2jLamTUUKTMmwUpcjEeohClnMHJl4qjXNW9mHQJiK65jmDHfLG3-nVSRse9PdXnXokGZ2_ac=@protonmail.com>
 <P-QnOpNsFdehy_F3FJgAr0lSJ2xtmT5cwRsEC8VfnIUrSgfNDkLNizm2L1TG65AhKM430tzJ9p33WBnSmJ92ZTKEoaKXCTQzVKrZkH9vtn4=@protonmail.com>
Message-ID: <-8y3dnfO2vpyLPeOF5scfp0c5AZd9FF-_xkr1jL2iT1j02fSMJHix2YQupuOeBRF9v5icwGQbriKFXqd5B1AusZp0X7ENOvQ_q4OGCazueU=@protonmail.com>

> Instead of using sidechains, just use channel factories.

I am not familiar enough with the latest advancements in this field. Is it possible using LN/channel factories to achieve off-line-like participation user experience without previous registration with any kind of gateway provider? For example, can you go online, join the network [somehow instantly], generate address/invoice and then put it somewhere for others to later use it when you are off-line? Can you also participate while being off-line for very long periods of time without relying on third party providers to secure your channels? If not, is using sidechains really equally replaceable with LN/CF constructions?








Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Monday, January 13, 2020 2:33 AM, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Good morning Robin,
>
> > Good morning ZmnSCPxj,
> > Thank you for your detailed feedback! Two topics:
> > Lightning vs Sidechains
> >
> > Why an either-or-solution, if we can connect sidechains via the LN to get the best of both worlds?
> > The LN works exceptionally great under the following conditions:
> >
> > -   you're always online
> >
> > -   you have BTC to manage your channels' inbound-capacity
> >
> > -   you can afford BTC transactions
> >     -   in your channel is much more than the minimum on-chain TX fees
> >         The next Billion users do not fit that category. They are on unreliable cell phone connections and do not have any BTC yet.
> >         And the more popular Bitcoin becomes, the fewer people can afford LN channels. Even Eltoo requires your funds to be significantly higher than Bitcoin's TX fees, right?
> >         Already today, more and more services like tippin.me, BlueWallet, etc, provide custodial solutions.
> >         For small amounts, custody is an acceptable workaround. And I love their usability. Install it and immediately I can send you $0.01. Yet, scaling their approach globally does not lead to desirable outcomes, since we'd be back to trusting banks with their Excel sheets.
> >         So let's make their internal ledgers public and trustless, via independent sidechains. Decentralized Blockchains do scale decently up to a couple Million UTXOs. So a couple thousand Sidechains is probably sufficient for a global medium of exchange. Cross-chain communication without requiring cross-chain validation is possible via atomic swaps and through Bitcoin's LN. That scales because it separates chain-validators from swap-validators.
> >         Bitcoin's LN acts as the central settlement layer for efficient cross-chain transactions between all sidechains.
> >         So Endusers "living" in sidechains instead of directly in the LN has many advantages:
> >
> > -   no bitcoin blockspace required for on-boarding new users
> >
> > -   no need to lock funds to provide inbound-capacity
> >
> > -   no need to stay online or pay watch towers
> >
> > -   no need to store channel histories
> >
> > -   account balances can be much smaller than BTC TX fees
> >     Those are the exact same reasons why BlueWallet built their LndHub. But sidechains can be trustless. Also a generic protocol provides flexibility for sidechain innovations with arbitrary digital assets and consensus rules.
> >
>
> Which is why I brought up multiparticipant offchain updateable cryptocurrency systems.
> The "channel factories" concepts does what you are looking for, except with better trust-minimization than sidechains can achieve.
> Just replace "sidechain" with either Decker-Wattenhofer or Decker-Russell-Osuntokun constructions.
> You can even use the Somsen "statechain" mechanism, which rides a Decker-Wattenhofer/Decker-Russell-Osuntokun construction, though its trust-minimization is only very very slightly better than federated sidechains.
>
> It is helpful to remember that Poon-Dryja, Decker-Wattenhofer, Decker-Russell-Osuntokun, and all other future such constructions, can host any contract that its lower layer can support.
> So if you ride a Poon-Dryja on top of the Bitcoin blockchain, you can host HTLCs inside the Poon-Dryja, since the Bitcoin blockchain can host HTLCs.
> Similarly, if you ride a Decker-Wattenhofer on top of the Bitcoin blockchain, you can host a Poon-Dryja inside the Decker-Wattenhofer, since the Bitcoin blockchain can host Poon-Dryja channels.
> This central insight leads one to conclude that anything you can put onchain, you an generally also put offchain, so why use a chain at all except as an ultimate anchor to reality?
> Poon-Dryja is strictly two-participant, while Decker-Wattenhofer limits the practical number of updates due to its use of decrementing relative timelocks: so you put the payment layer in a bunch of Poon-Dryja channels which support tons of updates each but only two participants per channel, and create a layer that supports changes to the channel topology (where changes to the channel connectivity are expected to be much rarer than payments) and is multiparticipant so you can actually scale.
>
> Instead of using sidechains, just use channel factories.
> You do not need to broadcast the entire internal ledgers of those services, only their customers need to know those internal ledgers, and sign off on the updates of those ledgers.
>
> Regards,
> ZmnSCPxj
>
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From joachimstr at protonmail.com  Mon Jan 13 18:06:17 2020
From: joachimstr at protonmail.com (=?UTF-8?Q?Joachim_Str=C3=B6mbergson?=)
Date: Mon, 13 Jan 2020 18:06:17 +0000
Subject: [bitcoin-dev] Coins: A trustless sidechain protocol
In-Reply-To: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>
References: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>
Message-ID: <ILtIOT_2wq-ld0mk5kPev5mw8RQD6pgzSF_EPuY1PE-mdsy8eJqsCaSU-zIyNZw-4W4p5JtLJs5d451PnHvQly-3V1q225bKmdanMZVOmGE=@protonmail.com>

While I haven't rejected sidechains entirely yet, this particular proposal seems uninteresting, especially for two reasons.

One ? it introduces a new token for each sidechain and suggests atomic swaps to be used for the exchange of the mainchain token with the sidechain token. Such a model seems nonsensical to me because there seems to be excessive number of blockchain projects that can be used similarly just as the sidechain in this proposal. Pick almost any altcoin out there and you can atomic swap it with Bitcoin. The fact that your sidechain is somehow mathematically bound to Bitcoin seems arbitrary because at the end you have a new token and a new issuance model. Therefore this is not extending Bitcoin economy, which is strictly limited by its convergence to zero inflation. This proposal is inflating the supply with a new token, which goes against what many people consider as a pillar of Bitcoin's value proposal. I think if you implement this proposal, you are going not to be considered as a Bitcoin sidechain, but you will be, from certain point of view, indistinguishable from any other altcoin. At the level of my current understanding, the only interesting sidechain model is the [theoretical] one with a two way peg with Bitcoin, preserving the issuance policy of Bitcoin.

Two ? the security of the proposed system seems to be very fragile, unless I have missed something. When I think about sidechains, I expect that it should be possible to create a niche chain which is used by few participants while the security of the chain is somehow guaranteed from its bind to the mainchain. If this was not the case, such a niche sidechain could easily be attacked, even if just stalled/censored for a long period time, with just a small [absolute] investment from an attacker, although this investment might be large if taken relatively to the utility of this niche sidechain. So if we speak concretely about your proposal, you assume honest majority of validators. But in your system the validators come from locking of stake on Bitcoin chain by nodes that are interested in a particular sidechain. If you put this model on a niche chain where only few participants are interested in it, it's trivial for an attacker to be stronger [have more Bitcoin to lock] than all legitimate users together. You should only use honest majority assumption where the scope is global, where it is very hard and very expensive to obtain majority.

Sent with [ProtonMail](https://protonmail.com) Secure Email.

??????? Original Message ???????
On Sunday, January 12, 2020 6:54 PM, Robin Linus via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi all,
>
> I've been working on a sidechain protocol with no trusted third party. You can find the [whitepaper here](http://coins.github.io/coins.pdf).
>
> Abstract. Coins is a Bitcoin extension designed for payments at scale. We propose an efficient solution to the double-spending problem using a bitcoin-backed proof-of-stake.  Validators vote on sidechain blocks with one-time signatures, forming a record that cannot be changed without destroying their collateral. Every user can become a validator by locking bitcoins. One-time signatures guarantee that validators loose their stake for publishing conflicting histories. Checkpoints can be additionally secured with a bitcoin-backed proof-of-burn. Assuming a rational majority of validators, the sidechain provides safety and liveness. The sidechain?s footprint within bitcoin?s blockchain is minimal. The protocol is a generic consensus mechanism allowing for arbitrary sidechain assets. Spawning multiple, independent instances scales horizontally.
>
> Feedback is highly appreciated!
>
> Thank you
>
> - Robin
>
> PS: [Here on Github you can find further research on scalability and usability](https://github.com/coins/coins.github.io).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200113/8ec899cc/attachment-0001.html>

From robinlinus at protonmail.com  Mon Jan 13 19:47:23 2020
From: robinlinus at protonmail.com (Robin Linus)
Date: Mon, 13 Jan 2020 19:47:23 +0000
Subject: [bitcoin-dev] Coins: A trustless sidechain protocol
In-Reply-To: <ILtIOT_2wq-ld0mk5kPev5mw8RQD6pgzSF_EPuY1PE-mdsy8eJqsCaSU-zIyNZw-4W4p5JtLJs5d451PnHvQly-3V1q225bKmdanMZVOmGE=@protonmail.com>
References: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>
 <ILtIOT_2wq-ld0mk5kPev5mw8RQD6pgzSF_EPuY1PE-mdsy8eJqsCaSU-zIyNZw-4W4p5JtLJs5d451PnHvQly-3V1q225bKmdanMZVOmGE=@protonmail.com>
Message-ID: <0RSAH-PjblJV6Q7TGosFHAEdc9QGauCQ_knCzMwcoGdW4Qt49ts-egDkIwM-X_f0RjsPMquwdnmB6spunH379ICEAJQgUH7R1SE8CuZs7pI=@protonmail.com>

Hi Joachim,

Thank you for your detailed feedback!

Regarding Reason #1:
This proposal is less like Bitcoin vs. Altcoins and much more like Ethereum vs. ERC20 tokens, because the derivatives are not in competition with BTC, but depend on it heavily. You support Bitcoin's growth by supporting such a sidechain.
Also, they won't work as separate currencies. For endusers you can abstract away all underlying complexities such that they have to think only in BTC. Exchanges rates can be hidden in TX fees. The sidechain derivatives would be nothing but a means of transfer. The unit of account is still BTC.

Regarding Reason #2:
In the "Limitations" section I discuss the cost of halting the chain:

Time value of locked bitcoins might be too cheap to protect the chain. We can introduce an additional cost and let validators burn bitcoins for every on-chain vote. This is much more robust because there is an ongoing cost for halting the system. Proof-of-burn has recently been formally analysed [16]. The economic implications of burning significant amounts of Bitcoin are questionable. A level of security comparable to Bitcoin requires the system?s BTC burn rate to be equal to Bitcoin?s infaltion rate.

Also remember, time value of Bitcoins is indeed a value. Even without a proof of burn, I'd consider such sidechains much more secure than those custodial lightning wallets which become more and more popular to circumvent the usability hurdles of the LN.

Thanks again,
- Robin

Sent with [ProtonMail](https://protonmail.com) Secure Email.

??????? Original Message ???????
On Monday, January 13, 2020 7:06 PM, Joachim Str?mbergson <joachimstr at protonmail.com> wrote:

> While I haven't rejected sidechains entirely yet, this particular proposal seems uninteresting, especially for two reasons.
>
> One ? it introduces a new token for each sidechain and suggests atomic swaps to be used for the exchange of the mainchain token with the sidechain token. Such a model seems nonsensical to me because there seems to be excessive number of blockchain projects that can be used similarly just as the sidechain in this proposal. Pick almost any altcoin out there and you can atomic swap it with Bitcoin. The fact that your sidechain is somehow mathematically bound to Bitcoin seems arbitrary because at the end you have a new token and a new issuance model. Therefore this is not extending Bitcoin economy, which is strictly limited by its convergence to zero inflation. This proposal is inflating the supply with a new token, which goes against what many people consider as a pillar of Bitcoin's value proposal. I think if you implement this proposal, you are going not to be considered as a Bitcoin sidechain, but you will be, from certain point of view, indistinguishable from any other altcoin. At the level of my current understanding, the only interesting sidechain model is the [theoretical] one with a two way peg with Bitcoin, preserving the issuance policy of Bitcoin.
>
> Two ? the security of the proposed system seems to be very fragile, unless I have missed something. When I think about sidechains, I expect that it should be possible to create a niche chain which is used by few participants while the security of the chain is somehow guaranteed from its bind to the mainchain. If this was not the case, such a niche sidechain could easily be attacked, even if just stalled/censored for a long period time, with just a small [absolute] investment from an attacker, although this investment might be large if taken relatively to the utility of this niche sidechain. So if we speak concretely about your proposal, you assume honest majority of validators. But in your system the validators come from locking of stake on Bitcoin chain by nodes that are interested in a particular sidechain. If you put this model on a niche chain where only few participants are interested in it, it's trivial for an attacker to be stronger [have more Bitcoin to lock] than all legitimate users together. You should only use honest majority assumption where the scope is global, where it is very hard and very expensive to obtain majority.
>
> Sent with [ProtonMail](https://protonmail.com) Secure Email.
>
> ??????? Original Message ???????
> On Sunday, January 12, 2020 6:54 PM, Robin Linus via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Hi all,
>>
>> I've been working on a sidechain protocol with no trusted third party. You can find the [whitepaper here](http://coins.github.io/coins.pdf).
>>
>> Abstract. Coins is a Bitcoin extension designed for payments at scale. We propose an efficient solution to the double-spending problem using a bitcoin-backed proof-of-stake.  Validators vote on sidechain blocks with one-time signatures, forming a record that cannot be changed without destroying their collateral. Every user can become a validator by locking bitcoins. One-time signatures guarantee that validators loose their stake for publishing conflicting histories. Checkpoints can be additionally secured with a bitcoin-backed proof-of-burn. Assuming a rational majority of validators, the sidechain provides safety and liveness. The sidechain?s footprint within bitcoin?s blockchain is minimal. The protocol is a generic consensus mechanism allowing for arbitrary sidechain assets. Spawning multiple, independent instances scales horizontally.
>>
>> Feedback is highly appreciated!
>>
>> Thank you
>>
>> - Robin
>>
>> PS: [Here on Github you can find further research on scalability and usability](https://github.com/coins/coins.github.io).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200113/b82d6658/attachment.html>

From peter at coinkite.com  Mon Jan 13 20:29:11 2020
From: peter at coinkite.com (Peter D. Gray)
Date: Mon, 13 Jan 2020 15:29:11 -0500
Subject: [bitcoin-dev] PSBT Addition (BIP 174) for authenticating
 source/output PSBT files
In-Reply-To: <4adabcd3-e2ce-d143-0193-8a8581a318aa@achow101.com>
References: <20200111172906.GO10797@coinkite.com>
 <20200112011705.6f6102dd@simplexum.com>
 <78dbbce2-0372-2516-489f-ed6e839b1a6f@achow101.com>
 <20200113142817.GQ10797@coinkite.com>
 <4adabcd3-e2ce-d143-0193-8a8581a318aa@achow101.com>
Message-ID: <20200113202911.GC45046@coinkite.com>

> In your proposal, it is the Signer who adds the signature, so it
> will receive a PSBT without auth sigs and thus that could be mutated to
> trigger those bugs anyways.

The Signer may be signing a PSBT that was corrupted by the MitM,
but at least later users of the signed PSBT can detect that occured.
At present, they do not know what the input PSBT content was when
it got to the Signer.

> ... The Combiner still has to deserialize the PSBT to get the signature, then it
> needs to re-serialize the PSBT to check that signature. 

If we use a fixed-width signature, such as just R+S bytes (64 bytes),
and not DER-encoding, then the signature is a fixed distance from
the last byte of the file. A conservative PSBT parser could start
by verifying the signature exists and is valid, before parsing the
rest of the file. (It would need to use the pubkeys from the original
PSBT, which it would ideally have on-hand already to verify the source
PSBT to the Coldcard.)

> For Finalizers, since its job is to construct the final
> scriptSig/scriptWitness, at worst, all it can do is produce an invalid
> transaction. Finalizers don't have access to the private keys so there's
> no bug possible that can result in a Finalizer producing a transaction
> that reveals the private key.

I agree that Finalizers cannot access the Bitcoin private keys, but
they still have stacks that can overflow, buffers that can be overrun
and so on. Perhaps if sighash is not SIGHASH_ALL, there are dangerous
things they can be tricked into... I don't know, but at least we
should make it possible to detect these cases. My goal is detection.

> ISTM the same is true of your proposal. You need to deserialize the PSBT
> and then figure out which fields were "original" and in what order. If
> there is a bug in your deserialization, an attacker can still exploit
> that. And if there is a bug in your reconstruction of "original", you'll
> have false positives.

No, I am not proposing anyone re-construct PSBT's... My proposal
is really only helpful if you have the full original PSBT on hand
(or its digest). For ultimate safety I would recommend checking the
incoming PSBT's signature is valid before parsing it.(If the
signature is fixed-length, see above.)

> My point was that you can achieve your MiTM protection by having the
> signature separate from the PSBT. You can still make your ECDSA
> signature and send it along with the PSBT, and you can do it with fixed
> or exchanged keys, no need for parsing the PSBT itself. It can be part
> of the transport protocol, not part of the data that is being transferred.

In the USB protocol between Coldcard and desktop, we do end-to-end
encryption with a session key picked via diff-hel so we're doing
our best there against MitM. However, our customers love the air-gap
feature which involves lots of sneakernet handling of MicroSD cards.
I don't want to force them into handling paired files, like detacted
signatures, and I was hoping this would be a good way to move the
signatures inside the PSBT files already being moved about.

---
Peter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG: A3A31BAD 5A2A5B10

On Mon, Jan 13, 2020 at 05:05:10PM +0000, Andrew Chow wrote:
> 
> On 1/13/20 9:28 AM, Peter D. Gray wrote:
> > I don't have a specific attack in mind, but these signatures, if
> > adopted by the community at large, will allow detection of-, and
> > could mitigate damage from-, some broad "bug-classes".
> > 
> > Consider if the PSBT Signer (hardware wallet) has bugs. Perhaps if
> > you tweak the PSBT in some unnatural way it produces output that
> > reveals the private key (duplicate k-value perhaps), or corrupts
> > the display of the transaction in helpful (to the attacker) ways
> > (typically case: output hidden as change).
> 
> Since the PSBT is to be signed by one of the Signers for the PSBT, I
> don't see how this is useful. If it is mutated and the signer has bugs,
> especially parsing bugs, the Signer also adding its signature won't
> help. In your proposal, it is the Signer who adds the signature, so it
> will receive a PSBT without auth sigs and thus that could be mutated to
> trigger those bugs anyways.
> 
> > There could also be bugs in the Combiner/Finalizer which the MiTM
> > wants to trigger. Legimate files, signed by the PSBT Signer, will not
> > contain those attacks, so are "safer" to process, even if your
> > Combiner's PSBT parser has bugs or is tragically dumb.
> 
> The job of Combiners is fairly limited and is really just related to
> parsing the PSBT into some internal object then shuffling those fields
> around. In that case, any bugs an attacker would want to exploit have to
> be deserialization bugs, in which case, your auth sigs don't help. The
> Combiner still has to deserialize the PSBT to get the signature, then it
> needs to re-serialize the PSBT to check that signature. An attacker
> could insert bad bytes into the PSBT which causes problems during
> deserialization, before the Combiner is able to check the signature.
> 
> For Finalizers, since its job is to construct the final
> scriptSig/scriptWitness, at worst, all it can do is produce an invalid
> transaction. Finalizers don't have access to the private keys so there's
> no bug possible that can result in a Finalizer producing a transaction
> that reveals the private key.
> 
> > 
> > That's just it, when we receive a signed PSBT, at present we don't
> > know *what* was signed without a complete understanding of the
> > transaction, the input UTXO (at least syntactially), and PSBT file
> > contents.  If there are bugs in that understanding (ie. checks we
> > all know are needed, but no-one actually implemented) then we might
> > transmit an harmful transaction, or continue to process a file
> > that has been corrupted-with-intent by a MiTM.
> 
> ISTM the same is true of your proposal. You need to deserialize the PSBT
> and then figure out which fields were "original" and in what order. If
> there is a bug in your deserialization, an attacker can still exploit
> that. And if there is a bug in your reconstruction of "original", you'll
> have false positives.
> 
> > It's fine to say that, but in an embedded environment, with very
> > limited memory like the Coldcard, PGP isn't an option (signing vs.
> > signature verification). I want to leverage the existing crypto and
> > PKI that we already have in play.
> 
> My point was that you can achieve your MiTM protection by having the
> signature separate from the PSBT. You can still make your ECDSA
> signature and send it along with the PSBT, and you can do it with fixed
> or exchanged keys, no need for parsing the PSBT itself. It can be part
> of the transport protocol, not part of the data that is being transferred.
> 
> Andrew
> 
> > 
> >> On 1/11/20 3:17 PM, Dmitry Petukhov via bitcoin-dev wrote:
> > ... [many valid points, repeated by Andrew] ...
> >>> If there is MitM, checking something at Finalizer is likely too
> >>> late - the party that can intercept PSBTs can finalize before the
> >>> legitimate Finalizer and broadcast the transaction.
> > 
> > Yes, that is a problem which is proposal does not address. If the
> > MitM has control over both directions, in and out, then whatever
> > he or she was trying to do will still happen. Personally, I'm okay
> > with that as a limition, but using the same signatures features,
> > and a pre-shared public key between the PSBT Creator and the Signer,
> > we could block the Signer from looking at MitM'ed files. (The Signer
> > would require and verify incoming unsigned PSBT to contain the
> > last-output-section-signature thing.) I'm not planning on supporting
> > that on the Coldcard (at least not yet), but with the proposed
> > additions, it is possible to do without further changes to the PSBT
> > spec.
> > 
> >>> Participants can work from the same PSBT ...
> >>> either pass two files (original and updated), or work out which fields
> >>> (key-value blobs) to remove to get the 'source' PSBT (which might not be
> >>> trivial with presense of proprietary and unknown fields). Even if you
> >>> know which key-value pairs to remove, there is no requirement for
> >>> ordering of the fields, and some signer can serialize them in different
> >>> order after dserialize/sign/add-signatures/re-serialize operation.
> > ...
> >>> Introducing additional ordering or other structure requirements over
> >>> simple key-value structure will add complexity to PSBT processing, and
> >>> adding complexity on such a basic level should have really serious
> >>> reasons, because that increases effort required for even basic
> >>> implementations and increases chance of bugs.
> > 
> > I want these signatures to protect against PSBT parsing bugs. That's
> > why they are byte-level on the whole file contents, and not based
> > on sub-sections of the file or various fields inside the file. Yes,
> > there are non-linear PSBT paths that will be difficult or impossible
> > to support with this approach. I would not expect implementations to
> > do anything fancy to reconstruct PSBT contents, I think they would
> > just track the complete file. In most setups today the Creator,
> > Combiner and Finalizer are the same device, and they are desktop
> > systems with gigs of memory.
> > 
> >>> If there is some authority on the 'correctness' of 'original' PSBT
> >>> (all particpants receive same PSBT at the start), particpants should
> >>> check the signature by that authority. That authority might use
> >>> the key used only for authentication, and not in the tx signing.
> > 
> > Yes, this can be acheived by pre-sharing a public key with the
> > Signer (described above). Only signed incoming PSBT's would be
> > accepted. That key doesn't have anything to do with the blockchain
> > or value transfer.
> > 
> >>> I think you do not need to wait for officially-assigned key numbers,
> >>> and can just implement the scheme you envision with proprietary keys,
> >>> document and promote it. Then if it shows its usefulness, it will
> >>> either become de-facto standard with your proprietary keys...
> > 
> > Yes, 100% ... but I value the list's feedback, and I would prefer to
> > start with a legitimate key number which I don't need to change later. It's
> > a non-breaking change and I wouldn't propose it otherwise.
> > 
> > ---
> > Peter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG: A3A31BAD 5A2A5B10
> > 
> > On Mon, Jan 13, 2020 at 06:39:28AM +0000, Andrew Chow wrote:
> >> I agree with Dimitry. I don't see the point of having the MiTM
> >> protection within the PSBT structure itself, in addition to the fact
> >> that adding new fields is largely unnecessary. In fact, I'm not quite
> >> sure what kind of attack you are trying to defend against with this
> >> proposal.
> >>
> >> If there is a MiTM who can modify your PSBT, then they can just modify
> >> the result the signed PSBT to drop the auth signatures. Furthermore, any
> >> modifications to scripts or UTXOs would just result in an invalid
> >> signature, so only time is wasted. But you'll just waste time anyways
> >> when you see a failed auth sig.
> >>
> >> Additionally, when a signer processes a PSBT, it will either accept the
> >> PSBT and add a signature for its inputs, or reject it and do nothing.
> >> Given this behavior (and I assume you aren't going to add auth sigs for
> >> rejected PSBTs because that doesn't make any sense), then you already
> >> have a signature there that covers everything your auth signature would
> >> cover. So just verify those signatures instead; for any inputs with
> >> signatures, everything you need to verify them are already there.
> >>
> >> Lastly, IMO, if you want MiTM protection, then you should do your
> >> protection with out of band communication. Just PGP sign the PSBT (or
> >> something similar) and send the signature along separately.
> >>
> >> Andrew
> >>
> >> On 1/11/20 3:17 PM, Dmitry Petukhov via bitcoin-dev wrote:
> >>>
> >>> I am not sure that this particular task should be done with data
> >>> embedded in PSBT itself, and not with some sort of container that
> >>> includes PSBT and the authentication information.
> >>>
> >>> The benefit seems to be in reusing PSBT structure for compatibilty, and
> >>> this might be a valid way, although I do not agree with some of your
> >>> points. I elaborate below:
> >>>
> >>>> 1) In the PSBT globals section, a signature over the "source" PSBT
> >>>> file. It would cover all the bytes of the original PSBT file, as
> >>>> it was received by the Signer.
> >>>
> >>> The problem of authenticating the contents of PSBT is independent of
> >>> the signing action. PSBT might be altered on the path from Creator to
> >>> Signer. Therefore you cannot always say that Signer will be an
> >>> authority over 'correctness' of PSBT.
> >>>
> >>>> - At the end of the signing process, the Finalizer should check all
> >>>> the Signers have worked from the same PSBT file (assuming that's
> >>>> the flow expected)
> >>>
> >>> If there is MitM, checking something at Finalizer is likely too
> >>> late - the party that can intercept PSBTs can finalize before the
> >>> legitimate Finalizer and broadcast the transaction.
> >>>
> >>> Participants can work from the same PSBT file if they all receive the
> >>> same PSBT, and not working in chain where next particpant receives
> >>> updated PSBT from the previous participant. Otherwise they will need to
> >>> either pass two files (original and updated), or work out which fields
> >>> (key-value blobs) to remove to get the 'source' PSBT (which might not be
> >>> trivial with presense of proprietary and unknown fields). Even if you
> >>> know which key-value pairs to remove, there is no requirement for
> >>> ordering of the fields, and some signer can serialize them in different
> >>> order after dserialize/sign/add-signatures/re-serialize operation.
> >>>
> >>> Introducing additional ordering or other structure requirements over
> >>> simple key-value structure will add complexity to PSBT processing, and
> >>> adding complexity on such a basic level should have really serious
> >>> reasons, because that increases effort required for even basic
> >>> implementations and increases chance of bugs.
> >>>
> >>> If there is some authority on the 'correctness' of 'original' PSBT
> >>> (all particpants receive same PSBT at the start), particpants should
> >>> check the signature by that authority. That authority might use
> >>> the key used only for authentication, and not in the tx signing.
> >>>
> >>> If particpants send PSBT in chain after adding their signatures, then
> >>> each participant can add their signature to say 'the contents
> >>> of PSBT after my updates should match this hash'.
> >>>
> >>> The signatures of previous participants in the chain most likely do not
> >>> matter because of difficulty of restoring the contents of PSBT as it
> >>> was before the previous particpant, if you do not pass _all_ the PSBTs
> >>> (which is excessive).
> >>>
> >>>> 2) In the output section, specifically, the last key/value pair of
> >>>> the last output of the transaction, I want to add a similar signature,
> >>>> again signed by one of the keys used in the signing process. This
> >>>> signature will cover all the bytes of the resulting (signed) PSBT
> >>>> up to that point. Because it is the last output of the output
> >>>> section, that signature will be the last few bytes of the PSBT file.
> >>>> By "appending" the signature in this way, it's easier to validate
> >>>> and create the signature, without blanking the signature area during
> >>>> digest step.
> >>>
> >>> This will introduce unnecessary higher-level structure to PSBT for the
> >>> reasons that I do not find strong enough for the amount of complexity
> >>> added.
> >>>
> >>> Also, as I said above, you likely do not need more than one
> >>> signature - if this is 'fan-out' scheme, then participants need do
> >>> check the sig of authority that created PSBT; if this is piggy-back
> >>> chain, then only previous particpant's signature is easily verifiable.
> >>>
> >>>> ## Next Steps
> >>>>
> >>>> I'd like to get two officially-assigned BIP-174 key numbers assigned
> >>>> for these two signatures, and then I will see that it gets added
> >>>> into Coldcard's firmware immediately. In time, other tools are
> >>>> welcome to take advantage of these checks. I will also write a BIP
> >>>> for this, and/or make an addition to BIP-174.
> >>>
> >>> I think you do not need to wait for officially-assigned key numbers,
> >>> and can just implement the scheme you envision with proprietary keys,
> >>> document and promote it. Then if it shows its usefulness, it will
> >>> either become de-facto standard with your proprietary keys (and
> >>> everyone will want to support 'Coldard PSBT auth' or whatever the name),
> >>> or the scheme will have serious grounds to be converted to standard and
> >>> have non-proprietary keys assigned.
> >>>
> >>> // Dmitry.
> >>> _______________________________________________
> >>> bitcoin-dev mailing list
> >>> bitcoin-dev at lists.linuxfoundation.org
> >>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >>>
> 

From joachimstr at protonmail.com  Mon Jan 13 20:49:51 2020
From: joachimstr at protonmail.com (=?UTF-8?Q?Joachim_Str=C3=B6mbergson?=)
Date: Mon, 13 Jan 2020 20:49:51 +0000
Subject: [bitcoin-dev] Coins: A trustless sidechain protocol
In-Reply-To: <0RSAH-PjblJV6Q7TGosFHAEdc9QGauCQ_knCzMwcoGdW4Qt49ts-egDkIwM-X_f0RjsPMquwdnmB6spunH379ICEAJQgUH7R1SE8CuZs7pI=@protonmail.com>
References: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>
 <ILtIOT_2wq-ld0mk5kPev5mw8RQD6pgzSF_EPuY1PE-mdsy8eJqsCaSU-zIyNZw-4W4p5JtLJs5d451PnHvQly-3V1q225bKmdanMZVOmGE=@protonmail.com>
 <0RSAH-PjblJV6Q7TGosFHAEdc9QGauCQ_knCzMwcoGdW4Qt49ts-egDkIwM-X_f0RjsPMquwdnmB6spunH379ICEAJQgUH7R1SE8CuZs7pI=@protonmail.com>
Message-ID: <6JaReZbjL3U0QrirtiCdgk107cNmQHiLbbJIDctf8uGUiqJOLvZwRLLPUQXAjzfAqRQBpaqtytcKhq1hvtSDwwaKGthwy40SWHDRnTpBkJA=@protonmail.com>

Hi Robin,

inline...
??????? Original Message ???????
On Monday, January 13, 2020 7:47 PM, Robin Linus <robinlinus at protonmail.com> wrote:

> Hi Joachim,
>
> Thank you for your detailed feedback!
>
> Regarding Reason #1:
> This proposal is less like Bitcoin vs. Altcoins and much more like Ethereum vs. ERC20 tokens, because the derivatives are not in competition with BTC, but depend on it heavily. You support Bitcoin's growth by supporting such a sidechain.
> Also, they won't work as separate currencies. For endusers you can abstract away all underlying complexities such that they have to think only in BTC. Exchanges rates can be hidden in TX fees. The sidechain derivatives would be nothing but a means of transfer. The unit of account is still BTC.

I can't see any difference and advantage over doing the same with say Litecoin. All you need is to create a special wallet which offers atomic swaps LTC-BTC and its unit of account displayed to user is going to be BTC. All you say will work perfectly with this special LTC wallet. Therefore your idea is as good as any other altcoin. In your case, someone else should indeed be able to create such a wallet in which the unit of account will be the new token, thus emulating the current LTC wallets. So the only difference in Litecoin is that the special wallet with BTC as unit is going to be created after the native one, while in your case it is vice versa.

I simply can't see why I'd call this construction of yours a Bitcoin sidechain and any other altcoin not. So I'd call both altcoins.

> Regarding Reason #2:
> In the "Limitations" section I discuss the cost of halting the chain:
>
> Time value of locked bitcoins might be too cheap to protect the chain. We can introduce an additional cost and let validators burn bitcoins for every on-chain vote. This is much more robust because there is an ongoing cost for halting the system. Proof-of-burn has recently been formally analysed [16]. The economic implications of burning significant amounts of Bitcoin are questionable. A level of security comparable to Bitcoin requires the system?s BTC burn rate to be equal to Bitcoin?s infaltion rate.
>
> Also remember, time value of Bitcoins is indeed a value. Even without a proof of burn, I'd consider such sidechains much more secure than those custodial lightning wallets which become more and more popular to circumvent the usability hurdles of the LN.

Comparison to other models is not relevant to my claim that such construction is insecure for small sidechains. And for big sidechains the reason #1 prefers any other altcoin. Even if you introduce proof of burn, the final attack cost is small for an attacker in absolute numbers, despite the fact that in the relative numbers the cost is huge.

> Thanks again,
> - Robin
>
> Sent with [ProtonMail](https://protonmail.com) Secure Email.
>
> ??????? Original Message ???????
> On Monday, January 13, 2020 7:06 PM, Joachim Str?mbergson <joachimstr at protonmail.com> wrote:
>
>> While I haven't rejected sidechains entirely yet, this particular proposal seems uninteresting, especially for two reasons.
>>
>> One ? it introduces a new token for each sidechain and suggests atomic swaps to be used for the exchange of the mainchain token with the sidechain token. Such a model seems nonsensical to me because there seems to be excessive number of blockchain projects that can be used similarly just as the sidechain in this proposal. Pick almost any altcoin out there and you can atomic swap it with Bitcoin. The fact that your sidechain is somehow mathematically bound to Bitcoin seems arbitrary because at the end you have a new token and a new issuance model. Therefore this is not extending Bitcoin economy, which is strictly limited by its convergence to zero inflation. This proposal is inflating the supply with a new token, which goes against what many people consider as a pillar of Bitcoin's value proposal. I think if you implement this proposal, you are going not to be considered as a Bitcoin sidechain, but you will be, from certain point of view, indistinguishable from any other altcoin. At the level of my current understanding, the only interesting sidechain model is the [theoretical] one with a two way peg with Bitcoin, preserving the issuance policy of Bitcoin.
>>
>> Two ? the security of the proposed system seems to be very fragile, unless I have missed something. When I think about sidechains, I expect that it should be possible to create a niche chain which is used by few participants while the security of the chain is somehow guaranteed from its bind to the mainchain. If this was not the case, such a niche sidechain could easily be attacked, even if just stalled/censored for a long period time, with just a small [absolute] investment from an attacker, although this investment might be large if taken relatively to the utility of this niche sidechain. So if we speak concretely about your proposal, you assume honest majority of validators. But in your system the validators come from locking of stake on Bitcoin chain by nodes that are interested in a particular sidechain. If you put this model on a niche chain where only few participants are interested in it, it's trivial for an attacker to be stronger [have more Bitcoin to lock] than all legitimate users together. You should only use honest majority assumption where the scope is global, where it is very hard and very expensive to obtain majority.
>>
>> Sent with [ProtonMail](https://protonmail.com) Secure Email.
>>
>> ??????? Original Message ???????
>> On Sunday, January 12, 2020 6:54 PM, Robin Linus via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> Hi all,
>>>
>>> I've been working on a sidechain protocol with no trusted third party. You can find the [whitepaper here](http://coins.github.io/coins.pdf).
>>>
>>> Abstract. Coins is a Bitcoin extension designed for payments at scale. We propose an efficient solution to the double-spending problem using a bitcoin-backed proof-of-stake.  Validators vote on sidechain blocks with one-time signatures, forming a record that cannot be changed without destroying their collateral. Every user can become a validator by locking bitcoins. One-time signatures guarantee that validators loose their stake for publishing conflicting histories. Checkpoints can be additionally secured with a bitcoin-backed proof-of-burn. Assuming a rational majority of validators, the sidechain provides safety and liveness. The sidechain?s footprint within bitcoin?s blockchain is minimal. The protocol is a generic consensus mechanism allowing for arbitrary sidechain assets. Spawning multiple, independent instances scales horizontally.
>>>
>>> Feedback is highly appreciated!
>>>
>>> Thank you
>>>
>>> - Robin
>>>
>>> PS: [Here on Github you can find further research on scalability and usability](https://github.com/coins/coins.github.io).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200113/88c8c246/attachment-0001.html>

From jlrubin at mit.edu  Mon Jan 13 22:05:21 2020
From: jlrubin at mit.edu (Jeremy)
Date: Mon, 13 Jan 2020 17:05:21 -0500
Subject: [bitcoin-dev] Coins: A trustless sidechain protocol
In-Reply-To: <-8y3dnfO2vpyLPeOF5scfp0c5AZd9FF-_xkr1jL2iT1j02fSMJHix2YQupuOeBRF9v5icwGQbriKFXqd5B1AusZp0X7ENOvQ_q4OGCazueU=@protonmail.com>
References: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>
 <Qa9HJ5p2bYnXsjvgcTz-J_stEwJ80SU9UTZF5abv96i5eM_6y3pmy9Bu4tEnFXOc_lBs-y2BFoMh4xOGjl2US56hAFPvxDZM2eyhJkEdBLM=@protonmail.com>
 <2mw_wd_ocLESpSG9ST3yJBsJriHf1l5LsdQ2jLamTUUKTMmwUpcjEeohClnMHJl4qjXNW9mHQJiK65jmDHfLG3-nVSRse9PdXnXokGZ2_ac=@protonmail.com>
 <P-QnOpNsFdehy_F3FJgAr0lSJ2xtmT5cwRsEC8VfnIUrSgfNDkLNizm2L1TG65AhKM430tzJ9p33WBnSmJ92ZTKEoaKXCTQzVKrZkH9vtn4=@protonmail.com>
 <-8y3dnfO2vpyLPeOF5scfp0c5AZd9FF-_xkr1jL2iT1j02fSMJHix2YQupuOeBRF9v5icwGQbriKFXqd5B1AusZp0X7ENOvQ_q4OGCazueU=@protonmail.com>
Message-ID: <CAD5xwhjPRELRdJNKiBbXtUFvrWSiG-1WaZKGV9FDw4=8Fq9YDw@mail.gmail.com>

https://utxos.org/uses/

Yes, you should check out the material at the link above. Specifically non
interactive channels solve this problem of one sided opens, where the other
party is passive/offline.


On Mon, Jan 13, 2020, 12:42 PM Joachim Str?mbergson via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> > Instead of using sidechains, just use channel factories.
>
> I am not familiar enough with the latest advancements in this field. Is it
> possible using LN/channel factories to achieve off-line-like participation
> user experience without previous registration with any kind of gateway
> provider? For example, can you go online, join the network [somehow
> instantly], generate address/invoice and then put it somewhere for others
> to later use it when you are off-line? Can you also participate while being
> off-line for very long periods of time without relying on third party
> providers to secure your channels? If not, is using sidechains really
> equally replaceable with LN/CF constructions?
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200113/87716194/attachment.html>

From robinlinus at protonmail.com  Mon Jan 13 22:22:43 2020
From: robinlinus at protonmail.com (Robin Linus)
Date: Mon, 13 Jan 2020 22:22:43 +0000
Subject: [bitcoin-dev] Coins: A trustless sidechain protocol
In-Reply-To: <6JaReZbjL3U0QrirtiCdgk107cNmQHiLbbJIDctf8uGUiqJOLvZwRLLPUQXAjzfAqRQBpaqtytcKhq1hvtSDwwaKGthwy40SWHDRnTpBkJA=@protonmail.com>
References: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>
 <ILtIOT_2wq-ld0mk5kPev5mw8RQD6pgzSF_EPuY1PE-mdsy8eJqsCaSU-zIyNZw-4W4p5JtLJs5d451PnHvQly-3V1q225bKmdanMZVOmGE=@protonmail.com>
 <0RSAH-PjblJV6Q7TGosFHAEdc9QGauCQ_knCzMwcoGdW4Qt49ts-egDkIwM-X_f0RjsPMquwdnmB6spunH379ICEAJQgUH7R1SE8CuZs7pI=@protonmail.com>
 <6JaReZbjL3U0QrirtiCdgk107cNmQHiLbbJIDctf8uGUiqJOLvZwRLLPUQXAjzfAqRQBpaqtytcKhq1hvtSDwwaKGthwy40SWHDRnTpBkJA=@protonmail.com>
Message-ID: <6pcznun9_VnOIV7D28YeCiWqSLtPnN7syJvgGVp_VIo_DAZyp2mDYZQxg6IT5dJagroU-TKgUUjLrJm12TlbhLCzwjftY6_OhIB3ej6o44E=@protonmail.com>

Hi Joachim,

>> Regarding Reason #1:
>> This proposal is less like Bitcoin vs. Altcoins and much more like Ethereum vs. ERC20 tokens, because the derivatives are not in competition with BTC, but depend on it heavily. You support Bitcoin's growth by supporting such a sidechain.
>> Also, they won't work as separate currencies. For endusers you can abstract away all underlying complexities such that they have to think only in BTC. Exchanges rates can be hidden in TX fees. The sidechain derivatives would be nothing but a means of transfer. The unit of account is still BTC.
>
> I can't see any difference and advantage over doing the same with say Litecoin. All you need is to create a special wallet which offers atomic swaps LTC-BTC and its unit of account displayed to user is going to be BTC. All you say will work perfectly with this special LTC wallet. Therefore your idea is as good as any other altcoin. In your case, someone else should indeed be able to create such a wallet in which the unit of account will be the new token, thus emulating the current LTC wallets. So the only difference in Litecoin is that the special wallet with BTC as unit is going to be created after the native one, while in your case it is vice versa.
>
> I simply can't see why I'd call this construction of yours a Bitcoin sidechain and any other altcoin not. So I'd call both altcoins.

Let me try to explain where I am coming from: Whenever I want to onboard a not-so-techy friend to Bitcoin by sending him $5 worth of BTC, I don't have many good options. Usually we end up using BlueWallet. It works great. Though it only works so well because it is fully custodial. That is how they solve all the tough LN problems like inbound-capacity of new users, watchtowers and channel backends. Their service is just an Excel table connect to the LN. Unfortunately, that is the best UX we can currently offer to endusers. To me that's unsatisfying. Is that how we want to enter the emerging markets and on-board the next Billion users? I like that BlueWallet gives me the option to run my own LndHub for my friends. Still, does that scale globally? More importantly, do we want that?

Now let's think about the altcoins argument. We want to serve a billion users. Blockchains do scale well to about a couple Million UTXOs, so we require a network of a couple thousand altcoins to serve our users.
We know how to build a nice LN for all of our altcoins with a star-shaped topology around Bitcoin as the central settlement layer. Atomic swaps FTW. We can abstract away their native currencies. We display to our users only BTC, hide the exchange rates in the TX fees and we're done. That is actually a scalability solution. So why don't we do that?
The problem here is, that In the long term, the market of PoW blockchains should be a winner-takes-all market, right? So all PoW chains but Bitcoin will eventually die because they're wasting lots of value on their energy. So actually we don't want a couple thousand altcoins wasting resources on pointlessly weak PoW chains. We want a single PoW chain which is as strong as possible.

That's why I'd argue it makes sense to consider a bitcoin-backed PoS and build a LN of thousands of nameless altcoins.

Regarding sidechain security: Burning BTC is almost equivalent to burning energy. You might argue that people won't burn BTC, but it is hard to argue against the strong theoretical security properties of proof-of-burn.

Furthermore, even without burning BTC, using only proof-of-stake I can guarantee doublespending is impossible. There is a very low incentive to risk your BTC's time value. You can only halt a sidechain. And you can halt the sidechain only for as long as you maintain the staking majority. Once you start an attack, you increase the incentive for others to increase their stake. Staking happens in bitcoin's blockchain, which you can't halt. Once the rational stakers regain 51% you've lost a year of time value of your BTC. Note that you can easily enforce stakers having to stake per chain. This guarantees attackers can use their BTC only to attack one chain per year.
Thus, the security of such a bitcoin-based PoS is stronger then one might suspect.

Thanks again,
- Robin

>> Regarding Reason #2:
>> In the "Limitations" section I discuss the cost of halting the chain:
>>
>> Time value of locked bitcoins might be too cheap to protect the chain. We can introduce an additional cost and let validators burn bitcoins for every on-chain vote. This is much more robust because there is an ongoing cost for halting the system. Proof-of-burn has recently been formally analysed [16]. The economic implications of burning significant amounts of Bitcoin are questionable. A level of security comparable to Bitcoin requires the system?s BTC burn rate to be equal to Bitcoin?s infaltion rate.
>>
>> Also remember, time value of Bitcoins is indeed a value. Even without a proof of burn, I'd consider such sidechains much more secure than those custodial lightning wallets which become more and more popular to circumvent the usability hurdles of the LN.
>
> Comparison to other models is not relevant to my claim that such construction is insecure for small sidechains. And for big sidechains the reason #1 prefers any other altcoin. Even if you introduce proof of burn, the final attack cost is small for an attacker in absolute numbers, despite the fact that in the relative numbers the cost is huge.
>
>> Thanks again,
>> - Robin
>>
>> Sent with [ProtonMail](https://protonmail.com) Secure Email.
>>
>> ??????? Original Message ???????
>> On Monday, January 13, 2020 7:06 PM, Joachim Str?mbergson <joachimstr at protonmail.com> wrote:
>>
>>> While I haven't rejected sidechains entirely yet, this particular proposal seems uninteresting, especially for two reasons.
>>>
>>> One ? it introduces a new token for each sidechain and suggests atomic swaps to be used for the exchange of the mainchain token with the sidechain token. Such a model seems nonsensical to me because there seems to be excessive number of blockchain projects that can be used similarly just as the sidechain in this proposal. Pick almost any altcoin out there and you can atomic swap it with Bitcoin. The fact that your sidechain is somehow mathematically bound to Bitcoin seems arbitrary because at the end you have a new token and a new issuance model. Therefore this is not extending Bitcoin economy, which is strictly limited by its convergence to zero inflation. This proposal is inflating the supply with a new token, which goes against what many people consider as a pillar of Bitcoin's value proposal. I think if you implement this proposal, you are going not to be considered as a Bitcoin sidechain, but you will be, from certain point of view, indistinguishable from any other altcoin. At the level of my current understanding, the only interesting sidechain model is the [theoretical] one with a two way peg with Bitcoin, preserving the issuance policy of Bitcoin.
>>>
>>> Two ? the security of the proposed system seems to be very fragile, unless I have missed something. When I think about sidechains, I expect that it should be possible to create a niche chain which is used by few participants while the security of the chain is somehow guaranteed from its bind to the mainchain. If this was not the case, such a niche sidechain could easily be attacked, even if just stalled/censored for a long period time, with just a small [absolute] investment from an attacker, although this investment might be large if taken relatively to the utility of this niche sidechain. So if we speak concretely about your proposal, you assume honest majority of validators. But in your system the validators come from locking of stake on Bitcoin chain by nodes that are interested in a particular sidechain. If you put this model on a niche chain where only few participants are interested in it, it's trivial for an attacker to be stronger [have more Bitcoin to lock] than all legitimate users together. You should only use honest majority assumption where the scope is global, where it is very hard and very expensive to obtain majority.
>>>
>>> Sent with [ProtonMail](https://protonmail.com) Secure Email.
>>>
>>> ??????? Original Message ???????
>>> On Sunday, January 12, 2020 6:54 PM, Robin Linus via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>>> Hi all,
>>>>
>>>> I've been working on a sidechain protocol with no trusted third party. You can find the [whitepaper here](http://coins.github.io/coins.pdf).
>>>>
>>>> Abstract. Coins is a Bitcoin extension designed for payments at scale. We propose an efficient solution to the double-spending problem using a bitcoin-backed proof-of-stake.  Validators vote on sidechain blocks with one-time signatures, forming a record that cannot be changed without destroying their collateral. Every user can become a validator by locking bitcoins. One-time signatures guarantee that validators loose their stake for publishing conflicting histories. Checkpoints can be additionally secured with a bitcoin-backed proof-of-burn. Assuming a rational majority of validators, the sidechain provides safety and liveness. The sidechain?s footprint within bitcoin?s blockchain is minimal. The protocol is a generic consensus mechanism allowing for arbitrary sidechain assets. Spawning multiple, independent instances scales horizontally.
>>>>
>>>> Feedback is highly appreciated!
>>>>
>>>> Thank you
>>>>
>>>> - Robin
>>>>
>>>> PS: [Here on Github you can find further research on scalability and usability](https://github.com/coins/coins.github.io).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200113/aeed17c9/attachment-0001.html>

From achow101-lists at achow101.com  Mon Jan 13 23:18:34 2020
From: achow101-lists at achow101.com (Andrew Chow)
Date: Mon, 13 Jan 2020 23:18:34 +0000
Subject: [bitcoin-dev] PSBT Addition (BIP 174) for authenticating
	source/output PSBT files
In-Reply-To: <20200113202911.GC45046@coinkite.com>
References: <20200111172906.GO10797@coinkite.com>
 <20200112011705.6f6102dd@simplexum.com>
 <78dbbce2-0372-2516-489f-ed6e839b1a6f@achow101.com>
 <20200113142817.GQ10797@coinkite.com>
 <4adabcd3-e2ce-d143-0193-8a8581a318aa@achow101.com>
 <20200113202911.GC45046@coinkite.com>
Message-ID: <02ca6fdd-4bb8-202c-a213-de872e7e8a8f@achow101.com>

On 1/13/20 3:29 PM, Peter D. Gray wrote:
> The Signer may be signing a PSBT that was corrupted by the MitM,
> but at least later users of the signed PSBT can detect that occured.
> At present, they do not know what the input PSBT content was when
> it got to the Signer.

But the MiTM on the way to the other roles will still see that signed
PSBT, and if the Signer has produced a signature such that someone can
get the private key, that MiTM will have the private key before the
transaction is broadcast. If this isn't part of your threat model, I
think it should be; I don't think it is reasonable to say that you are
only protecting against MiTM for one specific leg of the entire protocol.

> If we use a fixed-width signature, such as just R+S bytes (64 bytes),
> and not DER-encoding, then the signature is a fixed distance from
> the last byte of the file. A conservative PSBT parser could start
> by verifying the signature exists and is valid, before parsing the
> rest of the file. (It would need to use the pubkeys from the original
> PSBT, which it would ideally have on-hand already to verify the source
> PSBT to the Coldcard.)

Why the end? This brings up a particular implementation detail I didn't
want to get into since I was opposing the idea conceptually, but I don't
think that 2 new types are necessary. We absolutely do not need nor
should we have any global data (and the auth sig is absolutely global
data) in input or output specific fields. The outputs really should be
independent of the other inputs and outputs. So having the last output
have the signature is a layer violation.

Why put it at the end? If you want a byte offset, just put the signature
in the globals as the first kv pair.

> I agree that Finalizers cannot access the Bitcoin private keys, but
> they still have stacks that can overflow, buffers that can be overrun
> and so on. Perhaps if sighash is not SIGHASH_ALL, there are dangerous
> things they can be tricked into... I don't know, but at least we
> should make it possible to detect these cases. My goal is detection.

But that shouldn't matter to the Finalizer. It isn't the Finalizer's job
to enforce that the Signers followed a specific signing policy. If the
Signer chose to sign with a "dangerous policy", that's up to the signer
and the Finalizers shouldn't have anything to do with that.

> No, I am not proposing anyone re-construct PSBT's... My proposal
> is really only helpful if you have the full original PSBT on hand
> (or its digest). For ultimate safety I would recommend checking the
> incoming PSBT's signature is valid before parsing it.(If the
> signature is fixed-length, see above.)

That's another thing I don't understand about your proposal. Your
signature covers the "Original PSBT" which is really nebulous and could
anything. This doesn't make sense to me. Everyone has to somehow get the
same "Original PSBT" so you are assuming there's no MiTM in that initial
distribution (seems like an oversight in your threat model).

But then your "Original PSBT" can also be in a number of different
states, and your signature wouldn't cover some things. For example, the
"Original" could have just some of the UTXOs and some of the scripts,
not everything. So in later steps of the process, the MiTM protection
doesn't cover those things, so an attacker could modify them with no
effect on the signature.

> In the USB protocol between Coldcard and desktop, we do end-to-end
> encryption with a session key picked via diff-hel so we're doing
> our best there against MitM. However, our customers love the air-gap
> feature which involves lots of sneakernet handling of MicroSD cards.
> I don't want to force them into handling paired files, like detacted
> signatures, and I was hoping this would be a good way to move the
> signatures inside the PSBT files already being moved about.

You could put them in an archive (tarfile) so it's still just one file
being copied from the SD card. You already have archive creation on the
coldcard for backup creation anyways.

***

I guess what I don't get about this proposal is your threat model and
what specifically you are protecting against. It seems like this is only
protecting against the specific leg from a specific combined
Updater/Finalizer to and from its respective Signer. But this is not
always the use case and this isn't very generic. Other places that there
could be MiTM aren't covered.

I also don't get what a MiTM could even do. If your parser is vulnerable
to the standard programming vulns (buffer overflows, stack overflows,
etc.), ISTM you will still run into those with just a normal PSBT. If
you don't, then a MiTM can't trigger one there. And likewise for
signature issues; if your signer might produce a private key leaking
signature, then it will probably do that with a non-MiTM'd PSBT, and if
not, MiTM isn't going to change that.

Andrew

> 
> ---
> Peter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG: A3A31BAD 5A2A5B10
> 
> On Mon, Jan 13, 2020 at 05:05:10PM +0000, Andrew Chow wrote:
>>
>> On 1/13/20 9:28 AM, Peter D. Gray wrote:
>>> I don't have a specific attack in mind, but these signatures, if
>>> adopted by the community at large, will allow detection of-, and
>>> could mitigate damage from-, some broad "bug-classes".
>>>
>>> Consider if the PSBT Signer (hardware wallet) has bugs. Perhaps if
>>> you tweak the PSBT in some unnatural way it produces output that
>>> reveals the private key (duplicate k-value perhaps), or corrupts
>>> the display of the transaction in helpful (to the attacker) ways
>>> (typically case: output hidden as change).
>>
>> Since the PSBT is to be signed by one of the Signers for the PSBT, I
>> don't see how this is useful. If it is mutated and the signer has bugs,
>> especially parsing bugs, the Signer also adding its signature won't
>> help. In your proposal, it is the Signer who adds the signature, so it
>> will receive a PSBT without auth sigs and thus that could be mutated to
>> trigger those bugs anyways.
>>
>>> There could also be bugs in the Combiner/Finalizer which the MiTM
>>> wants to trigger. Legimate files, signed by the PSBT Signer, will not
>>> contain those attacks, so are "safer" to process, even if your
>>> Combiner's PSBT parser has bugs or is tragically dumb.
>>
>> The job of Combiners is fairly limited and is really just related to
>> parsing the PSBT into some internal object then shuffling those fields
>> around. In that case, any bugs an attacker would want to exploit have to
>> be deserialization bugs, in which case, your auth sigs don't help. The
>> Combiner still has to deserialize the PSBT to get the signature, then it
>> needs to re-serialize the PSBT to check that signature. An attacker
>> could insert bad bytes into the PSBT which causes problems during
>> deserialization, before the Combiner is able to check the signature.
>>
>> For Finalizers, since its job is to construct the final
>> scriptSig/scriptWitness, at worst, all it can do is produce an invalid
>> transaction. Finalizers don't have access to the private keys so there's
>> no bug possible that can result in a Finalizer producing a transaction
>> that reveals the private key.
>>
>>>
>>> That's just it, when we receive a signed PSBT, at present we don't
>>> know *what* was signed without a complete understanding of the
>>> transaction, the input UTXO (at least syntactially), and PSBT file
>>> contents.  If there are bugs in that understanding (ie. checks we
>>> all know are needed, but no-one actually implemented) then we might
>>> transmit an harmful transaction, or continue to process a file
>>> that has been corrupted-with-intent by a MiTM.
>>
>> ISTM the same is true of your proposal. You need to deserialize the PSBT
>> and then figure out which fields were "original" and in what order. If
>> there is a bug in your deserialization, an attacker can still exploit
>> that. And if there is a bug in your reconstruction of "original", you'll
>> have false positives.
>>
>>> It's fine to say that, but in an embedded environment, with very
>>> limited memory like the Coldcard, PGP isn't an option (signing vs.
>>> signature verification). I want to leverage the existing crypto and
>>> PKI that we already have in play.
>>
>> My point was that you can achieve your MiTM protection by having the
>> signature separate from the PSBT. You can still make your ECDSA
>> signature and send it along with the PSBT, and you can do it with fixed
>> or exchanged keys, no need for parsing the PSBT itself. It can be part
>> of the transport protocol, not part of the data that is being transferred.
>>
>> Andrew
>>
>>>
>>>> On 1/11/20 3:17 PM, Dmitry Petukhov via bitcoin-dev wrote:
>>> ... [many valid points, repeated by Andrew] ...
>>>>> If there is MitM, checking something at Finalizer is likely too
>>>>> late - the party that can intercept PSBTs can finalize before the
>>>>> legitimate Finalizer and broadcast the transaction.
>>>
>>> Yes, that is a problem which is proposal does not address. If the
>>> MitM has control over both directions, in and out, then whatever
>>> he or she was trying to do will still happen. Personally, I'm okay
>>> with that as a limition, but using the same signatures features,
>>> and a pre-shared public key between the PSBT Creator and the Signer,
>>> we could block the Signer from looking at MitM'ed files. (The Signer
>>> would require and verify incoming unsigned PSBT to contain the
>>> last-output-section-signature thing.) I'm not planning on supporting
>>> that on the Coldcard (at least not yet), but with the proposed
>>> additions, it is possible to do without further changes to the PSBT
>>> spec.
>>>
>>>>> Participants can work from the same PSBT ...
>>>>> either pass two files (original and updated), or work out which fields
>>>>> (key-value blobs) to remove to get the 'source' PSBT (which might not be
>>>>> trivial with presense of proprietary and unknown fields). Even if you
>>>>> know which key-value pairs to remove, there is no requirement for
>>>>> ordering of the fields, and some signer can serialize them in different
>>>>> order after dserialize/sign/add-signatures/re-serialize operation.
>>> ...
>>>>> Introducing additional ordering or other structure requirements over
>>>>> simple key-value structure will add complexity to PSBT processing, and
>>>>> adding complexity on such a basic level should have really serious
>>>>> reasons, because that increases effort required for even basic
>>>>> implementations and increases chance of bugs.
>>>
>>> I want these signatures to protect against PSBT parsing bugs. That's
>>> why they are byte-level on the whole file contents, and not based
>>> on sub-sections of the file or various fields inside the file. Yes,
>>> there are non-linear PSBT paths that will be difficult or impossible
>>> to support with this approach. I would not expect implementations to
>>> do anything fancy to reconstruct PSBT contents, I think they would
>>> just track the complete file. In most setups today the Creator,
>>> Combiner and Finalizer are the same device, and they are desktop
>>> systems with gigs of memory.
>>>
>>>>> If there is some authority on the 'correctness' of 'original' PSBT
>>>>> (all particpants receive same PSBT at the start), particpants should
>>>>> check the signature by that authority. That authority might use
>>>>> the key used only for authentication, and not in the tx signing.
>>>
>>> Yes, this can be acheived by pre-sharing a public key with the
>>> Signer (described above). Only signed incoming PSBT's would be
>>> accepted. That key doesn't have anything to do with the blockchain
>>> or value transfer.
>>>
>>>>> I think you do not need to wait for officially-assigned key numbers,
>>>>> and can just implement the scheme you envision with proprietary keys,
>>>>> document and promote it. Then if it shows its usefulness, it will
>>>>> either become de-facto standard with your proprietary keys...
>>>
>>> Yes, 100% ... but I value the list's feedback, and I would prefer to
>>> start with a legitimate key number which I don't need to change later. It's
>>> a non-breaking change and I wouldn't propose it otherwise.
>>>
>>> ---
>>> Peter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG: A3A31BAD 5A2A5B10
>>>
>>> On Mon, Jan 13, 2020 at 06:39:28AM +0000, Andrew Chow wrote:
>>>> I agree with Dimitry. I don't see the point of having the MiTM
>>>> protection within the PSBT structure itself, in addition to the fact
>>>> that adding new fields is largely unnecessary. In fact, I'm not quite
>>>> sure what kind of attack you are trying to defend against with this
>>>> proposal.
>>>>
>>>> If there is a MiTM who can modify your PSBT, then they can just modify
>>>> the result the signed PSBT to drop the auth signatures. Furthermore, any
>>>> modifications to scripts or UTXOs would just result in an invalid
>>>> signature, so only time is wasted. But you'll just waste time anyways
>>>> when you see a failed auth sig.
>>>>
>>>> Additionally, when a signer processes a PSBT, it will either accept the
>>>> PSBT and add a signature for its inputs, or reject it and do nothing.
>>>> Given this behavior (and I assume you aren't going to add auth sigs for
>>>> rejected PSBTs because that doesn't make any sense), then you already
>>>> have a signature there that covers everything your auth signature would
>>>> cover. So just verify those signatures instead; for any inputs with
>>>> signatures, everything you need to verify them are already there.
>>>>
>>>> Lastly, IMO, if you want MiTM protection, then you should do your
>>>> protection with out of band communication. Just PGP sign the PSBT (or
>>>> something similar) and send the signature along separately.
>>>>
>>>> Andrew
>>>>
>>>> On 1/11/20 3:17 PM, Dmitry Petukhov via bitcoin-dev wrote:
>>>>>
>>>>> I am not sure that this particular task should be done with data
>>>>> embedded in PSBT itself, and not with some sort of container that
>>>>> includes PSBT and the authentication information.
>>>>>
>>>>> The benefit seems to be in reusing PSBT structure for compatibilty, and
>>>>> this might be a valid way, although I do not agree with some of your
>>>>> points. I elaborate below:
>>>>>
>>>>>> 1) In the PSBT globals section, a signature over the "source" PSBT
>>>>>> file. It would cover all the bytes of the original PSBT file, as
>>>>>> it was received by the Signer.
>>>>>
>>>>> The problem of authenticating the contents of PSBT is independent of
>>>>> the signing action. PSBT might be altered on the path from Creator to
>>>>> Signer. Therefore you cannot always say that Signer will be an
>>>>> authority over 'correctness' of PSBT.
>>>>>
>>>>>> - At the end of the signing process, the Finalizer should check all
>>>>>> the Signers have worked from the same PSBT file (assuming that's
>>>>>> the flow expected)
>>>>>
>>>>> If there is MitM, checking something at Finalizer is likely too
>>>>> late - the party that can intercept PSBTs can finalize before the
>>>>> legitimate Finalizer and broadcast the transaction.
>>>>>
>>>>> Participants can work from the same PSBT file if they all receive the
>>>>> same PSBT, and not working in chain where next particpant receives
>>>>> updated PSBT from the previous participant. Otherwise they will need to
>>>>> either pass two files (original and updated), or work out which fields
>>>>> (key-value blobs) to remove to get the 'source' PSBT (which might not be
>>>>> trivial with presense of proprietary and unknown fields). Even if you
>>>>> know which key-value pairs to remove, there is no requirement for
>>>>> ordering of the fields, and some signer can serialize them in different
>>>>> order after dserialize/sign/add-signatures/re-serialize operation.
>>>>>
>>>>> Introducing additional ordering or other structure requirements over
>>>>> simple key-value structure will add complexity to PSBT processing, and
>>>>> adding complexity on such a basic level should have really serious
>>>>> reasons, because that increases effort required for even basic
>>>>> implementations and increases chance of bugs.
>>>>>
>>>>> If there is some authority on the 'correctness' of 'original' PSBT
>>>>> (all particpants receive same PSBT at the start), particpants should
>>>>> check the signature by that authority. That authority might use
>>>>> the key used only for authentication, and not in the tx signing.
>>>>>
>>>>> If particpants send PSBT in chain after adding their signatures, then
>>>>> each participant can add their signature to say 'the contents
>>>>> of PSBT after my updates should match this hash'.
>>>>>
>>>>> The signatures of previous participants in the chain most likely do not
>>>>> matter because of difficulty of restoring the contents of PSBT as it
>>>>> was before the previous particpant, if you do not pass _all_ the PSBTs
>>>>> (which is excessive).
>>>>>
>>>>>> 2) In the output section, specifically, the last key/value pair of
>>>>>> the last output of the transaction, I want to add a similar signature,
>>>>>> again signed by one of the keys used in the signing process. This
>>>>>> signature will cover all the bytes of the resulting (signed) PSBT
>>>>>> up to that point. Because it is the last output of the output
>>>>>> section, that signature will be the last few bytes of the PSBT file.
>>>>>> By "appending" the signature in this way, it's easier to validate
>>>>>> and create the signature, without blanking the signature area during
>>>>>> digest step.
>>>>>
>>>>> This will introduce unnecessary higher-level structure to PSBT for the
>>>>> reasons that I do not find strong enough for the amount of complexity
>>>>> added.
>>>>>
>>>>> Also, as I said above, you likely do not need more than one
>>>>> signature - if this is 'fan-out' scheme, then participants need do
>>>>> check the sig of authority that created PSBT; if this is piggy-back
>>>>> chain, then only previous particpant's signature is easily verifiable.
>>>>>
>>>>>> ## Next Steps
>>>>>>
>>>>>> I'd like to get two officially-assigned BIP-174 key numbers assigned
>>>>>> for these two signatures, and then I will see that it gets added
>>>>>> into Coldcard's firmware immediately. In time, other tools are
>>>>>> welcome to take advantage of these checks. I will also write a BIP
>>>>>> for this, and/or make an addition to BIP-174.
>>>>>
>>>>> I think you do not need to wait for officially-assigned key numbers,
>>>>> and can just implement the scheme you envision with proprietary keys,
>>>>> document and promote it. Then if it shows its usefulness, it will
>>>>> either become de-facto standard with your proprietary keys (and
>>>>> everyone will want to support 'Coldard PSBT auth' or whatever the name),
>>>>> or the scheme will have serious grounds to be converted to standard and
>>>>> have non-proprietary keys assigned.
>>>>>
>>>>> // Dmitry.
>>>>> _______________________________________________
>>>>> bitcoin-dev mailing list
>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>>
>>


From ZmnSCPxj at protonmail.com  Tue Jan 14 00:53:24 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 14 Jan 2020 00:53:24 +0000
Subject: [bitcoin-dev] Coins: A trustless sidechain protocol
In-Reply-To: <6pcznun9_VnOIV7D28YeCiWqSLtPnN7syJvgGVp_VIo_DAZyp2mDYZQxg6IT5dJagroU-TKgUUjLrJm12TlbhLCzwjftY6_OhIB3ej6o44E=@protonmail.com>
References: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>
 <ILtIOT_2wq-ld0mk5kPev5mw8RQD6pgzSF_EPuY1PE-mdsy8eJqsCaSU-zIyNZw-4W4p5JtLJs5d451PnHvQly-3V1q225bKmdanMZVOmGE=@protonmail.com>
 <0RSAH-PjblJV6Q7TGosFHAEdc9QGauCQ_knCzMwcoGdW4Qt49ts-egDkIwM-X_f0RjsPMquwdnmB6spunH379ICEAJQgUH7R1SE8CuZs7pI=@protonmail.com>
 <6JaReZbjL3U0QrirtiCdgk107cNmQHiLbbJIDctf8uGUiqJOLvZwRLLPUQXAjzfAqRQBpaqtytcKhq1hvtSDwwaKGthwy40SWHDRnTpBkJA=@protonmail.com>
 <6pcznun9_VnOIV7D28YeCiWqSLtPnN7syJvgGVp_VIo_DAZyp2mDYZQxg6IT5dJagroU-TKgUUjLrJm12TlbhLCzwjftY6_OhIB3ej6o44E=@protonmail.com>
Message-ID: <-XqpIGL2s4yhkiWLsuqhvfpQKm1iRdTZHoTy83d_rKW9bY0Qhz5WHxcET5JSzEMxQUXiq5e-VmDqgp2zZ8locphCSjnztSB_yNV_esq111s=@protonmail.com>

Good morning Robin,

> Hi Joachim,
>
> > > Regarding Reason #1:
> > > This proposal is less like Bitcoin vs. Altcoins and much more like Ethereum vs. ERC20 tokens, because the derivatives are not in competition with BTC, but depend on it heavily. You support Bitcoin's growth by supporting such a sidechain.?
> > > Also, they won't work as separate currencies. For endusers you can abstract away all underlying complexities such that they have to think only in BTC. Exchanges rates can be hidden in TX fees. The sidechain derivatives would be nothing but a means of transfer. The unit of account is still BTC.?
> >
> > I can't see any difference and advantage over doing the same with say Litecoin. All you need is to create a special wallet which offers atomic swaps LTC-BTC and its unit of account displayed to user is going to be BTC. All you say will work perfectly with this special LTC wallet. Therefore your idea is as good as any other altcoin. In your case, someone else should indeed be able to create such a wallet in which the unit of account will be the new token, thus emulating the current LTC wallets. So the only difference in Litecoin is that the special wallet with BTC as unit is going to be created after the native one, while in your case it is vice versa.
> >
> > I simply can't see why I'd call this construction of yours a Bitcoin sidechain and any other altcoin not. So I'd call both altcoins.
>
> Let me try to explain where I am coming from: Whenever I want to onboard a not-so-techy friend to Bitcoin by sending him $5 worth of BTC, I don't have many good options. Usually we end up using BlueWallet. It works great. Though it only works so well because it is fully custodial. That is how they solve all the tough LN problems like inbound-capacity of new users, watchtowers and channel backends. Their service is just an Excel table connect to the LN. Unfortunately, that is the best UX we can currently offer to endusers. To me that's unsatisfying. Is that how we want to enter the emerging markets and on-board the next Billion users? I like that BlueWallet gives me the option to run my own LndHub for my friends. Still, does that scale globally? More importantly, do we want that?
>
> Now let's think about the altcoins argument. We want to serve a billion users. Blockchains do scale well to about a couple Million UTXOs, so we require a network of a couple thousand altcoins to serve our users.
> We know how to build a nice LN for all of our altcoins with a star-shaped topology around Bitcoin as the central settlement layer. Atomic swaps FTW. We can abstract away their native currencies. We display to our users only BTC, hide the exchange rates in the TX fees and we're done. That is actually a scalability solution. So why don't we do that?

Because Lightning remains a superior *scalability* solution to microchains.

(The below is a Fermi estimate; it is intended to give an intuition on the rough orders of magnitude that we are discussing, not strict predictions of how the world works)

Let us suppose that N users would produce N * t bytes of transactions.

Under Lightning, that data is sent to a tiny subset of the entire LN.
As Lightning limits routes to at most 20 hops, let us take the worst case and say that under Lightning, those users will force 20 * N * t bytes to be processed globally.

If all users were to use a *single* blockchain, because all users must process all transactions within the blockchain, that will mean everyone has to process N * N * t bytes.

Now the microchain concept is that, we can split the N in half, so instead of a single N * N * t bytes being processed, we get two (N / 2) * (N / 2) * t, or more generally, if there are c chains: c * ((N / c) ^ 2) * t or N * N * t / c.

So for microchains to beat Lightning, you would have to make N * N * t / c < 20 * N * t, or equivalently N / c < 20, i.e. 20 users per sidechain.

If you have as low as 20 users per sidechain, you might as well just use channel factories to host Lightning channels, so channel factories + channels (i.e. Lightning Network) is probably better than having tiny sidechaisn with 20 users each.

Again the above is a very rough Fermi estimate, but it gives you a hint on the orders of magnitude you should consider, i.e. about a few dozen users per sidechain, and a few dozens users in a sidechain is probably not a lot to give security to that sidechain, whereas with Lightning channel factories you can drop onchain any time to upgrade your security to the full mining hashpower (and we hope that the threat of being able to do so is enough to discourage attempts at theft).

What Lightning cannot do is add certain kinds of features other than scalability, for example Turing-complete disasters (RSK) or confidential assets (LBTC).
Sidechains are for features, not scale, so your proposed sidechain concept remains of interest at least as a possible way to anchor sidechains with new features.

Regards,
ZmnSCPxj

From robinlinus at protonmail.com  Tue Jan 14 02:19:55 2020
From: robinlinus at protonmail.com (Robin Linus)
Date: Tue, 14 Jan 2020 02:19:55 +0000
Subject: [bitcoin-dev] Coins: A trustless sidechain protocol
In-Reply-To: <-XqpIGL2s4yhkiWLsuqhvfpQKm1iRdTZHoTy83d_rKW9bY0Qhz5WHxcET5JSzEMxQUXiq5e-VmDqgp2zZ8locphCSjnztSB_yNV_esq111s=@protonmail.com>
References: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>
 <ILtIOT_2wq-ld0mk5kPev5mw8RQD6pgzSF_EPuY1PE-mdsy8eJqsCaSU-zIyNZw-4W4p5JtLJs5d451PnHvQly-3V1q225bKmdanMZVOmGE=@protonmail.com>
 <0RSAH-PjblJV6Q7TGosFHAEdc9QGauCQ_knCzMwcoGdW4Qt49ts-egDkIwM-X_f0RjsPMquwdnmB6spunH379ICEAJQgUH7R1SE8CuZs7pI=@protonmail.com>
 <6JaReZbjL3U0QrirtiCdgk107cNmQHiLbbJIDctf8uGUiqJOLvZwRLLPUQXAjzfAqRQBpaqtytcKhq1hvtSDwwaKGthwy40SWHDRnTpBkJA=@protonmail.com>
 <6pcznun9_VnOIV7D28YeCiWqSLtPnN7syJvgGVp_VIo_DAZyp2mDYZQxg6IT5dJagroU-TKgUUjLrJm12TlbhLCzwjftY6_OhIB3ej6o44E=@protonmail.com>
 <-XqpIGL2s4yhkiWLsuqhvfpQKm1iRdTZHoTy83d_rKW9bY0Qhz5WHxcET5JSzEMxQUXiq5e-VmDqgp2zZ8locphCSjnztSB_yNV_esq111s=@protonmail.com>
Message-ID: <2NvYkCEanXxFZvWPT3SJ-8whLGsVQYH_QbAHjPqLZIpeCO9E_mL7cCWTg6Qe4Af8gSMMeizbQQh3pZ-QW91xHDQOfZZUFdoacNOjzEEg85Y=@protonmail.com>

> because all users must process all transactions within the blockchain

Reality shows, that's wrong. Bitcoin's security doesn't require verification to scale quadratically with users. Since the whitepaper, Satoshi was explicit about that phenomena. We can discuss nuances, yet it's overall plausible and empirically it's true: Only a tiny minority of users ever verifies the blockchain, still bitcoin works perfectly well. An honest economic majority is sufficient.

Yes, if you can, run your own node. Let's lower the barriers and let's help others to run their own nodes. Let's keep the blocks small and bitcoin's UTXOs set verifiable with consumer hardware. That's the core of decentralized security.

But let's face it: most people on this planet will never run a bitcoin full node. And it is not required.

Bitcoin-backed PoS-sidechains scale in terms of verification and storage just like any other blockchain. However, security is strictly better because double-spends are impossible.  A single honest validating user guarantees that attackers cannot do more harm than halting a sidechain. Thus, endusers won't have to validate all of each others' transactions at all.

For most endusers such sidechains' security is strictly superior to today's LN experience.

Let's face it: The most popular LN apps are fully custodial.
They have to be custodial because there is no way to make LN usable for regular users on unreliable phones.

Any payment channel which requires you to be always online excludes 99% of the world's population.
Any payment channel which potentially requires you to be able to pay high on-chain fees excludes most people, too. And on-chain fees keep rising.

Thus, no matter what Channel Factory constructions we build, they will not match most people's requirements. We will keep falling back to custodial solutions.
Excel tables connected to the LN. The LN is awesome as a settlement layer. In particular for anything like bitcoin banks that have been discussed since the beginning.
But why 1000 trusted Excel tables if we can have 1000 trustless sidechains?

From ZmnSCPxj at protonmail.com  Tue Jan 14 02:59:25 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 14 Jan 2020 02:59:25 +0000
Subject: [bitcoin-dev] Coins: A trustless sidechain protocol
In-Reply-To: <2NvYkCEanXxFZvWPT3SJ-8whLGsVQYH_QbAHjPqLZIpeCO9E_mL7cCWTg6Qe4Af8gSMMeizbQQh3pZ-QW91xHDQOfZZUFdoacNOjzEEg85Y=@protonmail.com>
References: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>
 <ILtIOT_2wq-ld0mk5kPev5mw8RQD6pgzSF_EPuY1PE-mdsy8eJqsCaSU-zIyNZw-4W4p5JtLJs5d451PnHvQly-3V1q225bKmdanMZVOmGE=@protonmail.com>
 <0RSAH-PjblJV6Q7TGosFHAEdc9QGauCQ_knCzMwcoGdW4Qt49ts-egDkIwM-X_f0RjsPMquwdnmB6spunH379ICEAJQgUH7R1SE8CuZs7pI=@protonmail.com>
 <6JaReZbjL3U0QrirtiCdgk107cNmQHiLbbJIDctf8uGUiqJOLvZwRLLPUQXAjzfAqRQBpaqtytcKhq1hvtSDwwaKGthwy40SWHDRnTpBkJA=@protonmail.com>
 <6pcznun9_VnOIV7D28YeCiWqSLtPnN7syJvgGVp_VIo_DAZyp2mDYZQxg6IT5dJagroU-TKgUUjLrJm12TlbhLCzwjftY6_OhIB3ej6o44E=@protonmail.com>
 <-XqpIGL2s4yhkiWLsuqhvfpQKm1iRdTZHoTy83d_rKW9bY0Qhz5WHxcET5JSzEMxQUXiq5e-VmDqgp2zZ8locphCSjnztSB_yNV_esq111s=@protonmail.com>
 <2NvYkCEanXxFZvWPT3SJ-8whLGsVQYH_QbAHjPqLZIpeCO9E_mL7cCWTg6Qe4Af8gSMMeizbQQh3pZ-QW91xHDQOfZZUFdoacNOjzEEg85Y=@protonmail.com>
Message-ID: <MAgdbCHb2isOrbTArpYEo9fEdUNI7qTvO3lzU1V5XrBZOR6u8R0YTRV8f5oCUpUGwWjmaWuYqhlowvPEk5GLnliAbETgA--LLp_pZ1LuMXE=@protonmail.com>

Good morning Robin,


> > because all users must process all transactions within the blockchain
>
> Reality shows, that's wrong. Bitcoin's security doesn't require verification to scale quadratically with users. Since the whitepaper, Satoshi was explicit about that phenomena. We can discuss nuances, yet it's overall plausible and empirically it's true: Only a tiny minority of users ever verifies the blockchain, still bitcoin works perfectly well. An honest economic majority is sufficient.
>
> Yes, if you can, run your own node. Let's lower the barriers and let's help others to run their own nodes. Let's keep the blocks small and bitcoin's UTXOs set verifiable with consumer hardware. That's the core of decentralized security.
>
> But let's face it: most people on this planet will never run a bitcoin full node. And it is not required.
>
> Bitcoin-backed PoS-sidechains scale in terms of verification and storage just like any other blockchain. However, security is strictly better because double-spends are impossible. A single honest validating user guarantees that attackers cannot do more harm than halting a sidechain. Thus, endusers won't have to validate all of each others' transactions at all.
>
> For most endusers such sidechains' security is strictly superior to today's LN experience.
>
> Let's face it: The most popular LN apps are fully custodial.
> They have to be custodial because there is no way to make LN usable for regular users on unreliable phones.
>
> Any payment channel which requires you to be always online excludes 99% of the world's population.
> Any payment channel which potentially requires you to be able to pay high on-chain fees excludes most people, too. And on-chain fees keep rising.
>
> Thus, no matter what Channel Factory constructions we build, they will not match most people's requirements. We will keep falling back to custodial solutions.
> Excel tables connected to the LN. The LN is awesome as a settlement layer. In particular for anything like bitcoin banks that have been discussed since the beginning.
> But why 1000 trusted Excel tables if we can have 1000 trustless sidechains?

First:

>  A single honest validating user guarantees that attackers cannot do more harm than halting a sidechain.

Is not compatible with:

> 1000 trustless sidechains

You are *tr\*sting* that there exists at least ***one*** ***honest*** user per sidechain.
Thus it is not a trustless solution, but a tr\*sted one.
Replacing 1000 tr\*sted Excel tables with 1000 tr\*sted blockchains is the same class of error as replacing the banking system with centralized large-scale blockchains: you gain the drawbacks of blockchains without gaining its benefits.

The security, integrity, and censorship-resistance of Bitcoin is dependent on there existing some sophisticated actors ("persons") who are willing to take on the risk of running fullnodes and providing hashpower.
This is the Risk-Sharing principle, by which the risk of keeping Bitcoin running is spread out among many persons who are willing to keep Bitcoin alive.
The existence of such actors cannot be assured, but it seems to me that fragmenting the entire community of such limited number of actors would not give good risk-sharing within a sidechain.

Regards,
ZmnSCPxj

From aj at erisian.com.au  Tue Jan 14 03:20:26 2020
From: aj at erisian.com.au (Anthony Towns)
Date: Tue, 14 Jan 2020 13:20:26 +1000
Subject: [bitcoin-dev] Modern Soft Fork Activation
In-Reply-To: <415e793656ab4326b48d9dc050a85eb8@disroot.org>
References: <415e793656ab4326b48d9dc050a85eb8@disroot.org>
Message-ID: <20200114032026.33ft2qsjk72citpr@erisian.com.au>

On Mon, Jan 13, 2020 at 08:34:24AM +0000, Yosef via bitcoin-dev wrote:
> tl;dr How about 80% ?

The point of having hashpower upgraded is that it means that there's low
liklihood of long chains of blocks that are invalid per the new rules, so
that if you haven't upgraded your node but wait for a few confirmations,
you'll still (with very high liklihood) only see blocks valid per the
new rules.

If you have 80% of miners enforcing the rules, then if someone produces
a block that violates the new rules (but is valid for the old ones),
then you've got a 20% chance of one of the non-enforcing miners getting
the next block, and a 4% chance of non-enforcing miners getting both
the next blocks, giving 3 confirmations to invalid transactions. That
seems a bit high.

3 confirmations isn't unrealistic, eg Coinbase apparently recently
dropped its requirement to that apparently:

https://blog.coinbase.com/announcing-new-confirmation-requirements-4a5504ba8d81

I could maybe see a 90% threshold though?

> 95% can prove difficult to achieve. Some % of negligent miners that forget to upgrade is expected.

Is it? We went from 59% to 54% to 28% to 0% (!!) of blocks not signalling
for segwit during consecutive two-week blocks in the BIP-91/148
period; and from 100% of blocks not signalling for BIP-91 to 99.4%,
48%, 15%, and 11% during consecutive 2.3 day periods targeting an 80%
threshold. Certainly that was a particularly high-stakes period, but
they were both pretty short. For comparison, for CSV, we went from 100%
not signalling to 61%, to 54% to 3.4% in consecutive two-week periods.

> Completing that to 5% is not too difficult for a small malicious minority trying to delay the activation. This is the issue Matt's goal #5 aims to prevent, and while the fallback to BIP-8 helps, BIP-9?s 95% requirement makes it worse by allowing quite a neglected minority to force a dramatic delay. Also note how in such case it would have been better to skip BIP-9 altogether and maybe save 1.5 years.

I don't think you can really skip steps if you need a flag day:

 - the first 12 months is for *really seriously* making sure there's no
   problems with the proposed upgrade; you can't that because people
   might not look for problems until the code's out there and ready for
   actual use

 - the next 6 months is for updating the software to lock in the flag
   day; you can't skip that because it takes time to get new releases out

 - the next 24 months is to ensure everyone's upgraded their nodes so
   that they won't be at risk of thinking they've received bitcoins when
   those coins aren't in compliance with the new rules; and you can't
   skip that because if we don't have hashpower reliably enforcing the
   rules, *everybody* needs to upgrade, which can take a lot of time.

Times could be tweaked, but the "everyone has to upgrade their node
software" is almost the same constraint that hard forks have, so I think
you want to end up with a long overall lead time any which way. For
comparison, 0.12.1 came out about 45 months ago and 0.13.2 came out
about 36 months ago -- about 0.5% of nodes are running 0.12 or earler,
and about 4.9% of nodes are running 0.13 or earlier, at least per [0],
so the overall timeline of 42 months seems plausible to me...

[0] https://luke.dashjr.org/programs/bitcoin/files/charts/software.html

I think (especially if we attempt BIP-91/BIP-148-style compulsory
signalling again) it's worth also considering the failure case if miners
false-signal: that is they signal support of the new soft-fork rules,
but then don't actually enforce them. If you end up with, say, 15% of
hashpower not upgraded or signalling, 25% of hashpower not upgraded but
signalling so their blocks don't get orphaned, and only 65% of hashpower
upgraded, you have a 1% chance of 5 blocks built on top of a block
that's invalid according to the new rules, giving those transactions 6
confirmations as far as non-upgraded nodes are concerned.

Cheers,
aj


From robinlinus at protonmail.com  Tue Jan 14 04:12:56 2020
From: robinlinus at protonmail.com (Robin Linus)
Date: Tue, 14 Jan 2020 04:12:56 +0000
Subject: [bitcoin-dev] Coins: A trustless sidechain protocol
In-Reply-To: <MAgdbCHb2isOrbTArpYEo9fEdUNI7qTvO3lzU1V5XrBZOR6u8R0YTRV8f5oCUpUGwWjmaWuYqhlowvPEk5GLnliAbETgA--LLp_pZ1LuMXE=@protonmail.com>
References: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>
 <ILtIOT_2wq-ld0mk5kPev5mw8RQD6pgzSF_EPuY1PE-mdsy8eJqsCaSU-zIyNZw-4W4p5JtLJs5d451PnHvQly-3V1q225bKmdanMZVOmGE=@protonmail.com>
 <0RSAH-PjblJV6Q7TGosFHAEdc9QGauCQ_knCzMwcoGdW4Qt49ts-egDkIwM-X_f0RjsPMquwdnmB6spunH379ICEAJQgUH7R1SE8CuZs7pI=@protonmail.com>
 <6JaReZbjL3U0QrirtiCdgk107cNmQHiLbbJIDctf8uGUiqJOLvZwRLLPUQXAjzfAqRQBpaqtytcKhq1hvtSDwwaKGthwy40SWHDRnTpBkJA=@protonmail.com>
 <6pcznun9_VnOIV7D28YeCiWqSLtPnN7syJvgGVp_VIo_DAZyp2mDYZQxg6IT5dJagroU-TKgUUjLrJm12TlbhLCzwjftY6_OhIB3ej6o44E=@protonmail.com>
 <-XqpIGL2s4yhkiWLsuqhvfpQKm1iRdTZHoTy83d_rKW9bY0Qhz5WHxcET5JSzEMxQUXiq5e-VmDqgp2zZ8locphCSjnztSB_yNV_esq111s=@protonmail.com>
 <2NvYkCEanXxFZvWPT3SJ-8whLGsVQYH_QbAHjPqLZIpeCO9E_mL7cCWTg6Qe4Af8gSMMeizbQQh3pZ-QW91xHDQOfZZUFdoacNOjzEEg85Y=@protonmail.com>
 <MAgdbCHb2isOrbTArpYEo9fEdUNI7qTvO3lzU1V5XrBZOR6u8R0YTRV8f5oCUpUGwWjmaWuYqhlowvPEk5GLnliAbETgA--LLp_pZ1LuMXE=@protonmail.com>
Message-ID: <9hNzMroHNW8QOHQ9LekmLwudZnfcAz6xloMM3NRKrT8c52uI6-vztXxHQqyOkxsK2kwNmn61EvhBabZIpsnHW7QNGV1mRJtZ2Zx-UFSfx68=@protonmail.com>

Good morning ZmnSCPxj,

> > > because all users must process all transactions within the blockchain
> >
> > Reality shows, that's wrong. Bitcoin's security doesn't require verification to scale quadratically with users. Since the whitepaper, Satoshi was explicit about that phenomena. We can discuss nuances, yet it's overall plausible and empirically it's true: Only a tiny minority of users ever verifies the blockchain, still bitcoin works perfectly well. An honest economic majority is sufficient.
> > Yes, if you can, run your own node. Let's lower the barriers and let's help others to run their own nodes. Let's keep the blocks small and bitcoin's UTXOs set verifiable with consumer hardware. That's the core of decentralized security.
> > But let's face it: most people on this planet will never run a bitcoin full node. And it is not required.
> > Bitcoin-backed PoS-sidechains scale in terms of verification and storage just like any other blockchain. However, security is strictly better because double-spends are impossible. A single honest validating user guarantees that attackers cannot do more harm than halting a sidechain. Thus, endusers won't have to validate all of each others' transactions at all.
> > For most endusers such sidechains' security is strictly superior to today's LN experience.
> > Let's face it: The most popular LN apps are fully custodial.
> > They have to be custodial because there is no way to make LN usable for regular users on unreliable phones.
> > Any payment channel which requires you to be always online excludes 99% of the world's population.
> > Any payment channel which potentially requires you to be able to pay high on-chain fees excludes most people, too. And on-chain fees keep rising.
> > Thus, no matter what Channel Factory constructions we build, they will not match most people's requirements. We will keep falling back to custodial solutions.
> > Excel tables connected to the LN. The LN is awesome as a settlement layer. In particular for anything like bitcoin banks that have been discussed since the beginning.
> > But why 1000 trusted Excel tables if we can have 1000 trustless sidechains?
>
> First:
>
> > A single honest validating user guarantees that attackers cannot do more harm than halting a sidechain.
>
> Is not compatible with:
>
> > 1000 trustless sidechains
>
> You are *tr\sting that there exists at least one honest user per sidechain.
> Thus it is not a trustless solution, but a tr\*sted one.
> Replacing 1000 tr\*sted Excel tables with 1000 tr\*sted blockchains is the same class of error as replacing the banking system with centralized large-scale blockchains: you gain the drawbacks of blockchains without gaining its benefits.

Agreed. Still, let's discuss a solution that meets the requirements of billions of average users with unreliable mobile devices.

Endusers payment experience should be insanely simple.

The LN currently offers regular users mostly custodial services. Is there a foreseeable roadmap to meet endusers' simplicity requirements with non-custodial constructions?

Bitcoin-backed PoS sidechains are strictly superior to custodial hubs. They provide all hub features such as being able to pay merchants in BTC, plus many clear advantages such as better security including public auditability and decentralized data storage. And they do not require any consensus changes.


> The security, integrity, and censorship-resistance of Bitcoin is dependent on there existing some sophisticated actors ("persons") who are willing to take on the risk of running fullnodes and providing hashpower.
> This is the Risk-Sharing principle, by which the risk of keeping Bitcoin running is spread out among many persons who are willing to keep Bitcoin alive.
> The existence of such actors cannot be assured, but it seems to me that fragmenting the entire community of such limited number of actors would not give good risk-sharing within a sidechain.

Indeed, a highly fragmented market would be inefficient and insecure. However, I'd assume a free market of sidechains is intelligent enough to use its resources efficiently.


Thanks again for your detailed feedback,
-Robin

From joachimstr at protonmail.com  Tue Jan 14 15:06:32 2020
From: joachimstr at protonmail.com (=?UTF-8?Q?Joachim_Str=C3=B6mbergson?=)
Date: Tue, 14 Jan 2020 15:06:32 +0000
Subject: [bitcoin-dev] Coins: A trustless sidechain protocol
In-Reply-To: <6pcznun9_VnOIV7D28YeCiWqSLtPnN7syJvgGVp_VIo_DAZyp2mDYZQxg6IT5dJagroU-TKgUUjLrJm12TlbhLCzwjftY6_OhIB3ej6o44E=@protonmail.com>
References: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>
 <ILtIOT_2wq-ld0mk5kPev5mw8RQD6pgzSF_EPuY1PE-mdsy8eJqsCaSU-zIyNZw-4W4p5JtLJs5d451PnHvQly-3V1q225bKmdanMZVOmGE=@protonmail.com>
 <0RSAH-PjblJV6Q7TGosFHAEdc9QGauCQ_knCzMwcoGdW4Qt49ts-egDkIwM-X_f0RjsPMquwdnmB6spunH379ICEAJQgUH7R1SE8CuZs7pI=@protonmail.com>
 <6JaReZbjL3U0QrirtiCdgk107cNmQHiLbbJIDctf8uGUiqJOLvZwRLLPUQXAjzfAqRQBpaqtytcKhq1hvtSDwwaKGthwy40SWHDRnTpBkJA=@protonmail.com>
 <6pcznun9_VnOIV7D28YeCiWqSLtPnN7syJvgGVp_VIo_DAZyp2mDYZQxg6IT5dJagroU-TKgUUjLrJm12TlbhLCzwjftY6_OhIB3ej6o44E=@protonmail.com>
Message-ID: <beLVDOWDR2iV7hnmLpR4bBal2QWxAYqayzw8r9CRc5afhyqZjGIQZQZEerwIIXcmRC9KFigFDFu5_CU4vxoeLFxhNrDGUaZy44_JOs3asmk=@protonmail.com>

Hi Robin.

While your motivation seems reasonable, your solution is not. It is not enough that a problem exists. Although the solution must be technically sound for the proposal to be interesting. So I agree it makes sense to consider Bitcoin sidechains, not sure if with PoS consensus or other, but no one yet proposed a viable solution, other than Federation based sidechains. Your proposal explored a single specific PoS sidechain, which to me does not sound interesting. Maybe you can improve it, maybe not.

I also disagree that it is okay if anyone can halt operation of a sidechain with just tiny investment. For me that is critical security flaw of your proposal. By enforcing stakers having to stake per chain you have actually lowered the cost for the attacker to attack each specific chain.

Sent with [ProtonMail](https://protonmail.com) Secure Email.

??????? Original Message ???????
On Monday, January 13, 2020 10:22 PM, Robin Linus <robinlinus at protonmail.com> wrote:

> Hi Joachim,
>
>>> Regarding Reason #1:
>>> This proposal is less like Bitcoin vs. Altcoins and much more like Ethereum vs. ERC20 tokens, because the derivatives are not in competition with BTC, but depend on it heavily. You support Bitcoin's growth by supporting such a sidechain.
>>> Also, they won't work as separate currencies. For endusers you can abstract away all underlying complexities such that they have to think only in BTC. Exchanges rates can be hidden in TX fees. The sidechain derivatives would be nothing but a means of transfer. The unit of account is still BTC.
>>
>> I can't see any difference and advantage over doing the same with say Litecoin. All you need is to create a special wallet which offers atomic swaps LTC-BTC and its unit of account displayed to user is going to be BTC. All you say will work perfectly with this special LTC wallet. Therefore your idea is as good as any other altcoin. In your case, someone else should indeed be able to create such a wallet in which the unit of account will be the new token, thus emulating the current LTC wallets. So the only difference in Litecoin is that the special wallet with BTC as unit is going to be created after the native one, while in your case it is vice versa.
>>
>> I simply can't see why I'd call this construction of yours a Bitcoin sidechain and any other altcoin not. So I'd call both altcoins.
>
> Let me try to explain where I am coming from: Whenever I want to onboard a not-so-techy friend to Bitcoin by sending him $5 worth of BTC, I don't have many good options. Usually we end up using BlueWallet. It works great. Though it only works so well because it is fully custodial. That is how they solve all the tough LN problems like inbound-capacity of new users, watchtowers and channel backends. Their service is just an Excel table connect to the LN. Unfortunately, that is the best UX we can currently offer to endusers. To me that's unsatisfying. Is that how we want to enter the emerging markets and on-board the next Billion users? I like that BlueWallet gives me the option to run my own LndHub for my friends. Still, does that scale globally? More importantly, do we want that?
>
> Now let's think about the altcoins argument. We want to serve a billion users. Blockchains do scale well to about a couple Million UTXOs, so we require a network of a couple thousand altcoins to serve our users.
> We know how to build a nice LN for all of our altcoins with a star-shaped topology around Bitcoin as the central settlement layer. Atomic swaps FTW. We can abstract away their native currencies. We display to our users only BTC, hide the exchange rates in the TX fees and we're done. That is actually a scalability solution. So why don't we do that?
> The problem here is, that In the long term, the market of PoW blockchains should be a winner-takes-all market, right? So all PoW chains but Bitcoin will eventually die because they're wasting lots of value on their energy. So actually we don't want a couple thousand altcoins wasting resources on pointlessly weak PoW chains. We want a single PoW chain which is as strong as possible.
>
> That's why I'd argue it makes sense to consider a bitcoin-backed PoS and build a LN of thousands of nameless altcoins.
>
> Regarding sidechain security: Burning BTC is almost equivalent to burning energy. You might argue that people won't burn BTC, but it is hard to argue against the strong theoretical security properties of proof-of-burn.
>
> Furthermore, even without burning BTC, using only proof-of-stake I can guarantee doublespending is impossible. There is a very low incentive to risk your BTC's time value. You can only halt a sidechain. And you can halt the sidechain only for as long as you maintain the staking majority. Once you start an attack, you increase the incentive for others to increase their stake. Staking happens in bitcoin's blockchain, which you can't halt. Once the rational stakers regain 51% you've lost a year of time value of your BTC. Note that you can easily enforce stakers having to stake per chain. This guarantees attackers can use their BTC only to attack one chain per year.
> Thus, the security of such a bitcoin-based PoS is stronger then one might suspect.
>
> Thanks again,
> - Robin
>
>>> Regarding Reason #2:
>>> In the "Limitations" section I discuss the cost of halting the chain:
>>>
>>> Time value of locked bitcoins might be too cheap to protect the chain. We can introduce an additional cost and let validators burn bitcoins for every on-chain vote. This is much more robust because there is an ongoing cost for halting the system. Proof-of-burn has recently been formally analysed [16]. The economic implications of burning significant amounts of Bitcoin are questionable. A level of security comparable to Bitcoin requires the system?s BTC burn rate to be equal to Bitcoin?s infaltion rate.
>>>
>>> Also remember, time value of Bitcoins is indeed a value. Even without a proof of burn, I'd consider such sidechains much more secure than those custodial lightning wallets which become more and more popular to circumvent the usability hurdles of the LN.
>>
>> Comparison to other models is not relevant to my claim that such construction is insecure for small sidechains. And for big sidechains the reason #1 prefers any other altcoin. Even if you introduce proof of burn, the final attack cost is small for an attacker in absolute numbers, despite the fact that in the relative numbers the cost is huge.
>>
>>> Thanks again,
>>> - Robin
>>>
>>> Sent with [ProtonMail](https://protonmail.com) Secure Email.
>>>
>>> ??????? Original Message ???????
>>> On Monday, January 13, 2020 7:06 PM, Joachim Str?mbergson <joachimstr at protonmail.com> wrote:
>>>
>>>> While I haven't rejected sidechains entirely yet, this particular proposal seems uninteresting, especially for two reasons.
>>>>
>>>> One ? it introduces a new token for each sidechain and suggests atomic swaps to be used for the exchange of the mainchain token with the sidechain token. Such a model seems nonsensical to me because there seems to be excessive number of blockchain projects that can be used similarly just as the sidechain in this proposal. Pick almost any altcoin out there and you can atomic swap it with Bitcoin. The fact that your sidechain is somehow mathematically bound to Bitcoin seems arbitrary because at the end you have a new token and a new issuance model. Therefore this is not extending Bitcoin economy, which is strictly limited by its convergence to zero inflation. This proposal is inflating the supply with a new token, which goes against what many people consider as a pillar of Bitcoin's value proposal. I think if you implement this proposal, you are going not to be considered as a Bitcoin sidechain, but you will be, from certain point of view, indistinguishable from any other altcoin. At the level of my current understanding, the only interesting sidechain model is the [theoretical] one with a two way peg with Bitcoin, preserving the issuance policy of Bitcoin.
>>>>
>>>> Two ? the security of the proposed system seems to be very fragile, unless I have missed something. When I think about sidechains, I expect that it should be possible to create a niche chain which is used by few participants while the security of the chain is somehow guaranteed from its bind to the mainchain. If this was not the case, such a niche sidechain could easily be attacked, even if just stalled/censored for a long period time, with just a small [absolute] investment from an attacker, although this investment might be large if taken relatively to the utility of this niche sidechain. So if we speak concretely about your proposal, you assume honest majority of validators. But in your system the validators come from locking of stake on Bitcoin chain by nodes that are interested in a particular sidechain. If you put this model on a niche chain where only few participants are interested in it, it's trivial for an attacker to be stronger [have more Bitcoin to lock] than all legitimate users together. You should only use honest majority assumption where the scope is global, where it is very hard and very expensive to obtain majority.
>>>>
>>>> Sent with [ProtonMail](https://protonmail.com) Secure Email.
>>>>
>>>> ??????? Original Message ???????
>>>> On Sunday, January 12, 2020 6:54 PM, Robin Linus via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>
>>>>> Hi all,
>>>>>
>>>>> I've been working on a sidechain protocol with no trusted third party. You can find the [whitepaper here](http://coins.github.io/coins.pdf).
>>>>>
>>>>> Abstract. Coins is a Bitcoin extension designed for payments at scale. We propose an efficient solution to the double-spending problem using a bitcoin-backed proof-of-stake.  Validators vote on sidechain blocks with one-time signatures, forming a record that cannot be changed without destroying their collateral. Every user can become a validator by locking bitcoins. One-time signatures guarantee that validators loose their stake for publishing conflicting histories. Checkpoints can be additionally secured with a bitcoin-backed proof-of-burn. Assuming a rational majority of validators, the sidechain provides safety and liveness. The sidechain?s footprint within bitcoin?s blockchain is minimal. The protocol is a generic consensus mechanism allowing for arbitrary sidechain assets. Spawning multiple, independent instances scales horizontally.
>>>>>
>>>>> Feedback is highly appreciated!
>>>>>
>>>>> Thank you
>>>>>
>>>>> - Robin
>>>>>
>>>>> PS: [Here on Github you can find further research on scalability and usability](https://github.com/coins/coins.github.io).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200114/72b4fc9b/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Tue Jan 14 15:26:18 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 14 Jan 2020 15:26:18 +0000
Subject: [bitcoin-dev] Coins: A trustless sidechain protocol
In-Reply-To: <beLVDOWDR2iV7hnmLpR4bBal2QWxAYqayzw8r9CRc5afhyqZjGIQZQZEerwIIXcmRC9KFigFDFu5_CU4vxoeLFxhNrDGUaZy44_JOs3asmk=@protonmail.com>
References: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>
 <ILtIOT_2wq-ld0mk5kPev5mw8RQD6pgzSF_EPuY1PE-mdsy8eJqsCaSU-zIyNZw-4W4p5JtLJs5d451PnHvQly-3V1q225bKmdanMZVOmGE=@protonmail.com>
 <0RSAH-PjblJV6Q7TGosFHAEdc9QGauCQ_knCzMwcoGdW4Qt49ts-egDkIwM-X_f0RjsPMquwdnmB6spunH379ICEAJQgUH7R1SE8CuZs7pI=@protonmail.com>
 <6JaReZbjL3U0QrirtiCdgk107cNmQHiLbbJIDctf8uGUiqJOLvZwRLLPUQXAjzfAqRQBpaqtytcKhq1hvtSDwwaKGthwy40SWHDRnTpBkJA=@protonmail.com>
 <6pcznun9_VnOIV7D28YeCiWqSLtPnN7syJvgGVp_VIo_DAZyp2mDYZQxg6IT5dJagroU-TKgUUjLrJm12TlbhLCzwjftY6_OhIB3ej6o44E=@protonmail.com>
 <beLVDOWDR2iV7hnmLpR4bBal2QWxAYqayzw8r9CRc5afhyqZjGIQZQZEerwIIXcmRC9KFigFDFu5_CU4vxoeLFxhNrDGUaZy44_JOs3asmk=@protonmail.com>
Message-ID: <FMYpymM9ePfMzdSqBtwf5oRl4bL6XMmDkCrwWMqBW8CK-lz4d0zjpk4oDuU7lWa16wV3Tmtnjd4LTs8Oi8-BIz_ce1rp-jK8ot9Apeo48BA=@protonmail.com>

As well I would like to point out that in order to receive funds, *something* has to be online to get the message that receives the data.
In the blockchain layer this is diffused among all fullnodes.

At the Lightning layer, your direct peer could hold off on failing an incoming payment while you are offline.
Instead, it could simply stall until the outgoing HTLC would reach its timelock anyway.
Then you can come online and then the peer can send the HTLC to you and you can claim it.
This remains noncustodial as the direct peer cannot steal the funds from you.
I believe there was some discussion regarding this on lightning-dev in the past few months.
However, it does require that the peer know that *you* are the final recipient (if not, it would be unable to fail the HTLC as quickly as possible), thus a privacy leak.

In any case *some* node has to be online in order for anyone to receive funds, whether onchain or not: it is simply that a widespread blcokchain is very very likely to have some online node capable of storing the payment until you can come online to process it.
What you propose splits up the fullnodes into many tiny sidechains, such that a sidechain may get stalled and you would be unable to receive a payment anyway while you are offline, because there are far fewer nodes per sidechain in order for such mass sidechains to start beating the raw scaling Lightning brings.

Regards,
ZmnSCPxj

> Hi Robin.
>
> While your motivation seems reasonable, your solution is not. It is not enough that a problem exists. Although the solution must be technically sound for the proposal to be interesting. So I agree it makes sense to consider Bitcoin sidechains, not sure if with PoS consensus or other, but no one yet proposed a viable solution, other than Federation based sidechains. Your proposal explored a single specific PoS sidechain, which to me does not sound interesting. Maybe you can improve it, maybe not.
>
> I also disagree that it is okay if anyone can halt operation of a sidechain with just tiny investment. For me that is critical security flaw of your proposal. By enforcing stakers having to stake per chain you have actually lowered the cost for the attacker to attack each specific chain.
>
> Sent with ProtonMail Secure Email.
>
> ??????? Original Message ???????
> On Monday, January 13, 2020 10:22 PM, Robin Linus <robinlinus at protonmail.com> wrote:
>
> > Hi Joachim,
> >
> > > > Regarding Reason #1:
> > > > This proposal is less like Bitcoin vs. Altcoins and much more like Ethereum vs. ERC20 tokens, because the derivatives are not in competition with BTC, but depend on it heavily. You support Bitcoin's growth by supporting such a sidechain.?
> > > > Also, they won't work as separate currencies. For endusers you can abstract away all underlying complexities such that they have to think only in BTC. Exchanges rates can be hidden in TX fees. The sidechain derivatives would be nothing but a means of transfer. The unit of account is still BTC.?
> > >
> > > I can't see any difference and advantage over doing the same with say Litecoin. All you need is to create a special wallet which offers atomic swaps LTC-BTC and its unit of account displayed to user is going to be BTC. All you say will work perfectly with this special LTC wallet. Therefore your idea is as good as any other altcoin. In your case, someone else should indeed be able to create such a wallet in which the unit of account will be the new token, thus emulating the current LTC wallets. So the only difference in Litecoin is that the special wallet with BTC as unit is going to be created after the native one, while in your case it is vice versa.
> > >
> > > I simply can't see why I'd call this construction of yours a Bitcoin sidechain and any other altcoin not. So I'd call both altcoins.
> >
> > Let me try to explain where I am coming from: Whenever I want to onboard a not-so-techy friend to Bitcoin by sending him $5 worth of BTC, I don't have many good options. Usually we end up using BlueWallet. It works great. Though it only works so well because it is fully custodial. That is how they solve all the tough LN problems like inbound-capacity of new users, watchtowers and channel backends. Their service is just an Excel table connect to the LN. Unfortunately, that is the best UX we can currently offer to endusers. To me that's unsatisfying. Is that how we want to enter the emerging markets and on-board the next Billion users? I like that BlueWallet gives me the option to run my own LndHub for my friends. Still, does that scale globally? More importantly, do we want that?
> >
> > Now let's think about the altcoins argument. We want to serve a billion users. Blockchains do scale well to about a couple Million UTXOs, so we require a network of a couple thousand altcoins to serve our users.
> > We know how to build a nice LN for all of our altcoins with a star-shaped topology around Bitcoin as the central settlement layer. Atomic swaps FTW. We can abstract away their native currencies. We display to our users only BTC, hide the exchange rates in the TX fees and we're done. That is actually a scalability solution. So why don't we do that?
> > The problem here is, that In the long term, the market of PoW blockchains should be a winner-takes-all market, right? So all PoW chains but Bitcoin will eventually die because they're wasting lots of value on their energy. So actually we don't want a couple thousand altcoins wasting resources on pointlessly weak PoW chains. We want a single PoW chain which is as strong as possible.
> >
> > That's why I'd argue it makes sense to consider a bitcoin-backed PoS and build a LN of thousands of nameless altcoins.
> >
> > Regarding sidechain security: Burning BTC is almost equivalent to burning energy. You might argue that people won't burn BTC, but it is hard to argue against the strong theoretical security properties of proof-of-burn.
> >
> > Furthermore, even without burning BTC, using only proof-of-stake I can guarantee doublespending is impossible. There is a very low incentive to risk your BTC's time value. You can only halt a sidechain. And you can halt the sidechain only for as long as you maintain the staking majority. Once you start an attack, you increase the incentive for others to increase their stake. Staking happens in bitcoin's blockchain, which you can't halt. Once the rational stakers regain 51% you've lost a year of time value of your BTC. Note that you can easily enforce stakers having to stake per chain. This guarantees attackers can use their BTC only to attack one chain per year.?
> > Thus, the security of such a bitcoin-based PoS is stronger then one might suspect.
> >
> > Thanks again,
> > - Robin
> >
> > > > Regarding Reason #2:
> > > > In the "Limitations" section I discuss the cost of halting the chain:
> > > >
> > > > Time value of locked bitcoins might be too cheap to protect the chain. We can introduce an additional cost and let validators burn bitcoins for every on-chain vote. This is much more robust because there is an ongoing cost for halting the system. Proof-of-burn has recently been formally analysed [16]. The economic implications of burning significant amounts of Bitcoin are questionable. A level of security comparable to Bitcoin requires the system?s BTC burn rate to be equal to Bitcoin?s infaltion rate.
> > > >
> > > > Also remember, time value of Bitcoins is indeed a value. Even without a proof of burn, I'd consider such sidechains much more secure than those custodial lightning wallets which become more and more popular to circumvent the usability hurdles of the LN.
> > >
> > > Comparison to other models is not relevant to my claim that such construction is insecure for small sidechains. And for big sidechains the reason #1 prefers any other altcoin. Even if you introduce proof of burn, the final attack cost is small for an attacker in absolute numbers, despite the fact that in the relative numbers the cost is huge.
> > >
> > > > Thanks again,?
> > > > - Robin
> > > >
> > > > Sent with ProtonMail Secure Email.
> > > >
> > > > ??????? Original Message ???????
> > > > On Monday, January 13, 2020 7:06 PM, Joachim Str?mbergson <joachimstr at protonmail.com> wrote:
> > > >
> > > > > While I haven't rejected sidechains entirely yet, this particular proposal seems uninteresting, especially for two reasons.
> > > > >
> > > > > One ? it introduces a new token for each sidechain and suggests atomic swaps to be used for the exchange of the mainchain token with the sidechain token. Such a model seems nonsensical to me because there seems to be excessive number of blockchain projects that can be used similarly just as the sidechain in this proposal. Pick almost any altcoin out there and you can atomic swap it with Bitcoin. The fact that your sidechain is somehow mathematically bound to Bitcoin seems arbitrary because at the end you have a new token and a new issuance model. Therefore this is not extending Bitcoin economy, which is strictly limited by its convergence to zero inflation. This proposal is inflating the supply with a new token, which goes against what many people consider as a pillar of Bitcoin's value proposal. I think if you implement this proposal, you are going not to be considered as a Bitcoin sidechain, but you will be, from certain point of view, indistinguishable from any other altcoin. At the level of my current understanding, the only interesting sidechain model is the [theoretical] one with a two way peg with Bitcoin, preserving the issuance policy of Bitcoin.
> > > > >
> > > > > Two ? the security of the proposed system seems to be very fragile, unless I have missed something. When I think about sidechains, I expect that it should be possible to create a niche chain which is used by few participants while the security of the chain is somehow guaranteed from its bind to the mainchain. If this was not the case, such a niche sidechain could easily be attacked, even if just stalled/censored for a long period time, with just a small [absolute] investment from an attacker, although this investment might be large if taken relatively to the utility of this niche sidechain. So if we speak concretely about your proposal, you assume honest majority of validators. But in your system the validators come from locking of stake on Bitcoin chain by nodes that are interested in a particular sidechain. If you put this model on a niche chain where only few participants are interested in it, it's trivial for an attacker to be stronger [have more Bitcoin to lock] than all legitimate users together. You should only use honest majority assumption where the scope is global, where it is very hard and very expensive to obtain majority.
> > > > >
> > > > > Sent with ProtonMail Secure Email.
> > > > >
> > > > > ??????? Original Message ???????
> > > > > On Sunday, January 12, 2020 6:54 PM, Robin Linus via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > > > >
> > > > > > Hi all,
> > > > > >
> > > > > > I've been working on a sidechain protocol with no trusted third party. You can find thewhitepaper here.
> > > > > >
> > > > > > Abstract.Coins is a Bitcoin extension designed for payments at scale.?We propose an efficient solution to the double-spending problem using a bitcoin-backed proof-of-stake.? Validators vote on sidechain blocks with one-time signatures, forming a record that cannot be changed without destroying their collateral. Every user can become a validator by locking bitcoins.?One-time signatures guarantee that validators loose their?stake?for?publishing?conflicting?histories. Checkpoints?can?be?additionally secured with a bitcoin-backed proof-of-burn.?Assuming a rational majority of validators, the sidechain provides safety and liveness. The sidechain?s footprint within bitcoin?s blockchain is minimal.?The protocol is a generic consensus mechanism allowing for arbitrary sidechain assets. Spawning multiple, independent instances scales horizontally.
> > > > > >
> > > > > > Feedback is highly appreciated!
> > > > > >
> > > > > > Thank you
> > > > > >
> > > > > > - Robin
> > > > > >
> > > > > > PS:Here on Github you can find further research on scalability and usability.



From lf-lists at mattcorallo.com  Tue Jan 14 19:22:47 2020
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Tue, 14 Jan 2020 19:22:47 +0000
Subject: [bitcoin-dev] Modern Soft Fork Activation
In-Reply-To: <202001102337.53397.luke@dashjr.org>
References: <4a132f8a-22e3-8e31-e338-bed9ef46d2ef@mattcorallo.com>
 <202001102337.53397.luke@dashjr.org>
Message-ID: <e77c5ee7-bb47-477b-2458-778d4b5c2231@mattcorallo.com>

Good thing no one is proposing a naive BIP 9 approach :). I'll note that
BIP 9 has been fairly robust (spy-mining issues notwithstanding, which
we believe are at least largely solved in the wild) in terms of safety,
though I noted extensively in the first mail that it failed in terms of
misunderstanding the activation parameters. I think the above proposal
largely solves that, and I don't see much in the way of arguing that
point from you, here.

As an aside, BIP 9 is also the Devil We Know, which carries a lot of
value, since we've found (and addressed) direct issues with it, whereas
all other activation methods we have ~0 experience with in the modern
Bitcoin network.

On 1/10/20 11:37 PM, Luke Dashjr wrote:
> I think BIP 9 is a proven failure, and flag day softforks have their own 
> problems:
> 
> A) There is no way to unambiguously say "the rules for this chain are 
> <x,y,z>". It leaves the chain in a kind of "quantum state" where the rules 
> could be one thing, or could be another. Until the new rules are violated, we 
> do not know if the softfork was a success or not. Because of this, people 
> will rightly shy away from relying on the new rules. This problem is made 
> worse by the fact that common node policies might not produce blocks which 
> violate the rules. If we had gone with BIP149 for Segwit, it is IMO probable 
> we would still not have a clear answer today to "Is Segwit active or not?"
> 
> B) Because of (A), there is also no clear way to intentionally reject the 
> softfork. Those who do not consent to it are effectively compelled to accept 
> it anyway. While it is usually possible to craft an opposing softfork, this 
> should IMO be well-defined and simple to do (including a plan to do so in any 
> BIP9-alike spec).
> 
> For these reasons, in 2017, I proposed revising BIP 8 with a mandatory signal, 
> similar to how BIP148 worked: https://github.com/bitcoin/bips/pull/550
> However, the author of BIP 8 has since vanished, and because we had no 
> immediate softfork plans, efforts to move this forward were abandoned 
> temporarily. It seems like a good time to resume this work.
> 
> In regard to your goal #3, I would like to note that after the mandatory 
> signal period, old miners could resume mining unchanged. This means there is 
> a temporary loss of hashrate to the network, but I think it is overall better 
> than the alternatives. The temporary loss of income from invalid blocks will 
> also give affected miners a last push to upgrade, hopefully improving the 
> long run security of the network hashrate.
> 
> Luke
> 
> (P.S. As for your #1, I do think it is oversimplified in some cases, but we 
> should leave that for later discussion when it actually becomes relevant.)

From lf-lists at mattcorallo.com  Tue Jan 14 19:42:07 2020
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Tue, 14 Jan 2020 19:42:07 +0000
Subject: [bitcoin-dev] Modern Soft Fork Activation
In-Reply-To: <20200111144207.5xzspeptstspsbsf@erisian.com.au>
References: <20200111144207.5xzspeptstspsbsf@erisian.com.au>
Message-ID: <a7fc5d7f-9b11-ed8e-0513-fd863881290e@mattcorallo.com>

In general, your thoughts on the theory of how consensus changes should
work I strongly agree with. However, my one significant disagreement is
how practical it is for things to *actually* work that way. While I wish
ecosystem players (both businesses and users) spent their time
interacting with the Bitcoin development community enough that they had
a deep understanding of upcoming protocol change designs, it just isn't
realistic to expect that. Thus, having an "out" to avoid activation
after a release has been cut with fork activation logic is quite a
compelling requirement.

Thus, part of the goal here is that we ensure we have that "out", and
can observe the response of the ecosystem once the change is "staring
them in the face", as it were. A BIP 9 process is here not only to offer
a compelling activation path, but *also* to allow for observation and
discussion time for any lingering minor objections prior to a BIP 8/flag
day activation.

As for a "mandatory signaling period" as a part of BIP 8, I find this
idea strange both in that it flies in the face of all recent soft fork
design work, and because it doesn't actually accomplish its stated goal.

Recent soft-fork design has all been about how to design something with
minimal ecosystem impact. Certainly in the 95% activation case I can't
say I feel strongly, but if you actually *hit* the BIP 8 flag day,
deliberately causing significant network forks for old clients has the
potential to cause real ecosystem risk. While part of the reason for a
24-month time horizon between BIP 8 decision and flag-day activation
endeavors to de-risk the chance that major players are running on
un-upgraded nodes, you cannot ignore the reality of them, both full-,
and SPV-clients.

On the other hand, in practice, we've seen that version bits are set on
the pool side, and not on the node side, meaning the goal of ensuring
miners have upgraded isn't really accomplished in practice, you just end
up forking the chain for no gain.

Matt

On 1/11/20 2:42 PM, Anthony Towns wrote:
> On Fri, Jan 10, 2020 at 09:30:09PM +0000, Matt Corallo via bitcoin-dev wrote:
>> 1) a standard BIP 9 deployment with a one-year time horizon for
>> activation with 95% miner readiness,
>> 2) in the case that no activation occurs within a year, a six month
>> quieting period during which the community can analyze and discussion
>> the reasons for no activation and,
>> 3) in the case that it makes sense, a simple command-line/bitcoin.conf
>> parameter which was supported since the original deployment release
>> would enable users to opt into a BIP 8 deployment with a 24-month
>> time-horizon for flag-day activation (as well as a new Bitcoin Core
>> release enabling the flag universally).
> 
> FWIW etc, but my perspective on this is that the way we want consensus
> changes in Bitcoin to work is:
> 
>  - decentralised: we want everyone to be able to participate, in
>    designing/promoting/reviewing changes, without decision making
>    power getting centralised amongst one group or another
> 
>  - technical: we want changes to be judged on their objective technical
>    merits; politics and animal spirits and the like are fine, especially
>    for working out what to prioritise, but they shouldn't be part of the
>    final yes/no decision on consensus changes
> 
>  - improvements: changes might not make everyone better off, but we
>    don't want changes to screw anyone over either -- pareto
>    improvements in economics, "first, do no harm", etc. (if we get this
>    right, there's no need to make compromises and bundle multiple
>    flawed proposals so that everyone's an equal mix of happy and
>    miserable)
> 
> In particular, we don't want to misalign skills and responsibilities: it's
> fine for developers to judge if a proposal has bugs or technical problems,
> but we don't want want developers to have to decide if a proposal is
> "sufficiently popular" or "economically sound" and the like, for instance.
> Likewise we don't want to have miners or pool operators have to take
> responsibility for managing the whole economy, rather than just keeping
> their systems running.
> 
> So the way I hope this will work out is:
> 
>  - investors, industry, people in general work out priorities for what's
>    valuable to work on; this is an economic/policy/subjective question,
>    that everyone can participate in, and everyone can act on --
>    either directly if they're developers who can work on proposals and
>    implementations directly, or indirectly by persuading or paying other
>    people to work on whatever's important
> 
>  - developers work on proposals, designing and implementing them to make
>    (some subset of) bitcoin users better off, and to not make anyone worse
>    off.
> 
>  - if someone discovers a good technical reason why a proposal does make
>    people worse off, we don't try to keep pushing the proposal over the
>    top of objections, but go back to the drawing board and try to fix
>    the problems
> 
>  - once we've done as much development as we can, including setting up
>    experimental testnet/signet style deployments for testing, we setup a
>    deployment. the idea at this point is to make sure the live network
>    upgrade works, and to retain the ability to abort if last minute
>    problems come up. no doubt some review and testing will be left until
>    the last minute and only done here, but *ideally* the focus should be
>    on catching errors *well before* this point.
> 
>  - as a result, the activation strategy mostly needs to be about ensuring
>    that the Bitcoin network stays in consensus, rather than checking
>    popularity or voting -- the yes/no decisions should have mostly been
>    made earlier already. so we have two strategies for locking in the
>    upgrade: either 95%+ of hashpower signals that they've upgraded to
>    software that will enforce the changes forever more, _or_ after a
>    year of trying to deploy, we fail to find any technical problems,
>    and then allow an additional 2.5 years to ensure all node software is
>    upgraded to enforce the new rules before locking them in.
> 
> The strategy behind the last point is that we need to establish that
> there's consensus amongst all of Bitcoin before we commit to a flag day,
> and if we've found some method to establish consensus on that, then we're
> done -- we've already got consensus, we don't need to put a blockchain
> protocol on top of that and signal that we've got consensus. (Activating
> via hashpower still needs signalling, because we need to coordinate on
> *when* sufficient hashpower has upgraded)
> 
> This approach is obviously compatible with BIP-148 or BIP-91 style
> forced-signalling UASFs if some upgrade does need to be done urgently
> despite miner opposition; the forced signalling just needs to occur during
> the BIP-9 or BIP-8 phases, and no during the "quiet period". Probably the
> first period of BIP-8 after the quiet period would make the most sense.
> 
> But without that, this approach seems very friendly for miners: even
> if they don't upgrade, they won't mine invalid blocks (unless the rules
> activate and someone else deliberately mines an invalid block and they
> build on top of it), and if a change is incompatible with, say 10%
> of hashpower, it won't be forced on them for 3.5 years, by which point
> it's probably a good bet that everyone's upgrading to a new generation
> of mining hardware anyway. But even that's a backstop, because if a
> change *is* incompatible with existing mining hardware, that's an easily
> describable technical problem that should mean we go back to the drawing
> board and fix it, not deploy the change despite the problems. [0]
> 
> On Fri, Jan 10, 2020 at 11:21:51PM +0100, Jorge Tim?n via bitcoin-dev wrote:
>> Regarding bip8-like activation, luke-jr suggested that [..] a
>> consensus rule could require the blocks to signal for activation in
>> the last activation window.
> 
> FWIW, that had been my (strong) preference too, but I think I'm now
> convinced it's not needed/useful.
> 
>> I see 2 main advantages for this:
>> 1) Outdated nodes can implement warnings (like in bip9) and they can
>> see those warnings even if it's activated in the last activation
>> window.
> 
> The 3.5 year window from BIP-9-starttime to BIP-8-flagday means you'd
> have to be using *very* out of date software to need to autodetect
> unknown upgrades. If an upgrade starts on 2021-01-01 say, it'd be
> supported by 0.21.x, 0.22.0, and 0.23.0 (with bip8 as an opt-in) and
> 0.24.0, 0.25.0, 0.26.0, 0.27.0, and 0.28.0 (with bip8 as always on)
> before flag day activation on 2024-06-01.
> 
> 0.21.x to 0.23.x could warn if they see potential early BIP-8 activation
> via versionbits, and also warn if the flag day date is seen saying "flag
> day activation may have happened, please check external sources and
> consider upgrading your node software".
> 
> So you'd need to be running 0.20.x, released 4 years prior to the
> activation to be outdated enough to not get warnings, I think.
> 
>> 2) It is easier for users to actively resist a given change they
>> oppose. Instead of requiring signaling, their nodes can be set to
>> ignore chains that activate it. This will result in a fork, but if
>> different groups of users want different things, this is arguably the
>> best behaviour: a "clean" split.
> 
> If you're knowingly doing a deliberate minority chain split, you'll
> almost certainly change the PoW function, and trivially get a clean
> split as a result of doing that.
> 
> But I think what we want is to move away from consensus decisions being a
> "who has the most money/power/hashpower/nodes/reddit-accounts" contest
> to being a question of "have we dealt with every reasonable technical
> objection?" -- I think that's better for decentralisation in that anyone
> can stop a bad proposal without having to be rich/powerful/persuasive,
> and better for encouraging constructive contributions. 
> 
> The other side to this is that if it's just a matter of resolving
> technical problems, then it's also straightforward for a small but skilled
> group to get a consensus change through even if the vast majority doesn't
> think it's a priority -- they just need to make a good proposal, make
> sure it doesn't make people worse off, work through all the objections
> people find, and be willing to wait for it to go through reviews and
> upgrade steps which may take extra time if other people don't think it's
> a high priority. But those are all just technical challenges, that can
> be resolved with skill and patience, whoever you might be. So to me,
> that's a win for decentralisation as well.
> 
>> I assume many people won't like this, but I really think we should
>> consider how users should ideally resist an unwanted change, even if
>> the proponents had the best intentions in mind, there may be
>> legitimate reasons to resist it that they may not have considered.
> 
> For me, the focus there is on Matt's first point: "avoid activating
> [or merging, or even proposing] in the face of significant, reasonable,
> and directed objection". If you want to stop a change you should have to
> do nothing more than describe the problems with it; and if there aren't
> problems with it, you shouldn't be trying to stop the change.
> 
> (A benefit to having the BIP-8 settings defined simultaneously with
> the initial activation attempt is that it means that if the core
> devs/maintainers go crazy with power and try to force/prevent the BIP-8
> activation despite clear community consensus going the other way, then
> it will be easy to for the client, and set the parameter correctly --
> literally just a matter of changing a value in chainparams.cpp, unlike the
> difficulties of changing the blocksize from 1MB to 2MB. Other variations
> of this overall approach have the same benefit)
> 
> Cheers,
> aj (very grateful to Greg and Matt for explaining a lot of thing
>     about this approach and helping resolve my concerns with it)
> 
> [0] Trigger warning, PTSD over the 2015-2017 blocksize wars...
> 
>     The segwit timeline was something like this:
> 
>      2015-05 - blocksize debate begins on bitcoin-dev
>      2015-08 - bitcoin xt with bip101 hardfork released
>      2015-09 - scaling bitcoin phase 1
>      2015-12 - segwit proposal at scaling bitcoin phase 2
>      2016-01 - segwit testnet launched
>      2016-02 - bitcoin classic with bip109 hardfork released
>      2016-04 - first release (0.12.1) with a bip9 deployment (csv)
>      2016-06 - segwit merged
>      2016-07 - csv activated
>      2016-10 - first release (0.13.1) with segwit activation params
>      2016-11 - segwit activation starttime
>      2017-02 - UASF first proposed
>      2017-03 - antpool to swith to bitcoin unlimited
>      2017-04 - covert ASICBoost vs segwit conflict described
>      2017-05 - NY segwit2x agreement, btc1 with bip102 hardfork started
>      2017-05 - BIP-91 proposed
>      2017-06 - UAHF proposal from bitmain that became BCH
>      2017-07 - BIP-91 lockin
>      2017-08 - BIP-148 activation
>      2017-08 - BCH chainsplit
>      2017-08 - segwit lockin and activation
>      2017-11 - 2x fork called off; btc1 nodes stall; 2x chain stillborn
>      2018-02 - first release (0.16.0) with segwit wallet support
> 
>     (That's about 33 months in total, compared to the 24 months we've
>     already spent since taproot was first described in Jan 2018, or the
>     42 months before flag-day activation in Matt's proposal)
> 
>     I don't think that timeline is a good example of how things should
>     work, and would call out a few mistakes in particular:
> 
>      * too much urgency to increase the blocksize resulting in rushed
>        decision making, especially for the hardfork implementations, but
>        also for segwit
> 
>      * alternative clients attempted to activate forks without
>        resolving technical problems (eventually resulting in the btc1
>        client stalling prior to the expected hard fork block, eg)
> 
>      * a lot of emphasis was on numbers (market share, hashpower, etc)
>        rather than technical merits, resulting in a lot of false
>        signalling an political meaneuvering
> 
>      * the incompatibility between ASICBoost and segwit wasn't noticed
>        prior to activation, and wasn't fixed when it was noticed
>        (certainly you can justify this as a tit-for-tat response to the
>        other errors having been made in bad faith, or as not being a real
>        problem because everyone claimed that they weren't doing covert
>        ASICBoost, but considered on its own I think the incompatibility
>        should have been resolved)
> 
>      * the UASF approach had significant potential technical problems
>        (potential for long reorgs, p2p network splits) that weren't
>        resolved by the time it became active. happily, this was mitigated
>        by hashpower enforcement of BIP-148 rules via BIP-91. neither
>        BIP-148 or BIP-91 gained enough consensus to be supported in
>        bitcoin core though
> 
>     I don't personally think we need to fix every problem we had with
>     segwit's process -- it eventually mostly worked out okay, after all --
>     but I think Matt's approach has a good chance of fixing a lot of
>     them, while still leaving us flexibility to deal with whatever new
>     problems we come up with in their place.
> 

From robinlinus at protonmail.com  Wed Jan 15 01:43:06 2020
From: robinlinus at protonmail.com (Robin Linus)
Date: Wed, 15 Jan 2020 01:43:06 +0000
Subject: [bitcoin-dev] Coins: A trustless sidechain protocol
In-Reply-To: <FMYpymM9ePfMzdSqBtwf5oRl4bL6XMmDkCrwWMqBW8CK-lz4d0zjpk4oDuU7lWa16wV3Tmtnjd4LTs8Oi8-BIz_ce1rp-jK8ot9Apeo48BA=@protonmail.com>
References: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>
 <ILtIOT_2wq-ld0mk5kPev5mw8RQD6pgzSF_EPuY1PE-mdsy8eJqsCaSU-zIyNZw-4W4p5JtLJs5d451PnHvQly-3V1q225bKmdanMZVOmGE=@protonmail.com>
 <0RSAH-PjblJV6Q7TGosFHAEdc9QGauCQ_knCzMwcoGdW4Qt49ts-egDkIwM-X_f0RjsPMquwdnmB6spunH379ICEAJQgUH7R1SE8CuZs7pI=@protonmail.com>
 <6JaReZbjL3U0QrirtiCdgk107cNmQHiLbbJIDctf8uGUiqJOLvZwRLLPUQXAjzfAqRQBpaqtytcKhq1hvtSDwwaKGthwy40SWHDRnTpBkJA=@protonmail.com>
 <6pcznun9_VnOIV7D28YeCiWqSLtPnN7syJvgGVp_VIo_DAZyp2mDYZQxg6IT5dJagroU-TKgUUjLrJm12TlbhLCzwjftY6_OhIB3ej6o44E=@protonmail.com>
 <beLVDOWDR2iV7hnmLpR4bBal2QWxAYqayzw8r9CRc5afhyqZjGIQZQZEerwIIXcmRC9KFigFDFu5_CU4vxoeLFxhNrDGUaZy44_JOs3asmk=@protonmail.com>
 <FMYpymM9ePfMzdSqBtwf5oRl4bL6XMmDkCrwWMqBW8CK-lz4d0zjpk4oDuU7lWa16wV3Tmtnjd4LTs8Oi8-BIz_ce1rp-jK8ot9Apeo48BA=@protonmail.com>
Message-ID: <9ojpE1QHVyo_xJXqJFREMWLfYkJDJYIRMHNJ_WUazaWeO02KOqPU6GOaimSv0RwzACi5L4xM8K6p1x5vQOtMGchPSU3-J_EVDLUa807dGmw=@protonmail.com>

Good morning everybody!

Thanks again for your detailed feedback.

Maybe you're right and my solution is just crap :) So back to the drafting table!

It seems to be a good idea to separate problem definition and solution. Here I tried to nail down LN's usability issue:
https://github.com/coins/coins.github.io/blob/master/notes/lightning-network.md
Would be great to hear your thoughts on that. Do we generally agree that Bitcoin has to work well on mobiles? Where do your opinions differ?

If you are open to sidechains in general, we are discussing mostly consensus mechanisms.
The consensus mechanism of custodial LN services is some trusted server somewhere, with a single hot key and no public auditability.
That's state of the art LN experience on mobile. And it's worse than fiat banks.

Yes, Liquid's trusted federation is much better than such custodial services. Still, how does it scale globally? Lots of trusted federations?
Probably, we all favor a more trust-minimized sidechain consensus mechanism.

Most likely, it is impossible to produce decentralized consensus without consuming an external resource.
Furthermore, decentralized consensus requires an honest majority. Thus, fragmenting the consumption of the available resources over multiple chains weakens every chain proportionally. Therefore, whatever consensus mechanism we choose, the number of sidechains should be as small as possible. By implication, sidechains have to be as large as possible.

The market simply has no capacity to secure thousands of chains, if they don't have millions of users each.
Consensus resource consumption is a winner takes all market, until a sidechain becomes so full, that a further chain becomes profitable. Secure and profitable sidechains require strong network effects. Otherwise, there's a downwards spiral of no users which leads to no stakers and vice versa. Needless sidechains die off quickly.


Regarding proof-of-burn: In theory, you could build a pure proof-of-burn sidechain which is literally as secure as Bitcoin's consensus. If you burn about 12.5 BTC for every sidechain block, then the sidechain is exactly as costly to produce as Bitcoins blockchain. So regardless of the practicality, the theoretical security argument of PoB is very sound, or am I missing something?

If it is, then can't we build some PoS / PoB construction to secure sidechains?


Regarding 2-way peg and "a new asset for every chain is bad". Let's look at my real world bank account. There are no real dollars in it. No legal tender.
It's just my bank's derivative of the Dollar, representing their promise to give me my Dollars whenever I want.
Note that my bank's altcoin is not pegged 1:1 to the legal tender issued by the central bank. In the background they're balancing their books.
All that is hidden from me as a customer. They know, I just want to facilitate payments in USD. As a customer I do not care about their underlying financial instruments. That's why I'd assume, that sidechain assets can be used as an instrument of BTC value transfer, without a 1:1-peg to BTC.
The only thing that really matters, is liquidity for atomic swaps to pay LN invoices denominated in BTC. That again, is a matter of network effects of a sidechain.


Thanks again,
-Robin







Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Tuesday, January 14, 2020 4:26 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> As well I would like to point out that in order to receive funds, something has to be online to get the message that receives the data.
> In the blockchain layer this is diffused among all fullnodes.
>
> At the Lightning layer, your direct peer could hold off on failing an incoming payment while you are offline.
> Instead, it could simply stall until the outgoing HTLC would reach its timelock anyway.
> Then you can come online and then the peer can send the HTLC to you and you can claim it.
> This remains noncustodial as the direct peer cannot steal the funds from you.
> I believe there was some discussion regarding this on lightning-dev in the past few months.
> However, it does require that the peer know that you are the final recipient (if not, it would be unable to fail the HTLC as quickly as possible), thus a privacy leak.
>
> In any case some node has to be online in order for anyone to receive funds, whether onchain or not: it is simply that a widespread blcokchain is very very likely to have some online node capable of storing the payment until you can come online to process it.
> What you propose splits up the fullnodes into many tiny sidechains, such that a sidechain may get stalled and you would be unable to receive a payment anyway while you are offline, because there are far fewer nodes per sidechain in order for such mass sidechains to start beating the raw scaling Lightning brings.
>
> Regards,
> ZmnSCPxj
>
> > Hi Robin.
> > While your motivation seems reasonable, your solution is not. It is not enough that a problem exists. Although the solution must be technically sound for the proposal to be interesting. So I agree it makes sense to consider Bitcoin sidechains, not sure if with PoS consensus or other, but no one yet proposed a viable solution, other than Federation based sidechains. Your proposal explored a single specific PoS sidechain, which to me does not sound interesting. Maybe you can improve it, maybe not.
> > I also disagree that it is okay if anyone can halt operation of a sidechain with just tiny investment. For me that is critical security flaw of your proposal. By enforcing stakers having to stake per chain you have actually lowered the cost for the attacker to attack each specific chain.
> > Sent with ProtonMail Secure Email.
> > ??????? Original Message ???????
> > On Monday, January 13, 2020 10:22 PM, Robin Linus robinlinus at protonmail.com wrote:
> >
> > > Hi Joachim,
> > >
> > > > > Regarding Reason #1:
> > > > > This proposal is less like Bitcoin vs. Altcoins and much more like Ethereum vs. ERC20 tokens, because the derivatives are not in competition with BTC, but depend on it heavily. You support Bitcoin's growth by supporting such a sidechain.?
> > > > > Also, they won't work as separate currencies. For endusers you can abstract away all underlying complexities such that they have to think only in BTC. Exchanges rates can be hidden in TX fees. The sidechain derivatives would be nothing but a means of transfer. The unit of account is still BTC.
> > > >
> > > > I can't see any difference and advantage over doing the same with say Litecoin. All you need is to create a special wallet which offers atomic swaps LTC-BTC and its unit of account displayed to user is going to be BTC. All you say will work perfectly with this special LTC wallet. Therefore your idea is as good as any other altcoin. In your case, someone else should indeed be able to create such a wallet in which the unit of account will be the new token, thus emulating the current LTC wallets. So the only difference in Litecoin is that the special wallet with BTC as unit is going to be created after the native one, while in your case it is vice versa.
> > > > I simply can't see why I'd call this construction of yours a Bitcoin sidechain and any other altcoin not. So I'd call both altcoins.
> > >
> > > Let me try to explain where I am coming from: Whenever I want to onboard a not-so-techy friend to Bitcoin by sending him $5 worth of BTC, I don't have many good options. Usually we end up using BlueWallet. It works great. Though it only works so well because it is fully custodial. That is how they solve all the tough LN problems like inbound-capacity of new users, watchtowers and channel backends. Their service is just an Excel table connect to the LN. Unfortunately, that is the best UX we can currently offer to endusers. To me that's unsatisfying. Is that how we want to enter the emerging markets and on-board the next Billion users? I like that BlueWallet gives me the option to run my own LndHub for my friends. Still, does that scale globally? More importantly, do we want that?
> > > Now let's think about the altcoins argument. We want to serve a billion users. Blockchains do scale well to about a couple Million UTXOs, so we require a network of a couple thousand altcoins to serve our users.
> > > We know how to build a nice LN for all of our altcoins with a star-shaped topology around Bitcoin as the central settlement layer. Atomic swaps FTW. We can abstract away their native currencies. We display to our users only BTC, hide the exchange rates in the TX fees and we're done. That is actually a scalability solution. So why don't we do that?
> > > The problem here is, that In the long term, the market of PoW blockchains should be a winner-takes-all market, right? So all PoW chains but Bitcoin will eventually die because they're wasting lots of value on their energy. So actually we don't want a couple thousand altcoins wasting resources on pointlessly weak PoW chains. We want a single PoW chain which is as strong as possible.
> > > That's why I'd argue it makes sense to consider a bitcoin-backed PoS and build a LN of thousands of nameless altcoins.
> > > Regarding sidechain security: Burning BTC is almost equivalent to burning energy. You might argue that people won't burn BTC, but it is hard to argue against the strong theoretical security properties of proof-of-burn.
> > > Furthermore, even without burning BTC, using only proof-of-stake I can guarantee doublespending is impossible. There is a very low incentive to risk your BTC's time value. You can only halt a sidechain. And you can halt the sidechain only for as long as you maintain the staking majority. Once you start an attack, you increase the incentive for others to increase their stake. Staking happens in bitcoin's blockchain, which you can't halt. Once the rational stakers regain 51% you've lost a year of time value of your BTC. Note that you can easily enforce stakers having to stake per chain. This guarantees attackers can use their BTC only to attack one chain per year.?
> > > Thus, the security of such a bitcoin-based PoS is stronger then one might suspect.
> > > Thanks again,
> > >
> > > -   Robin
> > >
> > > > > Regarding Reason #2:
> > > > > In the "Limitations" section I discuss the cost of halting the chain:
> > > > > Time value of locked bitcoins might be too cheap to protect the chain. We can introduce an additional cost and let validators burn bitcoins for every on-chain vote. This is much more robust because there is an ongoing cost for halting the system. Proof-of-burn has recently been formally analysed [16]. The economic implications of burning significant amounts of Bitcoin are questionable. A level of security comparable to Bitcoin requires the system?s BTC burn rate to be equal to Bitcoin?s infaltion rate.
> > > > > Also remember, time value of Bitcoins is indeed a value. Even without a proof of burn, I'd consider such sidechains much more secure than those custodial lightning wallets which become more and more popular to circumvent the usability hurdles of the LN.
> > > >
> > > > Comparison to other models is not relevant to my claim that such construction is insecure for small sidechains. And for big sidechains the reason #1 prefers any other altcoin. Even if you introduce proof of burn, the final attack cost is small for an attacker in absolute numbers, despite the fact that in the relative numbers the cost is huge.
> > > >
> > > > > Thanks again,
> > > > >
> > > > > -   Robin
> > > > >
> > > > > Sent with ProtonMail Secure Email.
> > > > > ??????? Original Message ???????
> > > > > On Monday, January 13, 2020 7:06 PM, Joachim Str?mbergson joachimstr at protonmail.com wrote:
> > > > >
> > > > > > While I haven't rejected sidechains entirely yet, this particular proposal seems uninteresting, especially for two reasons.
> > > > > > One ? it introduces a new token for each sidechain and suggests atomic swaps to be used for the exchange of the mainchain token with the sidechain token. Such a model seems nonsensical to me because there seems to be excessive number of blockchain projects that can be used similarly just as the sidechain in this proposal. Pick almost any altcoin out there and you can atomic swap it with Bitcoin. The fact that your sidechain is somehow mathematically bound to Bitcoin seems arbitrary because at the end you have a new token and a new issuance model. Therefore this is not extending Bitcoin economy, which is strictly limited by its convergence to zero inflation. This proposal is inflating the supply with a new token, which goes against what many people consider as a pillar of Bitcoin's value proposal. I think if you implement this proposal, you are going not to be considered as a Bitcoin sidechain, but you will be, from certain point of view, indistinguishable from any other altcoin. At the level of my current understanding, the only interesting sidechain model is the [theoretical] one with a two way peg with Bitcoin, preserving the issuance policy of Bitcoin.
> > > > > > Two ? the security of the proposed system seems to be very fragile, unless I have missed something. When I think about sidechains, I expect that it should be possible to create a niche chain which is used by few participants while the security of the chain is somehow guaranteed from its bind to the mainchain. If this was not the case, such a niche sidechain could easily be attacked, even if just stalled/censored for a long period time, with just a small [absolute] investment from an attacker, although this investment might be large if taken relatively to the utility of this niche sidechain. So if we speak concretely about your proposal, you assume honest majority of validators. But in your system the validators come from locking of stake on Bitcoin chain by nodes that are interested in a particular sidechain. If you put this model on a niche chain where only few participants are interested in it, it's trivial for an attacker to be stronger [have more Bitcoin to lock] than all legitimate users together. You should only use honest majority assumption where the scope is global, where it is very hard and very expensive to obtain majority.
> > > > > > Sent with ProtonMail Secure Email.
> > > > > > ??????? Original Message ???????
> > > > > > On Sunday, January 12, 2020 6:54 PM, Robin Linus via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:
> > > > > >
> > > > > > > Hi all,
> > > > > > > I've been working on a sidechain protocol with no trusted third party. You can find thewhitepaper here.
> > > > > > > Abstract.Coins is a Bitcoin extension designed for payments at scale.?We propose an efficient solution to the double-spending problem using a bitcoin-backed proof-of-stake.? Validators vote on sidechain blocks with one-time signatures, forming a record that cannot be changed without destroying their collateral. Every user can become a validator by locking bitcoins.?One-time signatures guarantee that validators loose their?stake?for?publishing?conflicting?histories. Checkpoints?can?be?additionally secured with a bitcoin-backed proof-of-burn.?Assuming a rational majority of validators, the sidechain provides safety and liveness. The sidechain?s footprint within bitcoin?s blockchain is minimal.?The protocol is a generic consensus mechanism allowing for arbitrary sidechain assets. Spawning multiple, independent instances scales horizontally.
> > > > > > > Feedback is highly appreciated!
> > > > > > > Thank you
> > > > > > >
> > > > > > > -   Robin
> > > > > > >
> > > > > > > PS:Here on Github you can find further research on scalability and usability.



From ZmnSCPxj at protonmail.com  Wed Jan 15 05:46:04 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 15 Jan 2020 05:46:04 +0000
Subject: [bitcoin-dev] Coins: A trustless sidechain protocol
In-Reply-To: <9ojpE1QHVyo_xJXqJFREMWLfYkJDJYIRMHNJ_WUazaWeO02KOqPU6GOaimSv0RwzACi5L4xM8K6p1x5vQOtMGchPSU3-J_EVDLUa807dGmw=@protonmail.com>
References: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>
 <ILtIOT_2wq-ld0mk5kPev5mw8RQD6pgzSF_EPuY1PE-mdsy8eJqsCaSU-zIyNZw-4W4p5JtLJs5d451PnHvQly-3V1q225bKmdanMZVOmGE=@protonmail.com>
 <0RSAH-PjblJV6Q7TGosFHAEdc9QGauCQ_knCzMwcoGdW4Qt49ts-egDkIwM-X_f0RjsPMquwdnmB6spunH379ICEAJQgUH7R1SE8CuZs7pI=@protonmail.com>
 <6JaReZbjL3U0QrirtiCdgk107cNmQHiLbbJIDctf8uGUiqJOLvZwRLLPUQXAjzfAqRQBpaqtytcKhq1hvtSDwwaKGthwy40SWHDRnTpBkJA=@protonmail.com>
 <6pcznun9_VnOIV7D28YeCiWqSLtPnN7syJvgGVp_VIo_DAZyp2mDYZQxg6IT5dJagroU-TKgUUjLrJm12TlbhLCzwjftY6_OhIB3ej6o44E=@protonmail.com>
 <beLVDOWDR2iV7hnmLpR4bBal2QWxAYqayzw8r9CRc5afhyqZjGIQZQZEerwIIXcmRC9KFigFDFu5_CU4vxoeLFxhNrDGUaZy44_JOs3asmk=@protonmail.com>
 <FMYpymM9ePfMzdSqBtwf5oRl4bL6XMmDkCrwWMqBW8CK-lz4d0zjpk4oDuU7lWa16wV3Tmtnjd4LTs8Oi8-BIz_ce1rp-jK8ot9Apeo48BA=@protonmail.com>
 <9ojpE1QHVyo_xJXqJFREMWLfYkJDJYIRMHNJ_WUazaWeO02KOqPU6GOaimSv0RwzACi5L4xM8K6p1x5vQOtMGchPSU3-J_EVDLUa807dGmw=@protonmail.com>
Message-ID: <tAwpxfAGBzayt7ftFikSTt5eIvEdzxJ29sDrMvuLQ5RSxnIn8JuND6TSYBymM5UybwG1ieS9y3dAJntz-KsZjzfs1x49CVD4CoZS7QaLkZU=@protonmail.com>

Good morning Robin,


> Good morning everybody!
>
> Thanks again for your detailed feedback.
>
> Maybe you're right and my solution is just crap :) So back to the drafting table!
>
> It seems to be a good idea to separate problem definition and solution. Here I tried to nail down LN's usability issue:
> https://github.com/coins/coins.github.io/blob/master/notes/lightning-network.md
> Would be great to hear your thoughts on that. Do we generally agree that Bitcoin has to work well on mobiles? Where do your opinions differ?
>
> If you are open to sidechains in general, we are discussing mostly consensus mechanisms.
> The consensus mechanism of custodial LN services is some trusted server somewhere, with a single hot key and no public auditability.
> That's state of the art LN experience on mobile. And it's worse than fiat banks.
>
> Yes, Liquid's trusted federation is much better than such custodial services. Still, how does it scale globally? Lots of trusted federations?
> Probably, we all favor a more trust-minimized sidechain consensus mechanism.
>
> Most likely, it is impossible to produce decentralized consensus without consuming an external resource.
> Furthermore, decentralized consensus requires an honest majority. Thus, fragmenting the consumption of the available resources over multiple chains weakens every chain proportionally. Therefore, whatever consensus mechanism we choose, the number of sidechains should be as small as possible. By implication, sidechains have to be as large as possible.
>
> The market simply has no capacity to secure thousands of chains, if they don't have millions of users each.
> Consensus resource consumption is a winner takes all market, until a sidechain becomes so full, that a further chain becomes profitable. Secure and profitable sidechains require strong network effects. Otherwise, there's a downwards spiral of no users which leads to no stakers and vice versa. Needless sidechains die off quickly.

Again, please refer to the previous Fermi estimate: blockchains have bad scaling precisely because every fullnode must know every transaction.
With blockchains, anything that is not a fullnode is trusting something, and the issue of custodiality is always and has always been an issue of trust.

>
> Regarding proof-of-burn: In theory, you could build a pure proof-of-burn sidechain which is literally as secure as Bitcoin's consensus. If you burn about 12.5 BTC for every sidechain block, then the sidechain is exactly as costly to produce as Bitcoins blockchain. So regardless of the practicality, the theoretical security argument of PoB is very sound, or am I missing something?

Locking coins is equivalent to burning them, as you are "burning" the opportunity to use those coins elsewhere, e.g. in a JoinMarket maker or Lightning forwarding node.
Proof of locked coins is therefore indistinguishable from proof-of-burn in this sense, and your original proposal is proof-of-locked-coins.

Burning coins is effectively a donation to all HODLers, while locking coins is effectively a donation to all JoinMarket makers and Lightning forwarding nodes (i.e. HODLers too).

Something I have been playing with mentally would be a unidirectional peg in a sidechain.
Burn funds in the mainchain and build a block with equivalent amount in the coinbase of a sidechain.
But I stopped working on sidechains due to the aforementioned lack of scaling they produce: sidechains are for features, and federated sidechains are fine for new features.

>
> If it is, then can't we build some PoS / PoB construction to secure sidechains?
>
> Regarding 2-way peg and "a new asset for every chain is bad". Let's look at my real world bank account. There are no real dollars in it. No legal tender.
> It's just my bank's derivative of the Dollar, representing their promise to give me my Dollars whenever I want.
> Note that my bank's altcoin is not pegged 1:1 to the legal tender issued by the central bank. In the background they're balancing their books.

....


The "balancing their books" **is** the peg.

Consider that for example that a sidechain may have 21 million bitcoins instantiated in it, but locked.
In order to unlock *part* of that supply, you have to provably lock funds in the mainchain.
This "moves" coins from mainchain to  sidechain, but in reality there are still 21 million maincoins and 21 million separate sidecoins.
What matters is that there are only 21 million ***user-controllable*** coins in total, some in the mainchain and some in the sidechain.
That is enough for this to be a peg.

Thus, everything the bank does to "balance their books" is in fact a peg to the central-bank issued currency.

> All that is hidden from me as a customer. They know, I just want to facilitate payments in USD. As a customer I do not care about their underlying financial instruments. That's why I'd assume, that sidechain assets can be used as an instrument of BTC value transfer, without a 1:1-peg to BTC.
> The only thing that really matters, is liquidity for atomic swaps to pay LN invoices denominated in BTC. That again, is a matter of network effects of a sidechain.

Why would accept a sidecoin with degraded security and accepted by fewer people if it is not pegged to BTC?

That immediately kills any network effects you are targeting.

--

In any case, a project I have been playing with (which I am not pursuing in seriousness and which I will not seriously support, because LN > sidechains) is to combine the mainchain-staking with https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-January/016611.html

Basically, on the mainchain, the sidechain is represented by single UTXO that contains all the funds in the sidechain.
That UTXO would then have the same SCRIPT as described in the above linked post.

Mainchain coin owners that want to be included in the staker set can put their staked amount into a UTXO.
The sidechain stakers then confirm the addition of this staker to the staker set by spending the sidechain single UTXO and the entering staker, putting the funds into a new sidechain single UTXO that now includes the entering staker in the signing set.
Sidechain stakers can also redeem their stake back by requesting the staker set, so that the sidechain single UTXO is consumed and spent into a new sidechain single UTXO that removes the leaving staker in the signing set, plus a second UTXO containing the money that the leaving sidechain staker is reclaiming from stake.

Withdraws and deposits into the sidechain use a similar mechanism, except the depositor does not get its pubkey added to the signer set, but its funds are instantiated into the sidechain (the stakers do not have their funds instantiated into the sidechain: the mainchain staked funds and the sidechain "live" funds are thus separated, even though on the mainchain they are combined within the sidechain single UTXO).

Like all federated sidechains this assumes a federation can be formed that can be trusted to not just spend the entire sidechain single UTXO on other funds.
In particular, if the federation is taken over, it can deny the entry of new stakers that would want to evict them.
Thus the security is significantly lower.

(proof-of-work allows existing miners to be evicted, at cost, by deploying more hashpower than the existing miners have: this is central to censorship-resistance on the main blockchain layer)

The stakers that sign on the sidechain single UTXO that appears on the mainchain need not be the same set that determines consensus on the sidechain.
In terms of the Liquid blockchain, the signers on the sidechain single UTXO are the watchmen (who ensure the peg is correct), and need not be the same set as the blocksigners (who advance the sidechain state by authorizing valid blocks).


Regards,
ZmnSCPxj

From max at towardsliberty.com  Wed Jan 15 21:23:15 2020
From: max at towardsliberty.com (Max Hillebrand)
Date: Wed, 15 Jan 2020 22:23:15 +0100
Subject: [bitcoin-dev] ***UNCHECKED*** Wormhole: Sending and receiving
	bitcoin anonymously
Message-ID: <96dc101e-30ba-9833-7ba0-41eda910d3cc@towardsliberty.com>


-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512


Hello all!

May I propose you this protocol which seemingly provides a great level
of privacy for both the sender and receiver of bitcoin. This was
initially posted to the [Wasabi Wallet
GitHub](https://github.com/zkSNACKs/Meta/issues/64), and after thorough
contemplation and minor tweaks, I would now like to request your
feedback on the conceptual design and possible implementation.

Cheers
Max


# Wormhole


## Abstract

A protocol to transfer bitcoin, without the receiver gaining knowledge
of the input of the sender, and without the sender gaining knowledge of
the output of the receiver, while simultaneously generating equal value
CoinJoin outputs with anonymity set.


## Introduction

This is achieved by minor changes to the [Zero
Link](https://github.com/nopara73/zerolink) CoinJoin protocol, utilizing
a centralized coordinator who cannot steal, and cannot spy. Schnorr
blind signatures are used to obfuscate the link between inputs and equal
value outputs throughout the ceremony. The coordinator does not gain
knowledge that Wormhole is used.


## Protocol

- - Alice A [with tor identity A1 and A2] has a 5.5 bitcoin UTXO
- - A sends 1 bitcoin to Bob B [with tor identity B1 and B2]
- - Wasabi server W coordinates the zero link CoinJoin:
??? -- Equal value denominations are 1, 2, 4, 8, 16, 32 bitcoin
??? -- Anonymity set for each denomination is 100
??? -- Wormhole protocol is opt-in for some unknown number of peers

### Input Registration

- - A generates an input proof of the 5.5 bitcoin UTXO
- - A generates one `blindedOutput` with 4 bitcoin, and one
`changeAddress` with 0.5 bitcoin
- - B generates one `blindedOutput` with 1 bitcoin & he sends this
to A
- - A1 sends all of the above to W
- - W verifies
??? -- `maxInputsPerRegistraion` not reached
??? -- `maxInputPerTx` not reached
??? -- `blindedOutput` never registered
??? -- each input
??????? --- not already registered for this round
??????? --- UTXO not banned
??????? --- proof
??????? --- unspent
??????? --- if coinbase, confirmations > 100
??????? --- must be SegWit v0 [maybe also v1] bech32
??????? --- is from unconfirmed CoinJoin tx
- - W generates `uniqueID`
- - W signs all `blindedOutput`
- - W sends `uniqueID` & `signedBlindedOutput` to A1

### Connection Confirmation

- - Starts when `timeSinceLastRound > maxWaitPeriod` OR
`registeredInputs > requiredInputs`
- - A abandons if confirmation is refused
- - A1 sends `uniqueID` W
- - W verifies `uniqueID`, and calculates `roundHash = hash of all
registered inputs`
- - W sends `roundHash` to A1 and B1

### Output Registration

- - Starts when `confirmedUniquelds == registeredInputs` OR `timeout &&
confirmedUniquelds >= requiredInputs`
- - A sends `signedBlindedOuput_B` to B
- - Both A and B unblind the `signedBlindedOutput`
- - Both A2 and B2 send `output` & `signature` & `roundHash`
**DIRECTLY** to W - they do **NOT** send to each other
- - W verifies `roundHash` & `signature` & `Output`

### Signing

- - Starts when `outputs == registeredInputs` OR `timeout` [go signing,
even if there are missing outputs to identify them and ban them as they
won't sign]
- - W builds CoinJoin transaction `CJTX` and sends to A1 and B1
and all other peers
- - A and B verify `roundHash` [by calculating hash of all `txInputs`]
- - B verifies that his output is included & signs a commitment
message m where he acknowledges that it is included & sends m to A
- - A verifies that her input and her outputs are included & verifies
B signature of m [assumption that Bob provides a correct address, as
with any transaction] & signs `CJTX`
- - A1 sends `uniqueID` & `signature, inputIndex` to W - A does
**NOT** send this to B
- - W verifies `uniqueID` & each signature against
`inputs[uniqueID][index]`

### Broadcast TX

- - Starts when `signatures == registeredInputs`
- - W broadcasts signed transaction to the Bitcoin peer-to-peer network


## Result

- - A has one 4 bitcoin UTXO with 100 anonset & one 0.5 bitcoin
UTXO with 1 anonset
- - B has one 1 bitcoin UTXO with 100 anonset
- - W knows the input and change of A & W does not know who
controls which equal value output & W does not know that B has no inputs
- - A does not know the output of B, there are 99 possible coins.
- - B does not know the input and outputs of A, there are 100+
possible coins.


## Communication

This is an interactive protocol with several rounds of communication,
thus all A & B & W need to be online. The communication between
A and B can be done on any suitably private channel, including but
not limited to tor, QR codes, SD cards, or carrier pigeon. The
communication between A / B & W will be the same as used for the
regular zero link implementation, most likely tor.


## Privacy

The equal value zero link outputs from A and B have the anonymity
set of the total number of equal value zero link outputs in the same
transaction. Wormhole breaks the assumption that zero link is a
consolidation within the same wallet [`Input Alice = Output Alice +
Fee`], in a way that neither A nor B can spy on each other. W does
not know if any peer is using Wormhole, none or one or all peers
**might** use it.


## Questions

I am not sure what information is broadcasted from W to all peers in
the round, and if Bob can get this information without revealing that he
is the receiver of a Wormhole transaction [he has no input proof]. What
information can be send from W to B directly will determine the
trust level of A passing honest messages.

Wormhole might be used in conjunction with [Pay to
Endpoint](https://medium.com/@nopara73/pay-to-endpoint-56eb05d3cac6) or
[Knapsack](https://www.comsys.rwth-aachen.de/fileadmin/papers/2017/2017-maurer-trustcom-coinjoin.pdf)
so that A can send a specific amount to B, with part being the equal
value zero link output, and part the P2EP change, or Knapsack
sub-transaction.

[Atomic coin
swaps](https://github.com/ElementsProject/scriptless-scripts/blob/master/md/atomic-swap.md)
with Schnorr adaptor signatures might be integrated, so A input in
`CJTX1` "pays" B output in `CJTX2`, but this might require B to know
the signature [and thus the input] of A.

- -- 
This email was signed with my PGP key [E900 5F66 A86B B816 BD7D 967E
BEDC D95C 42AC
3C57](https://towardsliberty.com/contact/PGP_MaxHillebrand.txt)
Please verify it on my [website](https://towardsliberty.com/contact),
[github](https://github.com/maxhillebrand/contact) and on the bottom
right corner of my [videos](https://towardsliberty.com/videos).
-----BEGIN PGP SIGNATURE-----

iQIzBAEBCgAdFiEESKcexyWeb+u7zuh5+CjfVEmKd88FAl4fgr4ACgkQ+CjfVEmK
d8/56xAAnRcr8CN945OGzHQOZE4aaSKDipPBIPhuRs4RNWSzlP+16gUuDOksR31b
P8lXgleycr/SHipL2CwrBdl4FPNX82CKw9p5rO/PBkkZ4g3TNAyMJD6ec2S0oBRc
hsASMPWJ7oXoRFf9yXKUnFyjMPg75U12pw3GmNOu9EM8FB50zjCO61BB2VRbFHTh
VZ5KVWHclOMyWpQsz+/awi9kzpP2t0/dMV1vx6fq3DhlzXQOKEGXQ+yh4eZ+0L+Y
9DwjBVH1q0QufQHwZynWv+TjSftdwJqdiCeKpO1UQo+IgaBE6CkHSlwOK/09mPHK
hcSaSpa75KbNIdZUP+6bZG1aLT4AWMAdxbeR/Z4E50bqnHsvETcJeN+L6vopcLZN
3Pyc7jWD82+jBqXrLez7IiIyHRxrqrcyrLYAJoNavvtyGKRnT/jodxsX0QDyhm/3
PfHwADKrrnYtcnSL2rpSNNAEQF8SOXRPUm+Kr7rrwnfegiRjtIz1uD5lysPj++OJ
O9yxQsnhNt6/lAkUTXnQPPIooqEXXazDb0hrJMguXfnPVRsKGpzajHg7e33d5OZx
vLSpKZx9TGOPbsbC6vR+NXz6n0U3Kba26Qc4dSYUi3sdLokcTR0wvDxHxTouYswr
KPOaqR11SZ3wsL9NTXbU91SyVQBvdZP95uvlpoN3n9kopzSO5eA=
=HG53
-----END PGP SIGNATURE-----


From gubatron at gmail.com  Thu Jan 16 01:21:52 2020
From: gubatron at gmail.com (Angel Leon)
Date: Wed, 15 Jan 2020 18:21:52 -0700
Subject: [bitcoin-dev] Coins: A trustless sidechain protocol
In-Reply-To: <P-QnOpNsFdehy_F3FJgAr0lSJ2xtmT5cwRsEC8VfnIUrSgfNDkLNizm2L1TG65AhKM430tzJ9p33WBnSmJ92ZTKEoaKXCTQzVKrZkH9vtn4=@protonmail.com>
References: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>
 <Qa9HJ5p2bYnXsjvgcTz-J_stEwJ80SU9UTZF5abv96i5eM_6y3pmy9Bu4tEnFXOc_lBs-y2BFoMh4xOGjl2US56hAFPvxDZM2eyhJkEdBLM=@protonmail.com>
 <2mw_wd_ocLESpSG9ST3yJBsJriHf1l5LsdQ2jLamTUUKTMmwUpcjEeohClnMHJl4qjXNW9mHQJiK65jmDHfLG3-nVSRse9PdXnXokGZ2_ac=@protonmail.com>
 <P-QnOpNsFdehy_F3FJgAr0lSJ2xtmT5cwRsEC8VfnIUrSgfNDkLNizm2L1TG65AhKM430tzJ9p33WBnSmJ92ZTKEoaKXCTQzVKrZkH9vtn4=@protonmail.com>
Message-ID: <CADZB0_ZcJawjSBBE9nHLcFrHoZofDt-8pw4Xx980zp8OCjN6CA@mail.gmail.com>

> Instead of using sidechains, just use channel factories.
> You do not need to broadcast the entire internal ledgers of those
services, only their customers need to know those internal ledgers, and
sign off on the updates of those ledgers.

That's right, all you need to broadcast is a small proof, a non-interactive
blockchain suffix proof
https://eprint.iacr.org/2017/963.pdf



On Sun, Jan 12, 2020 at 7:33 PM ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Good morning Robin,
>
>
> > Good morning ZmnSCPxj,
> >
> > Thank you for your detailed feedback! Two topics:
> >
> > Lightning vs Sidechains
> >
> > ------------------------
> >
> > Why an either-or-solution, if we can connect sidechains via the LN to
> get the best of both worlds?
> >
> > The LN works exceptionally great under the following conditions:
> >
> > -   you're always online
> > -   you have BTC to manage your channels' inbound-capacity
> > -   you can afford BTC transactions
> >     -   in your channel is much more than the minimum on-chain TX fees
> >
> >         The next Billion users do not fit that category. They are on
> unreliable cell phone connections and do not have any BTC yet.
> >         And the more popular Bitcoin becomes, the fewer people can
> afford LN channels. Even Eltoo requires your funds to be significantly
> higher than Bitcoin's TX fees, right?
> >
> >         Already today, more and more services like tippin.me,
> BlueWallet, etc, provide custodial solutions.
> >         For small amounts, custody is an acceptable workaround. And I
> love their usability. Install it and immediately I can send you $0.01. Yet,
> scaling their approach globally does not lead to desirable outcomes, since
> we'd be back to trusting banks with their Excel sheets.
> >
> >         So let's make their internal ledgers public and trustless, via
> independent sidechains. Decentralized Blockchains do scale decently up to a
> couple Million UTXOs. So a couple thousand Sidechains is probably
> sufficient for a global medium of exchange. Cross-chain communication
> without requiring cross-chain validation is possible via atomic swaps and
> through Bitcoin's LN. That scales because it separates chain-validators
> from swap-validators.
> >         Bitcoin's LN acts as the central settlement layer for efficient
> cross-chain transactions between all sidechains.
> >
> >         So Endusers "living" in sidechains instead of directly in the LN
> has many advantages:
> >
> > -   no bitcoin blockspace required for on-boarding new users
> > -   no need to lock funds to provide inbound-capacity
> > -   no need to stay online or pay watch towers
> > -   no need to store channel histories
> > -   account balances can be much smaller than BTC TX fees
> >
> >     Those are the exact same reasons why BlueWallet built their LndHub.
> But sidechains can be trustless. Also a generic protocol provides
> flexibility for sidechain innovations with arbitrary digital assets and
> consensus rules.
>
>
> Which is why I brought up multiparticipant offchain updateable
> cryptocurrency systems.
> The "channel factories" concepts does what you are looking for, except
> with better trust-minimization than sidechains can achieve.
> Just replace "sidechain" with either Decker-Wattenhofer or
> Decker-Russell-Osuntokun constructions.
> You can even use the Somsen "statechain" mechanism, which rides a
> Decker-Wattenhofer/Decker-Russell-Osuntokun construction, though its
> trust-minimization is only very very slightly better than federated
> sidechains.
>
> It is helpful to remember that Poon-Dryja, Decker-Wattenhofer,
> Decker-Russell-Osuntokun, and all other future such constructions, can host
> any contract that its lower layer can support.
> So if you ride a Poon-Dryja on top of the Bitcoin blockchain, you can host
> HTLCs inside the Poon-Dryja, since the Bitcoin blockchain can host HTLCs.
> Similarly, if you ride a Decker-Wattenhofer on top of the Bitcoin
> blockchain, you can host a Poon-Dryja inside the Decker-Wattenhofer, since
> the Bitcoin blockchain can host Poon-Dryja channels.
> This central insight leads one to conclude that anything you can put
> onchain, you an generally also put offchain, so why use a chain at all
> except as an ultimate anchor to reality?
> Poon-Dryja is strictly two-participant, while Decker-Wattenhofer limits
> the practical number of updates due to its use of decrementing relative
> timelocks: so you put the payment layer in a bunch of Poon-Dryja channels
> which support tons of updates each but only two participants per channel,
> and create a layer that supports changes to the channel topology (where
> changes to the channel connectivity are expected to be much rarer than
> payments) and is multiparticipant so you can *actually* scale.
>
> Instead of using sidechains, just use channel factories.
> You do not need to broadcast the entire internal ledgers of those
> services, only their customers need to know those internal ledgers, and
> sign off on the updates of those ledgers.
>
> Regards,
> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200115/48d7ea4b/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Thu Jan 16 02:11:44 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 16 Jan 2020 02:11:44 +0000
Subject: [bitcoin-dev] ***UNCHECKED*** Wormhole: Sending and receiving
	bitcoin anonymously
In-Reply-To: <96dc101e-30ba-9833-7ba0-41eda910d3cc@towardsliberty.com>
References: <96dc101e-30ba-9833-7ba0-41eda910d3cc@towardsliberty.com>
Message-ID: <T410nnBIHG8Gr2T8ir9OLa9e2SPi2EagjGntUByw-u1ELuJGU7Hh5cGHoBRlYJKbaXXbchECb-a-1HXHrQlx7wGoN1YeNocpXlnkiveddkc=@protonmail.com>

Good morning Max,

It seems similar very closely to TumbleBit, at least in the overall protocol.
A cursory read does not reveal any direct problems with it.

Regards,
ZmnSCPxj

> Hello all!
>
> May I propose you this protocol which seemingly provides a great level
> of privacy for both the sender and receiver of bitcoin. This was
> initially posted to the Wasabi WalletGitHub, and after thoroughcontemplation and minor tweaks, I would now like to request your
> feedback on the conceptual design and possible implementation.
>
> Cheers
> Max
>
> Wormhole
>
> =========
>
> Abstract
>
> ---------
>
> A protocol to transfer bitcoin, without the receiver gaining knowledge
> of the input of the sender, and without the sender gaining knowledge of
> the output of the receiver, while simultaneously generating equal value
> CoinJoin outputs with anonymity set.
>
> Introduction
>
> -------------
>
> This is achieved by minor changes to theZeroLink CoinJoin protocol, utilizinga centralized coordinator who cannot steal, and cannot spy. Schnorr
> blind signatures are used to obfuscate the link between inputs and equal
> value outputs throughout the ceremony. The coordinator does not gain
> knowledge that Wormhole is used.
>
> Protocol
>
> ---------
>
> -   Alice A [with tor identity A1 and A2] has a 5.5 bitcoin UTXO
> -   A sends 1 bitcoin to Bob B [with tor identity B1 and B2]
> -   Wasabi server W coordinates the zero link CoinJoin:
>     ??? -- Equal value denominations are 1, 2, 4, 8, 16, 32 bitcoin
>     ??? -- Anonymity set for each denomination is 100
>     ??? -- Wormhole protocol is opt-in for some unknown number of peers
>
>
> ### Input Registration
>
> -   A generates an input proof of the 5.5 bitcoin UTXO
> -   A generates one `blindedOutput` with 4 bitcoin, and one
>     `changeAddress` with 0.5 bitcoin
>
> -   B generates one `blindedOutput` with 1 bitcoin & he sends this
>     to A
>
> -   A1 sends all of the above to W
> -   W verifies
>     ??? -- `maxInputsPerRegistraion` not reached
>     ??? -- `maxInputPerTx` not reached
>     ??? -- `blindedOutput` never registered
>     ??? -- each input
>     ??????? --- not already registered for this round
>     ??????? --- UTXO not banned
>     ??????? --- proof
>     ??????? --- unspent
>     ??????? --- if coinbase, confirmations > 100
>
>
> --- must be SegWit v0 [maybe also v1] bech32
> ??????? --- is from unconfirmed CoinJoin tx
>
> -   W generates `uniqueID`
> -   W signs all `blindedOutput`
> -   W sends `uniqueID` & `signedBlindedOutput` to A1
>
> ### Connection Confirmation
>
> -   Starts when `timeSinceLastRound > maxWaitPeriod` OR
>
> `registeredInputs > requiredInputs`
>
> -   A abandons if confirmation is refused
> -   A1 sends `uniqueID` W
> -   W verifies `uniqueID`, and calculates `roundHash = hash of all registered inputs`
> -   W sends `roundHash` to A1 and B1
>
> ### Output Registration
>
> -   Starts when `confirmedUniquelds == registeredInputs` OR `timeout && confirmedUniquelds >= requiredInputs`
>
> -   A sends `signedBlindedOuput_B` to B
>
> -   Both A and B unblind the `signedBlindedOutput`
>
> -   Both A2 and B2 send `output` & `signature` & `roundHash`
>     DIRECTLY to W - they do NOT send to each other
>
> -   W verifies `roundHash` & `signature` & `Output`
>
>
> ### Signing
>
> -   Starts when `outputs == registeredInputs` OR `timeout` [go signing,
>     even if there are missing outputs to identify them and ban them as they
>     won't sign]
>
> -   W builds CoinJoin transaction `CJTX` and sends to A1 and B1
>     and all other peers
>
> -   A and B verify `roundHash` [by calculating hash of all `txInputs`]
> -   B verifies that his output is included & signs a commitment
>     message m where he acknowledges that it is included & sends m to A
>
> -   A verifies that her input and her outputs are included & verifies
>     B signature of m [assumption that Bob provides a correct address, as
>     with any transaction] & signs `CJTX`
>
> -   A1 sends `uniqueID` & `signature, inputIndex` to W - A does
>     NOT send this to B
>
> -   W verifies `uniqueID` & each signature against
>     `inputs[uniqueID][index]`
>
>
> ### Broadcast TX
>
> -   Starts when `signatures == registeredInputs`
> -   W broadcasts signed transaction to the Bitcoin peer-to-peer network
>
>
> Result
>
> -------
>
> -   A has one 4 bitcoin UTXO with 100 anonset & one 0.5 bitcoin
>     UTXO with 1 anonset
>
> -   B has one 1 bitcoin UTXO with 100 anonset
> -   W knows the input and change of A & W does not know who
>     controls which equal value output & W does not know that B has no inputs
>
> -   A does not know the output of B, there are 99 possible coins.
> -   B does not know the input and outputs of A, there are 100+
>     possible coins.
>
>
> Communication
>
> --------------
>
> This is an interactive protocol with several rounds of communication,
> thus all A & B & W need to be online. The communication between
> A and B can be done on any suitably private channel, including but
> not limited to tor, QR codes, SD cards, or carrier pigeon. The
> communication between A / B & W will be the same as used for the
> regular zero link implementation, most likely tor.
>
> Privacy
>
> --------
>
> The equal value zero link outputs from A and B have the anonymity
> set of the total number of equal value zero link outputs in the same
> transaction. Wormhole breaks the assumption that zero link is a
> consolidation within the same wallet [`Input Alice = Output Alice + Fee`], in a way that neither A nor B can spy on each other. W does
> not know if any peer is using Wormhole, none or one or all peers
> might use it.
>
> Questions
>
> ----------
>
> I am not sure what information is broadcasted from W to all peers in
> the round, and if Bob can get this information without revealing that he
> is the receiver of a Wormhole transaction [he has no input proof]. What
> information can be send from W to B directly will determine the
> trust level of A passing honest messages.
>
> Wormhole might be used in conjunction with Pay toEndpoint orKnapsack
> so that A can send a specific amount to B, with part being the equal
> value zero link output, and part the P2EP change, or Knapsack
> sub-transaction.
>
> Atomic coinswapswith Schnorr adaptor signatures might be integrated, so A input in
> `CJTX1` "pays" B output in `CJTX2`, but this might require B to know
> the signature [and thus the input] of A.
>
> --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
>
> This email was signed with my PGP key E900 5F66 A86B B816 BD7D 967EBEDC D95C 42AC3C57Please verify it on my website,
> github and on the bottom
> right corner of my videos.



From aj at erisian.com.au  Thu Jan 16 03:46:17 2020
From: aj at erisian.com.au (Anthony Towns)
Date: Thu, 16 Jan 2020 13:46:17 +1000
Subject: [bitcoin-dev] Modern Soft Fork Activation
In-Reply-To: <a7fc5d7f-9b11-ed8e-0513-fd863881290e@mattcorallo.com>
References: <20200111144207.5xzspeptstspsbsf@erisian.com.au>
 <a7fc5d7f-9b11-ed8e-0513-fd863881290e@mattcorallo.com>
Message-ID: <20200116034617.zgkvtub55phdtxap@erisian.com.au>

On Tue, Jan 14, 2020 at 07:42:07PM +0000, Matt Corallo wrote:
> Thus, part of the goal here is that we ensure we have that "out", and
> can observe the response of the ecosystem once the change is "staring
> them in the face", as it were.

> A BIP 9 process is here not only to offer
> a compelling activation path, but *also* to allow for observation and
> discussion time for any lingering minor objections prior to a BIP 8/flag
> day activation.

One thing that I wonder is if your proposal (and BIP9) has enough of
time for this sort of observation?

If something looks good to devs and miners, but still has some
underlying problem, it seems like it would be pretty easy to for it
to activate quickly just because miners happen to upgrade quickly and
don't see a need to tweak the default signalling parameters. I think
the BIP 68/112/113 bundle starttime was met at block 409643 (May 1,
2016), so it entered STARTED at 411264 (May 11), was LOCKED_IN at 417312
(June 21), and active at 481824 (July 5). If we're worried people will
only seriously look at things once activation is possible, having just
a month or two to find new problems isn't very long.

One approach to improve that might be to have the first point release that
includes the soft-fork activation parameters _not_ update getblocktemplate
to signal the version bit by default, but only do that in a second point
release later. That way miners could manually enable signalling if there's
some reason to rush things (which still means there's pressure to actually
look at the changes), but by default there's a bit of extra time.

(This might just be a reason why people should look at proposals before
they're ready to activate, though; or why users of bitcoin should also
be miners)

> On the other hand, in practice, we've seen that version bits are set on
> the pool side, and not on the node side, meaning the goal of ensuring
> miners have upgraded isn't really accomplished in practice, you just end
> up forking the chain for no gain.

ITYM version bits are set via mining software rather than the node
software the constructs blocks (when validation happens), so that
there's no strong link between signalling and having actually updated
your software to properly enforce the new rules? I think people have
suggested in the past moving signalling into the coinbase or similar
rather than the version field of the header to make that link a bit
tighter. Maybe this is worth doing at the same time? (For pools that
want to let their users choose whether to signal or not, that'd mean
offering two different templates for them to mine, I guess) That would
mean miners using the version field as extra nonce space wouldn't be
confused with upgrade signalling at least...

(I don't have an opinion on whether either of these is worth worrying
about)

Cheers,
aj


From msafi at msafi.com  Thu Jan 16 18:30:24 2020
From: msafi at msafi.com (M.K. Safi)
Date: Thu, 16 Jan 2020 10:30:24 -0800
Subject: [bitcoin-dev] I want to rebuild the GUI in JavaScript
In-Reply-To: <338F9187-AE9C-4771-8298-AC4AF11D1F8B@jonasschnelli.ch>
References: <CABCTTz6A_ahH_3VZ1stBP4uoqTTcwQCQ_X1Xywdi33etssCioA@mail.gmail.com>
 <338F9187-AE9C-4771-8298-AC4AF11D1F8B@jonasschnelli.ch>
Message-ID: <CABCTTz5mGMdfeoVV2ADMg7aVT4zb=NsfgnP7F4KxG6h_dSvrjg@mail.gmail.com>

Thank you for the feedback Jonas. It was helpful.

I'll take this topic off list since this is probably not the right place
for it, but just for those who emailed me asking about how to follow the
progress, I've been working on a proof-of-concept over the last month and
published it here: https://github.com/orange-org/orange

I would appreciate contributions toward growing this. Check out the bottom
of the README for ways to get involved. Thanks!

On Sat, Nov 23, 2019 at 10:36 AM Jonas Schnelli via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi
>
> This is probably the wrong place to discuss that (OT).
>
> > I?d like to try to rebuild Bitcoin Core GUI using the JavaScript
> Electron framework. My goal is to get a real world understanding of the
> pros and cons of moving from Qt to Electron.
>
> There is a relatively new Bitcoin Core Github issue that covers that topic
> [1].
> AFAIK many Bitcoin Core contributors (and users?) don?t like the idea of
> having a Browser and JavaScript to achieve a UI with relatively simple
> user-stories.
>
> I think if you want to do this, try to work on a third party project and
> let your Electron UI connect to Bitcoin Core over RPC.
> To avoid pulling, eventually use ZMQ or help getting long polling into
> Bitcoin Core [2].
>
> Adding a Electron/JavaScript UI to the Bitcoin Core repository is very
> unlikely to happen.
>
> [1] https://github.com/bitcoin/bitcoin/issues/17395
> [2] https://github.com/bitcoin/bitcoin/pull/7949
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200116/e1893bcc/attachment.html>

From robinlinus at protonmail.com  Fri Jan 17 04:17:56 2020
From: robinlinus at protonmail.com (Robin Linus)
Date: Fri, 17 Jan 2020 04:17:56 +0000
Subject: [bitcoin-dev] Coins: A trustless sidechain protocol
In-Reply-To: <beLVDOWDR2iV7hnmLpR4bBal2QWxAYqayzw8r9CRc5afhyqZjGIQZQZEerwIIXcmRC9KFigFDFu5_CU4vxoeLFxhNrDGUaZy44_JOs3asmk=@protonmail.com>
References: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>
 <ILtIOT_2wq-ld0mk5kPev5mw8RQD6pgzSF_EPuY1PE-mdsy8eJqsCaSU-zIyNZw-4W4p5JtLJs5d451PnHvQly-3V1q225bKmdanMZVOmGE=@protonmail.com>
 <0RSAH-PjblJV6Q7TGosFHAEdc9QGauCQ_knCzMwcoGdW4Qt49ts-egDkIwM-X_f0RjsPMquwdnmB6spunH379ICEAJQgUH7R1SE8CuZs7pI=@protonmail.com>
 <6JaReZbjL3U0QrirtiCdgk107cNmQHiLbbJIDctf8uGUiqJOLvZwRLLPUQXAjzfAqRQBpaqtytcKhq1hvtSDwwaKGthwy40SWHDRnTpBkJA=@protonmail.com>
 <6pcznun9_VnOIV7D28YeCiWqSLtPnN7syJvgGVp_VIo_DAZyp2mDYZQxg6IT5dJagroU-TKgUUjLrJm12TlbhLCzwjftY6_OhIB3ej6o44E=@protonmail.com>
 <beLVDOWDR2iV7hnmLpR4bBal2QWxAYqayzw8r9CRc5afhyqZjGIQZQZEerwIIXcmRC9KFigFDFu5_CU4vxoeLFxhNrDGUaZy44_JOs3asmk=@protonmail.com>
Message-ID: <utxb-_hCi1ABBK86Z5qAkOH0q6RiyiAg1UXzCxgy1usYS2iVZjwIdXjEfnXXenqkMVtJ8omdyUw9kf9BTQXghTnWSvOoTqO7m3SMUPZURR0=@protonmail.com>

Hi Joachim,

> if anyone can halt operation of a sidechain with just tiny investment.

It'll be impossible to halt a healthy chain with a tiny investment because halting a chain costs you at least as much as the side chain rewards. The "invested time value per block" of all honest stakers converges against the block reward. If imbalanced, someone will stake more bitcoin to get the cheap sidechain rewards. Exactly the same market mechanism secures PoW.

For a decentralized consensus via resource consumption it doesn't matter which limited resource you consume. The only relevant factor is that the value of the block reward is sufficient to motivate people to invest a lot of that resource. To motivate them to invest so much that an attacker cannot invest more. Independently of the resource, the amount of honestly invested resources converges against the value of the block reward.

Thus, I would even go further with my claim and argue that the security of bitcoin-backed PoS is exactly as strong as PoW because in both cases their security is proportionally to the dollar value of their block reward. PoS sidechain security depends only on a sufficient userbase and thus, block reward value.

Thanks again for your detailed feedback,
-Robin

> For me that is critical security flaw of your proposal. By enforcing stakers having to stake per chain you have actually lowered the cost for the attacker to attack each specific chain.
>
> Sent with [ProtonMail](https://protonmail.com) Secure Email.
>
> ??????? Original Message ???????
> On Monday, January 13, 2020 10:22 PM, Robin Linus <robinlinus at protonmail.com> wrote:
>
>> Hi Joachim,
>>
>>>> Regarding Reason #1:
>>>> This proposal is less like Bitcoin vs. Altcoins and much more like Ethereum vs. ERC20 tokens, because the derivatives are not in competition with BTC, but depend on it heavily. You support Bitcoin's growth by supporting such a sidechain.
>>>> Also, they won't work as separate currencies. For endusers you can abstract away all underlying complexities such that they have to think only in BTC. Exchanges rates can be hidden in TX fees. The sidechain derivatives would be nothing but a means of transfer. The unit of account is still BTC.
>>>
>>> I can't see any difference and advantage over doing the same with say Litecoin. All you need is to create a special wallet which offers atomic swaps LTC-BTC and its unit of account displayed to user is going to be BTC. All you say will work perfectly with this special LTC wallet. Therefore your idea is as good as any other altcoin. In your case, someone else should indeed be able to create such a wallet in which the unit of account will be the new token, thus emulating the current LTC wallets. So the only difference in Litecoin is that the special wallet with BTC as unit is going to be created after the native one, while in your case it is vice versa.
>>>
>>> I simply can't see why I'd call this construction of yours a Bitcoin sidechain and any other altcoin not. So I'd call both altcoins.
>>
>> Let me try to explain where I am coming from: Whenever I want to onboard a not-so-techy friend to Bitcoin by sending him $5 worth of BTC, I don't have many good options. Usually we end up using BlueWallet. It works great. Though it only works so well because it is fully custodial. That is how they solve all the tough LN problems like inbound-capacity of new users, watchtowers and channel backends. Their service is just an Excel table connect to the LN. Unfortunately, that is the best UX we can currently offer to endusers. To me that's unsatisfying. Is that how we want to enter the emerging markets and on-board the next Billion users? I like that BlueWallet gives me the option to run my own LndHub for my friends. Still, does that scale globally? More importantly, do we want that?
>>
>> Now let's think about the altcoins argument. We want to serve a billion users. Blockchains do scale well to about a couple Million UTXOs, so we require a network of a couple thousand altcoins to serve our users.
>> We know how to build a nice LN for all of our altcoins with a star-shaped topology around Bitcoin as the central settlement layer. Atomic swaps FTW. We can abstract away their native currencies. We display to our users only BTC, hide the exchange rates in the TX fees and we're done. That is actually a scalability solution. So why don't we do that?
>> The problem here is, that In the long term, the market of PoW blockchains should be a winner-takes-all market, right? So all PoW chains but Bitcoin will eventually die because they're wasting lots of value on their energy. So actually we don't want a couple thousand altcoins wasting resources on pointlessly weak PoW chains. We want a single PoW chain which is as strong as possible.
>>
>> That's why I'd argue it makes sense to consider a bitcoin-backed PoS and build a LN of thousands of nameless altcoins.
>>
>> Regarding sidechain security: Burning BTC is almost equivalent to burning energy. You might argue that people won't burn BTC, but it is hard to argue against the strong theoretical security properties of proof-of-burn.
>>
>> Furthermore, even without burning BTC, using only proof-of-stake I can guarantee doublespending is impossible. There is a very low incentive to risk your BTC's time value. You can only halt a sidechain. And you can halt the sidechain only for as long as you maintain the staking majority. Once you start an attack, you increase the incentive for others to increase their stake. Staking happens in bitcoin's blockchain, which you can't halt. Once the rational stakers regain 51% you've lost a year of time value of your BTC. Note that you can easily enforce stakers having to stake per chain. This guarantees attackers can use their BTC only to attack one chain per year.
>> Thus, the security of such a bitcoin-based PoS is stronger then one might suspect.
>>
>> Thanks again,
>> - Robin
>>
>>>> Regarding Reason #2:
>>>> In the "Limitations" section I discuss the cost of halting the chain:
>>>>
>>>> Time value of locked bitcoins might be too cheap to protect the chain. We can introduce an additional cost and let validators burn bitcoins for every on-chain vote. This is much more robust because there is an ongoing cost for halting the system. Proof-of-burn has recently been formally analysed [16]. The economic implications of burning significant amounts of Bitcoin are questionable. A level of security comparable to Bitcoin requires the system?s BTC burn rate to be equal to Bitcoin?s infaltion rate.
>>>>
>>>> Also remember, time value of Bitcoins is indeed a value. Even without a proof of burn, I'd consider such sidechains much more secure than those custodial lightning wallets which become more and more popular to circumvent the usability hurdles of the LN.
>>>
>>> Comparison to other models is not relevant to my claim that such construction is insecure for small sidechains. And for big sidechains the reason #1 prefers any other altcoin. Even if you introduce proof of burn, the final attack cost is small for an attacker in absolute numbers, despite the fact that in the relative numbers the cost is huge.
>>>
>>>> Thanks again,
>>>> - Robin
>>>>
>>>> Sent with [ProtonMail](https://protonmail.com) Secure Email.
>>>>
>>>> ??????? Original Message ???????
>>>> On Monday, January 13, 2020 7:06 PM, Joachim Str?mbergson <joachimstr at protonmail.com> wrote:
>>>>
>>>>> While I haven't rejected sidechains entirely yet, this particular proposal seems uninteresting, especially for two reasons.
>>>>>
>>>>> One ? it introduces a new token for each sidechain and suggests atomic swaps to be used for the exchange of the mainchain token with the sidechain token. Such a model seems nonsensical to me because there seems to be excessive number of blockchain projects that can be used similarly just as the sidechain in this proposal. Pick almost any altcoin out there and you can atomic swap it with Bitcoin. The fact that your sidechain is somehow mathematically bound to Bitcoin seems arbitrary because at the end you have a new token and a new issuance model. Therefore this is not extending Bitcoin economy, which is strictly limited by its convergence to zero inflation. This proposal is inflating the supply with a new token, which goes against what many people consider as a pillar of Bitcoin's value proposal. I think if you implement this proposal, you are going not to be considered as a Bitcoin sidechain, but you will be, from certain point of view, indistinguishable from any other altcoin. At the level of my current understanding, the only interesting sidechain model is the [theoretical] one with a two way peg with Bitcoin, preserving the issuance policy of Bitcoin.
>>>>>
>>>>> Two ? the security of the proposed system seems to be very fragile, unless I have missed something. When I think about sidechains, I expect that it should be possible to create a niche chain which is used by few participants while the security of the chain is somehow guaranteed from its bind to the mainchain. If this was not the case, such a niche sidechain could easily be attacked, even if just stalled/censored for a long period time, with just a small [absolute] investment from an attacker, although this investment might be large if taken relatively to the utility of this niche sidechain. So if we speak concretely about your proposal, you assume honest majority of validators. But in your system the validators come from locking of stake on Bitcoin chain by nodes that are interested in a particular sidechain. If you put this model on a niche chain where only few participants are interested in it, it's trivial for an attacker to be stronger [have more Bitcoin to lock] than all legitimate users together. You should only use honest majority assumption where the scope is global, where it is very hard and very expensive to obtain majority.
>>>>>
>>>>> Sent with [ProtonMail](https://protonmail.com) Secure Email.
>>>>>
>>>>> ??????? Original Message ???????
>>>>> On Sunday, January 12, 2020 6:54 PM, Robin Linus via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>>
>>>>>> Hi all,
>>>>>>
>>>>>> I've been working on a sidechain protocol with no trusted third party. You can find the [whitepaper here](http://coins.github.io/coins.pdf).
>>>>>>
>>>>>> Abstract. Coins is a Bitcoin extension designed for payments at scale. We propose an efficient solution to the double-spending problem using a bitcoin-backed proof-of-stake.  Validators vote on sidechain blocks with one-time signatures, forming a record that cannot be changed without destroying their collateral. Every user can become a validator by locking bitcoins. One-time signatures guarantee that validators loose their stake for publishing conflicting histories. Checkpoints can be additionally secured with a bitcoin-backed proof-of-burn. Assuming a rational majority of validators, the sidechain provides safety and liveness. The sidechain?s footprint within bitcoin?s blockchain is minimal. The protocol is a generic consensus mechanism allowing for arbitrary sidechain assets. Spawning multiple, independent instances scales horizontally.
>>>>>>
>>>>>> Feedback is highly appreciated!
>>>>>>
>>>>>> Thank you
>>>>>>
>>>>>> - Robin
>>>>>>
>>>>>> PS: [Here on Github you can find further research on scalability and usability](https://github.com/coins/coins.github.io).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200117/bcdd4c47/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Fri Jan 17 13:54:50 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 17 Jan 2020 13:54:50 +0000
Subject: [bitcoin-dev] Coins: A trustless sidechain protocol
In-Reply-To: <utxb-_hCi1ABBK86Z5qAkOH0q6RiyiAg1UXzCxgy1usYS2iVZjwIdXjEfnXXenqkMVtJ8omdyUw9kf9BTQXghTnWSvOoTqO7m3SMUPZURR0=@protonmail.com>
References: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>
 <ILtIOT_2wq-ld0mk5kPev5mw8RQD6pgzSF_EPuY1PE-mdsy8eJqsCaSU-zIyNZw-4W4p5JtLJs5d451PnHvQly-3V1q225bKmdanMZVOmGE=@protonmail.com>
 <0RSAH-PjblJV6Q7TGosFHAEdc9QGauCQ_knCzMwcoGdW4Qt49ts-egDkIwM-X_f0RjsPMquwdnmB6spunH379ICEAJQgUH7R1SE8CuZs7pI=@protonmail.com>
 <6JaReZbjL3U0QrirtiCdgk107cNmQHiLbbJIDctf8uGUiqJOLvZwRLLPUQXAjzfAqRQBpaqtytcKhq1hvtSDwwaKGthwy40SWHDRnTpBkJA=@protonmail.com>
 <6pcznun9_VnOIV7D28YeCiWqSLtPnN7syJvgGVp_VIo_DAZyp2mDYZQxg6IT5dJagroU-TKgUUjLrJm12TlbhLCzwjftY6_OhIB3ej6o44E=@protonmail.com>
 <beLVDOWDR2iV7hnmLpR4bBal2QWxAYqayzw8r9CRc5afhyqZjGIQZQZEerwIIXcmRC9KFigFDFu5_CU4vxoeLFxhNrDGUaZy44_JOs3asmk=@protonmail.com>
 <utxb-_hCi1ABBK86Z5qAkOH0q6RiyiAg1UXzCxgy1usYS2iVZjwIdXjEfnXXenqkMVtJ8omdyUw9kf9BTQXghTnWSvOoTqO7m3SMUPZURR0=@protonmail.com>
Message-ID: <lUnYaQ3Ubk82XnFs9TFXpsjzPGqS7jAGWJNIqOPKmchkAGANZ5JmrErRs_29HVNdm_KlMXuP6l45TYBglItGDZ1Szefz7FazxuBG52lOprQ=@protonmail.com>

Good morning Robin,

> Hi Joachim,?
>
> > if anyone can halt operation of a sidechain with just tiny investment.
>
> It'll be impossible to halt a healthy chain with a tiny investment because halting a chain costs you at least as much as the side chain rewards. The "invested time value per block" of all honest stakers converges against the block reward. If imbalanced, someone will stake more bitcoin to get the cheap sidechain rewards. Exactly the same market mechanism secures PoW.
>
> For a decentralized consensus via resource consumption it doesn't matter which limited resource you consume. The only relevant factor is that the value of the block reward is sufficient to motivate people to invest a lot of that resource. To motivate them to invest so much that an attacker cannot invest more. Independently of the resource, the amount of honestly invested resources converges against the value of the block reward.

Also known as MC = MR.

This is in fact the core of the argument *against* this kind of global microchain system: each individual chain will either:

* Pay ridiculously high fees per transaction, because the microchain has a small number of transactions because that is the entire *point* of microchains.
* Pay insufficient fees per block, making it easy to attack, meaning the security of the chain has to be centralized around a few actors anyway (e.g. checkpoints, like what every altcoin implements), which is not much better than the custodial case you are complaining against.

In order to have a sidechain that is as secure as Bitcoin today, you need:

* Sidechain fees to cover both *current Bitcoin fees* plus *current Bitcoin block rewards*.

Consequently, the sidechain has to have either *more* users than Bitcoin today, or *higher* fees than Bitcoin today.

Unless of course you propose to have the sidechain issue its own coin, in which case it is not much more than an altcoin.
Still, the real-world value of the total block rewards for that altcoin will have to match the real-world value of the total block rewards of Bitcoin in order to have security even approaching Bitcoin.

>
> Thus, I would even go further with my claim and argue that the security of bitcoin-backed PoS is exactly as strong as PoW because in both cases their security is proportionally to the dollar value of their block reward. PoS sidechain security depends only on a sufficient userbase and thus, block reward value.

Only if the consumed resource matches what is consumed under PoW.
Otherwise it is not much better than a low-PoW altcoin, i.e. easily attackable unless it centralizes around the developers.


I understand the desire to smoothen the experience of onboarding new users to Bitcoin.
But this path is not much better than the custodial solutions you are trying to avoid anyway.

Regards,
ZmnSCPxj

From jlrubin at mit.edu  Sat Jan 18 03:58:27 2020
From: jlrubin at mit.edu (Jeremy)
Date: Fri, 17 Jan 2020 19:58:27 -0800
Subject: [bitcoin-dev] OP_CTV Workshop & CFP February 1st, 2020
In-Reply-To: <CAD5xwhixf+YGNiVZ2kB2zN+s2Wy_BscYVWQVgWXv+LEwrfgMEA@mail.gmail.com>
References: <CAD5xwhixf+YGNiVZ2kB2zN+s2Wy_BscYVWQVgWXv+LEwrfgMEA@mail.gmail.com>
Message-ID: <CAD5xwhhXpAkqb+2aNOjjpfcHSiMwZz-=G3wFb0+9aU_DdhtcvA@mail.gmail.com>

It's not too late to sign up  to attend the workshop; but we are
approaching capacity!

Please fill out the form if you'd like to participate as soon as possible
so that we can plan accordingly.

Feel free to forward this posting to people who don't follow this list but
you think should attend.
--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>


On Sat, Jan 4, 2020 at 5:58 PM Jeremy <jlrubin at mit.edu> wrote:

> Dear Bitcoin Developers,
>
> On February 1st, 2020 in San Francisco (location to be shared with
> attendees only) I will be hosting a workshop to aid in reviewing and
> advancing OP_CHECKTEMPLATEVERIFY.
>
> The workshop will be from 10am-5pm. The basic schedule of events (subject
> to change) is in the footer of this email.
>
> If you would like to attend, please fill out the form
> https://forms.gle/ex2WLYS319HFdpJYA . We should have capacity for
> everyone who wants to come, but I'll need to know by January 15th if you
> plan to attend. The primary audience for the event is Bitcoin developers,
> ecosystem engineers (i.e., mining pools, wallets, exchanges, etc), and
> researchers.
>
> If you have research or projects related to OP_CTV you would be interested
> in presenting, please indicate in the application form with a brief
> summary of your topic.
>
> I may be able to sponsor travel for a few developers who would otherwise
> be unable to attend. Please indicate on the form if you require such
> support.
>
> If you're able to sponsor the event (for lunch/dinner, or for travel
> subsidies), please reach out or indicate on the form.
>
> If you cannot attend, I'll make a best effort to make all materials from
> the event available online. The channel ##ctv-bip-review is also available
> for general discussion about OP_CTV.
>
> Happy New Year!
>
> Jeremy
>
> 10:00 AM - 10:30 AM: coffee & registration
>
> BIP SESSION
> 10:30 AM - 11:00 AM: CTV BIP Design Walkthrough & Basic Motivation
> 11:00 AM - 11:30 AM: Small Group Discussion & BIP Reading
> 11:30 AM - 12:00 PM: BIP Q&A
>
> 12pm: Lunch
>
> IMPLEMENTATION SESSION
> 1:00 PM - 1:30 PM: BIP Implementation Walkthrough
> 1:30 PM - 2:00 PM: Q&A + silent review implementation review time
>
> DEPLOYMENT SESSION
> 2:00 PM - 2:15 PM: Deployment Plan Proposal
> 2:15 PM - 2:45 PM: Deployment Plan Discussion
>
> 2:45-3pm: BREAK
>
> ECOSYSTEM SUPPORT SESSION
> 3:00 PM - 3:30 PM: Mempool Updates Presentation & Discussion
> 3:30 PM - 4:00 PM: Package Relay Informational Updates
>
> DEMO SESSION & APPLICATION TALKS
> 4:00 PM - 4:10 PM: SENDMANYCOMPACTED Demo
> 4:10 PM - 4:20 PM: Vault Wallet Demo
> 4:20 PM: - 4:30 PM: TBA
> 4:30 PM - 4:40PM: TBA
> 4:40 PM - 4:50 PM: TBA
>
> WRAP UP
> 4:50 PM - 5:00 PM
>
> DINNER:
> 5:00 PM - 7:00 PM Dinner & Drinks
>
>
> --
> @JeremyRubin <https://twitter.com/JeremyRubin>
> <https://twitter.com/JeremyRubin>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200117/ca2da814/attachment.html>

From luke at dashjr.org  Sun Jan 19 17:04:35 2020
From: luke at dashjr.org (Luke Dashjr)
Date: Sun, 19 Jan 2020 17:04:35 +0000
Subject: [bitcoin-dev] Bitcoin Knots 0.19.0.1.knots20200104 released
Message-ID: <202001191704.48707.luke@dashjr.org>

Bitcoin Knots version 0.19.0.1.knots20200104 is now available from:

  https://bitcoinknots.org/files/0.19.x/0.19.0.1.knots20200104/

This release includes new features, various bug fixes and performance 
improvements, as well as updated translations.

Please report bugs using the issue tracker at GitHub:

  https://github.com/bitcoinknots/bitcoin/issues

To receive security and update notifications, please subscribe to:

  https://bitcoinknots.org/list/announcements/join/

For the full release notes and change log, see:

https://github.com/bitcoinknots/bitcoin/blob/v0.19.0.1.knots20200104/doc/release-notes.md

New features of particular interest
===================================

- BIP157 (Neutrino) can be enabled to serve compact block filters to peers.
  This requires both the `-blockfilterindex` and `-peercfilters` options
  enabled, and can also be turned on in the GUI settings under the Network
  tab.

- PSBT support has been experimentally expanded to include the new version and
  proprietary fields, as well as easier usage from the GUI for watch-only
  wallets.

- The Overview tab now has the ability to hide private information. This is
  still an experimental feature, and suggestions for how the new "privacy
  mode" should look can be made on the related Core PR:
    https://github.com/bitcoin/bitcoin/pull/16432
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 1524 bytes
Desc: This is a digitally signed message part.
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200119/83ec0ecc/attachment.sig>

From robinlinus at protonmail.com  Sat Jan 18 08:21:36 2020
From: robinlinus at protonmail.com (Robin Linus)
Date: Sat, 18 Jan 2020 08:21:36 +0000
Subject: [bitcoin-dev] Coins: A trustless sidechain protocol
In-Reply-To: <lUnYaQ3Ubk82XnFs9TFXpsjzPGqS7jAGWJNIqOPKmchkAGANZ5JmrErRs_29HVNdm_KlMXuP6l45TYBglItGDZ1Szefz7FazxuBG52lOprQ=@protonmail.com>
References: <kAPCabG_c_AiGFYny48dO7ZT-MUgINLLoiKdzElSN8IrRej9szT3t9s0FvAHihraSo0CftPwFjU_pxvKuu9SziIJFt2JZxO3rdpS3-CMKzg=@protonmail.com>
 <ILtIOT_2wq-ld0mk5kPev5mw8RQD6pgzSF_EPuY1PE-mdsy8eJqsCaSU-zIyNZw-4W4p5JtLJs5d451PnHvQly-3V1q225bKmdanMZVOmGE=@protonmail.com>
 <0RSAH-PjblJV6Q7TGosFHAEdc9QGauCQ_knCzMwcoGdW4Qt49ts-egDkIwM-X_f0RjsPMquwdnmB6spunH379ICEAJQgUH7R1SE8CuZs7pI=@protonmail.com>
 <6JaReZbjL3U0QrirtiCdgk107cNmQHiLbbJIDctf8uGUiqJOLvZwRLLPUQXAjzfAqRQBpaqtytcKhq1hvtSDwwaKGthwy40SWHDRnTpBkJA=@protonmail.com>
 <6pcznun9_VnOIV7D28YeCiWqSLtPnN7syJvgGVp_VIo_DAZyp2mDYZQxg6IT5dJagroU-TKgUUjLrJm12TlbhLCzwjftY6_OhIB3ej6o44E=@protonmail.com>
 <beLVDOWDR2iV7hnmLpR4bBal2QWxAYqayzw8r9CRc5afhyqZjGIQZQZEerwIIXcmRC9KFigFDFu5_CU4vxoeLFxhNrDGUaZy44_JOs3asmk=@protonmail.com>
 <utxb-_hCi1ABBK86Z5qAkOH0q6RiyiAg1UXzCxgy1usYS2iVZjwIdXjEfnXXenqkMVtJ8omdyUw9kf9BTQXghTnWSvOoTqO7m3SMUPZURR0=@protonmail.com>
 <lUnYaQ3Ubk82XnFs9TFXpsjzPGqS7jAGWJNIqOPKmchkAGANZ5JmrErRs_29HVNdm_KlMXuP6l45TYBglItGDZ1Szefz7FazxuBG52lOprQ=@protonmail.com>
Message-ID: <nFmYwRlcPEVdyxh35Rn8WgbP15JKjj9TqMss3nFXohUDH_YHOhTVfnmyjMGojZWaTHJV9HiGzw8KoGYi3pDz5Ne0FaBIEfnstPfUsW1fqr0=@protonmail.com>

Goog morning ZmnSCPxj,


>     Unless of course you propose to have the sidechain issue its own coin, in which case it is not much more than an altcoin.

Okay, call it an altcoin consensus mechanism. Because sidechains do have to issue their own coins.

Still, I am not proposing independent altcoins. Bitcoin is the only unit of account. I am proposing bitcoin derivatives only as means of bitcoin transfer. Think of gold vs cash.

>     Still, the real-world value of the total block rewards for that altcoin will have to match the real-world value of the total block rewards of Bitcoin in order to have security even approaching Bitcoin.

My point is that, assuming equal rewards, PoW and bitcoin-backed PoS do offer the same level of security.

So in theory, you are right. In practice, a sidechain does not need to be as secure as bitcoin. It requires only a sufficient user base.



Thanks again for your detailed answer,
-Robin

From ZmnSCPxj at protonmail.com  Tue Jan 21 04:38:07 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 21 Jan 2020 04:38:07 +0000
Subject: [bitcoin-dev] Payswap
Message-ID: <nWAInXGl2LEOcttjF0HhV8rgmjNXZS9nfb8I-XApvOaz1KLZbzZcLDoPaa4ADDMpAKHF9-SfGX291bnYwNaW8afuMSL5KQjdV0E8LQksGSU=@protonmail.com>

Good morning list,

[On a recent post on lightning-dev](https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-January/002431.html), I brought up the possibility of using a circular self-payment to hide the actual direction of payment from third-party snooping nodes.
Basically, instead of paying the amount to the destination, we can have an atomic mechanism by which the source pays a larger-than-amount payment to the destination and the destination returns the difference instead.

As the mechanisms on Lightning are also implementable directly on the blockchain, I observe as well that we can use a similar mechanism based on CoinSwap to mislead onchain analysis as well.

The normal payment flow for a Bitoin payer is typically:

* Locate some of its owned UTXO(s) that total an amount equal or greater than the payment amount.
* Create a single transaction that consumes those inputs and outputs the amount to the destination and any remainder to a new address we control.

However, we can observe as well that transactions and transaction outputs can be considered nodes and edges of a transaction graph, respectively.
We can then consider the categorical dual of such a graph.

Let me then present the Payswap payment flow:

* Sender locates some of its owned UTXO(s) that total an amount equal or greater than the payment amount.
  * Sender reveals the sum to destination.
* Destination locates some of its owned UTXO(s) that total an amount equal or greater than the difference (change) of the sender total minus the payment amount.
* Sender and destination set up an unequal CoinSwap:
  * Destination receives all the Sender coins.
  * Sender receives the difference between the Sender total and the payment amount (change).
* Sender and destination execute the CoinSwap and complete the payment protocol.

What appears onchain are:

* A transaction with a single output.
  * This is the CoinSwap funding transaction that was offered by the sender and claimed by the destination.
  * As a single-output transaction, this looks to chain analysis to be a likely self-payment.
* A transaction with two outputs.
  * This is the CoinSwap funding transaction that was offered by the destination and claimed by the sender.
  * The output that goes back to the destination looks like a change output according to chain analysis.
  * The output that goes to the sender looks like a payment from the destination to the sender, reversing the apparent direction of payment and obscuring the amount paid.
* Two more transaction that complete the protocol, each spending one of the above and moving the funds to unilateral control of the destination and sender respectively.

The above is an active misleading of chain analysis.

This is even possible today with 2p-ECDSA to make it use P2WPKH with Scriptless Script.

Against the above flow I must caution:

* This involves more transactions than Payjoin, thus more expensive in blockspace.
* The protocol can be aborted by one participant, which will lead to spending onchain fees to back out of the protocol, unlike Payjoin which is atomic with paying onchain fees.
* As I [point out elsewhere](https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002245.html), CoinSwap overhead approaches the overhead of setting up a temporary Lightning Network channel, thus it might actually be better to implement all CoinSwap protocols over Lightning instead.

Regards,
ZmnSCPxj


From ZmnSCPxj at protonmail.com  Fri Jan 24 10:11:55 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 24 Jan 2020 10:11:55 +0000
Subject: [bitcoin-dev] Payswap
In-Reply-To: <nWAInXGl2LEOcttjF0HhV8rgmjNXZS9nfb8I-XApvOaz1KLZbzZcLDoPaa4ADDMpAKHF9-SfGX291bnYwNaW8afuMSL5KQjdV0E8LQksGSU=@protonmail.com>
References: <nWAInXGl2LEOcttjF0HhV8rgmjNXZS9nfb8I-XApvOaz1KLZbzZcLDoPaa4ADDMpAKHF9-SfGX291bnYwNaW8afuMSL5KQjdV0E8LQksGSU=@protonmail.com>
Message-ID: <hWBM2yvN6QhN97j2qjFV_yWmCaRtCJ3cqO-LXRcKEZu89kzOaaQPmfRCuEq4uZe07WHKNNa5dZ7X1PqK4hd_9X5cxR8SuD0lWtUG-fVdIFA=@protonmail.com>

Good morning list,

A few more things to consider:

Probably the correct order for this would be for the payer to instantiate the Scriptless Script payment to the payee first, then the payee instantiating the change back to the payer.

By use of some kind of Scriptless Script, it is possible to as well implement a proof-of-payment system similar to Lightning, which might be useful to prove to an auditor that a payment has been made (without being forced to reveal this to anyone other than the auditor).
Both the payer and payee can generate a scalar.
The payee provides a signed invoice (can reuse the Lightning BOLT11 invoice format) attesting the payment point that needs to be paid, the payment point being the generator point times te payee scalar.
The payer then instantiates the Scriptless Script PTLC, requiring knowledge of the payee scalar + the payer scalar from the payee.
Then the payee instantiates the change Scriptless Script PTLC, requiring knowledge of the payer scalar from the payer.
Then the payee claims the change, which allows the payer to claim the full transfer while revealing the payee scalar as a proof-of-payment.


Regards,
ZmnSCPxj

> Good morning list,
>
> On a recent post on lightning-dev, I brought up the possibility of using a circular self-payment to hide the actual direction of payment from third-party snooping nodes.
> Basically, instead of paying the amount to the destination, we can have an atomic mechanism by which the source pays a larger-than-amount payment to the destination and the destination returns the difference instead.
>
> As the mechanisms on Lightning are also implementable directly on the blockchain, I observe as well that we can use a similar mechanism based on CoinSwap to mislead onchain analysis as well.
>
> The normal payment flow for a Bitoin payer is typically:
>
> -   Locate some of its owned UTXO(s) that total an amount equal or greater than the payment amount.
> -   Create a single transaction that consumes those inputs and outputs the amount to the destination and any remainder to a new address we control.
>
>     However, we can observe as well that transactions and transaction outputs can be considered nodes and edges of a transaction graph, respectively.
>     We can then consider the categorical dual of such a graph.
>
>     Let me then present the Payswap payment flow:
>
> -   Sender locates some of its owned UTXO(s) that total an amount equal or greater than the payment amount.
>     -   Sender reveals the sum to destination.
> -   Destination locates some of its owned UTXO(s) that total an amount equal or greater than the difference (change) of the sender total minus the payment amount.
> -   Sender and destination set up an unequal CoinSwap:
>     -   Destination receives all the Sender coins.
>     -   Sender receives the difference between the Sender total and the payment amount (change).
> -   Sender and destination execute the CoinSwap and complete the payment protocol.
>
>     What appears onchain are:
>
> -   A transaction with a single output.
>     -   This is the CoinSwap funding transaction that was offered by the sender and claimed by the destination.
>     -   As a single-output transaction, this looks to chain analysis to be a likely self-payment.
> -   A transaction with two outputs.
>     -   This is the CoinSwap funding transaction that was offered by the destination and claimed by the sender.
>     -   The output that goes back to the destination looks like a change output according to chain analysis.
>     -   The output that goes to the sender looks like a payment from the destination to the sender, reversing the apparent direction of payment and obscuring the amount paid.
> -   Two more transaction that complete the protocol, each spending one of the above and moving the funds to unilateral control of the destination and sender respectively.
>
>     The above is an active misleading of chain analysis.
>
>     This is even possible today with 2p-ECDSA to make it use P2WPKH with Scriptless Script.
>
>     Against the above flow I must caution:
>
> -   This involves more transactions than Payjoin, thus more expensive in blockspace.
> -   The protocol can be aborted by one participant, which will lead to spending onchain fees to back out of the protocol, unlike Payjoin which is atomic with paying onchain fees.
> -   As I point out elsewhere, CoinSwap overhead approaches the overhead of setting up a temporary Lightning Network channel, thus it might actually be better to implement all CoinSwap protocols over Lightning instead.
>
>     Regards,
>     ZmnSCPxj
>
>
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From fresheneesz at gmail.com  Sat Jan 25 01:50:49 2020
From: fresheneesz at gmail.com (Billy)
Date: Fri, 24 Jan 2020 17:50:49 -0800
Subject: [bitcoin-dev] op_checktemplateverify and number of inputs
Message-ID: <CAGpPWDYYYYEeuQVL6d97_OwN_f8ektdqv-5zXVT9fEqiS6qtoQ@mail.gmail.com>

I have a question about op_ctv related to the requirement to specify the
number of inputs. I don't quite see why its necessary, but most
importantly, I don't see why we want to *require* the user of the op to
specify the number of inputs, tho I see the reasoning why one would want to
specify it. If the op allowed both cases (specifying a number of inputs and
allowing any number), it seems like the best of both worlds. I started a
discussion on bitcointalk.org:

https://bitcointalk.org/index.php?topic=5220520
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200124/5cd8c5b5/attachment.html>

From jlrubin at mit.edu  Sun Jan 26 17:23:57 2020
From: jlrubin at mit.edu (Jeremy)
Date: Sun, 26 Jan 2020 09:23:57 -0800
Subject: [bitcoin-dev] op_checktemplateverify and number of inputs
In-Reply-To: <CAGpPWDYYYYEeuQVL6d97_OwN_f8ektdqv-5zXVT9fEqiS6qtoQ@mail.gmail.com>
References: <CAGpPWDYYYYEeuQVL6d97_OwN_f8ektdqv-5zXVT9fEqiS6qtoQ@mail.gmail.com>
Message-ID: <CAD5xwhg9848ptvGS-tct4Ofpcucef3Qi9XhDQEYzEpM+-ydZMw@mail.gmail.com>

Hi Billy,

Restricting the number of inputs is necessary to preclude TXID
malleability. Committing to all of the information required necessitates
that the number of inputs be committed.

This allows us to build non-interactive layer 2 protocols which depend on
TXID non-malleability (most of them at writing).

You raise a good point that allowing *any number* of inputs is an
interesting case, which I had discussed offline with a few different
people. I think the conclusion was that that flexibility is better left
outside of the OP directly.

If you want an any number of inputs template, and we enable something like
OP_CAT (e.g., OP_CAT, OP_SHA256STREAM) then you can spend to something like:

<hash data before # inputs> OP_SWAP OP_CAT OP_SWAP OP_CAT <data post #
inputs> OP_CAT OP_SHA256 OP_CTV

And then pass in the # of inputs and sequences hash as arguments to the
function.

I can respond separately to your bitcointalk post as you ask a different
set of questions there.

Best,

Jeremy
--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>


On Sun, Jan 26, 2020 at 8:59 AM Billy via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I have a question about op_ctv related to the requirement to specify the
> number of inputs. I don't quite see why its necessary, but most
> importantly, I don't see why we want to *require* the user of the op to
> specify the number of inputs, tho I see the reasoning why one would want to
> specify it. If the op allowed both cases (specifying a number of inputs and
> allowing any number), it seems like the best of both worlds. I started a
> discussion on bitcointalk.org:
>
> https://bitcointalk.org/index.php?topic=5220520
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200126/a0b42ad4/attachment.html>

From lloyd.fourn at gmail.com  Tue Jan 28 09:28:27 2020
From: lloyd.fourn at gmail.com (Lloyd Fournier)
Date: Tue, 28 Jan 2020 20:28:27 +1100
Subject: [bitcoin-dev] [Annoucement] Discreet Log Contract Protocol
	Specification
In-Reply-To: <CAFQwNuz5YtpWZh7UF_b5zVz2gspMnWfdaMRdVhobZSq6pcxybQ@mail.gmail.com>
References: <CAFQwNuz5YtpWZh7UF_b5zVz2gspMnWfdaMRdVhobZSq6pcxybQ@mail.gmail.com>
Message-ID: <CAH5Bsr2=EE+tj+SXckQV=4x7LNXrB4KTJhZWMLQZ8FWLGMnv3g@mail.gmail.com>

Hi Chris,

This is a really exciting effort. I hope I will be able to contribute to
it. I was wondering if you had seen the idea that DLCs can be done in only
two transaction using Schnorr[1]. I also think this can be done in Bitcoin
as it is today using ECDSA adaptor signatures [2]. In my mind, the adaptor
signature protocol is both easier to specify and implement on top of being
cheaper and more private.

LL

[1] https://lists.launchpad.net/mimblewimble/msg00485.html
[2]
https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-November/002316.html

On Tue, Jan 14, 2020 at 2:12 AM Chris Stewart via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi all,
>
> Suredbits and Crypto Garage have begun to work on a specification for
> using discreet log contracts <https://adiabat.github.io/dlc.pdf> in a
> safe, private and interoperable way. We are writing to the mailing list to
> inform and solicit feedback for the protocol specification so that we can
> -- as a community -- agree on a common standard to use Bitcoin oracles.
>
> Our goal is to end up with a set of documents like the BIPs (Bitcoin
> Improvement Proposals) and BOLTs (Basis of Lightning Technology) so that
> others that wish to use the technology can easily write software to
> integrate into the protocol.
>
> A secondary goal of ours is to remain compatible with standards used by
> other bitcoin related protocols (like Lightning) so that every future
> bitcoin related protocol can reach for a ?toolbox? of agreed standards for
> things like funding transactions and closing transactions. We want to avoid
> reinventing the wheel where possible and allow for library developers to
> re-use software to hook into many bitcoin related protocols.
>
> You can find the specification repository here:
>
> https://github.com/discreetlogcontracts/dlcspecs/
>
> For more information on DLCs:
>
> [1] - https://adiabat.github.io/dlc.pdf
>
> [2] - https://cryptogarage.co.jp/p2pd/
>
> [3] -
> https://suredbits.com/discreet-log-contracts-part-1-what-is-a-discreet-log-contract/
>
> [4] -
> https://blockstream.com/2019/04/19/en-transacting-bitcoin-based-p2p-derivatives/
>
> [5] - https://dci.mit.edu/smart-contracts
>
> -Chris
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200128/4b5183aa/attachment.html>

From karljohan-alm at garage.co.jp  Thu Jan 30 11:55:13 2020
From: karljohan-alm at garage.co.jp (Karl-Johan Alm)
Date: Thu, 30 Jan 2020 20:55:13 +0900
Subject: [bitcoin-dev] New tool to assist in BIP 340-342 review: tap
Message-ID: <CALJw2w4uj56rbDh-BryFts7TOKCyznUfcvtNehzSn+ZRVB1Hrw@mail.gmail.com>

Hello,

One of the tools I am maintaining called btcdeb (Bitcoin Script
Debugger) has a new experimental branch "taproot", which builds on top
of the WIP taproot pull request to Bitcoin Core, and contains a new
command line tool called "tap".

Tap allows you to compose taproot and/or tapscript outputs, both for
funding and spending.

There is a detailed tutorial on how this works here:
https://github.com/kallewoof/btcdeb/blob/taproot/doc/tapscript-example-with-tap.md

Feedback welcome.

From ZmnSCPxj at protonmail.com  Fri Jan 31 03:42:08 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 31 Jan 2020 03:42:08 +0000
Subject: [bitcoin-dev] Onchain fee insurance mechanism
Message-ID: <2U3WdMgyM7iLhQnak0GjkH6u6C0C_Ry59WucTiRthajkOXqAirvN55U39to0kQY5bDzv9SBZXy5Qbx2QZopJwktHqVUKbfpCjEfq1H_v0vE=@protonmail.com>

Good morning list,

During LNConf 2019, Jack Mallers presented about hedging of onchain fees, which he argues is necessary in order to have a smooth experience interfacing between onchain and offchain (in particular, when closing and opening channels).

The exact mechanism proposed was to construct a futures market on onchain feerates, with miners taking short positions on fees (they are naturally long on fees) while users take long positions on fees (they are naturally short on fees).

I observe that what the users effectively experience is similar to a constant feerate (indeed the positions the user takes up are arranged such that the user takes a constant feerate for a vast majority of the expected future outcomes).
This is effectively an insurance policy against increases in feerate.

Let me then propose a specific mechanism for feerate insurance against onchain feerate spikes.

Let us suppose that the user Alice, has 500000 satoshi, and has to pay Bob 400000 satoshi.
Further, Alice and Bob have a fee insurance provider Ingrid.
Ingrid assures Alice and Bob that 600 satoshi is sufficient to confirm the payment from Alice to Bob within 4 blocks.
Ingrid also happens to have a 800000 satoshi output lying around.

At current blockheight B, Alice and Ingrid then arrange a series of transactions:

    nLockTime: B+1
    nSequence: RBF enabled, no relative locktime.
    inputs: Alice 5000000, Ingrid 800000
    outputs:
        Bob 400000
        Alice 99400
        Ingrid 800400
    fee: 200

    nLockTime: B+2
    nSequence: RBF enabled, no relative locktime.
    inputs: Alice 5000000, Ingrid 800000
    outputs:
        Bob 400000
        Alice 99400
        Ingrid 800200
    fee: 400

    nLockTime: B+3
    nSequence: RBF enabled, no relative locktime.
    inputs: Alice 5000000, Ingrid 800000
    outputs:
        Bob 400000
        Alice 99400
        Ingrid 800001
    fee: 599

    nLockTime: B+4
    nSequence: RBF enabled, no relative locktime.
    inputs: Alice 5000000, Ingrid 800000
    outputs:
        Bob 400000
        Alice 99400
        Ingrid 797000
    fee: 3600

Basically, if the first transaction is able to be included in the next block immediately, then Ingrid is able to earn the most of the fee paid by Alice.
However, as more blocks pass without the transaction getting committed, the transaction in the mempool is replaced by transactions that bump up the fee, until the time limit is reached and Ingrid pays out significantly in order to ensure the payment pushes through.

As far as I can tell, this mechanism will also work for CPFP-style transactions.

In general, the insurance provider Ingrid will be a miner.

--

In the original context, this is generally about fast confirmation of channel closes.
At the time that a commitment transaction is made, it is uncertain if the feerate for it would still remain valid for some future spike.
The safest is that, if the counterparty is offline, if the feerate spikes, we should drop the channel unilaterally onchain before it rises so high that the commitment transaction cannot be confirmed in a timely manner.
However, if the feerate then settles lower afterwards, we have already broadcasted the channel closure will no longer be able to use the fund on Lightning.

Unfortunately, the mechanism described above requires absolute locktimes, which would impose a maximum lifetime on channels, which we would like to avoid.
Thus, the mechanism cannot be used for Lightning closes.

For the Lightning case, what we want is something like:

* Ingrid assures Alice and Bob that the close transaction can be confirmed at any time, for only N satoshi.

The previous mechanism described is nearer to:

* Ingrid assures Alice that the transaction can be confirmed up to B blocks from now, for only N satoshi.

The issue is that relative locktimes require that a transaction be confirmed, and it is transaction itself that we want to assure.
Thus, we cannot use relative locktimes for any kind of fee-insurance mechanism.
Thus, we must somehow tie down the blockheight at which we start our countdown, and so we cannot use this for Lightning closes, since Lightning closes must be freely doable at any time.

Still, the mechanism might be useful for onchain transactions to help reassure users (which is why I send this post to bitcoin-dev).

Regards,
ZmnSCPxj

From dave at dtrt.org  Fri Jan 31 21:01:29 2020
From: dave at dtrt.org (David A. Harding)
Date: Fri, 31 Jan 2020 15:01:29 -0600
Subject: [bitcoin-dev] Onchain fee insurance mechanism
In-Reply-To: <2U3WdMgyM7iLhQnak0GjkH6u6C0C_Ry59WucTiRthajkOXqAirvN55U39to0kQY5bDzv9SBZXy5Qbx2QZopJwktHqVUKbfpCjEfq1H_v0vE=@protonmail.com>
References: <2U3WdMgyM7iLhQnak0GjkH6u6C0C_Ry59WucTiRthajkOXqAirvN55U39to0kQY5bDzv9SBZXy5Qbx2QZopJwktHqVUKbfpCjEfq1H_v0vE=@protonmail.com>
Message-ID: <20200131210129.ufnjxb2x7wllhcuw@ganymede>

On Fri, Jan 31, 2020 at 03:42:08AM +0000, ZmnSCPxj via bitcoin-dev wrote:
> Let me then propose a specific mechanism for feerate insurance against onchain feerate spikes.
> 
> [...]
> 
> At current blockheight B, Alice and Ingrid then arrange a series of transactions:
> 
>     nLockTime: B+1
>     nSequence: RBF enabled, no relative locktime.
>     inputs: Alice 5000000, Ingrid 800000
>     outputs:
>         Bob 400000
>         Alice 99400
>         Ingrid 800400
>     fee: 200
>
> [...]

Ingrid is able to rescind this series of pre-signed transactions at any
time before one of the transactions is confirmed by double spending her
UTXO (e.g. via a RBF fee bump).  If Alice needs to trust Ingrid to honor
the contract anyway, they might as well not include Ingrid's input or
output in the transaction and instead use an external accounting and
payment mechanism.  For example, Alice and Ingrid agree to a fee
schedule:

>     height: B+1
>     fee: 200
>
>     height: B+2
>     fee: 400
>
>     height: B+3
>     fee: 599
>
>     height: B+4
>     fee: 3600

Then they wait for whichever version of the transaction to confirm and
one of them remits to the other the appropriate amount (either 400, 200,
or 1 base unit to Ingrid, or 3,000 base units to Alice).  This
remittance can be done by whatever mechanism they both support (e.g. an
onchain transaction, an LN payment, or just credit on an exchange).

Since it's possible to achieve equivilent security (or lack thereof)
without the locktime mechanism, I don't think the locktime mechanism
adds anything to the idea of hedging fees---and, as you note, it suffers
from incompatibility with some cases where users would be especially
eager to obtain feerate insurance.

-Dave
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200131/7493919a/attachment.sig>

From maimtiaz at bu.edu  Fri Jan 31 23:07:26 2020
From: maimtiaz at bu.edu (Anas)
Date: Fri, 31 Jan 2020 18:07:26 -0500
Subject: [bitcoin-dev] Characterizing orphan transaction in the Bitcoin
	network
Message-ID: <CAPc0aKFuE9RVHj0i3k_C+Lc3dyqk6m4+zvq=JG+51TUgUMFz5w@mail.gmail.com>

Hi all,

This paper - https://arxiv.org/pdf/1912.11541.pdf - characterizes orphan
transactions in the Bitcoin network and shows that increasing the size of
the orphan pool reduces network overhead with almost no additional
performance overhead. What are your thoughts?

Abstract:

> Orphan transactions are those whose parental income-sources are missing at
> the time that they are processed. These transactions are not propagated to
> other nodes until all of their missing parents are received, and they thus
> end up languishing in a local buffer until evicted or their parents are
> found. Although there has been little work in the literature on
> characterizing the nature and impact of such orphans, it is intuitive that
> they may affect throughput on the Bitcoin network. This work thus seeks to
> methodically research such effects through a measurement campaign of orphan
> transactions on live Bitcoin nodes. Our data show that, surprisingly,
> orphan transactions tend to have fewer parents on average than non-orphan
> transactions. Moreover, the salient features of their missing parents are a
> lower fee and larger size than their non-orphan counterparts, resulting in
> a lower transaction fee per byte. Finally, we note that the network
> overhead incurred by these orphan transactions can be significant,
> exceeding 17% when using the default orphan memory pool size (100
> transactions). However, this overhead can be made negligible, without
> significant computational or memory demands, if the pool size is merely
> increased to 1000 transactions.


Regards,
Anas
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200131/374b5b05/attachment.html>

From hasu.research at gmail.com  Fri Jan 31 13:38:22 2020
From: hasu.research at gmail.com (ha su)
Date: Fri, 31 Jan 2020 14:38:22 +0100
Subject: [bitcoin-dev] Purge attacks (spin on sabotage attacks)
Message-ID: <CAEmzEcO51GEETunPBXuecpVtZCvH4rpvcNcLsYCrDaDH=3_qVQ@mail.gmail.com>

Hi all,

I think I discovered an interesting form of sabotage attack (possible for
miners) that tries to create coordination disincentives among Bitcoin users
- named after the dystopian movie The Purge, where all crime is legal for
one night every year.

TLDR
* An attacker replaces the most recent blocks full of transactions with
empty blocks.
* Previously confirmed txns return into the mempool, where anyone with a
minimum of technical knowledge or access to public tools can
opportunistically double-spend their txns back to themselves. (the process
is the same as double-spending regular zero-conf txns)

The attack seems useful to undermine trust in Bitcoin's assurances, e.g.
the future finality of transactions. It differs from other forms of
sabotage (e.g. DoS by mining only empty blocks) in that it specifically
disrupts the coordination process among users in response to the attack.

By giving some users a chance to benefit from the attack, the attacker
gives them a vested interest in staying on the attack chain. If enough
users accept the invitation to double-spend, it might become harder to come
to consensus on how to deal with the attack.

Purge attacks probably don?t constitute a bigger risk than other known
forms of sabotage attacks, but seem like an interesting spin where the
attacker specifically targets the pre-coordination of defenders.

You can find the full report, incl. some mitigations against sabotage
attacks, at
https://blog.deribit.com/insights/destabilizing-bitcoin-consensus-with-purge-attacks/

Your feedback is highly appreciated.

Regards,
Hasu
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200131/774692b8/attachment.html>

