From laanwj at gmail.com  Sat Aug  1 12:46:44 2020
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Sat, 1 Aug 2020 14:46:44 +0200
Subject: [bitcoin-dev] Bitcoin Core 0.20.1 released
Message-ID: <20200801124644.frjxj4qu7orplkvk@aurora.visucore.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

0.20.1 Release Notes
====================

Bitcoin Core version 0.20.1 is now available from:

  <https://bitcoincore.org/bin/bitcoin-core-0.20.1/>

Or through BitTorrent:

    magnet:?xt=urn:btih:6e2c72d73d763465a725e3ae941b2b937edd0300&dn=bitcoin-core-0.20.1&tr=https%3A%2F%2Fopenbittorrent.com%2F&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337%2Fannounce&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969%2Fannounce&tr=udp%3A%2F%2Fexplodie.org%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.torrent.eu.org%3A451%2Fannounce&tr=udp%3A%2F%2Ftracker.bitcoin.sprovoost.nl%3A6969

This minor release includes various bug fixes and performance
improvements, as well as updated translations.

Please report bugs using the issue tracker at GitHub:

  <https://github.com/bitcoin/bitcoin/issues>

To receive security and update notifications, please subscribe to:

  <https://bitcoincore.org/en/list/announcements/join/>

How to Upgrade
==============

If you are running an older version, shut it down. Wait until it has completely
shut down (which might take a few minutes in some cases), then run the
installer (on Windows) or just copy over `/Applications/Bitcoin-Qt` (on Mac)
or `bitcoind`/`bitcoin-qt` (on Linux).

Upgrading directly from a version of Bitcoin Core that has reached its EOL is
possible, but it might take some time if the data directory needs to be migrated. Old
wallet versions of Bitcoin Core are generally supported.

Compatibility
==============

Bitcoin Core is supported and extensively tested on operating systems
using the Linux kernel, macOS 10.12+, and Windows 7 and newer.  Bitcoin
Core should also work on most other Unix-like systems but is not as
frequently tested on them.  It is not recommended to use Bitcoin Core on
unsupported systems.

- From Bitcoin Core 0.20.0 onwards, macOS versions earlier than 10.12 are no
longer supported. Additionally, Bitcoin Core does not yet change appearance
when macOS "dark mode" is activated.

Known Bugs
==========

The process for generating the source code release ("tarball") has changed in an
effort to make it more complete, however, there are a few regressions in
this release:

- - The generated `configure` script is currently missing, and you will need to
  install autotools and run `./autogen.sh` before you can run
  `./configure`. This is the same as when checking out from git.

- - Instead of running `make` simply, you should instead run
  `BITCOIN_GENBUILD_NO_GIT=1 make`.

Notable changes
===============

Changes regarding misbehaving peers
- -----------------------------------

Peers that misbehave (e.g. send us invalid blocks) are now referred to as
discouraged nodes in log output, as they're not (and weren't) strictly banned:
incoming connections are still allowed from them, but they're preferred for
eviction.

Furthermore, a few additional changes are introduced to how discouraged
addresses are treated:

- - Discouraging an address does not time out automatically after 24 hours
  (or the `-bantime` setting). Depending on traffic from other peers,
  discouragement may time out at an indeterminate time.

- - Discouragement is not persisted over restarts.

- - There is no method to list discouraged addresses. They are not returned by
  the `listbanned` RPC. That RPC also no longer reports the `ban_reason`
  field, as `"manually added"` is the only remaining option.

- - Discouragement cannot be removed with the `setban remove` RPC command.
  If you need to remove a discouragement, you can remove all discouragements by
  stop-starting your node.

Notification changes
- --------------------

`-walletnotify` notifications are now sent for wallet transactions that are
removed from the mempool because they conflict with a new block. These
notifications were sent previously before the v0.19 release, but had been
broken since that release (bug
[#18325](https://github.com/bitcoin/bitcoin/issues/18325)).

PSBT changes
- ------------

PSBTs will contain both the non-witness utxo and the witness utxo for segwit
inputs in order to restore compatibility with wallet software that are now
requiring the full previous transaction for segwit inputs. The witness utxo
is still provided to maintain compatibility with software which relied on its
existence to determine whether an input was segwit.

0.20.1 change log
=================

### Mining
- - #19019 Fix GBT: Restore "!segwit" and "csv" to "rules" key (luke-jr)

### P2P protocol and network code
- - #19219 Replace automatic bans with discouragement filter (sipa)

### Wallet
- - #19300 Handle concurrent wallet loading (promag)
- - #18982 Minimal fix to restore conflicted transaction notifications (ryanofsky)

### RPC and other APIs
- - #19524 Increment input value sum only once per UTXO in decodepsbt (fanquake)
- - #19517 psbt: Increment input value sum only once per UTXO in decodepsbt (achow101)
- - #19215 psbt: Include and allow both non_witness_utxo and witness_utxo for segwit inputs (achow101)

### GUI
- - #19097 Add missing QPainterPath include (achow101)
- - #19059 update Qt base translations for macOS release (fanquake)

### Build system
- - #19152 improve build OS configure output (skmcontrib)
- - #19536 qt, build: Fix QFileDialog for static builds (hebasto)

### Tests and QA
- - #19444 Remove cached directories and associated script blocks from appveyor config (sipsorcery)
- - #18640 appveyor: Remove clcache (MarcoFalke)

### Miscellaneous
- - #19194 util: Don't reference errno when pthread fails (miztake)
- - #18700 Fix locking on WSL using flock instead of fcntl (meshcollider)

Credits
=======

Thanks to everyone who directly contributed to this release:

- - Aaron Clauson
- - Andrew Chow
- - fanquake
- - Hennadii Stepanov
- - Jo?o Barbosa
- - Luke Dashjr
- - MarcoFalke
- - MIZUTA Takeshi
- - Pieter Wuille
- - Russell Yanofsky
- - sachinkm77
- - Samuel Dobson
- - Wladimir J. van der Laan

As well as to everyone that helped with translations on
[Transifex](https://www.transifex.com/bitcoin/bitcoin/).

-----BEGIN PGP SIGNATURE-----

iQEzBAEBCgAdFiEEnerg3HBjJJ+wVHRoHkrtYphs0l0FAl8lYXMACgkQHkrtYphs
0l2A/Af+POYB8GbqA/MnjGRk8Uw6togCO+06gydbbCSHiVEXv9KN17eSimeUw7B8
TcatI0d0+Dx2Exv5vhes3rZrX7eh6clma4WMpxKuWlnL8LzeTV5Hz2lxD6Kg9eZO
gyqsYOgQCtAatApO71z6exzhkqxakzTnWEnWijjG1qVnjGhUPIqEv9KisfhQfWRt
CKGazPK3k6KxVsDG7p5s9a5ue7b88t1E6jiWt/OR6U5Z50AVQzc7Keji7wuG9byr
WsDq8w8VuxLtvLbfNJyR9TguiU3vr85Wm3kK9kjDi4t83l1dzbU4hVllb970dzEK
llclXg5rRi2c52uW4qVXGw2oEMmdfw==
=lUXy
-----END PGP SIGNATURE-----

From m at ib.tc  Sat Aug  1 05:09:25 2020
From: m at ib.tc (Mike Brooks)
Date: Fri, 31 Jul 2020 22:09:25 -0700
Subject: [bitcoin-dev] Smaller Transactions with PubRef
Message-ID: <CALFqKjTDcsD4xpc-TryTRCNnCJivyqkU9dv0ff2emP5kxZF1bA@mail.gmail.com>

The attached BIP describes a new opcode that unlocks the ability to have
transactions that are about 37% smaller than a traditional single-source
segwit transaction.  (Savings vary based on the number of inputs.)

The pursuit of smaller transactions is vital for Inclusive Accountability
as less data needs to be recorded on chain. Frugality is improved in two
ways; more transactions can be confirmed in a  block, and small value
inputs otherwise inaccessible can now be referenced without losing
unrecoverable value due to transaction overhead.

https://github.com/TheRook/bip-pubref/blob/master/bip-PubRef.mediawiki

The variant of this technology on the ethereum side is Ditto Transactions:
https://ethereum-magicians.org/t/eip-ditto-transactions/4455
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200731/e20309cb/attachment.html>

From ZmnSCPxj at protonmail.com  Sun Aug  2 00:36:08 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sun, 02 Aug 2020 00:36:08 +0000
Subject: [bitcoin-dev] Smaller Transactions with PubRef
In-Reply-To: <CALFqKjTDcsD4xpc-TryTRCNnCJivyqkU9dv0ff2emP5kxZF1bA@mail.gmail.com>
References: <CALFqKjTDcsD4xpc-TryTRCNnCJivyqkU9dv0ff2emP5kxZF1bA@mail.gmail.com>
Message-ID: <1cxOISncF4dES_Ijm5FJUhwUAzBupnLPiv3qnU20as76zMMhVyggkg1hphq4ehuqEFK_H88TBbfI2pKbLWzzx7E6kOUXeC-yOcfrOkg3uAY=@protonmail.com>

Good morning Mike,

Hard NAK.

The responses to the original posting already pointed out important problems with this:

* Encourages address reuse, hurting fungibility and privacy.
* Prevents pruning, since access to previous blocks must always be available in order to validate.
* Optimized implementation requires creating yet another index to previous block data, increasing requirements on fullnodes.
* Requires SCRIPT to be re-evaluated on transactions arriving in  newblocks, to protect against reorgs of the chaintip, and in particular `OP_PUBREF` references to near the chaintip.

None of these issues have been addressed in your current proposal.
The proposal looks at clients only, without considering what validators have to implement in order to validate new blocks with this opcode.

Regards,
ZmnSCPxj

From m at ib.tc  Sun Aug  2 01:12:16 2020
From: m at ib.tc (Mike Brooks)
Date: Sat, 1 Aug 2020 18:12:16 -0700
Subject: [bitcoin-dev] Smaller Transactions with PubRef
In-Reply-To: <1cxOISncF4dES_Ijm5FJUhwUAzBupnLPiv3qnU20as76zMMhVyggkg1hphq4ehuqEFK_H88TBbfI2pKbLWzzx7E6kOUXeC-yOcfrOkg3uAY=@protonmail.com>
References: <CALFqKjTDcsD4xpc-TryTRCNnCJivyqkU9dv0ff2emP5kxZF1bA@mail.gmail.com>
 <1cxOISncF4dES_Ijm5FJUhwUAzBupnLPiv3qnU20as76zMMhVyggkg1hphq4ehuqEFK_H88TBbfI2pKbLWzzx7E6kOUXeC-yOcfrOkg3uAY=@protonmail.com>
Message-ID: <CALFqKjSrQ260XfYtdvd9N=ZKZvJqE2iz+reGtBNpq++br9S1ig@mail.gmail.com>

Hey  ZmnSCPxj,

Re-orgs should be solved in a different way.

Best Regards,
Micahel

On Sat, Aug 1, 2020 at 5:36 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Mike,
>
> Hard NAK.
>
> The responses to the original posting already pointed out important
> problems with this:
>
> * Encourages address reuse, hurting fungibility and privacy.
> * Prevents pruning, since access to previous blocks must always be
> available in order to validate.
> * Optimized implementation requires creating yet another index to previous
> block data, increasing requirements on fullnodes.
> * Requires SCRIPT to be re-evaluated on transactions arriving in
> newblocks, to protect against reorgs of the chaintip, and in particular
> `OP_PUBREF` references to near the chaintip.
>
> None of these issues have been addressed in your current proposal.
> The proposal looks at clients only, without considering what validators
> have to implement in order to validate new blocks with this opcode.
>
> Regards,
> ZmnSCPxj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200801/39c1cb94/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: Floating-Point Nakamoto Consensus.pdf
Type: application/pdf
Size: 70769 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200801/39c1cb94/attachment-0001.pdf>

From ZmnSCPxj at protonmail.com  Sun Aug  2 14:22:30 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sun, 02 Aug 2020 14:22:30 +0000
Subject: [bitcoin-dev] Smaller Transactions with PubRef
In-Reply-To: <CALFqKjSrQ260XfYtdvd9N=ZKZvJqE2iz+reGtBNpq++br9S1ig@mail.gmail.com>
References: <CALFqKjTDcsD4xpc-TryTRCNnCJivyqkU9dv0ff2emP5kxZF1bA@mail.gmail.com>
 <1cxOISncF4dES_Ijm5FJUhwUAzBupnLPiv3qnU20as76zMMhVyggkg1hphq4ehuqEFK_H88TBbfI2pKbLWzzx7E6kOUXeC-yOcfrOkg3uAY=@protonmail.com>
 <CALFqKjSrQ260XfYtdvd9N=ZKZvJqE2iz+reGtBNpq++br9S1ig@mail.gmail.com>
Message-ID: <-vfdrKtX7fPIncbPlX7CkHYD0NjZDz6VUjlkUrCO-feq3zaQpXRl8Wu_HP7CRXm1sc_p0B0IZjnTxiHfz_saXWL5W6ax9CVnddaDfPQvTBE=@protonmail.com>

Good morning Mike,

The issue with SCRIPT re-evaluation is that reorgs cause more processing to be done by nodes.

Floating-point Nakamoto Consensus does not help here, since a node can receive the lower-scored block first, and *then* a higher-scored block, and thus will ***still*** observe a reorg since the chain tip is replaced with a higher-scored block later.

This still increases the processing load on validating fullnodes, and prevents any kind of pruning from working for validating fullnodes.

A miner can also still mount a DoS on validating fullnodes, with `OP_PUBREF` and Floating-Point Nakamoto Consensus by re-mining the same block, and broadcasting a block if it has higher score than the previous chain tip.
This locks the blockchain ***and*** increases the load on fullnodes, which have to re-validate uses of `OP_PUBREF` that might refer to the chain tip.

Regards,
ZmnSCPxj

> Hey? ZmnSCPxj,
>
> Re-orgs should be solved in a different?way.?
>
> Best Regards,
> Micahel
>
> On Sat, Aug 1, 2020 at 5:36 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>
> > Good morning Mike,
> >
> > Hard NAK.
> >
> > The responses to the original posting already pointed out important problems with this:
> >
> > * Encourages address reuse, hurting fungibility and privacy.
> > * Prevents pruning, since access to previous blocks must always be available in order to validate.
> > * Optimized implementation requires creating yet another index to previous block data, increasing requirements on fullnodes.
> > * Requires SCRIPT to be re-evaluated on transactions arriving in? newblocks, to protect against reorgs of the chaintip, and in particular `OP_PUBREF` references to near the chaintip.
> >
> > None of these issues have been addressed in your current proposal.
> > The proposal looks at clients only, without considering what validators have to implement in order to validate new blocks with this opcode.
> >
> > Regards,
> > ZmnSCPxj



From rich at gotenna.com  Mon Aug  3 19:27:13 2020
From: rich at gotenna.com (Richard Myers)
Date: Mon, 3 Aug 2020 21:27:13 +0200
Subject: [bitcoin-dev] BIP 118 and SIGHASH_ANYPREVOUT
In-Reply-To: <O_Zr7tM2TYwJdFS0o9RraXrtRPI4ZcVU65qcBpg-tvTPOqnGWkEUDQY5XqcihbUyAHF31L4isFWsD_u2SsSb8YzfjYDWiVXQsr6oAd9YXBY=@protonmail.com>
References: <20200709214048.27mycsi5h2bnv3cc@erisian.com.au>
 <O_Zr7tM2TYwJdFS0o9RraXrtRPI4ZcVU65qcBpg-tvTPOqnGWkEUDQY5XqcihbUyAHF31L4isFWsD_u2SsSb8YzfjYDWiVXQsr6oAd9YXBY=@protonmail.com>
Message-ID: <CACJVCgL+Ap9VBsDQp+KEuwhAkPZ1c0ACBRjHnB_qk-hi8_Uq7Q@mail.gmail.com>

Thanks AJ for the updated BIP - very exciting!

I'm also interested in this in the context of a Taproot version of
Decker-Russell-Osuntokun (eltoo). Thanks ZmnSCPxj for summarizing your
thoughts on how this would work. I have had some difficulty understanding
when someone might want to use ANYPREVOUT vs. ANYPREVOUTANYSCRIPT and this
is a clever demonstration of how the differences can be exploited.

I sketched out the protocol you described to help my understand it (below)
and some questions came to mind:

1) If you do a collaborative close, would you need to use script-path
spending, or could you use key-path spending instead to improve privacy?

2) You mention 1.5 round trips for the (two party) MuSig signing session.
Must there be separate 1.5 round trips for each of the two signatures
produced (update, settlement) for each state update?

3) A related question: can the 1.5 round trips for signing be combined with
the 1.5 round trips required to update the channel (ie. A signs settlement
tx, B signs settlement & update txs, A signs update tx)?

Perhaps something like this:
 -> A provides partial signature for settlement tx
 <- B provides complete signature for settlement tx and partial signature
for update tx
 -> A provides complete signature for update tx

4) I'm not sure why AJ's formulation included an addition sig(X), but
otherwise is it similar to what you're suggesting?

https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-May/001996.html

All the best,

  -- Richard

------- my interpretation of your scheme ----


  [Fund Channel]
    |
    |
    |
    v
   P=Musig(A,B)+scripts (Taproot internal key, aka script path key?)
   Q=Musig(A,B) (Taproot output key, aka root key?)

   OR ----------- [Cooperative Close]
   |||            Sig(Q) -----+
   |||                        |----> Sig(A)...
   |||                        |
   |||                        |----> Sig(B)...
   |||
   |||
   ||+-->[Update(n)]
   ||    nlocktime/state > n
   ||    Sig(P)+ANYPREVOUTANYSCRIPT
   ||
   ||     OR ---------->[Settle(n)]           [Uncooperative Close @
state n]
   ||      |            Sig(P)+ANYPREVOUT
   ||      |            csv [delay] --------+---> Sig(A)...    [HTLCs
& Settled
   ||      |                                |
Outputs ]
   ||      |                                |---> Sig(B)...
   ||      v
   |+---->[Update(n+1)]
   |      nlocktime/state > n+1
   |      Sig(P)+ANYPREVOUTANYSCRIPT
   |
   |      OR ----------->[Settle(n+1)]        [Uncooperative Close @
state n+1]
   |       |             Sig(P)+ANYPREVOUT
   |       |             csv [delay] -------+---> Sig(A)...    [HTLCs
& Settled
   |       |                                |
Outputs ]
   v       v                                |---> Sig(B)...





On Fri, Jul 10, 2020 at 5:30 AM ZmnSCPxj via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:

...

> Slightly off-topic, but I suppose a Decker-Russell-Osuntokun construction
> could, in theory, have only a single internal taproot pubkey, `P = MuSig(A,
> B)` for a channel between A and B.
>
> So the funding outpoint would be spent with a taprooted P + a single
> tapscript `<1> OP_CHECKSIG`.
>
> Update transactions would be signed with the internal taproot pubkey using
> `SIGHASH_ANYPREVOUTANYSCRIPT`.
> The update transaction output would be spendable with a taprooted P + a
> single tapscript `<index + 1> OP_CHECKLOCKTIMEVERIFY OP_DROP <1>
> OP_CHECKSIG`.
> Each update transaction would have a monotonically-increasing `nLockTime`,
> i.e. the above `index`.
>
> Then a state transaction would be signed with the internal taproot pubkey
> using `SIGHASH_ANYPREVOUT`, which commits to the exact script including
> `<index + 1>`, which is unique for each update transaction.
> Thus a state transaction can only spend the specific update transaction,
> but the update transaction can spend the funding outpoint or any update
> transaction outpoint.
> State transaction input would have an `nSequence` requiring a relative
> locktime of the agreed-upon unilateral close delay.
>
> The above assumes MuSig signing, which requires 1.5 round trips for a
> channel, or three broadcast rounds for a multiparticipant (n >= 3)
> construction.
>
>
> Regards,
> ZmnSCPxj
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200803/fadaa364/attachment.html>

From roconnor at blockstream.com  Mon Aug  3 22:49:10 2020
From: roconnor at blockstream.com (Russell O'Connor)
Date: Mon, 3 Aug 2020 18:49:10 -0400
Subject: [bitcoin-dev] On the compatibility of Bech32 and Shamir's Secret
	Sharing
In-Reply-To: <CAMZUoKnNK-_shu4BQXK=FbtqYUn8MT=yjNDY1VFx73AAcSAzsQ@mail.gmail.com>
References: <CAEcfjBRCA1sKcFC5M++WECsgYD-jDBYGuwxLfh0PSzRkCehEDA@mail.gmail.com>
 <CAD5xwhgP=9-AvMOVO+-b9c3DZ_vYd-bPLYM26Qvawmcj28UOZw@mail.gmail.com>
 <CAMZUoKnNK-_shu4BQXK=FbtqYUn8MT=yjNDY1VFx73AAcSAzsQ@mail.gmail.com>
Message-ID: <CAMZUoKnA4cMTDYnvcUQo9N+1T9pZCjGg4WGbFgaox4BaXao2QA@mail.gmail.com>

With the help of Pieter I've recently made some interesting mathematical
observations about Bech32 codewords and Shamir's secret sharing:

(1) Affine combinations of two Bech32 codewords is again a valid Bech32
codeword.
(2) Lagrange polynomials form a partition of unity.

The consequences of these facts is that when you perform Shamir's secret
sharing where all your shares have valid Bech32 checksums, then the
resulting secret will also have a valid Bech32 checksum.  Conversely, if
your secret has a valid Bech32 checksum, and your random shares have valid
Bech32 checksums, then all your derived shares will have valid Bech32
checksums.  This can form a basis on which we can build a simple secret
sharing scheme for dividing up a BIP-32 master seed.

In order to illustrate this, I'll describe an example scheme for *k*-of-*n*
Shamir's secret sharing scheme where *2 <= k* <= *n* <= 31.

Suppose we have a 128-bit master seed 0xb6721d937d82f238672de4db91b87d0c.
We encode this secret as the following Bech32 codeword: "
donotusesss321s2name00keepmymasterseedunderwraps2n89wr".  Let's deconstruct
this codeword.

"donotusesss32": A Bech32 hrp for this example scheme.
"1": The Bech32 separator.
"s": The first data character is the index of this share. Each index is a
Bech32 character.  In this scheme the secret share is always at index "s",
which stands for "secret".
"2": The second data character is the threshold.  In this example we are
using a 2-of-n threshold.  We use the digits 2-9 for thresholds upto 9.  We
use Bech32 characters a-y for thresholds from 10 to 31.
"name00": The next 6 characters are an id for this set of shares.  This id
isn't part of the secret data. It is used to ensure that the shares you are
reconstructing were generated for the same secret.  This id just needs to
be unique for all the secrets that you are dividing up with this scheme.
The id can be chosen randomly, sequentially, or even set to the constant
such as "qqqqqq" if you do not want to use it for identification.
"keepmymasterseedunderwraps": This is the 128-bit secret master seed
0xb6721d937d82f238672de4db91b87d0c encoded in Bech32.  The master seed can
be a 128-bit, 256-bit or 512-bit value.
"2n89wr" is the Bech32 checksum.

We will generate shares for a 2-of-3 threshold.  We generate the first
share at index "a".  In this example we generate "
donotusesss321a2name00q0h5aajczn04g9sh0wtsl2f0y0g3vlkr".

"donotusesss32": The Bech32 hrp for this example scheme.
"1": The Bech32 separator.
"a": The first data character is the index of this share which we have
chosen to be "a".
"2": The second data character is the threshold, which is 2.
"name00": The next 6 characters is the id we chose above for this set of
shares.
"q0h5aajczn04g9sh0wtsl2f0y0": This is 26 randomly selected bech32 characters
"g3vlkr" is the Bech32 checksum.

We generated the next two shares at index "c" and and index "d".  These
shares are generated using characterwise Lagrange interpolation of the
secret share and the above randomly generated share.
The resulting shares are "
donotusesss321c2name00chzu58ep57hd9xmaw6zmuyjeau0kq4mr" and "
donotusesss321d2name00ung8rmkf2snftj57zu45g7z84hzmzk4r"

Notice that the resulting strings have
(1) valid checksums;
(2) have correct indices;
(3) have the correct threshold values;
(4) have the correct ids.

This scheme still enjoys the perfect information hiding property of
Shamir's secret sharing.  Even when you know *k*-1 shares, every possible
master seed value has exactly one set of shares that includes those
particular *k*-1 shares, so knowing *k*-1 shares tells you nothing about
the secret data value.

One nice property of Lagrange interpolation is that it is simple enough to
compute by hand with the help of a few lookup tables.  Bech32 checksums can
also be computed and checked by hand with the help of lookup tables.  While
the majority of users wouldn't do hand computations, those motivated users
who have a healthy distrust of digital devices can generate and manipulate
the secret shares by hand.  The Bech32 checksum property means that after
generating the shares by hand, you can then validate the checksums by hand.
With extremely high probability, you will catch any computation error you
make.  My SSS32 repository at https://github.com/roconnor-blockstream/SSS32
has a postscript file that generates the lookup tables needed for hand
computation, although the document is a bit disorganized at the moment.

The main deficiency of the scheme presented here is that we want a longer
checksum than used in BIP-173 that is more suitable for error correction,
rather than simply error detection.

This example scheme was inspired in part by SLIP-32
<https://github.com/satoshilabs/slips/blob/master/slip-0032.md> with the
intent to be a hand computable version of the same idea.

P.S. It is possible that this all could be made obsolete by a threshold
musig signature scheme.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200803/67e64b4d/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Tue Aug  4 01:38:55 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 04 Aug 2020 01:38:55 +0000
Subject: [bitcoin-dev] BIP 118 and SIGHASH_ANYPREVOUT
In-Reply-To: <CACJVCgL+Ap9VBsDQp+KEuwhAkPZ1c0ACBRjHnB_qk-hi8_Uq7Q@mail.gmail.com>
References: <20200709214048.27mycsi5h2bnv3cc@erisian.com.au>
 <O_Zr7tM2TYwJdFS0o9RraXrtRPI4ZcVU65qcBpg-tvTPOqnGWkEUDQY5XqcihbUyAHF31L4isFWsD_u2SsSb8YzfjYDWiVXQsr6oAd9YXBY=@protonmail.com>
 <CACJVCgL+Ap9VBsDQp+KEuwhAkPZ1c0ACBRjHnB_qk-hi8_Uq7Q@mail.gmail.com>
Message-ID: <E0LvOEKdi7T-mG9yh9bnDXtsZGX1Ui269zQ5ydg4ws-HZtZ65stYLCc5G0tBjj3XnmCS0uEAxGcGweEoF5KllGClMpuKC8uQiIHfd6MYNQE=@protonmail.com>

Good morning Richard,

> Thanks AJ for the updated BIP - very exciting!
>
> I'm also interested in this in the context of a Taproot version of Decker-Russell-Osuntokun (eltoo).?Thanks ZmnSCPxj for summarizing your thoughts on how this would work. I have had some difficulty understanding when someone might want to use ANYPREVOUT vs. ANYPREVOUTANYSCRIPT and this is a clever demonstration of how the?differences can be exploited.
>
> I sketched out the protocol you described to help my understand it (below) and some questions came to mind:
>
> 1) If you do a collaborative close, would you need to use script-path spending, or could you use key-path spending instead to improve privacy?

It can (and should) use key-path, yes.

>
> 2) You mention 1.5 round trips for the (two party) MuSig signing session. Must there be separate 1.5 round trips for each of the two signatures produced (update, settlement) for each state update?

I believe we can amortize this slightly by providing the `R` commitments for the *next* signing session with the `s` for the *current* signing session, reducing to 1.0 round trips.

However, I believe a provably-safe 2-round MuSig (with composable MuSig even!) is being worked on and should be released in a week or two, and if it is safe to provide the first round of the *next* session with the final round of the *current* session then we could reduce it to just one (large) message send per update.

>
> 3) A related question: can the 1.5 round trips for signing be combined with the 1.5 round trips required to update the channel (ie. A signs settlement tx, B signs settlement & update txs, A signs update tx)??
>
> Perhaps something like this:
> ?-> A provides partial signature for settlement tx
> ?<- B provides complete signature for settlement tx and partial signature for update tx
> ?-> A provides complete signature for update tx

My understanding (which might be incorrect!) is that it should be safe to perform the signing sessions for the settlement and update txes simultaneously, i.e.

* round 1: send `R` commitments for both update and settlement tx (can be sent with round 3 of previous signing session).
* round 2: send `R` for both update and settlement tx.
* round 3: send `s` for both update and settlement tx.

Depending on how we do the HTLCs / PTLCs, we might also need to send signatures for all HTLCs, in parallel with the update+settlement tx signatures, as well.

> 4) I'm not sure why AJ's formulation included an addition sig(X), but otherwise is it similar to what you're suggesting?
> ??https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-May/001996.html

This might have been the "chaperone signatures" proposed for `SIGHASH_NOINPUT` / `SIGHASH_ANYPREVOUT` back then.
This was supposed to protect against replaying a `SIGHASH_ANYPREVOUT` signature in case of address reuse.
I pointed out that it would be much simpler for a Lightning spec to provide a privkey for a common `X` used by all Lightning nodes, and thus would not really provide much better security in practice.


I believe what we intend now is a form of hidden output tagging to protect against signature replay.
An output has to have a special taproot version in order to be spent with `SIGHASH_ANYPREVOUT` or `SIGHASH_ANYPREVOUTANYSCRIPT` in the script path, and `SIGHASH_ANYPREVOUT`/`SIGHASH_ANYPREVOUTANYSCRIPT` is not usable with key path spends.


Regards,
ZmnSCPxj

From lf-lists at mattcorallo.com  Tue Aug  4 04:02:21 2020
From: lf-lists at mattcorallo.com (lf-lists at mattcorallo.com)
Date: Tue, 4 Aug 2020 00:02:21 -0400
Subject: [bitcoin-dev] BIP 118 and SIGHASH_ANYPREVOUT
In-Reply-To: <20200709214048.27mycsi5h2bnv3cc@erisian.com.au>
References: <20200709214048.27mycsi5h2bnv3cc@erisian.com.au>
Message-ID: <4AFF2D6A-57BE-40CF-A15F-E972AEB9ACDE@mattcorallo.com>

While I admit I haven?t analyzed the feasibility, I want to throw one additional design consideration into the ring.

Namely, it would ideally be trivial, at the p2p protocol layer, to relay a transaction to a full node without knowing exactly which input transaction that full node has in its mempool/active chain. This is at least potentially important for systems like lighting where you do not know which counterparty commitment transaction(s) are in a random node?s mempool and you should be able to describe to that node that you are spending then nonetheless.

This is (obviously) an incredibly nontrivial problem both in p2p protocol complexity and mempool optimization, but it may leave SIGHASH_NOINPUT rather useless for lighting without it.

The least we could do is think about the consensus design in that context, even if we have to provide an external overlay relay network in order to make lighting transactions relay properly (presumably with miners running such software).

Matt

> On Jul 9, 2020, at 17:46, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> ?Hello world,
> 
> After talking with Christina ages ago, we came to the conclusion that
> it made more sense to update BIP 118 to the latest thinking than have
> a new BIP number, so I've (finally) opened a (draft) PR to update BIP
> 118 with the ANYPREVOUT bip I've passed around to a few people,
> 
> https://github.com/bitcoin/bips/pull/943
> 
> Probably easiest to just read the new BIP text on github:
> 
> https://github.com/ajtowns/bips/blob/bip-anyprevout/bip-0118.mediawiki
> 
> It doesn't come with tested code at this point, but I figure better to
> have the text available for discussion than nothing.
> 
> Some significant changes since previous discussion include complete lack
> of chaperone signatures or anything like it (if you want them, you can
> always add them yourself, of course), and that ANYPREVOUTANYSCRIPT no
> longer commits to the value (details/rationale in the text).
> 
> Cheers,
> aj
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From ZmnSCPxj at protonmail.com  Tue Aug  4 04:23:03 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 04 Aug 2020 04:23:03 +0000
Subject: [bitcoin-dev] BIP 118 and SIGHASH_ANYPREVOUT
In-Reply-To: <4AFF2D6A-57BE-40CF-A15F-E972AEB9ACDE@mattcorallo.com>
References: <20200709214048.27mycsi5h2bnv3cc@erisian.com.au>
 <4AFF2D6A-57BE-40CF-A15F-E972AEB9ACDE@mattcorallo.com>
Message-ID: <i9rsIn-lslFVgi9AZzyuLvD8sPJqibqSF0loi80tg0cQcGKW9Ccfvo-KSIQjhI7NvWCz8Bm5vTdiC1-TbWAf7s4QCabh6Kca4I6iBftpLQ0=@protonmail.com>

Good morning Matt,

> While I admit I haven?t analyzed the feasibility, I want to throw one additional design consideration into the ring.
>
> Namely, it would ideally be trivial, at the p2p protocol layer, to relay a transaction to a full node without knowing exactly which input transaction that full node has in its mempool/active chain. This is at least potentially important for systems like lighting where you do not know which counterparty commitment transaction(s) are in a random node?s mempool and you should be able to describe to that node that you are spending then nonetheless.
>
> This is (obviously) an incredibly nontrivial problem both in p2p protocol complexity and mempool optimization, but it may leave SIGHASH_NOINPUT rather useless for lighting without it.
>
> The least we could do is think about the consensus design in that context, even if we have to provide an external overlay relay network in order to make lighting transactions relay properly (presumably with miners running such software).

Ah, right.

A feasible attack, without the above, would be to connect to the fullnode of the victim, and connect to miners separately.
Then you broadcast to the victim one of the old txes, call it tx A, but you broadcast to the miners a *different* old tx, call it B.
The victim reacts only to tA, but does not react to B since it does not see B in the mempool.

On the other hand --- what the victim needs to react to is *onchain* confirmed transactions.
So I think all the victim needs to do, in a Lightning universe utilizing primarily `SIGHASH_NOINPUT`-based mechanisms, is to monitor onchain events and ignore mempool events.

So if we give fairly long timeouts for our mechanisms, it should be enough, I think, since once a transaction is confirmed its txid does not malleate without a reorg and a `SIGHASH_NOINPUT` signature can then be "locked" to that txid, unless a reorg unconfirms the transaction.
We only need to be aware of deep reorgs and re-broadcast with a malleated prevout until the tx being spent is deeply confirmed.

In addition, we want to implement scorch-the-earth, keep-bumping-the-fee strategies anyway, so we would keep rebroadcasting new versions of the spending transaction, and spending from a transaction that is confirmed.

Or are there other attack vectors you can see that I do not?
I think this is fixed by looking at the blockchain.

Regards,
ZmnSCPxj

From decker.christian at gmail.com  Tue Aug  4 10:38:20 2020
From: decker.christian at gmail.com (Christian Decker)
Date: Tue, 04 Aug 2020 12:38:20 +0200
Subject: [bitcoin-dev] BIP 118 and SIGHASH_ANYPREVOUT
In-Reply-To: <i9rsIn-lslFVgi9AZzyuLvD8sPJqibqSF0loi80tg0cQcGKW9Ccfvo-KSIQjhI7NvWCz8Bm5vTdiC1-TbWAf7s4QCabh6Kca4I6iBftpLQ0=@protonmail.com>
References: <20200709214048.27mycsi5h2bnv3cc@erisian.com.au>
 <4AFF2D6A-57BE-40CF-A15F-E972AEB9ACDE@mattcorallo.com>
 <i9rsIn-lslFVgi9AZzyuLvD8sPJqibqSF0loi80tg0cQcGKW9Ccfvo-KSIQjhI7NvWCz8Bm5vTdiC1-TbWAf7s4QCabh6Kca4I6iBftpLQ0=@protonmail.com>
Message-ID: <87zh7ay9ur.fsf@gmail.com>

> Ah, right.
>
> A feasible attack, without the above, would be to connect to the
> fullnode of the victim, and connect to miners separately.  Then you
> broadcast to the victim one of the old txes, call it tx A, but you
> broadcast to the miners a *different* old tx, call it B.  The victim
> reacts only to tA, but does not react to B since it does not see B in
> the mempool.
>
> On the other hand --- what the victim needs to react to is *onchain*
> confirmed transactions.  So I think all the victim needs to do, in a
> Lightning universe utilizing primarily `SIGHASH_NOINPUT`-based
> mechanisms, is to monitor onchain events and ignore mempool events.
>
> So if we give fairly long timeouts for our mechanisms, it should be
> enough, I think, since once a transaction is confirmed its txid does
> not malleate without a reorg and a `SIGHASH_NOINPUT` signature can
> then be "locked" to that txid, unless a reorg unconfirms the
> transaction.  We only need to be aware of deep reorgs and re-broadcast
> with a malleated prevout until the tx being spent is deeply confirmed.

This is indeed part of the reason why we chose to describe the protocol
on-chain first in the paper and lift it off-chain after showing the
basic functionality. This means that the protocol is still correct even
if executed solely on information derived from blocks and confirmed
transactions in those blocks. The timeouts have to be chosen carefully
to allow reacting in a timely fashion, however that is true for all
off-chain protocols.

> In addition, we want to implement scorch-the-earth,
> keep-bumping-the-fee strategies anyway, so we would keep
> rebroadcasting new versions of the spending transaction, and spending
> from a transaction that is confirmed.

Correct, it might be desirable to give a misbehaving node a papercut by
letting their update transaction confirm (taking their fee along with
it) and then reacting to the outdated update by overriding the effects
with a new update-settlement pair.

So, while being able to react to a transaction in the memory pool early
might be a nice addition, it is not strictly required for safety of the
protocol. I say nice addition, because it can allow replacing the
outdated transaction directly, thus saving the misbehaving node from the
fee papercut, but also save a bit of blockspace which that fee would
have paid for, and leave it available for other transactions.

Cheers,
Christian

From lf-lists at mattcorallo.com  Tue Aug  4 13:10:02 2020
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Tue, 4 Aug 2020 09:10:02 -0400
Subject: [bitcoin-dev] BIP 118 and SIGHASH_ANYPREVOUT
In-Reply-To: <i9rsIn-lslFVgi9AZzyuLvD8sPJqibqSF0loi80tg0cQcGKW9Ccfvo-KSIQjhI7NvWCz8Bm5vTdiC1-TbWAf7s4QCabh6Kca4I6iBftpLQ0=@protonmail.com>
References: <i9rsIn-lslFVgi9AZzyuLvD8sPJqibqSF0loi80tg0cQcGKW9Ccfvo-KSIQjhI7NvWCz8Bm5vTdiC1-TbWAf7s4QCabh6Kca4I6iBftpLQ0=@protonmail.com>
Message-ID: <735E5B6A-785E-408B-8658-FA36200923C7@mattcorallo.com>

Hmm, apologies that little context was provided - this was meant in the context of the current crop of relay-based attacks that have been discovered. As we learned in those contexts, ?just handle it when it confirms? doesn?t provide the types of guarantees we were hoping for as placing commitment transactions in mempools can be used to prevent honest nodes from broadcasting the latest state. This implies that HTLC security may be at risk.

> On Aug 4, 2020, at 00:23, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
> 
> ?Good morning Matt,
> 
>> While I admit I haven?t analyzed the feasibility, I want to throw one additional design consideration into the ring.
>> 
>> Namely, it would ideally be trivial, at the p2p protocol layer, to relay a transaction to a full node without knowing exactly which input transaction that full node has in its mempool/active chain. This is at least potentially important for systems like lighting where you do not know which counterparty commitment transaction(s) are in a random node?s mempool and you should be able to describe to that node that you are spending then nonetheless.
>> 
>> This is (obviously) an incredibly nontrivial problem both in p2p protocol complexity and mempool optimization, but it may leave SIGHASH_NOINPUT rather useless for lighting without it.
>> 
>> The least we could do is think about the consensus design in that context, even if we have to provide an external overlay relay network in order to make lighting transactions relay properly (presumably with miners running such software).
> 
> Ah, right.
> 
> A feasible attack, without the above, would be to connect to the fullnode of the victim, and connect to miners separately.
> Then you broadcast to the victim one of the old txes, call it tx A, but you broadcast to the miners a *different* old tx, call it B.
> The victim reacts only to tA, but does not react to B since it does not see B in the mempool.
> 
> On the other hand --- what the victim needs to react to is *onchain* confirmed transactions.
> So I think all the victim needs to do, in a Lightning universe utilizing primarily `SIGHASH_NOINPUT`-based mechanisms, is to monitor onchain events and ignore mempool events.
> 
> So if we give fairly long timeouts for our mechanisms, it should be enough, I think, since once a transaction is confirmed its txid does not malleate without a reorg and a `SIGHASH_NOINPUT` signature can then be "locked" to that txid, unless a reorg unconfirms the transaction.
> We only need to be aware of deep reorgs and re-broadcast with a malleated prevout until the tx being spent is deeply confirmed.
> 
> In addition, we want to implement scorch-the-earth, keep-bumping-the-fee strategies anyway, so we would keep rebroadcasting new versions of the spending transaction, and spending from a transaction that is confirmed.
> 
> Or are there other attack vectors you can see that I do not?
> I think this is fixed by looking at the blockchain.
> 
> Regards,
> ZmnSCPxj

From ZmnSCPxj at protonmail.com  Tue Aug  4 14:59:52 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 04 Aug 2020 14:59:52 +0000
Subject: [bitcoin-dev] BIP 118 and SIGHASH_ANYPREVOUT
In-Reply-To: <735E5B6A-785E-408B-8658-FA36200923C7@mattcorallo.com>
References: <i9rsIn-lslFVgi9AZzyuLvD8sPJqibqSF0loi80tg0cQcGKW9Ccfvo-KSIQjhI7NvWCz8Bm5vTdiC1-TbWAf7s4QCabh6Kca4I6iBftpLQ0=@protonmail.com>
 <735E5B6A-785E-408B-8658-FA36200923C7@mattcorallo.com>
Message-ID: <KSfad5I1vkw0QoInOkoVtxk9Sw6ypolsQu6TwMd_Y9CzaQsLTElk14434R3Rc2gwC88oAfiH3cITp4do0gtSKknUUBfrmbRKGeYW0ldeevU=@protonmail.com>

Good morning Matt,

> Hmm, apologies that little context was provided - this was meant in the context of the current crop of relay-based attacks that have been discovered. As we learned in those contexts, ?just handle it when it confirms? doesn?t provide the types of guarantees we were hoping for as placing commitment transactions in mempools can be used to prevent honest nodes from broadcasting the latest state. This implies that HTLC security may be at risk.
>

Ah, okay.

So the attack is this:

* Attacker connects twice to the LN: one to any node near the victim, one to the victim.
* Attacker arranges for the attacker-victim channel to have most funds in the side of the victim.
* The attacker routes a circular payment terminating in the victim-attacker channel.
  * The victim accepts some incoming HTLC, and provides an outgoing HTLC to the attacker via the victim-attacker channel.
* The attacker broadcasts a very low-fee old-state transaction of the victim-attacker channel, one that is too low-fee to practically get confirmed, just before the HTLC timeout.
* The victim-outgoing HTLC times out, making the victim broadcast a unilateral close attempt for the victim-attacker channel in order to enforce the HTLC onchain.
  * Unfortunately for the victim, relay shenanigans prevent the latest commitment from being broadcast.
* The attacker waits for the victim-incoming HTLC to timeout, which forces the victim to `update_htlc_failed` the incoming HTLC or risk having that channel closed (and losing future routing fees).
  * The attacker now gets back its outgoing funds.
* The attacker lets the old-state transaction get relayed, and then re-seats the latest update transaction to that.
* Once the latest transaction allows the HTLCs to be published, the attacker claims the victim-outgoing HTLC with the hashlock branch.
  * The attacker now gets its incoming funds, doubling its money, because that is how the "send me 1 BTC I send you 2 BTC back" Twitter thing works right?

Hmmm.

The only thing I can imagine helping here is for the forwarding node to drop channels onchain "early", i.e. if the HTLC will time out in say 14 blocks we drop the channel onchain, so we have a little leeway in bumping up fees for the commitment transaction.
Maybe.
I am sure Matt can find yet another relay attack that prevents that, at this point, haha.

"Are we *still* talking about onchain fees....?" - Adelaide 2018

Regards,
ZmnSCPxj




> > On Aug 4, 2020, at 00:23, ZmnSCPxj ZmnSCPxj at protonmail.com wrote:
> > Good morning Matt,
> >
> > > While I admit I haven?t analyzed the feasibility, I want to throw one additional design consideration into the ring.
> > > Namely, it would ideally be trivial, at the p2p protocol layer, to relay a transaction to a full node without knowing exactly which input transaction that full node has in its mempool/active chain. This is at least potentially important for systems like lighting where you do not know which counterparty commitment transaction(s) are in a random node?s mempool and you should be able to describe to that node that you are spending then nonetheless.
> > > This is (obviously) an incredibly nontrivial problem both in p2p protocol complexity and mempool optimization, but it may leave SIGHASH_NOINPUT rather useless for lighting without it.
> > > The least we could do is think about the consensus design in that context, even if we have to provide an external overlay relay network in order to make lighting transactions relay properly (presumably with miners running such software).
> >
> > Ah, right.
> > A feasible attack, without the above, would be to connect to the fullnode of the victim, and connect to miners separately.
> > Then you broadcast to the victim one of the old txes, call it tx A, but you broadcast to the miners a different old tx, call it B.
> > The victim reacts only to tA, but does not react to B since it does not see B in the mempool.
> > On the other hand --- what the victim needs to react to is onchain confirmed transactions.
> > So I think all the victim needs to do, in a Lightning universe utilizing primarily `SIGHASH_NOINPUT`-based mechanisms, is to monitor onchain events and ignore mempool events.
> > So if we give fairly long timeouts for our mechanisms, it should be enough, I think, since once a transaction is confirmed its txid does not malleate without a reorg and a `SIGHASH_NOINPUT` signature can then be "locked" to that txid, unless a reorg unconfirms the transaction.
> > We only need to be aware of deep reorgs and re-broadcast with a malleated prevout until the tx being spent is deeply confirmed.
> > In addition, we want to implement scorch-the-earth, keep-bumping-the-fee strategies anyway, so we would keep rebroadcasting new versions of the spending transaction, and spending from a transaction that is confirmed.
> > Or are there other attack vectors you can see that I do not?
> > I think this is fixed by looking at the blockchain.
> > Regards,
> > ZmnSCPxj



From lf-lists at mattcorallo.com  Thu Aug  6 15:58:53 2020
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Thu, 6 Aug 2020 11:58:53 -0400
Subject: [bitcoin-dev] BIP 118 and SIGHASH_ANYPREVOUT
In-Reply-To: <KSfad5I1vkw0QoInOkoVtxk9Sw6ypolsQu6TwMd_Y9CzaQsLTElk14434R3Rc2gwC88oAfiH3cITp4do0gtSKknUUBfrmbRKGeYW0ldeevU=@protonmail.com>
References: <i9rsIn-lslFVgi9AZzyuLvD8sPJqibqSF0loi80tg0cQcGKW9Ccfvo-KSIQjhI7NvWCz8Bm5vTdiC1-TbWAf7s4QCabh6Kca4I6iBftpLQ0=@protonmail.com>
 <735E5B6A-785E-408B-8658-FA36200923C7@mattcorallo.com>
 <KSfad5I1vkw0QoInOkoVtxk9Sw6ypolsQu6TwMd_Y9CzaQsLTElk14434R3Rc2gwC88oAfiH3cITp4do0gtSKknUUBfrmbRKGeYW0ldeevU=@protonmail.com>
Message-ID: <94bb2092-6d53-0e46-45ac-a1f8e04dafba@mattcorallo.com>

Yep! That is the attack I had in mind - just in general any time you have a non-relative time limit (ie an HTLC) for
confirmation, relay attacks become critical and its no longer just about revocation (which is fine when your time limit
is CSV-based).

In general, SIGHASH_NOINPUT makes these issues much, much simpler to address, but only if we assume that nodes can
somehow be "smart" about replacement when they see a SIGHASH_NOINPUT spend which can spend an output that something else
in the mempool already spends (potentially a different input than the relaying node thinks the transaction should
spend). While ideally we'd be able to shove that (significant) complexity into the Bitcoin P2P network, that may not be
feasible, but we could imagine a relay network of lightning nodes doing that calculation and then passing the
transactions to their local full nodes.

Given such an overlay network would represent an increase in local mempool fees, it is not unreasonable to expect at
least some miners to run a local node which can submit such transactions to their template-generating nodes.

Matt

On 8/4/20 10:59 AM, ZmnSCPxj wrote:
> Good morning Matt,
> 
>> Hmm, apologies that little context was provided - this was meant in the context of the current crop of relay-based attacks that have been discovered. As we learned in those contexts, ?just handle it when it confirms? doesn?t provide the types of guarantees we were hoping for as placing commitment transactions in mempools can be used to prevent honest nodes from broadcasting the latest state. This implies that HTLC security may be at risk.
>>
> 
> Ah, okay.
> 
> So the attack is this:
> 
> * Attacker connects twice to the LN: one to any node near the victim, one to the victim.
> * Attacker arranges for the attacker-victim channel to have most funds in the side of the victim.
> * The attacker routes a circular payment terminating in the victim-attacker channel.
>   * The victim accepts some incoming HTLC, and provides an outgoing HTLC to the attacker via the victim-attacker channel.
> * The attacker broadcasts a very low-fee old-state transaction of the victim-attacker channel, one that is too low-fee to practically get confirmed, just before the HTLC timeout.
> * The victim-outgoing HTLC times out, making the victim broadcast a unilateral close attempt for the victim-attacker channel in order to enforce the HTLC onchain.
>   * Unfortunately for the victim, relay shenanigans prevent the latest commitment from being broadcast.
> * The attacker waits for the victim-incoming HTLC to timeout, which forces the victim to `update_htlc_failed` the incoming HTLC or risk having that channel closed (and losing future routing fees).
>   * The attacker now gets back its outgoing funds.
> * The attacker lets the old-state transaction get relayed, and then re-seats the latest update transaction to that.
> * Once the latest transaction allows the HTLCs to be published, the attacker claims the victim-outgoing HTLC with the hashlock branch.
>   * The attacker now gets its incoming funds, doubling its money, because that is how the "send me 1 BTC I send you 2 BTC back" Twitter thing works right?
> 
> Hmmm.
> 
> The only thing I can imagine helping here is for the forwarding node to drop channels onchain "early", i.e. if the HTLC will time out in say 14 blocks we drop the channel onchain, so we have a little leeway in bumping up fees for the commitment transaction.
> Maybe.
> I am sure Matt can find yet another relay attack that prevents that, at this point, haha.
> 
> "Are we *still* talking about onchain fees....?" - Adelaide 2018
> 
> Regards,
> ZmnSCPxj
> 
> 
> 
> 
>>> On Aug 4, 2020, at 00:23, ZmnSCPxj ZmnSCPxj at protonmail.com wrote:
>>> Good morning Matt,
>>>
>>>> While I admit I haven?t analyzed the feasibility, I want to throw one additional design consideration into the ring.
>>>> Namely, it would ideally be trivial, at the p2p protocol layer, to relay a transaction to a full node without knowing exactly which input transaction that full node has in its mempool/active chain. This is at least potentially important for systems like lighting where you do not know which counterparty commitment transaction(s) are in a random node?s mempool and you should be able to describe to that node that you are spending then nonetheless.
>>>> This is (obviously) an incredibly nontrivial problem both in p2p protocol complexity and mempool optimization, but it may leave SIGHASH_NOINPUT rather useless for lighting without it.
>>>> The least we could do is think about the consensus design in that context, even if we have to provide an external overlay relay network in order to make lighting transactions relay properly (presumably with miners running such software).
>>>
>>> Ah, right.
>>> A feasible attack, without the above, would be to connect to the fullnode of the victim, and connect to miners separately.
>>> Then you broadcast to the victim one of the old txes, call it tx A, but you broadcast to the miners a different old tx, call it B.
>>> The victim reacts only to tA, but does not react to B since it does not see B in the mempool.
>>> On the other hand --- what the victim needs to react to is onchain confirmed transactions.
>>> So I think all the victim needs to do, in a Lightning universe utilizing primarily `SIGHASH_NOINPUT`-based mechanisms, is to monitor onchain events and ignore mempool events.
>>> So if we give fairly long timeouts for our mechanisms, it should be enough, I think, since once a transaction is confirmed its txid does not malleate without a reorg and a `SIGHASH_NOINPUT` signature can then be "locked" to that txid, unless a reorg unconfirms the transaction.
>>> We only need to be aware of deep reorgs and re-broadcast with a malleated prevout until the tx being spent is deeply confirmed.
>>> In addition, we want to implement scorch-the-earth, keep-bumping-the-fee strategies anyway, so we would keep rebroadcasting new versions of the spending transaction, and spending from a transaction that is confirmed.
>>> Or are there other attack vectors you can see that I do not?
>>> I think this is fixed by looking at the blockchain.
>>> Regards,
>>> ZmnSCPxj
> 
> 

From rich at gotenna.com  Fri Aug  7 15:34:43 2020
From: rich at gotenna.com (Richard Myers)
Date: Fri, 7 Aug 2020 17:34:43 +0200
Subject: [bitcoin-dev] BIP 118 and SIGHASH_ANYPREVOUT
In-Reply-To: <94bb2092-6d53-0e46-45ac-a1f8e04dafba@mattcorallo.com>
References: <i9rsIn-lslFVgi9AZzyuLvD8sPJqibqSF0loi80tg0cQcGKW9Ccfvo-KSIQjhI7NvWCz8Bm5vTdiC1-TbWAf7s4QCabh6Kca4I6iBftpLQ0=@protonmail.com>
 <735E5B6A-785E-408B-8658-FA36200923C7@mattcorallo.com>
 <KSfad5I1vkw0QoInOkoVtxk9Sw6ypolsQu6TwMd_Y9CzaQsLTElk14434R3Rc2gwC88oAfiH3cITp4do0gtSKknUUBfrmbRKGeYW0ldeevU=@protonmail.com>
 <94bb2092-6d53-0e46-45ac-a1f8e04dafba@mattcorallo.com>
Message-ID: <CACJVCgLtt=SBLeA=JWPhzU7EdbJUy2AfPTGbs-pRn0fuwGmZsQ@mail.gmail.com>

When you say that a special relay network might be more "smart about
replacement" in the context of ANYPREVOUT*, do you mean these nodes could
RBF parts of a package like this:


Given:
 - Package A = UpdateTx_A(n=1): txin: AnchorTx, txout: SettlementTx_A(n=1)
-> HtlcTxs(n=1)_A -> .chain of  transactions that pin UpdateTx_A(n=1) with
high total fee, etc.


And a new package with higher fee rate versions of ANYPREVOUT* transactions
in the package, but otherwise lower total fee:

 - Package B = UpdateTx_B(n=1): txin: AnchorTx, txout: SettlementTx_B(n=1)
-> HtlcTxs(n=1)_B -> low total fee package


Relay just the higher up-front fee-rate transactions from package B which
get spent by the high absolute fee child transactions from package A:

 - Package A' = UpdateTx_B(n=1): txin: AnchorTx, txout: SettlementTx_B(n=1)
-> HtlcTxs(n=1)_A -> ...chain of up to 25 txs that pin UpdateTx(n=1) with
high total fee, etc.

On Thu, Aug 6, 2020 at 5:59 PM Matt Corallo via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> In general, SIGHASH_NOINPUT makes these issues much, much simpler to
> address, but only if we assume that nodes can
> somehow be "smart" about replacement when they see a SIGHASH_NOINPUT spend
> which can spend an output that something else
> in the mempool already spends (potentially a different input than the
> relaying node thinks the transaction should
> spend). While ideally we'd be able to shove that (significant) complexity
> into the Bitcoin P2P network, that may not be
> feasible, but we could imagine a relay network of lightning nodes doing
> that calculation and then passing the
> transactions to their local full nodes.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200807/79ab9202/attachment.html>

From lf-lists at mattcorallo.com  Tue Aug 11 00:14:29 2020
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Mon, 10 Aug 2020 20:14:29 -0400
Subject: [bitcoin-dev] BIP 118 and SIGHASH_ANYPREVOUT
In-Reply-To: <CACJVCgLtt=SBLeA=JWPhzU7EdbJUy2AfPTGbs-pRn0fuwGmZsQ@mail.gmail.com>
References: <i9rsIn-lslFVgi9AZzyuLvD8sPJqibqSF0loi80tg0cQcGKW9Ccfvo-KSIQjhI7NvWCz8Bm5vTdiC1-TbWAf7s4QCabh6Kca4I6iBftpLQ0=@protonmail.com>
 <735E5B6A-785E-408B-8658-FA36200923C7@mattcorallo.com>
 <KSfad5I1vkw0QoInOkoVtxk9Sw6ypolsQu6TwMd_Y9CzaQsLTElk14434R3Rc2gwC88oAfiH3cITp4do0gtSKknUUBfrmbRKGeYW0ldeevU=@protonmail.com>
 <94bb2092-6d53-0e46-45ac-a1f8e04dafba@mattcorallo.com>
 <CACJVCgLtt=SBLeA=JWPhzU7EdbJUy2AfPTGbs-pRn0fuwGmZsQ@mail.gmail.com>
Message-ID: <e3b1d9a0-df1d-38e0-02cb-306020ab7240@mattcorallo.com>

I was assuming, largely, that Bitcoin Core will eventually get what you describe here (which is generally termed 
"package relay", implying we relay, and process, groups of transactions as one).

What we'd need for SIGHASH_ANYPREVOUT is a relay network that isn't just smart about fee calculation, but can actually 
rewrite the transactions themselves before passing them on to a local bitcoind.

eg such a network would need to be able to relay
"I have transaction A, with one input, which is valid for any output-idx-0 in a transaction spending output B".
and then have the receiver go look up which transaction in its mempool/chain spends output B, then fill in the input 
with that outpoint and hand the now-fully-formed transaction to their local bitcoind for processing.

Matt

On 8/7/20 11:34 AM, Richard Myers wrote:
> When you say that a special relay network might be more "smart about replacement" in the context of ANYPREVOUT*, do you 
> mean these nodes could RBF parts of a package like this:
> 
> 
> Given:
>  ?- Package A = UpdateTx_A(n=1): txin: AnchorTx, txout: SettlementTx_A(n=1) -> HtlcTxs(n=1)_A -> .chain of? transactions 
> that pin UpdateTx_A(n=1) with high total fee, etc.
> 
> 
> And a new package with higher fee rate versions of ANYPREVOUT* transactions in the package, but otherwise lower total fee:
> 
>  ?- Package B = UpdateTx_B(n=1): txin: AnchorTx, txout: SettlementTx_B(n=1) ->?HtlcTxs(n=1)_B -> low total fee package
> 
> 
> Relay just?the higher up-front fee-rate transactions from package B which get spent by the high absolute fee child 
> transactions from package A:
> 
>  ?- Package A' =?UpdateTx_B(n=1): txin: AnchorTx, txout: SettlementTx_B(n=1) -> HtlcTxs(n=1)_A -> ...chain of up to 25 
> txs that pin UpdateTx(n=1) with high total fee, etc.
> 
> On Thu, Aug 6, 2020 at 5:59 PM Matt Corallo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org 
> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
> 
>     In general, SIGHASH_NOINPUT makes these issues much, much simpler to address, but only if we assume that nodes can
>     somehow be "smart" about replacement when they see a SIGHASH_NOINPUT spend which can spend an output that something else
>     in the mempool already spends (potentially a different input than the relaying node thinks the transaction should
>     spend). While ideally we'd be able to shove that (significant) complexity into the Bitcoin P2P network, that may not be
>     feasible, but we could imagine a relay network of lightning nodes doing that calculation and then passing the
>     transactions to their local full nodes. 
> 
> 

From belcher at riseup.net  Tue Aug 11 12:05:57 2020
From: belcher at riseup.net (Chris Belcher)
Date: Tue, 11 Aug 2020 13:05:57 +0100
Subject: [bitcoin-dev] Detailed protocol design for routed multi-transaction
	CoinSwap
Message-ID: <813e51a1-4252-08c0-d42d-5cef32f684bc@riseup.net>

I'm currently working on implementing CoinSwap (see my other email
"Design for a CoinSwap implementation for massively improving Bitcoin
privacy and fungibility").

CoinSwaps are special because they look just like regular bitcoin
transactions, so they improve the privacy even for people who do not use
them. Once CoinSwap is deployed, anyone attempting surveillance of
bitcoin transactions will be forced to ask themselves the question: how
do we know this transaction wasn't a CoinSwap?

This email contains a detailed design of the first protocol version. It
makes use of the building blocks of multi-transaction CoinSwaps, routed
CoinSwaps, liquidity market, private key handover, and fidelity bonds.
It does not include PayJoin-with-CoinSwap, but that's in the plan to be
added later.

== Routed CoinSwap ==

Diagram of CoinSwaps in the route:

    Alice ====> Bob ====> Charlie ====> Alice

Where (====>) means one CoinSwap. Alice gives coins to Bob, who gives
coins to Charlie, who gives coins to Alice. Alice is the market taker
and she starts with the hash preimage. She chooses the CoinSwap amount
and chooses who the makers will be.

This design has one market taker and two market makers in its route, but
it can easily be extended to any number of makers.

== Multiple transactions ==

Each single CoinSwap is made up of multiple transactions to avoid amount
correlation

          (a0 BTC) --->     (b0 BTC) --->         (c0 BTC) --->
    Alice (a1 BTC) ---> Bob (b1 BTC) ---> Charlie (c1 BTC) ---> Alice
          (a2 BTC) --->     (b2 BTC) --->         (c2 BTC) --->

The arrow (--->) represent funding transactions. The money gets paid to
a 2-of-2 multisig but after the CoinSwap protocol and private key
handover is done they will be controlled by the next party in the route.

This example has 6 regular-sized transactions which use approximately
the same amount of block space as a single JoinMarket coinjoin with 6
parties (1 taker, 5 makers). Yet the privacy provided by this one
CoinSwap would be far far greater. It would not have to be repeated in
the way that Equal-Output CoinJoins must be.

== Direct connections to Alice ===

Only Alice, the taker, knows the entire route, Bob and Charlie just know
their previous and next transactions. Bob and Charlie do not have direct
connections with each other, only with Alice.

Diagram of Tor connections:

    Bob      Charlie
     |       /
     |      /
     |     /
      Alice

When Bob and Charlie communicate, they are actually sending and
receiving messages via Alice who relays them to Charlie or Bob. This
helps hide whether the previous or next counterparty in a CoinSwap route
is a maker or taker.

This doesn't have security issues even in the final steps where private
keys are handed over, because those private keys are always for 2-of-2
multisig and so on their own are never enough to steal money.


=== Miner fees ===

Makers have no incentive to pay any miner fees. They only do
transactions which earn them an income and are willing to wait a very
long time for that to happen. By contrast takers want to create
transactions far more urgently. In JoinMarket we coded a protocol where
the maker could contribute to miner fees, but the market price offered
of that trended towards zero. So the reality is that takers will pay all
the miner fees. Also because makers don't know the taker's time
preference they don't know how much they should pay in miner fees.

The taker will have to set limits on how large the maker's transactions
are, otherwise makers could abuse this by having the taker consolidate
maker's UTXOs for free.

== Funding transaction definitions ==

Funding transactions are those which pay into the 2-of-2 multisig addresses.

Definitions:
I = initial coinswap amount sent by Alice = a0 + a1 + a2
(WA, WB, WC) = Total value of UTXOs being spent by Alice, Bob, Charlie
               respectively. Could be called "wallet Alice", "wallet
               Bob", etc
(B, C) = Coinswap fees paid by Alice and earned by Bob and Charlie.
(M1, M2, M3) = Miner fees of the first, second, third, etc sets of
               funding transactions. Alice will choose what these are
               since she's paying.
multisig(A+B) = A 2of2 multisig output with private keys held by A and B

The value in square parentheses refers to the bitcoin amount.

Alice funding txes
  [WA btc] ---> multisig (Alice+Bob) [I btc]
                change [WA-M1-I btc]
Bob funding txes
  [WB btc] ---> multisig (Bob+Charlie) [I-M2-B btc]
                change [WB-I+B btc]
Charlie funding txes
  [WC btc] ---> multisig (Charlie+Alice) [(I-M2-B)-M3-C btc]
                change [WC-(I-M2-B)+C btc]

Here we've drawn these transactions as single transactions, but they are
actually multiple transactions where the outputs add up some value (e.g.
add up to I in Alice's transactions.)

=== Table of balances before and after a successful CoinSwap ===

If a CoinSwap is successful then all the multisig outputs in the funding
transactions will become controlled unilaterally by one party. We can
calculate how the balances of each party change.

Party   | Before | After
--------|--------|-------------------------------------------
Alice   | WA     | WA-M1-I + (I-M2-B)-M3-C  = WA-M1-M2-M3-B-C
Bob     | WB     | WB-I+B + I               = WB+B
Charlie | WC     | WC-(I-M2-B)+C + I-M2-B   = WC+C

After a successful coinswap, we see Alice's balance goes down by the
miner fees and the coinswap fees. Bob's and Charlie's balance goes up by
their coinswap fees.

== Contract transaction definitions ==

Contract transactions are those which may spend from the 2-of-2 multisig
outputs, they transfer the coins into a contract where the coins can be
spent either by waiting for a timeout or providing a hash preimage
value. Ideally contract transactions will never be broadcast but their
existence keeps all parties honest.

M~ is miner fees, which we treat as a random variable, and ultimately
set by whichever pre-signed RBF tx get mined. When we talk about _the_
contract tx, we actually mean perhaps 20-30 transactions which only
differ by the miner fee and have RBF enabled, so they can be broadcasted
in sequence to get the contract transaction mined regardless of the
demand for block space.

(Alice+timelock_A OR Bob+hash) = Is an output which can be spent
                                 either with Alice's private key
                                 after waiting for a relative
                                 timelock_A, or by Bob's private key by
                                 revealing a hash preimage value

Alice contract tx:
    multisig (Alice+Bob) ---> (Alice+timelock_A OR Bob+hash)
    [I btc]                   [I-M~ btc]
Bob contract tx:
    multisig (Bob+Charlie) ---> (Bob+timelock_B OR Charlie+hash)
    [I-M2-B btc]                [I-M2-B-M~ btc]
Charlie contract tx:
    multisig (Charlie+Alice)  ---> (Charlie+timelock_C OR Alice+hash)
    [(I-M2-B)-M3-C btc]            [(I-M2-B)-M3-C-M~ btc]


=== Table of balances before/after CoinSwap using contracts transactions ===

In this case the parties had to get their money back by broadcasting and
mining the contract transactions and waiting for timeouts.

Party   | Before | After
--------|--------|--------------------------------------------
Alice   | WA     | WA-M1-I + I-M~                   = WA-M1-M~
Bob     | WB     | WB-I+B + I-M2-B-M~               = WB-M2-M~
Charlie | WC     | WC-(I-M2-B)+C + (I-M2-B)-M3-C-M~ = WC-M3-M~

In the timeout failure case, every party pays for their own miner fees.
And nobody earns or spends any coinswap fees. So even for a market maker
its possible for their wallet balance to go down sometimes, although as
we shall see there are anti-DOS features which make this unlikely to
happen often.

A possible attack by a malicious Alice is that she chooses M1 to be very
low (e.g. 1 sat/vbyte) and sets M2 and M3 to be very high (e.g. 1000
sat/vb) and then intentionally aborts, forcing the makers to lose much
more money in miner fees than the attacker. The attack can be used to
waste away Bob's and Charlie's coins on miner fees at little cost to the
malicious taker Alice. So to defend against this attack Bob and Charlie
must refuse to sign a contract transaction if the corresponding funding
transaction pays miner fees greater than Alice's funding transaction.


There can also be a failure case where each party gets their money using
hash preimage values instead of timeouts. Note that each party has to
sweep the output before the timeout expires, so that will cost an
additional miner fee M~.

Party   | Before | After
--------|--------|------------------------------------------------------
Alice   | WA     | WA-M1-I + (I-M2-B)-M3-C-M~ - M~ = WA-M1-M2-M3-B-C-2M~
Bob     | WB     | WB-I+B + I-M~ - M~              = WB+B-2M~
Charlie | WC     | WC-(I-M2-B)+C + I-M2-B-M~ - M~  = WC+C-2M~

In this situation the makers Bob and Charlie earn their CoinSwap fees,
but they pay an additional miner fee twice. Alice pays for all the
funding transaction miner fees, and the CoinSwap fees, and two
additional miner fees. And she had her privacy damaged because the
entire world saw on the blockchain the contract script.

Using the timelock path is like a refund, everyone's coin just comes
back to them. Using the preimage is like the CoinSwap transaction
happened, with the coins being sent ahead one hop. Again note that if
the preimage is used then coinswap fees are paid.

=== Staggered timelocks ===

The timelocks are staggered so that if Alice uses the preimage to take
coins then the right people will also learn the preimage and have enough
time to be able to get their coins back too. Alice starts with knowledge
of the hash preimage so she must have a longest timelock.

== EC tweak to reduce one round trip ==

When two parties are agreeing on a 2-of-2 multisig address, they need to
agree on their public keys. We can avoid one round trip by using the EC
tweak trick.

When Alice, the taker, downloads the entire offer book for the liquidity
market, the offers will also contain a EC public key. Alice can tweak
this to generate a brand new public key for which the maker knows the
private key. This public key will be one of the keys in the 2-of-2
multisig. This feature removes one round trip from the protocol.

    q = EC privkey generated by maker
    Q = q.G = EC pubkey published by maker

    p = nonce generated by taker
    P = p.G = nonce point calculated by taker

    R = Q + P = pubkey used in bitcoin transaction
      = (q + p).G

Taker sends unsigned transaction which pays to multisig using pubkey Q,
and also sends nonce p. The maker can use nonce p to calculate (q + p)
which is the private key of pubkey R.

Taker doesnt know the privkey because they are unable to find q because
of the ECDLP.

Any eavesdropper can see the nonce p and easily calculate the point R
too but Tor communication is encrypted so this isnt a concern.

None of the makers in the route know each other's Q values, so Alice the
taker will generate a nonce p on their behalf and send it over. I
believe this cant be used for any kind of attack, because the signing
maker will always check that the nonce results in the public key
included in the transaction they're signing, and they'll never sign a
transaction not in their interests.


== Protocol ==

This section is the most important part of this document.

Definitions:
fund = all funding txes (remember in this multi-tx protocol there can be
       multiple txes which together make up the funding)
A htlc = all htlc contract txes (fully signed) belonging to party A
A unsign htcl = all unsigned htlc contract txes belonging to party A
                including the nonce point p used to calculate the
                maker's pubkey.
p = nonce point p used in the tweak EC protocol for calculating the
    maker's pubkey
A htlc B/2 = Bob's signature for the 2of2 multisig of the Alice htlc
             contract tx
privA(A+B) = private key generated by Alice in the output
             multisig (Alice+Bob)


 | Alice           | Bob             | Charlie         |
 |=================|=================|=================|
0. A unsign htlc ---->               |                 |
1.               <---- A htlc B/2    |                 |
2. ***** BROADCAST AND MINE ALICE FUNDING TXES ******  |
3. A fund+htlc+p ---->               |                 |
4.                 | B unsign htlc ---->               |
5.                 |               <---- B htlc C/2    |
6. ******* BROADCAST AND MINE BOB FUNDING TXES ******* |
7.                 | B fund+htlc+p ---->               |
8.               <---------------------- C unsign htlc |
9.    C htlc A/2 ---------------------->               |
A. ***** BROADCAST AND MINE CHARLIE FUNDING TXES ***** |
B.               <---------------------- C fund+htlc+p |
C. hash preimage ---------------------->               |
D. hash preimage ---->               |                 |
E.    privA(A+B) ---->               |                 |
F.                 |    privB(B+C) ---->               |
G.               <---------------------- privC(C+A)    |

== Protocol notes ==
0-2 are the steps which setup Alice's funding tx and her contract tx for
    possible refund
4-5 same as 0-2 but for Bob
8-9 same as 0-2 but for Charlie
3,7 is proof to the next party that the previous party has already
    committed miner fees to getting a transaction mined, and therefore
    this isnt a DOS attack. The step also reveals the fully-signed
    contract transaction which the party can use to get their money back
    with a preimage.
C-G is revealing the hash preimage to all, and handing over the private
    keys


== Analysis of aborts ==

We will now discuss aborts, which happen when one party halts the
protocol and doesnt continue. Perhaps they had a power cut, their
internet broke, or they're a malicious attacker wanting to waste time
and money. The other party may try to reestablish a connection for some
time, but eventually must give up.

Number refers to the step number where the abort happened
e.g. step 1 means that the party aborted instead of the action happening
on protocol step 1.

The party name refers to what that party does
e.g. Party1: aborts, Party2/Party3: does a thing in reaction

0. Alice: aborts. Bob/Charlie: do nothing, they havent lost any time or
   money
1. Bob: aborts. Alice: lost no time or money, try with another Bob.
   Charlie: do nothing
2-3. same as 0.
4. Bob: aborts. Charlie: do nothing. Alice: broadcasts her contract tx
   and waits for the timeout, loses time and money on miner fees, she'll
   never coinswap with Bob's fidelity bond again.
5. Charlie: aborts. Alice/Bob: lose nothing, find another Charlie to
   coinswap with.
6. same as 4.
7. similar to 4 but Alice MIGHT not blacklist Bob's fidelity bond,
   because Bob will also have to broadcast his contract tx and will also
   lose time and money.
8. Charlie: aborts. Bob: broadcast his contract transaction and wait for
   the timeout to get his money back, also broadcast Alice's contract
   transaction in retaliation. Alice: waits for the timeout on her htlc
   tx that Bob broadcasted, will never do a coinswap with Charlie's
   fidelity bond again.
9. Alice: aborts. Charlie: do nothing, no money or time lost. Bob:
   broadcast bob contract tx and wait for timeout to get money back,
   comforted by the knowledge that when Alice comes back online she'll
   have to do the same thing and waste the same amount of time and
   money.
A-B. same as 8.
C-E. Alice: aborts. Bob/Charlie: all broadcast their contract txes and
     wait for the timeout to get their money back, or if Charlie knows
     the preimage he uses it to get the money immediately, which Bob can
     read from the blockchain and also use.
F. Bob: aborts. Alice: broadcast Charlie htlc tx and use preimage to get
   money immediately, Alice blacklists Bob's fidelity bond. Charlie:
   broadcast Bob htlc and use preimage to get money immediately.
G. Charlie: aborts. Alice: broadcast Charlie htlc and use preimage to
   get money immediately, Alice blacklists Charlie's fidelity bond. Bob:
   does nothing, already has his privkey.

==== Retaliation as DOS-resistance ====

In some situations (e.g. step 8.) if one maker in the coinswap route is
the victim of a DOS they will retaliate by DOSing the previous maker in
the route. This may seem unnecessary and unfair (after all why waste
even more time and block space) but is actually the best way to resist
DOS because it produces a concrete cost every time a DOS happens.


== Analysis of deviations ==

This section discusses what happens if one party deviates from the
protocol by doing something else, for example broadcasting a htlc
contract tx when they shouldnt have.

The party name refers to what that party does, followed by other party's
reactions to it.
e.g. Party1: does a thing, Party2/Party3: does a thing in reaction

If multiple deviations are possible in a step then they are numbered
e.g. A1 A2 A2 etc


0-2. Alice/Bob/Charlie: nothing else is possible except following the
     protocol or aborting
3. Alice: broadcasts one or more of the A htlc txes. Bob/Charlie/Dennis:
   do nothing, they havent lost any time or money.
4-6. Bob/Charlie: nothing else is possible except following the protocol
     or aborting.
7. Bob: broadcasts one or more of the B htlc txes, Alice: broadcasts all
   her own A htlc txes and waits for the timeout to get her money back.
   Charlie: do nothing
8. Charlie: nothing else is possible except following the protocol or
   aborting.
9. Alice: broadcasts one or more of the A htlc txes. Bob: broadcasts all
   his own A htlc txes and waits for the timeout.
A. same as 8.
B. Charlie: broadcasts one or more of the C htlc txes, Alice/Bob:
   broadcasts all their own htlc txes and waits for the timeout to get
   their money back.
C-E1. Alice: broadcasts all of C htlc txes and uses her knowledge of the
      preimage hash to take the money immediately. Charlie: broadcasts
      all of B htlc txes and reading the hash value from the blockchain,
      uses it to take the money from B htlc immediately. Bob: broadcasts
      all of A htlc txes, and reading hash from the blockchain, uses it
      to take the money from A htlc immediately.
C-E2. Alice: broadcast her own A htlc txes, and after a timeout take the
      money. Bob: broadcast his own B htlc txes and after the timeout
      take their money. Charlie: broadcast his own C htlc txes and after
      the timeout take their money.
F1. Bob: broadcast one or more of A htcl txes and use the hash preimage
    to get the money immediately. He already knows both privkeys of the
    multisig so this is pointless and just damages privacy and wastes
    miner fees. Alice: blacklist Bob's fidelity bond.
F2. Bob: broadcast one or more of the C htlc txes. Charlie: use preimage
    to get his money immediately. Bob's actions were pointless. Alice:
    cant tell whether Bob or Charlie actually broadcasted, so blacklist
    both fidelity bonds.
G1. Charlie: broadcast one or more of B htcl txes and use the hash
    preimage to get the money immediately. He already knows both
    privkeys of the multisig so this is pointless and just damages
    privacy and wastes miner fees. Alice: cant tell whether Bob or
    Charlie actually broadcasted, so blacklist both fidelity bonds.
G2. Charlie: broadcast one or more of the A htlc txes. Alice: broadcast
    the remaining A htlc txes and use preimage to get her money
    immediately. Charlies's actions were pointless. Alice: blacklist
    Charlie's fidelity bond.

The multisig outputs of the funding transactions can stay unspent
indefinitely. However the parties must always be watching the network
and ready to respond with their own sweep using a preimage. This is
because the other party still possesses a fully-signed contract tx. The
parties respond in the same way as in steps C-E1, F2 and G2. Alice's
reaction of blacklisting both fidelity bonds might not be the right way,
because one maker could use it to get another one blacklisted (as well
as themselves).


== Conclusion ==

This document describes the first version of the protocol which
implements multi-transaction Coinswap, routed Coinswap, fidelity bonds,
a liquidity market and private key handover. I describe the protocol and
also analyze aborts of the protocols and deviations from the protocol.


From bitcoin-dev at wuille.net  Wed Aug 12 18:49:56 2020
From: bitcoin-dev at wuille.net (Pieter Wuille)
Date: Wed, 12 Aug 2020 18:49:56 +0000
Subject: [bitcoin-dev] Revisiting squaredness tiebreaker for R point in
	BIP340
Message-ID: <g7VgKBKlUmgMkNo6Nq1OkyilwW6Z4WbqeSZHXfvh_LDYmry5R7uGbavyEHtv2xr_0KBevL057TxSdlo_tS0_ucBXYNm8MuTu_jgyrGO9jpo=@wuille.net>

Hello all,

The current BIP340 draft[1] uses two different tiebreakers for conveying the Y coordinate of points: for the R point inside signatures squaredness is used, while for public keys evenness is used. Originally both used squaredness, but it was changed[2] for public keys after observing this results in additional complexity for compatibility with existing systems.

The reason for choosing squaredness as tiebreaker was performance: in non-batch signature validation, the recomputed R point must be verified to have the correct sign, to guarantee consistency with batch validation. Whether the Y coordinate is square can be computed directly in Jacobian coordinates, while determining evenness requires a conversion to affine coordinates first.

This argument of course relies on the assumption that determining whether the Y coordinate is square can be done more efficiently than a conversion to affine coordinates. It appears now that this assumption is incorrect, and the justification for picking the squaredness tiebreaking doesn't really exist. As it comes with other trade-offs (it slows down signing, and is a less conventional choice), it would seem that we should reconsider the option of having the R point use the evenness tiebreaker (like public keys).

It is late in the process, but I feel I owe this explanation so that at least the possibility of changing can be discussed with all information. On the upside, this was discovered in the context of looking into a cool improvement to libsecp256k1[5], which makes things faster in general, but specifically benefits the evenness variant.


# 1. What happened?

Computing squaredness is done through the Jacobi symbol (same inventor, but unrelated to Jacobian coordinates). Computing evenness requires converting points to affine coordinates first, and that needs a modular inverse. The assumption that Jacobi symbols are faster to compute than inverses was based on:

* A (possibly) mistaken belief about the theory: fast algorithms for both Jacobi symbols and inverses are internally based on variants of the same extended GCD algorithm[3]. Since an inverse needs to extract a full big integer out of the transition steps made in the extgcd algorithm, while the Jacobi symbol just extracts a single bit, it had seemed that any advances applicable to one would be applicable to the other, but inverses would always need additional work on top. It appears however that a class of extgcd algorithms exists (LSB based ones) that cannot be used for Jacobi calculations without losing efficiency. Recent developments[4] and a proposed implementation in libsecp256k1[5] by Peter Dettman show that using this, inverses in some cases can in fact be faster than Jacobi symbols.

* A broken benchmark. This belief was incorrectly confirmed by a broken benchmark[6] in libsecp256k1 for the libgmp-based Jacobi symbol calculation and modular inverse. The benchmark was repeatedly testing the same constant input, which apparently was around 2.5x faster than the average speed. It is a variable-time algorithm, so a good variation of inputs matters. This mistake had me (and probably others) convinced for years that Jacobi symbols were amazingly fast, while in reality they were always very close in performance to inverses.


# 2. What is the actual impact of picking evenness instead?

It is hard to make very generic statements here, as BIP340 will hopefully be used for a long time, and hardware advancements and algorithmic improvements may change the balance. That said, performance on current hardware with optimized algorithms is the best approximation we have.

The numbers below give the expected performance change from squareness to evenness, for single BIP340 validation, and for signing. Positive numbers mean evenness is faster. Batch validation is not impacted at all.

In the short term, for block validation in Bitcoin Core, the numbers for master-nogmp are probably the most relevant (as Bitcoin Core uses libsecp256k1 without libgmp, to reduce consensus-critical dependencies). If/when [5] gets merged, safegcd-nogmp will be what matters. On a longer time scale, the gmp numbers may be more relevant, as the Jacobi implementation there is certainly closer to the state of the art.

* i7-7820HQ: (verify) (sign)
  - master-nogmp: -0.3% +16.1%
  - safegcd-nogmp: +6.7% +17.1%
  - master-gmp: +0.6% +7.7%
  - safegcd-gmp: +1.6% +8.6%

* Cortex-A53: (verify) (sign)
  - master-nogmp: -0.3% +15.7%
  - safegcd-nogmp: +7.5% +16.9%
  - master-gmp: +0.3% +4.1%
  - safegcd-gmp: 0.0% +3.5%

* EPYC 7742: (verify) (sign)
  - master-nogmp: -0.3% +16.8%
  - safegcd-nogmp: +8.6% +18.4%
  - master-gmp: 0.0% +7.4%
  - safegcd-gmp: +2.3% +7.8%

In well optimized cryptographic code speedups as large as a couple percent are difficult to come by, so we would usually consider changes of this magnitude relevant. Note however that while the percentages for signing speed are larger, they are not what is unexpected here. The choice for the square tiebreaker was intended to improve verification speed at the cost of signing speed. As it turns out that it doesn't actually benefit verification speed, this is a bad trade-off.


# 3. How big a change is it

* In the BIP:
  - Changing both invocations of `has_square_y` to `has_even_y`.
  - Changing the `lift_x_square_y` invocation to `lift_x_even_y`.
  - Applying the same change to the test vector generation code, and the resulting test vectors.
* In the libsecp256k1:
  - An 8-line patch to the proposed BIP340 implementation[7]: see [8]
* In Bitcoin Core:
  - Similarly small changes to the Python test reimplementation[9]
* Duplicating these changes in other draft implementations that may already exist.
* Review for all the above.


# 4. Conclusion

We discovered that the justification for using squaredness tiebreakers in BIP340 is based on a misunderstanding, and recent developments show that it may in fact be a somewhat worse choice than the alternative. It is a relatively simple change to address this, but that has be weighed against the impact of changing the standard at this stage.

Thoughts?


# 5. References

  [1] https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#design
  [2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017639.html
  [3] https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
  [4] https://gcd.cr.yp.to/safegcd-20190413.pdf
  [5] https://github.com/bitcoin-core/secp256k1/pull/767
  [6] https://github.com/bitcoin-core/secp256k1/pull/797
  [7] https://github.com/bitcoin-core/secp256k1/pull/558
  [8] https://github.com/sipa/secp256k1/commit/822311ca230a48d2c373f3e48b91b2a59e1371d6
  [9] https://github.com/bitcoin/bitcoin/pull/17977


Cheers,

--
Pieter


From nadav at suredbits.com  Wed Aug 12 20:19:01 2020
From: nadav at suredbits.com (Nadav Kohen)
Date: Wed, 12 Aug 2020 15:19:01 -0500
Subject: [bitcoin-dev] Revisiting squaredness tiebreaker for R point in
	BIP340
In-Reply-To: <g7VgKBKlUmgMkNo6Nq1OkyilwW6Z4WbqeSZHXfvh_LDYmry5R7uGbavyEHtv2xr_0KBevL057TxSdlo_tS0_ucBXYNm8MuTu_jgyrGO9jpo=@wuille.net>
References: <g7VgKBKlUmgMkNo6Nq1OkyilwW6Z4WbqeSZHXfvh_LDYmry5R7uGbavyEHtv2xr_0KBevL057TxSdlo_tS0_ucBXYNm8MuTu_jgyrGO9jpo=@wuille.net>
Message-ID: <CALGTLwOStbj6j4p2FFf+mw+88=W7cbNDhoCbpLL9zR9XmrS4Sg@mail.gmail.com>

Hello Pieter and all,

I am one of the maintainers of Bitcoin-S[1] and I maintain our secp256k1
bindings (via JNI) as well as our (inefficient) bouncy castle fallback
implementations of all secp256k1 functionality we depend on including
Schnorr signatures. In light of this new information that there is no real
downside to using evenness as the nonce tie-breaker, I am personally very
in favor of this change as it strictly simplifies things as well as making
types consistent between nonces and persistent signing keys (I can get rid
of our SchnorrNonce type :). An additional minor benefit not already
mentioned is that in places in our codebase where deserialized data is just
being passed around and not used, we currently require a computation to go
from a (x-only) SchnorrNonce to an ECPublicKey whereas going from a
SchnorrPublicKey simply requires pre-pending a 0x02 byte.

I am likely not aware of the entire impact that changing the BIP at this
stage would have but from my view (of having to update bindings and test
vectors and my fallback implementation, as well as wanting to get a stable
branch on secp256k1-zkp containing both ECDSA adaptor signatures and
Schnorr signatures for use in Discreet Log Contracts), I think this change
is totally worth it and it will only become harder to make this
simplification in the future. The schnorrsig branch has not yet been merged
into secp256k1 (and is nearing this stage I think) and so long as making
this change doesn't set us back more than a month (which seems unlikely) I
am personally in favor of making this change. Glad to hear other's thoughts
on this of course but I figured I'd voice my support :)

Best,
Nadav

[1] https://github.com/bitcoin-s/bitcoin-s/



On Wed, Aug 12, 2020 at 2:04 PM Pieter Wuille via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hello all,
>
> The current BIP340 draft[1] uses two different tiebreakers for conveying
> the Y coordinate of points: for the R point inside signatures squaredness
> is used, while for public keys evenness is used. Originally both used
> squaredness, but it was changed[2] for public keys after observing this
> results in additional complexity for compatibility with existing systems.
>
> The reason for choosing squaredness as tiebreaker was performance: in
> non-batch signature validation, the recomputed R point must be verified to
> have the correct sign, to guarantee consistency with batch validation.
> Whether the Y coordinate is square can be computed directly in Jacobian
> coordinates, while determining evenness requires a conversion to affine
> coordinates first.
>
> This argument of course relies on the assumption that determining whether
> the Y coordinate is square can be done more efficiently than a conversion
> to affine coordinates. It appears now that this assumption is incorrect,
> and the justification for picking the squaredness tiebreaking doesn't
> really exist. As it comes with other trade-offs (it slows down signing, and
> is a less conventional choice), it would seem that we should reconsider the
> option of having the R point use the evenness tiebreaker (like public keys).
>
> It is late in the process, but I feel I owe this explanation so that at
> least the possibility of changing can be discussed with all information. On
> the upside, this was discovered in the context of looking into a cool
> improvement to libsecp256k1[5], which makes things faster in general, but
> specifically benefits the evenness variant.
>
>
> # 1. What happened?
>
> Computing squaredness is done through the Jacobi symbol (same inventor,
> but unrelated to Jacobian coordinates). Computing evenness requires
> converting points to affine coordinates first, and that needs a modular
> inverse. The assumption that Jacobi symbols are faster to compute than
> inverses was based on:
>
> * A (possibly) mistaken belief about the theory: fast algorithms for both
> Jacobi symbols and inverses are internally based on variants of the same
> extended GCD algorithm[3]. Since an inverse needs to extract a full big
> integer out of the transition steps made in the extgcd algorithm, while the
> Jacobi symbol just extracts a single bit, it had seemed that any advances
> applicable to one would be applicable to the other, but inverses would
> always need additional work on top. It appears however that a class of
> extgcd algorithms exists (LSB based ones) that cannot be used for Jacobi
> calculations without losing efficiency. Recent developments[4] and a
> proposed implementation in libsecp256k1[5] by Peter Dettman show that using
> this, inverses in some cases can in fact be faster than Jacobi symbols.
>
> * A broken benchmark. This belief was incorrectly confirmed by a broken
> benchmark[6] in libsecp256k1 for the libgmp-based Jacobi symbol calculation
> and modular inverse. The benchmark was repeatedly testing the same constant
> input, which apparently was around 2.5x faster than the average speed. It
> is a variable-time algorithm, so a good variation of inputs matters. This
> mistake had me (and probably others) convinced for years that Jacobi
> symbols were amazingly fast, while in reality they were always very close
> in performance to inverses.
>
>
> # 2. What is the actual impact of picking evenness instead?
>
> It is hard to make very generic statements here, as BIP340 will hopefully
> be used for a long time, and hardware advancements and algorithmic
> improvements may change the balance. That said, performance on current
> hardware with optimized algorithms is the best approximation we have.
>
> The numbers below give the expected performance change from squareness to
> evenness, for single BIP340 validation, and for signing. Positive numbers
> mean evenness is faster. Batch validation is not impacted at all.
>
> In the short term, for block validation in Bitcoin Core, the numbers for
> master-nogmp are probably the most relevant (as Bitcoin Core uses
> libsecp256k1 without libgmp, to reduce consensus-critical dependencies).
> If/when [5] gets merged, safegcd-nogmp will be what matters. On a longer
> time scale, the gmp numbers may be more relevant, as the Jacobi
> implementation there is certainly closer to the state of the art.
>
> * i7-7820HQ: (verify) (sign)
>   - master-nogmp: -0.3% +16.1%
>   - safegcd-nogmp: +6.7% +17.1%
>   - master-gmp: +0.6% +7.7%
>   - safegcd-gmp: +1.6% +8.6%
>
> * Cortex-A53: (verify) (sign)
>   - master-nogmp: -0.3% +15.7%
>   - safegcd-nogmp: +7.5% +16.9%
>   - master-gmp: +0.3% +4.1%
>   - safegcd-gmp: 0.0% +3.5%
>
> * EPYC 7742: (verify) (sign)
>   - master-nogmp: -0.3% +16.8%
>   - safegcd-nogmp: +8.6% +18.4%
>   - master-gmp: 0.0% +7.4%
>   - safegcd-gmp: +2.3% +7.8%
>
> In well optimized cryptographic code speedups as large as a couple percent
> are difficult to come by, so we would usually consider changes of this
> magnitude relevant. Note however that while the percentages for signing
> speed are larger, they are not what is unexpected here. The choice for the
> square tiebreaker was intended to improve verification speed at the cost of
> signing speed. As it turns out that it doesn't actually benefit
> verification speed, this is a bad trade-off.
>
>
> # 3. How big a change is it
>
> * In the BIP:
>   - Changing both invocations of `has_square_y` to `has_even_y`.
>   - Changing the `lift_x_square_y` invocation to `lift_x_even_y`.
>   - Applying the same change to the test vector generation code, and the
> resulting test vectors.
> * In the libsecp256k1:
>   - An 8-line patch to the proposed BIP340 implementation[7]: see [8]
> * In Bitcoin Core:
>   - Similarly small changes to the Python test reimplementation[9]
> * Duplicating these changes in other draft implementations that may
> already exist.
> * Review for all the above.
>
>
> # 4. Conclusion
>
> We discovered that the justification for using squaredness tiebreakers in
> BIP340 is based on a misunderstanding, and recent developments show that it
> may in fact be a somewhat worse choice than the alternative. It is a
> relatively simple change to address this, but that has be weighed against
> the impact of changing the standard at this stage.
>
> Thoughts?
>
>
> # 5. References
>
>   [1]
> https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#design
>   [2]
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017639.html
>   [3] https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
>   [4] https://gcd.cr.yp.to/safegcd-20190413.pdf
>   [5] https://github.com/bitcoin-core/secp256k1/pull/767
>   [6] https://github.com/bitcoin-core/secp256k1/pull/797
>   [7] https://github.com/bitcoin-core/secp256k1/pull/558
>   [8]
> https://github.com/sipa/secp256k1/commit/822311ca230a48d2c373f3e48b91b2a59e1371d6
>   [9] https://github.com/bitcoin/bitcoin/pull/17977
>
>
> Cheers,
>
> --
> Pieter
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200812/e77abbbc/attachment-0001.html>

From lloyd.fourn at gmail.com  Thu Aug 13 05:31:58 2020
From: lloyd.fourn at gmail.com (Lloyd Fournier)
Date: Thu, 13 Aug 2020 15:31:58 +1000
Subject: [bitcoin-dev] Revisiting squaredness tiebreaker for R point in
	BIP340
In-Reply-To: <CALGTLwOStbj6j4p2FFf+mw+88=W7cbNDhoCbpLL9zR9XmrS4Sg@mail.gmail.com>
References: <g7VgKBKlUmgMkNo6Nq1OkyilwW6Z4WbqeSZHXfvh_LDYmry5R7uGbavyEHtv2xr_0KBevL057TxSdlo_tS0_ucBXYNm8MuTu_jgyrGO9jpo=@wuille.net>
 <CALGTLwOStbj6j4p2FFf+mw+88=W7cbNDhoCbpLL9zR9XmrS4Sg@mail.gmail.com>
Message-ID: <CAH5Bsr16LN=4d4ns0t5fYE11aw2FfnkBzBJionUUxF+76t+Dfg@mail.gmail.com>

Thanks for bringing this discovery up and a big thanks to Peter Dettman for
working on this.

I second what Nadav said. Removing pointless complexity is worth it even at
this stage. I also maintain a non-libsecp implementation of BIP340 etc.
Having two ways to convert an xonly to a point is a pain if you are trying
to maintain type safe apis. If there is no performance penalty (or even a
small one in the short term) to unifying xonly -> point conversion it's
worth it from my perspective.

LL

On Thu, Aug 13, 2020 at 6:29 AM Nadav Kohen via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hello Pieter and all,
>
> I am one of the maintainers of Bitcoin-S[1] and I maintain our secp256k1
> bindings (via JNI) as well as our (inefficient) bouncy castle fallback
> implementations of all secp256k1 functionality we depend on including
> Schnorr signatures. In light of this new information that there is no real
> downside to using evenness as the nonce tie-breaker, I am personally very
> in favor of this change as it strictly simplifies things as well as making
> types consistent between nonces and persistent signing keys (I can get rid
> of our SchnorrNonce type :). An additional minor benefit not already
> mentioned is that in places in our codebase where deserialized data is just
> being passed around and not used, we currently require a computation to go
> from a (x-only) SchnorrNonce to an ECPublicKey whereas going from a
> SchnorrPublicKey simply requires pre-pending a 0x02 byte.
>
> I am likely not aware of the entire impact that changing the BIP at this
> stage would have but from my view (of having to update bindings and test
> vectors and my fallback implementation, as well as wanting to get a stable
> branch on secp256k1-zkp containing both ECDSA adaptor signatures and
> Schnorr signatures for use in Discreet Log Contracts), I think this change
> is totally worth it and it will only become harder to make this
> simplification in the future. The schnorrsig branch has not yet been merged
> into secp256k1 (and is nearing this stage I think) and so long as making
> this change doesn't set us back more than a month (which seems unlikely) I
> am personally in favor of making this change. Glad to hear other's thoughts
> on this of course but I figured I'd voice my support :)
>
> Best,
> Nadav
>
> [1] https://github.com/bitcoin-s/bitcoin-s/
>
>
>
> On Wed, Aug 12, 2020 at 2:04 PM Pieter Wuille via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Hello all,
>>
>> The current BIP340 draft[1] uses two different tiebreakers for conveying
>> the Y coordinate of points: for the R point inside signatures squaredness
>> is used, while for public keys evenness is used. Originally both used
>> squaredness, but it was changed[2] for public keys after observing this
>> results in additional complexity for compatibility with existing systems.
>>
>> The reason for choosing squaredness as tiebreaker was performance: in
>> non-batch signature validation, the recomputed R point must be verified to
>> have the correct sign, to guarantee consistency with batch validation.
>> Whether the Y coordinate is square can be computed directly in Jacobian
>> coordinates, while determining evenness requires a conversion to affine
>> coordinates first.
>>
>> This argument of course relies on the assumption that determining whether
>> the Y coordinate is square can be done more efficiently than a conversion
>> to affine coordinates. It appears now that this assumption is incorrect,
>> and the justification for picking the squaredness tiebreaking doesn't
>> really exist. As it comes with other trade-offs (it slows down signing, and
>> is a less conventional choice), it would seem that we should reconsider the
>> option of having the R point use the evenness tiebreaker (like public keys).
>>
>> It is late in the process, but I feel I owe this explanation so that at
>> least the possibility of changing can be discussed with all information. On
>> the upside, this was discovered in the context of looking into a cool
>> improvement to libsecp256k1[5], which makes things faster in general, but
>> specifically benefits the evenness variant.
>>
>>
>> # 1. What happened?
>>
>> Computing squaredness is done through the Jacobi symbol (same inventor,
>> but unrelated to Jacobian coordinates). Computing evenness requires
>> converting points to affine coordinates first, and that needs a modular
>> inverse. The assumption that Jacobi symbols are faster to compute than
>> inverses was based on:
>>
>> * A (possibly) mistaken belief about the theory: fast algorithms for both
>> Jacobi symbols and inverses are internally based on variants of the same
>> extended GCD algorithm[3]. Since an inverse needs to extract a full big
>> integer out of the transition steps made in the extgcd algorithm, while the
>> Jacobi symbol just extracts a single bit, it had seemed that any advances
>> applicable to one would be applicable to the other, but inverses would
>> always need additional work on top. It appears however that a class of
>> extgcd algorithms exists (LSB based ones) that cannot be used for Jacobi
>> calculations without losing efficiency. Recent developments[4] and a
>> proposed implementation in libsecp256k1[5] by Peter Dettman show that using
>> this, inverses in some cases can in fact be faster than Jacobi symbols.
>>
>> * A broken benchmark. This belief was incorrectly confirmed by a broken
>> benchmark[6] in libsecp256k1 for the libgmp-based Jacobi symbol calculation
>> and modular inverse. The benchmark was repeatedly testing the same constant
>> input, which apparently was around 2.5x faster than the average speed. It
>> is a variable-time algorithm, so a good variation of inputs matters. This
>> mistake had me (and probably others) convinced for years that Jacobi
>> symbols were amazingly fast, while in reality they were always very close
>> in performance to inverses.
>>
>>
>> # 2. What is the actual impact of picking evenness instead?
>>
>> It is hard to make very generic statements here, as BIP340 will hopefully
>> be used for a long time, and hardware advancements and algorithmic
>> improvements may change the balance. That said, performance on current
>> hardware with optimized algorithms is the best approximation we have.
>>
>> The numbers below give the expected performance change from squareness to
>> evenness, for single BIP340 validation, and for signing. Positive numbers
>> mean evenness is faster. Batch validation is not impacted at all.
>>
>> In the short term, for block validation in Bitcoin Core, the numbers for
>> master-nogmp are probably the most relevant (as Bitcoin Core uses
>> libsecp256k1 without libgmp, to reduce consensus-critical dependencies).
>> If/when [5] gets merged, safegcd-nogmp will be what matters. On a longer
>> time scale, the gmp numbers may be more relevant, as the Jacobi
>> implementation there is certainly closer to the state of the art.
>>
>> * i7-7820HQ: (verify) (sign)
>>   - master-nogmp: -0.3% +16.1%
>>   - safegcd-nogmp: +6.7% +17.1%
>>   - master-gmp: +0.6% +7.7%
>>   - safegcd-gmp: +1.6% +8.6%
>>
>> * Cortex-A53: (verify) (sign)
>>   - master-nogmp: -0.3% +15.7%
>>   - safegcd-nogmp: +7.5% +16.9%
>>   - master-gmp: +0.3% +4.1%
>>   - safegcd-gmp: 0.0% +3.5%
>>
>> * EPYC 7742: (verify) (sign)
>>   - master-nogmp: -0.3% +16.8%
>>   - safegcd-nogmp: +8.6% +18.4%
>>   - master-gmp: 0.0% +7.4%
>>   - safegcd-gmp: +2.3% +7.8%
>>
>> In well optimized cryptographic code speedups as large as a couple
>> percent are difficult to come by, so we would usually consider changes of
>> this magnitude relevant. Note however that while the percentages for
>> signing speed are larger, they are not what is unexpected here. The choice
>> for the square tiebreaker was intended to improve verification speed at the
>> cost of signing speed. As it turns out that it doesn't actually benefit
>> verification speed, this is a bad trade-off.
>>
>>
>> # 3. How big a change is it
>>
>> * In the BIP:
>>   - Changing both invocations of `has_square_y` to `has_even_y`.
>>   - Changing the `lift_x_square_y` invocation to `lift_x_even_y`.
>>   - Applying the same change to the test vector generation code, and the
>> resulting test vectors.
>> * In the libsecp256k1:
>>   - An 8-line patch to the proposed BIP340 implementation[7]: see [8]
>> * In Bitcoin Core:
>>   - Similarly small changes to the Python test reimplementation[9]
>> * Duplicating these changes in other draft implementations that may
>> already exist.
>> * Review for all the above.
>>
>>
>> # 4. Conclusion
>>
>> We discovered that the justification for using squaredness tiebreakers in
>> BIP340 is based on a misunderstanding, and recent developments show that it
>> may in fact be a somewhat worse choice than the alternative. It is a
>> relatively simple change to address this, but that has be weighed against
>> the impact of changing the standard at this stage.
>>
>> Thoughts?
>>
>>
>> # 5. References
>>
>>   [1]
>> https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#design
>>   [2]
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017639.html
>>   [3] https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
>>   [4] https://gcd.cr.yp.to/safegcd-20190413.pdf
>>   [5] https://github.com/bitcoin-core/secp256k1/pull/767
>>   [6] https://github.com/bitcoin-core/secp256k1/pull/797
>>   [7] https://github.com/bitcoin-core/secp256k1/pull/558
>>   [8]
>> https://github.com/sipa/secp256k1/commit/822311ca230a48d2c373f3e48b91b2a59e1371d6
>>   [9] https://github.com/bitcoin/bitcoin/pull/17977
>>
>>
>> Cheers,
>>
>> --
>> Pieter
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200813/45cce79a/attachment.html>

From sdaftuar at gmail.com  Fri Aug 14 19:28:41 2020
From: sdaftuar at gmail.com (Suhas Daftuar)
Date: Fri, 14 Aug 2020 15:28:41 -0400
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
	connections are setup
Message-ID: <CAFp6fsE=HPFUMFhyuZkroBO_QJ-dUWNJqCPg9=fMJ3Jqnu1hnw@mail.gmail.com>

Hi,

Back in February I posted a proposal for WTXID-based transaction relay[1]
(now known as BIP 339), which included a proposal for feature negotiation
to take place prior to the VERACK message being received by each side.  In
my email to this list, I had asked for feedback as to whether that proposal
was problematic, and didn't receive any responses.

Since then, the implementation of BIP 339 has been merged into Bitcoin
Core, though it has not yet been released.

In thinking about the mechanism used there, I thought it would be helpful
to codify in a BIP the idea that Bitcoin network clients should ignore
unknown messages received before a VERACK.  A draft of my proposal is
available here[2].

I presume that software upgrading past protocol version 70016 was already
planning to either implement BIP 339, or ignore the wtxidrelay message
proposed in BIP 339 (if not, then this would create network split concerns
in the future -- so I hope that someone would speak up if this were a
problem).  When we propose future protocol upgrades that would benefit from
feature negotiation at the time of connection, I think it would be nice to
be able to use the same method as proposed in BIP 339, without even needing
to bump the protocol version.  So having an understanding that this is the
standard of how other network clients operate would be helpful.

If, on the other hand, this is problematic for some reason, I look forward
to hearing that as well, so that we can be careful about how we deploy
future p2p changes to avoid disruption.

Thanks,
Suhas Daftuar

[1]
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html

[2]
https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200814/6d0b3b0f/attachment.html>

From thomashartman1 at gmail.com  Sun Aug 16 15:41:30 2020
From: thomashartman1 at gmail.com (Thomas Hartman)
Date: Sun, 16 Aug 2020 11:41:30 -0400
Subject: [bitcoin-dev] reviving op_difficulty
Message-ID: <CAHAXnDXhAFQHiBCJ=H=1ZGHdHWhgLh1rG3pCPR5o48ziZzV+zQ@mail.gmail.com>

First, I would like to pay respects to tamas blummer, RIP.

https://bitcoinmagazine.com/articles/remembering-tamas-blummer-pioneering-bitcoin-developer

Tamas proposed an additional opcode for enabling bitcoin difficulty
futures, on this list at

https://www.mail-archive.com/bitcoin-dev at lists.linuxfoundation.org/msg07991.html

I really like this idea.

1) Trusted third parties are security holes

https://nakamotoinstitute.org/trusted-third-parties/

and oracles (eg discreet log contracts) are really just trusted third
parties in a blockchain's clothing. So truly ttp-free oracle-free on
chain contracts are good.

2) Difficulty is a proxy for energy, which is a proxy for usd, which
is what everyone currently cares about, which is bad. Energy is real.
Bitcoin traders should care about future difficulty, not future usd
price.

So in sum I think this is a very good idea, and I would like to
continue this work. Ideally I would like to see to completion the BIP
that Tamas was unable to produce.

Some initial thoughts on the technical merits.

My understanding is that adding a single op_difficulty operation as
proposed would enable not true difficulty futures but binary options
on difficulty.

https://en.wikipedia.org/wiki/Binary_option

As the wikipedia article notes, "While binary options may be used in
theoretical asset pricing, they are prone to fraud in their
applications and hence banned by regulators in many jurisdictions as a
form of gambling." The trouble is that because of the all or nothing
nature binary options are more of a gamble than a hedge. They are
popular with scammers, and even licensed binary options exchanges such
as nadex are under constant scrutiny by regulators.

Because any form of trusted third party-free / oracle free speculation
would encourage economic use of blockchain space and support the
transaction fee market, perhaps an economic case can be made for naive
op_difficulty as above even it has more of a flavor of gambling than
hedging. I think at a psychological level it would be good for a
ttp-free difficulty speculation tool to capture mindshare.

That being said, true difficulty futures -- real hedging and not just
gambling --  would be far healthier for bitcoin than binary options. I
am trying to wrangle what additional opcodes and protocol changes
would be required beyond just op_difficulty, to get true difficulty
futures on chain.

I envision something like this. To give some context: Current
difficulty is 16.9 Trillion. We're a week in to the current difficulty
regime so there's aboout 1000 blocks to retarget, and predicted next
difficuly is 18.5 Trillion. So let's pretend we sell a difficulty
future that pays out in sats, of the next difficulty divided by a
trillion. A reasonable price for this would be, say, 17.4 sats.

So in our op_difficulty utxo, one address (the futures buyer) would
get current difficulty / trillion, and the other address (the seller)
would get however much value is locked in the utxo, minus that amount
and miner fee. The payout would be limited by however much value is
locked in the utxo. Since difficulty adjusts very slowly I don't think
overflowing the locked up value would be much of a problem in
practice. We also want a mechanism to enable on-chain purchase of such
a contract, say for 17.4 sats.

One additional opcode that apparently would be required is division.
Some version of rshift could also do.

I am not clear if there is a way to solve the accounting for the
payouts, but perhaps there is a way to do this with covenants.

I'm somewhat new to protocol and script. I would appreciate if anyone
has any further advice on this.

Cheers, Thomas.

From jlrubin at mit.edu  Sun Aug 16 17:24:09 2020
From: jlrubin at mit.edu (Jeremy)
Date: Sun, 16 Aug 2020 10:24:09 -0700
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
 connections are setup
In-Reply-To: <CAFp6fsE=HPFUMFhyuZkroBO_QJ-dUWNJqCPg9=fMJ3Jqnu1hnw@mail.gmail.com>
References: <CAFp6fsE=HPFUMFhyuZkroBO_QJ-dUWNJqCPg9=fMJ3Jqnu1hnw@mail.gmail.com>
Message-ID: <CAD5xwhg-k1+0R8g4kn4fjvdqmsh0rS_44r4JOPFOCWDGqNLUFA@mail.gmail.com>

Concept ack!

It might be nice to include a few negotiation utility functions either in
this bip or at the same time in a separate bip. An example we might want to
include is a "polite disconnect", whereby a node can register that you
don't want to connect in the future due to incompatibility.

It also might be nice to standardize some naming convention or negotiation
message type so that we don't end up with different negotiation systems.
Then we can also limit the bip so that we're only defining negotiation
message types as ignorable v.s. some other message type (which can also be
ignored, but maybe we want to do something else in the future).

This also makes it easier for old (but newer than this bip) nodes to apply
some generic rules around reporting/rejecting/responding to unknown feature
negotiation v.s. an untagged message which might be a negotiation or
something else.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200816/6fb078d1/attachment.html>

From tier.nolan at gmail.com  Sun Aug 16 18:59:25 2020
From: tier.nolan at gmail.com (Tier Nolan)
Date: Sun, 16 Aug 2020 19:59:25 +0100
Subject: [bitcoin-dev] reviving op_difficulty
In-Reply-To: <CAHAXnDXhAFQHiBCJ=H=1ZGHdHWhgLh1rG3pCPR5o48ziZzV+zQ@mail.gmail.com>
References: <CAHAXnDXhAFQHiBCJ=H=1ZGHdHWhgLh1rG3pCPR5o48ziZzV+zQ@mail.gmail.com>
Message-ID: <CAE-z3OVCcAL2x39TswA8zrZ+yjSqdx4hccTWn9Ug8MQ5=k-Pgg@mail.gmail.com>

On Sun, Aug 16, 2020 at 4:50 PM Thomas Hartman via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> My understanding is that adding a single op_difficulty operation as
> proposed would enable not true difficulty futures but binary options
> on difficulty.
>
> https://en.wikipedia.org/wiki/Binary_option


Any kind of opcode is a binary option.  Either the output can be spent or
it can't.

You could get a pseudo-continuous future by having lots of outputs with
different thresholds.

Alice and Bob create a transaction with 100 outputs and each having 1% of
the future's value.

Output 0:  Pay Alice if diff < 1.00 trillion else Bob
Output 1:  Pay Alice if diff < 1.01 trillion else Bob
....
Output 98:  Pay Alice if diff < 1.98 trillion else Bob
Output 99:  Pay Alice if diff < 1.99 trillion else Bob

If the difficulty is 1.25 trillion, then Alice gets outputs 0-24 and Bob
gets outputs 25-99.  The future has a tick size of 1%.  It isn't very
efficient though

It would be good to have the option to specify a block height for the
future too.  If it triggered on block time, then miners have an incentive
to give false block times.

I am not clear if there is a way to solve the accounting for the
> payouts, but perhaps there is a way to do this with covenants.
>

I agree you would need covenants or something similar.

There needs to be a way to check the outputs (value and script) of the
spending transaction.  You also need a way for Alice and Bob to create
their spending transaction in sequence.

Output 0: Pay Alice if [output value 0] <= Diff / 1 trillion AND [output
value 1] >= (2 trillion - diff)  / (1 trillion) AND [output 1 pays to Bob]

To spend her output, Alice has to create a transaction which pays Bob and
assigns the coins in the right ratio.  [output value x] means the output
value of the spending transaction for output x.

To get it to work Alice creates a transaction with these restrictions

Output 0:
Script: Anything (Alice gets it to pay herself)
Value: <= Diff / 1 trillion

Output 1:
Script: Must pay to Bob
Value: >= (2 trillion - Diff) / 1 trillion

You also need to handle overflows with the calculations.

Bob can then spend output 1 and get his money.

There is a hold-up risk if Alice doesn't spend her money.  You can make the
output script so either of them can spend their coins to avoid that.

Output 0:
    Pay Alice if [output value 0] <= Diff / 1 trillion AND [output value 1]
>= (2 trillion - diff)  / (1 trillion) AND [output 1 pays to Bob]
      OR
    Pay Bob if [output value 0] <= (2 trillion - Diff) / 1 trillion AND
[output value 1] >= Diff / (1 trillion) AND [output 1 pays to Alice]

You would need a covenant-like instruction to check the output values and
scripts and the diff opcode to get the difficulty.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200816/63df27eb/attachment.html>

From eric at voskuil.org  Sun Aug 16 19:06:55 2020
From: eric at voskuil.org (Eric Voskuil)
Date: Sun, 16 Aug 2020 12:06:55 -0700
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
	connections are setup
In-Reply-To: <CAFp6fsE=HPFUMFhyuZkroBO_QJ-dUWNJqCPg9=fMJ3Jqnu1hnw@mail.gmail.com>
References: <CAFp6fsE=HPFUMFhyuZkroBO_QJ-dUWNJqCPg9=fMJ3Jqnu1hnw@mail.gmail.com>
Message-ID: <C18E3371-C27A-41CD-B81F-6C96FA210494@voskuil.org>

A requirement to ignore unknown (invalid) messages is not only a protocol breaking change but poor protocol design. The purpose of version negotiation is to determine the set of valid messages. Changes to version negotiation itself are very problematic.

The only limitation presented by versioning is that the system is sequential. As such, clients that do not wish to implement (or operators who do not wish to enable) them are faced with a problem when wanting to support later features. This is resolvable by making such features optional at the new protocol level. This allows each client to limit its communication to the negotiated protocol, and allows ignoring of known but unsupported/disabled features.

Sorry I missed your earlier post. Been distracted for a while.

e


> On Aug 14, 2020, at 12:28, Suhas Daftuar via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> ?
> Hi,
> 
> Back in February I posted a proposal for WTXID-based transaction relay[1] (now known as BIP 339), which included a proposal for feature negotiation to take place prior to the VERACK message being received by each side.  In my email to this list, I had asked for feedback as to whether that proposal was problematic, and didn't receive any responses.
> 
> Since then, the implementation of BIP 339 has been merged into Bitcoin Core, though it has not yet been released.
> 
> In thinking about the mechanism used there, I thought it would be helpful to codify in a BIP the idea that Bitcoin network clients should ignore unknown messages received before a VERACK.  A draft of my proposal is available here[2].
> 
> I presume that software upgrading past protocol version 70016 was already planning to either implement BIP 339, or ignore the wtxidrelay message proposed in BIP 339 (if not, then this would create network split concerns in the future -- so I hope that someone would speak up if this were a problem).  When we propose future protocol upgrades that would benefit from feature negotiation at the time of connection, I think it would be nice to be able to use the same method as proposed in BIP 339, without even needing to bump the protocol version.  So having an understanding that this is the standard of how other network clients operate would be helpful.
> 
> If, on the other hand, this is problematic for some reason, I look forward to hearing that as well, so that we can be careful about how we deploy future p2p changes to avoid disruption.
> 
> Thanks,
> Suhas Daftuar
> 
> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html
> 
> [2] https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200816/1813852d/attachment-0001.html>

From aj at erisian.com.au  Sun Aug 16 22:29:23 2020
From: aj at erisian.com.au (Anthony Towns)
Date: Mon, 17 Aug 2020 08:29:23 +1000
Subject: [bitcoin-dev] reviving op_difficulty
In-Reply-To: <CAHAXnDXhAFQHiBCJ=H=1ZGHdHWhgLh1rG3pCPR5o48ziZzV+zQ@mail.gmail.com>
References: <CAHAXnDXhAFQHiBCJ=H=1ZGHdHWhgLh1rG3pCPR5o48ziZzV+zQ@mail.gmail.com>
Message-ID: <20200816222923.zf47qrmqdiuv6yfp@erisian.com.au>

On Sun, Aug 16, 2020 at 11:41:30AM -0400, Thomas Hartman via bitcoin-dev wrote:
> My understanding is that adding a single op_difficulty operation as
> proposed would enable not true difficulty futures but binary options
> on difficulty.

An alternative approach for this might be to use taproot's annex concept.

https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-5

The idea would be to add an annex restriction that's only valid if the
difficulty is a given value (or within a given range). Protocol design
could be:

  Alice, Bob, Carol, Dave want to make bets on difficulty futures
  They each deposit a,b,c,d into a UTXO of value a+b+c+d payable to
    a 4-4 of multisig of their keys (eg MuSig(A,B,c,D))
  They construct signed payouts spending that UTXO, all timelocked
    for the future date; one spending to Alice with the annex locking
    in the difficulty to Alice's predicted range, one spending to Bob
    with the annex locking in the difficulty to Bob's predicted range,
    etc

When the future date arrives, whoever was right can immediately
broadcast their payout transaction. (If they don't, then someone else
might be able to when the difficulty next retargets)

(Specifying an exact value for the difficulty rather than a range might
be better; it's smaller/simpler on the blockchain, and doesn't reveal
the ranges of your predictions giving traders slightly better privacy.
The cost to doing that is if Alice predicts difficulty could be any of 100
different values, she needs 100 different signatures for her pre-signed
payout, one for each possible difficulty value that would be encoded in
the annex)

Cheers,
aj


From ZmnSCPxj at protonmail.com  Mon Aug 17 05:04:42 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 17 Aug 2020 05:04:42 +0000
Subject: [bitcoin-dev] reviving op_difficulty
In-Reply-To: <CAE-z3OVCcAL2x39TswA8zrZ+yjSqdx4hccTWn9Ug8MQ5=k-Pgg@mail.gmail.com>
References: <CAHAXnDXhAFQHiBCJ=H=1ZGHdHWhgLh1rG3pCPR5o48ziZzV+zQ@mail.gmail.com>
 <CAE-z3OVCcAL2x39TswA8zrZ+yjSqdx4hccTWn9Ug8MQ5=k-Pgg@mail.gmail.com>
Message-ID: <Y9rFseQ13QJ0TspORM_a542mUib8lJV2IiDe8GXS5SrxkvXbVI13MfbgGqVoSVftumcYNBBKut6Fz840ehS5VfvF2AsO_qNTyzvs6tTCpBk=@protonmail.com>

Good morning Tier, Thomas, and aj,

> On Sun, Aug 16, 2020 at 4:50 PM Thomas Hartman via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > My understanding is that adding a single op_difficulty operation as
> > proposed would enable not true difficulty futures but binary options
> > on difficulty.
> >
> > https://en.wikipedia.org/wiki/Binary_option
>
> Any kind of opcode is a binary option.? Either the output can be spent or it can't.
>
> You could get a pseudo-continuous future by having lots of outputs with different thresholds.
>
> Alice and Bob create a transaction with 100 outputs and each having 1% of the future's value.
>
> Output 0:? Pay Alice if diff < 1.00 trillion else Bob
> Output 1:? Pay Alice if diff < 1.01 trillion else Bob
> ....
> Output 98:? Pay Alice if diff < 1.98 trillion else Bob
> Output 99:? Pay Alice if diff < 1.99 trillion else Bob
>
> If the difficulty is 1.25 trillion, then Alice gets outputs 0-24 and Bob gets outputs 25-99.? The future has a tick size of 1%.? It isn't very efficient though

Taproot MAST to the rescue.

* Alice and Bob agree on the number of ticks N and payout schedule.
* Alice and Bob generate N fresh keypairs and share them.
* Alice and Bob generate tapleaf scripts of the form:
  * script[i] = Alice[i] && Bob[i] && diff < 1.00 trillion + i * tick_size && CLTV(deadline)
* Alice and Bob generate the taproot MAST for the above scripts.
* Alice and Bob generate, but do ***NOT*** sign, a funding transaction paying out to the generated taproot MAST.
* Bob generates partial signatures for N payout transactions, with lower-difficulty-targets paying out less to Alice and more to Bob, and higher-difficulty-targets paying out more to Alice and less to Bob.
  * This requires spending the [i]th tapleaf script with the appropriate difficulty target.
* Alice saves all the Bob signatures.
* At deadline, Alice rationally selects the highest-paying version that is still acceptable, based on the actual difficulty target at the time.

This requires publishing only O(log N) data (the merkle path to the selected tapleaf).
This translates to the 100-tick example requiring only one TXO, 1 scripthash, and 7 or so Merkle-tree-path hashes, compared to the above example which requires 100 TXOs and 100 script hashes.

The same scheme can be used with `OP_CTV` and without keypairs being involved, but basically anything `OP_CTV` can do, signing keypairs with pre-generated signatures from all participants can do just as well, with higher storage and setup costs.

Regards,
ZmnSCPxj

From thomashartman1 at gmail.com  Mon Aug 17 19:48:27 2020
From: thomashartman1 at gmail.com (Thomas Hartman)
Date: Mon, 17 Aug 2020 15:48:27 -0400
Subject: [bitcoin-dev] reviving op_difficulty
In-Reply-To: <Y9rFseQ13QJ0TspORM_a542mUib8lJV2IiDe8GXS5SrxkvXbVI13MfbgGqVoSVftumcYNBBKut6Fz840ehS5VfvF2AsO_qNTyzvs6tTCpBk=@protonmail.com>
References: <CAHAXnDXhAFQHiBCJ=H=1ZGHdHWhgLh1rG3pCPR5o48ziZzV+zQ@mail.gmail.com>
 <CAE-z3OVCcAL2x39TswA8zrZ+yjSqdx4hccTWn9Ug8MQ5=k-Pgg@mail.gmail.com>
 <Y9rFseQ13QJ0TspORM_a542mUib8lJV2IiDe8GXS5SrxkvXbVI13MfbgGqVoSVftumcYNBBKut6Fz840ehS5VfvF2AsO_qNTyzvs6tTCpBk=@protonmail.com>
Message-ID: <C7C0864D-5635-43B8-88B6-E53A14C3066C@gmail.com>

Tier, AJ, ZmnSCPxj, thanks! 

> On Aug 17, 2020, at 1:04 AM, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Taproot MAST to the rescue.

OK. So, using the tick scheme described by Tier a difficulty futures instrument is possible with current script + op_diff; and with taproot + op_diff (ZmnSCPxj) it may even be economical. (I will set aside covenants for now.)

To do it all on-chain, we need a mechanism for selling such an instrument in a trustless way.

That is to say (using ZmnSCPxj's construction), we have now a future where Bob pays Alice a pico-difficulty at next adjustment. 

But how does Alice pay Bob his 17.4 sat?

I am trying to figure out a way to do this naively using the base layer. (I really want this with lightning, and eventually hft, but first things first.)

My thinking so far is, Alice and Bob collaborate to create partial versions of

** the difficulty future funded by Bob, spendable by Alice in 1000 blocks
** and a 17.4 sat payment from Alice to Bob, spendable by Bob immediately

When Bob completes and broadcasts the payment from Alice, it should enable Alice to complete and broadcast the difficulty future funded by Bob. 

I am thinking a hash lock on the payment, with a preimage secret generated by Bob, could be used to accomplish this. When Bob unlocks and broadcasts the payment, this reveals the preimage, and with the preimage Alice can unlock and broadcast the difficulty future funded by Bob. 

Am I correct in thinking something like this could work?  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200817/444a999a/attachment.html>

From sdaftuar at gmail.com  Mon Aug 17 20:40:02 2020
From: sdaftuar at gmail.com (Suhas Daftuar)
Date: Mon, 17 Aug 2020 16:40:02 -0400
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
 connections are setup
In-Reply-To: <C18E3371-C27A-41CD-B81F-6C96FA210494@voskuil.org>
References: <CAFp6fsE=HPFUMFhyuZkroBO_QJ-dUWNJqCPg9=fMJ3Jqnu1hnw@mail.gmail.com>
 <C18E3371-C27A-41CD-B81F-6C96FA210494@voskuil.org>
Message-ID: <CAFp6fsH==PJ38vGvCGUr3AVS8XmQEjvLkNaopAhu0vY7xQjgAw@mail.gmail.com>

Hi Eric,

Thanks for your response.  If I understand correctly, you're suggesting
that in the future we do the same as what was done in BIP 339, of
accompanying new messages (which are optional) with a protocol version
bump, so that network clients are never reading unknown messages from a
peer (and can be free to disconnect a peer for sending an unknown message)?

I think that works fine, so if indeed there will be software that will
expect things to operate this way then I can withdraw the suggestion I've
made in this thread.  However I wanted to clarify that this is what you
suggest, because there is another downside to this approach (beyond the
sequential nature of sequence numbers that you mention) -- if a software
implementation misses a proposed new protocol upgrade, and thus fails to
parse (and ignore) some proposed new message, the result can be a network
split down the road as incompatible clients get slowly upgraded over time.

I think this coordination cost is something to be concerned about -- for
instance, the lack of response to my wtxid-relay proposal made me wonder if
other software would be implementing something to account for the new
message that proposal introduces (for clients with version >= 70016).  It's
reasonable for people to be busy and miss things like this, and I think
it's worth considering whether there's a safer way for us to deploy changes.

That said, I don't think this coordination cost is unbearable, so as long
as we have a process for making p2p protocol improvements I'm not too
worried about what mechanism we use.  So if this concern over coordination
of changes doesn't sway you, I think we can continue to just bump protocol
version at the same time as deploying new messages, as we have been doing,
and hope that we don't run into problems down the road.

If I have misunderstood how you think we should be making future protocol
changes, please let me know.

Thanks,
Suhas



On Sun, Aug 16, 2020 at 3:06 PM Eric Voskuil <eric at voskuil.org> wrote:

> A requirement to ignore unknown (invalid) messages is not only a protocol
> breaking change but poor protocol design. The purpose of version
> negotiation is to determine the set of valid messages. Changes to version
> negotiation itself are very problematic.
>
> The only limitation presented by versioning is that the system is
> sequential. As such, clients that do not wish to implement (or operators
> who do not wish to enable) them are faced with a problem when wanting to
> support later features. This is resolvable by making such features optional
> at the new protocol level. This allows each client to limit its
> communication to the negotiated protocol, and allows ignoring of known but
> unsupported/disabled features.
>
> Sorry I missed your earlier post. Been distracted for a while.
>
> e
>
>
> On Aug 14, 2020, at 12:28, Suhas Daftuar via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> ?
> Hi,
>
> Back in February I posted a proposal for WTXID-based transaction relay[1]
> (now known as BIP 339), which included a proposal for feature negotiation
> to take place prior to the VERACK message being received by each side.  In
> my email to this list, I had asked for feedback as to whether that proposal
> was problematic, and didn't receive any responses.
>
> Since then, the implementation of BIP 339 has been merged into Bitcoin
> Core, though it has not yet been released.
>
> In thinking about the mechanism used there, I thought it would be helpful
> to codify in a BIP the idea that Bitcoin network clients should ignore
> unknown messages received before a VERACK.  A draft of my proposal is
> available here[2].
>
> I presume that software upgrading past protocol version 70016 was already
> planning to either implement BIP 339, or ignore the wtxidrelay message
> proposed in BIP 339 (if not, then this would create network split concerns
> in the future -- so I hope that someone would speak up if this were a
> problem).  When we propose future protocol upgrades that would benefit from
> feature negotiation at the time of connection, I think it would be nice to
> be able to use the same method as proposed in BIP 339, without even needing
> to bump the protocol version.  So having an understanding that this is the
> standard of how other network clients operate would be helpful.
>
> If, on the other hand, this is problematic for some reason, I look forward
> to hearing that as well, so that we can be careful about how we deploy
> future p2p changes to avoid disruption.
>
> Thanks,
> Suhas Daftuar
>
> [1]
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html
>
> [2]
> https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200817/f449fb1f/attachment.html>

From eric at voskuil.org  Mon Aug 17 21:21:53 2020
From: eric at voskuil.org (Eric Voskuil)
Date: Mon, 17 Aug 2020 14:21:53 -0700
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
	connections are setup
In-Reply-To: <CAFp6fsH==PJ38vGvCGUr3AVS8XmQEjvLkNaopAhu0vY7xQjgAw@mail.gmail.com>
References: <CAFp6fsH==PJ38vGvCGUr3AVS8XmQEjvLkNaopAhu0vY7xQjgAw@mail.gmail.com>
Message-ID: <6FCCEC96-02F7-48D7-92EC-52234B94805B@voskuil.org>

Hi Suhas,

It seems to me that your first two paragraphs contradict each other, so I?m not sure we have understanding. As you say in the first paragraph, a peer would never get messages that it does not understand, so there is no chance that missing a protocol change would matter.

In case it?s not understood, version negotiation provides each peer with the maximum supported protocol version of the other. Once complete both have negotiated to the highest common version. No message not supported at that version may be sent by either.

If the protocol was to accept *any* message traffic then it will cease to be a protocol. People will drop in their changes without obtaining broad support, and peers will evolve to the point of no longer being peers. They won?t speak the same language and the ?network? will be little more than a broadcast transport, broadcasting all traffic to all peers, whether it?s for them or not.

People need to either build support or build a distinct network. That?s the actual coordination issue, which is inherent to protocol development.

Best,
e

> On Aug 17, 2020, at 13:40, Suhas Daftuar <sdaftuar at gmail.com> wrote:
> 
> Hi Eric,
> 
> Thanks for your response.  If I understand correctly, you're suggesting that in the future we do the same as what was done in BIP 339, of accompanying new messages (which are optional) with a protocol version bump, so that network clients are never reading unknown messages from a peer (and can be free to disconnect a peer for sending an unknown message)?
> 
> I think that works fine, so if indeed there will be software that will expect things to operate this way then I can withdraw the suggestion I've made in this thread.  However I wanted to clarify that this is what you suggest, because there is another downside to this approach (beyond the sequential nature of sequence numbers that you mention) -- if a software implementation misses a proposed new protocol upgrade, and thus fails to parse (and ignore) some proposed new message, the result can be a network split down the road as incompatible clients get slowly upgraded over time. 
> 
> I think this coordination cost is something to be concerned about -- for instance, the lack of response to my wtxid-relay proposal made me wonder if other software would be implementing something to account for the new message that proposal introduces (for clients with version >= 70016).  It's reasonable for people to be busy and miss things like this, and I think it's worth considering whether there's a safer way for us to deploy changes.
> 
> That said, I don't think this coordination cost is unbearable, so as long as we have a process for making p2p protocol improvements I'm not too worried about what mechanism we use.  So if this concern over coordination of changes doesn't sway you, I think we can continue to just bump protocol version at the same time as deploying new messages, as we have been doing, and hope that we don't run into problems down the road.  
> 
> If I have misunderstood how you think we should be making future protocol changes, please let me know.
> 
> Thanks,
> Suhas
> 
> 
> 
>> On Sun, Aug 16, 2020 at 3:06 PM Eric Voskuil <eric at voskuil.org> wrote:
>> A requirement to ignore unknown (invalid) messages is not only a protocol breaking change but poor protocol design. The purpose of version negotiation is to determine the set of valid messages. Changes to version negotiation itself are very problematic.
>> 
>> The only limitation presented by versioning is that the system is sequential. As such, clients that do not wish to implement (or operators who do not wish to enable) them are faced with a problem when wanting to support later features. This is resolvable by making such features optional at the new protocol level. This allows each client to limit its communication to the negotiated protocol, and allows ignoring of known but unsupported/disabled features.
>> 
>> Sorry I missed your earlier post. Been distracted for a while.
>> 
>> e
>> 
>> 
>>>> On Aug 14, 2020, at 12:28, Suhas Daftuar via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>> 
>>> ?
>>> Hi,
>>> 
>>> Back in February I posted a proposal for WTXID-based transaction relay[1] (now known as BIP 339), which included a proposal for feature negotiation to take place prior to the VERACK message being received by each side.  In my email to this list, I had asked for feedback as to whether that proposal was problematic, and didn't receive any responses.
>>> 
>>> Since then, the implementation of BIP 339 has been merged into Bitcoin Core, though it has not yet been released.
>>> 
>>> In thinking about the mechanism used there, I thought it would be helpful to codify in a BIP the idea that Bitcoin network clients should ignore unknown messages received before a VERACK.  A draft of my proposal is available here[2].
>>> 
>>> I presume that software upgrading past protocol version 70016 was already planning to either implement BIP 339, or ignore the wtxidrelay message proposed in BIP 339 (if not, then this would create network split concerns in the future -- so I hope that someone would speak up if this were a problem).  When we propose future protocol upgrades that would benefit from feature negotiation at the time of connection, I think it would be nice to be able to use the same method as proposed in BIP 339, without even needing to bump the protocol version.  So having an understanding that this is the standard of how other network clients operate would be helpful.
>>> 
>>> If, on the other hand, this is problematic for some reason, I look forward to hearing that as well, so that we can be careful about how we deploy future p2p changes to avoid disruption.
>>> 
>>> Thanks,
>>> Suhas Daftuar
>>> 
>>> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html
>>> 
>>> [2] https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200817/e1288ac9/attachment-0001.html>

From tier.nolan at gmail.com  Mon Aug 17 21:55:04 2020
From: tier.nolan at gmail.com (Tier Nolan)
Date: Mon, 17 Aug 2020 22:55:04 +0100
Subject: [bitcoin-dev] reviving op_difficulty
In-Reply-To: <Y9rFseQ13QJ0TspORM_a542mUib8lJV2IiDe8GXS5SrxkvXbVI13MfbgGqVoSVftumcYNBBKut6Fz840ehS5VfvF2AsO_qNTyzvs6tTCpBk=@protonmail.com>
References: <CAHAXnDXhAFQHiBCJ=H=1ZGHdHWhgLh1rG3pCPR5o48ziZzV+zQ@mail.gmail.com>
 <CAE-z3OVCcAL2x39TswA8zrZ+yjSqdx4hccTWn9Ug8MQ5=k-Pgg@mail.gmail.com>
 <Y9rFseQ13QJ0TspORM_a542mUib8lJV2IiDe8GXS5SrxkvXbVI13MfbgGqVoSVftumcYNBBKut6Fz840ehS5VfvF2AsO_qNTyzvs6tTCpBk=@protonmail.com>
Message-ID: <CAE-z3OVuBGs=QxvyFMw30FZVimYWUQc_KAxKS=A-tjwVCFSbwQ@mail.gmail.com>

On Mon, Aug 17, 2020 at 6:04 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Taproot MAST to the rescue.
>

Another option would be a binary payout

You pay 64 + 32 + 16 + 8 + 4 + 2 + 1 as outputs.  The outputs are
enabled/disabled based on the diff value.  This would require division and
also binary operators.

D = (int) ((100 * diff) / (1 trillion))

Output 0: 1.28:  If (D & 128) then pay Alice otherwise Bob
Output 0: 0.64:  If (D & 64) then pay Alice otherwise Bob
Output 0: 0.32:  If (D & 32) then pay Alice otherwise Bob
Output 0: 0.16:  If (D & 16) then pay Alice otherwise Bob
Output 0: 0.8:  If (D & 8) then pay Alice otherwise Bob
Output 0: 0.4:  If (D & 4) then pay Alice otherwise Bob
Output 0: 0.4:  If (D & 4) then pay Alice otherwise Bob
Output 0: 0.4:  If (D & 4) then pay Alice otherwise Bob

This has log performance in terms of the number of ticks like the MAST
solution.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200817/a3fd8bd8/attachment.html>

From ZmnSCPxj at protonmail.com  Mon Aug 17 23:14:00 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 17 Aug 2020 23:14:00 +0000
Subject: [bitcoin-dev] reviving op_difficulty
In-Reply-To: <C7C0864D-5635-43B8-88B6-E53A14C3066C@gmail.com>
References: <CAHAXnDXhAFQHiBCJ=H=1ZGHdHWhgLh1rG3pCPR5o48ziZzV+zQ@mail.gmail.com>
 <CAE-z3OVCcAL2x39TswA8zrZ+yjSqdx4hccTWn9Ug8MQ5=k-Pgg@mail.gmail.com>
 <Y9rFseQ13QJ0TspORM_a542mUib8lJV2IiDe8GXS5SrxkvXbVI13MfbgGqVoSVftumcYNBBKut6Fz840ehS5VfvF2AsO_qNTyzvs6tTCpBk=@protonmail.com>
 <C7C0864D-5635-43B8-88B6-E53A14C3066C@gmail.com>
Message-ID: <bc0SG26C9FUzZO4l9cGDtbBGb0lrhsxrcvDoJXpJGUbyKEUq3eE3vLwTu_WufWOsN6DK3lPcKttNdEa9h7_tqixk12sBVErMi0YYF_HNBGo=@protonmail.com>

Good morning Thomas,

> Tier, AJ, ZmnSCPxj, thanks!?
>
> > On Aug 17, 2020, at 1:04 AM, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> > Taproot MAST to the rescue.
>
> OK. So, using the tick scheme described by Tier a difficulty futures instrument is possible with current script + op_diff; and with taproot + op_diff (ZmnSCPxj) it may even be economical. (I will set aside covenants for now.)
>
> To do it all on-chain, we need a mechanism for selling such an instrument in a trustless way.
>
> That is to say (using ZmnSCPxj's construction), we have now a future where Bob pays Alice a pico-difficulty at next adjustment.?
>
> But how does Alice pay Bob his 17.4 sat?
>
> I am trying to figure out a way to do this naively using the base layer. (I really want this with lightning, and eventually hft, but first things first.)
>
> My thinking so far is, Alice and Bob collaborate to create partial versions of
>
> ** the difficulty future funded by Bob, spendable by Alice in 1000 blocks
> ** and a 17.4 sat payment from Alice to Bob, spendable by Bob immediately
>
> When Bob completes and broadcasts the payment from Alice, it should enable Alice to complete and broadcast the difficulty future funded by Bob.?
>
> I am thinking a hash lock on the payment, with a preimage secret generated by Bob, could be used to accomplish this. When Bob unlocks and broadcasts the payment, this reveals the preimage, and with the preimage Alice can unlock and broadcast the difficulty future funded by Bob.?
>
> Am I correct in thinking something like this could work?

Bitcoin transactions on the blockchain layer are atomic, so it would be far simpler to make the purchase output and the options output in the same transaction, in a sort of PayJoin-like cooperatively-signed transaction.

That said, the construction you are imagining is indeed going to work.
The only requirement is that the hash-branch needs two signatures in order to ensure that it pays out to a transaction with a very specific contract.
Xref.  how Lightning *really* creates its HTLCs.

Regards,
ZmnSCPxj


From luke at dashjr.org  Tue Aug 18 04:03:54 2020
From: luke at dashjr.org (Luke Dashjr)
Date: Tue, 18 Aug 2020 04:03:54 +0000
Subject: [bitcoin-dev] Bitcoin Knots 0.20.1.knots20200815 released
Message-ID: <202008180404.01337.luke@dashjr.org>

Bitcoin Knots version 0.20.1.knots20200815 is now available from:

  https://bitcoinknots.org/files/0.20.x/0.20.1.knots20200815/

This release includes new features, various bug fixes and performance
improvements, as well as updated translations.

Please report bugs using the issue tracker at GitHub:

  https://github.com/bitcoinknots/bitcoin/issues

To receive security and update notifications, please subscribe to:

  https://bitcoinknots.org/list/announcements/join/

For the full release notes and change log, see:

https://github.com/bitcoinknots/bitcoin/blob/v0.20.1.knots20200815/doc/release-notes.md
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 1528 bytes
Desc: This is a digitally signed message part.
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200818/13a10f73/attachment.sig>

From lf-lists at mattcorallo.com  Tue Aug 18 14:59:00 2020
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Tue, 18 Aug 2020 10:59:00 -0400
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
 connections are setup
In-Reply-To: <CAFp6fsE=HPFUMFhyuZkroBO_QJ-dUWNJqCPg9=fMJ3Jqnu1hnw@mail.gmail.com>
References: <CAFp6fsE=HPFUMFhyuZkroBO_QJ-dUWNJqCPg9=fMJ3Jqnu1hnw@mail.gmail.com>
Message-ID: <8a7031f2-a598-ac09-f2df-1672cd82980b@mattcorallo.com>

This sounds like a great idea!

Bitcoin is no longer a homogeneous network of one client - it is many, with different features implemented in each. The 
Bitcoin protocol hasn't (fully) evolved to capture that reality. Initially the Bitcoin protocol had a simple numerical 
version field, but that is wholly impractical for any diverse network - some clients may not wish to implement every 
possible new relay mechanic, and why should they have to in order to use other new features?

Bitcoin protocol changes have, many times in recent history, been made via new dummy "negotiation" messages, which take 
advantage of the fact that the Bitcoin protocol has always expected clients to ignore unknown messages. Given that 
pattern, it makes sense to have an explicit negotiation phase - after version and before verack, just send the list of 
features that you support to negotiate what the connection will be capable of. The exact way we do that doesn't matter 
much, and sending it as a stream of messages which each indicate support for a given protocol feature perfectly captures 
the pattern that has been used in several recent network upgrades, keeping consistency.

Matt

On 8/14/20 3:28 PM, Suhas Daftuar via bitcoin-dev wrote:
> Hi,
> 
> Back in February I posted a proposal for WTXID-based transaction relay[1] (now known as BIP 339), which included a 
> proposal for feature negotiation to take place prior to the VERACK message being received by each side.? In my email to 
> this list, I had asked for feedback as to whether that proposal was problematic, and didn't receive any responses.
> 
> Since then, the implementation?of BIP 339 has been merged into Bitcoin Core, though it has not yet been released.
> 
> In thinking about the mechanism used there, I thought it would?be helpful to codify in a BIP the idea that Bitcoin 
> network clients should ignore unknown messages received before a VERACK.? A draft of my proposal is available here[2].
> 
> I presume that software upgrading past protocol version 70016 was already planning to either implement BIP 339, or 
> ignore the wtxidrelay message proposed in BIP 339 (if not, then this would create network split concerns in the future 
> -- so I hope that someone would speak up if this were a problem).? When we propose future protocol upgrades that would 
> benefit from feature negotiation at the time of connection, I think it would be nice to be able to use the same method 
> as proposed in BIP 339, without even needing to bump the protocol version.? So having an understanding that this is the 
> standard of how other network clients operate would be helpful.
> 
> If, on the other hand, this is problematic for some reason, I look forward to hearing that as well, so that we can be 
> careful about how we deploy future p2p changes to avoid disruption.
> 
> Thanks,
> Suhas Daftuar
> 
> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html 
> <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html>
> 
> [2] https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki 
> <https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki>
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From lf-lists at mattcorallo.com  Tue Aug 18 17:26:36 2020
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Tue, 18 Aug 2020 13:26:36 -0400
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
 connections are setup
In-Reply-To: <84F1FD44-0482-4F77-8FFA-65492E445D23@voskuil.org>
References: <8a7031f2-a598-ac09-f2df-1672cd82980b@mattcorallo.com>
 <84F1FD44-0482-4F77-8FFA-65492E445D23@voskuil.org>
Message-ID: <6ccf6ff8-6b4f-c8f4-0dbb-36c5d076528f@mattcorallo.com>

There are several cases where a new message has been sent as a part of a negotiation without changing the protocol 
version. You may chose to ignore that, but that doesn't mean that it isn't an understood and even relied upon feature of 
the Bitcoin P2P protocol. If you wish to fail connections to new nodes (and risk network splits, as Suhas points out), 
then you may do so, but that doesn't make it a part of the Bitcoin P2P protocol that you must do so. Of course there is 
no "official document" by which we can make a formal appeal, but historical precedent suggests otherwise.

Still, I think we're talking pedantics here, and not in a useful way. Ultimately we need some kind of negotiation which 
is flexible in allowing different software to negotiate different features without a global lock-step version number 
increase. Or, to put it another way, if a feature is fully optional, why should there be a version number increase for 
it - the negotiation of it is independent and a version number only increases confusion over which change "owns" a given 
version number.

I presume you'd support a single message that lists the set of features which a node (optionally) wishes to support on 
the connection. This proposal is fully equivalent to that, instead opting to list them as individual messages instead of 
one message, which is a bit nicer in that they can be handled more independently or by different subsystems including 
even the message hashing.

Matt

On 8/18/20 12:54 PM, Eric Voskuil wrote:
> ?Bitcoin protocol has always expected clients to ignore unknown messages?
> 
> This is not true. Bitcoin has long implemented version negotiation, which is the opposite expectation. Libbitcoin?s p2p 
> protocol implementation immediately drops a peer that sends an invalid message according to the negotiated version. The 
> fact that a given client does not validate the protocol does not make it an expectation that the protocol not be validated.
> 
> Features can clearly be optional within an actual protocol. There have been post-handshake negotiations implemented for 
> optional messages which are valid at the negotiated version. The protocol may be flexible while remaining validateable. 
> There is no reason to force a client to accept unknown message traffic.
> 
> A generalized versioning change can be implemented in or after the handshake. The latter is already done on an ad-hoc 
> basis. The former is possible as long as the peer?s version is sufficient to be aware of the behavior. This does not 
> imply any need to send invalid messages. The verack itself can simply be extended with a matrix of feature support. 
> There is no reason to complicate negotiation with an additional message(s).
> 
> FWIW, bip37 did this poorly, adding a feature field to the version message, resulting in bip60. Due to this design, 
> older protocol-validating clients were broken. In this case it was message length that was presumed to not be validated.
> 
> e
> 
>> On Aug 18, 2020, at 07:59, Matt Corallo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> ?This sounds like a great idea!
>>
>> Bitcoin is no longer a homogeneous network of one client - it is many, with different features implemented in each. 
>> The Bitcoin protocol hasn't (fully) evolved to capture that reality. Initially the Bitcoin protocol had a simple 
>> numerical version field, but that is wholly impractical for any diverse network - some clients may not wish to 
>> implement every possible new relay mechanic, and why should they have to in order to use other new features?
>>
>> Bitcoin protocol changes have, many times in recent history, been made via new dummy "negotiation" messages, which 
>> take advantage of the fact that the Bitcoin protocol has always expected clients to ignore unknown messages. Given 
>> that pattern, it makes sense to have an explicit negotiation phase - after version and before verack, just send the 
>> list of features that you support to negotiate what the connection will be capable of. The exact way we do that 
>> doesn't matter much, and sending it as a stream of messages which each indicate support for a given protocol feature 
>> perfectly captures the pattern that has been used in several recent network upgrades, keeping consistency.
>>
>> Matt
>>
>> On 8/14/20 3:28 PM, Suhas Daftuar via bitcoin-dev wrote:
>>> Hi,
>>> Back in February I posted a proposal for WTXID-based transaction relay[1] (now known as BIP 339), which included a 
>>> proposal for feature negotiation to take place prior to the VERACK message being received by each side.? In my email 
>>> to this list, I had asked for feedback as to whether that proposal was problematic, and didn't receive any responses.
>>> Since then, the implementation?of BIP 339 has been merged into Bitcoin Core, though it has not yet been released.
>>> In thinking about the mechanism used there, I thought it would?be helpful to codify in a BIP the idea that Bitcoin 
>>> network clients should ignore unknown messages received before a VERACK.? A draft of my proposal is available here[2].
>>> I presume that software upgrading past protocol version 70016 was already planning to either implement BIP 339, or 
>>> ignore the wtxidrelay message proposed in BIP 339 (if not, then this would create network split concerns in the 
>>> future -- so I hope that someone would speak up if this were a problem).? When we propose future protocol upgrades 
>>> that would benefit from feature negotiation at the time of connection, I think it would be nice to be able to use the 
>>> same method as proposed in BIP 339, without even needing to bump the protocol version.? So having an understanding 
>>> that this is the standard of how other network clients operate would be helpful.
>>> If, on the other hand, this is problematic for some reason, I look forward to hearing that as well, so that we can be 
>>> careful about how we deploy future p2p changes to avoid disruption.
>>> Thanks,
>>> Suhas Daftuar
>>> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html 
>>> <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html>
>>> [2] 
>>> https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki 
>>> <https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From eric at voskuil.org  Tue Aug 18 16:54:58 2020
From: eric at voskuil.org (Eric Voskuil)
Date: Tue, 18 Aug 2020 09:54:58 -0700
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
	connections are setup
In-Reply-To: <8a7031f2-a598-ac09-f2df-1672cd82980b@mattcorallo.com>
References: <8a7031f2-a598-ac09-f2df-1672cd82980b@mattcorallo.com>
Message-ID: <84F1FD44-0482-4F77-8FFA-65492E445D23@voskuil.org>

?Bitcoin protocol has always expected clients to ignore unknown messages?

This is not true. Bitcoin has long implemented version negotiation, which is the opposite expectation. Libbitcoin?s p2p protocol implementation immediately drops a peer that sends an invalid message according to the negotiated version. The fact that a given client does not validate the protocol does not make it an expectation that the protocol not be validated.

Features can clearly be optional within an actual protocol. There have been post-handshake negotiations implemented for optional messages which are valid at the negotiated version. The protocol may be flexible while remaining validateable. There is no reason to force a client to accept unknown message traffic.

A generalized versioning change can be implemented in or after the handshake. The latter is already done on an ad-hoc basis. The former is possible as long as the peer?s version is sufficient to be aware of the behavior. This does not imply any need to send invalid messages. The verack itself can simply be extended with a matrix of feature support. There is no reason to complicate negotiation with an additional message(s).

FWIW, bip37 did this poorly, adding a feature field to the version message, resulting in bip60. Due to this design, older protocol-validating clients were broken. In this case it was message length that was presumed to not be validated.

e

> On Aug 18, 2020, at 07:59, Matt Corallo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> ?This sounds like a great idea!
> 
> Bitcoin is no longer a homogeneous network of one client - it is many, with different features implemented in each. The Bitcoin protocol hasn't (fully) evolved to capture that reality. Initially the Bitcoin protocol had a simple numerical version field, but that is wholly impractical for any diverse network - some clients may not wish to implement every possible new relay mechanic, and why should they have to in order to use other new features?
> 
> Bitcoin protocol changes have, many times in recent history, been made via new dummy "negotiation" messages, which take advantage of the fact that the Bitcoin protocol has always expected clients to ignore unknown messages. Given that pattern, it makes sense to have an explicit negotiation phase - after version and before verack, just send the list of features that you support to negotiate what the connection will be capable of. The exact way we do that doesn't matter much, and sending it as a stream of messages which each indicate support for a given protocol feature perfectly captures the pattern that has been used in several recent network upgrades, keeping consistency.
> 
> Matt
> 
>> On 8/14/20 3:28 PM, Suhas Daftuar via bitcoin-dev wrote:
>> Hi,
>> Back in February I posted a proposal for WTXID-based transaction relay[1] (now known as BIP 339), which included a proposal for feature negotiation to take place prior to the VERACK message being received by each side.  In my email to this list, I had asked for feedback as to whether that proposal was problematic, and didn't receive any responses.
>> Since then, the implementation of BIP 339 has been merged into Bitcoin Core, though it has not yet been released.
>> In thinking about the mechanism used there, I thought it would be helpful to codify in a BIP the idea that Bitcoin network clients should ignore unknown messages received before a VERACK.  A draft of my proposal is available here[2].
>> I presume that software upgrading past protocol version 70016 was already planning to either implement BIP 339, or ignore the wtxidrelay message proposed in BIP 339 (if not, then this would create network split concerns in the future -- so I hope that someone would speak up if this were a problem).  When we propose future protocol upgrades that would benefit from feature negotiation at the time of connection, I think it would be nice to be able to use the same method as proposed in BIP 339, without even needing to bump the protocol version.  So having an understanding that this is the standard of how other network clients operate would be helpful.
>> If, on the other hand, this is problematic for some reason, I look forward to hearing that as well, so that we can be careful about how we deploy future p2p changes to avoid disruption.
>> Thanks,
>> Suhas Daftuar
>> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html>
>> [2] https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki <https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200818/bf38200b/attachment-0001.html>

From eric at voskuil.org  Tue Aug 18 18:11:12 2020
From: eric at voskuil.org (Eric Voskuil)
Date: Tue, 18 Aug 2020 11:11:12 -0700
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
	connections are setup
In-Reply-To: <6ccf6ff8-6b4f-c8f4-0dbb-36c5d076528f@mattcorallo.com>
References: <6ccf6ff8-6b4f-c8f4-0dbb-36c5d076528f@mattcorallo.com>
Message-ID: <95DD247F-028E-432A-9C26-6337F5819A31@voskuil.org>


> On Aug 18, 2020, at 10:26, Matt Corallo <lf-lists at mattcorallo.com> wrote:
> 
> ?There are several cases where a new message has been sent as a part of a negotiation without changing the protocol version.

Such as?

> You may chose to ignore that, but that doesn't mean that it isn't an understood and even relied upon feature of the Bitcoin P2P protocol. If you wish to fail connections to new nodes (and risk network splits, as Suhas points out), then you may do so, but that doesn't make it a part of the Bitcoin P2P protocol that you must do so. Of course there is no "official document" by which we can make a formal appeal, but historical precedent suggests otherwise.

You are misrepresenting ?historical precedent?. I?ve seen several attempts to require arbitrary traffic over the years and none have been realized.

> Still, I think we're talking pedantics here, and not in a useful way.

Not to be pedantic, but I don?t know what that means.

> Ultimately we need some kind of negotiation which is flexible in allowing different software to negotiate different features without a global lock-step version number increase.

I have shown below how that already works.

> Or, to put it another way, if a feature is fully optional, why should there be a version number increase for it

For the reasons previously given.

> - the negotiation of it is independent and a version number only increases confusion over which change "owns" a given version number.

Presumably this is why we have a standards process. Any new message implies ownership. Deconflicting that is required, which implies it can easily be version associated (as it has been).

> I presume you'd support a single message that lists the set of features which a node (optionally) wishes to support on the connection. This proposal is fully equivalent to that, instead opting to list them as individual messages instead of one message, which is a bit nicer in that they can be handled more independently or by different subsystems including even the message hashing.

This presumes an implementation. As part of the handshake, collection of an arbitrary set of messages is a significant and unnecessary complication *of the protocol*. Extension of the verack is not. It is the simplest change possible to implement the desired behavior. Each peer simply supplies the matrix of sub-protocols it supports and only those supported by both are allowed. There is no reason for the protocol to split that matrix up into multiple messages, requiring termination. Independent messages exist because of timing or ordering requirements. Implementing dependent messages as if they were independent is wasteful and complicating.

I?m well aware of the inefficiency produced by version linearity in the face of optional sub-protocols. The protocol must negotiate to the version where it can then negotiate support, which has been done. I support creating a simpler system, eliminating these extra messages. The existing numeric version can be reserved exclusively for ?must? implement, and can be used to signal an extension to the verack. The verack can then carry a list of ?may? or ?should? sub-protocols for final negotiation.

The format of the matrix is arbitrary, but the requirement is to list a set of optional sub-protocols. This implies a namespace. This implies ?ownership? of names. In other words, that coordination requirement is not eliminated.

e

> Matt
> 
>> On 8/18/20 12:54 PM, Eric Voskuil wrote:
>> ?Bitcoin protocol has always expected clients to ignore unknown messages?
>> This is not true. Bitcoin has long implemented version negotiation, which is the opposite expectation. Libbitcoin?s p2p protocol implementation immediately drops a peer that sends an invalid message according to the negotiated version. The fact that a given client does not validate the protocol does not make it an expectation that the protocol not be validated.
>> Features can clearly be optional within an actual protocol. There have been post-handshake negotiations implemented for optional messages which are valid at the negotiated version. The protocol may be flexible while remaining validateable. There is no reason to force a client to accept unknown message traffic.
>> A generalized versioning change can be implemented in or after the handshake. The latter is already done on an ad-hoc basis. The former is possible as long as the peer?s version is sufficient to be aware of the behavior. This does not imply any need to send invalid messages. The verack itself can simply be extended with a matrix of feature support. There is no reason to complicate negotiation with an additional message(s).
>> FWIW, bip37 did this poorly, adding a feature field to the version message, resulting in bip60. Due to this design, older protocol-validating clients were broken. In this case it was message length that was presumed to not be validated.
>> e
>>>> On Aug 18, 2020, at 07:59, Matt Corallo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>> 
>>> ?This sounds like a great idea!
>>> 
>>> Bitcoin is no longer a homogeneous network of one client - it is many, with different features implemented in each. The Bitcoin protocol hasn't (fully) evolved to capture that reality. Initially the Bitcoin protocol had a simple numerical version field, but that is wholly impractical for any diverse network - some clients may not wish to implement every possible new relay mechanic, and why should they have to in order to use other new features?
>>> 
>>> Bitcoin protocol changes have, many times in recent history, been made via new dummy "negotiation" messages, which take advantage of the fact that the Bitcoin protocol has always expected clients to ignore unknown messages. Given that pattern, it makes sense to have an explicit negotiation phase - after version and before verack, just send the list of features that you support to negotiate what the connection will be capable of. The exact way we do that doesn't matter much, and sending it as a stream of messages which each indicate support for a given protocol feature perfectly captures the pattern that has been used in several recent network upgrades, keeping consistency.
>>> 
>>> Matt
>>> 
>>> On 8/14/20 3:28 PM, Suhas Daftuar via bitcoin-dev wrote:
>>>> Hi,
>>>> Back in February I posted a proposal for WTXID-based transaction relay[1] (now known as BIP 339), which included a proposal for feature negotiation to take place prior to the VERACK message being received by each side.  In my email to this list, I had asked for feedback as to whether that proposal was problematic, and didn't receive any responses.
>>>> Since then, the implementation of BIP 339 has been merged into Bitcoin Core, though it has not yet been released.
>>>> In thinking about the mechanism used there, I thought it would be helpful to codify in a BIP the idea that Bitcoin network clients should ignore unknown messages received before a VERACK.  A draft of my proposal is available here[2].
>>>> I presume that software upgrading past protocol version 70016 was already planning to either implement BIP 339, or ignore the wtxidrelay message proposed in BIP 339 (if not, then this would create network split concerns in the future -- so I hope that someone would speak up if this were a problem).  When we propose future protocol upgrades that would benefit from feature negotiation at the time of connection, I think it would be nice to be able to use the same method as proposed in BIP 339, without even needing to bump the protocol version.  So having an understanding that this is the standard of how other network clients operate would be helpful.
>>>> If, on the other hand, this is problematic for some reason, I look forward to hearing that as well, so that we can be careful about how we deploy future p2p changes to avoid disruption.
>>>> Thanks,
>>>> Suhas Daftuar
>>>> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html>
>>>> [2] https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki <https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki>
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From lf-lists at mattcorallo.com  Tue Aug 18 18:25:26 2020
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Tue, 18 Aug 2020 14:25:26 -0400
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
 connections are setup
In-Reply-To: <95DD247F-028E-432A-9C26-6337F5819A31@voskuil.org>
References: <6ccf6ff8-6b4f-c8f4-0dbb-36c5d076528f@mattcorallo.com>
 <95DD247F-028E-432A-9C26-6337F5819A31@voskuil.org>
Message-ID: <995919b9-0845-3a70-4b24-9b2c1ca5fd3d@mattcorallo.com>



On 8/18/20 2:11 PM, Eric Voskuil wrote:
  - snip -
>> Still, I think we're talking pedantics here, and not in a useful way.
> 
> Not to be pedantic, but I don?t know what that means.

It means that part of the discussion is not useful, and not worth bothering to go back and figure out what was shipped 
before the version increase and what wasn't, lets talk about what makes sense for the future :).

>> Ultimately we need some kind of negotiation which is flexible in allowing different software to negotiate different features without a global lock-step version number increase.
> 
> I have shown below how that already works.
> 
>> Or, to put it another way, if a feature is fully optional, why should there be a version number increase for it
> 
> For the reasons previously given.
> 
>> - the negotiation of it is independent and a version number only increases confusion over which change "owns" a given version number.
> 
> Presumably this is why we have a standards process. Any new message implies ownership. Deconflicting that is required, which implies it can easily be version associated (as it has been).

I think the point is, this doesn't work today, bumping the protocol version requires everyone agreeing on which features 
make sense, and as we can see from this email thread alone, that isn't a common result in this community. People happily 
ignore BIPs that make no sense, of which there are a lot, and they should totally be able to do that!

You can say that the current world works, but there's a reason over time we've shifted away from the original "shove 
another bit on the end of the version message, and everyone agrees on the order of those bits for new feature 
negotiation." Version bumping is an extension of that, really.

>> I presume you'd support a single message that lists the set of features which a node (optionally) wishes to support on the connection. This proposal is fully equivalent to that, instead opting to list them as individual messages instead of one message, which is a bit nicer in that they can be handled more independently or by different subsystems including even the message hashing.
> 
> This presumes an implementation. As part of the handshake, collection of an arbitrary set of messages is a significant and unnecessary complication *of the protocol*. Extension of the verack is not. It is the simplest change possible to implement the desired behavior. Each peer simply supplies the matrix of sub-protocols it supports and only those supported by both are allowed. There is no reason for the protocol to split that matrix up into multiple messages, requiring termination. Independent messages exist because of timing or ordering requirements. Implementing dependent messages as if they were independent is wasteful and complicating.

Some things may need further negotiation. eg compact blocks sends multiple redundant messages with different versions 
and then deduces the correct version based on the message ordering and version set supported. Doing this via verack 
locks you into a very specific possible negotiation protocols. You could extend it further and suggest a verack K-V list 
which allows for more flexible negotiation, but I'm not sure that it isn't more complicated than just shoving more 
messages on the wire.

> I?m well aware of the inefficiency produced by version linearity in the face of optional sub-protocols. The protocol must negotiate to the version where it can then negotiate support, which has been done. I support creating a simpler system, eliminating these extra messages. The existing numeric version can be reserved exclusively for ?must? implement, and can be used to signal an extension to the verack. The verack can then carry a list of ?may? or ?should? sub-protocols for final negotiation.

I think we agree here - the current method of protocol version bumping isn't scalable and something more flexible is 
definitely a better world.

> The format of the matrix is arbitrary, but the requirement is to list a set of optional sub-protocols. This implies a namespace. This implies ?ownership? of names. In other words, that coordination requirement is not eliminated.

This is true, there is some ownership requirement, we could switch to hashes or something of the like, but 
human-readable names have shown to be relatively non-colliding in past Bitcoin protocol changes.

> e
> 
>> Matt
>>
>>> On 8/18/20 12:54 PM, Eric Voskuil wrote:
>>> ?Bitcoin protocol has always expected clients to ignore unknown messages?
>>> This is not true. Bitcoin has long implemented version negotiation, which is the opposite expectation. Libbitcoin?s p2p protocol implementation immediately drops a peer that sends an invalid message according to the negotiated version. The fact that a given client does not validate the protocol does not make it an expectation that the protocol not be validated.
>>> Features can clearly be optional within an actual protocol. There have been post-handshake negotiations implemented for optional messages which are valid at the negotiated version. The protocol may be flexible while remaining validateable. There is no reason to force a client to accept unknown message traffic.
>>> A generalized versioning change can be implemented in or after the handshake. The latter is already done on an ad-hoc basis. The former is possible as long as the peer?s version is sufficient to be aware of the behavior. This does not imply any need to send invalid messages. The verack itself can simply be extended with a matrix of feature support. There is no reason to complicate negotiation with an additional message(s).
>>> FWIW, bip37 did this poorly, adding a feature field to the version message, resulting in bip60. Due to this design, older protocol-validating clients were broken. In this case it was message length that was presumed to not be validated.
>>> e
>>>>> On Aug 18, 2020, at 07:59, Matt Corallo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>
>>>> ?This sounds like a great idea!
>>>>
>>>> Bitcoin is no longer a homogeneous network of one client - it is many, with different features implemented in each. The Bitcoin protocol hasn't (fully) evolved to capture that reality. Initially the Bitcoin protocol had a simple numerical version field, but that is wholly impractical for any diverse network - some clients may not wish to implement every possible new relay mechanic, and why should they have to in order to use other new features?
>>>>
>>>> Bitcoin protocol changes have, many times in recent history, been made via new dummy "negotiation" messages, which take advantage of the fact that the Bitcoin protocol has always expected clients to ignore unknown messages. Given that pattern, it makes sense to have an explicit negotiation phase - after version and before verack, just send the list of features that you support to negotiate what the connection will be capable of. The exact way we do that doesn't matter much, and sending it as a stream of messages which each indicate support for a given protocol feature perfectly captures the pattern that has been used in several recent network upgrades, keeping consistency.
>>>>
>>>> Matt
>>>>
>>>> On 8/14/20 3:28 PM, Suhas Daftuar via bitcoin-dev wrote:
>>>>> Hi,
>>>>> Back in February I posted a proposal for WTXID-based transaction relay[1] (now known as BIP 339), which included a proposal for feature negotiation to take place prior to the VERACK message being received by each side.  In my email to this list, I had asked for feedback as to whether that proposal was problematic, and didn't receive any responses.
>>>>> Since then, the implementation of BIP 339 has been merged into Bitcoin Core, though it has not yet been released.
>>>>> In thinking about the mechanism used there, I thought it would be helpful to codify in a BIP the idea that Bitcoin network clients should ignore unknown messages received before a VERACK.  A draft of my proposal is available here[2].
>>>>> I presume that software upgrading past protocol version 70016 was already planning to either implement BIP 339, or ignore the wtxidrelay message proposed in BIP 339 (if not, then this would create network split concerns in the future -- so I hope that someone would speak up if this were a problem).  When we propose future protocol upgrades that would benefit from feature negotiation at the time of connection, I think it would be nice to be able to use the same method as proposed in BIP 339, without even needing to bump the protocol version.  So having an understanding that this is the standard of how other network clients operate would be helpful.
>>>>> If, on the other hand, this is problematic for some reason, I look forward to hearing that as well, so that we can be careful about how we deploy future p2p changes to avoid disruption.
>>>>> Thanks,
>>>>> Suhas Daftuar
>>>>> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html>
>>>>> [2] https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki <https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki>
>>>>> _______________________________________________
>>>>> bitcoin-dev mailing list
>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From eric at voskuil.org  Tue Aug 18 18:56:13 2020
From: eric at voskuil.org (Eric Voskuil)
Date: Tue, 18 Aug 2020 11:56:13 -0700
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
	connections are setup
In-Reply-To: <995919b9-0845-3a70-4b24-9b2c1ca5fd3d@mattcorallo.com>
References: <995919b9-0845-3a70-4b24-9b2c1ca5fd3d@mattcorallo.com>
Message-ID: <CE6A0401-8503-4E0C-8857-32E624CA1D28@voskuil.org>


> On Aug 18, 2020, at 11:25, Matt Corallo <lf-lists at mattcorallo.com> wrote:
> 
> On 8/18/20 2:11 PM, Eric Voskuil wrote:
> - snip -
>>> Still, I think we're talking pedantics here, and not in a useful way.
>> Not to be pedantic, but I don?t know what that means.
> 
> It means that part of the discussion is not useful, and not worth bothering to go back and figure out what was shipped before the version increase and what wasn't, lets talk about what makes sense for the future :).

When the discussion centers on backward compatibility, and there is confusion over what that actually implies, this is a central question. You snipped the bit about what actually constitutes the existing protocol. I have implemented every aspect of the protocol that is widely deployed, and I can say without question that the protocol does not require a peer to accept arbitrary messages. In other words, your statement on the subject was a very relevant factual error. Furthermore no reason has been demonstrated here to accept arbitrary traffic.

>>> Ultimately we need some kind of negotiation which is flexible in allowing different software to negotiate different features without a global lock-step version number increase.
>> I have shown below how that already works.
>>> Or, to put it another way, if a feature is fully optional, why should there be a version number increase for it
>> For the reasons previously given.
>>> - the negotiation of it is independent and a version number only increases confusion over which change "owns" a given version number.
>> Presumably this is why we have a standards process. Any new message implies ownership. Deconflicting that is required, which implies it can easily be version associated (as it has been).
> 
> I think the point is, this doesn't work today, bumping the protocol version requires everyone agreeing on which features make sense,

As I have shown, this is not the case. While I have given my support to simplifying the process, we should not proceed based on an incorrect understanding of actual behavior.

> and as we can see from this email thread alone, that isn't a common result in this community. People happily ignore BIPs that make no sense, of which there are a lot, and they should totally be able to do that!
> 
> You can say that the current world works, but there's a reason over time we've shifted away from the original "shove another bit on the end of the version message, and everyone agrees on the order of those bits for new feature negotiation." Version bumping is an extension of that, really.

Actually the protocol has not done this. It has used the version to signal a new sub-protocol, and then in some cases that sub-protocol has been made optional through subsequent negotiation. What is being proposed here is to simplify that process by collapsing the secondary negotiation into the handshake.

In fact I argued against this secondary ad-hoc negotiation when it began. Now we are coming around to recognizing that it?s a handshake issue, as I said at the time. I?m glad to see that.

>>> I presume you'd support a single message that lists the set of features which a node (optionally) wishes to support on the connection. This proposal is fully equivalent to that, instead opting to list them as individual messages instead of one message, which is a bit nicer in that they can be handled more independently or by different subsystems including even the message hashing.
>> This presumes an implementation. As part of the handshake, collection of an arbitrary set of messages is a significant and unnecessary complication *of the protocol*. Extension of the verack is not. It is the simplest change possible to implement the desired behavior. Each peer simply supplies the matrix of sub-protocols it supports and only those supported by both are allowed. There is no reason for the protocol to split that matrix up into multiple messages, requiring termination. Independent messages exist because of timing or ordering requirements. Implementing dependent messages as if they were independent is wasteful and complicating.
> 
> Some things may need further negotiation. eg compact blocks sends multiple redundant messages with different versions and then deduces the correct version based on the message ordering and version set supported. Doing this via verack locks you into a very specific possible negotiation protocols.

This is a moot point. Whether a list of supported optional sub-protocols is listed in one or multiple messages in the handshake would not change this.

> You could extend it further and suggest a verack K-V list which allows for more flexible negotiation, but I'm not sure that it isn't more complicated than just shoving more messages on the wire.

There is no difference between a constrained set of key-value pairs and a distinct set of options, so there is no additional complexity here.

>> I?m well aware of the inefficiency produced by version linearity in the face of optional sub-protocols. The protocol must negotiate to the version where it can then negotiate support, which has been done. I support creating a simpler system, eliminating these extra messages. The existing numeric version can be reserved exclusively for ?must? implement, and can be used to signal an extension to the verack. The verack can then carry a list of ?may? or ?should? sub-protocols for final negotiation.
> 
> I think we agree here - the current method of protocol version bumping isn't scalable and something more flexible is definitely a better world.

To be clear this does not increase flexibility, it reduces communication and therefore complexity, and allows peers to lock in allowed message semantics by the end of the handshake, as opposed to allowing them to change at any time.

>> The format of the matrix is arbitrary, but the requirement is to list a set of optional sub-protocols. This implies a namespace. This implies ?ownership? of names. In other words, that coordination requirement is not eliminated.
> 
> This is true, there is some ownership requirement, we could switch to hashes or something of the like, but human-readable names have shown to be relatively non-colliding in past Bitcoin protocol changes.

Hashes don?t prevent collisions. Someone can just use the same hash. Bitcoin uses names (message names) and numbers (version, service, relay...). It?s a protocol, coordination is the whole point.

e

>> e
>>> Matt
>>> 
>>>> On 8/18/20 12:54 PM, Eric Voskuil wrote:
>>>> ?Bitcoin protocol has always expected clients to ignore unknown messages?
>>>> This is not true. Bitcoin has long implemented version negotiation, which is the opposite expectation. Libbitcoin?s p2p protocol implementation immediately drops a peer that sends an invalid message according to the negotiated version. The fact that a given client does not validate the protocol does not make it an expectation that the protocol not be validated.
>>>> Features can clearly be optional within an actual protocol. There have been post-handshake negotiations implemented for optional messages which are valid at the negotiated version. The protocol may be flexible while remaining validateable. There is no reason to force a client to accept unknown message traffic.
>>>> A generalized versioning change can be implemented in or after the handshake. The latter is already done on an ad-hoc basis. The former is possible as long as the peer?s version is sufficient to be aware of the behavior. This does not imply any need to send invalid messages. The verack itself can simply be extended with a matrix of feature support. There is no reason to complicate negotiation with an additional message(s).
>>>> FWIW, bip37 did this poorly, adding a feature field to the version message, resulting in bip60. Due to this design, older protocol-validating clients were broken. In this case it was message length that was presumed to not be validated.
>>>> e
>>>>>> On Aug 18, 2020, at 07:59, Matt Corallo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>> 
>>>>> ?This sounds like a great idea!
>>>>> 
>>>>> Bitcoin is no longer a homogeneous network of one client - it is many, with different features implemented in each. The Bitcoin protocol hasn't (fully) evolved to capture that reality. Initially the Bitcoin protocol had a simple numerical version field, but that is wholly impractical for any diverse network - some clients may not wish to implement every possible new relay mechanic, and why should they have to in order to use other new features?
>>>>> 
>>>>> Bitcoin protocol changes have, many times in recent history, been made via new dummy "negotiation" messages, which take advantage of the fact that the Bitcoin protocol has always expected clients to ignore unknown messages. Given that pattern, it makes sense to have an explicit negotiation phase - after version and before verack, just send the list of features that you support to negotiate what the connection will be capable of. The exact way we do that doesn't matter much, and sending it as a stream of messages which each indicate support for a given protocol feature perfectly captures the pattern that has been used in several recent network upgrades, keeping consistency.
>>>>> 
>>>>> Matt
>>>>> 
>>>>> On 8/14/20 3:28 PM, Suhas Daftuar via bitcoin-dev wrote:
>>>>>> Hi,
>>>>>> Back in February I posted a proposal for WTXID-based transaction relay[1] (now known as BIP 339), which included a proposal for feature negotiation to take place prior to the VERACK message being received by each side.  In my email to this list, I had asked for feedback as to whether that proposal was problematic, and didn't receive any responses.
>>>>>> Since then, the implementation of BIP 339 has been merged into Bitcoin Core, though it has not yet been released.
>>>>>> In thinking about the mechanism used there, I thought it would be helpful to codify in a BIP the idea that Bitcoin network clients should ignore unknown messages received before a VERACK.  A draft of my proposal is available here[2].
>>>>>> I presume that software upgrading past protocol version 70016 was already planning to either implement BIP 339, or ignore the wtxidrelay message proposed in BIP 339 (if not, then this would create network split concerns in the future -- so I hope that someone would speak up if this were a problem).  When we propose future protocol upgrades that would benefit from feature negotiation at the time of connection, I think it would be nice to be able to use the same method as proposed in BIP 339, without even needing to bump the protocol version.  So having an understanding that this is the standard of how other network clients operate would be helpful.
>>>>>> If, on the other hand, this is problematic for some reason, I look forward to hearing that as well, so that we can be careful about how we deploy future p2p changes to avoid disruption.
>>>>>> Thanks,
>>>>>> Suhas Daftuar
>>>>>> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html>
>>>>>> [2] https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki <https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki>
>>>>>> _______________________________________________
>>>>>> bitcoin-dev mailing list
>>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>> _______________________________________________
>>>>> bitcoin-dev mailing list
>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From thomashartman1 at gmail.com  Wed Aug 19 21:15:08 2020
From: thomashartman1 at gmail.com (Thomas Hartman)
Date: Wed, 19 Aug 2020 17:15:08 -0400
Subject: [bitcoin-dev] reviving op_difficulty
In-Reply-To: <CAE-z3OVCcAL2x39TswA8zrZ+yjSqdx4hccTWn9Ug8MQ5=k-Pgg@mail.gmail.com>
References: <CAHAXnDXhAFQHiBCJ=H=1ZGHdHWhgLh1rG3pCPR5o48ziZzV+zQ@mail.gmail.com>
 <CAE-z3OVCcAL2x39TswA8zrZ+yjSqdx4hccTWn9Ug8MQ5=k-Pgg@mail.gmail.com>
Message-ID: <C4A9F1FC-8BD9-4A03-806B-5091375090B5@gmail.com>



> On Aug 16, 2020, at 2:59 PM, Tier Nolan via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Output 0:  Pay Alice if diff < 1.00 trillion else Bob

What is included in blocks is a packed representation of the difficulty target, not the difficulty per se as typically reported on blockchain explorer. 

https://en.bitcoin.it/wiki/Difficulty <https://en.bitcoin.it/wiki/Difficulty>

Perhaps what is best for speculation contracts is not the difficulty per se, but the ratio between some unknown future difficulty and the current difficulty. That is easily obtained from the packed representations already included in blocks. IE

Current difficulty / last difficulty = 1 / ( current target / last target )

To give a worked example, current difficulty is 16.94T, and last difficulty was 16.84T. 
Current packed target is 0x17109bac, last packed target is  0x1710b4f8	
16.94 / 16.84 is same as 1 / ( 0x109ba / 0x10b4f8  )  (the 17 is an exponent in both cases so leaving it out for clarity). 

So perhaps the way op_diff should work is take 2 packed targets, 1 known and 1 unknown at time of contract, and return the ratio. 

The contract could then work as previously described, except using the ratio for ticks instead of the difficulty.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200819/4a4b1a9f/attachment.html>

From bitcoin-dev at wuille.net  Wed Aug 19 23:16:17 2020
From: bitcoin-dev at wuille.net (Pieter Wuille)
Date: Wed, 19 Aug 2020 23:16:17 +0000
Subject: [bitcoin-dev] Revisiting squaredness tiebreaker for R point in
	BIP340
In-Reply-To: <g7VgKBKlUmgMkNo6Nq1OkyilwW6Z4WbqeSZHXfvh_LDYmry5R7uGbavyEHtv2xr_0KBevL057TxSdlo_tS0_ucBXYNm8MuTu_jgyrGO9jpo=@wuille.net>
References: <g7VgKBKlUmgMkNo6Nq1OkyilwW6Z4WbqeSZHXfvh_LDYmry5R7uGbavyEHtv2xr_0KBevL057TxSdlo_tS0_ucBXYNm8MuTu_jgyrGO9jpo=@wuille.net>
Message-ID: <ELtsqlQfq8t4RW8xGmoSgVO0NMYPUQx92wE308PGeIAo7t3Tu0CLpzwigPLi0Hh5IOC-iRtW965d3l8Ahgl0e4LpCuUymsS6RdBCXNCibs8=@wuille.net>

On Wednesday, August 12, 2020 11:49 AM, Pieter Wuille <bitcoin-dev at wuille.net> wrote:

> It is late in the process, but I feel I owe this explanation so that at least the possibility of changing can be discussed with all information.

As the responses have been pretty positive so far, we've gone ahead and made a patch to implement the change to the even tiebreaker: https://github.com/sipa/bips/pull/210

If there are no other arguments (against), I'll PR it to the BIPs repo in a week or so.

All comments/questions/... still welcome.

Cheers,

--
Pieter


From thomashartman1 at gmail.com  Wed Aug 19 23:32:25 2020
From: thomashartman1 at gmail.com (Thomas Hartman)
Date: Wed, 19 Aug 2020 19:32:25 -0400
Subject: [bitcoin-dev] reviving op_difficulty
In-Reply-To: <C4A9F1FC-8BD9-4A03-806B-5091375090B5@gmail.com>
References: <CAHAXnDXhAFQHiBCJ=H=1ZGHdHWhgLh1rG3pCPR5o48ziZzV+zQ@mail.gmail.com>
 <CAE-z3OVCcAL2x39TswA8zrZ+yjSqdx4hccTWn9Ug8MQ5=k-Pgg@mail.gmail.com>
 <C4A9F1FC-8BD9-4A03-806B-5091375090B5@gmail.com>
Message-ID: <1EE02345-9A45-427F-AE13-6E96FD25B55E@gmail.com>

> 
> So perhaps the way op_diff should work is take 2 packed targets, 1 known and 1 unknown at time of contract, and return the ratio. 

On second thought, I don?t think this is a good idea. The 32-bit packed difficulty target is equivalent to difficulty, and this is probably what should get pushed onto the stack. No division is needed, just the arithmetic less than operator, which is already live in script, using the tick strategy described by Tier. So it seems to me these contracts could truly be done with the addition of the single op_diff opcode. It?s probably less human readable to be using difficulty target instead of difficulty, but no one reads script anyway. 

It was also bothering me that difficulty was a floating point number (I have floating point phobia), so it is great not to have to think about floats anymore!


From ZmnSCPxj at protonmail.com  Thu Aug 20 11:17:07 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 20 Aug 2020 11:17:07 +0000
Subject: [bitcoin-dev] Detailed protocol design for routed
	multi-transaction CoinSwap
In-Reply-To: <813e51a1-4252-08c0-d42d-5cef32f684bc@riseup.net>
References: <813e51a1-4252-08c0-d42d-5cef32f684bc@riseup.net>
Message-ID: <xhRsCejqgUjoLy5hPMHgFcZdiqJsO7TfS0azWhis9-tvSgXodoKe7gN5IXyiVIVqUWSm7FoY-aBUaJCCDgixdWUN4n8EzhQlSNshsQeIFsw=@protonmail.com>

Good morning Chris,

Great to see this!

Mostly minor comments.



>
> == Direct connections to Alice ===
>
> Only Alice, the taker, knows the entire route, Bob and Charlie just know
> their previous and next transactions. Bob and Charlie do not have direct
> connections with each other, only with Alice.
>
> Diagram of Tor connections:
>
> Bob Charlie
> | /
> | /
> | /
> Alice
>
> When Bob and Charlie communicate, they are actually sending and
> receiving messages via Alice who relays them to Charlie or Bob. This
> helps hide whether the previous or next counterparty in a CoinSwap route
> is a maker or taker.
>
> This doesn't have security issues even in the final steps where private
> keys are handed over, because those private keys are always for 2-of-2
> multisig and so on their own are never enough to steal money.

This has a massive advantage over CoinJoin.

In CoinJoin, since all participants sign a single transaction, every participant knows the total number of participants.
Thus, in CoinJoin, it is fairly useless to have just one taker and one maker, the maker knows exactly which output belongs to the taker.
Even if all communications were done via the single paying taker, the maker(s) are shown the final transaction and thus can easily know how many participants there are (by counting the number of equal-valued outputs).

With CoinSwap, in principle no maker has to know how many other makers are in the swap.

Thus it would still be useful to make a single-maker CoinSwap, as that would be difficult, for the maker, to diferentiate from a multi-maker CoinSwap.

There are still a few potential leaks though:

* If paying through a CoinSwap, the cheapest option for the taker would be to send out a single large UTXO (single-output txes) to the first maker, and then demand the final payment and any change as two separate swaps from the final maker.
  * Intermediate makers are likely to not have exact amounts, thus is unlikely to create a single-output tx when forwarding.
  * Thus, the first maker could identify the taker.
* The makers can try timing the communications lag with the taker.
  The general assumption would be that more makers == more delay in taker responses.



>
> === Miner fees ===
>
> Makers have no incentive to pay any miner fees. They only do
> transactions which earn them an income and are willing to wait a very
> long time for that to happen. By contrast takers want to create
> transactions far more urgently. In JoinMarket we coded a protocol where
> the maker could contribute to miner fees, but the market price offered
> of that trended towards zero. So the reality is that takers will pay all
> the miner fees. Also because makers don't know the taker's time
> preference they don't know how much they should pay in miner fees.
>
> The taker will have to set limits on how large the maker's transactions
> are, otherwise makers could abuse this by having the taker consolidate
> maker's UTXOs for free.

Why not have the taker pay for the *first* maker-spent UTXO and have additional maker-spent UTXOs paid for by the maker?
i.e. the taker indicates "swap me 1 BTC in 3 bags of 0.3, 0.3, and 0.4 BTC", and pays for one UTXO spent for each "bag" (thus pays for 3 UTXOs).

Disagreements on feerate can be resolved by having the taker set the feerate, i.e. "the customer is always right".
Thus if the maker *has to* spend two UTXOs to make up the 0.4 BTC bag, it pays for the mining fees for that extra UTXO.
The maker can always reject the swap attempt if it *has to* spend multiple UTXOs and would lose money doing so if the taker demands a too-high feerate.


> == Contract transaction definitions ==
>
> Contract transactions are those which may spend from the 2-of-2 multisig
> outputs, they transfer the coins into a contract where the coins can be
> spent either by waiting for a timeout or providing a hash preimage
> value. Ideally contract transactions will never be broadcast but their
> existence keeps all parties honest.
>
> M~ is miner fees, which we treat as a random variable, and ultimately
> set by whichever pre-signed RBF tx get mined. When we talk about the
> contract tx, we actually mean perhaps 20-30 transactions which only
> differ by the miner fee and have RBF enabled, so they can be broadcasted
> in sequence to get the contract transaction mined regardless of the
> demand for block space.

The highest-fee version could have, in addition, CPFP-anchor outputs, like those being proposed in Lightning, so even if onchain fees rise above the largest fee reservation, it is possible to add even more fees.

Or not.
Hmm.


Another thought: later you describe that miner fees are paid by Alice by forwarding those fees as well, how does that work when there are multiple versions of the contract transaction?

>
> (Alice+timelock_A OR Bob+hash) = Is an output which can be spent
> either with Alice's private key
> after waiting for a relative
> timelock_A, or by Bob's private key by
> revealing a hash preimage value

The rationale for relative timelocks is that it makes private key turnover slightly more useable by ensuring that, after private key turnover, it is possible to wait indefinitely to spend the UTXO it received.
This is in contrast with absolute timelocks, where after private key turnover, it is required to spend received UTXO before the absolute timeout.

The dangers are:

* Until it receives the private key, if either of the incoming or outgoing contract transactions are confirmed, every swap participant (taker or maker) should also broadcast the other contract transaction, and resolve by onchain transactions (with loss of privacy).
* After receiving the private key, if the incoming contract transaction is confirmed, it should spend the resulting contract output.
* It is possible to steal from a participant if that participant goes offline longer than the timeout.
  This may imply that there may have to be some minimum timeout that makers indicate in their advertisements.
  * The taker can detect if the first maker is offline, then if it is offline, try a contract transaction broadcast, if it confirms, the taker can wait for the timeout; if it times out, the taker can clawback the transaction.
    * This appears to be riskless for the taker.
    * Against a similar attack, Lightning requires channel reserves, which means the first hop never gains control of the entire value, which is a basic requirement for private key turnover.
  * On the other hand, the taker has the largest timeout before it can clawback the funds, so it would wait for a long time, and at any time in between the first maker can come online and spend using the hashlock branch.
    * But the taker can just try on the hope it works; it has nothing to lose.
  * This attack seems to be possible only for the taker to mount.
    Other makers on the route cannot know who the other makers are, without cooperation of the taker, who is the only one who knows all the makers.
    * On the other hand, the last maker in the route has an outgoing HTLC with the smallest timelock, so it is the least-risk and therefore a maker who notices its outgoing HTLC has a low timeout might want to just do this anyway even if it is unsure if the taker is offline.
  * Participants might want to spend from the UTXO to a new address after private key turnover anyway.
    Makers could spend using a low-fee RBF-enabled tx, and when another request comes in for another swap, try to build a new funding tx with a higher-fee bump.


> A possible attack by a malicious Alice is that she chooses M1 to be very
> low (e.g. 1 sat/vbyte) and sets M2 and M3 to be very high (e.g. 1000
> sat/vb) and then intentionally aborts, forcing the makers to lose much
> more money in miner fees than the attacker. The attack can be used to
> waste away Bob's and Charlie's coins on miner fees at little cost to the
> malicious taker Alice. So to defend against this attack Bob and Charlie
> must refuse to sign a contract transaction if the corresponding funding
> transaction pays miner fees greater than Alice's funding transaction.

Sorry, I do not follow the logic for this...?

> The timelocks are staggered so that if Alice uses the preimage to take
> coins then the right people will also learn the preimage and have enough
> time to be able to get their coins back too. Alice starts with knowledge
> of the hash preimage so she must have a longest timelock.

More precisely:

* The HTLC outgoing from Alice has the longest timelock.
* The HTLC incoming into Alice has the shortest timelock.

For the makers, they only need to ensure that the incoming timelock is much larger than the outgoing timelock.


>
> == EC tweak to reduce one round trip ==
>
> When two parties are agreeing on a 2-of-2 multisig address, they need to
> agree on their public keys. We can avoid one round trip by using the EC
> tweak trick.
>
> When Alice, the taker, downloads the entire offer book for the liquidity
> market, the offers will also contain a EC public key. Alice can tweak
> this to generate a brand new public key for which the maker knows the
> private key. This public key will be one of the keys in the 2-of-2
> multisig. This feature removes one round trip from the protocol.
>
> q = EC privkey generated by maker
> Q = q.G = EC pubkey published by maker
>
> p = nonce generated by taker
> P = p.G = nonce point calculated by taker
>
> R = Q + P = pubkey used in bitcoin transaction
> = (q + p).G

Whoa whoa whoa whoa.

All this time I was thinking you were going to use 2p-ECDSA for all 2-of-2s.
In which case, the private key generated by the taker would be sufficient tweak to blind this.

In 2p-ECDSA, for two participants M = m * G; T = t * G, the total key is m * t * G = m * T = t * M.

Are you going to use `2 <T> <Q+P> 2 OP_CHECKMULTISIG` instead of 2p-ECDSA?
Note that you cannot usefully hide among Lightning mutual closes, because of the reserve; Lightning mutual closes are very very likely to be spent in a 1-input (that spends from a 2-of-2 P2WSH), 2-output (that pays to two P2WPKHs) tx.

>
> == Protocol ==

> ---8<------

The protocol looks correct to me.

LOL.

Give me a little more time to check it in detail hahaha.



>     ==== Retaliation as DOS-resistance ====
>
>     In some situations (e.g. step 8.) if one maker in the coinswap route is
>     the victim of a DOS they will retaliate by DOSing the previous maker in
>     the route. This may seem unnecessary and unfair (after all why waste
>     even more time and block space) but is actually the best way to resist
>     DOS because it produces a concrete cost every time a DOS happens.

I agree.

>
>     == Analysis of deviations ==
>
>     This section discusses what happens if one party deviates from the
>     protocol by doing something else, for example broadcasting a htlc
>     contract tx when they shouldnt have.
>
>     The party name refers to what that party does, followed by other party's
>     reactions to it.
>     e.g. Party1: does a thing, Party2/Party3: does a thing in reaction
>
>     If multiple deviations are possible in a step then they are numbered
>     e.g. A1 A2 A2 etc
>
>     0-2. Alice/Bob/Charlie: nothing else is possible except following the
>     protocol or aborting
>
> 8.  Alice: broadcasts one or more of the A htlc txes. Bob/Charlie/Dennis:
>     do nothing, they havent lost any time or money.
>     4-6. Bob/Charlie: nothing else is possible except following the protocol
>     or aborting.
>
> 9.  Bob: broadcasts one or more of the B htlc txes, Alice: broadcasts all
>     her own A htlc txes and waits for the timeout to get her money back.
>     Charlie: do nothing
>
> 10.  Charlie: nothing else is possible except following the protocol or
>     aborting.
>
> 11.  Alice: broadcasts one or more of the A htlc txes. Bob: broadcasts all
>     his own A htlc txes and waits for the timeout.
>     A. same as 8.
>     B. Charlie: broadcasts one or more of the C htlc txes, Alice/Bob:
>     broadcasts all their own htlc txes and waits for the timeout to get
>     their money back.
>     C-E1. Alice: broadcasts all of C htlc txes and uses her knowledge of the
>     preimage hash to take the money immediately. Charlie: broadcasts
>     all of B htlc txes and reading the hash value from the blockchain,
>     uses it to take the money from B htlc immediately. Bob: broadcasts
>     all of A htlc txes, and reading hash from the blockchain, uses it
>     to take the money from A htlc immediately.
>     C-E2. Alice: broadcast her own A htlc txes, and after a timeout take the
>     money. Bob: broadcast his own B htlc txes and after the timeout
>     take their money. Charlie: broadcast his own C htlc txes and after
>     the timeout take their money.
>     F1. Bob: broadcast one or more of A htcl txes and use the hash preimage
>     to get the money immediately. He already knows both privkeys of the
>     multisig so this is pointless and just damages privacy and wastes
>     miner fees. Alice: blacklist Bob's fidelity bond.
>     F2. Bob: broadcast one or more of the C htlc txes. Charlie: use preimage
>     to get his money immediately. Bob's actions were pointless. Alice:
>     cant tell whether Bob or Charlie actually broadcasted, so blacklist
>     both fidelity bonds.
>     G1. Charlie: broadcast one or more of B htcl txes and use the hash
>     preimage to get the money immediately. He already knows both
>     privkeys of the multisig so this is pointless and just damages
>     privacy and wastes miner fees. Alice: cant tell whether Bob or
>     Charlie actually broadcasted, so blacklist both fidelity bonds.
>     G2. Charlie: broadcast one or more of the A htlc txes. Alice: broadcast
>     the remaining A htlc txes and use preimage to get her money
>     immediately. Charlies's actions were pointless. Alice: blacklist
>     Charlie's fidelity bond.
>
>     The multisig outputs of the funding transactions can stay unspent
>     indefinitely. However the parties must always be watching the network
>     and ready to respond with their own sweep using a preimage. This is
>     because the other party still possesses a fully-signed contract tx. The
>     parties respond in the same way as in steps C-E1, F2 and G2. Alice's
>     reaction of blacklisting both fidelity bonds might not be the right way,
>     because one maker could use it to get another one blacklisted (as well
>     as themselves).

Looks OK, though note that a participant might try to do so (as pointed out above) in the hope that the next participant is offline.

Thank you very much for your writeup!

Regards,
ZmnSCPxj

From dave at dtrt.org  Thu Aug 20 14:13:39 2020
From: dave at dtrt.org (David A. Harding)
Date: Thu, 20 Aug 2020 10:13:39 -0400
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
 connections are setup
In-Reply-To: <C18E3371-C27A-41CD-B81F-6C96FA210494@voskuil.org>
References: <CAFp6fsE=HPFUMFhyuZkroBO_QJ-dUWNJqCPg9=fMJ3Jqnu1hnw@mail.gmail.com>
 <C18E3371-C27A-41CD-B81F-6C96FA210494@voskuil.org>
Message-ID: <20200820141339.gbbr5rewi4yvoarl@ganymede>

On Sun, Aug 16, 2020 at 12:06:55PM -0700, Eric Voskuil via bitcoin-dev wrote:
> A requirement to ignore unknown (invalid) messages is [...] a protocol
> breaking change 

I don't think it is.  The proposed BIP, as currently written, only tells
nodes to ignore unknown messages during peer negotiation.  The only case
where this will happen so far is BIP339, which says:

    The wtxidrelay message must be sent in response to a VERSION message
    from a peer whose protocol version is >= 70016, and prior to sending
    a VERACK

So unless you signal support for version >=70016, you'll never receive an
unknown message.  (And, if you do signal, you probably can't claim that
you were unaware of this new requirement, unless you were using a
non-BIP protocol like xthin[1]).

However, perhaps this new proposed BIP could be a bit clearer about its
expectations for future protocol upgrades by saying something like:

    Nodes implementing this BIP MUST also not send new negotiation
    message types to nodes whose protocol version is less than 70017.

That should promote backwards compatibility.  If you don't want to
ignore unknown negotiation messages between `version` and `verack`, you
can just set your protocol version to a max of 70016.

> A requirement to ignore unknown (invalid) messages is [...] poor
> protocol design. The purpose of version negotiation is to determine
> the set of valid messages. 

To be clear, the proposed requirement to ignore unknown messages is
limited in scope to the brief negotiation phase between `version` and
`verack`.  If you want to terminate connections (or do whatever) on
receipt of an unknown message, you can do that at any other time.

> Changes to version negotiation itself are very problematic.

For whom?

> The only limitation presented by versioning is that the system is
> sequential. 

That seems like a pretty significant limitation to decentralized
protocol development.

I think there are currently several people who want to run long-term
experiements for new protocol features using open source opt-in
codebases that anyone can run, and it would be advantageous to them to
have a flexible and lightweight feature negotiation system like this
proposed method.

> As such, clients that do not wish to implement (or operators who do
> not wish to enable) them are faced with a problem when wanting to
> support later features. This is resolvable by making such features
> optional at the new protocol level. This allows each client to limit
> its communication to the negotiated protocol, and allows ignoring of
> known but unsupported/disabled features.

I don't understand this.  How do two peers negotiate a set of two or
more optional features using only the exchange of single numbers?  For
example:

- Node A supports Feature X (implemented in protocol version 70998) and Feature Y (version 70999).

- Node B does not support X but does want to use Y; what does it use for its
  protocol version number when establishing a connection with node A?

---

Overall, I like the proposed BIP and the negotiation method it
describes.

Cheers,

-Dave

[1] This is not a recommendation for xthin, but I do think it's an example
    of the challenges of using a shared linear version number scheme for
    protocol negotiation in a decentralized system where different teams
    don't necessarily get along well with each other.
    https://github.com/ptschip/bitcoinxt/commit/7ea5854a3599851beffb1323544173f03d45373b#diff-c61070c281aed6ded69036c08bd08addR12
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200820/faec9a70/attachment.sig>

From nadav at suredbits.com  Thu Aug 20 15:28:56 2020
From: nadav at suredbits.com (Nadav Kohen)
Date: Thu, 20 Aug 2020 10:28:56 -0500
Subject: [bitcoin-dev] Detailed protocol design for routed
 multi-transaction CoinSwap
In-Reply-To: <xhRsCejqgUjoLy5hPMHgFcZdiqJsO7TfS0azWhis9-tvSgXodoKe7gN5IXyiVIVqUWSm7FoY-aBUaJCCDgixdWUN4n8EzhQlSNshsQeIFsw=@protonmail.com>
References: <813e51a1-4252-08c0-d42d-5cef32f684bc@riseup.net>
 <xhRsCejqgUjoLy5hPMHgFcZdiqJsO7TfS0azWhis9-tvSgXodoKe7gN5IXyiVIVqUWSm7FoY-aBUaJCCDgixdWUN4n8EzhQlSNshsQeIFsw=@protonmail.com>
Message-ID: <CALGTLwPOhHwXULLOhpEzbKxb0V-kjZWLRdnZ90T9RWxFSwuu4w@mail.gmail.com>

Hey Chris and all,

Looking good :) I have one major concern though

>    q = EC privkey generated by maker
>    Q = q.G = EC pubkey published by maker
>
>    p = nonce generated by taker
>    P = p.G = nonce point calculated by taker
>
>    R = Q + P = pubkey used in bitcoin transaction
>      = (q + p).G

If I'm understanding this correctly (which I'm not sure I ame), it seems
like the plan is to put R on-chain as the key to an output? As stated this
is completely insecure as Q is known in advance so the taker can always
choose a nonce p but then claim that their nonce point is p.G - Q so that
the key that goes on-chain is (p.G - Q + Q) = p.G allowing them to steal
the funds. If the plan is not to use full-fledged 2-ECDSA (which I think is
actually necessary as I still don't understand how the HTLC signatures are
generated) you have to, at the very least, force the taker to provide a
Zero Knowledge Proof of Knowledge (ZKPoK) of the discrete log to the point
they advertise as their nonce point to avoid this. Alternatively, I think
you can use the following key as is done in MuSig:

R = H(Q || P || Q)*Q + H(Q || P || P)*P

But I still don't see how signatures can be generated for HTLCs from this
key.

Of course all of this complexity more or less goes away once we have
Schnorr signatures and can use MuSig with adaptor signatures.

Best,
Nadav

On Thu, Aug 20, 2020 at 6:17 AM ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Good morning Chris,
>
> Great to see this!
>
> Mostly minor comments.
>
>
>
> >
> > == Direct connections to Alice ===
> >
> > Only Alice, the taker, knows the entire route, Bob and Charlie just know
> > their previous and next transactions. Bob and Charlie do not have direct
> > connections with each other, only with Alice.
> >
> > Diagram of Tor connections:
> >
> > Bob Charlie
> > | /
> > | /
> > | /
> > Alice
> >
> > When Bob and Charlie communicate, they are actually sending and
> > receiving messages via Alice who relays them to Charlie or Bob. This
> > helps hide whether the previous or next counterparty in a CoinSwap route
> > is a maker or taker.
> >
> > This doesn't have security issues even in the final steps where private
> > keys are handed over, because those private keys are always for 2-of-2
> > multisig and so on their own are never enough to steal money.
>
> This has a massive advantage over CoinJoin.
>
> In CoinJoin, since all participants sign a single transaction, every
> participant knows the total number of participants.
> Thus, in CoinJoin, it is fairly useless to have just one taker and one
> maker, the maker knows exactly which output belongs to the taker.
> Even if all communications were done via the single paying taker, the
> maker(s) are shown the final transaction and thus can easily know how many
> participants there are (by counting the number of equal-valued outputs).
>
> With CoinSwap, in principle no maker has to know how many other makers are
> in the swap.
>
> Thus it would still be useful to make a single-maker CoinSwap, as that
> would be difficult, for the maker, to diferentiate from a multi-maker
> CoinSwap.
>
> There are still a few potential leaks though:
>
> * If paying through a CoinSwap, the cheapest option for the taker would be
> to send out a single large UTXO (single-output txes) to the first maker,
> and then demand the final payment and any change as two separate swaps from
> the final maker.
>   * Intermediate makers are likely to not have exact amounts, thus is
> unlikely to create a single-output tx when forwarding.
>   * Thus, the first maker could identify the taker.
> * The makers can try timing the communications lag with the taker.
>   The general assumption would be that more makers == more delay in taker
> responses.
>
>
>
> >
> > === Miner fees ===
> >
> > Makers have no incentive to pay any miner fees. They only do
> > transactions which earn them an income and are willing to wait a very
> > long time for that to happen. By contrast takers want to create
> > transactions far more urgently. In JoinMarket we coded a protocol where
> > the maker could contribute to miner fees, but the market price offered
> > of that trended towards zero. So the reality is that takers will pay all
> > the miner fees. Also because makers don't know the taker's time
> > preference they don't know how much they should pay in miner fees.
> >
> > The taker will have to set limits on how large the maker's transactions
> > are, otherwise makers could abuse this by having the taker consolidate
> > maker's UTXOs for free.
>
> Why not have the taker pay for the *first* maker-spent UTXO and have
> additional maker-spent UTXOs paid for by the maker?
> i.e. the taker indicates "swap me 1 BTC in 3 bags of 0.3, 0.3, and 0.4
> BTC", and pays for one UTXO spent for each "bag" (thus pays for 3 UTXOs).
>
> Disagreements on feerate can be resolved by having the taker set the
> feerate, i.e. "the customer is always right".
> Thus if the maker *has to* spend two UTXOs to make up the 0.4 BTC bag, it
> pays for the mining fees for that extra UTXO.
> The maker can always reject the swap attempt if it *has to* spend multiple
> UTXOs and would lose money doing so if the taker demands a too-high feerate.
>
>
> > == Contract transaction definitions ==
> >
> > Contract transactions are those which may spend from the 2-of-2 multisig
> > outputs, they transfer the coins into a contract where the coins can be
> > spent either by waiting for a timeout or providing a hash preimage
> > value. Ideally contract transactions will never be broadcast but their
> > existence keeps all parties honest.
> >
> > M~ is miner fees, which we treat as a random variable, and ultimately
> > set by whichever pre-signed RBF tx get mined. When we talk about the
> > contract tx, we actually mean perhaps 20-30 transactions which only
> > differ by the miner fee and have RBF enabled, so they can be broadcasted
> > in sequence to get the contract transaction mined regardless of the
> > demand for block space.
>
> The highest-fee version could have, in addition, CPFP-anchor outputs, like
> those being proposed in Lightning, so even if onchain fees rise above the
> largest fee reservation, it is possible to add even more fees.
>
> Or not.
> Hmm.
>
>
> Another thought: later you describe that miner fees are paid by Alice by
> forwarding those fees as well, how does that work when there are multiple
> versions of the contract transaction?
>
> >
> > (Alice+timelock_A OR Bob+hash) = Is an output which can be spent
> > either with Alice's private key
> > after waiting for a relative
> > timelock_A, or by Bob's private key by
> > revealing a hash preimage value
>
> The rationale for relative timelocks is that it makes private key turnover
> slightly more useable by ensuring that, after private key turnover, it is
> possible to wait indefinitely to spend the UTXO it received.
> This is in contrast with absolute timelocks, where after private key
> turnover, it is required to spend received UTXO before the absolute timeout.
>
> The dangers are:
>
> * Until it receives the private key, if either of the incoming or outgoing
> contract transactions are confirmed, every swap participant (taker or
> maker) should also broadcast the other contract transaction, and resolve by
> onchain transactions (with loss of privacy).
> * After receiving the private key, if the incoming contract transaction is
> confirmed, it should spend the resulting contract output.
> * It is possible to steal from a participant if that participant goes
> offline longer than the timeout.
>   This may imply that there may have to be some minimum timeout that
> makers indicate in their advertisements.
>   * The taker can detect if the first maker is offline, then if it is
> offline, try a contract transaction broadcast, if it confirms, the taker
> can wait for the timeout; if it times out, the taker can clawback the
> transaction.
>     * This appears to be riskless for the taker.
>     * Against a similar attack, Lightning requires channel reserves, which
> means the first hop never gains control of the entire value, which is a
> basic requirement for private key turnover.
>   * On the other hand, the taker has the largest timeout before it can
> clawback the funds, so it would wait for a long time, and at any time in
> between the first maker can come online and spend using the hashlock branch.
>     * But the taker can just try on the hope it works; it has nothing to
> lose.
>   * This attack seems to be possible only for the taker to mount.
>     Other makers on the route cannot know who the other makers are,
> without cooperation of the taker, who is the only one who knows all the
> makers.
>     * On the other hand, the last maker in the route has an outgoing HTLC
> with the smallest timelock, so it is the least-risk and therefore a maker
> who notices its outgoing HTLC has a low timeout might want to just do this
> anyway even if it is unsure if the taker is offline.
>   * Participants might want to spend from the UTXO to a new address after
> private key turnover anyway.
>     Makers could spend using a low-fee RBF-enabled tx, and when another
> request comes in for another swap, try to build a new funding tx with a
> higher-fee bump.
>
>
> > A possible attack by a malicious Alice is that she chooses M1 to be very
> > low (e.g. 1 sat/vbyte) and sets M2 and M3 to be very high (e.g. 1000
> > sat/vb) and then intentionally aborts, forcing the makers to lose much
> > more money in miner fees than the attacker. The attack can be used to
> > waste away Bob's and Charlie's coins on miner fees at little cost to the
> > malicious taker Alice. So to defend against this attack Bob and Charlie
> > must refuse to sign a contract transaction if the corresponding funding
> > transaction pays miner fees greater than Alice's funding transaction.
>
> Sorry, I do not follow the logic for this...?
>
> > The timelocks are staggered so that if Alice uses the preimage to take
> > coins then the right people will also learn the preimage and have enough
> > time to be able to get their coins back too. Alice starts with knowledge
> > of the hash preimage so she must have a longest timelock.
>
> More precisely:
>
> * The HTLC outgoing from Alice has the longest timelock.
> * The HTLC incoming into Alice has the shortest timelock.
>
> For the makers, they only need to ensure that the incoming timelock is
> much larger than the outgoing timelock.
>
>
> >
> > == EC tweak to reduce one round trip ==
> >
> > When two parties are agreeing on a 2-of-2 multisig address, they need to
> > agree on their public keys. We can avoid one round trip by using the EC
> > tweak trick.
> >
> > When Alice, the taker, downloads the entire offer book for the liquidity
> > market, the offers will also contain a EC public key. Alice can tweak
> > this to generate a brand new public key for which the maker knows the
> > private key. This public key will be one of the keys in the 2-of-2
> > multisig. This feature removes one round trip from the protocol.
> >
> > q = EC privkey generated by maker
> > Q = q.G = EC pubkey published by maker
> >
> > p = nonce generated by taker
> > P = p.G = nonce point calculated by taker
> >
> > R = Q + P = pubkey used in bitcoin transaction
> > = (q + p).G
>
> Whoa whoa whoa whoa.
>
> All this time I was thinking you were going to use 2p-ECDSA for all
> 2-of-2s.
> In which case, the private key generated by the taker would be sufficient
> tweak to blind this.
>
> In 2p-ECDSA, for two participants M = m * G; T = t * G, the total key is m
> * t * G = m * T = t * M.
>
> Are you going to use `2 <T> <Q+P> 2 OP_CHECKMULTISIG` instead of 2p-ECDSA?
> Note that you cannot usefully hide among Lightning mutual closes, because
> of the reserve; Lightning mutual closes are very very likely to be spent in
> a 1-input (that spends from a 2-of-2 P2WSH), 2-output (that pays to two
> P2WPKHs) tx.
>
> >
> > == Protocol ==
>
> > ---8<------
>
> The protocol looks correct to me.
>
> LOL.
>
> Give me a little more time to check it in detail hahaha.
>
>
>
> >     ==== Retaliation as DOS-resistance ====
> >
> >     In some situations (e.g. step 8.) if one maker in the coinswap route
> is
> >     the victim of a DOS they will retaliate by DOSing the previous maker
> in
> >     the route. This may seem unnecessary and unfair (after all why waste
> >     even more time and block space) but is actually the best way to
> resist
> >     DOS because it produces a concrete cost every time a DOS happens.
>
> I agree.
>
> >
> >     == Analysis of deviations ==
> >
> >     This section discusses what happens if one party deviates from the
> >     protocol by doing something else, for example broadcasting a htlc
> >     contract tx when they shouldnt have.
> >
> >     The party name refers to what that party does, followed by other
> party's
> >     reactions to it.
> >     e.g. Party1: does a thing, Party2/Party3: does a thing in reaction
> >
> >     If multiple deviations are possible in a step then they are numbered
> >     e.g. A1 A2 A2 etc
> >
> >     0-2. Alice/Bob/Charlie: nothing else is possible except following the
> >     protocol or aborting
> >
> > 8.  Alice: broadcasts one or more of the A htlc txes. Bob/Charlie/Dennis:
> >     do nothing, they havent lost any time or money.
> >     4-6. Bob/Charlie: nothing else is possible except following the
> protocol
> >     or aborting.
> >
> > 9.  Bob: broadcasts one or more of the B htlc txes, Alice: broadcasts all
> >     her own A htlc txes and waits for the timeout to get her money back.
> >     Charlie: do nothing
> >
> > 10.  Charlie: nothing else is possible except following the protocol or
> >     aborting.
> >
> > 11.  Alice: broadcasts one or more of the A htlc txes. Bob: broadcasts
> all
> >     his own A htlc txes and waits for the timeout.
> >     A. same as 8.
> >     B. Charlie: broadcasts one or more of the C htlc txes, Alice/Bob:
> >     broadcasts all their own htlc txes and waits for the timeout to get
> >     their money back.
> >     C-E1. Alice: broadcasts all of C htlc txes and uses her knowledge of
> the
> >     preimage hash to take the money immediately. Charlie: broadcasts
> >     all of B htlc txes and reading the hash value from the blockchain,
> >     uses it to take the money from B htlc immediately. Bob: broadcasts
> >     all of A htlc txes, and reading hash from the blockchain, uses it
> >     to take the money from A htlc immediately.
> >     C-E2. Alice: broadcast her own A htlc txes, and after a timeout take
> the
> >     money. Bob: broadcast his own B htlc txes and after the timeout
> >     take their money. Charlie: broadcast his own C htlc txes and after
> >     the timeout take their money.
> >     F1. Bob: broadcast one or more of A htcl txes and use the hash
> preimage
> >     to get the money immediately. He already knows both privkeys of the
> >     multisig so this is pointless and just damages privacy and wastes
> >     miner fees. Alice: blacklist Bob's fidelity bond.
> >     F2. Bob: broadcast one or more of the C htlc txes. Charlie: use
> preimage
> >     to get his money immediately. Bob's actions were pointless. Alice:
> >     cant tell whether Bob or Charlie actually broadcasted, so blacklist
> >     both fidelity bonds.
> >     G1. Charlie: broadcast one or more of B htcl txes and use the hash
> >     preimage to get the money immediately. He already knows both
> >     privkeys of the multisig so this is pointless and just damages
> >     privacy and wastes miner fees. Alice: cant tell whether Bob or
> >     Charlie actually broadcasted, so blacklist both fidelity bonds.
> >     G2. Charlie: broadcast one or more of the A htlc txes. Alice:
> broadcast
> >     the remaining A htlc txes and use preimage to get her money
> >     immediately. Charlies's actions were pointless. Alice: blacklist
> >     Charlie's fidelity bond.
> >
> >     The multisig outputs of the funding transactions can stay unspent
> >     indefinitely. However the parties must always be watching the network
> >     and ready to respond with their own sweep using a preimage. This is
> >     because the other party still possesses a fully-signed contract tx.
> The
> >     parties respond in the same way as in steps C-E1, F2 and G2. Alice's
> >     reaction of blacklisting both fidelity bonds might not be the right
> way,
> >     because one maker could use it to get another one blacklisted (as
> well
> >     as themselves).
>
> Looks OK, though note that a participant might try to do so (as pointed
> out above) in the hope that the next participant is offline.
>
> Thank you very much for your writeup!
>
> Regards,
> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200820/d782e2d1/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Thu Aug 20 21:38:16 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 20 Aug 2020 21:38:16 +0000
Subject: [bitcoin-dev] Detailed protocol design for routed
	multi-transaction CoinSwap
In-Reply-To: <CALGTLwPOhHwXULLOhpEzbKxb0V-kjZWLRdnZ90T9RWxFSwuu4w@mail.gmail.com>
References: <813e51a1-4252-08c0-d42d-5cef32f684bc@riseup.net>
 <xhRsCejqgUjoLy5hPMHgFcZdiqJsO7TfS0azWhis9-tvSgXodoKe7gN5IXyiVIVqUWSm7FoY-aBUaJCCDgixdWUN4n8EzhQlSNshsQeIFsw=@protonmail.com>
 <CALGTLwPOhHwXULLOhpEzbKxb0V-kjZWLRdnZ90T9RWxFSwuu4w@mail.gmail.com>
Message-ID: <eoSHJi6wcD_oq5w9XBzj91Q8bn_fGKIjyQ_F1xxKDUhuyjhKeJrUXVE315lC0G9VrN7DakXC-D9Yds7DQ5TVaHai_caCAnugp7SsgFYaH_Y=@protonmail.com>

Good morning Nadav,

> Hey Chris and all,
>
> Looking good :) I have one major concern though
>
> >? ? q = EC privkey generated by maker
> >? ? Q = q.G = EC pubkey published by maker
> >
> >? ? p = nonce generated by taker
> >? ? P = p.G = nonce point calculated by taker
> >
> >? ? R = Q + P = pubkey used in bitcoin transaction
> >? ? ? = (q + p).G
>
> If I'm understanding this correctly (which I'm not sure I ame), it seems like the plan is to put R on-chain as the key to an output? As stated this is completely?insecure as Q is known in advance so the taker can always choose a nonce p but then claim that their nonce point is p.G - Q so that the key that goes on-chain is (p.G - Q?+ Q) = p.G allowing them to steal the funds.

My reading from this is that nonce `p` has to be given by the taker to the maker outright.
In original post:

> Taker sends unsigned transaction which pays to multisig using pubkey Q,
> and also sends nonce p.

Thus, taker provides a proof-of-knowledge, i.e. the actual `p` scalar itself (not zero-knowledge, but what the maker needs is proof-of-knowledge, and could not care less if the proof is zero-knowledge or not).

On the other hand, I do not see the point of this tweak if you are going to use 2p-ECDSA, since my knowledge is that 2p-ECDSA uses the pubkey that is homomorphic to the product of the private keys.
And that pubkey is already tweaked, by the fresh privkey of the maker (and the maker is buying privacy and wants security of the swap, so is incentivized to generate high-entropy temporary privkeys for the actual swap operation).

Not using 2p-ECDSA of some kind would remove most of the privacy advantages of CoinSwap.
You cannot hide among `2 <A> <B> 2 OP_CHECKMULTISIG` scripts of Lightning, because:

* Lightning channel closes tend to be weeks at least after the funding outpoint creation, whereas CoinSwap envisions hours or days.
* Lightning mutual channel closes have a very high probability of spending to two P2WPKH addresses.

You need to hide among the much larger singlesig anonymity set, which means using a single signature (created multiparty by both participants), not two signatures (one from each participant).

Or is this intended for HTLCs in open-coded SCRIPTs `OP_DUP OP_IF OP_HASH160 <hash> OP_EQUAL <A> OP_ELSE <time> OP_CHECKSEQUENCEVERIFY OP_DROP <B> OP_ENDIF OP_CHECKSIG`?
This provides a slight privacy boost in a case (contract transaction publication) where most of the privacy is lost anyway.

Regards,
ZmnSCPxj

From belcher at riseup.net  Thu Aug 20 22:15:34 2020
From: belcher at riseup.net (Chris Belcher)
Date: Thu, 20 Aug 2020 23:15:34 +0100
Subject: [bitcoin-dev] Detailed protocol design for routed
 multi-transaction CoinSwap
In-Reply-To: <xhRsCejqgUjoLy5hPMHgFcZdiqJsO7TfS0azWhis9-tvSgXodoKe7gN5IXyiVIVqUWSm7FoY-aBUaJCCDgixdWUN4n8EzhQlSNshsQeIFsw=@protonmail.com>
References: <813e51a1-4252-08c0-d42d-5cef32f684bc@riseup.net>
 <xhRsCejqgUjoLy5hPMHgFcZdiqJsO7TfS0azWhis9-tvSgXodoKe7gN5IXyiVIVqUWSm7FoY-aBUaJCCDgixdWUN4n8EzhQlSNshsQeIFsw=@protonmail.com>
Message-ID: <e8ca67be-d07c-3f2e-4318-0d2bab061dd9@riseup.net>

Hello ZmnSCPxj,

Thanks for the review. My comments are inline.

On 20/08/2020 12:17, ZmnSCPxj wrote:
> Good morning Chris,
> 
> Great to see this!
> 
> Mostly minor comments.
> 
> 
> 
>>
>> == Direct connections to Alice ===
>>
>> Only Alice, the taker, knows the entire route, Bob and Charlie just know
>> their previous and next transactions. Bob and Charlie do not have direct
>> connections with each other, only with Alice.
>>
>> Diagram of Tor connections:
>>
>> Bob Charlie
>> | /
>> | /
>> | /
>> Alice
>>
>> When Bob and Charlie communicate, they are actually sending and
>> receiving messages via Alice who relays them to Charlie or Bob. This
>> helps hide whether the previous or next counterparty in a CoinSwap route
>> is a maker or taker.
>>
>> This doesn't have security issues even in the final steps where private
>> keys are handed over, because those private keys are always for 2-of-2
>> multisig and so on their own are never enough to steal money.
> 
> This has a massive advantage over CoinJoin.
> 
> In CoinJoin, since all participants sign a single transaction, every participant knows the total number of participants.
> Thus, in CoinJoin, it is fairly useless to have just one taker and one maker, the maker knows exactly which output belongs to the taker.
> Even if all communications were done via the single paying taker, the maker(s) are shown the final transaction and thus can easily know how many participants there are (by counting the number of equal-valued outputs).
> 
> With CoinSwap, in principle no maker has to know how many other makers are in the swap.
> 
> Thus it would still be useful to make a single-maker CoinSwap, as that would be difficult, for the maker, to diferentiate from a multi-maker CoinSwap.

Yes great point.

> There are still a few potential leaks though:
> 
> * If paying through a CoinSwap, the cheapest option for the taker would be to send out a single large UTXO (single-output txes) to the first maker, and then demand the final payment and any change as two separate swaps from the final maker.
>   * Intermediate makers are likely to not have exact amounts, thus is unlikely to create a single-output tx when forwarding.
>   * Thus, the first maker could identify the taker.

Right, so if the taker uses only a single maker then they must have more
than one UTXO.

This leak in the case of a taker spending a single UTXO also happens
when the taker needs to create a branching route. I described this in my
original email "Design for a CoinSwap implementation for massively
improving Bitcoin privacy and fungibility" under the section "Combining
multi-transaction with routing" (the second diagram).

I think this might be unavoidable. If the taker has just one UTXO they'd
be much better off using multiple makers for this reason.


> * The makers can try timing the communications lag with the taker.
>   The general assumption would be that more makers == more delay in taker responses.

Sounds like adding random delays would fix this. The protocol already
involves waiting for a confirmation (average waiting time 10 minutes, at
best) and might involve more confirmations for extra security and
privacy. So adding a random delay of up to 0.5-1 minutes shouldnt cause
too many issues.
Also the Tor network can be pretty laggy so that might add enough noise
anyway.

>>
>> === Miner fees ===
>>
>> Makers have no incentive to pay any miner fees. They only do
>> transactions which earn them an income and are willing to wait a very
>> long time for that to happen. By contrast takers want to create
>> transactions far more urgently. In JoinMarket we coded a protocol where
>> the maker could contribute to miner fees, but the market price offered
>> of that trended towards zero. So the reality is that takers will pay all
>> the miner fees. Also because makers don't know the taker's time
>> preference they don't know how much they should pay in miner fees.
>>
>> The taker will have to set limits on how large the maker's transactions
>> are, otherwise makers could abuse this by having the taker consolidate
>> maker's UTXOs for free.
> 
> Why not have the taker pay for the *first* maker-spent UTXO and have additional maker-spent UTXOs paid for by the maker?
> i.e. the taker indicates "swap me 1 BTC in 3 bags of 0.3, 0.3, and 0.4 BTC", and pays for one UTXO spent for each "bag" (thus pays for 3 UTXOs).
> 
> Disagreements on feerate can be resolved by having the taker set the feerate, i.e. "the customer is always right".
> Thus if the maker *has to* spend two UTXOs to make up the 0.4 BTC bag, it pays for the mining fees for that extra UTXO.
> The maker can always reject the swap attempt if it *has to* spend multiple UTXOs and would lose money doing so if the taker demands a too-high feerate.

Having the taker pay for just one UTXO will have an unfortunate side
effect of resulting in the maker's money being split up into a large
number of UTXOs, because every CoinSwap they take part in has an
incentive to increase their UTXO count by one. At the start of
JoinMarket this was an issue where then a taker wanting to CoinJoin a
large would come along and the result would be a huge CoinJoin
transaction with many many small inputs. Perhaps the taker could pay for
2-3 UTXOs to counteract this. (Of course the exact number would be
configurable by the taker user, but defaults usually don't get changed).

I'm still not convinced with having makers contribute to miner fees. In
JoinMarket we tried to get makers to contribute a little to miner fees
and simply they never did in any meaningful way. The market has spoken.
In terms of incentives makers are happy to wait a very long time, if we
assume they're just HODLers then even if they earn a few thousand
satoshis that's good.

>> == Contract transaction definitions ==
>>
>> Contract transactions are those which may spend from the 2-of-2 multisig
>> outputs, they transfer the coins into a contract where the coins can be
>> spent either by waiting for a timeout or providing a hash preimage
>> value. Ideally contract transactions will never be broadcast but their
>> existence keeps all parties honest.
>>
>> M~ is miner fees, which we treat as a random variable, and ultimately
>> set by whichever pre-signed RBF tx get mined. When we talk about the
>> contract tx, we actually mean perhaps 20-30 transactions which only
>> differ by the miner fee and have RBF enabled, so they can be broadcasted
>> in sequence to get the contract transaction mined regardless of the
>> demand for block space.
> 
> The highest-fee version could have, in addition, CPFP-anchor outputs, like those being proposed in Lightning, so even if onchain fees rise above the largest fee reservation, it is possible to add even more fees.
> 
> Or not.
> Hmm.

I think RBF transactions are better because they ultimately use less
block space than CPFP.

There seems to be very little cost in signing many additional
precomputed RBF transactions. So the taker and makers could sign
transactions all the way up to 10000 sat/vbyte. I think this doesn't
apply to Lightning, because bandwidth seems to be more constrained
there: even a tiny micropayment for 1 satoshi would require 10x or 100x
more bandwidth if every lightning htlc used precomputed RBF.

> Another thought: later you describe that miner fees are paid by Alice by forwarding those fees as well, how does that work when there are multiple versions of the contract transaction?

Alice only pays the miner fees for the funding transactions, not the
contract transaction. The miner fees for the contract transactions are
taken from the contract balance. The contract transactions are 1-input
1-output, and whoever ends up with the money will be the one who paid
the miner fee.

>> (Alice+timelock_A OR Bob+hash) = Is an output which can be spent
>> either with Alice's private key
>> after waiting for a relative
>> timelock_A, or by Bob's private key by
>> revealing a hash preimage value
> 
> The rationale for relative timelocks is that it makes private key turnover slightly more useable by ensuring that, after private key turnover, it is possible to wait indefinitely to spend the UTXO it received.
> This is in contrast with absolute timelocks, where after private key turnover, it is required to spend received UTXO before the absolute timeout.
> 
> The dangers are:
> 
> * Until it receives the private key, if either of the incoming or outgoing contract transactions are confirmed, every swap participant (taker or maker) should also broadcast the other contract transaction, and resolve by onchain transactions (with loss of privacy).
> * After receiving the private key, if the incoming contract transaction is confirmed, it should spend the resulting contract output.
> * It is possible to steal from a participant if that participant goes offline longer than the timeout.
>   This may imply that there may have to be some minimum timeout that makers indicate in their advertisements.
>   * The taker can detect if the first maker is offline, then if it is offline, try a contract transaction broadcast, if it confirms, the taker can wait for the timeout; if it times out, the taker can clawback the transaction.
>     * This appears to be riskless for the taker.
>     * Against a similar attack, Lightning requires channel reserves, which means the first hop never gains control of the entire value, which is a basic requirement for private key turnover.
>   * On the other hand, the taker has the largest timeout before it can clawback the funds, so it would wait for a long time, and at any time in between the first maker can come online and spend using the hashlock branch.
>     * But the taker can just try on the hope it works; it has nothing to lose.
>   * This attack seems to be possible only for the taker to mount.
>     Other makers on the route cannot know who the other makers are, without cooperation of the taker, who is the only one who knows all the makers.
>     * On the other hand, the last maker in the route has an outgoing HTLC with the smallest timelock, so it is the least-risk and therefore a maker who notices its outgoing HTLC has a low timeout might want to just do this anyway even if it is unsure if the taker is offline.

Every off-chain protocol like this has the livelyness requirement. Each
party must always be watching the chain and be ready to broadcast
something in response. I'm not sure how any of this relates to the
choice of relative vs absolute time locks.

You're right that attempting such an move by the taker is riskless, but
its not costless. The taker sets up the entire CoinSwap protocol because
they wanted more privacy; but if the taker broadcasts the Alice contract
transaction and waits for the timeout, then all they've achieved is
spent miner fees, got their own coin back and draw attention to it with
the unusual HTLC script. They've achieved no benefit from what I see, so
they won't do this. Any taker or maker who attempts anything like this
will be spending miner fees.

I also envision that makers will run their own personal "watchtowers",
similar to watchtowers in the lightning world, which would watch the
blockchain and be ready to broadcast a transaction. In terms of
incentives, makers are HODLers and we can expect them to protect their
stash very carefully by running perhaps multiple redundant watchtowers
in multiple locations and multiple networks. Therefore a taker noticing
that a maker's .onion is down does not imply that all the maker's
watchtowers are down.

Of course we will choose the timelocks to be long enough so that
everyone has enough time to broadcast a transaction in response, even in
times of congested mempools.

>   * Participants might want to spend from the UTXO to a new address after private key turnover anyway.
>     Makers could spend using a low-fee RBF-enabled tx, and when another request comes in for another swap, try to build a new funding tx with a higher-fee bump.

I don't think this will happen very often. It's spending money on block
space for not much benefit. If the maker ever decides to shut down their
maker they can transfer all their coins in HTLCs to single-sig
transactions exclusively controlled by them, but in normal operation I
doubt it will happen.


>> A possible attack by a malicious Alice is that she chooses M1 to be very
>> low (e.g. 1 sat/vbyte) and sets M2 and M3 to be very high (e.g. 1000
>> sat/vb) and then intentionally aborts, forcing the makers to lose much
>> more money in miner fees than the attacker. The attack can be used to
>> waste away Bob's and Charlie's coins on miner fees at little cost to the
>> malicious taker Alice. So to defend against this attack Bob and Charlie
>> must refuse to sign a contract transaction if the corresponding funding
>> transaction pays miner fees greater than Alice's funding transaction.
> 
> Sorry, I do not follow the logic for this...?

I'll try to explain again with an example, hopefully it clarifies.

Recall the table of balances before/after CoinSwap using contracts
transactions:

Party   | Before | After
--------|--------|--------------------------------------------
Alice   | WA     | WA-M1-I + I-MA~                  = WA-M1-MA~
Bob     | WB     | WB-I+B + I-M2-B-MB~              = WB-M2-MB~


What the table says is that if the CoinSwap results in the HTLC
transactions being mined and the locktime branch being used, then both
Alice and Bob will see their wallet balance fall by two miner fees (in
Alice's case the miner fee of the Alice funding transaction plus the
miner fee of the Alice contract transaction).

The attack I describe works because Alice chooses both MA~ and MB~. The
attack is that Alice chooses MA~ to be a very low value (e.g. 1 sat/vb)
and chooses MB~ to be a very high value (e.g. 1000 sat/vb). Then Alice
intentionally sabotages the CoinSwap and forces it to go to the timeout
case, what happens is that Bob's wallet balance falls by much more than
Alice's, because MB~ > MA~. So this is a DOS attack: Alice can waste
Bob's resources without wasting much of her own.

>> The timelocks are staggered so that if Alice uses the preimage to take
>> coins then the right people will also learn the preimage and have enough
>> time to be able to get their coins back too. Alice starts with knowledge
>> of the hash preimage so she must have a longest timelock.
> 
> More precisely:
> 
> * The HTLC outgoing from Alice has the longest timelock.
> * The HTLC incoming into Alice has the shortest timelock.
> 
> For the makers, they only need to ensure that the incoming timelock is much larger than the outgoing timelock.

Agreed.

Perhaps I chose confusing terminology, "Alice contract transaction"
means the transaction which pays money to Alice after a timeout. The
text you quoted is confusingly written, and it would've been better to
write: "Alice starts with knowledge of the hash preimage so the Alice
contract transaction must have a longest timelock."

>> == EC tweak to reduce one round trip ==
>>
>> When two parties are agreeing on a 2-of-2 multisig address, they need to
>> agree on their public keys. We can avoid one round trip by using the EC
>> tweak trick.
>>
>> When Alice, the taker, downloads the entire offer book for the liquidity
>> market, the offers will also contain a EC public key. Alice can tweak
>> this to generate a brand new public key for which the maker knows the
>> private key. This public key will be one of the keys in the 2-of-2
>> multisig. This feature removes one round trip from the protocol.
>>
>> q = EC privkey generated by maker
>> Q = q.G = EC pubkey published by maker
>>
>> p = nonce generated by taker
>> P = p.G = nonce point calculated by taker
>>
>> R = Q + P = pubkey used in bitcoin transaction
>> = (q + p).G
> 
> Whoa whoa whoa whoa.
> 
> All this time I was thinking you were going to use 2p-ECDSA for all 2-of-2s.
> In which case, the private key generated by the taker would be sufficient tweak to blind this.
> 
> In 2p-ECDSA, for two participants M = m * G; T = t * G, the total key is m * t * G = m * T = t * M.
> 
> Are you going to use `2 <T> <Q+P> 2 OP_CHECKMULTISIG` instead of 2p-ECDSA?
> Note that you cannot usefully hide among Lightning mutual closes, because of the reserve; Lightning mutual closes are very very likely to be spent in a 1-input (that spends from a 2-of-2 P2WSH), 2-output (that pays to two P2WPKHs) tx.

Yes, I intend for 2p-ECDSA to be used eventually, but for the first
version I'll only implement regular multisigs with OP_CHECKMULTISIG.
Once all the other details of this protocol are implemented correctly
and mostly-bug-free then 2p-ECDSA can be added. It can be added in the
protocol steps 0-1, 3-5 and 7-9.

This document also doesn't talk about PayJoin-with-CoinSwap, but that
can be added later too.

>>
>>     == Analysis of deviations ==
>>
>>     This section discusses what happens if one party deviates from the
>>     protocol by doing something else, for example broadcasting a htlc
>>     contract tx when they shouldnt have.
>>
>>     The party name refers to what that party does, followed by other party's
>>     reactions to it.
>>     e.g. Party1: does a thing, Party2/Party3: does a thing in reaction
>>
>>     If multiple deviations are possible in a step then they are numbered
>>     e.g. A1 A2 A2 etc
>>
>>     0-2. Alice/Bob/Charlie: nothing else is possible except following the
>>     protocol or aborting
>>
>> 8.  Alice: broadcasts one or more of the A htlc txes. Bob/Charlie/Dennis:
>>     do nothing, they havent lost any time or money.
>>     4-6. Bob/Charlie: nothing else is possible except following the protocol
>>     or aborting.
>>
>> 9.  Bob: broadcasts one or more of the B htlc txes, Alice: broadcasts all
>>     her own A htlc txes and waits for the timeout to get her money back.
>>     Charlie: do nothing
>>
>> 10.  Charlie: nothing else is possible except following the protocol or
>>     aborting.
>>
>> 11.  Alice: broadcasts one or more of the A htlc txes. Bob: broadcasts all
>>     his own A htlc txes and waits for the timeout.
>>     A. same as 8.
>>     B. Charlie: broadcasts one or more of the C htlc txes, Alice/Bob:
>>     broadcasts all their own htlc txes and waits for the timeout to get
>>     their money back.
>>     C-E1. Alice: broadcasts all of C htlc txes and uses her knowledge of the
>>     preimage hash to take the money immediately. Charlie: broadcasts
>>     all of B htlc txes and reading the hash value from the blockchain,
>>     uses it to take the money from B htlc immediately. Bob: broadcasts
>>     all of A htlc txes, and reading hash from the blockchain, uses it
>>     to take the money from A htlc immediately.
>>     C-E2. Alice: broadcast her own A htlc txes, and after a timeout take the
>>     money. Bob: broadcast his own B htlc txes and after the timeout
>>     take their money. Charlie: broadcast his own C htlc txes and after
>>     the timeout take their money.
>>     F1. Bob: broadcast one or more of A htcl txes and use the hash preimage
>>     to get the money immediately. He already knows both privkeys of the
>>     multisig so this is pointless and just damages privacy and wastes
>>     miner fees. Alice: blacklist Bob's fidelity bond.
>>     F2. Bob: broadcast one or more of the C htlc txes. Charlie: use preimage
>>     to get his money immediately. Bob's actions were pointless. Alice:
>>     cant tell whether Bob or Charlie actually broadcasted, so blacklist
>>     both fidelity bonds.
>>     G1. Charlie: broadcast one or more of B htcl txes and use the hash
>>     preimage to get the money immediately. He already knows both
>>     privkeys of the multisig so this is pointless and just damages
>>     privacy and wastes miner fees. Alice: cant tell whether Bob or
>>     Charlie actually broadcasted, so blacklist both fidelity bonds.
>>     G2. Charlie: broadcast one or more of the A htlc txes. Alice: broadcast
>>     the remaining A htlc txes and use preimage to get her money
>>     immediately. Charlies's actions were pointless. Alice: blacklist
>>     Charlie's fidelity bond.
>>
>>     The multisig outputs of the funding transactions can stay unspent
>>     indefinitely. However the parties must always be watching the network
>>     and ready to respond with their own sweep using a preimage. This is
>>     because the other party still possesses a fully-signed contract tx. The
>>     parties respond in the same way as in steps C-E1, F2 and G2. Alice's
>>     reaction of blacklisting both fidelity bonds might not be the right way,
>>     because one maker could use it to get another one blacklisted (as well
>>     as themselves).
> 
> Looks OK, though note that a participant might try to do so (as pointed out above) in the hope that the next participant is offline.

I really hope that everyone (the makers at least) is running multiple
redundant watchtowers, so that anyone attempting this attack just wastes
money on miner fees and achieves nothing.

From belcher at riseup.net  Thu Aug 20 22:37:35 2020
From: belcher at riseup.net (Chris Belcher)
Date: Thu, 20 Aug 2020 23:37:35 +0100
Subject: [bitcoin-dev] Detailed protocol design for routed
 multi-transaction CoinSwap
In-Reply-To: <eoSHJi6wcD_oq5w9XBzj91Q8bn_fGKIjyQ_F1xxKDUhuyjhKeJrUXVE315lC0G9VrN7DakXC-D9Yds7DQ5TVaHai_caCAnugp7SsgFYaH_Y=@protonmail.com>
References: <813e51a1-4252-08c0-d42d-5cef32f684bc@riseup.net>
 <xhRsCejqgUjoLy5hPMHgFcZdiqJsO7TfS0azWhis9-tvSgXodoKe7gN5IXyiVIVqUWSm7FoY-aBUaJCCDgixdWUN4n8EzhQlSNshsQeIFsw=@protonmail.com>
 <CALGTLwPOhHwXULLOhpEzbKxb0V-kjZWLRdnZ90T9RWxFSwuu4w@mail.gmail.com>
 <eoSHJi6wcD_oq5w9XBzj91Q8bn_fGKIjyQ_F1xxKDUhuyjhKeJrUXVE315lC0G9VrN7DakXC-D9Yds7DQ5TVaHai_caCAnugp7SsgFYaH_Y=@protonmail.com>
Message-ID: <f0bce6e1-c116-6282-73c8-b75c0dfa62bf@riseup.net>

Hello Nadav and ZmnSCPxj,

On 20/08/2020 22:38, ZmnSCPxj wrote:
> Good morning Nadav,
> 
>> Hey Chris and all,
>>
>> Looking good :) I have one major concern though
>>
>>> ? ? q = EC privkey generated by maker
>>> ? ? Q = q.G = EC pubkey published by maker
>>>
>>> ? ? p = nonce generated by taker
>>> ? ? P = p.G = nonce point calculated by taker
>>>
>>> ? ? R = Q + P = pubkey used in bitcoin transaction
>>> ? ? ? = (q + p).G
>>
>> If I'm understanding this correctly (which I'm not sure I ame), it seems like the plan is to put R on-chain as the key to an output? As stated this is completely?insecure as Q is known in advance so the taker can always choose a nonce p but then claim that their nonce point is p.G - Q so that the key that goes on-chain is (p.G - Q?+ Q) = p.G allowing them to steal the funds.
> 
> My reading from this is that nonce `p` has to be given by the taker to the maker outright.
> In original post:
> 
>> Taker sends unsigned transaction which pays to multisig using pubkey Q,
>> and also sends nonce p.
> 
> Thus, taker provides a proof-of-knowledge, i.e. the actual `p` scalar itself (not zero-knowledge, but what the maker needs is proof-of-knowledge, and could not care less if the proof is zero-knowledge or not).

Yes this looks right. In hindsight my text could be clarified by
changing the relevant lines to:

    p = nonce generated by taker, sent to maker
    P = p.G = nonce point calculated by taker

    R = Q + P = pubkey used in bitcoin transaction, calculated by taker
      = (q + p).G = same pubkey, calculated by maker


I don't think the key subtraction attack described by Nadav will work
here...?


> On the other hand, I do not see the point of this tweak if you are going to use 2p-ECDSA, since my knowledge is that 2p-ECDSA uses the pubkey that is homomorphic to the product of the private keys.
> And that pubkey is already tweaked, by the fresh privkey of the maker (and the maker is buying privacy and wants security of the swap, so is incentivized to generate high-entropy temporary privkeys for the actual swap operation).
> 
> Not using 2p-ECDSA of some kind would remove most of the privacy advantages of CoinSwap.
> You cannot hide among `2 <A> <B> 2 OP_CHECKMULTISIG` scripts of Lightning, because:
> 
> * Lightning channel closes tend to be weeks at least after the funding outpoint creation, whereas CoinSwap envisions hours or days.
> * Lightning mutual channel closes have a very high probability of spending to two P2WPKH addresses.
> 
> You need to hide among the much larger singlesig anonymity set, which means using a single signature (created multiparty by both participants), not two signatures (one from each participant).
> 
> Or is this intended for HTLCs in open-coded SCRIPTs `OP_DUP OP_IF OP_HASH160 <hash> OP_EQUAL <A> OP_ELSE <time> OP_CHECKSEQUENCEVERIFY OP_DROP <B> OP_ENDIF OP_CHECKSIG`?
> This provides a slight privacy boost in a case (contract transaction publication) where most of the privacy is lost anyway.

I completely agree that 2of2 multisigs made with OP_CHECKMULTISIG are
lacking in terms of privacy, and that 2p-ECDSA is much better. However
this whole protocol is quite complicated and I thought it would be a
good move to first implement it with OP_CHECKMULTISIG, to get all the
other details right (miner fees, coinswap fees, private key handover,
contract transactions, tor hidden services, watchtowers, etc etc) and
then add 2p-ECDSA later. Of course in that case all this tweaking of
public keys would be superseded by the 2p-ECDSA protocol.

From aj at erisian.com.au  Fri Aug 21 02:36:47 2020
From: aj at erisian.com.au (Anthony Towns)
Date: Fri, 21 Aug 2020 12:36:47 +1000
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
 connections are setup
In-Reply-To: <CAFp6fsE=HPFUMFhyuZkroBO_QJ-dUWNJqCPg9=fMJ3Jqnu1hnw@mail.gmail.com>
References: <CAFp6fsE=HPFUMFhyuZkroBO_QJ-dUWNJqCPg9=fMJ3Jqnu1hnw@mail.gmail.com>
Message-ID: <20200821023647.7eat4goqqrtaqnna@erisian.com.au>

On Fri, Aug 14, 2020 at 03:28:41PM -0400, Suhas Daftuar via bitcoin-dev wrote:
> In thinking about the mechanism used there, I thought it would?be helpful to
> codify in a BIP the idea that Bitcoin network clients should ignore unknown
> messages received before a VERACK.? A draft of my proposal is available here
> [2].

Rather than allowing arbitrary messages, maybe it would make sense to
have a specific feature negotiation message, eg:

  VERSION ...
  FEATURE wtxidrelay
  FEATURE packagerelay
  VERACK

with the behaviour being that it's valid only between VERSION and VERACK,
and it takes a length-prefixed-string giving the feature name, optional
additional data, and if the feature name isn't recognised the message
is ignored.

If we were to support a "polite disconnect" feature like Jeremy suggested,
it might be easier to do that for a generic FEATURE message, than
reimplement it for the message proposed by each new feature.

Cheers,
aj


From ZmnSCPxj at protonmail.com  Fri Aug 21 04:20:23 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 21 Aug 2020 04:20:23 +0000
Subject: [bitcoin-dev] Detailed protocol design for routed
	multi-transaction CoinSwap
In-Reply-To: <e8ca67be-d07c-3f2e-4318-0d2bab061dd9@riseup.net>
References: <813e51a1-4252-08c0-d42d-5cef32f684bc@riseup.net>
 <xhRsCejqgUjoLy5hPMHgFcZdiqJsO7TfS0azWhis9-tvSgXodoKe7gN5IXyiVIVqUWSm7FoY-aBUaJCCDgixdWUN4n8EzhQlSNshsQeIFsw=@protonmail.com>
 <e8ca67be-d07c-3f2e-4318-0d2bab061dd9@riseup.net>
Message-ID: <WtKtWCdqIFVTTqw9-EggdsTIo6ejfP8my868MYyAqO8FUboiXWZUd0hw2PyvEKZNJxqAWJ_9BnOllAGEuUYYcA654amKTC4MSmO3TO4A7pU=@protonmail.com>

Good morning,



> Right, so if the taker uses only a single maker then they must have more
> than one UTXO.

Spending one UTXO is fine, it is generating a transaction that has one output that is problematic.

What needs to happen is that this single UTXO is spent to two outputs: the CoinSwap 2-of-2 and the change output.
This is because intermediate makers will have very high likelihood of generating such a pattern (it is unlikely they have an exact amount that a taker would require of them), and the occassional maker might have a very large UTXO that it can use for similar purposes.

One thing a taker can do would be to multipath its CoinSwap, i.e. it spends any number of UTXOs and creates two outputs, which are actually two separate CoinSwap 2-of-2s to different makers.
As each maker is unaware of the other, this should be similar to the case where the maker is an intermediate hop and is getting its incoming HTLC from another maker, which is unlikely to have a precise amount and will thus have a transaction that has two outputs, the 2-of-2 CoinSwap and the change.

>
> This leak in the case of a taker spending a single UTXO also happens
> when the taker needs to create a branching route. I described this in my
> original email "Design for a CoinSwap implementation for massively
> improving Bitcoin privacy and fungibility" under the section "Combining
> multi-transaction with routing" (the second diagram).
>
> I think this might be unavoidable. If the taker has just one UTXO they'd
> be much better off using multiple makers for this reason.
>
> > -   The makers can try timing the communications lag with the taker.
> >     The general assumption would be that more makers == more delay in taker responses.
> >
>
> Sounds like adding random delays would fix this. The protocol already
> involves waiting for a confirmation (average waiting time 10 minutes, at
> best) and might involve more confirmations for extra security and
> privacy. So adding a random delay of up to 0.5-1 minutes shouldnt cause
> too many issues.
> Also the Tor network can be pretty laggy so that might add enough noise
> anyway.

Indeed, this seems a bit of a long shot for the surveilling maker.

> > > === Miner fees ===
> > > Makers have no incentive to pay any miner fees. They only do
> > > transactions which earn them an income and are willing to wait a very
> > > long time for that to happen. By contrast takers want to create
> > > transactions far more urgently. In JoinMarket we coded a protocol where
> > > the maker could contribute to miner fees, but the market price offered
> > > of that trended towards zero. So the reality is that takers will pay all
> > > the miner fees. Also because makers don't know the taker's time
> > > preference they don't know how much they should pay in miner fees.
> > > The taker will have to set limits on how large the maker's transactions
> > > are, otherwise makers could abuse this by having the taker consolidate
> > > maker's UTXOs for free.
> >
> > Why not have the taker pay for the first maker-spent UTXO and have additional maker-spent UTXOs paid for by the maker?
> > i.e. the taker indicates "swap me 1 BTC in 3 bags of 0.3, 0.3, and 0.4 BTC", and pays for one UTXO spent for each "bag" (thus pays for 3 UTXOs).
> > Disagreements on feerate can be resolved by having the taker set the feerate, i.e. "the customer is always right".
> > Thus if the maker has to spend two UTXOs to make up the 0.4 BTC bag, it pays for the mining fees for that extra UTXO.
> > The maker can always reject the swap attempt if it has to spend multiple UTXOs and would lose money doing so if the taker demands a too-high feerate.
>
> Having the taker pay for just one UTXO will have an unfortunate side
> effect of resulting in the maker's money being split up into a large
> number of UTXOs, because every CoinSwap they take part in has an
> incentive to increase their UTXO count by one. At the start of
> JoinMarket this was an issue where then a taker wanting to CoinJoin a
> large would come along and the result would be a huge CoinJoin
> transaction with many many small inputs. Perhaps the taker could pay for
> 2-3 UTXOs to counteract this. (Of course the exact number would be
> configurable by the taker user, but defaults usually don't get changed).
>
> I'm still not convinced with having makers contribute to miner fees. In
> JoinMarket we tried to get makers to contribute a little to miner fees
> and simply they never did in any meaningful way. The market has spoken.
> In terms of incentives makers are happy to wait a very long time, if we
> assume they're just HODLers then even if they earn a few thousand
> satoshis that's good.
>
> > > == Contract transaction definitions ==
> > > Contract transactions are those which may spend from the 2-of-2 multisig
> > > outputs, they transfer the coins into a contract where the coins can be
> > > spent either by waiting for a timeout or providing a hash preimage
> > > value. Ideally contract transactions will never be broadcast but their
> > > existence keeps all parties honest.
> > > M~ is miner fees, which we treat as a random variable, and ultimately
> > > set by whichever pre-signed RBF tx get mined. When we talk about the
> > > contract tx, we actually mean perhaps 20-30 transactions which only
> > > differ by the miner fee and have RBF enabled, so they can be broadcasted
> > > in sequence to get the contract transaction mined regardless of the
> > > demand for block space.
> >
> > The highest-fee version could have, in addition, CPFP-anchor outputs, like those being proposed in Lightning, so even if onchain fees rise above the largest fee reservation, it is possible to add even more fees.
> > Or not.
> > Hmm.
>
> I think RBF transactions are better because they ultimately use less
> block space than CPFP.
>
> There seems to be very little cost in signing many additional
> precomputed RBF transactions. So the taker and makers could sign
> transactions all the way up to 10000 sat/vbyte. I think this doesn't
> apply to Lightning, because bandwidth seems to be more constrained
> there: even a tiny micropayment for 1 satoshi would require 10x or 100x
> more bandwidth if every lightning htlc used precomputed RBF.

I was wondering if it would be a good idea actually if the **largest** fee RBF transaction had additional CPFP anchor outputs, not saying to replace the entire group of RBF transactions entirely.

This is just in case of a very sudden increase in feerates that goes beyond the largest that was prepared beforehand.
"You cannot predict the feerates future" is becoming something of a mantra over in Lightning, though I guess a "big enough" spread of RBF transactions would work in practice >99% of the time.


> > Another thought: later you describe that miner fees are paid by Alice by forwarding those fees as well, how does that work when there are multiple versions of the contract transaction?
>
> Alice only pays the miner fees for the funding transactions, not the
> contract transaction. The miner fees for the contract transactions are
> taken from the contract balance. The contract transactions are 1-input
> 1-output, and whoever ends up with the money will be the one who paid
> the miner fee.

Okay, that is much clearer.

> > > (Alice+timelock_A OR Bob+hash) = Is an output which can be spent
> > > either with Alice's private key
> > > after waiting for a relative
> > > timelock_A, or by Bob's private key by
> > > revealing a hash preimage value
> >
> > The rationale for relative timelocks is that it makes private key turnover slightly more useable by ensuring that, after private key turnover, it is possible to wait indefinitely to spend the UTXO it received.
> > This is in contrast with absolute timelocks, where after private key turnover, it is required to spend received UTXO before the absolute timeout.
> > The dangers are:
> >
> > -   Until it receives the private key, if either of the incoming or outgoing contract transactions are confirmed, every swap participant (taker or maker) should also broadcast the other contract transaction, and resolve by onchain transactions (with loss of privacy).
> > -   After receiving the private key, if the incoming contract transaction is confirmed, it should spend the resulting contract output.
> > -   It is possible to steal from a participant if that participant goes offline longer than the timeout.
> >     This may imply that there may have to be some minimum timeout that makers indicate in their advertisements.
> >     -   The taker can detect if the first maker is offline, then if it is offline, try a contract transaction broadcast, if it confirms, the taker can wait for the timeout; if it times out, the taker can clawback the transaction.
> >         -   This appears to be riskless for the taker.
> >         -   Against a similar attack, Lightning requires channel reserves, which means the first hop never gains control of the entire value, which is a basic requirement for private key turnover.
> >     -   On the other hand, the taker has the largest timeout before it can clawback the funds, so it would wait for a long time, and at any time in between the first maker can come online and spend using the hashlock branch.
> >         -   But the taker can just try on the hope it works; it has nothing to lose.
> >     -   This attack seems to be possible only for the taker to mount.
> >         Other makers on the route cannot know who the other makers are, without cooperation of the taker, who is the only one who knows all the makers.
> >         -   On the other hand, the last maker in the route has an outgoing HTLC with the smallest timelock, so it is the least-risk and therefore a maker who notices its outgoing HTLC has a low timeout might want to just do this anyway even if it is unsure if the taker is offline.
>
> Every off-chain protocol like this has the livelyness requirement. Each
> party must always be watching the chain and be ready to broadcast
> something in response. I'm not sure how any of this relates to the
> choice of relative vs absolute time locks.

Absolute timelocks mean that you can set a timer where you put your node to sleep without risk of loss of funds (basically, once the absolute timelocks have resolved, you can forget about CoinSwaps).
But I think the ability to spend at any time would be better, and getting 100% online 144 blocks a day, 2016 blocks a retargeting period is becoming more and more feasible.

>
> You're right that attempting such an move by the taker is riskless, but
> its not costless. The taker sets up the entire CoinSwap protocol because
> they wanted more privacy; but if the taker broadcasts the Alice contract
> transaction and waits for the timeout, then all they've achieved is
> spent miner fees, got their own coin back and draw attention to it with
> the unusual HTLC script. They've achieved no benefit from what I see, so
> they won't do this. Any taker or maker who attempts anything like this
> will be spending miner fees.

They would be spending miner fees *from the funds being stolen*, thus still costless.

In particular, let us imagine a simple 1-maker swap.

* The taker and the maker complete the swap.
* The taker now has possession of:
  * The private key for its incoming HTLC.
  * The pre-signed contract transaction for its outgoing HTLC.
* The taker spends from its incoming HTLC using the private key.
  * The maker ignores this, because this is just normal operation.
  * Fees paid for this is not an **additional** cost, because a taker that wants to put its freshly-private funds into cold storage will do this anyway.
  * The taker gets a fresh, private coin from this incoming HTLC, so it gets the privacy it paid for.
* The taker waits for the incoming-HTLC-spend to confirm.
* The taker broadcasts the pre-signed contract transaction, in the hope that the maker is offline.
  * The fees paid for this are from the contract transaction that the taker is trying to steal.
    Even if the theft attempt fails, the taker has already gotten its private money out, and is thus not risking anything.
  * Semantically, the outgoing HTLC is already "owned" by the maker (the maker has private key to it).
    * Thus, the taker commits an action that the maker pays fees for!
  * The maker cannot react except to spend via the hashlock branch.
    In particular, because the taker-incoming (maker-outgoing) UTXO is already spent, it cannot retaliate by also broadcasting the contract transaction of the taker-incoming (maker-outgoing) HTLC.
* The theft succeeds (the timelock passes) because the maker happens to be offline for that long.
  * This is "free money" to the taker, who has already gotten what it paid for --- private money in cold storage --- from the CoinSwap.
  * Even if the stolen fund reveals the contract, the taker can re-acquire privacy for the funds it stole for free, by paying for --- wait for it --- another CoinSwap for its swag.

Using an absolute timelock (implemented by a `nLockTime` tx directly off the 2-of-2, ***not*** `OP_CHECKLOCKTIMEVERIFY`), plus a Scriptless Script 2p-ECDSA (again implemented by a tx directly off the 2-of-2) instead of a hashlock, seems to avoid this, I think, at the cost of reducing the utility of private key turnover by having a deadline where the private key *has to* be used.
This is because there is no contract transaction that is share-owned by both participants in the swap.
Instead there are two distinct transactions with separate ownerships: a timeout tx (that is owned by the participant paying for the HTLC/PTLC) and a claim tx (that is owned by the participant accepting the HTLC/PTLC).

> > -   Participants might want to spend from the UTXO to a new address after private key turnover anyway.
> >     Makers could spend using a low-fee RBF-enabled tx, and when another request comes in for another swap, try to build a new funding tx with a higher-fee bump.
> >
>
> I don't think this will happen very often. It's spending money on block
> space for not much benefit. If the maker ever decides to shut down their
> maker they can transfer all their coins in HTLCs to single-sig
> transactions exclusively controlled by them, but in normal operation I
> doubt it will happen.

Accidents can happen (e.g. somebody trips over the power cord of the maker hardware), so hedging this somewhat might give a useful safety net.

>
> The attack I describe works because Alice chooses both MA~ and MB~. The
> attack is that Alice chooses MA~ to be a very low value (e.g. 1 sat/vb)
> and chooses MB~ to be a very high value (e.g. 1000 sat/vb). Then Alice
> intentionally sabotages the CoinSwap and forces it to go to the timeout
> case, what happens is that Bob's wallet balance falls by much more than
> Alice's, because MB~ > MA~. So this is a DOS attack: Alice can waste
> Bob's resources without wasting much of her own.

Ah, right, that is clearer.

> > > == EC tweak to reduce one round trip ==
> > > When two parties are agreeing on a 2-of-2 multisig address, they need to
> > > agree on their public keys. We can avoid one round trip by using the EC
> > > tweak trick.
> > > When Alice, the taker, downloads the entire offer book for the liquidity
> > > market, the offers will also contain a EC public key. Alice can tweak
> > > this to generate a brand new public key for which the maker knows the
> > > private key. This public key will be one of the keys in the 2-of-2
> > > multisig. This feature removes one round trip from the protocol.
> > > q = EC privkey generated by maker
> > > Q = q.G = EC pubkey published by maker
> > > p = nonce generated by taker
> > > P = p.G = nonce point calculated by taker
> > > R = Q + P = pubkey used in bitcoin transaction
> > > = (q + p).G
> >
> > Whoa whoa whoa whoa.
> > All this time I was thinking you were going to use 2p-ECDSA for all 2-of-2s.
> > In which case, the private key generated by the taker would be sufficient tweak to blind this.
> > In 2p-ECDSA, for two participants M = m * G; T = t * G, the total key is m * t * G = m * T = t * M.
> > Are you going to use `2 <T> <Q+P> 2 OP_CHECKMULTISIG` instead of 2p-ECDSA?
> > Note that you cannot usefully hide among Lightning mutual closes, because of the reserve; Lightning mutual closes are very very likely to be spent in a 1-input (that spends from a 2-of-2 P2WSH), 2-output (that pays to two P2WPKHs) tx.
>
> Yes, I intend for 2p-ECDSA to be used eventually, but for the first
> version I'll only implement regular multisigs with OP_CHECKMULTISIG.
> Once all the other details of this protocol are implemented correctly
> and mostly-bug-free then 2p-ECDSA can be added. It can be added in the
> protocol steps 0-1, 3-5 and 7-9.

Okay, that is clearer.

I think 2p-ECDSA should be first priority after getting a decent alpha version.

> This document also doesn't talk about PayJoin-with-CoinSwap, but that
> can be added later too.

2p-ECDSA with Scriptless Script potentially gives a lot more privacy than any PayJoin IMO, due simply to the much larger anonymity set, and there are enough chain-analysis-heuristic-breaking shenanigans we can implement with plain CoinSwap, I think.


Regards,
ZmnSCPxj

From eric at voskuil.org  Fri Aug 21 04:25:08 2020
From: eric at voskuil.org (Eric Voskuil)
Date: Thu, 20 Aug 2020 21:25:08 -0700
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
	connections are setup
In-Reply-To: <20200821023647.7eat4goqqrtaqnna@erisian.com.au>
References: <20200821023647.7eat4goqqrtaqnna@erisian.com.au>
Message-ID: <D8D5CF3A-27AE-4000-BECB-9926DCF7CB4C@voskuil.org>

Hi Anthony,

This is what I was implying in my last post (the reference to the unnecessary overload of message typing). However, if one imagines a sequence diagram for this communication it becomes obvious that all such messages are 100% redundant with verack.

e

> On Aug 20, 2020, at 19:37, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> ?On Fri, Aug 14, 2020 at 03:28:41PM -0400, Suhas Daftuar via bitcoin-dev wrote:
>> In thinking about the mechanism used there, I thought it would be helpful to
>> codify in a BIP the idea that Bitcoin network clients should ignore unknown
>> messages received before a VERACK.  A draft of my proposal is available here
>> [2].
> 
> Rather than allowing arbitrary messages, maybe it would make sense to
> have a specific feature negotiation message, eg:
> 
>  VERSION ...
>  FEATURE wtxidrelay
>  FEATURE packagerelay
>  VERACK
> 
> with the behaviour being that it's valid only between VERSION and VERACK,
> and it takes a length-prefixed-string giving the feature name, optional
> additional data, and if the feature name isn't recognised the message
> is ignored.
> 
> If we were to support a "polite disconnect" feature like Jeremy suggested,
> it might be easier to do that for a generic FEATURE message, than
> reimplement it for the message proposed by each new feature.
> 
> Cheers,
> aj
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From dkbryant at gmail.com  Fri Aug 21 05:55:59 2020
From: dkbryant at gmail.com (Dan Bryant)
Date: Fri, 21 Aug 2020 00:55:59 -0500
Subject: [bitcoin-dev] Time to lower minrelaytxfee ?
Message-ID: <CAAUFj113g15EUXvdQG1caLBar6HakLRag6URA9Q-y52OZEmhzQ@mail.gmail.com>

It's been 5 years since minrealytxfee was lowered.  At the time
bitcoin was trading for $255 and it was agreed that the fee of 5000
sat/vkB was too high.  It was lowered to 1000 sat/vkB.  In regards to
how much anti-DoS protection that provided, it comes out to $0.00255 /
vkB in USD terms.  To have parity with the last reduction, we would
need to reduce minrealytxfee to 22 sat/vKB, though an even more
conservative reduction to 100 or 50 sat/vKB would be welcome.

With the growing adoption of LN, there is a need for ultra-low-fee
on-chain TXNs.  Having these queue and confirm overnight, or even
waiting until the Sunday lull would still probably be welcome to many
users.  The fact that the mempool is going empty at least every week
indicates that miners have not reached the floor of what they are
willing to mine.

About 2 years ago there was a PR (#13922) to try to make a reduction
from 1000 to 200 sat/vkB.  It was widely accepted but the submitter
eventually closed it in favor of PR #13990.

If minrelaytxfee is already parameterized and configurable in
bitcoin.conf, how could it be detrimental to operation of a node to
change the default?

References:

* https://github.com/bitcoin/bitcoin/commit/9e93640be6c49fa1505ba5c5df8c89210da5a6e4
* https://github.com/bitcoin/bitcoin/pull/13922
* https://github.com/bitcoin/bitcoin/pull/13990

From john at johnnewbery.com  Fri Aug 21 08:50:49 2020
From: john at johnnewbery.com (John Newbery)
Date: Fri, 21 Aug 2020 09:50:49 +0100
Subject: [bitcoin-dev] Revisiting squaredness tiebreaker for R point in
	BIP340
In-Reply-To: <g7VgKBKlUmgMkNo6Nq1OkyilwW6Z4WbqeSZHXfvh_LDYmry5R7uGbavyEHtv2xr_0KBevL057TxSdlo_tS0_ucBXYNm8MuTu_jgyrGO9jpo=@wuille.net>
References: <g7VgKBKlUmgMkNo6Nq1OkyilwW6Z4WbqeSZHXfvh_LDYmry5R7uGbavyEHtv2xr_0KBevL057TxSdlo_tS0_ucBXYNm8MuTu_jgyrGO9jpo=@wuille.net>
Message-ID: <CAFmfg2uL-gCV+1e1rf8+ywSUcEGTA01PP4jm+8kYub7R9E9hNw@mail.gmail.com>

Pieter,

Thanks for the illuminating write-up. There seem to be two questions here,
one technical and one process:

1. Is changing to even tie-breaker for R the correct choice technically? I
can't comment on the performance characteristics of using a square/even
tie-breaker and I'll assume the numbers you give are correct. An enormous
benefit that you don't mention (but Nadav and Lloyd do) is that
standardizing to a single tie-breaker for R points and public keys is much
simpler to explain and much easier for implementers and developers to
understand. I've explained the taproot proposals to many people through the
optech workshops and bitdevs meetups, and people are invariably confused by
which type of tie-breaker to use where. Absent a large performance benefit
for having different tiebreakers, I think this alone is good reason to
standardize to one tie-breaker.

2. Is it too late in the process to change? No. We're building things to
last years, hopefully decades. We should measure a hundred times and cut
once. A benefit of the long lead time of taproot is that as we get more
information, we can improve the proposal. Let's do that here. Nadav and
Lloyd have both written alternative implementations of taproot and are
happy to make this change. Presumably if this was going to cause serious
pain for any other implementer/developer they would have raised objections
by now.

Summary: We should change the proposal and implementation to use even
tie-breakers everywhere.

John #notoquadraticresiduetiebreakers Newbery

On Wed, Aug 12, 2020 at 7:49 PM Pieter Wuille via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hello all,
>
> The current BIP340 draft[1] uses two different tiebreakers for conveying
> the Y coordinate of points: for the R point inside signatures squaredness
> is used, while for public keys evenness is used. Originally both used
> squaredness, but it was changed[2] for public keys after observing this
> results in additional complexity for compatibility with existing systems.
>
> The reason for choosing squaredness as tiebreaker was performance: in
> non-batch signature validation, the recomputed R point must be verified to
> have the correct sign, to guarantee consistency with batch validation.
> Whether the Y coordinate is square can be computed directly in Jacobian
> coordinates, while determining evenness requires a conversion to affine
> coordinates first.
>
> This argument of course relies on the assumption that determining whether
> the Y coordinate is square can be done more efficiently than a conversion
> to affine coordinates. It appears now that this assumption is incorrect,
> and the justification for picking the squaredness tiebreaking doesn't
> really exist. As it comes with other trade-offs (it slows down signing, and
> is a less conventional choice), it would seem that we should reconsider the
> option of having the R point use the evenness tiebreaker (like public keys).
>
> It is late in the process, but I feel I owe this explanation so that at
> least the possibility of changing can be discussed with all information. On
> the upside, this was discovered in the context of looking into a cool
> improvement to libsecp256k1[5], which makes things faster in general, but
> specifically benefits the evenness variant.
>
>
> # 1. What happened?
>
> Computing squaredness is done through the Jacobi symbol (same inventor,
> but unrelated to Jacobian coordinates). Computing evenness requires
> converting points to affine coordinates first, and that needs a modular
> inverse. The assumption that Jacobi symbols are faster to compute than
> inverses was based on:
>
> * A (possibly) mistaken belief about the theory: fast algorithms for both
> Jacobi symbols and inverses are internally based on variants of the same
> extended GCD algorithm[3]. Since an inverse needs to extract a full big
> integer out of the transition steps made in the extgcd algorithm, while the
> Jacobi symbol just extracts a single bit, it had seemed that any advances
> applicable to one would be applicable to the other, but inverses would
> always need additional work on top. It appears however that a class of
> extgcd algorithms exists (LSB based ones) that cannot be used for Jacobi
> calculations without losing efficiency. Recent developments[4] and a
> proposed implementation in libsecp256k1[5] by Peter Dettman show that using
> this, inverses in some cases can in fact be faster than Jacobi symbols.
>
> * A broken benchmark. This belief was incorrectly confirmed by a broken
> benchmark[6] in libsecp256k1 for the libgmp-based Jacobi symbol calculation
> and modular inverse. The benchmark was repeatedly testing the same constant
> input, which apparently was around 2.5x faster than the average speed. It
> is a variable-time algorithm, so a good variation of inputs matters. This
> mistake had me (and probably others) convinced for years that Jacobi
> symbols were amazingly fast, while in reality they were always very close
> in performance to inverses.
>
>
> # 2. What is the actual impact of picking evenness instead?
>
> It is hard to make very generic statements here, as BIP340 will hopefully
> be used for a long time, and hardware advancements and algorithmic
> improvements may change the balance. That said, performance on current
> hardware with optimized algorithms is the best approximation we have.
>
> The numbers below give the expected performance change from squareness to
> evenness, for single BIP340 validation, and for signing. Positive numbers
> mean evenness is faster. Batch validation is not impacted at all.
>
> In the short term, for block validation in Bitcoin Core, the numbers for
> master-nogmp are probably the most relevant (as Bitcoin Core uses
> libsecp256k1 without libgmp, to reduce consensus-critical dependencies).
> If/when [5] gets merged, safegcd-nogmp will be what matters. On a longer
> time scale, the gmp numbers may be more relevant, as the Jacobi
> implementation there is certainly closer to the state of the art.
>
> * i7-7820HQ: (verify) (sign)
>   - master-nogmp: -0.3% +16.1%
>   - safegcd-nogmp: +6.7% +17.1%
>   - master-gmp: +0.6% +7.7%
>   - safegcd-gmp: +1.6% +8.6%
>
> * Cortex-A53: (verify) (sign)
>   - master-nogmp: -0.3% +15.7%
>   - safegcd-nogmp: +7.5% +16.9%
>   - master-gmp: +0.3% +4.1%
>   - safegcd-gmp: 0.0% +3.5%
>
> * EPYC 7742: (verify) (sign)
>   - master-nogmp: -0.3% +16.8%
>   - safegcd-nogmp: +8.6% +18.4%
>   - master-gmp: 0.0% +7.4%
>   - safegcd-gmp: +2.3% +7.8%
>
> In well optimized cryptographic code speedups as large as a couple percent
> are difficult to come by, so we would usually consider changes of this
> magnitude relevant. Note however that while the percentages for signing
> speed are larger, they are not what is unexpected here. The choice for the
> square tiebreaker was intended to improve verification speed at the cost of
> signing speed. As it turns out that it doesn't actually benefit
> verification speed, this is a bad trade-off.
>
>
> # 3. How big a change is it
>
> * In the BIP:
>   - Changing both invocations of `has_square_y` to `has_even_y`.
>   - Changing the `lift_x_square_y` invocation to `lift_x_even_y`.
>   - Applying the same change to the test vector generation code, and the
> resulting test vectors.
> * In the libsecp256k1:
>   - An 8-line patch to the proposed BIP340 implementation[7]: see [8]
> * In Bitcoin Core:
>   - Similarly small changes to the Python test reimplementation[9]
> * Duplicating these changes in other draft implementations that may
> already exist.
> * Review for all the above.
>
>
> # 4. Conclusion
>
> We discovered that the justification for using squaredness tiebreakers in
> BIP340 is based on a misunderstanding, and recent developments show that it
> may in fact be a somewhat worse choice than the alternative. It is a
> relatively simple change to address this, but that has be weighed against
> the impact of changing the standard at this stage.
>
> Thoughts?
>
>
> # 5. References
>
>   [1]
> https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#design
>   [2]
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017639.html
>   [3] https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
>   [4] https://gcd.cr.yp.to/safegcd-20190413.pdf
>   [5] https://github.com/bitcoin-core/secp256k1/pull/767
>   [6] https://github.com/bitcoin-core/secp256k1/pull/797
>   [7] https://github.com/bitcoin-core/secp256k1/pull/558
>   [8]
> https://github.com/sipa/secp256k1/commit/822311ca230a48d2c373f3e48b91b2a59e1371d6
>   [9] https://github.com/bitcoin/bitcoin/pull/17977
>
>
> Cheers,
>
> --
> Pieter
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200821/52fd57bc/attachment-0001.html>

From belcher at riseup.net  Fri Aug 21 09:47:31 2020
From: belcher at riseup.net (Chris Belcher)
Date: Fri, 21 Aug 2020 10:47:31 +0100
Subject: [bitcoin-dev] Detailed protocol design for routed
 multi-transaction CoinSwap
In-Reply-To: <WtKtWCdqIFVTTqw9-EggdsTIo6ejfP8my868MYyAqO8FUboiXWZUd0hw2PyvEKZNJxqAWJ_9BnOllAGEuUYYcA654amKTC4MSmO3TO4A7pU=@protonmail.com>
References: <813e51a1-4252-08c0-d42d-5cef32f684bc@riseup.net>
 <xhRsCejqgUjoLy5hPMHgFcZdiqJsO7TfS0azWhis9-tvSgXodoKe7gN5IXyiVIVqUWSm7FoY-aBUaJCCDgixdWUN4n8EzhQlSNshsQeIFsw=@protonmail.com>
 <e8ca67be-d07c-3f2e-4318-0d2bab061dd9@riseup.net>
 <WtKtWCdqIFVTTqw9-EggdsTIo6ejfP8my868MYyAqO8FUboiXWZUd0hw2PyvEKZNJxqAWJ_9BnOllAGEuUYYcA654amKTC4MSmO3TO4A7pU=@protonmail.com>
Message-ID: <f5ba3015-2ec8-b35d-dc40-3e3e9e11449f@riseup.net>

Hello,

On 21/08/2020 05:20, ZmnSCPxj wrote:
> Good morning,
> 
> 
> 
>> Right, so if the taker uses only a single maker then they must have more
>> than one UTXO.
> 
> Spending one UTXO is fine, it is generating a transaction that has one output that is problematic.
> 
> What needs to happen is that this single UTXO is spent to two outputs: the CoinSwap 2-of-2 and the change output.
> This is because intermediate makers will have very high likelihood of generating such a pattern (it is unlikely they have an exact amount that a taker would require of them), and the occassional maker might have a very large UTXO that it can use for similar purposes.
> 
> One thing a taker can do would be to multipath its CoinSwap, i.e. it spends any number of UTXOs and creates two outputs, which are actually two separate CoinSwap 2-of-2s to different makers.
> As each maker is unaware of the other, this should be similar to the case where the maker is an intermediate hop and is getting its incoming HTLC from another maker, which is unlikely to have a precise amount and will thus have a transaction that has two outputs, the 2-of-2 CoinSwap and the change.

Agreed.
I write about multipath CoinSwap routes in the original design document,
under "Combining multi-transaction with routing"


>>>> === Miner fees ===
>>>> Makers have no incentive to pay any miner fees. They only do
>>>> transactions which earn them an income and are willing to wait a very
>>>> long time for that to happen. By contrast takers want to create
>>>> transactions far more urgently. In JoinMarket we coded a protocol where
>>>> the maker could contribute to miner fees, but the market price offered
>>>> of that trended towards zero. So the reality is that takers will pay all
>>>> the miner fees. Also because makers don't know the taker's time
>>>> preference they don't know how much they should pay in miner fees.
>>>> The taker will have to set limits on how large the maker's transactions
>>>> are, otherwise makers could abuse this by having the taker consolidate
>>>> maker's UTXOs for free.
>>>
>>> Why not have the taker pay for the first maker-spent UTXO and have additional maker-spent UTXOs paid for by the maker?
>>> i.e. the taker indicates "swap me 1 BTC in 3 bags of 0.3, 0.3, and 0.4 BTC", and pays for one UTXO spent for each "bag" (thus pays for 3 UTXOs).
>>> Disagreements on feerate can be resolved by having the taker set the feerate, i.e. "the customer is always right".
>>> Thus if the maker has to spend two UTXOs to make up the 0.4 BTC bag, it pays for the mining fees for that extra UTXO.
>>> The maker can always reject the swap attempt if it has to spend multiple UTXOs and would lose money doing so if the taker demands a too-high feerate.
>>
>> Having the taker pay for just one UTXO will have an unfortunate side
>> effect of resulting in the maker's money being split up into a large
>> number of UTXOs, because every CoinSwap they take part in has an
>> incentive to increase their UTXO count by one. At the start of
>> JoinMarket this was an issue where then a taker wanting to CoinJoin a
>> large would come along and the result would be a huge CoinJoin
>> transaction with many many small inputs. Perhaps the taker could pay for
>> 2-3 UTXOs to counteract this. (Of course the exact number would be
>> configurable by the taker user, but defaults usually don't get changed).
>>
>> I'm still not convinced with having makers contribute to miner fees. In
>> JoinMarket we tried to get makers to contribute a little to miner fees
>> and simply they never did in any meaningful way. The market has spoken.
>> In terms of incentives makers are happy to wait a very long time, if we
>> assume they're just HODLers then even if they earn a few thousand
>> satoshis that's good.
>>
>>>> == Contract transaction definitions ==
>>>> Contract transactions are those which may spend from the 2-of-2 multisig
>>>> outputs, they transfer the coins into a contract where the coins can be
>>>> spent either by waiting for a timeout or providing a hash preimage
>>>> value. Ideally contract transactions will never be broadcast but their
>>>> existence keeps all parties honest.
>>>> M~ is miner fees, which we treat as a random variable, and ultimately
>>>> set by whichever pre-signed RBF tx get mined. When we talk about the
>>>> contract tx, we actually mean perhaps 20-30 transactions which only
>>>> differ by the miner fee and have RBF enabled, so they can be broadcasted
>>>> in sequence to get the contract transaction mined regardless of the
>>>> demand for block space.
>>>
>>> The highest-fee version could have, in addition, CPFP-anchor outputs, like those being proposed in Lightning, so even if onchain fees rise above the largest fee reservation, it is possible to add even more fees.
>>> Or not.
>>> Hmm.
>>
>> I think RBF transactions are better because they ultimately use less
>> block space than CPFP.
>>
>> There seems to be very little cost in signing many additional
>> precomputed RBF transactions. So the taker and makers could sign
>> transactions all the way up to 10000 sat/vbyte. I think this doesn't
>> apply to Lightning, because bandwidth seems to be more constrained
>> there: even a tiny micropayment for 1 satoshi would require 10x or 100x
>> more bandwidth if every lightning htlc used precomputed RBF.
> 
> I was wondering if it would be a good idea actually if the **largest** fee RBF transaction had additional CPFP anchor outputs, not saying to replace the entire group of RBF transactions entirely.
> 
> This is just in case of a very sudden increase in feerates that goes beyond the largest that was prepared beforehand.
> "You cannot predict the feerates future" is becoming something of a mantra over in Lightning, though I guess a "big enough" spread of RBF transactions would work in practice >99% of the time.

Got it. I agree having a CPFP anchor output on the largest fee RBF is a
good idea then.

> 
>>>> (Alice+timelock_A OR Bob+hash) = Is an output which can be spent
>>>> either with Alice's private key
>>>> after waiting for a relative
>>>> timelock_A, or by Bob's private key by
>>>> revealing a hash preimage value
>>>
>>> The rationale for relative timelocks is that it makes private key turnover slightly more useable by ensuring that, after private key turnover, it is possible to wait indefinitely to spend the UTXO it received.
>>> This is in contrast with absolute timelocks, where after private key turnover, it is required to spend received UTXO before the absolute timeout.
>>> The dangers are:
>>>
>>> -   Until it receives the private key, if either of the incoming or outgoing contract transactions are confirmed, every swap participant (taker or maker) should also broadcast the other contract transaction, and resolve by onchain transactions (with loss of privacy).
>>> -   After receiving the private key, if the incoming contract transaction is confirmed, it should spend the resulting contract output.
>>> -   It is possible to steal from a participant if that participant goes offline longer than the timeout.
>>>     This may imply that there may have to be some minimum timeout that makers indicate in their advertisements.
>>>     -   The taker can detect if the first maker is offline, then if it is offline, try a contract transaction broadcast, if it confirms, the taker can wait for the timeout; if it times out, the taker can clawback the transaction.
>>>         -   This appears to be riskless for the taker.
>>>         -   Against a similar attack, Lightning requires channel reserves, which means the first hop never gains control of the entire value, which is a basic requirement for private key turnover.
>>>     -   On the other hand, the taker has the largest timeout before it can clawback the funds, so it would wait for a long time, and at any time in between the first maker can come online and spend using the hashlock branch.
>>>         -   But the taker can just try on the hope it works; it has nothing to lose.
>>>     -   This attack seems to be possible only for the taker to mount.
>>>         Other makers on the route cannot know who the other makers are, without cooperation of the taker, who is the only one who knows all the makers.
>>>         -   On the other hand, the last maker in the route has an outgoing HTLC with the smallest timelock, so it is the least-risk and therefore a maker who notices its outgoing HTLC has a low timeout might want to just do this anyway even if it is unsure if the taker is offline.
>>
>> Every off-chain protocol like this has the livelyness requirement. Each
>> party must always be watching the chain and be ready to broadcast
>> something in response. I'm not sure how any of this relates to the
>> choice of relative vs absolute time locks.
> 
> Absolute timelocks mean that you can set a timer where you put your node to sleep without risk of loss of funds (basically, once the absolute timelocks have resolved, you can forget about CoinSwaps).
> But I think the ability to spend at any time would be better, and getting 100% online 144 blocks a day, 2016 blocks a retargeting period is becoming more and more feasible.

You can always put your node to sleep as a maker, and your watchtowers
will protect you.

What do you mean by the point about 100% online nodes getting more
feasible? Many bitcoin nodes have been always-on for years, I think I
missed something.

>> You're right that attempting such an move by the taker is riskless, but
>> its not costless. The taker sets up the entire CoinSwap protocol because
>> they wanted more privacy; but if the taker broadcasts the Alice contract
>> transaction and waits for the timeout, then all they've achieved is
>> spent miner fees, got their own coin back and draw attention to it with
>> the unusual HTLC script. They've achieved no benefit from what I see, so
>> they won't do this. Any taker or maker who attempts anything like this
>> will be spending miner fees.
> 
> They would be spending miner fees *from the funds being stolen*, thus still costless.
> 
> In particular, let us imagine a simple 1-maker swap.
> 
> * The taker and the maker complete the swap.
> * The taker now has possession of:
>   * The private key for its incoming HTLC.
>   * The pre-signed contract transaction for its outgoing HTLC.
> * The taker spends from its incoming HTLC using the private key.
>   * The maker ignores this, because this is just normal operation.
>   * Fees paid for this is not an **additional** cost, because a taker that wants to put its freshly-private funds into cold storage will do this anyway.
>   * The taker gets a fresh, private coin from this incoming HTLC, so it gets the privacy it paid for.
> * The taker waits for the incoming-HTLC-spend to confirm.
> * The taker broadcasts the pre-signed contract transaction, in the hope that the maker is offline.
>   * The fees paid for this are from the contract transaction that the taker is trying to steal.
>     Even if the theft attempt fails, the taker has already gotten its private money out, and is thus not risking anything.
>   * Semantically, the outgoing HTLC is already "owned" by the maker (the maker has private key to it).
>     * Thus, the taker commits an action that the maker pays fees for!
>   * The maker cannot react except to spend via the hashlock branch.
>     In particular, because the taker-incoming (maker-outgoing) UTXO is already spent, it cannot retaliate by also broadcasting the contract transaction of the taker-incoming (maker-outgoing) HTLC.
> * The theft succeeds (the timelock passes) because the maker happens to be offline for that long.
>   * This is "free money" to the taker, who has already gotten what it paid for --- private money in cold storage --- from the CoinSwap.
>   * Even if the stolen fund reveals the contract, the taker can re-acquire privacy for the funds it stole for free, by paying for --- wait for it --- another CoinSwap for its swag.

Yep you're right, I get it.

The biggest defense against theft will have to be multiple redundant
watchtowers. But as you say the attack is riskless and costless for the
taker to attempt, so they might try anyway even if the probability of
success is very low.

If this attack becomes widespread then it effectively breaks the
property that maker's coins remain unspent indefinitely. It seems like
that would lead to makers increasing their CoinSwap fees because they
know they'll always have to spend a bit of miner fees afterwards.

Hopefully the success rate for this attack can be low enough that
taker's human niceness will stop them trying. But for sure this is a
concerning problem.

> Using an absolute timelock (implemented by a `nLockTime` tx directly off the 2-of-2, ***not*** `OP_CHECKLOCKTIMEVERIFY`), plus a Scriptless Script 2p-ECDSA (again implemented by a tx directly off the 2-of-2) instead of a hashlock, seems to avoid this, I think, at the cost of reducing the utility of private key turnover by having a deadline where the private key *has to* be used.
> This is because there is no contract transaction that is share-owned by both participants in the swap.
> Instead there are two distinct transactions with separate ownerships: a timeout tx (that is owned by the participant paying for the HTLC/PTLC) and a claim tx (that is owned by the participant accepting the HTLC/PTLC).

A downside of using absolute timelocks is that it combines the two time
periods: the time period where a watchtower must respond and the time
period under which private keys must be used.

So for example if the absolute timelock is set to 3 weeks, that means
the maker has 3 weeks to spend their coins using the private keys which
is a nice long period. However if the CoinSwaps fails with the timeout
case then the maker has to wait 3 weeks to get their coins back, which
is a long time.

We can go the other extreme and set the absolute timelock to be 2 days.
Then the maker only has to wait 2 days in the unfortunate event that
their coinswap fails with the timeout case. But it means they must use
their private keys to spend coins within the short period of 2 days(!)

Though this still might be worth it to solve the riskless/costless
stealing attempts.


>>> -   Participants might want to spend from the UTXO to a new address after private key turnover anyway.
>>>     Makers could spend using a low-fee RBF-enabled tx, and when another request comes in for another swap, try to build a new funding tx with a higher-fee bump.
>>>
>>
>> I don't think this will happen very often. It's spending money on block
>> space for not much benefit. If the maker ever decides to shut down their
>> maker they can transfer all their coins in HTLCs to single-sig
>> transactions exclusively controlled by them, but in normal operation I
>> doubt it will happen.
> 
> Accidents can happen (e.g. somebody trips over the power cord of the maker hardware), so hedging this somewhat might give a useful safety net.

Right, but taking out the maker hardware isn't enough for funds to be
stolen, all the watchtowers would need to be taken out too.


>>>> == EC tweak to reduce one round trip ==
>>>> When two parties are agreeing on a 2-of-2 multisig address, they need to
>>>> agree on their public keys. We can avoid one round trip by using the EC
>>>> tweak trick.
>>>> When Alice, the taker, downloads the entire offer book for the liquidity
>>>> market, the offers will also contain a EC public key. Alice can tweak
>>>> this to generate a brand new public key for which the maker knows the
>>>> private key. This public key will be one of the keys in the 2-of-2
>>>> multisig. This feature removes one round trip from the protocol.
>>>> q = EC privkey generated by maker
>>>> Q = q.G = EC pubkey published by maker
>>>> p = nonce generated by taker
>>>> P = p.G = nonce point calculated by taker
>>>> R = Q + P = pubkey used in bitcoin transaction
>>>> = (q + p).G
>>>
>>> Whoa whoa whoa whoa.
>>> All this time I was thinking you were going to use 2p-ECDSA for all 2-of-2s.
>>> In which case, the private key generated by the taker would be sufficient tweak to blind this.
>>> In 2p-ECDSA, for two participants M = m * G; T = t * G, the total key is m * t * G = m * T = t * M.
>>> Are you going to use `2 <T> <Q+P> 2 OP_CHECKMULTISIG` instead of 2p-ECDSA?
>>> Note that you cannot usefully hide among Lightning mutual closes, because of the reserve; Lightning mutual closes are very very likely to be spent in a 1-input (that spends from a 2-of-2 P2WSH), 2-output (that pays to two P2WPKHs) tx.
>>
>> Yes, I intend for 2p-ECDSA to be used eventually, but for the first
>> version I'll only implement regular multisigs with OP_CHECKMULTISIG.
>> Once all the other details of this protocol are implemented correctly
>> and mostly-bug-free then 2p-ECDSA can be added. It can be added in the
>> protocol steps 0-1, 3-5 and 7-9.
> 
> Okay, that is clearer.
> 
> I think 2p-ECDSA should be first priority after getting a decent alpha version.
> 
>> This document also doesn't talk about PayJoin-with-CoinSwap, but that
>> can be added later too.
> 
> 2p-ECDSA with Scriptless Script potentially gives a lot more privacy than any PayJoin IMO, due simply to the much larger anonymity set, and there are enough chain-analysis-heuristic-breaking shenanigans we can implement with plain CoinSwap, I think.

I completely agree.


Regards
CB

From lf-lists at mattcorallo.com  Fri Aug 21 14:15:10 2020
From: lf-lists at mattcorallo.com (lf-lists at mattcorallo.com)
Date: Fri, 21 Aug 2020 10:15:10 -0400
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
	connections are setup
In-Reply-To: <20200821023647.7eat4goqqrtaqnna@erisian.com.au>
References: <20200821023647.7eat4goqqrtaqnna@erisian.com.au>
Message-ID: <A26FA2BC-50E5-4635-95E4-56AAA969C9DA@mattcorallo.com>

Sure, we could do a new message for negotiation, but there doesn?t seem to be a lot of reason for it - using the same namespace for negotiation seems fine too. In any case, this is one of those things that doesn?t matter in the slightest, and if one person volunteers to write a BIP and code, no reason they shouldn?t just decide and be allowed to run with it. Rough consensus and running code, as it were :)

Matt


> On Aug 20, 2020, at 22:37, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> ?On Fri, Aug 14, 2020 at 03:28:41PM -0400, Suhas Daftuar via bitcoin-dev wrote:
>> In thinking about the mechanism used there, I thought it would be helpful to
>> codify in a BIP the idea that Bitcoin network clients should ignore unknown
>> messages received before a VERACK.  A draft of my proposal is available here
>> [2].
> 
> Rather than allowing arbitrary messages, maybe it would make sense to
> have a specific feature negotiation message, eg:
> 
>  VERSION ...
>  FEATURE wtxidrelay
>  FEATURE packagerelay
>  VERACK
> 
> with the behaviour being that it's valid only between VERSION and VERACK,
> and it takes a length-prefixed-string giving the feature name, optional
> additional data, and if the feature name isn't recognised the message
> is ignored.
> 
> If we were to support a "polite disconnect" feature like Jeremy suggested,
> it might be easier to do that for a generic FEATURE message, than
> reimplement it for the message proposed by each new feature.
> 
> Cheers,
> aj
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From nadav at shesek.info  Fri Aug 21 16:36:30 2020
From: nadav at shesek.info (Nadav Ivgi)
Date: Fri, 21 Aug 2020 19:36:30 +0300
Subject: [bitcoin-dev] Time to lower minrelaytxfee ?
In-Reply-To: <CAAUFj113g15EUXvdQG1caLBar6HakLRag6URA9Q-y52OZEmhzQ@mail.gmail.com>
References: <CAAUFj113g15EUXvdQG1caLBar6HakLRag6URA9Q-y52OZEmhzQ@mail.gmail.com>
Message-ID: <CAGXD5f3=H9TinyYh122oq1x+3exTyxvvAT1m_eiNY34Nhw7bcA@mail.gmail.com>

Having large portions of the network using a different minrelayfee could
make it easier to reliably get different parts of the network to accept
different conflicting transactions into their mempools, which could
potentially be used to double-spend unconfirmed non-rbf transactions with
more ease. Node operators that accept unconfirmed payments with a
minrelayfee that's higher than what other nodes/miners are typically
accepting would be at risk.

Relying on unconfirmed transactions is of course discouraged so I'm not
sure how much weight this should be given if at all, but I thought it was
at least worth bringing up.

Nadav


On Fri, Aug 21, 2020 at 11:00 AM Dan Bryant via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> It's been 5 years since minrealytxfee was lowered.  At the time
> bitcoin was trading for $255 and it was agreed that the fee of 5000
> sat/vkB was too high.  It was lowered to 1000 sat/vkB.  In regards to
> how much anti-DoS protection that provided, it comes out to $0.00255 /
> vkB in USD terms.  To have parity with the last reduction, we would
> need to reduce minrealytxfee to 22 sat/vKB, though an even more
> conservative reduction to 100 or 50 sat/vKB would be welcome.
>
> With the growing adoption of LN, there is a need for ultra-low-fee
> on-chain TXNs.  Having these queue and confirm overnight, or even
> waiting until the Sunday lull would still probably be welcome to many
> users.  The fact that the mempool is going empty at least every week
> indicates that miners have not reached the floor of what they are
> willing to mine.
>
> About 2 years ago there was a PR (#13922) to try to make a reduction
> from 1000 to 200 sat/vkB.  It was widely accepted but the submitter
> eventually closed it in favor of PR #13990.
>
> If minrelaytxfee is already parameterized and configurable in
> bitcoin.conf, how could it be detrimental to operation of a node to
> change the default?
>
> References:
>
> *
> https://github.com/bitcoin/bitcoin/commit/9e93640be6c49fa1505ba5c5df8c89210da5a6e4
> * https://github.com/bitcoin/bitcoin/pull/13922
> * https://github.com/bitcoin/bitcoin/pull/13990
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200821/fb241441/attachment.html>

From gsanders87 at gmail.com  Fri Aug 21 16:57:32 2020
From: gsanders87 at gmail.com (Greg Sanders)
Date: Fri, 21 Aug 2020 12:57:32 -0400
Subject: [bitcoin-dev] Time to lower minrelaytxfee ?
In-Reply-To: <CAAUFj113g15EUXvdQG1caLBar6HakLRag6URA9Q-y52OZEmhzQ@mail.gmail.com>
References: <CAAUFj113g15EUXvdQG1caLBar6HakLRag6URA9Q-y52OZEmhzQ@mail.gmail.com>
Message-ID: <CAB3F3DuRN2ZzubrWYE6xTF78tU2kO1=XonHf_JFdfRTHYHfgjg@mail.gmail.com>

No strong opinions but:

Denial of service attacks can become 5x cheaper.

If you don't thoroughly test
https://github.com/bitcoin/bitcoin/issues/16499 these
changes you can end up with bugs that can cause issues on p2p network.

On Fri, Aug 21, 2020 at 4:00 AM Dan Bryant via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> It's been 5 years since minrealytxfee was lowered.  At the time
> bitcoin was trading for $255 and it was agreed that the fee of 5000
> sat/vkB was too high.  It was lowered to 1000 sat/vkB.  In regards to
> how much anti-DoS protection that provided, it comes out to $0.00255 /
> vkB in USD terms.  To have parity with the last reduction, we would
> need to reduce minrealytxfee to 22 sat/vKB, though an even more
> conservative reduction to 100 or 50 sat/vKB would be welcome.
>
> With the growing adoption of LN, there is a need for ultra-low-fee
> on-chain TXNs.  Having these queue and confirm overnight, or even
> waiting until the Sunday lull would still probably be welcome to many
> users.  The fact that the mempool is going empty at least every week
> indicates that miners have not reached the floor of what they are
> willing to mine.
>
> About 2 years ago there was a PR (#13922) to try to make a reduction
> from 1000 to 200 sat/vkB.  It was widely accepted but the submitter
> eventually closed it in favor of PR #13990.
>
> If minrelaytxfee is already parameterized and configurable in
> bitcoin.conf, how could it be detrimental to operation of a node to
> change the default?
>
> References:
>
> *
> https://github.com/bitcoin/bitcoin/commit/9e93640be6c49fa1505ba5c5df8c89210da5a6e4
> * https://github.com/bitcoin/bitcoin/pull/13922
> * https://github.com/bitcoin/bitcoin/pull/13990
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200821/53f9cfde/attachment.html>

From eric at voskuil.org  Fri Aug 21 16:42:46 2020
From: eric at voskuil.org (Eric Voskuil)
Date: Fri, 21 Aug 2020 09:42:46 -0700
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
	connections are setup
In-Reply-To: <A26FA2BC-50E5-4635-95E4-56AAA969C9DA@mattcorallo.com>
References: <A26FA2BC-50E5-4635-95E4-56AAA969C9DA@mattcorallo.com>
Message-ID: <B514142F-382B-4D49-B68D-0115ECBD1D79@voskuil.org>

I?m pretty sure one can run whatever they want even without a BIP. There is nobody here to do any ?allowing?. On the other hand, standards development is tedious for good reason.

Generally speaking, overloading is a primary source of complexity (creating more branches in code and human explanation). Nevertheless this is verack payload, no additional messages are necessary or helpful.

e

> On Aug 21, 2020, at 07:15, Matt Corallo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> ?Sure, we could do a new message for negotiation, but there doesn?t seem to be a lot of reason for it - using the same namespace for negotiation seems fine too. In any case, this is one of those things that doesn?t matter in the slightest, and if one person volunteers to write a BIP and code, no reason they shouldn?t just decide and be allowed to run with it. Rough consensus and running code, as it were :)
> 
> Matt
> 
> 
>>> On Aug 20, 2020, at 22:37, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>> 
>>> ?On Fri, Aug 14, 2020 at 03:28:41PM -0400, Suhas Daftuar via bitcoin-dev wrote:
>>> In thinking about the mechanism used there, I thought it would be helpful to
>>> codify in a BIP the idea that Bitcoin network clients should ignore unknown
>>> messages received before a VERACK.  A draft of my proposal is available here
>>> [2].
>> 
>> Rather than allowing arbitrary messages, maybe it would make sense to
>> have a specific feature negotiation message, eg:
>> 
>> VERSION ...
>> FEATURE wtxidrelay
>> FEATURE packagerelay
>> VERACK
>> 
>> with the behaviour being that it's valid only between VERSION and VERACK,
>> and it takes a length-prefixed-string giving the feature name, optional
>> additional data, and if the feature name isn't recognised the message
>> is ignored.
>> 
>> If we were to support a "polite disconnect" feature like Jeremy suggested,
>> it might be easier to do that for a generic FEATURE message, than
>> reimplement it for the message proposed by each new feature.
>> 
>> Cheers,
>> aj
>> 
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From jlrubin at mit.edu  Fri Aug 21 19:50:21 2020
From: jlrubin at mit.edu (Jeremy)
Date: Fri, 21 Aug 2020 12:50:21 -0700
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
 connections are setup
In-Reply-To: <B514142F-382B-4D49-B68D-0115ECBD1D79@voskuil.org>
References: <A26FA2BC-50E5-4635-95E4-56AAA969C9DA@mattcorallo.com>
 <B514142F-382B-4D49-B68D-0115ECBD1D79@voskuil.org>
Message-ID: <CAD5xwhi9zVp3nOhFy3Hia_Md++Gdz+F5Kat_bbbZwBcmPhMGZA@mail.gmail.com>

I have a proposal:

Protocol >= 70016 cease to send or process VERACK, and instead use
HANDSHAKEACK, which is completed after feature negotiation.

This should make everyone happy/unhappy, as in a new protocol number it's
fair game to change these semantics to be clear that we're acking more than
version.

I don't care about when or where these messages are sequenced overall, it
seems to have minimal impact. If I had free choice, I slightly agree with
Eric that verack should come before feature negotiation, as we want to
divorce the idea that protocol number and feature support are tied.

But once this is done, we can supplant Verack with HANDSHAKENACK or
HANDSHAKEACK to signal success or failure to agree on a connection. A NACK
reason (version too high/low or an important feature missing) could be
optional. Implicit NACK would be disconnecting, but is discouraged because
a peer doesn't know if it should reconnect or the failure was intentional.

------

AJ: I think I generally do prefer to have a FEATURE wrapper as you
suggested, or a rule that all messages in this period are interpreted as
features (and may be redundant with p2p message types -- so you can
literally just use the p2p message name w/o any data).

I think we would want a semantic (which could be based just on message
names, but first-class support would be nice) for ACKing that a feature is
enabled. This is because a transcript of:

NODE0:
FEATURE A
FEATURE B
VERACK

NODE1:
FEATURE A
VERACK

It remains unclear if Node 1 ignored B because it's an unknown feature, or
because it is disabled. A transcript like:

NODE0:
FEATURE A
FEATURE B
FEATURE C
ACK A
VERACK

NODE1:
FEATURE A
ACK A
NACK B
VERACK

would make it clear that A and B are known, B is disabled, and C is
unknown. C has 0 support, B Node 0 should support inbound messages but
knows not to send to Node 1, and A has full bilateral support. Maybe
instead it could a message FEATURE SEND A and FEATURE RECV A, so we can
make the split explicit rather than inferred from ACK/NACK.


------

I'd also propose that we add a message which is SYNC, which indicates the
end of a list of FEATURES and a request to send ACKS or NACKS back (which
are followed by a SYNC). This allows multi-round negotiation where based on
the presence of other features, I may expand the set of features I am
offering. I think you could do without SYNC, but there are more edge cases
and the explicitness is nice given that this already introduces future
complexity.

This multi-round makes it an actual negotiation rather than a pure
announcement system. I don't think it would be used much in the near term,
but it makes sense to define it correctly now. Build for the future and
all...



--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200821/1083efeb/attachment.html>

From lf-lists at mattcorallo.com  Fri Aug 21 20:45:26 2020
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Fri, 21 Aug 2020 16:45:26 -0400
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
 connections are setup
In-Reply-To: <CAD5xwhi9zVp3nOhFy3Hia_Md++Gdz+F5Kat_bbbZwBcmPhMGZA@mail.gmail.com>
References: <A26FA2BC-50E5-4635-95E4-56AAA969C9DA@mattcorallo.com>
 <B514142F-382B-4D49-B68D-0115ECBD1D79@voskuil.org>
 <CAD5xwhi9zVp3nOhFy3Hia_Md++Gdz+F5Kat_bbbZwBcmPhMGZA@mail.gmail.com>
Message-ID: <b6198e1a-c30b-358a-9673-247a7c305913@mattcorallo.com>

This seems to be pretty overengineered. Do you have a specific use-case in mind for anything more than simply continuing 
the pattern we've been using of sending a message indicating support for a given feature? If we find some in the future, 
we could deploy something like this, though the current proposal makes it possible to do it on a per-feature case.

The great thing about Suhas' proposal is the diff is about -1/+1 (not including tests), while still getting all the 
flexibility we need. Even better, the code already exists.

Matt

On 8/21/20 3:50 PM, Jeremy wrote:
> I have a proposal:
> 
> Protocol >= 70016 cease to send or process VERACK, and instead use HANDSHAKEACK, which is completed after feature 
> negotiation.
> 
> This should make everyone happy/unhappy, as in a new protocol number it's fair game to change these semantics to be 
> clear that we're acking more than version.
> 
> I don't care about when or where these messages are sequenced overall, it seems to have minimal impact. If I had free 
> choice, I slightly agree with Eric that verack should come before feature negotiation, as we want to divorce the idea 
> that protocol number and feature support are tied.
> 
> But once this is done, we can supplant Verack with HANDSHAKENACK or HANDSHAKEACK to signal success or failure to agree 
> on a connection. A NACK reason (version too high/low or an important feature missing) could be optional. Implicit NACK 
> would be disconnecting, but is discouraged because a peer doesn't know if it should reconnect or the failure was 
> intentional.
> 
> ------
> 
> AJ: I think I generally do prefer to have a FEATURE wrapper as you suggested, or a rule that all messages in this period 
> are interpreted as features (and may be redundant with p2p message types -- so you can literally just use the p2p 
> message name w/o any data).
> 
> I think we would want a semantic (which could be based just on message names, but first-class support would be nice) for 
> ACKing that a feature is enabled. This is because a transcript of:
> 
> NODE0:
> FEATURE A
> FEATURE B
> VERACK
> 
> NODE1:
> FEATURE A
> VERACK
> 
> It remains unclear if Node 1 ignored B because it's an unknown feature, or because it is disabled. A transcript like:
> 
> NODE0:
> FEATURE A
> FEATURE B
> FEATURE C
> ACK A
> VERACK
> 
> NODE1:
> FEATURE A
> ACK A
> NACK B
> VERACK
> 
> would make it clear that A and B are known, B is disabled, and C is unknown. C has 0 support, B Node 0 should support 
> inbound messages but knows not to send to Node 1, and A has full bilateral support. Maybe instead it could a message 
> FEATURE SEND A and FEATURE RECV A, so we can make the split explicit rather than inferred from ACK/NACK.
> 
> 
> ------
> 
> I'd also propose that we add a message which is SYNC, which indicates the end of a list of FEATURES and a request to 
> send ACKS or NACKS back (which are followed by a SYNC). This allows multi-round negotiation where based on the presence 
> of other features, I may expand the set of features I am offering. I think you could do without SYNC, but there are more 
> edge cases and the explicitness is nice given that this already introduces future complexity.
> 
> This multi-round makes it an actual negotiation rather than a pure announcement system. I don't think it would be used 
> much in the near term, but it makes sense to define it correctly now. Build for the future and all...
> 
> 
> 
> --
> @JeremyRubin <https://twitter.com/JeremyRubin><https://twitter.com/JeremyRubin>

From jlrubin at mit.edu  Fri Aug 21 21:08:33 2020
From: jlrubin at mit.edu (Jeremy)
Date: Fri, 21 Aug 2020 14:08:33 -0700
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
 connections are setup
In-Reply-To: <b6198e1a-c30b-358a-9673-247a7c305913@mattcorallo.com>
References: <A26FA2BC-50E5-4635-95E4-56AAA969C9DA@mattcorallo.com>
 <B514142F-382B-4D49-B68D-0115ECBD1D79@voskuil.org>
 <CAD5xwhi9zVp3nOhFy3Hia_Md++Gdz+F5Kat_bbbZwBcmPhMGZA@mail.gmail.com>
 <b6198e1a-c30b-358a-9673-247a7c305913@mattcorallo.com>
Message-ID: <CAD5xwhhrz8SMQ4bA6eD2VRwqmMEzVv7NmrD8kDnPfqJy092bKQ@mail.gmail.com>

Actually we already have service bits (which are sadly limited) which allow
negotiation of non bilateral feature support, so this would supercede that.
--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>


On Fri, Aug 21, 2020 at 1:45 PM Matt Corallo <lf-lists at mattcorallo.com>
wrote:

> This seems to be pretty overengineered. Do you have a specific use-case in
> mind for anything more than simply continuing
> the pattern we've been using of sending a message indicating support for a
> given feature? If we find some in the future,
> we could deploy something like this, though the current proposal makes it
> possible to do it on a per-feature case.
>
> The great thing about Suhas' proposal is the diff is about -1/+1 (not
> including tests), while still getting all the
> flexibility we need. Even better, the code already exists.
>
> Matt
>
> On 8/21/20 3:50 PM, Jeremy wrote:
> > I have a proposal:
> >
> > Protocol >= 70016 cease to send or process VERACK, and instead use
> HANDSHAKEACK, which is completed after feature
> > negotiation.
> >
> > This should make everyone happy/unhappy, as in a new protocol number
> it's fair game to change these semantics to be
> > clear that we're acking more than version.
> >
> > I don't care about when or where these messages are sequenced overall,
> it seems to have minimal impact. If I had free
> > choice, I slightly agree with Eric that verack should come before
> feature negotiation, as we want to divorce the idea
> > that protocol number and feature support are tied.
> >
> > But once this is done, we can supplant Verack with HANDSHAKENACK or
> HANDSHAKEACK to signal success or failure to agree
> > on a connection. A NACK reason (version too high/low or an important
> feature missing) could be optional. Implicit NACK
> > would be disconnecting, but is discouraged because a peer doesn't know
> if it should reconnect or the failure was
> > intentional.
> >
> > ------
> >
> > AJ: I think I generally do prefer to have a FEATURE wrapper as you
> suggested, or a rule that all messages in this period
> > are interpreted as features (and may be redundant with p2p message types
> -- so you can literally just use the p2p
> > message name w/o any data).
> >
> > I think we would want a semantic (which could be based just on message
> names, but first-class support would be nice) for
> > ACKing that a feature is enabled. This is because a transcript of:
> >
> > NODE0:
> > FEATURE A
> > FEATURE B
> > VERACK
> >
> > NODE1:
> > FEATURE A
> > VERACK
> >
> > It remains unclear if Node 1 ignored B because it's an unknown feature,
> or because it is disabled. A transcript like:
> >
> > NODE0:
> > FEATURE A
> > FEATURE B
> > FEATURE C
> > ACK A
> > VERACK
> >
> > NODE1:
> > FEATURE A
> > ACK A
> > NACK B
> > VERACK
> >
> > would make it clear that A and B are known, B is disabled, and C is
> unknown. C has 0 support, B Node 0 should support
> > inbound messages but knows not to send to Node 1, and A has full
> bilateral support. Maybe instead it could a message
> > FEATURE SEND A and FEATURE RECV A, so we can make the split explicit
> rather than inferred from ACK/NACK.
> >
> >
> > ------
> >
> > I'd also propose that we add a message which is SYNC, which indicates
> the end of a list of FEATURES and a request to
> > send ACKS or NACKS back (which are followed by a SYNC). This allows
> multi-round negotiation where based on the presence
> > of other features, I may expand the set of features I am offering. I
> think you could do without SYNC, but there are more
> > edge cases and the explicitness is nice given that this already
> introduces future complexity.
> >
> > This multi-round makes it an actual negotiation rather than a pure
> announcement system. I don't think it would be used
> > much in the near term, but it makes sense to define it correctly now.
> Build for the future and all...
> >
> >
> >
> > --
> > @JeremyRubin <https://twitter.com/JeremyRubin><
> https://twitter.com/JeremyRubin>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200821/4814eb47/attachment-0001.html>

From jlrubin at mit.edu  Fri Aug 21 21:17:32 2020
From: jlrubin at mit.edu (Jeremy)
Date: Fri, 21 Aug 2020 14:17:32 -0700
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
 connections are setup
In-Reply-To: <CAD5xwhhrz8SMQ4bA6eD2VRwqmMEzVv7NmrD8kDnPfqJy092bKQ@mail.gmail.com>
References: <A26FA2BC-50E5-4635-95E4-56AAA969C9DA@mattcorallo.com>
 <B514142F-382B-4D49-B68D-0115ECBD1D79@voskuil.org>
 <CAD5xwhi9zVp3nOhFy3Hia_Md++Gdz+F5Kat_bbbZwBcmPhMGZA@mail.gmail.com>
 <b6198e1a-c30b-358a-9673-247a7c305913@mattcorallo.com>
 <CAD5xwhhrz8SMQ4bA6eD2VRwqmMEzVv7NmrD8kDnPfqJy092bKQ@mail.gmail.com>
Message-ID: <CAD5xwhjdLJvMd5gpKQXfW5Tr9RV0GTakA0pD3-xzQLHd_nY1OA@mail.gmail.com>

As for an example of where you'd want multi-round, you could imagine a
scenario where you have a feature A which gets bugfixed by the introduction
of feature B, and you don't want to expose that you support A unless you
first negotiate B. Or if you can negotiate B you should never expose A, but
for old nodes you'll still do it if B is unknown to them. An example of
this would be (were it not already out without a feature negotiation
existing) WTXID/TXID relay.

The SYNC primitve simply codifies what order messages should be in and when
you're done for a phase of negotiation offering something. It can be done
without, but then you have to be more careful to broadcast in the correct
order and it's not clear when/if you should wait for more time before
responding.


On Fri, Aug 21, 2020 at 2:08 PM Jeremy <jlrubin at mit.edu> wrote:

> Actually we already have service bits (which are sadly limited) which
> allow negotiation of non bilateral feature support, so this would supercede
> that.
> --
> @JeremyRubin <https://twitter.com/JeremyRubin>
> <https://twitter.com/JeremyRubin>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200821/2517650e/attachment.html>

From eric at voskuil.org  Fri Aug 21 21:17:55 2020
From: eric at voskuil.org (Eric Voskuil)
Date: Fri, 21 Aug 2020 14:17:55 -0700
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
	connections are setup
In-Reply-To: <CAD5xwhhrz8SMQ4bA6eD2VRwqmMEzVv7NmrD8kDnPfqJy092bKQ@mail.gmail.com>
References: <CAD5xwhhrz8SMQ4bA6eD2VRwqmMEzVv7NmrD8kDnPfqJy092bKQ@mail.gmail.com>
Message-ID: <C9CB03D3-2328-4FEB-96EF-4FB297C78BC6@voskuil.org>

Service bits are advertised, protocol support is not.

https://en.bitcoin.it/wiki/Protocol_documentation#Network_address

e

> On Aug 21, 2020, at 14:08, Jeremy <jlrubin at mit.edu> wrote:
> 
> ?
> Actually we already have service bits (which are sadly limited) which allow negotiation of non bilateral feature support, so this would supercede that.
> --
> @JeremyRubin
> 
> 
>> On Fri, Aug 21, 2020 at 1:45 PM Matt Corallo <lf-lists at mattcorallo.com> wrote:
>> This seems to be pretty overengineered. Do you have a specific use-case in mind for anything more than simply continuing 
>> the pattern we've been using of sending a message indicating support for a given feature? If we find some in the future, 
>> we could deploy something like this, though the current proposal makes it possible to do it on a per-feature case.
>> 
>> The great thing about Suhas' proposal is the diff is about -1/+1 (not including tests), while still getting all the 
>> flexibility we need. Even better, the code already exists.
>> 
>> Matt
>> 
>> On 8/21/20 3:50 PM, Jeremy wrote:
>> > I have a proposal:
>> > 
>> > Protocol >= 70016 cease to send or process VERACK, and instead use HANDSHAKEACK, which is completed after feature 
>> > negotiation.
>> > 
>> > This should make everyone happy/unhappy, as in a new protocol number it's fair game to change these semantics to be 
>> > clear that we're acking more than version.
>> > 
>> > I don't care about when or where these messages are sequenced overall, it seems to have minimal impact. If I had free 
>> > choice, I slightly agree with Eric that verack should come before feature negotiation, as we want to divorce the idea 
>> > that protocol number and feature support are tied.
>> > 
>> > But once this is done, we can supplant Verack with HANDSHAKENACK or HANDSHAKEACK to signal success or failure to agree 
>> > on a connection. A NACK reason (version too high/low or an important feature missing) could be optional. Implicit NACK 
>> > would be disconnecting, but is discouraged because a peer doesn't know if it should reconnect or the failure was 
>> > intentional.
>> > 
>> > ------
>> > 
>> > AJ: I think I generally do prefer to have a FEATURE wrapper as you suggested, or a rule that all messages in this period 
>> > are interpreted as features (and may be redundant with p2p message types -- so you can literally just use the p2p 
>> > message name w/o any data).
>> > 
>> > I think we would want a semantic (which could be based just on message names, but first-class support would be nice) for 
>> > ACKing that a feature is enabled. This is because a transcript of:
>> > 
>> > NODE0:
>> > FEATURE A
>> > FEATURE B
>> > VERACK
>> > 
>> > NODE1:
>> > FEATURE A
>> > VERACK
>> > 
>> > It remains unclear if Node 1 ignored B because it's an unknown feature, or because it is disabled. A transcript like:
>> > 
>> > NODE0:
>> > FEATURE A
>> > FEATURE B
>> > FEATURE C
>> > ACK A
>> > VERACK
>> > 
>> > NODE1:
>> > FEATURE A
>> > ACK A
>> > NACK B
>> > VERACK
>> > 
>> > would make it clear that A and B are known, B is disabled, and C is unknown. C has 0 support, B Node 0 should support 
>> > inbound messages but knows not to send to Node 1, and A has full bilateral support. Maybe instead it could a message 
>> > FEATURE SEND A and FEATURE RECV A, so we can make the split explicit rather than inferred from ACK/NACK.
>> > 
>> > 
>> > ------
>> > 
>> > I'd also propose that we add a message which is SYNC, which indicates the end of a list of FEATURES and a request to 
>> > send ACKS or NACKS back (which are followed by a SYNC). This allows multi-round negotiation where based on the presence 
>> > of other features, I may expand the set of features I am offering. I think you could do without SYNC, but there are more 
>> > edge cases and the explicitness is nice given that this already introduces future complexity.
>> > 
>> > This multi-round makes it an actual negotiation rather than a pure announcement system. I don't think it would be used 
>> > much in the near term, but it makes sense to define it correctly now. Build for the future and all...
>> > 
>> > 
>> > 
>> > --
>> > @JeremyRubin <https://twitter.com/JeremyRubin><https://twitter.com/JeremyRubin>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200821/f8dbf6e4/attachment.html>

From lf-lists at mattcorallo.com  Fri Aug 21 22:16:02 2020
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Fri, 21 Aug 2020 18:16:02 -0400
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
 connections are setup
In-Reply-To: <CAD5xwhjdLJvMd5gpKQXfW5Tr9RV0GTakA0pD3-xzQLHd_nY1OA@mail.gmail.com>
References: <A26FA2BC-50E5-4635-95E4-56AAA969C9DA@mattcorallo.com>
 <B514142F-382B-4D49-B68D-0115ECBD1D79@voskuil.org>
 <CAD5xwhi9zVp3nOhFy3Hia_Md++Gdz+F5Kat_bbbZwBcmPhMGZA@mail.gmail.com>
 <b6198e1a-c30b-358a-9673-247a7c305913@mattcorallo.com>
 <CAD5xwhhrz8SMQ4bA6eD2VRwqmMEzVv7NmrD8kDnPfqJy092bKQ@mail.gmail.com>
 <CAD5xwhjdLJvMd5gpKQXfW5Tr9RV0GTakA0pD3-xzQLHd_nY1OA@mail.gmail.com>
Message-ID: <afcedaf1-dd69-9402-eeeb-006bb9211b98@mattcorallo.com>

Hmm, could that not be accomplished by simply building this into new messages? eg, send "betterprotocol", if you see a 
verack and no "betterprotocol" from your peer, send "worseprotocol" before you send a "verack".

Matt

On 8/21/20 5:17 PM, Jeremy wrote:
> As for an example of where you'd want multi-round, you could imagine a scenario where you have a feature A which gets 
> bugfixed by the introduction of feature B, and you don't want to expose that you support A unless you first negotiate B. 
> Or if you can negotiate B you should never expose A, but for old nodes you'll still do it if B is unknown to them. An 
> example of this would be (were it not already out without a feature negotiation existing) WTXID/TXID relay.
> 
> The SYNC primitve simply codifies what order messages should be in and when you're done for a phase of negotiation 
> offering something. It can be done without, but then you have to be more careful to broadcast in the correct order and 
> it's not clear when/if you should wait for more time before responding.
> 
> 
> On Fri, Aug 21, 2020 at 2:08 PM Jeremy <jlrubin at mit.edu <mailto:jlrubin at mit.edu>> wrote:
> 
>     Actually we already have service bits (which are sadly limited) which allow negotiation of non bilateral feature
>     support, so this would supercede that.
>     --
>     @JeremyRubin <https://twitter.com/JeremyRubin><https://twitter.com/JeremyRubin>
> 

From ZmnSCPxj at protonmail.com  Sat Aug 22 01:09:35 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 22 Aug 2020 01:09:35 +0000
Subject: [bitcoin-dev] Detailed protocol design for routed
	multi-transaction CoinSwap
In-Reply-To: <f5ba3015-2ec8-b35d-dc40-3e3e9e11449f@riseup.net>
References: <813e51a1-4252-08c0-d42d-5cef32f684bc@riseup.net>
 <xhRsCejqgUjoLy5hPMHgFcZdiqJsO7TfS0azWhis9-tvSgXodoKe7gN5IXyiVIVqUWSm7FoY-aBUaJCCDgixdWUN4n8EzhQlSNshsQeIFsw=@protonmail.com>
 <e8ca67be-d07c-3f2e-4318-0d2bab061dd9@riseup.net>
 <WtKtWCdqIFVTTqw9-EggdsTIo6ejfP8my868MYyAqO8FUboiXWZUd0hw2PyvEKZNJxqAWJ_9BnOllAGEuUYYcA654amKTC4MSmO3TO4A7pU=@protonmail.com>
 <f5ba3015-2ec8-b35d-dc40-3e3e9e11449f@riseup.net>
Message-ID: <mht_82bLLV27HegePe5Cl_jSLnQ0qHYeH7V-aUNT3H6JYcECIG135hvxwrJr0QvLM5_7VpOd7cUUXZegQv5K0y27feckAe2B84oBz-2ZhqE=@protonmail.com>

Good morning Chris,


> > Absolute timelocks mean that you can set a timer where you put your node to sleep without risk of loss of funds (basically, once the absolute timelocks have resolved, you can forget about CoinSwaps).
> > But I think the ability to spend at any time would be better, and getting 100% online 144 blocks a day, 2016 blocks a retargeting period is becoming more and more feasible.
>
> You can always put your node to sleep as a maker, and your watchtowers
> will protect you.

Assuming you have multiple watchtowers, yes.

It would be best if watchtowers for CoinSwap and watchtowers for Lightning could be the same thing, and ideally, a watchtower would not even know if what it was watching were a Lightning channel or a CoinSwap until an attack happens.

>
> What do you mean by the point about 100% online nodes getting more
> feasible? Many bitcoin nodes have been always-on for years, I think I
> missed something.

Not all locations on Earth make it easy to be 100% online.
However, as the technology of you puny humans advance, it becomes more and more possible for a random point on Earth to be 100% online.

> > > You're right that attempting such an move by the taker is riskless, but
> > > its not costless. The taker sets up the entire CoinSwap protocol because
> > > they wanted more privacy; but if the taker broadcasts the Alice contract
> > > transaction and waits for the timeout, then all they've achieved is
> > > spent miner fees, got their own coin back and draw attention to it with
> > > the unusual HTLC script. They've achieved no benefit from what I see, so
> > > they won't do this. Any taker or maker who attempts anything like this
> > > will be spending miner fees.
> >
> > They would be spending miner fees from the funds being stolen, thus still costless.
> > In particular, let us imagine a simple 1-maker swap.
> >
> > -   The taker and the maker complete the swap.
> > -   The taker now has possession of:
> >     -   The private key for its incoming HTLC.
> >     -   The pre-signed contract transaction for its outgoing HTLC.
> > -   The taker spends from its incoming HTLC using the private key.
> >     -   The maker ignores this, because this is just normal operation.
> >     -   Fees paid for this is not an additional cost, because a taker that wants to put its freshly-private funds into cold storage will do this anyway.
> >     -   The taker gets a fresh, private coin from this incoming HTLC, so it gets the privacy it paid for.
> > -   The taker waits for the incoming-HTLC-spend to confirm.
> > -   The taker broadcasts the pre-signed contract transaction, in the hope that the maker is offline.
> >     -   The fees paid for this are from the contract transaction that the taker is trying to steal.
> >         Even if the theft attempt fails, the taker has already gotten its private money out, and is thus not risking anything.
> >
> >     -   Semantically, the outgoing HTLC is already "owned" by the maker (the maker has private key to it).
> >         -   Thus, the taker commits an action that the maker pays fees for!
> >     -   The maker cannot react except to spend via the hashlock branch.
> >         In particular, because the taker-incoming (maker-outgoing) UTXO is already spent, it cannot retaliate by also broadcasting the contract transaction of the taker-incoming (maker-outgoing) HTLC.
> >
> > -   The theft succeeds (the timelock passes) because the maker happens to be offline for that long.
> >     -   This is "free money" to the taker, who has already gotten what it paid for --- private money in cold storage --- from the CoinSwap.
> >     -   Even if the stolen fund reveals the contract, the taker can re-acquire privacy for the funds it stole for free, by paying for --- wait for it --- another CoinSwap for its swag.
>
> Yep you're right, I get it.
>
> The biggest defense against theft will have to be multiple redundant
> watchtowers. But as you say the attack is riskless and costless for the
> taker to attempt, so they might try anyway even if the probability of
> success is very low.
>
> If this attack becomes widespread then it effectively breaks the
> property that maker's coins remain unspent indefinitely. It seems like
> that would lead to makers increasing their CoinSwap fees because they
> know they'll always have to spend a bit of miner fees afterwards.
>
> Hopefully the success rate for this attack can be low enough that
> taker's human niceness will stop them trying. But for sure this is a
> concerning problem.

Indeed.

We also cannot use succinct atomic swaps because their asymmetry makes them unroutable --- you can only use it for single-maker swaps.
This makes it obvious to the maker that you have only a single maker.

> > Using an absolute timelock (implemented by a `nLockTime` tx directly off the 2-of-2, not `OP_CHECKLOCKTIMEVERIFY`), plus a Scriptless Script 2p-ECDSA (again implemented by a tx directly off the 2-of-2) instead of a hashlock, seems to avoid this, I think, at the cost of reducing the utility of private key turnover by having a deadline where the private key has to be used.
> > This is because there is no contract transaction that is share-owned by both participants in the swap.
> > Instead there are two distinct transactions with separate ownerships: a timeout tx (that is owned by the participant paying for the HTLC/PTLC) and a claim tx (that is owned by the participant accepting the HTLC/PTLC).
>
> A downside of using absolute timelocks is that it combines the two time
> periods: the time period where a watchtower must respond and the time
> period under which private keys must be used.
>
> So for example if the absolute timelock is set to 3 weeks, that means
> the maker has 3 weeks to spend their coins using the private keys which
> is a nice long period. However if the CoinSwaps fails with the timeout
> case then the maker has to wait 3 weeks to get their coins back, which
> is a long time.
>
> We can go the other extreme and set the absolute timelock to be 2 days.
> Then the maker only has to wait 2 days in the unfortunate event that
> their coinswap fails with the timeout case. But it means they must use
> their private keys to spend coins within the short period of 2 days(!)
>
> Though this still might be worth it to solve the riskless/costless
> stealing attempts.

Yes.
Note that this only works if you dive into Scriptless Script 2p-ECDSA/Schnorr immediately.

It also makes watchtowers for Lightning inherently incompatible with watchtowers for CoinSwaps using absolute timelocks.

A watchtower guarding for CoinSwaps using absolute timelocks would:

* Need to know the funding outpoint it is guarding.
  * Watchtowers for Lightning (and contract-transaction-based CoinSwap) do *not* need to know this, they just need to know a transaction ID that, if confirmed, they will broadcast *another* transaction.
* Need to watch *blockheight*.
  * Watchtowers for Lightning (and contract-transaction-based CoinSwap) only check for transactions matching txids they are watching for.

In particular the first point is a massive privacy lose.
Lightning watchtowers can have the txid they are watching for in the clear, and the transaction they will broadcast in reaction to the watched txid being confirmed is encrypted using a key derived from the transaction with the given txid, and thus do not learn which funding outpoint it is protecting until an attack occurs, which is very good for privacy.

(even if the maker were to run private watchtowers of their own rather than using some public watchtower service, if the private watchtower is hacked it contains information that can be used to identify funding outpoints, thus making them targets.
Thus, it is best if watchtowers, whether public or private, do not contain any privacy-damaging information, to reduce the attack surface on privacy.)

A way to make watchtowers for absolute-timelock CoinSwap also have the same interface (i.e. "Watch for this txid, if it appears onchain broadcast this transaction") as Lightning watchtowers would be to have the timeout tx pay out to a `OP_IF <1 day> OP_CHECKSEQUENCEVERIFY OP_DROP <taker> OP_ELSE <revocationkey> OP_ENDIF OP_CHECKSIGVERIFY`.
The revocation key would be the same private key that is turned over at the end of the CoinSwap.
So, if the absolute timelock expires and the other participant broadcasts the timeout tx, the maker still has an opportunity to revoke that output, for one additional day.

Then, at the end of the CoinSwap where the private key is turned over, the maker can hand the txid of the timeout tx, plus an encrypted transaction that spends from the revocation branch of the timeout tx back to the maker and a tip to the watchtower, to the watchtower, who remains unaware what the funding txo is (it only gets a txid and an encrypted blob, so gets no information).
The same interface can be used by Lightning Poon-Dryja (it is sub-optimal, but usable, for Decker-Russell-Osuntokun), and the watchtower would not even learn if it was watching for a Lightning channel or for a CoinSwap.

Then, if the maker were holding on to the funding outpoint of its incoming HTLC in the hope another taker arrives for its services, and then some silly human trips over the maker hardware power cord, and the condition is not fixed by the timeout, it can still be privately protected by watchtowers.

This comes at the cost of even worse UX if something goes wrong with the swap: an increased timeout.


Regards,
ZmnSCPxj

From dave at dtrt.org  Sat Aug 22 16:46:20 2020
From: dave at dtrt.org (David A. Harding)
Date: Sat, 22 Aug 2020 12:46:20 -0400
Subject: [bitcoin-dev] reviving op_difficulty
In-Reply-To: <CAHAXnDXhAFQHiBCJ=H=1ZGHdHWhgLh1rG3pCPR5o48ziZzV+zQ@mail.gmail.com>
References: <CAHAXnDXhAFQHiBCJ=H=1ZGHdHWhgLh1rG3pCPR5o48ziZzV+zQ@mail.gmail.com>
Message-ID: <20200822164619.vh3rdmdqf6vlmcji@ganymede>

On Sun, Aug 16, 2020 at 11:41:30AM -0400, Thomas Hartman via bitcoin-dev wrote:
> First, I would like to pay respects to tamas blummer, RIP.
> 
> https://bitcoinmagazine.com/articles/remembering-tamas-blummer-pioneering-bitcoin-developer

RIP, Tamas.

> Tamas proposed an additional opcode for enabling bitcoin difficulty
> futures, on this list at
> 
> https://www.mail-archive.com/bitcoin-dev at lists.linuxfoundation.org/msg07991.html

Subsequent to Blummer's post, I heard from Jeremy Rubin about a
scheme[1] that allows difficulty futures without requiring any changes
to Bitcoin.  In short, it takes advantage of the fact that changes in
difficulty also cause a difference in maturation time between timelocks
and height-locks.  As an simple example:

1. Alice and Bob create an unsigned transaction that deposits their
   money into a 2-of-2 multisig.

2. They cooperate to create and sign two conflicting spends from the multisig:

    a. Pays Alice with an nLockTime(height) of CURRENT_HEIGHT + 2016 blocks

    b. Pays Bob with an nLockTime(time) of CURRENT_TIME + 2016 * 10 * 60 seconds

3. After both conflicting spends are signed, Alice and Bob sign and
   broadcast the deposit transaction from #1.

4. If hashrate increases during the subsequent period, the spend that
   pays Alice will mature first, so she broadcasts it and receives that
   money.  If hashrate decreases, the spend to Bob matures first, so he
   receives the money.

Of course, this basic formula can be tweaked to create other contracts,
e.g. a contract that only pays if hashrate goes down more than 25%.

As far as I can tell, this method should be compatible with offchain
commitments (e.g. payments within channels) and could be embedded in a
taproot commitment using OP_CLTV or OP_CSV instead of nLockTime.

-Dave

[1] https://powswap.com/
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200822/d044fb7d/attachment.sig>

From eric at voskuil.org  Sun Aug 23 17:45:45 2020
From: eric at voskuil.org (Eric Voskuil)
Date: Sun, 23 Aug 2020 10:45:45 -0700
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
	connections are setup
In-Reply-To: <b6198e1a-c30b-358a-9673-247a7c305913@mattcorallo.com>
References: <b6198e1a-c30b-358a-9673-247a7c305913@mattcorallo.com>
Message-ID: <1DE500EE-BDC7-4B36-AB12-45885D20C226@voskuil.org>



> On Aug 21, 2020, at 13:45, Matt Corallo <lf-lists at mattcorallo.com> wrote:
> 
> ?This seems to be pretty overengineered.

I agree. In fact all proposals I?ve seen on this are over engineered.

> Do you have a specific use-case in mind for anything more than simply continuing the pattern we've been using of sending a message indicating support for a given feature?

Correct me if I?m wrong, but this pattern is what the proposal aims to eliminate. There is no reason whatsoever for a message per indication. The appropriate pattern is already established in the implementation of service bits. In fact in this discussion it has been pointed out that the problem with service bits is simply too few bits.

> If we find some in the future,

> we could deploy something like this, though the current proposal makes it possible to do it on a per-feature case.

As does any other proposal, including passage of the full set of optional sub-protocols in the verack.

> The great thing about Suhas' proposal is the diff is about -1/+1 (not including tests), while still getting all the flexibility we need.

> Even better, the code already exists.

This is neither true nor relevant. Maybe the Segwit 2X guys should have used this argument.

e


> Matt
> 
>> On 8/21/20 3:50 PM, Jeremy wrote:
>> I have a proposal:
>> Protocol >= 70016 cease to send or process VERACK, and instead use HANDSHAKEACK, which is completed after feature negotiation.
>> This should make everyone happy/unhappy, as in a new protocol number it's fair game to change these semantics to be clear that we're acking more than version.
>> I don't care about when or where these messages are sequenced overall, it seems to have minimal impact. If I had free choice, I slightly agree with Eric that verack should come before feature negotiation, as we want to divorce the idea that protocol number and feature support are tied.
>> But once this is done, we can supplant Verack with HANDSHAKENACK or HANDSHAKEACK to signal success or failure to agree on a connection. A NACK reason (version too high/low or an important feature missing) could be optional. Implicit NACK would be disconnecting, but is discouraged because a peer doesn't know if it should reconnect or the failure was intentional.
>> ------
>> AJ: I think I generally do prefer to have a FEATURE wrapper as you suggested, or a rule that all messages in this period are interpreted as features (and may be redundant with p2p message types -- so you can literally just use the p2p message name w/o any data).
>> I think we would want a semantic (which could be based just on message names, but first-class support would be nice) for ACKing that a feature is enabled. This is because a transcript of:
>> NODE0:
>> FEATURE A
>> FEATURE B
>> VERACK
>> NODE1:
>> FEATURE A
>> VERACK
>> It remains unclear if Node 1 ignored B because it's an unknown feature, or because it is disabled. A transcript like:
>> NODE0:
>> FEATURE A
>> FEATURE B
>> FEATURE C
>> ACK A
>> VERACK
>> NODE1:
>> FEATURE A
>> ACK A
>> NACK B
>> VERACK
>> would make it clear that A and B are known, B is disabled, and C is unknown. C has 0 support, B Node 0 should support inbound messages but knows not to send to Node 1, and A has full bilateral support. Maybe instead it could a message FEATURE SEND A and FEATURE RECV A, so we can make the split explicit rather than inferred from ACK/NACK.
>> ------
>> I'd also propose that we add a message which is SYNC, which indicates the end of a list of FEATURES and a request to send ACKS or NACKS back (which are followed by a SYNC). This allows multi-round negotiation where based on the presence of other features, I may expand the set of features I am offering. I think you could do without SYNC, but there are more edge cases and the explicitness is nice given that this already introduces future complexity.
>> This multi-round makes it an actual negotiation rather than a pure announcement system. I don't think it would be used much in the near term, but it makes sense to define it correctly now. Build for the future and all...
>> --
>> @JeremyRubin <https://twitter.com/JeremyRubin><https://twitter.com/JeremyRubin>

From eric at voskuil.org  Sun Aug 23 17:49:35 2020
From: eric at voskuil.org (Eric Voskuil)
Date: Sun, 23 Aug 2020 10:49:35 -0700
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
	connections are setup
In-Reply-To: <afcedaf1-dd69-9402-eeeb-006bb9211b98@mattcorallo.com>
References: <afcedaf1-dd69-9402-eeeb-006bb9211b98@mattcorallo.com>
Message-ID: <27FE83C7-0269-4DEB-82E4-486FAFFA0DE5@voskuil.org>


> On Aug 21, 2020, at 15:16, Matt Corallo <lf-lists at mattcorallo.com> wrote:
> 
> ?Hmm, could that not be accomplished by simply building this into new messages? eg, send "betterprotocol", if you see a verack and no "betterprotocol" from your peer, send "worseprotocol" before you send a "verack".
> 
> Matt
> 
>> On 8/21/20 5:17 PM, Jeremy wrote:
>> As for an example of where you'd want multi-round, you could imagine a scenario where you have a feature A which gets bugfixed by the introduction of feature B, and you don't want to expose that you support A unless you first negotiate B. Or if you can negotiate B you should never expose A, but for old nodes you'll still do it if B is unknown to them.

This seems to imply a security benefit (I can?t discern any other rationale for this complexity). It should be clear that this is no more than trivially weak obfuscation and not worth complicating the protocol to achieve.

>> An example of this would be (were it not already out without a feature negotiation existing) WTXID/TXID relay.
>> The SYNC primitve simply codifies what order messages should be in and when you're done for a phase of negotiation offering something. It can be done without, but then you have to be more careful to broadcast in the correct order and it's not clear when/if you should wait for more time before responding.
>> On Fri, Aug 21, 2020 at 2:08 PM Jeremy <jlrubin at mit.edu <mailto:jlrubin at mit.edu>> wrote:
>>    Actually we already have service bits (which are sadly limited) which allow negotiation of non bilateral feature
>>    support, so this would supercede that.
>>    --
>>    @JeremyRubin <https://twitter.com/JeremyRubin><https://twitter.com/JeremyRubin>

From RobertSpigler at protonmail.ch  Sun Aug 23 22:07:38 2020
From: RobertSpigler at protonmail.ch (Robert Spigler)
Date: Sun, 23 Aug 2020 22:07:38 +0000
Subject: [bitcoin-dev] PSBT Security Standard
Message-ID: <8CmLbHXXpuOUrV26QPKkE9vx4n44wAaFXHQ1z5F0UdV-M8ypEssmOoMGUQiG3RlIrS9Za-lP0-G3ARIb6icDK4yn90fxlQXwBJa58CQMRuo=@protonmail.ch>

Hello All,

In the past, discussions around how to securely store/use/setup PSBT's have been decided as out of scope for BIP 174 - "it is not a specification of how hardware wallets should behave, it is a description of a data structure and the abstract workflow around it"

For example, Nicolas Dorier had many concerns around a year ago during the global xpub field discussions, and Electrum Wallet devs and Sjors Provoost have had various discussions on how to coordinate multisig wallets and represent cosigners securely (1. what do cosigners need: xfp, derivation prefix, xpub, script type; 2. needs to be forward thinking: work with Musig, Lightning, Taproot, Native Descriptor Wallets, etc; 3. how do we authenticate across devices, ensure PSBT's haven't been changed en route, defend against change attacks, etc - Bob McElrath had some interesting ideas on these).

Jonathan Underwood's PSBT_GLOBAL_XPUB_SIGNATURE addition to BIP174 helps with some of these, but it is not a finalized BIP yet, and while the global xpub field is, it is not pulled into Core yet.

What do people think of the idea of expanding or creating a new, more descriptive BIP on how to securely use PSBT's?

IMO, especially since Core has been merging more PR's on the work around offline/multisig use, this has become more important.

Last time I discussed this, Glenn Willen and Luke Dashjr thought this was a good idea, with Luke offering a Bitcoin Wiki page for the short term, but that was a few months ago and I thought I would open this idea to the general community.

-Robert Spigler
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200823/41254548/attachment.html>

From sdaftuar at gmail.com  Mon Aug 24 09:44:07 2020
From: sdaftuar at gmail.com (Suhas Daftuar)
Date: Mon, 24 Aug 2020 05:44:07 -0400
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
 connections are setup
In-Reply-To: <27FE83C7-0269-4DEB-82E4-486FAFFA0DE5@voskuil.org>
References: <afcedaf1-dd69-9402-eeeb-006bb9211b98@mattcorallo.com>
 <27FE83C7-0269-4DEB-82E4-486FAFFA0DE5@voskuil.org>
Message-ID: <CAFp6fsFUuFLjtUWhR3k-0P79r9-QRpuEZrcQfb96jEYdV0RD4Q@mail.gmail.com>

Hi all,

Thanks for the helpful discussion.

My primary motivation in starting this thread was to establish what the
expectations are for new feature deployment (particularly whether the
protocol version should continue to be bumped or not), and I think I have
that answer -- different from what I proposed when I started this thread,
but not in a way that I think meaningfully hinders future work.  So I'm
happy to leave it at that and withdraw my suggestion.

Cheers,
Suhas


On Sun, Aug 23, 2020 at 1:51 PM Eric Voskuil via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> > On Aug 21, 2020, at 15:16, Matt Corallo <lf-lists at mattcorallo.com>
> wrote:
> >
> > ?Hmm, could that not be accomplished by simply building this into new
> messages? eg, send "betterprotocol", if you see a verack and no
> "betterprotocol" from your peer, send "worseprotocol" before you send a
> "verack".
> >
> > Matt
> >
> >> On 8/21/20 5:17 PM, Jeremy wrote:
> >> As for an example of where you'd want multi-round, you could imagine a
> scenario where you have a feature A which gets bugfixed by the introduction
> of feature B, and you don't want to expose that you support A unless you
> first negotiate B. Or if you can negotiate B you should never expose A, but
> for old nodes you'll still do it if B is unknown to them.
>
> This seems to imply a security benefit (I can?t discern any other
> rationale for this complexity). It should be clear that this is no more
> than trivially weak obfuscation and not worth complicating the protocol to
> achieve.
>
> >> An example of this would be (were it not already out without a feature
> negotiation existing) WTXID/TXID relay.
> >> The SYNC primitve simply codifies what order messages should be in and
> when you're done for a phase of negotiation offering something. It can be
> done without, but then you have to be more careful to broadcast in the
> correct order and it's not clear when/if you should wait for more time
> before responding.
> >> On Fri, Aug 21, 2020 at 2:08 PM Jeremy <jlrubin at mit.edu <mailto:
> jlrubin at mit.edu>> wrote:
> >>    Actually we already have service bits (which are sadly limited)
> which allow negotiation of non bilateral feature
> >>    support, so this would supercede that.
> >>    --
> >>    @JeremyRubin <https://twitter.com/JeremyRubin><
> https://twitter.com/JeremyRubin>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200824/895e4c0a/attachment-0001.html>

From g.andrew.stone at gmail.com  Mon Aug 24 13:59:26 2020
From: g.andrew.stone at gmail.com (G. Andrew Stone)
Date: Mon, 24 Aug 2020 09:59:26 -0400
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
 connections are setup
In-Reply-To: <CAFp6fsFUuFLjtUWhR3k-0P79r9-QRpuEZrcQfb96jEYdV0RD4Q@mail.gmail.com>
References: <afcedaf1-dd69-9402-eeeb-006bb9211b98@mattcorallo.com>
 <27FE83C7-0269-4DEB-82E4-486FAFFA0DE5@voskuil.org>
 <CAFp6fsFUuFLjtUWhR3k-0P79r9-QRpuEZrcQfb96jEYdV0RD4Q@mail.gmail.com>
Message-ID: <CAHUwRvvAG08LauksreAfbPLmZp__Ab6Ja7VH_oS_foK+SVso=w@mail.gmail.com>

Since discussion around allowing unknown messages or not allowing them
seems contentious, I'd like to offer up another possibility: create a
single new message, XVERSION, (and bump the protocol rev) which is a
key-value array of arbitrary data.  Any protocol extension can then choose
a new key (with a 32 or 64 bit keyspace you can basically hand out prefixes
to any implementation that wants one)  and publish custom data via this
message without needing to bump the protocol rev field.  Typical "custom
data" would be the min and max supported version of some specific extended
protocol, but any data is possible since the "value" field can be
serialized via the same network serialization format.  It therefore doubles
as a "configuration" message as well as protocol extension negotiation.
For example, we use it to communicate the maximum unconfirmed chain a node
will commit to the mempool, and peers don't bother to send transactions
that exceed this limit.

You can find a specification here:
https://gitlab.com/bitcoinunlimited/BCHUnlimited/-/blob/dev/doc/xversionmessage.md

Code has been deployed for a long time.

Regards,
Andrew


On Mon, Aug 24, 2020 at 5:44 AM Suhas Daftuar via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi all,
>
> Thanks for the helpful discussion.
>
> My primary motivation in starting this thread was to establish what the
> expectations are for new feature deployment (particularly whether the
> protocol version should continue to be bumped or not), and I think I have
> that answer -- different from what I proposed when I started this thread,
> but not in a way that I think meaningfully hinders future work.  So I'm
> happy to leave it at that and withdraw my suggestion.
>
> Cheers,
> Suhas
>
>
> On Sun, Aug 23, 2020 at 1:51 PM Eric Voskuil via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>>
>> > On Aug 21, 2020, at 15:16, Matt Corallo <lf-lists at mattcorallo.com>
>> wrote:
>> >
>> > ?Hmm, could that not be accomplished by simply building this into new
>> messages? eg, send "betterprotocol", if you see a verack and no
>> "betterprotocol" from your peer, send "worseprotocol" before you send a
>> "verack".
>> >
>> > Matt
>> >
>> >> On 8/21/20 5:17 PM, Jeremy wrote:
>> >> As for an example of where you'd want multi-round, you could imagine a
>> scenario where you have a feature A which gets bugfixed by the introduction
>> of feature B, and you don't want to expose that you support A unless you
>> first negotiate B. Or if you can negotiate B you should never expose A, but
>> for old nodes you'll still do it if B is unknown to them.
>>
>> This seems to imply a security benefit (I can?t discern any other
>> rationale for this complexity). It should be clear that this is no more
>> than trivially weak obfuscation and not worth complicating the protocol to
>> achieve.
>>
>> >> An example of this would be (were it not already out without a feature
>> negotiation existing) WTXID/TXID relay.
>> >> The SYNC primitve simply codifies what order messages should be in and
>> when you're done for a phase of negotiation offering something. It can be
>> done without, but then you have to be more careful to broadcast in the
>> correct order and it's not clear when/if you should wait for more time
>> before responding.
>> >> On Fri, Aug 21, 2020 at 2:08 PM Jeremy <jlrubin at mit.edu <mailto:
>> jlrubin at mit.edu>> wrote:
>> >>    Actually we already have service bits (which are sadly limited)
>> which allow negotiation of non bilateral feature
>> >>    support, so this would supercede that.
>> >>    --
>> >>    @JeremyRubin <https://twitter.com/JeremyRubin><
>> https://twitter.com/JeremyRubin>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200824/3991406e/attachment.html>

From antoine.riard at gmail.com  Mon Aug 24 19:30:05 2020
From: antoine.riard at gmail.com (Antoine Riard)
Date: Mon, 24 Aug 2020 20:30:05 +0100
Subject: [bitcoin-dev] Detailed protocol design for routed
 multi-transaction CoinSwap
In-Reply-To: <813e51a1-4252-08c0-d42d-5cef32f684bc@riseup.net>
References: <813e51a1-4252-08c0-d42d-5cef32f684bc@riseup.net>
Message-ID: <CALZpt+GxKDEDAGUH3Jb3rcZdh_jy_depLRE5KzGTpkZOLVH+QA@mail.gmail.com>

Hello Chris,

I think you might have vulnerability issues with the current design.

With regards to the fee model for contract transactions, AFAICT timely
confirmation is a fund safety matter for an intermediate hop. Between the
offchain preimage reveal phase and the offchain private key handover phase,
the next hop can broadcast your outgoing contract transactions, thus
forcing you to claim quickly backward as you can't assume previous hop will
honestly cooperate to achieve the private key handover. This means that
your range of pre-signed RBF-transactions must theoretically have for fee
upper bound the maximum of the contested balance, as game-theory side, it's
rational to you to burn your balance instead of letting your counterparty
claim it after timelock expiration, in face of mempool congestion. Where
the issue dwells is that this fee is pre-committed and not cancelled when
the balance change of ownership by the outgoing hop learning the preimage
of the haslock output. Thus the previous hop is free to broadcast the
highest-fee RBF-transactions and burn your balance, as for him, his balance
is now encoded in the output of the contract transactions on the previous
link, for which he knows the preimage.

Note, I think this is independent of picking up either relative or absolute
timelocks as what matters is the block delta between two links. Of course
you can increase this delta to be week-lengthy and thus decrease the need
for a compelling fee but a) you may force quickly close with contract
transactions if the private key handover doesn't happen soon, you don't
want to be caught by surprise by congestion so you would close far behind
delta period expiration like half of it, and b) you increase the time-value
of makers funds in case of faulty hop, thus logically increasing the maker
fee and making the cost of the system higher in average. I guess a better
solution would be to use dual-anchor outputs has spec'ed out by Lightning,
it lets the party who has a balance at stake unilaterally increase feerate
with a CPFP. The CPFP is obviously a higher blockchain cost but a) it's a
safety mechanism for a worst-case scenario, 99% of the time they won't be
committed, b) you might use this CPFP to aggregate change outputs or other
opportunistically side-usage.

With regards to the preimage release phase, I think you might have a
pinning scenario. The victim would be an intermediate hop, targeted by a
malicious taker. The preimage isn't revealed offchain to this victim hop. A
low-feerate version of the outgoing contract transaction is broadcast and
not going to confirm, assuming a bit of congestion. As preimage is known,
the malicious taker can directly attach a high-fee, low-feerate child
transaction and thus prevent any replacement of the pinned parent by a
honest broadcast of a high-fee RBF-transaction under BIP 125 rules. At the
same time, the malicious taker broadcasts the contract tx on the previous
link and gets it confirmed. At relative timelock expiration, malicious
taker claims back the funds. When the pinned transaction spending the
outgoing link gets evicted (either by replacing child by a higher feerate
or waiting for mempool expiration after 2 weeks), taker gets it confirmed
this time and claims output through hashlock. Given the relative timelock
blocking the victim, there is not even a race.

I guess restraining the contract transaction to one and only one version
would overcome this attack. A honest intermediate hop, as soon as seeing a
relative timelock triggered backward would immediately broadcast the
outgoing link contract tx or if it's already in network mempools broadcast
a higher-feerate child. As you don't have valid multiple contract
transactions, an attacker can't obstruct you to propagate the correct
child, as you are not blind about the parent txid.

Lastly, one downside of using relative timelocks, in case of one downstream
link failure, it forces every other upstream hops to go onchain to protect
against this kind of pinning scenario. And this would be a privacy
breakdown, as a maker would be able to provoke one, thus constraining every
upstream hops to go onchain with the same hash and revealing the CoinSwap
route.

Let me know if I reviewed the correct transactions circuit model or
misunderstood associated semantic. I might be completely wrong, coming from
a LN perspective.

Cheers,
Antoine

Le mar. 11 ao?t 2020 ? 13:06, Chris Belcher via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> a ?crit :

> I'm currently working on implementing CoinSwap (see my other email
> "Design for a CoinSwap implementation for massively improving Bitcoin
> privacy and fungibility").
>
> CoinSwaps are special because they look just like regular bitcoin
> transactions, so they improve the privacy even for people who do not use
> them. Once CoinSwap is deployed, anyone attempting surveillance of
> bitcoin transactions will be forced to ask themselves the question: how
> do we know this transaction wasn't a CoinSwap?
>
> This email contains a detailed design of the first protocol version. It
> makes use of the building blocks of multi-transaction CoinSwaps, routed
> CoinSwaps, liquidity market, private key handover, and fidelity bonds.
> It does not include PayJoin-with-CoinSwap, but that's in the plan to be
> added later.
>
> == Routed CoinSwap ==
>
> Diagram of CoinSwaps in the route:
>
>     Alice ====> Bob ====> Charlie ====> Alice
>
> Where (====>) means one CoinSwap. Alice gives coins to Bob, who gives
> coins to Charlie, who gives coins to Alice. Alice is the market taker
> and she starts with the hash preimage. She chooses the CoinSwap amount
> and chooses who the makers will be.
>
> This design has one market taker and two market makers in its route, but
> it can easily be extended to any number of makers.
>
> == Multiple transactions ==
>
> Each single CoinSwap is made up of multiple transactions to avoid amount
> correlation
>
>           (a0 BTC) --->     (b0 BTC) --->         (c0 BTC) --->
>     Alice (a1 BTC) ---> Bob (b1 BTC) ---> Charlie (c1 BTC) ---> Alice
>           (a2 BTC) --->     (b2 BTC) --->         (c2 BTC) --->
>
> The arrow (--->) represent funding transactions. The money gets paid to
> a 2-of-2 multisig but after the CoinSwap protocol and private key
> handover is done they will be controlled by the next party in the route.
>
> This example has 6 regular-sized transactions which use approximately
> the same amount of block space as a single JoinMarket coinjoin with 6
> parties (1 taker, 5 makers). Yet the privacy provided by this one
> CoinSwap would be far far greater. It would not have to be repeated in
> the way that Equal-Output CoinJoins must be.
>
> == Direct connections to Alice ===
>
> Only Alice, the taker, knows the entire route, Bob and Charlie just know
> their previous and next transactions. Bob and Charlie do not have direct
> connections with each other, only with Alice.
>
> Diagram of Tor connections:
>
>     Bob      Charlie
>      |       /
>      |      /
>      |     /
>       Alice
>
> When Bob and Charlie communicate, they are actually sending and
> receiving messages via Alice who relays them to Charlie or Bob. This
> helps hide whether the previous or next counterparty in a CoinSwap route
> is a maker or taker.
>
> This doesn't have security issues even in the final steps where private
> keys are handed over, because those private keys are always for 2-of-2
> multisig and so on their own are never enough to steal money.
>
>
> === Miner fees ===
>
> Makers have no incentive to pay any miner fees. They only do
> transactions which earn them an income and are willing to wait a very
> long time for that to happen. By contrast takers want to create
> transactions far more urgently. In JoinMarket we coded a protocol where
> the maker could contribute to miner fees, but the market price offered
> of that trended towards zero. So the reality is that takers will pay all
> the miner fees. Also because makers don't know the taker's time
> preference they don't know how much they should pay in miner fees.
>
> The taker will have to set limits on how large the maker's transactions
> are, otherwise makers could abuse this by having the taker consolidate
> maker's UTXOs for free.
>
> == Funding transaction definitions ==
>
> Funding transactions are those which pay into the 2-of-2 multisig
> addresses.
>
> Definitions:
> I = initial coinswap amount sent by Alice = a0 + a1 + a2
> (WA, WB, WC) = Total value of UTXOs being spent by Alice, Bob, Charlie
>                respectively. Could be called "wallet Alice", "wallet
>                Bob", etc
> (B, C) = Coinswap fees paid by Alice and earned by Bob and Charlie.
> (M1, M2, M3) = Miner fees of the first, second, third, etc sets of
>                funding transactions. Alice will choose what these are
>                since she's paying.
> multisig(A+B) = A 2of2 multisig output with private keys held by A and B
>
> The value in square parentheses refers to the bitcoin amount.
>
> Alice funding txes
>   [WA btc] ---> multisig (Alice+Bob) [I btc]
>                 change [WA-M1-I btc]
> Bob funding txes
>   [WB btc] ---> multisig (Bob+Charlie) [I-M2-B btc]
>                 change [WB-I+B btc]
> Charlie funding txes
>   [WC btc] ---> multisig (Charlie+Alice) [(I-M2-B)-M3-C btc]
>                 change [WC-(I-M2-B)+C btc]
>
> Here we've drawn these transactions as single transactions, but they are
> actually multiple transactions where the outputs add up some value (e.g.
> add up to I in Alice's transactions.)
>
> === Table of balances before and after a successful CoinSwap ===
>
> If a CoinSwap is successful then all the multisig outputs in the funding
> transactions will become controlled unilaterally by one party. We can
> calculate how the balances of each party change.
>
> Party   | Before | After
> --------|--------|-------------------------------------------
> Alice   | WA     | WA-M1-I + (I-M2-B)-M3-C  = WA-M1-M2-M3-B-C
> Bob     | WB     | WB-I+B + I               = WB+B
> Charlie | WC     | WC-(I-M2-B)+C + I-M2-B   = WC+C
>
> After a successful coinswap, we see Alice's balance goes down by the
> miner fees and the coinswap fees. Bob's and Charlie's balance goes up by
> their coinswap fees.
>
> == Contract transaction definitions ==
>
> Contract transactions are those which may spend from the 2-of-2 multisig
> outputs, they transfer the coins into a contract where the coins can be
> spent either by waiting for a timeout or providing a hash preimage
> value. Ideally contract transactions will never be broadcast but their
> existence keeps all parties honest.
>
> M~ is miner fees, which we treat as a random variable, and ultimately
> set by whichever pre-signed RBF tx get mined. When we talk about _the_
> contract tx, we actually mean perhaps 20-30 transactions which only
> differ by the miner fee and have RBF enabled, so they can be broadcasted
> in sequence to get the contract transaction mined regardless of the
> demand for block space.
>
> (Alice+timelock_A OR Bob+hash) = Is an output which can be spent
>                                  either with Alice's private key
>                                  after waiting for a relative
>                                  timelock_A, or by Bob's private key by
>                                  revealing a hash preimage value
>
> Alice contract tx:
>     multisig (Alice+Bob) ---> (Alice+timelock_A OR Bob+hash)
>     [I btc]                   [I-M~ btc]
> Bob contract tx:
>     multisig (Bob+Charlie) ---> (Bob+timelock_B OR Charlie+hash)
>     [I-M2-B btc]                [I-M2-B-M~ btc]
> Charlie contract tx:
>     multisig (Charlie+Alice)  ---> (Charlie+timelock_C OR Alice+hash)
>     [(I-M2-B)-M3-C btc]            [(I-M2-B)-M3-C-M~ btc]
>
>
> === Table of balances before/after CoinSwap using contracts transactions
> ===
>
> In this case the parties had to get their money back by broadcasting and
> mining the contract transactions and waiting for timeouts.
>
> Party   | Before | After
> --------|--------|--------------------------------------------
> Alice   | WA     | WA-M1-I + I-M~                   = WA-M1-M~
> Bob     | WB     | WB-I+B + I-M2-B-M~               = WB-M2-M~
> Charlie | WC     | WC-(I-M2-B)+C + (I-M2-B)-M3-C-M~ = WC-M3-M~
>
> In the timeout failure case, every party pays for their own miner fees.
> And nobody earns or spends any coinswap fees. So even for a market maker
> its possible for their wallet balance to go down sometimes, although as
> we shall see there are anti-DOS features which make this unlikely to
> happen often.
>
> A possible attack by a malicious Alice is that she chooses M1 to be very
> low (e.g. 1 sat/vbyte) and sets M2 and M3 to be very high (e.g. 1000
> sat/vb) and then intentionally aborts, forcing the makers to lose much
> more money in miner fees than the attacker. The attack can be used to
> waste away Bob's and Charlie's coins on miner fees at little cost to the
> malicious taker Alice. So to defend against this attack Bob and Charlie
> must refuse to sign a contract transaction if the corresponding funding
> transaction pays miner fees greater than Alice's funding transaction.
>
>
> There can also be a failure case where each party gets their money using
> hash preimage values instead of timeouts. Note that each party has to
> sweep the output before the timeout expires, so that will cost an
> additional miner fee M~.
>
> Party   | Before | After
> --------|--------|------------------------------------------------------
> Alice   | WA     | WA-M1-I + (I-M2-B)-M3-C-M~ - M~ = WA-M1-M2-M3-B-C-2M~
> Bob     | WB     | WB-I+B + I-M~ - M~              = WB+B-2M~
> Charlie | WC     | WC-(I-M2-B)+C + I-M2-B-M~ - M~  = WC+C-2M~
>
> In this situation the makers Bob and Charlie earn their CoinSwap fees,
> but they pay an additional miner fee twice. Alice pays for all the
> funding transaction miner fees, and the CoinSwap fees, and two
> additional miner fees. And she had her privacy damaged because the
> entire world saw on the blockchain the contract script.
>
> Using the timelock path is like a refund, everyone's coin just comes
> back to them. Using the preimage is like the CoinSwap transaction
> happened, with the coins being sent ahead one hop. Again note that if
> the preimage is used then coinswap fees are paid.
>
> === Staggered timelocks ===
>
> The timelocks are staggered so that if Alice uses the preimage to take
> coins then the right people will also learn the preimage and have enough
> time to be able to get their coins back too. Alice starts with knowledge
> of the hash preimage so she must have a longest timelock.
>
> == EC tweak to reduce one round trip ==
>
> When two parties are agreeing on a 2-of-2 multisig address, they need to
> agree on their public keys. We can avoid one round trip by using the EC
> tweak trick.
>
> When Alice, the taker, downloads the entire offer book for the liquidity
> market, the offers will also contain a EC public key. Alice can tweak
> this to generate a brand new public key for which the maker knows the
> private key. This public key will be one of the keys in the 2-of-2
> multisig. This feature removes one round trip from the protocol.
>
>     q = EC privkey generated by maker
>     Q = q.G = EC pubkey published by maker
>
>     p = nonce generated by taker
>     P = p.G = nonce point calculated by taker
>
>     R = Q + P = pubkey used in bitcoin transaction
>       = (q + p).G
>
> Taker sends unsigned transaction which pays to multisig using pubkey Q,
> and also sends nonce p. The maker can use nonce p to calculate (q + p)
> which is the private key of pubkey R.
>
> Taker doesnt know the privkey because they are unable to find q because
> of the ECDLP.
>
> Any eavesdropper can see the nonce p and easily calculate the point R
> too but Tor communication is encrypted so this isnt a concern.
>
> None of the makers in the route know each other's Q values, so Alice the
> taker will generate a nonce p on their behalf and send it over. I
> believe this cant be used for any kind of attack, because the signing
> maker will always check that the nonce results in the public key
> included in the transaction they're signing, and they'll never sign a
> transaction not in their interests.
>
>
> == Protocol ==
>
> This section is the most important part of this document.
>
> Definitions:
> fund = all funding txes (remember in this multi-tx protocol there can be
>        multiple txes which together make up the funding)
> A htlc = all htlc contract txes (fully signed) belonging to party A
> A unsign htcl = all unsigned htlc contract txes belonging to party A
>                 including the nonce point p used to calculate the
>                 maker's pubkey.
> p = nonce point p used in the tweak EC protocol for calculating the
>     maker's pubkey
> A htlc B/2 = Bob's signature for the 2of2 multisig of the Alice htlc
>              contract tx
> privA(A+B) = private key generated by Alice in the output
>              multisig (Alice+Bob)
>
>
>  | Alice           | Bob             | Charlie         |
>  |=================|=================|=================|
> 0. A unsign htlc ---->               |                 |
> 1.               <---- A htlc B/2    |                 |
> 2. ***** BROADCAST AND MINE ALICE FUNDING TXES ******  |
> 3. A fund+htlc+p ---->               |                 |
> 4.                 | B unsign htlc ---->               |
> 5.                 |               <---- B htlc C/2    |
> 6. ******* BROADCAST AND MINE BOB FUNDING TXES ******* |
> 7.                 | B fund+htlc+p ---->               |
> 8.               <---------------------- C unsign htlc |
> 9.    C htlc A/2 ---------------------->               |
> A. ***** BROADCAST AND MINE CHARLIE FUNDING TXES ***** |
> B.               <---------------------- C fund+htlc+p |
> C. hash preimage ---------------------->               |
> D. hash preimage ---->               |                 |
> E.    privA(A+B) ---->               |                 |
> F.                 |    privB(B+C) ---->               |
> G.               <---------------------- privC(C+A)    |
>
> == Protocol notes ==
> 0-2 are the steps which setup Alice's funding tx and her contract tx for
>     possible refund
> 4-5 same as 0-2 but for Bob
> 8-9 same as 0-2 but for Charlie
> 3,7 is proof to the next party that the previous party has already
>     committed miner fees to getting a transaction mined, and therefore
>     this isnt a DOS attack. The step also reveals the fully-signed
>     contract transaction which the party can use to get their money back
>     with a preimage.
> C-G is revealing the hash preimage to all, and handing over the private
>     keys
>
>
> == Analysis of aborts ==
>
> We will now discuss aborts, which happen when one party halts the
> protocol and doesnt continue. Perhaps they had a power cut, their
> internet broke, or they're a malicious attacker wanting to waste time
> and money. The other party may try to reestablish a connection for some
> time, but eventually must give up.
>
> Number refers to the step number where the abort happened
> e.g. step 1 means that the party aborted instead of the action happening
> on protocol step 1.
>
> The party name refers to what that party does
> e.g. Party1: aborts, Party2/Party3: does a thing in reaction
>
> 0. Alice: aborts. Bob/Charlie: do nothing, they havent lost any time or
>    money
> 1. Bob: aborts. Alice: lost no time or money, try with another Bob.
>    Charlie: do nothing
> 2-3. same as 0.
> 4. Bob: aborts. Charlie: do nothing. Alice: broadcasts her contract tx
>    and waits for the timeout, loses time and money on miner fees, she'll
>    never coinswap with Bob's fidelity bond again.
> 5. Charlie: aborts. Alice/Bob: lose nothing, find another Charlie to
>    coinswap with.
> 6. same as 4.
> 7. similar to 4 but Alice MIGHT not blacklist Bob's fidelity bond,
>    because Bob will also have to broadcast his contract tx and will also
>    lose time and money.
> 8. Charlie: aborts. Bob: broadcast his contract transaction and wait for
>    the timeout to get his money back, also broadcast Alice's contract
>    transaction in retaliation. Alice: waits for the timeout on her htlc
>    tx that Bob broadcasted, will never do a coinswap with Charlie's
>    fidelity bond again.
> 9. Alice: aborts. Charlie: do nothing, no money or time lost. Bob:
>    broadcast bob contract tx and wait for timeout to get money back,
>    comforted by the knowledge that when Alice comes back online she'll
>    have to do the same thing and waste the same amount of time and
>    money.
> A-B. same as 8.
> C-E. Alice: aborts. Bob/Charlie: all broadcast their contract txes and
>      wait for the timeout to get their money back, or if Charlie knows
>      the preimage he uses it to get the money immediately, which Bob can
>      read from the blockchain and also use.
> F. Bob: aborts. Alice: broadcast Charlie htlc tx and use preimage to get
>    money immediately, Alice blacklists Bob's fidelity bond. Charlie:
>    broadcast Bob htlc and use preimage to get money immediately.
> G. Charlie: aborts. Alice: broadcast Charlie htlc and use preimage to
>    get money immediately, Alice blacklists Charlie's fidelity bond. Bob:
>    does nothing, already has his privkey.
>
> ==== Retaliation as DOS-resistance ====
>
> In some situations (e.g. step 8.) if one maker in the coinswap route is
> the victim of a DOS they will retaliate by DOSing the previous maker in
> the route. This may seem unnecessary and unfair (after all why waste
> even more time and block space) but is actually the best way to resist
> DOS because it produces a concrete cost every time a DOS happens.
>
>
> == Analysis of deviations ==
>
> This section discusses what happens if one party deviates from the
> protocol by doing something else, for example broadcasting a htlc
> contract tx when they shouldnt have.
>
> The party name refers to what that party does, followed by other party's
> reactions to it.
> e.g. Party1: does a thing, Party2/Party3: does a thing in reaction
>
> If multiple deviations are possible in a step then they are numbered
> e.g. A1 A2 A2 etc
>
>
> 0-2. Alice/Bob/Charlie: nothing else is possible except following the
>      protocol or aborting
> 3. Alice: broadcasts one or more of the A htlc txes. Bob/Charlie/Dennis:
>    do nothing, they havent lost any time or money.
> 4-6. Bob/Charlie: nothing else is possible except following the protocol
>      or aborting.
> 7. Bob: broadcasts one or more of the B htlc txes, Alice: broadcasts all
>    her own A htlc txes and waits for the timeout to get her money back.
>    Charlie: do nothing
> 8. Charlie: nothing else is possible except following the protocol or
>    aborting.
> 9. Alice: broadcasts one or more of the A htlc txes. Bob: broadcasts all
>    his own A htlc txes and waits for the timeout.
> A. same as 8.
> B. Charlie: broadcasts one or more of the C htlc txes, Alice/Bob:
>    broadcasts all their own htlc txes and waits for the timeout to get
>    their money back.
> C-E1. Alice: broadcasts all of C htlc txes and uses her knowledge of the
>       preimage hash to take the money immediately. Charlie: broadcasts
>       all of B htlc txes and reading the hash value from the blockchain,
>       uses it to take the money from B htlc immediately. Bob: broadcasts
>       all of A htlc txes, and reading hash from the blockchain, uses it
>       to take the money from A htlc immediately.
> C-E2. Alice: broadcast her own A htlc txes, and after a timeout take the
>       money. Bob: broadcast his own B htlc txes and after the timeout
>       take their money. Charlie: broadcast his own C htlc txes and after
>       the timeout take their money.
> F1. Bob: broadcast one or more of A htcl txes and use the hash preimage
>     to get the money immediately. He already knows both privkeys of the
>     multisig so this is pointless and just damages privacy and wastes
>     miner fees. Alice: blacklist Bob's fidelity bond.
> F2. Bob: broadcast one or more of the C htlc txes. Charlie: use preimage
>     to get his money immediately. Bob's actions were pointless. Alice:
>     cant tell whether Bob or Charlie actually broadcasted, so blacklist
>     both fidelity bonds.
> G1. Charlie: broadcast one or more of B htcl txes and use the hash
>     preimage to get the money immediately. He already knows both
>     privkeys of the multisig so this is pointless and just damages
>     privacy and wastes miner fees. Alice: cant tell whether Bob or
>     Charlie actually broadcasted, so blacklist both fidelity bonds.
> G2. Charlie: broadcast one or more of the A htlc txes. Alice: broadcast
>     the remaining A htlc txes and use preimage to get her money
>     immediately. Charlies's actions were pointless. Alice: blacklist
>     Charlie's fidelity bond.
>
> The multisig outputs of the funding transactions can stay unspent
> indefinitely. However the parties must always be watching the network
> and ready to respond with their own sweep using a preimage. This is
> because the other party still possesses a fully-signed contract tx. The
> parties respond in the same way as in steps C-E1, F2 and G2. Alice's
> reaction of blacklisting both fidelity bonds might not be the right way,
> because one maker could use it to get another one blacklisted (as well
> as themselves).
>
>
> == Conclusion ==
>
> This document describes the first version of the protocol which
> implements multi-transaction Coinswap, routed Coinswap, fidelity bonds,
> a liquidity market and private key handover. I describe the protocol and
> also analyze aborts of the protocols and deviations from the protocol.
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200824/758a5361/attachment-0001.html>

From jlrubin at mit.edu  Mon Aug 24 19:58:56 2020
From: jlrubin at mit.edu (Jeremy)
Date: Mon, 24 Aug 2020 12:58:56 -0700
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
 connections are setup
In-Reply-To: <27FE83C7-0269-4DEB-82E4-486FAFFA0DE5@voskuil.org>
References: <afcedaf1-dd69-9402-eeeb-006bb9211b98@mattcorallo.com>
 <27FE83C7-0269-4DEB-82E4-486FAFFA0DE5@voskuil.org>
Message-ID: <CAD5xwhgDWpaavk3R5gjUwMU37bRTmKC+o5hHoWVeaiW8WFQNjA@mail.gmail.com>

>
>
>
>
>
>
> * >> On 8/21/20 5:17 PM, Jeremy wrote: >> As for an example of where you'd
> want multi-round, you could imagine a scenario where you have a feature A
> which gets bugfixed by the introduction of feature B, and you don't want to
> expose that you support A unless you first negotiate B. Or if you can
> negotiate B you should never expose A, but for old nodes you'll still do it
> if B is unknown to them. This seems to imply a security benefit (I can?t
> discern any other rationale for this complexity). It should be clear that
> this is no more than trivially weak obfuscation and not worth complicating
> the protocol to achieve.*


The benefit is not privacy oriented and I didn't intend to imply as such.
The benefit is that you may only wish to expose functionality to peers
which support some other set of features. For example, with wtxid relay, I
might want to expose some additional functionality after establishing my
peer supports it, that peers which do not have wtxid relay should not be
allowed to use. The benefit over just exposing all functions is then a node
might be programmed to support the new feature but not wtxid relay, which
can lead to some incompatibilities.

You cannot implement this logic as a purely post-hoc "advertise all and
then figure out what is allowed" because then you require strict
consistency between peers of that post-hoc feature availability implication
map.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200824/f26112b9/attachment.html>

From eric at voskuil.org  Mon Aug 24 20:17:17 2020
From: eric at voskuil.org (Eric Voskuil)
Date: Mon, 24 Aug 2020 13:17:17 -0700
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
	connections are setup
In-Reply-To: <CAD5xwhgDWpaavk3R5gjUwMU37bRTmKC+o5hHoWVeaiW8WFQNjA@mail.gmail.com>
References: <CAD5xwhgDWpaavk3R5gjUwMU37bRTmKC+o5hHoWVeaiW8WFQNjA@mail.gmail.com>
Message-ID: <5B76307E-9810-49F1-8289-E0F0E84ACD72@voskuil.org>

I said security, not privacy. You are in fact exposing the feature to any node that wants to negotiate for it. if you don?t want to expose the buggy feature, then disable it. Otherwise you cannot prevent peers from accessing it. Presumably peers prefer the new feature if they support it, so there is no need for this complexity.

e

> On Aug 24, 2020, at 12:59, Jeremy <jlrubin at mit.edu> wrote:
> 
> ?
>> 
>> >> On 8/21/20 5:17 PM, Jeremy wrote:
>> >> As for an example of where you'd want multi-round, you could imagine a scenario where you have a feature A which gets bugfixed by the introduction of feature B, and you don't want to expose that you support A unless you first negotiate B. Or if you can negotiate B you should never expose A, but for old nodes you'll still do it if B is unknown to them.
>> 
>> This seems to imply a security benefit (I can?t discern any other rationale for this complexity). It should be clear that this is no more than trivially weak obfuscation and not worth complicating the protocol to achieve.
> 
> 
> The benefit is not privacy oriented and I didn't intend to imply as such. The benefit is that you may only wish to expose functionality to peers which support some other set of features. For example, with wtxid relay, I might want to expose some additional functionality after establishing my peer supports it, that peers which do not have wtxid relay should not be allowed to use. The benefit over just exposing all functions is then a node might be programmed to support the new feature but not wtxid relay, which can lead to some incompatibilities.
> 
> You cannot implement this logic as a purely post-hoc "advertise all and then figure out what is allowed" because then you require strict consistency between peers of that post-hoc feature availability implication map.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200824/edfe09fb/attachment.html>

From jlrubin at mit.edu  Mon Aug 24 20:21:52 2020
From: jlrubin at mit.edu (Jeremy)
Date: Mon, 24 Aug 2020 13:21:52 -0700
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
 connections are setup
In-Reply-To: <5B76307E-9810-49F1-8289-E0F0E84ACD72@voskuil.org>
References: <CAD5xwhgDWpaavk3R5gjUwMU37bRTmKC+o5hHoWVeaiW8WFQNjA@mail.gmail.com>
 <5B76307E-9810-49F1-8289-E0F0E84ACD72@voskuil.org>
Message-ID: <CAD5xwhiSf3isoMsVJiv5KQ3n5ymcS+StigkX_eDe5hmAGra-0Q@mail.gmail.com>

On Mon, Aug 24, 2020 at 1:17 PM Eric Voskuil <eric at voskuil.org> wrote:

> I said security, not privacy. You are in fact exposing the feature to any
> node that wants to negotiate for it. if you don?t want to expose the buggy
> feature, then disable it. Otherwise you cannot prevent peers from accessing
> it. Presumably peers prefer the new feature if they support it, so there is
> no need for this complexity.
>
>
>
I interpreted* " This seems to imply a security benefit (I can?t discern
any other rationale for this complexity). It should be clear that this is
no more than trivially weak obfuscation and not worth complicating the
protocol to achieve.", *to be about obfuscation and therefore privacy.

The functionality that I'm mentioning might not be buggy, it might just not
support peers who don't support another feature. You can always disconnect
a peer who sends a message that you didn't handshake on (or maybe we should
elbow bump given the times).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200824/27b10d97/attachment.html>

From eric at voskuil.org  Mon Aug 24 20:33:46 2020
From: eric at voskuil.org (Eric Voskuil)
Date: Mon, 24 Aug 2020 13:33:46 -0700
Subject: [bitcoin-dev] Generalizing feature negotiation when new p2p
	connections are setup
In-Reply-To: <CAD5xwhiSf3isoMsVJiv5KQ3n5ymcS+StigkX_eDe5hmAGra-0Q@mail.gmail.com>
References: <CAD5xwhiSf3isoMsVJiv5KQ3n5ymcS+StigkX_eDe5hmAGra-0Q@mail.gmail.com>
Message-ID: <B5077EB6-64CB-4067-96F0-5E11C074FE8C@voskuil.org>

I see no requirement for anything here apart from exchanging a list of supported ?features?. Conditionally hiding a feature provides no benefit. Any peer that wants it can get it (obfuscation being weak security), and otherwise it?s a non-issue.

e

> On Aug 24, 2020, at 13:22, Jeremy <jlrubin at mit.edu> wrote:
> 
>> On Mon, Aug 24, 2020 at 1:17 PM Eric Voskuil <eric at voskuil.org> wrote:
>> I said security, not privacy. You are in fact exposing the feature to any node that wants to negotiate for it. if you don?t want to expose the buggy feature, then disable it. Otherwise you cannot prevent peers from accessing it. Presumably peers prefer the new feature if they support it, so there is no need for this complexity.
> 
> I interpreted " This seems to imply a security benefit (I can?t discern any other rationale for this complexity). It should be clear that this is no more than trivially weak obfuscation and not worth complicating the protocol to achieve.", to be about obfuscation and therefore privacy.
> 
> The functionality that I'm mentioning might not be buggy, it might just not support peers who don't support another feature. You can always disconnect a peer who sends a message that you didn't handshake on (or maybe we should elbow bump given the times).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200824/e5e1facc/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Tue Aug 25 03:16:05 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 25 Aug 2020 03:16:05 +0000
Subject: [bitcoin-dev] Detailed protocol design for routed
	multi-transaction CoinSwap
In-Reply-To: <CALZpt+GxKDEDAGUH3Jb3rcZdh_jy_depLRE5KzGTpkZOLVH+QA@mail.gmail.com>
References: <813e51a1-4252-08c0-d42d-5cef32f684bc@riseup.net>
 <CALZpt+GxKDEDAGUH3Jb3rcZdh_jy_depLRE5KzGTpkZOLVH+QA@mail.gmail.com>
Message-ID: <VpsctPiYOV704v9wZiSROdRggid7uRv2mZVnCIILEPL4_VmwKhMVdNMPBj9XaF73-39jFLl3cq1o2tSk8h45tMuWM9W_i4_MQHKoJdYh9ew=@protonmail.com>


Good morning Antoine,


> Note, I think this is independent of picking up either relative or absolute timelocks as what matters is the block delta between two links.

I believe it is quite dependent on relative locktimes.
Relative locktimes *require* a contract transaction to kick off the relative locktime period.
On the other hand, with Scriptless Script (which we know how to do with 2p-ECDSA only, i.e. doable pre-Taproot), absolute locktimes do not need a contract transaction.

With absolute locktimes + Scriptless SCript, in a single onchain PTLC, one participant holds a completely-signed timelock transaction while the other participant holds a completely-signed pointlock transaction.
This can be arranged by having one side offer partial signatures for the transaction of the other, and once completing the signature, not sharing it with the other until we are ready to actually broadcast the transaction of our own volition.
There is no transaction that both participants hold in completely-signed form.

This should remove most of the shenanigans possible, and makes the 30xRBF safe for any range of fees.
I think.

Since for each PTLC a participant holds only its "own" transaction, it is possible for a participant to define its range of fees for the RBF versions of the transaction it owns, without negotiation with the other participant.
Since the fee involved is deducted from its own transaction, each participant can define this range of RBFed fees and impose it on the partial signatures it gets from the other participant.

--

Private key turnover is still useful even in an absolute-timelock world.

If we need to bump up the block delta between links, it might be impractical to have the total delta of a multi-hop swap be too long at the taker.

As a concrete example, suppose A is a taker who wants to route over makers B and C.
However, B and C require a CLTV delta of 1 week.

If A wants to route "directly" A->B->C->A, then if something bad happens, it could be looking at having its funds locked for two weeks.

To reduce this risk, A can instead first swap A->B->A, then when that completes, A->C->A.
This limits its funding lockup to 1 week.

Private key turnover is useful since as soon as the A->B->A swap completes, it can directly fund the A->C->A swap from the B-side funding transaction of the A->B->A swap.

         |   A->B->A         |    A->C->A           |
         :                   :                      :
      A -:->funding A&B--> B :                      :
         :                   :                      :
      B -:->funding A&B -----:--> funding A&C --> C :
         :                   :                      :
         :                   :C-> funding A&C ------:-> to-cold  A -->
         :                   :                      :

This increases the number of transactions by 1 per swap beyond the first, compared to a direct routing A->B->C->A, but this may be worth it for A if the timelocks involved are too big for A.

With 2p-ECDSA, a funding A&C looks exactly the same as a to-cold A, so B is unable to reliably determine if it is the last hop in the route.

Without private key turnover, A would have:

                      **NO** private key turnover!

         |   A->B->A         |    A->C->A                      |
         :                   :                                 :
      A -:->funding A&B--> B :                                 :
         :                   :                                 :
      B -:->funding A&B -----:--> claim A -> funding A&C --> C :
         :                   :                                 :
         :                   :           C-> funding A&C ------:-> to-cold  A -->
         :                   :                                 :

So if timelock-deltas are possibly-high (to reduce the probability of the MAD-HTLC argument, and other attacks, succeeding), takers might prefer to route by completing one swap first before starting the next one, and private key turnover is useful by reducing blockspace required by each hop.

For reference, this is how it looks like with a single A->B->C->A swap with private key turnover:

         |   A->B->C->A      |
         :                   :
      A -:->funding A&B--> B :
         :                   :
      B -:->funding B&C -> C :
         :                   :
      C -:->funding A&C -----:-> to-cold A -->
         :                   :

This is still smaller than in the A->B->A, A->C->A with private key turnover, by one funding tx per hop.
However, A risks a much higher timelock (twice the timelock).
Thus, A might prefer a lower timelock in exchange for paying for an additional transaction.

Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Tue Aug 25 03:16:05 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 25 Aug 2020 03:16:05 +0000
Subject: [bitcoin-dev] Detailed protocol design for routed
	multi-transaction CoinSwap
In-Reply-To: <CALZpt+GxKDEDAGUH3Jb3rcZdh_jy_depLRE5KzGTpkZOLVH+QA@mail.gmail.com>
References: <813e51a1-4252-08c0-d42d-5cef32f684bc@riseup.net>
 <CALZpt+GxKDEDAGUH3Jb3rcZdh_jy_depLRE5KzGTpkZOLVH+QA@mail.gmail.com>
Message-ID: <VpsctPiYOV704v9wZiSROdRggid7uRv2mZVnCIILEPL4_VmwKhMVdNMPBj9XaF73-39jFLl3cq1o2tSk8h45tMuWM9W_i4_MQHKoJdYh9ew=@protonmail.com>


Good morning Antoine,


> Note, I think this is independent of picking up either relative or absolute timelocks as what matters is the block delta between two links.

I believe it is quite dependent on relative locktimes.
Relative locktimes *require* a contract transaction to kick off the relative locktime period.
On the other hand, with Scriptless Script (which we know how to do with 2p-ECDSA only, i.e. doable pre-Taproot), absolute locktimes do not need a contract transaction.

With absolute locktimes + Scriptless SCript, in a single onchain PTLC, one participant holds a completely-signed timelock transaction while the other participant holds a completely-signed pointlock transaction.
This can be arranged by having one side offer partial signatures for the transaction of the other, and once completing the signature, not sharing it with the other until we are ready to actually broadcast the transaction of our own volition.
There is no transaction that both participants hold in completely-signed form.

This should remove most of the shenanigans possible, and makes the 30xRBF safe for any range of fees.
I think.

Since for each PTLC a participant holds only its "own" transaction, it is possible for a participant to define its range of fees for the RBF versions of the transaction it owns, without negotiation with the other participant.
Since the fee involved is deducted from its own transaction, each participant can define this range of RBFed fees and impose it on the partial signatures it gets from the other participant.

--

Private key turnover is still useful even in an absolute-timelock world.

If we need to bump up the block delta between links, it might be impractical to have the total delta of a multi-hop swap be too long at the taker.

As a concrete example, suppose A is a taker who wants to route over makers B and C.
However, B and C require a CLTV delta of 1 week.

If A wants to route "directly" A->B->C->A, then if something bad happens, it could be looking at having its funds locked for two weeks.

To reduce this risk, A can instead first swap A->B->A, then when that completes, A->C->A.
This limits its funding lockup to 1 week.

Private key turnover is useful since as soon as the A->B->A swap completes, it can directly fund the A->C->A swap from the B-side funding transaction of the A->B->A swap.

         |   A->B->A         |    A->C->A           |
         :                   :                      :
      A -:->funding A&B--> B :                      :
         :                   :                      :
      B -:->funding A&B -----:--> funding A&C --> C :
         :                   :                      :
         :                   :C-> funding A&C ------:-> to-cold  A -->
         :                   :                      :

This increases the number of transactions by 1 per swap beyond the first, compared to a direct routing A->B->C->A, but this may be worth it for A if the timelocks involved are too big for A.

With 2p-ECDSA, a funding A&C looks exactly the same as a to-cold A, so B is unable to reliably determine if it is the last hop in the route.

Without private key turnover, A would have:

                      **NO** private key turnover!

         |   A->B->A         |    A->C->A                      |
         :                   :                                 :
      A -:->funding A&B--> B :                                 :
         :                   :                                 :
      B -:->funding A&B -----:--> claim A -> funding A&C --> C :
         :                   :                                 :
         :                   :           C-> funding A&C ------:-> to-cold  A -->
         :                   :                                 :

So if timelock-deltas are possibly-high (to reduce the probability of the MAD-HTLC argument, and other attacks, succeeding), takers might prefer to route by completing one swap first before starting the next one, and private key turnover is useful by reducing blockspace required by each hop.

For reference, this is how it looks like with a single A->B->C->A swap with private key turnover:

         |   A->B->C->A      |
         :                   :
      A -:->funding A&B--> B :
         :                   :
      B -:->funding B&C -> C :
         :                   :
      C -:->funding A&C -----:-> to-cold A -->
         :                   :

This is still smaller than in the A->B->A, A->C->A with private key turnover, by one funding tx per hop.
However, A risks a much higher timelock (twice the timelock).
Thus, A might prefer a lower timelock in exchange for paying for an additional transaction.

Regards,
ZmnSCPxj

From Jule.Adka at protonmail.com  Tue Aug 25 13:42:05 2020
From: Jule.Adka at protonmail.com (Jule.Adka)
Date: Tue, 25 Aug 2020 13:42:05 +0000
Subject: [bitcoin-dev] New tipe of outputs that saves space and give more
	privacy
Message-ID: <4J4ILDzMrP8LgBtLcgYxftOAhGNX8BVFdamKbkbmD3fxz912nBxOLJnoq2hBgrD9OP5RUeMH7VrBcBItG2Tqz2b9SZokVI5qtiuO2RokY78=@protonmail.com>

Hey, there! I have a new proposal to help Bitcoin?s scalability, while helping privacy.

Motivation

All transactions in the Bitcoin?s network have a header, an input list and an output list. Every transaction must consume some previous outputs and create new ones, this creates huge amounts of data through the years, and creates scalability problems. With segwit we solved some problems by moving part of the data to a separate structure that stores data useful to verify the transaction itself, but not its state and the state of the whole blockchain[1]. But we still have a problem with the outputs list, some transactions create various outputs, generating munch data and increasing the size of the unspent transactions outputs(UTXOs) that are held for every full node into the network.

Another problem with this approach is the fact that all outputs are recorded, disclosed and accessible to everyone that looks at the transaction. This creates various privacy problems that are exploited for the chain analize companies and governments to track individuals and link it to their own personality.

Description

I propose a new type of output, called Mekelized Output Set and the p2mos(pay to Mekelized Output Set) standard. Instead of listing all the output set, as in an ordinary transaction, Alice only specifies a Markle root, and only when she tries to spend the coin, she may to show a path into the Merkle from her transaction to the recorded root (a.k.a Merkle Path), and proof that her output really exists.

The extra data (the path) are stored into the witness structure, and can be striped after verification. Once the size of the witness structure is ignored/discounted when calculating the block size, it gives more space for transactions in a unique block, without increasing it?s actual size. As well, decrease the UTXO?s size, taking less resource from validators node.

An ordinary(the current standard) p2wpkh transaction with one output have 8 bytes to amount, 1-9 varInt for the locking-script size and 22 bytes (OP_0 OP_PUSHBYTES_20 <20-bytes-hash>), at most 39 bytes for each output[2]. If we use sha256 to encode the merkle, we need only 32 of script data, 49 in the total. 10 bytes more than an ordinary transaction with one output. But usually the transactions have 2 outputs (the actual payment and a change) or more. If the transaction have 2 outputs, we only record one commitment and the two outputs keep hidden until it has been spent (also the UTXO set is have one transaction instead of 2), the 2 outputs would require 78 bytes to record, we can do it with the same 49 bytes. For a 12 outputs[3] transaction, it would require 468 bytes, and so on?

By using p2mos saves space by reducing any transaction to a 49 bytes-wide output set, no matter how many outputs actually exist. Also, once only the peers are able to know the number and the value of the outputs, a third party has no way to know the ownership of the remaining coins, many of the privacy troubles associated with outputs, like Equal-output CoinJoin and different outputs types[4] are solved.

An example

When Alice?s wallet create a transaction, sending 5 bitcoins to Bob and spending from a 10 bitcoins output (forget the fees, for a while), Alice must send 5 bitcoins to Bob and 5 back to she as change, when Bob?s wallet create the invoice to be paid by Alice, he gives an output to Alice and she adds it together into a Merkle Tree, takes the root and build a transaction paying to this hash. Alice?s wallet then sends a path into the tree to prove to Bob that his output is really into a transaction and is fully expendable from Bob?s wallet. Bob now looks for the mempool (and the chain, of course) to find transactions that pay to the given Markle Root.

Now let?s see how Bob spends from this UTXO. His wallet knows the path that has taken from his transaction to the top, and the wallet reveals it to the network, before evaluating the output. Bob sends the actual output, the path to the root of the tree as well the data to solve the lockscript on it(note that ?actual output? means the output that keeps hidden from the world until Bob spends it). After checking if Bob?s output really exists, an node can evaluate it exactly in the same way as ordinary transactions, the output will look like any other.

Alice?s wallet does the same to spend her 5 BTC, but presenting a totally different output, that she spends from a script that only she has a way to do, if they use p2wpkh she must present the public key and a valid signature. After evaluation, the node can discard all this data and keeps only with the 1-input-1-output transaction.

This new transaction has the same fields of an ordinary one, amount, script size and script. Probably we will need an opcode to make reference to p2mos (pay toMerkelized output set), instructing the node to look at the witness data in order to find the actual output. So, we have 1 byte of opcode and32 bytes of the Merkle Root. The amount is preserved for compatibility as well for calculating mining fees, once the miner has no idea of the actual value locked into the output. The fee calculus doesn't change.

The amount also is helpful to determine whether the UTXO still have any locked coins, if the total ?removed? outputs value (i.e the outputs that has been revealed and spent) are equal to the locked value, the output is now totally spend and may be removed from the UTXO?s set. If one tries to retrieve more than it?s actually locked in, it fails.

Let?s say that Alice locks her 10 BTC, but creates two outputs: 6 BTC to she and 5 BTC to Bob, if she spends from this output, now Bob have no way to spend from this, because if he broadcast his 5 BTC he will exceed the total value, and the evaluation will fall. The 5 BTC will be locked up forever, and he can?t create an alternative transaction, because it will never mech with the Merkle path and hence the root. To prevent this, some kind of verification of the values may be made by the wallets, all wallets must verify the values.

To one wallet verify all the outputs, without revealing the sigscript, we can hash the other 2 fields and exchange the hashes, the leafs of the tree are made by the hash(sigscript || scriptSize) || amount. Only the amounts are disclosed, keeping the privacy, after verifying the process of hashing can be done by all the parties, reaching the same root, at the end.

Pros

Using the p2mos, one keeps private the information about the outputs until it has been spent, as well saving space into the block and makes the transactions (without taking in account the witness data) smaller, decreasing the data used for SPV nodes. We still have an input and an output with explicit given values, that is useful for verifying the state of the chain.

Cons

Needs more coordination between the wallets (this is a problem, especially with scenarios that one part is offline), is a bit more hard to compute for a validator, and would require some extra bandwidth for downloading the witness data.

Retro Compatibility

On one hand, old nodes that don?t follow the new consensus rule can accept this kind of transaction if it?s made as a anyone can spend in the current consensus, but with other meanings in the new one(as segwit), but on the other hand, at a second spend, the node will interpret it as double spend, hence invalidating it. So the main problem with this approach is to implement it as a soft-fork.

I would like to receive any thoughts and considerations about this proposal. At the most, thank you very much. Sincerely, Jule Adka (Jule.Adka at protonmail.com)

[1][BIP141](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki), Segregated Witness

[2] ANTONOPOLOS, Andres. Mastering Bitcoin

[3] A 12-output transaction in[blockstream.info](https://blockstream.info/tx/1bdde4ec3486ac67018727cfb4aa7fd84011db29bc0fdb525a810ad2ab1eb24d).

[4] Privacy on[Bitcoin wiki](https://en.bitcoin.it/wiki/Privacy)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200825/aa27a927/attachment-0001.html>

From jlrubin at mit.edu  Tue Aug 25 15:24:46 2020
From: jlrubin at mit.edu (Jeremy)
Date: Tue, 25 Aug 2020 08:24:46 -0700
Subject: [bitcoin-dev] New tipe of outputs that saves space and give
	more privacy
In-Reply-To: <4J4ILDzMrP8LgBtLcgYxftOAhGNX8BVFdamKbkbmD3fxz912nBxOLJnoq2hBgrD9OP5RUeMH7VrBcBItG2Tqz2b9SZokVI5qtiuO2RokY78=@protonmail.com>
References: <4J4ILDzMrP8LgBtLcgYxftOAhGNX8BVFdamKbkbmD3fxz912nBxOLJnoq2hBgrD9OP5RUeMH7VrBcBItG2Tqz2b9SZokVI5qtiuO2RokY78=@protonmail.com>
Message-ID: <CAD5xwhjca8CnTda88EviFWz2wc0qVGYFF50TwT+kbguhLfdS6w@mail.gmail.com>

You may wish to review bip-119 ChecktemplateVerify, as it is designed to
support something very similar to what you've described. You can see more
at https://utxos.org

On Tue, Aug 25, 2020, 6:48 AM Jule.Adka via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hey, there! I have a new proposal to help Bitcoin?s scalability, while
> helping privacy.
>
> *Motivation*
>
> All transactions in the Bitcoin?s network have a header, an input list and
> an output list. Every transaction must consume some previous outputs and
> create new ones, this creates huge amounts of data through the years, and
> creates scalability problems. With segwit we solved some problems by moving
> part of the data to a separate structure that stores data useful to verify
> the transaction itself, but not its state and the state of the whole
> blockchain[1]. But we still have a problem with the outputs list, some
> transactions create various outputs, generating munch data and increasing
> the size of the unspent transactions outputs(UTXOs) that are held for every
> full node into the network.
>
> Another problem with this approach is the fact that all outputs are
> recorded, disclosed and accessible to everyone that looks at the
> transaction. This creates various privacy problems that are exploited for
> the chain analize companies and governments to track individuals and link
> it to their own personality.
>
> *Description*
>
> I propose a new type of output, called Mekelized Output Set and the
> p2mos(pay to Mekelized Output Set) standard. Instead of listing all the
> output set, as in an ordinary transaction, Alice only specifies a Markle
> root, and only when she tries to spend the coin, she may to show a path
> into the Merkle from her transaction to the recorded root (a.k.a Merkle
> Path), and proof that her output really exists.
>
> The extra data (the path) are stored into the witness structure, and can
> be striped after verification. Once the size of the witness structure is
> ignored/discounted when calculating the block size, it gives more space for
> transactions in a unique block, without increasing it?s actual size. As
> well, decrease the UTXO?s size, taking less resource from validators node.
>
>  An ordinary(the current standard) p2wpkh transaction with one output have
> 8 bytes to amount, 1-9 varInt for the locking-script size and 22 bytes
> (OP_0 OP_PUSHBYTES_20 <20-bytes-hash>), at most 39 bytes for each
> output[2]. If we use sha256 to encode the merkle, we need only 32 of script
> data, 49 in the total. 10 bytes more than an ordinary transaction with one
> output. But usually the transactions have 2 outputs (the actual payment and
> a change) or more. If the transaction have 2 outputs, we only record one
> commitment and the two outputs keep hidden until it has been spent (also
> the UTXO set is have one transaction instead of 2), the 2 outputs would
> require 78 bytes to record, we can do it with the same 49 bytes. For a 12
> outputs[3] transaction, it would require 468 bytes, and so on?
>
> By using p2mos saves space by reducing any transaction to a 49 bytes-wide
> output set, no matter how many outputs actually exist. Also, once only the
> peers are able to know the number and the value of the outputs, a third
> party has no way to know the ownership of the remaining coins, many of the
> privacy troubles associated with outputs, like Equal-output CoinJoin and
> different outputs types[4] are solved.
>
> *An example*
>
> When Alice?s wallet create a transaction, sending 5 bitcoins to Bob and
> spending from a 10 bitcoins output (forget the fees, for a while), Alice
> must send 5 bitcoins to Bob and 5 back to she as change, when Bob?s wallet
> create the invoice to be paid by Alice, he gives an output to Alice and she
> adds it together into a Merkle Tree, takes the root and build a transaction
> paying to this hash. Alice?s wallet then sends a path into the tree to
> prove to Bob that his output is really into a transaction and is fully
> expendable from Bob?s wallet. Bob now looks for the mempool (and the
> chain, of course) to find transactions that pay to the given Markle Root.
>
> Now let?s see how Bob spends from this UTXO. His wallet knows the path
> that has taken from his transaction to the top, and the wallet reveals it
> to the network, before evaluating the output. Bob sends the actual output,
> the path to the root of the tree as well the data to solve the lockscript
> on it(note that ?actual output? means the output that keeps hidden from the
> world until Bob spends it). After checking if Bob?s output really exists,
> an node can evaluate it exactly in the same way as ordinary transactions,
> the output will look like any other.
>
> Alice?s wallet does the same to spend her 5 BTC, but presenting a totally
> different output, that she spends from a script that only she has a way to
> do, if they use p2wpkh she must present the public key and a valid
> signature. After evaluation, the node can discard all this data and keeps
> only with the 1-input-1-output transaction.
>
> This new transaction has the same fields of an ordinary one, amount,
> script size and script. Probably we will need an opcode to make reference
> to p2mos (pay to Merkelized output set), instructing the node to look at
> the witness data in order to find the actual output. So, we have 1 byte of
> opcode and 32 bytes of the Merkle Root. The amount is preserved for
> compatibility as well for calculating mining fees, once the miner has no
> idea of the actual value locked into the output. The fee calculus doesn't
> change.
>
> The amount also is helpful to determine whether the UTXO still have any
> locked coins, if the total ?removed? outputs value (i.e the outputs that
> has been revealed and spent) are equal to the locked value, the output is
> now totally spend and may be removed from the UTXO?s set. If one tries to
> retrieve more than it?s actually locked in, it fails.
>
> Let?s say that Alice locks her 10 BTC, but creates two outputs: 6 BTC to
> she and 5 BTC to Bob, if she spends from this output, now Bob have no way
> to spend from this, because if he broadcast his 5 BTC he will  exceed the
> total value, and the evaluation will fall. The 5 BTC will be locked up
> forever, and he can?t create an alternative transaction, because it will
> never mech with the Merkle path and hence the root. To prevent this, some
> kind of verification of the values may be made by the wallets, all wallets
> must verify the values.
>
> To one wallet verify all the outputs, without revealing the sigscript, we
> can hash the other 2 fields and exchange the hashes, the leafs of the tree
> are made by the hash(sigscript || scriptSize) || amount. Only the amounts
> are disclosed, keeping the privacy, after verifying the process of hashing
> can be done by all the parties, reaching the same root, at the end.
>
> *Pros*
>
> Using the p2mos, one keeps private the information about the outputs until
> it has been spent, as well saving space into the block and makes the
> transactions (without taking in account the witness data) smaller,
> decreasing the data used for SPV nodes. We still have an input and an
> output with explicit given values, that is useful for verifying the state
> of the chain.
>
> *                                                          Cons*
>
> Needs more coordination between the wallets (this is a problem, especially
> with scenarios that one part is offline), is a bit more hard to compute for
> a validator, and would require some extra bandwidth for downloading the
> witness data.
>
> *Retro Compatibility*
>
> On one hand, old nodes that don?t follow the new consensus rule can accept
> this kind of transaction if it?s made as a anyone can spend in the current
> consensus, but with other meanings in the new one(as segwit), but on the
> other hand, at a second spend, the node will interpret it as double spend,
> hence invalidating it. So the main problem with this approach is to
> implement it as a soft-fork.
>
> I would like to receive any thoughts and considerations about this
> proposal. At the most, thank you very much. Sincerely, Jule Adka (
> Jule.Adka at protonmail.com)
>
> [1] *BIP141*
> <https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki>,
> Segregated Witness
>
> [2] ANTONOPOLOS, Andres. Mastering Bitcoin
>             [3] A 12-output transaction in *blockstream.info*
> <https://blockstream.info/tx/1bdde4ec3486ac67018727cfb4aa7fd84011db29bc0fdb525a810ad2ab1eb24d>
> .
>
> [4] Privacy on *Bitcoin wiki* <https://en.bitcoin.it/wiki/Privacy>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200825/24854a15/attachment-0001.html>

From bitcoin-dev at wuille.net  Thu Aug 27 01:10:21 2020
From: bitcoin-dev at wuille.net (Pieter Wuille)
Date: Thu, 27 Aug 2020 01:10:21 +0000
Subject: [bitcoin-dev] Revisiting squaredness tiebreaker for R point in
	BIP340
In-Reply-To: <CAFmfg2uL-gCV+1e1rf8+ywSUcEGTA01PP4jm+8kYub7R9E9hNw@mail.gmail.com>
References: <g7VgKBKlUmgMkNo6Nq1OkyilwW6Z4WbqeSZHXfvh_LDYmry5R7uGbavyEHtv2xr_0KBevL057TxSdlo_tS0_ucBXYNm8MuTu_jgyrGO9jpo=@wuille.net>
 <CAFmfg2uL-gCV+1e1rf8+ywSUcEGTA01PP4jm+8kYub7R9E9hNw@mail.gmail.com>
Message-ID: <DwS85N0KtcuFE7n5tHOg9C_nq1JSMg9qqpuhQn3mJhhTnLbvh6yHHxj8aqDzwHFNO9LnbHIQ-NsVevhxqUlHP1gL5iB-NpSdaLwt_s6ymGc=@wuille.net>

On Friday, August 21, 2020 1:50 AM, John Newbery via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Summary: We should change the proposal and implementation to use even tie-breakers everywhere.
>
> John #notoquadraticresiduetiebreakers Newbery

Thanks Nadav, Lloyd, John, and those who commented privately,

As the comments we've received have been unanimously in favor of changing, here is the PR for doing so: https://github.com/bitcoin/bips/pull/982

I'm very happy with this outcome, as it's indeed a significant reduction in the mental overhead needed for explaining the design decisions (the entire optimization section from the BIP can be removed, as those are no longer relevant to inform the decisions).

There is still some ongoing discussion about another change, namely permitting the use of messages that aren't exactly 32 bytes in length: https://github.com/sipa/bips/issues/207, but that would be a strict superset of what is permitted now, and have no impact on its use in BIP341/BIP342.

Cheers,

--
Pieter #thefinalfinalfinalbip340 Wuille
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200827/4f959652/attachment.html>

From michaelfolkson at gmail.com  Sat Aug 29 10:14:50 2020
From: michaelfolkson at gmail.com (Michael Folkson)
Date: Sat, 29 Aug 2020 11:14:50 +0100
Subject: [bitcoin-dev] Default Signet, Custom Signets and Resetting Testnet
Message-ID: <CAFvNmHQM5DB1paFZZ=uT3uY3hN6pOY=opfh92vS-HTka-uH3Yw@mail.gmail.com>

Hi all

Signet has been announced and discussed previously on the mailing list so I
won't repeat what Signet is and its motivation.

(For more background we recently had a Socratic Seminar with Kalle Alm and
AJ Towns on Signet. Transcript, reading list and video are available.)

https://diyhpl.us/wiki/transcripts/london-bitcoin-devs/2020-08-19-socratic-seminar-signet/

The first (of multiple) Signet PR 18267 in Bitcoin Core is at an advanced
stage of review and certainly additional code review and testing of that PR
is encouraged.

https://github.com/bitcoin/bitcoin/pull/18267

However there are some meta questions around Signet(s) that are best
discussed outside of the Bitcoin Core repo and it would be good to ensure
everyone's testing needs are being met. I will put forward my initial
thoughts on some of these questions. These thoughts seem to be aligned with
Kalle's and AJ's initial views but they have not reviewed this post and
they can chime in if they feel I am misrepresenting their perspectives.

1) Should there be one "default" Signet that we use for specific purpose(s)
or should we "let a thousand ships sail"?

To be clear there will be multiple custom Signets. Even if we wanted to
prevent them we couldn't. But is there an argument for having a "default"
Signet with a network effect? A Signet that a large proportion of the
community is drawn to using with tooling and support? I would say yes.
Especially if we see Signet as a staging ground for testing proposed soft
fork(s). Otherwise there will be lots of splintered Signet networks all
with different combinations of proposed soft forks enabled and no network
effect around a particular Signet. I think this would be bewildering for
say Taproot testers to have to choose between Person A's Signet with
Taproot enabled and Person B's Signet with Taproot enabled. For this to
work there would have to be a formal understanding of at what stage a
proposed soft fork should be enabled on "default" Signet. It would have to
be at a sufficiently mature stage (e.g. BIP number allocated, BIP drafted
and under review, PR open in Bitcoin Core repo under review etc) but early
enough so that it can be tested on Signet well in advance of being
considered for activation on mainnet. This does present challenges if soft
forks are enabled on Signet and then change/get updated. However there are
approaches that AJ in particular is working on to deal with this, one of
which I have described below.

https://bitcoin.stackexchange.com/questions/98642/can-we-experiment-on-signet-with-multiple-proposed-soft-forks-whilst-maintaining

2) Assuming there is a "default" Signet how many people and who should have
keys to sign each new "default" Signet block? If one of these keys is lost
or stolen should we reset Signet? Should we plan to reset "default" Signet
at regular intervals anyway (say every two years)?

Currently it is a 1-of-2 multisig with Kalle Alm and AJ Towns having keys.
It was suggested on IRC that there should be at least one additional key
present in the EU/US timezone so blocks can continue to be mined during an
Asia-Pacific outage. (Kalle and AJ are both in the Asia-Pacific region).
Kalle believes we should keep Signet running indefinitely unless we
encounter specific problems and personally I think this makes sense.

https://github.com/bitcoin/bitcoin/issues/19787#issuecomment-679160691

3) Kalle has also experienced concern from some in the community that
testnet will somehow be replaced by Signet. This is not the case. As long
as someone out there is mining testnet blocks testnet will continue.
However, there is the question of whether testnet needs to be reset. It was
last reset in 2012 and there are differing accounts on whether this is
presenting a problem for users of testnet. Assuming Signet is successful
there will be less testing on testnet but what testing use cases will still
prefer testnet? It has been argued that testnet should be a large chain to
stress test certain IBD, P2P scenarios in which case it may be the case
that we don't want to reset testnet. All other testing use cases would not
be impacted by the downsides of a large chain as they would gravitate
towards Signet regardless.

https://bitcoin.stackexchange.com/questions/98579/will-there-be-a-testnet4-or-do-we-not-need-a-testnet-reset-once-we-have-signet/

If you have thoughts, feedback, questions it would be great to hear them.
Certainly we should seek to make sure everybody's testing needs are being
considered.

There is a closed issue on the Bitcoin Core repo if you seek to review some
of the prior conversation. Ideally though we would have discussion that
isn't directly impacting Bitcoin Core here on the mailing list or on IRC
rather than in the Bitcoin Core repo.

https://github.com/bitcoin/bitcoin/issues/19787

Thanks
Michael

-- 
Michael Folkson
Email: michaelfolkson at gmail.com
Keybase: michaelfolkson
PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200829/852eb2b5/attachment.html>

From belcher at riseup.net  Sat Aug 29 22:03:09 2020
From: belcher at riseup.net (Chris Belcher)
Date: Sat, 29 Aug 2020 23:03:09 +0100
Subject: [bitcoin-dev] Detailed protocol design for routed
 multi-transaction CoinSwap
In-Reply-To: <CALZpt+GxKDEDAGUH3Jb3rcZdh_jy_depLRE5KzGTpkZOLVH+QA@mail.gmail.com>
References: <813e51a1-4252-08c0-d42d-5cef32f684bc@riseup.net>
 <CALZpt+GxKDEDAGUH3Jb3rcZdh_jy_depLRE5KzGTpkZOLVH+QA@mail.gmail.com>
Message-ID: <d08ddff2-f62a-661b-d9cf-2f84f7d3ea9e@riseup.net>

Hello Antoine,

Thanks for the very useful insights.

It seems having just one contract transaction which includes anchor
outputs in the style already used by Lightning is one way to fix both
these vulnerabilities.

For the first attack, the other side cannot burn the entire balance
because they only have access to the small amount of satoshi of the
anchor output, and to add miner fees they must add their own inputs. So
they'd burn their own coins to miner fees, not the coins in the contract.

For the second attack, the other side cannot do transaction pinning
because there is only one contract transaction, and all the protections
already developed for use with Lightning apply here as well, such as
CPFP carve out.


Another possible fix for both vulnerabilities is to separate the
timelock and hashlock cases into two separate transactions as described
by ZmnSCPxj in a recent email to this list. This comes at the cost of
breaking private key handover allowing coins to remain unspent indefinitely.

Another possible fix for the second attack, is to encumber the output
with a `1 OP_CSV` which stops that output being spent while unconfirmed.
This seems to be the simplest way if your aim is to only fix the second
attack.


These are all the possible fixes I can think of.

Regards
Chris

On 24/08/2020 20:30, Antoine Riard wrote:
> Hello Chris,
> 
> I think you might have vulnerability issues with the current design.
> 
> With regards to the fee model for contract transactions, AFAICT timely
> confirmation is a fund safety matter for an intermediate hop. Between the
> offchain preimage reveal phase and the offchain private key handover phase,
> the next hop can broadcast your outgoing contract transactions, thus
> forcing you to claim quickly backward as you can't assume previous hop will
> honestly cooperate to achieve the private key handover. This means that
> your range of pre-signed RBF-transactions must theoretically have for fee
> upper bound the maximum of the contested balance, as game-theory side, it's
> rational to you to burn your balance instead of letting your counterparty
> claim it after timelock expiration, in face of mempool congestion. Where
> the issue dwells is that this fee is pre-committed and not cancelled when
> the balance change of ownership by the outgoing hop learning the preimage
> of the haslock output. Thus the previous hop is free to broadcast the
> highest-fee RBF-transactions and burn your balance, as for him, his balance
> is now encoded in the output of the contract transactions on the previous
> link, for which he knows the preimage.
> 
> Note, I think this is independent of picking up either relative or absolute
> timelocks as what matters is the block delta between two links. Of course
> you can increase this delta to be week-lengthy and thus decrease the need
> for a compelling fee but a) you may force quickly close with contract
> transactions if the private key handover doesn't happen soon, you don't
> want to be caught by surprise by congestion so you would close far behind
> delta period expiration like half of it, and b) you increase the time-value
> of makers funds in case of faulty hop, thus logically increasing the maker
> fee and making the cost of the system higher in average. I guess a better
> solution would be to use dual-anchor outputs has spec'ed out by Lightning,
> it lets the party who has a balance at stake unilaterally increase feerate
> with a CPFP. The CPFP is obviously a higher blockchain cost but a) it's a
> safety mechanism for a worst-case scenario, 99% of the time they won't be
> committed, b) you might use this CPFP to aggregate change outputs or other
> opportunistically side-usage.
> 
> With regards to the preimage release phase, I think you might have a
> pinning scenario. The victim would be an intermediate hop, targeted by a
> malicious taker. The preimage isn't revealed offchain to this victim hop. A
> low-feerate version of the outgoing contract transaction is broadcast and
> not going to confirm, assuming a bit of congestion. As preimage is known,
> the malicious taker can directly attach a high-fee, low-feerate child
> transaction and thus prevent any replacement of the pinned parent by a
> honest broadcast of a high-fee RBF-transaction under BIP 125 rules. At the
> same time, the malicious taker broadcasts the contract tx on the previous
> link and gets it confirmed. At relative timelock expiration, malicious
> taker claims back the funds. When the pinned transaction spending the
> outgoing link gets evicted (either by replacing child by a higher feerate
> or waiting for mempool expiration after 2 weeks), taker gets it confirmed
> this time and claims output through hashlock. Given the relative timelock
> blocking the victim, there is not even a race.
> 
> I guess restraining the contract transaction to one and only one version
> would overcome this attack. A honest intermediate hop, as soon as seeing a
> relative timelock triggered backward would immediately broadcast the
> outgoing link contract tx or if it's already in network mempools broadcast
> a higher-feerate child. As you don't have valid multiple contract
> transactions, an attacker can't obstruct you to propagate the correct
> child, as you are not blind about the parent txid.
> 
> Lastly, one downside of using relative timelocks, in case of one downstream
> link failure, it forces every other upstream hops to go onchain to protect
> against this kind of pinning scenario. And this would be a privacy
> breakdown, as a maker would be able to provoke one, thus constraining every
> upstream hops to go onchain with the same hash and revealing the CoinSwap
> route.
> 
> Let me know if I reviewed the correct transactions circuit model or
> misunderstood associated semantic. I might be completely wrong, coming from
> a LN perspective.
> 
> Cheers,
> Antoine
> 
> Le mar. 11 ao?t 2020 ? 13:06, Chris Belcher via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> a ?crit :
> 
>> I'm currently working on implementing CoinSwap (see my other email
>> "Design for a CoinSwap implementation for massively improving Bitcoin
>> privacy and fungibility").
>>
>> CoinSwaps are special because they look just like regular bitcoin
>> transactions, so they improve the privacy even for people who do not use
>> them. Once CoinSwap is deployed, anyone attempting surveillance of
>> bitcoin transactions will be forced to ask themselves the question: how
>> do we know this transaction wasn't a CoinSwap?
>>
>> This email contains a detailed design of the first protocol version. It
>> makes use of the building blocks of multi-transaction CoinSwaps, routed
>> CoinSwaps, liquidity market, private key handover, and fidelity bonds.
>> It does not include PayJoin-with-CoinSwap, but that's in the plan to be
>> added later.
>>
>> == Routed CoinSwap ==
>>
>> Diagram of CoinSwaps in the route:
>>
>>     Alice ====> Bob ====> Charlie ====> Alice
>>
>> Where (====>) means one CoinSwap. Alice gives coins to Bob, who gives
>> coins to Charlie, who gives coins to Alice. Alice is the market taker
>> and she starts with the hash preimage. She chooses the CoinSwap amount
>> and chooses who the makers will be.
>>
>> This design has one market taker and two market makers in its route, but
>> it can easily be extended to any number of makers.
>>
>> == Multiple transactions ==
>>
>> Each single CoinSwap is made up of multiple transactions to avoid amount
>> correlation
>>
>>           (a0 BTC) --->     (b0 BTC) --->         (c0 BTC) --->
>>     Alice (a1 BTC) ---> Bob (b1 BTC) ---> Charlie (c1 BTC) ---> Alice
>>           (a2 BTC) --->     (b2 BTC) --->         (c2 BTC) --->
>>
>> The arrow (--->) represent funding transactions. The money gets paid to
>> a 2-of-2 multisig but after the CoinSwap protocol and private key
>> handover is done they will be controlled by the next party in the route.
>>
>> This example has 6 regular-sized transactions which use approximately
>> the same amount of block space as a single JoinMarket coinjoin with 6
>> parties (1 taker, 5 makers). Yet the privacy provided by this one
>> CoinSwap would be far far greater. It would not have to be repeated in
>> the way that Equal-Output CoinJoins must be.
>>
>> == Direct connections to Alice ===
>>
>> Only Alice, the taker, knows the entire route, Bob and Charlie just know
>> their previous and next transactions. Bob and Charlie do not have direct
>> connections with each other, only with Alice.
>>
>> Diagram of Tor connections:
>>
>>     Bob      Charlie
>>      |       /
>>      |      /
>>      |     /
>>       Alice
>>
>> When Bob and Charlie communicate, they are actually sending and
>> receiving messages via Alice who relays them to Charlie or Bob. This
>> helps hide whether the previous or next counterparty in a CoinSwap route
>> is a maker or taker.
>>
>> This doesn't have security issues even in the final steps where private
>> keys are handed over, because those private keys are always for 2-of-2
>> multisig and so on their own are never enough to steal money.
>>
>>
>> === Miner fees ===
>>
>> Makers have no incentive to pay any miner fees. They only do
>> transactions which earn them an income and are willing to wait a very
>> long time for that to happen. By contrast takers want to create
>> transactions far more urgently. In JoinMarket we coded a protocol where
>> the maker could contribute to miner fees, but the market price offered
>> of that trended towards zero. So the reality is that takers will pay all
>> the miner fees. Also because makers don't know the taker's time
>> preference they don't know how much they should pay in miner fees.
>>
>> The taker will have to set limits on how large the maker's transactions
>> are, otherwise makers could abuse this by having the taker consolidate
>> maker's UTXOs for free.
>>
>> == Funding transaction definitions ==
>>
>> Funding transactions are those which pay into the 2-of-2 multisig
>> addresses.
>>
>> Definitions:
>> I = initial coinswap amount sent by Alice = a0 + a1 + a2
>> (WA, WB, WC) = Total value of UTXOs being spent by Alice, Bob, Charlie
>>                respectively. Could be called "wallet Alice", "wallet
>>                Bob", etc
>> (B, C) = Coinswap fees paid by Alice and earned by Bob and Charlie.
>> (M1, M2, M3) = Miner fees of the first, second, third, etc sets of
>>                funding transactions. Alice will choose what these are
>>                since she's paying.
>> multisig(A+B) = A 2of2 multisig output with private keys held by A and B
>>
>> The value in square parentheses refers to the bitcoin amount.
>>
>> Alice funding txes
>>   [WA btc] ---> multisig (Alice+Bob) [I btc]
>>                 change [WA-M1-I btc]
>> Bob funding txes
>>   [WB btc] ---> multisig (Bob+Charlie) [I-M2-B btc]
>>                 change [WB-I+B btc]
>> Charlie funding txes
>>   [WC btc] ---> multisig (Charlie+Alice) [(I-M2-B)-M3-C btc]
>>                 change [WC-(I-M2-B)+C btc]
>>
>> Here we've drawn these transactions as single transactions, but they are
>> actually multiple transactions where the outputs add up some value (e.g.
>> add up to I in Alice's transactions.)
>>
>> === Table of balances before and after a successful CoinSwap ===
>>
>> If a CoinSwap is successful then all the multisig outputs in the funding
>> transactions will become controlled unilaterally by one party. We can
>> calculate how the balances of each party change.
>>
>> Party   | Before | After
>> --------|--------|-------------------------------------------
>> Alice   | WA     | WA-M1-I + (I-M2-B)-M3-C  = WA-M1-M2-M3-B-C
>> Bob     | WB     | WB-I+B + I               = WB+B
>> Charlie | WC     | WC-(I-M2-B)+C + I-M2-B   = WC+C
>>
>> After a successful coinswap, we see Alice's balance goes down by the
>> miner fees and the coinswap fees. Bob's and Charlie's balance goes up by
>> their coinswap fees.
>>
>> == Contract transaction definitions ==
>>
>> Contract transactions are those which may spend from the 2-of-2 multisig
>> outputs, they transfer the coins into a contract where the coins can be
>> spent either by waiting for a timeout or providing a hash preimage
>> value. Ideally contract transactions will never be broadcast but their
>> existence keeps all parties honest.
>>
>> M~ is miner fees, which we treat as a random variable, and ultimately
>> set by whichever pre-signed RBF tx get mined. When we talk about _the_
>> contract tx, we actually mean perhaps 20-30 transactions which only
>> differ by the miner fee and have RBF enabled, so they can be broadcasted
>> in sequence to get the contract transaction mined regardless of the
>> demand for block space.
>>
>> (Alice+timelock_A OR Bob+hash) = Is an output which can be spent
>>                                  either with Alice's private key
>>                                  after waiting for a relative
>>                                  timelock_A, or by Bob's private key by
>>                                  revealing a hash preimage value
>>
>> Alice contract tx:
>>     multisig (Alice+Bob) ---> (Alice+timelock_A OR Bob+hash)
>>     [I btc]                   [I-M~ btc]
>> Bob contract tx:
>>     multisig (Bob+Charlie) ---> (Bob+timelock_B OR Charlie+hash)
>>     [I-M2-B btc]                [I-M2-B-M~ btc]
>> Charlie contract tx:
>>     multisig (Charlie+Alice)  ---> (Charlie+timelock_C OR Alice+hash)
>>     [(I-M2-B)-M3-C btc]            [(I-M2-B)-M3-C-M~ btc]
>>
>>
>> === Table of balances before/after CoinSwap using contracts transactions
>> ===
>>
>> In this case the parties had to get their money back by broadcasting and
>> mining the contract transactions and waiting for timeouts.
>>
>> Party   | Before | After
>> --------|--------|--------------------------------------------
>> Alice   | WA     | WA-M1-I + I-M~                   = WA-M1-M~
>> Bob     | WB     | WB-I+B + I-M2-B-M~               = WB-M2-M~
>> Charlie | WC     | WC-(I-M2-B)+C + (I-M2-B)-M3-C-M~ = WC-M3-M~
>>
>> In the timeout failure case, every party pays for their own miner fees.
>> And nobody earns or spends any coinswap fees. So even for a market maker
>> its possible for their wallet balance to go down sometimes, although as
>> we shall see there are anti-DOS features which make this unlikely to
>> happen often.
>>
>> A possible attack by a malicious Alice is that she chooses M1 to be very
>> low (e.g. 1 sat/vbyte) and sets M2 and M3 to be very high (e.g. 1000
>> sat/vb) and then intentionally aborts, forcing the makers to lose much
>> more money in miner fees than the attacker. The attack can be used to
>> waste away Bob's and Charlie's coins on miner fees at little cost to the
>> malicious taker Alice. So to defend against this attack Bob and Charlie
>> must refuse to sign a contract transaction if the corresponding funding
>> transaction pays miner fees greater than Alice's funding transaction.
>>
>>
>> There can also be a failure case where each party gets their money using
>> hash preimage values instead of timeouts. Note that each party has to
>> sweep the output before the timeout expires, so that will cost an
>> additional miner fee M~.
>>
>> Party   | Before | After
>> --------|--------|------------------------------------------------------
>> Alice   | WA     | WA-M1-I + (I-M2-B)-M3-C-M~ - M~ = WA-M1-M2-M3-B-C-2M~
>> Bob     | WB     | WB-I+B + I-M~ - M~              = WB+B-2M~
>> Charlie | WC     | WC-(I-M2-B)+C + I-M2-B-M~ - M~  = WC+C-2M~
>>
>> In this situation the makers Bob and Charlie earn their CoinSwap fees,
>> but they pay an additional miner fee twice. Alice pays for all the
>> funding transaction miner fees, and the CoinSwap fees, and two
>> additional miner fees. And she had her privacy damaged because the
>> entire world saw on the blockchain the contract script.
>>
>> Using the timelock path is like a refund, everyone's coin just comes
>> back to them. Using the preimage is like the CoinSwap transaction
>> happened, with the coins being sent ahead one hop. Again note that if
>> the preimage is used then coinswap fees are paid.
>>
>> === Staggered timelocks ===
>>
>> The timelocks are staggered so that if Alice uses the preimage to take
>> coins then the right people will also learn the preimage and have enough
>> time to be able to get their coins back too. Alice starts with knowledge
>> of the hash preimage so she must have a longest timelock.
>>
>> == EC tweak to reduce one round trip ==
>>
>> When two parties are agreeing on a 2-of-2 multisig address, they need to
>> agree on their public keys. We can avoid one round trip by using the EC
>> tweak trick.
>>
>> When Alice, the taker, downloads the entire offer book for the liquidity
>> market, the offers will also contain a EC public key. Alice can tweak
>> this to generate a brand new public key for which the maker knows the
>> private key. This public key will be one of the keys in the 2-of-2
>> multisig. This feature removes one round trip from the protocol.
>>
>>     q = EC privkey generated by maker
>>     Q = q.G = EC pubkey published by maker
>>
>>     p = nonce generated by taker
>>     P = p.G = nonce point calculated by taker
>>
>>     R = Q + P = pubkey used in bitcoin transaction
>>       = (q + p).G
>>
>> Taker sends unsigned transaction which pays to multisig using pubkey Q,
>> and also sends nonce p. The maker can use nonce p to calculate (q + p)
>> which is the private key of pubkey R.
>>
>> Taker doesnt know the privkey because they are unable to find q because
>> of the ECDLP.
>>
>> Any eavesdropper can see the nonce p and easily calculate the point R
>> too but Tor communication is encrypted so this isnt a concern.
>>
>> None of the makers in the route know each other's Q values, so Alice the
>> taker will generate a nonce p on their behalf and send it over. I
>> believe this cant be used for any kind of attack, because the signing
>> maker will always check that the nonce results in the public key
>> included in the transaction they're signing, and they'll never sign a
>> transaction not in their interests.
>>
>>
>> == Protocol ==
>>
>> This section is the most important part of this document.
>>
>> Definitions:
>> fund = all funding txes (remember in this multi-tx protocol there can be
>>        multiple txes which together make up the funding)
>> A htlc = all htlc contract txes (fully signed) belonging to party A
>> A unsign htcl = all unsigned htlc contract txes belonging to party A
>>                 including the nonce point p used to calculate the
>>                 maker's pubkey.
>> p = nonce point p used in the tweak EC protocol for calculating the
>>     maker's pubkey
>> A htlc B/2 = Bob's signature for the 2of2 multisig of the Alice htlc
>>              contract tx
>> privA(A+B) = private key generated by Alice in the output
>>              multisig (Alice+Bob)
>>
>>
>>  | Alice           | Bob             | Charlie         |
>>  |=================|=================|=================|
>> 0. A unsign htlc ---->               |                 |
>> 1.               <---- A htlc B/2    |                 |
>> 2. ***** BROADCAST AND MINE ALICE FUNDING TXES ******  |
>> 3. A fund+htlc+p ---->               |                 |
>> 4.                 | B unsign htlc ---->               |
>> 5.                 |               <---- B htlc C/2    |
>> 6. ******* BROADCAST AND MINE BOB FUNDING TXES ******* |
>> 7.                 | B fund+htlc+p ---->               |
>> 8.               <---------------------- C unsign htlc |
>> 9.    C htlc A/2 ---------------------->               |
>> A. ***** BROADCAST AND MINE CHARLIE FUNDING TXES ***** |
>> B.               <---------------------- C fund+htlc+p |
>> C. hash preimage ---------------------->               |
>> D. hash preimage ---->               |                 |
>> E.    privA(A+B) ---->               |                 |
>> F.                 |    privB(B+C) ---->               |
>> G.               <---------------------- privC(C+A)    |
>>
>> == Protocol notes ==
>> 0-2 are the steps which setup Alice's funding tx and her contract tx for
>>     possible refund
>> 4-5 same as 0-2 but for Bob
>> 8-9 same as 0-2 but for Charlie
>> 3,7 is proof to the next party that the previous party has already
>>     committed miner fees to getting a transaction mined, and therefore
>>     this isnt a DOS attack. The step also reveals the fully-signed
>>     contract transaction which the party can use to get their money back
>>     with a preimage.
>> C-G is revealing the hash preimage to all, and handing over the private
>>     keys
>>
>>
>> == Analysis of aborts ==
>>
>> We will now discuss aborts, which happen when one party halts the
>> protocol and doesnt continue. Perhaps they had a power cut, their
>> internet broke, or they're a malicious attacker wanting to waste time
>> and money. The other party may try to reestablish a connection for some
>> time, but eventually must give up.
>>
>> Number refers to the step number where the abort happened
>> e.g. step 1 means that the party aborted instead of the action happening
>> on protocol step 1.
>>
>> The party name refers to what that party does
>> e.g. Party1: aborts, Party2/Party3: does a thing in reaction
>>
>> 0. Alice: aborts. Bob/Charlie: do nothing, they havent lost any time or
>>    money
>> 1. Bob: aborts. Alice: lost no time or money, try with another Bob.
>>    Charlie: do nothing
>> 2-3. same as 0.
>> 4. Bob: aborts. Charlie: do nothing. Alice: broadcasts her contract tx
>>    and waits for the timeout, loses time and money on miner fees, she'll
>>    never coinswap with Bob's fidelity bond again.
>> 5. Charlie: aborts. Alice/Bob: lose nothing, find another Charlie to
>>    coinswap with.
>> 6. same as 4.
>> 7. similar to 4 but Alice MIGHT not blacklist Bob's fidelity bond,
>>    because Bob will also have to broadcast his contract tx and will also
>>    lose time and money.
>> 8. Charlie: aborts. Bob: broadcast his contract transaction and wait for
>>    the timeout to get his money back, also broadcast Alice's contract
>>    transaction in retaliation. Alice: waits for the timeout on her htlc
>>    tx that Bob broadcasted, will never do a coinswap with Charlie's
>>    fidelity bond again.
>> 9. Alice: aborts. Charlie: do nothing, no money or time lost. Bob:
>>    broadcast bob contract tx and wait for timeout to get money back,
>>    comforted by the knowledge that when Alice comes back online she'll
>>    have to do the same thing and waste the same amount of time and
>>    money.
>> A-B. same as 8.
>> C-E. Alice: aborts. Bob/Charlie: all broadcast their contract txes and
>>      wait for the timeout to get their money back, or if Charlie knows
>>      the preimage he uses it to get the money immediately, which Bob can
>>      read from the blockchain and also use.
>> F. Bob: aborts. Alice: broadcast Charlie htlc tx and use preimage to get
>>    money immediately, Alice blacklists Bob's fidelity bond. Charlie:
>>    broadcast Bob htlc and use preimage to get money immediately.
>> G. Charlie: aborts. Alice: broadcast Charlie htlc and use preimage to
>>    get money immediately, Alice blacklists Charlie's fidelity bond. Bob:
>>    does nothing, already has his privkey.
>>
>> ==== Retaliation as DOS-resistance ====
>>
>> In some situations (e.g. step 8.) if one maker in the coinswap route is
>> the victim of a DOS they will retaliate by DOSing the previous maker in
>> the route. This may seem unnecessary and unfair (after all why waste
>> even more time and block space) but is actually the best way to resist
>> DOS because it produces a concrete cost every time a DOS happens.
>>
>>
>> == Analysis of deviations ==
>>
>> This section discusses what happens if one party deviates from the
>> protocol by doing something else, for example broadcasting a htlc
>> contract tx when they shouldnt have.
>>
>> The party name refers to what that party does, followed by other party's
>> reactions to it.
>> e.g. Party1: does a thing, Party2/Party3: does a thing in reaction
>>
>> If multiple deviations are possible in a step then they are numbered
>> e.g. A1 A2 A2 etc
>>
>>
>> 0-2. Alice/Bob/Charlie: nothing else is possible except following the
>>      protocol or aborting
>> 3. Alice: broadcasts one or more of the A htlc txes. Bob/Charlie/Dennis:
>>    do nothing, they havent lost any time or money.
>> 4-6. Bob/Charlie: nothing else is possible except following the protocol
>>      or aborting.
>> 7. Bob: broadcasts one or more of the B htlc txes, Alice: broadcasts all
>>    her own A htlc txes and waits for the timeout to get her money back.
>>    Charlie: do nothing
>> 8. Charlie: nothing else is possible except following the protocol or
>>    aborting.
>> 9. Alice: broadcasts one or more of the A htlc txes. Bob: broadcasts all
>>    his own A htlc txes and waits for the timeout.
>> A. same as 8.
>> B. Charlie: broadcasts one or more of the C htlc txes, Alice/Bob:
>>    broadcasts all their own htlc txes and waits for the timeout to get
>>    their money back.
>> C-E1. Alice: broadcasts all of C htlc txes and uses her knowledge of the
>>       preimage hash to take the money immediately. Charlie: broadcasts
>>       all of B htlc txes and reading the hash value from the blockchain,
>>       uses it to take the money from B htlc immediately. Bob: broadcasts
>>       all of A htlc txes, and reading hash from the blockchain, uses it
>>       to take the money from A htlc immediately.
>> C-E2. Alice: broadcast her own A htlc txes, and after a timeout take the
>>       money. Bob: broadcast his own B htlc txes and after the timeout
>>       take their money. Charlie: broadcast his own C htlc txes and after
>>       the timeout take their money.
>> F1. Bob: broadcast one or more of A htcl txes and use the hash preimage
>>     to get the money immediately. He already knows both privkeys of the
>>     multisig so this is pointless and just damages privacy and wastes
>>     miner fees. Alice: blacklist Bob's fidelity bond.
>> F2. Bob: broadcast one or more of the C htlc txes. Charlie: use preimage
>>     to get his money immediately. Bob's actions were pointless. Alice:
>>     cant tell whether Bob or Charlie actually broadcasted, so blacklist
>>     both fidelity bonds.
>> G1. Charlie: broadcast one or more of B htcl txes and use the hash
>>     preimage to get the money immediately. He already knows both
>>     privkeys of the multisig so this is pointless and just damages
>>     privacy and wastes miner fees. Alice: cant tell whether Bob or
>>     Charlie actually broadcasted, so blacklist both fidelity bonds.
>> G2. Charlie: broadcast one or more of the A htlc txes. Alice: broadcast
>>     the remaining A htlc txes and use preimage to get her money
>>     immediately. Charlies's actions were pointless. Alice: blacklist
>>     Charlie's fidelity bond.
>>
>> The multisig outputs of the funding transactions can stay unspent
>> indefinitely. However the parties must always be watching the network
>> and ready to respond with their own sweep using a preimage. This is
>> because the other party still possesses a fully-signed contract tx. The
>> parties respond in the same way as in steps C-E1, F2 and G2. Alice's
>> reaction of blacklisting both fidelity bonds might not be the right way,
>> because one maker could use it to get another one blacklisted (as well
>> as themselves).
>>
>>
>> == Conclusion ==
>>
>> This document describes the first version of the protocol which
>> implements multi-transaction Coinswap, routed Coinswap, fidelity bonds,
>> a liquidity market and private key handover. I describe the protocol and
>> also analyze aborts of the protocols and deviations from the protocol.
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
> 

From ZmnSCPxj at protonmail.com  Sun Aug 30 13:38:11 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sun, 30 Aug 2020 13:38:11 +0000
Subject: [bitcoin-dev] Detailed protocol design for routed
	multi-transaction CoinSwap
In-Reply-To: <d08ddff2-f62a-661b-d9cf-2f84f7d3ea9e@riseup.net>
References: <813e51a1-4252-08c0-d42d-5cef32f684bc@riseup.net>
 <CALZpt+GxKDEDAGUH3Jb3rcZdh_jy_depLRE5KzGTpkZOLVH+QA@mail.gmail.com>
 <d08ddff2-f62a-661b-d9cf-2f84f7d3ea9e@riseup.net>
Message-ID: <JbGkYGhmwBZZEvZHPzR67vmY7O2-qaNKhV0aD5EC0lfqm8dHzBNS9xz8-WgJ3O2mTjVoKB4Z-IgLGApROnn3fS-NHXwyEruB3_5z2dSJmZI=@protonmail.com>

Good morning Chris,

> It seems having just one contract transaction which includes anchor
> outputs in the style already used by Lightning is one way to fix both
> these vulnerabilities.
>
> For the first attack, the other side cannot burn the entire balance
> because they only have access to the small amount of satoshi of the
> anchor output, and to add miner fees they must add their own inputs. So
> they'd burn their own coins to miner fees, not the coins in the contract.

Minimum output size is 547 sats, so anchor outputs are that amount at minimum.
A P2SH-P2WPKH output costs something like ~130 vbytes to spend, at 1.000 sat/vbyte that is only ~130 sats to spend a 547 sat anchor output, an opportunistic camper could collect from a few swaps it would have done anyway (e.g. as a passive popular maker?) and broadcast the contract txes of those swaps and then spend the anchor outputs together to get a few sats in a not-so-dusty UTXO, getting (547 - 130) sat per input minus the cost of creating a new tiny output.
Assuming the camper has already claimed its side of the swap in order to put it in cold, this is basically a tiny but free amount of extra money, and if small CoinJoins in JoinMarket are any indication, the 547 sats minus fee to spend it minus fee to create (amortized among the multiple contract txes) new UTXO might be comparable to the actual maker fee.

Since this camping attack is done after the CoinSwap, the maker fidelity bond is a weak protection against this.
The maker can keep around contract transactions indefinitely, and if standard wallets assume they can leave the coins in the same UTXO indefinitely, the contract transactions remain valid indefinitely, including up to fidelity bond timeout.
When the fidelity bond times out, the maker has to destroy its identity anyway, so it could opportunistically wait for a low-fee period after fidelity-bond timeout (we currently get low fee periods once a week, for example, so the camper can wait for at most a week to do this) to publish all still-valid contract transactions, and spend all the anchor outputs including the fidelity bond at the minimum feerate, getting a slightly larger fidelity bond fund, then CoinSwap it to honest makers to clean it, then make a new fidelity bond.
And if one of the takers happens to not be watching for contract tx timeout, it can potentially get free money, again, from the inattention.

(I call it a "camper attack" since the attacking CoinSwap participant waits around in a single place (maker fidelity bond) and snipes passing contract transactions to extract value from them when opportunity (low fee rate) is good, like a camper.)

To protect against this, we should force contract txes to signal RBF, make contract txes min-relay=feerate (requires CPFP package relay at base layer tho), and during low-fee periods we should collect outputs whose private key have been turned over to us, paying at a feerate slightly higher than 547 sat / 130 vbyte fee rate (at which point it becomes uneconomical for campers to mount their sniping attack as they would lose the anchor output amount to fees anyway).

In fact the wallet can do that all the time, and if prevailing fees are above the 547 / 130 rate it will not confirm and the wallet that wants to spend its funds *now* can sign a new RBF tx at higher feerate to replace it.

Low fees, who would have thought that would enable an attack vector....

Regards,
ZmnSCPxj

