From cserveny.tamas+bc at gmail.com  Fri Sep  1 12:47:08 2017
From: cserveny.tamas+bc at gmail.com (Cserveny Tamas)
Date: Fri, 01 Sep 2017 12:47:08 +0000
Subject: [bitcoin-dev] Horizontal scaling of blockchain
Message-ID: <CACY+MSO8PM89VTtKfuZiQGvAs7a7R6_4mY+onhZh9KnvwxW2uw@mail.gmail.com>

Hi,

I was thinking about how to scale the block-chain.

The fundamental problem is that if the miners add capacity it will only
increase (protect) their share of block reward, but does not increase the
speed of transactions. This will only raise the fee in the long run with
the block reward decreasing.
The throughput is limited by the block size and the complexity. Changing
any of variables in the above equation was raised already many times and
there was no consensus on them.

The current chain is effectively single threaded. If we look around in the
sw industry how single threaded applications could be scaled, one viable
option emerge: horizontal scaling. This is an option if the problem can be
partitioned, and transactions in partitions could be processed alongside.
Number of partitions would be start with a fairly low number, something
between 2-10, but nothing is against setting it to a higher number later on
according to a schedule.

Partitioning key alternatives:
*Ordering on inputs:*

1) In this case transactions would need to be mined per input address
partition.
2) TX have inputs in partition 1 and 2, then needs a confirmation in both
partitions.
3) All partitioned chains have the same longest valid approach.
4) Only one chain needed to be considered for double spending, others are
invalid in case they contain that input.

This opens up questions like:
- how the fee will be shared? Fees per partition?
- Ensure a good hash function which spreads evenly, because the inputs
cannot be manipulated for load balancing
- What to do about half mined transactions (Maybe they should be two
transactions and then there is less effect about it, but payment won't be
atomic in both partitions)

*Ordering on transaction ids:*

1) Transactions would be partitioned by their TX-id. Maybe a field allowing
txid-s to match a given partition.
2) Creating blocks like this parallel would be safe for bonefide
transactions. A block will be created each 10 mins.
3) In order to get malicious/doublespent transactions out of the system
another layer must be introduced.
- This layer would be used to merge the parallel blocks. It would have to
refer all previous blocks considered for unspent inputs.
- Most of the blocks will merge just fine as normally block 1 and block 2
would not contain double spending. (of course malicious double spending
will revert speed to current levels, because the miner might have to drop a
block in the partition because it contains a spent input on another
stronger branch)
- The standard longest chain wins strategy would be used for validity on
the meta level
- Meta does not require mining, a branches can be added and they are valid
unless there are double spent inputs inside. Block inside this meta already
"paid for".

Generally both ways would have an effect on the block reward and
complexity, which is needs to be adjusted. (not to create more BTC at the
end, reduced hashing power on partitions.)
I think complexity is not an issue, the important thing is that we tune it
to 10mins / block rate per partition.

Activation could be done by creating the infrastructure first and using
only one partitions only, which is effectively the same as today. Then
activate partitions on a certain block according to a schedule. From that
block, partition enforcement will be active and the transactions will be
sorted to the right partition / chain.

It is easy to make new partitions, just need to activate them on branch
block number.
Closing partitions is a bit more complex in case of TX partitioned
transactions, but managed by the meta layer and activated at a certain
partition block. Maybe it is not even possible in case of input partitions.

I could imagine that it is too big change. Many cons and pros on partition
keys.

What is your opinion about it?

Cheers,

Tamas
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170901/ce983641/attachment-0001.html>

From omarshib at gmail.com  Fri Sep  1 07:16:41 2017
From: omarshib at gmail.com (Omar Shibli)
Date: Fri, 1 Sep 2017 10:16:41 +0300
Subject: [bitcoin-dev] BIP proposal, Pay to Contract BIP43 Application
In-Reply-To: <CAE3EOfh+mEB6P0ZO7AVs-i92Y1Fyppj+zNHGF4MbCohFCyZaSg@mail.gmail.com>
References: <CAE3EOfgJdrO29GCftwORcq0087X0Y74gYtuMWvO1EWEkrT-7rg@mail.gmail.com>
	<CAAS2fgSbK=Hf7nViHScLezCAUdKkFT1MxEM4VZhZxoj990O8PQ@mail.gmail.com>
	<CAE3EOfh+mEB6P0ZO7AVs-i92Y1Fyppj+zNHGF4MbCohFCyZaSg@mail.gmail.com>
Message-ID: <CAE3EOfgSEveQQesGLDAAwOgHn8+sjkzc1ayvv7ieRS19k=d63A@mail.gmail.com>

Hello Gregory,

Thanks for you feedback.

The BIP has been updated to explicitly specify the multiparty key
derivation scheme which hopefully addresses your concerns.

Please have a look at the updated draft of the BIP at the link below:

https://github.com/commerceblock/pay-to-contract-protocol-specification/blob/master/bip-draft.mediawiki

Any feedback is highly appreciated.

Regards,
Omar

On Tue, Aug 15, 2017 at 7:40 PM, omar shibli <omarshib at gmail.com> wrote:

> Thank you for your time Gregory, I really appreciate that.
>
> What we are describing here is a method to embed cryptographic signatures
> into a public key based on HD Wallets - BIP32.
> In a practical application, we should have two cryptographic signatures
> from both sides, I don't think in that case your scenario would be an issue.
>
> More specifically in our application, we do the following construction:
>
> contract base: m/200'/0'/<contract_number>'
> payment base (merchant commitment): contract_base/<merchant_
> contract_signature>
> payment address (customer commitment): contract_base/<merchant_
> contract_signature>/<customer_contract_signature>
>
> payment address funds could be reclaimed only if the
> customer_contract_signature is provided by the customer.
>
> In terms of durability, our app is pretty simple at this point, we don't
> store anything, we let customer download and manage the files.
>
> I will update the BIP to address your concerns.
>
> On Tue, Aug 15, 2017 at 8:12 AM, Gregory Maxwell <greg at xiph.org> wrote:
>
>> This construction appears to me to be completely insecure.
>>
>>
>> Say my pubkey (the result of the derivation path) is P.
>>
>> We agree to contract C1.   A payment is made to P + G*H(C1).
>>
>> But in secret, I constructed contract C2 and pubkey Q and set P = Q +
>> G*H(C2).
>>
>> Now I can take that payment (paid to Q + G*(C1) + G*H(C2)) and assert
>> it was in act a payment to P' + G*H(C2).   (P' is simply Q + G*H(C1))
>>
>> I don't see anything in the proposal that addresses this. Am I missing it?
>>
>> The applications are also not clear to me, and it doesn't appear to
>> address durability issues (how do you avoid losing your funds if you
>> lose the exact contract?).
>>
>>
>>
>>
>> On Mon, Aug 14, 2017 at 6:05 AM, omar shibli via bitcoin-dev
>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> > Hey all,
>> >
>> > A lot of us familiar with the pay to contract protocol, and how it uses
>> > cleverly the homomorphic property of elliptic curve encryption system to
>> > achieve it.
>> > Unfortunately, there is no standard specification on how to conduct such
>> > transactions in the cyberspace.
>> >
>> > We have developed a basic trade finance application that relies on the
>> > original idea described in the Homomorphic Payment Addresses and the
>> > Pay-to-Contract Protocol paper, yet we have generalized it and made it
>> BIP43
>> > complaint.
>> >
>> > We would like to share our method, and get your feedback about it,
>> hopefully
>> > this effort will result into a standard for the benefit of the
>> community.
>> >
>> > Abstract idea:
>> >
>> > We define the following levels in BIP32 path.
>> > m / purpose' / coin_type' / contract_id' / *
>> >
>> > contract_id is is an arbitrary number within the valid range of indices.
>> >
>> > Then we define, contract base as following prefix:
>> > m / purpose' / coin_type' / contract_id'
>> >
>> > contract commitment address is computed as follows:
>> > hash document using cryptographic hash function of your choice (e.g.
>> blake2)
>> > map hash to partial derivation path
>> > Convert hash to binary array.
>> > Partition the array into parts, each part length should be 16.
>> > Convert each part to integer in decimal format.
>> > Convert each integer to string.
>> > Join all strings with slash `/`.
>> > compute child public key by chaining the derivation path from step 2
>> with
>> > contract base:
>> > m/<contract_base>/<hash_derivation_path>
>> > compute address
>> > Example:
>> >
>> > master private extended key:
>> > xprv9s21ZrQH143K2JF8RafpqtKiTbsbaxEeUaMnNHsm5o6wCW3z8ySyH4Ux
>> FVSfZ8n7ESu7fgir8imbZKLYVBxFPND1pniTZ81vKfd45EHKX73
>> > coin type: 0
>> > contract id: 7777777
>> >
>> > contract base computation :
>> >
>> > derivation path:
>> > m/999'/0'/7777777'
>> > contract base public extended key:
>> > xpub6CMCS9rY5GKdkWWyoeXEbmJmxGgDcbihofyARxucufdw7k3oc1JNnnii
>> D5H2HynKBwhaem4KnPTue6s9R2tcroqkHv7vpLFBgbKRDwM5WEE
>> >
>> > Contract content:
>> > foo
>> >
>> > Contract sha256 signature:
>> > 2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae
>> >
>> > Contract partial derivation path:
>> > 11302/46187/26879/50831/63899/17724/7472/16692/4930/11632/25
>> 731/49056/63882/24200/25190/59310
>> >
>> > Contract commitment pub key path:
>> > m/999'/0'/7777777'/11302/46187/26879/50831/63899/17724/7472/
>> 16692/4930/11632/25731/49056/63882/24200/25190/59310
>> > or
>> > <contract_base_extended_pub_key>/11302/46187/26879/50831/638
>> 99/17724/7472/16692/4930/11632/25731/49056/63882/24200/25190/59310
>> >
>> > Contract commitment pub key:
>> > xpub6iQVNpbZxdf9QJC8mGmz7cd3Cswt2itcQofZbKmyka5jdvQKQCqYSDFj
>> 8KCmRm4GBvcQW8gaFmDGAfDyz887msEGqxb6Pz4YUdEH8gFuaiS
>> >
>> > Contract commitment address:
>> > 17yTyx1gXPPkEUN1Q6Tg3gPFTK4dhvmM5R
>> >
>> >
>> > You can find the full BIP draft in the following link:
>> > https://github.com/commerceblock/pay-to-contract-protocol-
>> specification/blob/master/bip-draft.mediawiki
>> >
>> >
>> > Regards,
>> > Omar
>> >
>> > _______________________________________________
>> > bitcoin-dev mailing list
>> > bitcoin-dev at lists.linuxfoundation.org
>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> >
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170901/94a90deb/attachment.html>

From tomz at freedommail.ch  Fri Sep  1 13:12:18 2017
From: tomz at freedommail.ch (Tom Zander)
Date: Fri, 01 Sep 2017 15:12:18 +0200
Subject: [bitcoin-dev] Horizontal scaling of blockchain
In-Reply-To: <CACY+MSO8PM89VTtKfuZiQGvAs7a7R6_4mY+onhZh9KnvwxW2uw@mail.gmail.com>
References: <CACY+MSO8PM89VTtKfuZiQGvAs7a7R6_4mY+onhZh9KnvwxW2uw@mail.gmail.com>
Message-ID: <1570222.Uh686LP1o4@strawberry>

On Friday, 1 September 2017 14:47:08 CEST Cserveny Tamas via bitcoin-dev 
wrote:
> The fundamental problem is that if the miners add capacity it will only
> increase (protect) their share of block reward, but does not increase the
> speed of transactions.

Adding more space in blocks has no effect on the block-reward. It does 
actually increase the throughput speed of transactions.

> This will only raise the fee in the long run with
> the block reward decreasing.

Also this is exactly the opposite of what actually happened.

> The current chain is effectively single threaded. 

This is not true, since xthin/compactblocks have been introduced we 
completely removed this bottle-neck.
The transactions will be validated continuously, in parallel and not just 
when a block is found.

-- 
Tom Zander
Blog: https://zander.github.io
Vlog: https://vimeo.com/channels/tomscryptochannel

From lvella at gmail.com  Fri Sep  1 17:15:10 2017
From: lvella at gmail.com (Lucas Clemente Vella)
Date: Fri, 1 Sep 2017 14:15:10 -0300
Subject: [bitcoin-dev] Horizontal scaling of blockchain
In-Reply-To: <1570222.Uh686LP1o4@strawberry>
References: <CACY+MSO8PM89VTtKfuZiQGvAs7a7R6_4mY+onhZh9KnvwxW2uw@mail.gmail.com>
	<1570222.Uh686LP1o4@strawberry>
Message-ID: <CAGCathxjDsST6xD+CvKN_3md3UcWuKqgSvV+CjaTqS4gPaPGZg@mail.gmail.com>

> > The current chain is effectively single threaded.
>
> This is not true, since xthin/compactblocks have been introduced we
> completely removed this bottle-neck.
> The transactions will be validated continuously, in parallel and not just
> when a block is found.
>

If I understood correctly, OP was not talking about the process inside a
node being single threaded, but instead that the whole bitcoin distributed
system behaves as single threaded computation. OP seems to be describing a
system closer to what IOTA uses, by distributing among the miners the task
of validating the transactions. Although, without more specific details, it
is hard to judge the benefits.

-- 
Lucas Clemente Vella
lvella at gmail.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170901/01e7e191/attachment.html>

From dermoth at aei.ca  Fri Sep  1 17:24:56 2017
From: dermoth at aei.ca (Thomas Guyot-Sionnest)
Date: Fri, 1 Sep 2017 13:24:56 -0400
Subject: [bitcoin-dev] Horizontal scaling of blockchain
In-Reply-To: <CAGCathxjDsST6xD+CvKN_3md3UcWuKqgSvV+CjaTqS4gPaPGZg@mail.gmail.com>
References: <CACY+MSO8PM89VTtKfuZiQGvAs7a7R6_4mY+onhZh9KnvwxW2uw@mail.gmail.com>
	<1570222.Uh686LP1o4@strawberry>
	<CAGCathxjDsST6xD+CvKN_3md3UcWuKqgSvV+CjaTqS4gPaPGZg@mail.gmail.com>
Message-ID: <a172c495-c868-5e13-5db9-59e5cbb52f38@aei.ca>

On 01/09/17 01:15 PM, Lucas Clemente Vella via bitcoin-dev wrote:
>
>     > The current chain is effectively single threaded.
>
>     This is not true, since xthin/compactblocks have been introduced we
>     completely removed this bottle-neck.
>     The transactions will be validated continuously, in parallel and
>     not just
>     when a block is found.
>
>
> If I understood correctly, OP was not talking about the process inside
> a node being single threaded, but instead that the whole bitcoin
> distributed system behaves as single threaded computation. OP seems to
> be describing a system closer to what IOTA uses, by distributing among
> the miners the task of validating the transactions. Although, without
> more specific details, it is hard to judge the benefits.
>

If the goal is reducing the delay for validation then I don't get what
advantage there would be vs. reducing the difficulty.

Also it is my understanding that with the Lightning network transactions
could be validated instantly by third parties and could be subject to
smaller fees overall...

Regards,

-- 
Thomas

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170901/44c8986f/attachment-0001.html>

From cserveny.tamas+bc at gmail.com  Fri Sep  1 18:15:53 2017
From: cserveny.tamas+bc at gmail.com (Cserveny Tamas)
Date: Fri, 01 Sep 2017 18:15:53 +0000
Subject: [bitcoin-dev] Horizontal scaling of blockchain
In-Reply-To: <CAGCathxjDsST6xD+CvKN_3md3UcWuKqgSvV+CjaTqS4gPaPGZg@mail.gmail.com>
References: <CACY+MSO8PM89VTtKfuZiQGvAs7a7R6_4mY+onhZh9KnvwxW2uw@mail.gmail.com>
	<1570222.Uh686LP1o4@strawberry>
	<CAGCathxjDsST6xD+CvKN_3md3UcWuKqgSvV+CjaTqS4gPaPGZg@mail.gmail.com>
Message-ID: <CACY+MSOPWhTnR-ZR67T1a5ZU2w4pWa6FkXsGF3_C+n3gKFCPSA@mail.gmail.com>

Yes. I meant the single thread as an analogy, if a block is found, other
blocks are worthless. (more or less) Longest chain wins.

My line of though was, that currently the only way to scale with the
traffic (and lowering the fees) is increasing the block size (which is hard
as I learned from recent events), or reducing the complexity which is less
secure (most likely more controversial)

Splitting the chain is effectively increasing the block size, but without
the increased hashing and validation overhead.

The usage growth seems to be more of exponential rather than linear. Sooner
or later the block size will need to be 4 mb then 40 mb, then what is the
real limit? Otherwise waiting times and thus the fees will just grow
rapidly. I don't think that it is desirable.

With splitting the ledger, the block size can remain 1-2 mb for long time,
only new partitions needs to be added on a schedule. This would also make
better use of the hashing capacity.

Cheers,

Tamas






On Fri, Sep 1, 2017 at 7:15 PM Lucas Clemente Vella <lvella at gmail.com>
wrote:

> > The current chain is effectively single threaded.
>>
>> This is not true, since xthin/compactblocks have been introduced we
>> completely removed this bottle-neck.
>> The transactions will be validated continuously, in parallel and not just
>> when a block is found.
>>
>
> If I understood correctly, OP was not talking about the process inside a
> node being single threaded, but instead that the whole bitcoin distributed
> system behaves as single threaded computation. OP seems to be describing a
> system closer to what IOTA uses, by distributing among the miners the task
> of validating the transactions. Although, without more specific details, it
> is hard to judge the benefits.
>
> --
> Lucas Clemente Vella
> lvella at gmail.com
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170901/d908e965/attachment.html>

From dermoth at aei.ca  Fri Sep  1 19:40:44 2017
From: dermoth at aei.ca (Thomas Guyot-Sionnest)
Date: Fri, 1 Sep 2017 15:40:44 -0400
Subject: [bitcoin-dev] Horizontal scaling of blockchain
In-Reply-To: <CACY+MSOPWhTnR-ZR67T1a5ZU2w4pWa6FkXsGF3_C+n3gKFCPSA@mail.gmail.com>
References: <CACY+MSO8PM89VTtKfuZiQGvAs7a7R6_4mY+onhZh9KnvwxW2uw@mail.gmail.com>
	<1570222.Uh686LP1o4@strawberry>
	<CAGCathxjDsST6xD+CvKN_3md3UcWuKqgSvV+CjaTqS4gPaPGZg@mail.gmail.com>
	<CACY+MSOPWhTnR-ZR67T1a5ZU2w4pWa6FkXsGF3_C+n3gKFCPSA@mail.gmail.com>
Message-ID: <e9531342-db9b-ffdf-5ada-0c143eb89d9e@aei.ca>

On 01/09/17 02:15 PM, Cserveny Tamas via bitcoin-dev wrote:
> Yes. I meant the single thread as an analogy, if a block is found,
> other blocks are worthless. (more or less) Longest chain wins.
>
> My line of though was, that currently the only way to scale with the
> traffic (and lowering the fees) is increasing the block size (which is
> hard as I learned from recent events), or reducing the complexity
> which is less secure (most likely more controversial)
>

It wouldn't be less secure as long as you adjust the confirmation
accordingly. If we decided to mine one block every minute, then your
usual 6 confirmation should become 60 confirmation. In the end, the same
amount of work will have been done to prove the transaction is legit and
so it's just as secure... Actually, one could argue since the average
hash rate over 60 block is more accurate than over 6, it's actually more
secure if you also pay attention to hash rate variation as part of the
confirmation... That help in the scenario a very large pool goes dark to
mine a sidechain.

-- 
Thomas


From tomz at freedommail.ch  Sat Sep  2 21:13:57 2017
From: tomz at freedommail.ch (Tom Zander)
Date: Sat, 02 Sep 2017 23:13:57 +0200
Subject: [bitcoin-dev] Horizontal scaling of blockchain
In-Reply-To: <CACY+MSOPWhTnR-ZR67T1a5ZU2w4pWa6FkXsGF3_C+n3gKFCPSA@mail.gmail.com>
References: <CACY+MSO8PM89VTtKfuZiQGvAs7a7R6_4mY+onhZh9KnvwxW2uw@mail.gmail.com>
	<CAGCathxjDsST6xD+CvKN_3md3UcWuKqgSvV+CjaTqS4gPaPGZg@mail.gmail.com>
	<CACY+MSOPWhTnR-ZR67T1a5ZU2w4pWa6FkXsGF3_C+n3gKFCPSA@mail.gmail.com>
Message-ID: <3416963.LpSpYe5DLS@strawberry>

On Friday, 1 September 2017 20:15:53 CEST Cserveny Tamas wrote:
> The usage growth seems to be more of exponential rather than linear.
> Sooner or later the block size will need to be 4 mb then 40 mb, then what
> is the real limit? Otherwise waiting times and thus the fees will just
> grow rapidly. I don't think that it is desirable.

The real limit is set by the technology. Just like in 1990 we could not 
fathom having something like YouTube and high-res video streaming (Netflix), 
the limits of what is possible continually shifts.

This is basically how any successful product has ever grown, I think that it 
is not just desirable, it is inevitable.
-- 
Tom Zander
Blog: https://zander.github.io
Vlog: https://vimeo.com/channels/tomscryptochannel

From thomasv at electrum.org  Sun Sep  3 05:19:12 2017
From: thomasv at electrum.org (Thomas Voegtlin)
Date: Sun, 3 Sep 2017 07:19:12 +0200
Subject: [bitcoin-dev] BIP49 Derivation scheme changes
In-Reply-To: <CABuOfuijNyNrdSfCXKySw0Qf7E1db8sgzWYgW9uOg_ZJJbuixA@mail.gmail.com>
References: <CABuOfuijNyNrdSfCXKySw0Qf7E1db8sgzWYgW9uOg_ZJJbuixA@mail.gmail.com>
Message-ID: <5a27e555-173e-b5a7-8c05-5ee32e885ee2@electrum.org>



On 30.08.2017 09:24, shiva sitamraju via bitcoin-dev wrote:

> 
> 2. Segwit wallet seed words have a different format which is incompatible
> with previous wallet seed words. This  encodes the information that this
> wallet is segwit in the seed words itself. We need to define a structure
> for this
> 

That is what Electrum does.
See http://docs.electrum.org/en/latest/seedphrase.html

From pete at petertodd.org  Mon Sep  4 14:06:44 2017
From: pete at petertodd.org (Peter Todd)
Date: Mon, 4 Sep 2017 10:06:44 -0400
Subject: [bitcoin-dev] Fwd:  "Compressed" headers stream
In-Reply-To: <CAAS2fgRvSZm-NVLU++0WmWoaYbpX1R0Fqmv_Jf7a_RsqzXfOog@mail.gmail.com>
References: <CADabwBBrrPM2f9h_sgxY12tg=FUvKKCcnCC8ixnct93YL9uEFQ@mail.gmail.com>
	<CAAS2fgS3uG=4vgFuObPKA_5MstoGm4AabO=60fhV3EU_0dvejg@mail.gmail.com>
	<CAAS2fgRvSZm-NVLU++0WmWoaYbpX1R0Fqmv_Jf7a_RsqzXfOog@mail.gmail.com>
Message-ID: <20170904140644.GF1276@fedora-23-dvm>

On Mon, Aug 28, 2017 at 05:12:15PM +0000, Gregory Maxwell via bitcoin-dev wrote:
> You are leaving a lot of bytes on the table.
> 
> The bits field can only change every 2016 blocks (4 bytes per header),
> the timestamp can not be less than the median of the last 11 and is
> usually only a small amount over the last one (saves 2 bytes per
> header), the block version is usually one of the last few (save 3
> bytes per header).
> 
> But all these things improvements are just a constant factor. I think
> you want the compact SPV proofs described in the appendix of the
> sidechains whitepaper which creates log scaling proofs.

Note that I'm already planning on OpenTimestamps having infrastructure for
trusted validity attestations; log scaling proofs alone only prove total work,
not validity. Timestamping has all kinds of very dubious security properties
when done via proof-of-work, due to various ways that miners can get away with
inaccurate block times. In particular, setting a block time backwards is
something that miners can do, particularly with majority hashing power, which
is the exact thing we're trying to prevent in a timestamp proof.

This all makes me dubious about risking further weakening of this already weak
security with compact SPV proofs; we'd need a lot more analysis to understand
what we're risking. Also note that we can ship a known-good
sum-merkle-tree tip hash with the software, which further reduces initial
download bandwidth needed to get the block headers on top of this obviously
safe eliding of redundant hashes.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170904/8be560f7/attachment.sig>

From pete at petertodd.org  Mon Sep  4 14:10:17 2017
From: pete at petertodd.org (Peter Todd)
Date: Mon, 4 Sep 2017 10:10:17 -0400
Subject: [bitcoin-dev] "Compressed" headers stream
In-Reply-To: <CAB3F3DtX2+awy71YPhMRjFRr4tvcGyq3Pu4997Sw2Jn_yAX+=g@mail.gmail.com>
References: <CADabwBBrrPM2f9h_sgxY12tg=FUvKKCcnCC8ixnct93YL9uEFQ@mail.gmail.com>
	<CAB3F3DuK-5Bs-NunBVBnNbAT3SCVBZEqJqRHUHsSZhCVeO8xEQ@mail.gmail.com>
	<CADabwBDQ=aJuW7fGcU2h-yYKxfj5A0Vx6DNHEM=_ppMrdA_mcw@mail.gmail.com>
	<CAB3F3DtX2+awy71YPhMRjFRr4tvcGyq3Pu4997Sw2Jn_yAX+=g@mail.gmail.com>
Message-ID: <20170904141017.GG1276@fedora-23-dvm>

On Mon, Aug 28, 2017 at 12:26:48PM -0400, Greg Sanders via bitcoin-dev wrote:
> Well, if anything my question may bolster your use-case. If there's a
> heavier chain that is invalid, I kind of doubt it matters for timestamping
> reasons.

Timestamping can easily be *more* vulnerable to malicious miners than financial
applications for a number of reasons, including the fact that there's no
financial feedback loop of miners destroying the value of the coins they
produce - timestamping is a non-financial piggy-back application that doesn't
directly interact with the Bitcoin economy, beyond a trival number of timestamp
transactions.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170904/818e9344/attachment-0001.sig>

From pete at petertodd.org  Mon Sep  4 13:51:35 2017
From: pete at petertodd.org (Peter Todd)
Date: Mon, 4 Sep 2017 09:51:35 -0400
Subject: [bitcoin-dev] P2WPKH Scripts, P2PKH Addresses,
 and Uncompressed Public Keys
In-Reply-To: <CY4PR1801MB181557B7331133954A3098DD809E0@CY4PR1801MB1815.namprd18.prod.outlook.com>
References: <CY4PR1801MB181583C344B0993205D4B6C8809E0@CY4PR1801MB1815.namprd18.prod.outlook.com>
	<CAAS2fgT+HHg_xuuWuGrYcX0ALcBowmY-1Kt6-dzSBOwdcr08HQ@mail.gmail.com>
	<CY4PR1801MB181557B7331133954A3098DD809E0@CY4PR1801MB1815.namprd18.prod.outlook.com>
Message-ID: <20170904135135.GE1276@fedora-23-dvm>

On Mon, Aug 28, 2017 at 08:55:47PM +0000, Alex Nagy via bitcoin-dev wrote:
> Thanks Gregory - to be clear should Native P2WPKH scripts only appear in redeem scripts?  From reading the various BIPs it had seemed like Native P2WPKH and Native P2WSH were also valid and identifiable if they were encoded in TxOuts.  The theoretical use case for this would be saving bytes in Txes with many outputs.

It's not a theoretical use-case: the two OpenTimestamps calendar servers I run
- {alice,bob}.btc.calendar.opentimestamps.org - use native P2WPKH segwit
outputs to keep transaction size to the absolute minimum possible; previously
they used bare CHECKSIG <pubkey> output scripts for the same reason.

I enabled support for it the moment segwit activated, so I'm probably the first
ever production user of P2WPKH on mainnet, and quite possibly, the first person
to create P2WPKH outputs on mainnet for any reason.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170904/74b9488c/attachment.sig>

From thomasv at electrum.org  Tue Sep  5 10:25:16 2017
From: thomasv at electrum.org (Thomas Voegtlin)
Date: Tue, 5 Sep 2017 12:25:16 +0200
Subject: [bitcoin-dev] Proposal: bip32 version bytes for segwit scripts
Message-ID: <43636dd6-ab9e-da15-59ae-f31eb11ff7ff@electrum.org>

BIP32 extended public/private keys have version bytes that result in the
user visible xpub/xprv prefix. The BIP's recommendation is to use
different version bytes for other networks (such as tpub/tprv for testnet)

I would like to use additional version bytes to indicate the type of
output script used with the public keys.

I believe the change should be user visible, because users are exposed
to master public keys. I propose the following prefixes:

========== =========== ===================================
Version    Prefix      Description
========== =========== ===================================
0x0488ade4 xprv        P2PKH or P2SH
0x0488b21e xpub        P2PKH or P2SH
0x049d7878 yprv        (P2WPKH or P2WSH) nested in P2SH
0x049d7cb2 ypub        (P2WPKH or P2WSH) nested in P2SH
0x04b2430c zprv        P2WPKH or P2WSH
0x04b24746 zpub        P2WPKH or P2WSH
========== =========== ===================================
(source: http://docs.electrum.org/en/latest/seedphrase.html)

I have heard the argument that xpub/xprv serialization is a format for
keys, and that it should not be used to encode how these keys are used.
However, the very existence of version bytes, and the fact that they are
used to signal whether keys will be used on testnet or mainnet goes
against that argument.

If we do not signal the script type in the version bytes, I believe
wallet developers are going to use dirtier tricks, such as the bip32
child number field in combination with bip43/bip44/bip49.


Thomas

From tomas at tomasvdw.nl  Tue Sep  5 14:17:26 2017
From: tomas at tomasvdw.nl (Tomas)
Date: Tue, 05 Sep 2017 16:17:26 +0200
Subject: [bitcoin-dev] Partial UTXO tree as commitment
Message-ID: <1504621046.2505938.1095808376.49C6DC53@webmail.messagingengine.com>

I would like to propose an efficient UTXO commitment scheme.

A UTXO commitment can be useful for:

1. Fast syncing a full node, by downloading the UTXO-set
2. Proofing (non) existence of a UTXO..

Various schemes have been proposed:

* Merkle/radix trees and variants; all of which have the problem that
they significantly increase the burden of maintaining the UTXO set.
Furthermore, such schemes tend to practically prescribe the UTXO storage
format severely limiting continuous per-implementation optimizations.
* A "flat" rolling hash, eg the ECMH proposed by Pieter Wiulle which is
cheap to calculate but only solves (1) and not (2).

I propose a hybrid approach, with very limited extra burden to maintain
and reasonably small proofs: 

We divide the UTXO set in buckets by prefix of their TXID, then maintain
a rolling hash for each bucket. The commitment is then the root of the
tree constructed from the resulting bucket hashes. To construct the
tree: For each depth, we group the hashes of the next depth per 64
hashes and calculate the rolling hash of each. (Effectively, this is a
prefix tree with a fixed branch-size of 64).

Bucketcount
-------------------
txcount = number of TXIDs in the UTXO set
bucketcount = (smallest power of 2 larger than sqrt(txcount))  << 6

Rationale for bucketcount:

* This currently gives a bucketcount of 2^19, which is very cheap to
maintain with a 16mb array of rolling hashes.
* This currently gives an average bucket size of 4kb. With a rolling
hash, full nodes don't need to maintain the buckets themselves, but they
are used for proofs.
* The burden of future UTXO growth is divided among maintaining the
rolling hashes and size of the proof: 10,000x as large UTXO set (20TB),
gives ~400kb buckets and ~1.6gb in maintaining rolling hashes.
* This gives a tree depth of 5, which means the cost of every UTXO
update is increased  by ~3 rolling hashes (and a double SHA), as the
lowest depths don't benefit from caching.
* A proof for (non) existence of a UTXO is ~ 4*64*32 =8kb (branch-nodes)
+ 4kb (bucket) = ~12kb

Specification [WIP]
---------------------------
We define the "UTXO commitment" as the serialized byte array: "U" "T"
"X" "O" VARINT(version) VARINT(txcount) UINT256(UTXO-root)    [todo
clarify]

A block that contains an output in the coinbase whose scriptPubKey
consists solely of OP_RETURN [UTXO commitment] must be rejected if in
the UTXO commitment the version equals 1 and either 
* After updating the UTXO state, the number of distinct TXIDs in the
UTXO set is not equal to the txcount value of the UTXO commitment
* After updating the UTXO state, the UTXO-root in the UTXO commitment is
not equal to the UTXO-root defined below.

The UTXO-root can be calculated as follows:

* Define _bucketcount_ as (smallest power of 2 larger than
sqrt(txcount))  << 6
* Given a TXID in the UTXO set, define UTXO(TXID) as the double SHA256
of (TXID + coins). (coins is the serialization of unspent outputs to be
spec'ed). 
* Let bucket N be the set of values UTXO(TXID) for each TXID in the
UTXO-set where (TXID mod _bucketcount_) equals N.
* Let rhash N be the rolling hash (TBD) of all values in bucket N
* Let the hash sequence be the ordered sequence  rhash
[0,_bucketcount_).

1. If the hash sequence contains at most 64 entries, then the UTXO-root
is the rolling hash of all entries in the hash sequence, otherwise:
2. Group the hash sequence in ordered subsequences of 64 entries each.
3. Find the rolling hash of each subsequence
4. Continue with 1., with the hash sequence being the ordered sequence
of these rolling hashes.

Note: an implementation may want to maintain and update the set of
rolling hashes at higher depths on each UTXO set operation.

Note: the secure ECMH is a good candidate for the bucket hash. This
could also be used for the branch rolling hashes, but it might be worth
considering XOR for those as there seem to be simply not enough
candidates to find a colliding set?

Note: two magic numbers are used: "<< 6" for the bucket count, and "64"
for the branch size. They work nicely but are pulled out of a dark place
and merit some experimentation.

Use cases for light clients
-------------------------------------
These UTXO proofs could be used as compact fraud proofs, although the
benefit of this is not generally agreed upon.

They can also be used to increase low-conf security to light clients, by
validating the signatures and order-validity of incoming transactions
against the right bucket of the current UTXO set.

An interesting use case may be another type of light client. It could be
interesting for a light client to abandon the bloom filters, and instead
use the UTXO proofs to verify whether an incoming or outgoing
transaction is confirmed. This could be beneficial for "rarely active"
light clients such as smartphone apps, as it prevents the need to
synchronize previous blocks with bloom filters, and allows syncing to
the latest block with 12kb/output.

Summary 
--------------
* Allows fast full node syncing.
* Costs full nodes ~20mb extra in RAM
* Costs full nodes ~3 rolling hash operations per UTXO operation.
* Allows UTXO (non) existence proofs for currently avg ~12kb.
* Size of proof grows O(sqrt(N)) with UTXO set
* Size of extra full node memory grows O(sqrt(N)) with UTXO set


Tomas van der Wansem
bitcrust

From shiva at blockonomics.co  Tue Sep  5 07:10:15 2017
From: shiva at blockonomics.co (shiva sitamraju)
Date: Tue, 5 Sep 2017 12:40:15 +0530
Subject: [bitcoin-dev] BIP49 Derivation scheme changes
Message-ID: <CABuOfuiz9U=ZPWRUfVXHgBekZ74B4zkUikg6Svxbr6jrJA5Vyw@mail.gmail.com>

Hi,

Thanks Thomas. The procedure described in
http://docs.electrum.org/en/latest/seedphrase.html is really what I was
looking for ! I really don't see any point of following BIP49, If possible
it would be great if you can propose an alternative to BIP49 that follows
similar structure to what is used in electrum.

I have proposed following changes to BIP32 serialization format
https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#serialization-format
to differentiate segwit xpub/xprv. Below the list of new version bytes,
resulting base58 prefix and network type:

0x042393df ,  sxpr ,   segwit mainnet private key
0x04239377 , sxpb , segwit mainnet public key
0x04222463 , stpb ,  segwit testnet public key
0x042224cc ,  stpr ,  segwit testnet private key

Let me know your thoughts

On Tue, Sep 5, 2017 at 12:12 AM, <
bitcoin-dev-request at lists.linuxfoundation.org> wrote:

> Send bitcoin-dev mailing list submissions to
>         bitcoin-dev at lists.linuxfoundation.org
>
> To subscribe or unsubscribe via the World Wide Web, visit
>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> or, via email, send a message with subject or body 'help' to
>         bitcoin-dev-request at lists.linuxfoundation.org
>
> You can reach the person managing the list at
>         bitcoin-dev-owner at lists.linuxfoundation.org
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of bitcoin-dev digest..."
>
>
> Today's Topics:
>
>    1. Re: Horizontal scaling of blockchain (Cserveny Tamas)
>    2. Re: Horizontal scaling of blockchain (Thomas Guyot-Sionnest)
>    3. Re: Horizontal scaling of blockchain (Tom Zander)
>    4. Re: BIP49 Derivation scheme changes (Thomas Voegtlin)
>    5. Re: Fwd:  "Compressed" headers stream (Peter Todd)
>    6. Re: "Compressed" headers stream (Peter Todd)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Fri, 01 Sep 2017 18:15:53 +0000
> From: Cserveny Tamas <cserveny.tamas+bc at gmail.com>
> To: Lucas Clemente Vella <lvella at gmail.com>, Tom Zander
>         <tomz at freedommail.ch>,  Bitcoin Protocol Discussion
>         <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] Horizontal scaling of blockchain
> Message-ID:
>         <CACY+MSOPWhTnR-ZR67T1a5ZU2w4pWa6FkXsGF3_C+
> n3gKFCPSA at mail.gmail.com>
> Content-Type: text/plain; charset="utf-8"
>
> Yes. I meant the single thread as an analogy, if a block is found, other
> blocks are worthless. (more or less) Longest chain wins.
>
> My line of though was, that currently the only way to scale with the
> traffic (and lowering the fees) is increasing the block size (which is hard
> as I learned from recent events), or reducing the complexity which is less
> secure (most likely more controversial)
>
> Splitting the chain is effectively increasing the block size, but without
> the increased hashing and validation overhead.
>
> The usage growth seems to be more of exponential rather than linear. Sooner
> or later the block size will need to be 4 mb then 40 mb, then what is the
> real limit? Otherwise waiting times and thus the fees will just grow
> rapidly. I don't think that it is desirable.
>
> With splitting the ledger, the block size can remain 1-2 mb for long time,
> only new partitions needs to be added on a schedule. This would also make
> better use of the hashing capacity.
>
> Cheers,
>
> Tamas
>
>
>
>
>
>
> On Fri, Sep 1, 2017 at 7:15 PM Lucas Clemente Vella <lvella at gmail.com>
> wrote:
>
> > > The current chain is effectively single threaded.
> >>
> >> This is not true, since xthin/compactblocks have been introduced we
> >> completely removed this bottle-neck.
> >> The transactions will be validated continuously, in parallel and not
> just
> >> when a block is found.
> >>
> >
> > If I understood correctly, OP was not talking about the process inside a
> > node being single threaded, but instead that the whole bitcoin
> distributed
> > system behaves as single threaded computation. OP seems to be describing
> a
> > system closer to what IOTA uses, by distributing among the miners the
> task
> > of validating the transactions. Although, without more specific details,
> it
> > is hard to judge the benefits.
> >
> > --
> > Lucas Clemente Vella
> > lvella at gmail.com
> >
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> attachments/20170901/d908e965/attachment-0001.html>
>
> ------------------------------
>
> Message: 2
> Date: Fri, 1 Sep 2017 15:40:44 -0400
> From: Thomas Guyot-Sionnest <dermoth at aei.ca>
> To: Cserveny Tamas <cserveny.tamas+bc at gmail.com>,       Bitcoin Protocol
>         Discussion <bitcoin-dev at lists.linuxfoundation.org>,     Lucas
> Clemente
>         Vella <lvella at gmail.com>, Tom Zander <tomz at freedommail.ch>
> Subject: Re: [bitcoin-dev] Horizontal scaling of blockchain
> Message-ID: <e9531342-db9b-ffdf-5ada-0c143eb89d9e at aei.ca>
> Content-Type: text/plain; charset=windows-1252
>
> On 01/09/17 02:15 PM, Cserveny Tamas via bitcoin-dev wrote:
> > Yes. I meant the single thread as an analogy, if a block is found,
> > other blocks are worthless. (more or less) Longest chain wins.
> >
> > My line of though was, that currently the only way to scale with the
> > traffic (and lowering the fees) is increasing the block size (which is
> > hard as I learned from recent events), or reducing the complexity
> > which is less secure (most likely more controversial)
> >
>
> It wouldn't be less secure as long as you adjust the confirmation
> accordingly. If we decided to mine one block every minute, then your
> usual 6 confirmation should become 60 confirmation. In the end, the same
> amount of work will have been done to prove the transaction is legit and
> so it's just as secure... Actually, one could argue since the average
> hash rate over 60 block is more accurate than over 6, it's actually more
> secure if you also pay attention to hash rate variation as part of the
> confirmation... That help in the scenario a very large pool goes dark to
> mine a sidechain.
>
> --
> Thomas
>
>
>
> ------------------------------
>
> Message: 3
> Date: Sat, 02 Sep 2017 23:13:57 +0200
> From: Tom Zander <tomz at freedommail.ch>
> To: Cserveny Tamas <cserveny.tamas+bc at gmail.com>
> Cc: Bitcoin Protocol Discussion
>         <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] Horizontal scaling of blockchain
> Message-ID: <3416963.LpSpYe5DLS at strawberry>
> Content-Type: text/plain; charset="us-ascii"
>
> On Friday, 1 September 2017 20:15:53 CEST Cserveny Tamas wrote:
> > The usage growth seems to be more of exponential rather than linear.
> > Sooner or later the block size will need to be 4 mb then 40 mb, then what
> > is the real limit? Otherwise waiting times and thus the fees will just
> > grow rapidly. I don't think that it is desirable.
>
> The real limit is set by the technology. Just like in 1990 we could not
> fathom having something like YouTube and high-res video streaming
> (Netflix),
> the limits of what is possible continually shifts.
>
> This is basically how any successful product has ever grown, I think that
> it
> is not just desirable, it is inevitable.
> --
> Tom Zander
> Blog: https://zander.github.io
> Vlog: https://vimeo.com/channels/tomscryptochannel
>
>
> ------------------------------
>
> Message: 4
> Date: Sun, 3 Sep 2017 07:19:12 +0200
> From: Thomas Voegtlin <thomasv at electrum.org>
> To: bitcoin-dev at lists.linuxfoundation.org
> Subject: Re: [bitcoin-dev] BIP49 Derivation scheme changes
> Message-ID: <5a27e555-173e-b5a7-8c05-5ee32e885ee2 at electrum.org>
> Content-Type: text/plain; charset=utf-8
>
>
>
> On 30.08.2017 09:24, shiva sitamraju via bitcoin-dev wrote:
>
> >
> > 2. Segwit wallet seed words have a different format which is incompatible
> > with previous wallet seed words. This  encodes the information that this
> > wallet is segwit in the seed words itself. We need to define a structure
> > for this
> >
>
> That is what Electrum does.
> See http://docs.electrum.org/en/latest/seedphrase.html
>
>
> ------------------------------
>
> Message: 5
> Date: Mon, 4 Sep 2017 10:06:44 -0400
> From: Peter Todd <pete at petertodd.org>
> To: Gregory Maxwell <greg at xiph.org>,    Bitcoin Protocol Discussion
>         <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] Fwd:  "Compressed" headers stream
> Message-ID: <20170904140644.GF1276 at fedora-23-dvm>
> Content-Type: text/plain; charset="us-ascii"
>
> On Mon, Aug 28, 2017 at 05:12:15PM +0000, Gregory Maxwell via bitcoin-dev
> wrote:
> > You are leaving a lot of bytes on the table.
> >
> > The bits field can only change every 2016 blocks (4 bytes per header),
> > the timestamp can not be less than the median of the last 11 and is
> > usually only a small amount over the last one (saves 2 bytes per
> > header), the block version is usually one of the last few (save 3
> > bytes per header).
> >
> > But all these things improvements are just a constant factor. I think
> > you want the compact SPV proofs described in the appendix of the
> > sidechains whitepaper which creates log scaling proofs.
>
> Note that I'm already planning on OpenTimestamps having infrastructure for
> trusted validity attestations; log scaling proofs alone only prove total
> work,
> not validity. Timestamping has all kinds of very dubious security
> properties
> when done via proof-of-work, due to various ways that miners can get away
> with
> inaccurate block times. In particular, setting a block time backwards is
> something that miners can do, particularly with majority hashing power,
> which
> is the exact thing we're trying to prevent in a timestamp proof.
>
> This all makes me dubious about risking further weakening of this already
> weak
> security with compact SPV proofs; we'd need a lot more analysis to
> understand
> what we're risking. Also note that we can ship a known-good
> sum-merkle-tree tip hash with the software, which further reduces initial
> download bandwidth needed to get the block headers on top of this obviously
> safe eliding of redundant hashes.
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
> -------------- next part --------------
> A non-text attachment was scrubbed...
> Name: signature.asc
> Type: application/pgp-signature
> Size: 455 bytes
> Desc: Digital signature
> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> attachments/20170904/8be560f7/attachment-0001.sig>
>
> ------------------------------
>
> Message: 6
> Date: Mon, 4 Sep 2017 10:10:17 -0400
> From: Peter Todd <pete at petertodd.org>
> To: Greg Sanders <gsanders87 at gmail.com>,        Bitcoin Protocol
> Discussion
>         <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] "Compressed" headers stream
> Message-ID: <20170904141017.GG1276 at fedora-23-dvm>
> Content-Type: text/plain; charset="us-ascii"
>
> On Mon, Aug 28, 2017 at 12:26:48PM -0400, Greg Sanders via bitcoin-dev
> wrote:
> > Well, if anything my question may bolster your use-case. If there's a
> > heavier chain that is invalid, I kind of doubt it matters for
> timestamping
> > reasons.
>
> Timestamping can easily be *more* vulnerable to malicious miners than
> financial
> applications for a number of reasons, including the fact that there's no
> financial feedback loop of miners destroying the value of the coins they
> produce - timestamping is a non-financial piggy-back application that
> doesn't
> directly interact with the Bitcoin economy, beyond a trival number of
> timestamp
> transactions.
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
> -------------- next part --------------
> A non-text attachment was scrubbed...
> Name: signature.asc
> Type: application/pgp-signature
> Size: 455 bytes
> Desc: Digital signature
> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> attachments/20170904/818e9344/attachment.sig>
>
> ------------------------------
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> End of bitcoin-dev Digest, Vol 28, Issue 3
> ******************************************
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170905/a3ece874/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Tue Sep  5 08:21:59 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 05 Sep 2017 04:21:59 -0400
Subject: [bitcoin-dev] Sidechain headers on mainchain (unification of
	drivechains and spv proofs)
Message-ID: <H7RPmZGfkVC8opGMMCW7Orav6yD05-AVB9bNtNU8C0hKYokiXL32VSmn0wkjn77qh4MvacPOePdVQ5gQZuAMF6q2oEuvKDSu6crNcEoXx_0=@protonmail.com>

Good morning all,

I have started to consider a unification of drivechains, blind merged mining, and sidechain SPV proofs to form yet another solution for sidechains.

Briefly, below are the starting assumptions:

1.  SPV proofs are a short chain of sidechain block headers.  This is used to prove to the mainchain that some fund has been locked in the sidechain and the mainchain should unlock an equivalent fund to the redeemer.

2.  SPV proofs are large and even in compact form, are still large.  We can instead use miner voting to control whether some mainchain fund should be unlocked.  Presumably, the mainchain miners are monitoring that the sidechain is operating correctly and can know directly if a side-to-main peg is valid.

3.  To maintain mainchain's security, we should use merged mining for sidechain mining rather than have a separate set of miners for mainchain and each sidechain.

4.  A blockchain is just a singly-linked list.  Genesis block is the NULL of the list.  Additional blocks are added at the "front" of the singly-linked list.  In Bitcoin, the Merkle tree root is the "pointer to head" and the previous block header ID is the "pointer to tail"; additional data like proof-of-work nonce, timestamp, and version bits exist but are not inherent parts of the blockchain linked list.

5.  In addition to SPV proofs, we should also support reorg proofs.  Basically, a reorg proof is a longer SPV proof that shows that a previous SPV proof is invalid.

--

With those, I present the idea, "sidechain headers in mainchain".

Let us modify Sztorc's OP_BRIBEVERIFY to require the below SCRIPT to use:

<Previous Sidechain Block Header Hash> <Current Sidechain Block Merkle Tree> <Sidechain ID> OP_BRIBEVERIFY OP_DROP OP_DROP OP_DROP

We also require that <Sidechain ID> be filled only once per mainchain block, as per the "blind" merge mining of Sztorc.

The key insight is that the <Previous Sidechain Block Header Hash> and <Current Sidechain Block Merkle Tree> are, in fact, the sidechain header.  Concatenating those data and hashing them is the block header hash.  Just as additional information (like extranonce and witness commitment) are put in the mainchain coinbase transaction, any additional information that the sidechain would have wanted to put in its header can be committed to in the sidechain's equivalent of a coinbase transaction (i.e. a sidechain header transaction).

(All three pieces of data can be "merged" into a single very long data push to reduce the number of OP_DROP operations, this is a detail)

Thus, the sidechain header chain (but not the block data) is embedded in the mainchain itself.

Thus, SPV proofs do not need to present new data to the mainchain.  Instead, the mainchain already embeds the SPV proof, since the headers are already in the mainchain's blocks.  All that is needed to unlock a lockbox is to provide some past sidechain header hash (or possibly just a previous mainchain block that contains the sidechain header hash, to make it easier for mainchain nodes to look up) and the Merkle path to a sidechain-side side-to-main peg  transaction.  If the sidechain header chain is "long enough" (for example, 288 sidechain block headers) then it is presumably SPV-safe to release the funds on the mainchain side.

--

Suppose a sidechain is reorganized, while a side-to-main peg transaction is in the sidechain that is to be reorganized away.

Let us make our example simpler by requiring an SPV proof to be only 4 sidechain block headers.

In the example below, small letters are sidechain block headers to be reorganized, large letters are sidechain block headers that will be judged valid.  The sidechain block header "Aa" is the fork point.  b' is the sidechain block containing the side-to-main peg that is lost.

Remember, for each mainchain block, only a single sidechain block header for a particular sidechain ID can be added.

The numbers in this example below are mainchain block height numbers.

0: Aa
1: b'
2: c
4: C
5: d
6: D
7: E
8: F
9: G
10: H <- b' side-to-main is judged as "not valid"

Basically, in case of a sidechain fork, the mainchain considers the longest chain to be valid if it is longer by the SPV proof required length.  In the above, at mainchain block 10, the sidechain H is now 4 blocks (H,G,F,E) longer than the other sidechain fork that ended at d.

Mainchain nodes can validate this rule because the sidechain headers are embedded in the mainchain block's coinbase.  Thus, mainchain fullnodes can validate this part of the sidechain rule of "longest work chain".

--

Suppose I wish to steal funds from sidechain, by stealing the sidechain lockboxes on the mainchain.  I can use the OP_BRIBEVERIFY opcode which Sztorc has graciously provided to cause miners that are otherwise uninterested in the sidechain to put random block headers on a sidechain fork.  Since the mainchain nodes are not going to verify the sidechain blocks (and are unaware of sidechain block formats in detail, just the sidechain block headers), I can get away with this on the mainchain.

However, to do so, I need to pay OP_BRIBEVERIFY multiple times.  If our rule is 288 sidechain blocks for an SPV proof, then I need to pay OP_BRIBEVERIFY 288 times.

This can then be used to reduce the risk of theft.  If lockboxes have a limit in value, or are fixed in value, that maximum/fixed value can be made small enough that paying OP_BRIBEVERIFY 288 times is likely to be more expensive than the lockbox value.

In addition, because only one sidechain header can be put for each mainchain header, I will also need to compete with legitimate users of the sidechain.  Those users may devote some of their mainchain funds to keep the sidechain alive and valid by paying OP_BRIBEVERIFY themselves.  They will reject my invalid sidechain block and build from a fork point before my theft attempt.

Because the rule is that the longest sidechain must beat the second-longest chain by 288 (or however many) sidechain block headers, legitimate users of the sidechain will impede my progress to successful theft.  This makes it less attractive for me to attempt to steal from the sidechain.

The effect is that legitimate users are generating reorg proofs while I try to complete my SPV proof.  As the legitimate users increase their fork, I need to keep up and overtake them.  This can make it unattractive for me to steal from the sidechain.

Note however that we assume here that a side-to-main peg cannot occur more often than an entire SPV proof period.

--

Suppose I am a major power with influence over >51% of mainchain miners.  What happens if I use that influence to cause the greatest damage to the sidechain?

I can simply ask my miners to create invalid side-to-main pegs that unlock the sidechain's lockboxes.  With a greater than 51% of mainchain miners, I do not need to do anything like attempt to double-spend mainchain UTXO's.  Instead, I can simply ask my miners to operate correctly to mainchain rules, but violate sidechain rules and steal the sidechain's lockboxes.

With greater than 51% of mainchain miners, I can extend my invalid sidechain until we reach the minimum necessary SPV proof.  Assuming a two-way race between legitimate users of the sidechain and me, since I have >51% of mainchain miners, I can build the SPV proof faster than the legitimate users can create a reorg proof against me.  This is precisely the same situation that causes drivechain to fail.

An alternative is to require that miners participating in sidechains to check the sidechain in full, and to consider mainchain blocks containing invalid sidechain headers as invalid.  However, this greatly increases the amount of data that a full miner needs to be able to receive and verify, effectively increasing centralization risk for the mainchain.

--

The central idea of drivechain is simply that miners vote on the validity of sidechain side-to-main pegs.  But this is effectively the same as miners - and/or OP_BRIBEVERIFY users - only putting valid sidechain block headers on top of valid sidechain block headers.  Thus, if we instead use sidechain-headers-on-mainchain, the "vote" that the sidechain side-to-main peg is valid, is the same as a valid merge-mine of the sidechain.

SPV proofs are unnecessary in drivechain.  In sidechain-header-on-mainchain, SPV proofs are already embedded in the mainchain.  In drivechain, we ask mainchain fullnodes to trust miners.  In sidechain-header-on-mainchain, mainchain fullnodes validate SPV proofs on the mainchain, without trusting anyone and without running sidechain software.

To validate the mainchain, a mainchain node keeps a data structure for each existing sidechain's fork.

When the sidechain is first created (perhaps by some special transaction that creates the sidechain's genesis block header and/or sidechain ID, possibly with some proof-of-burn to ensure that Bitcoin users do not arbitrarily create "useless" sidechains, but still allowing permissionless creation of sidechains), the mainchain node creates that data structure.

The data structure contains:

1.  A sidechain block height, a large number initially 0 at sidechain genesis.
2.  A side-to-main peg pointer, which may be NULL, and which also includes a block height at which the side-to-main peg is.
3.  Links to other forks of the same sidechain ID, if any.
4.  The top block header hash of the sidechain (sidechain tip).

If the sidechain's block header on a mainchain block is the direct descendant of the current sidechain tip, we just update the top block header hash and increment the block height.

If there is a side-to-main peg on the sidechain block header, if the side-to-main peg pointer is NULL, we initialize it and store the block height at which the side-to-main peg exists.  If there is already a pending side-to-main peg, the mainchain block is judged invalid; thus for a 288-block region only one side-to-main peg can be done.

If, for a mainchain block, the sidechain header does NOT extend the most recent sidechain tip, we have detected a sidechain split condition.  We then create a copy of the data structure for the tallest fork, then roll it back until we reach the split point; this rollback should also clear the side-to-main pointer, if we rollback to a blockheight below the side-to-main peg.  Rollback is delimited: if after 288 sidechain headers we have not found the split point, the mainchain node rejects the mainchain block as invalid.  Thus new sidechain forks cannot be started further back than our SPV proof size on the current longest sidechain.  This allows powerful individuals to kill the sidechain by spending sufficient OP_BRIBEVERIFY to put random numbers on the sidechain headers, preventing the sidechain from ever operating correctly unless the sidechain accepts this loss of valid headers specially.

If there is only a single such structure for a sidechain, the sidechain is single-chained and not under attack.  If the side-to-main peg pointer is non-null and the block height of the sidechain is 288 higher than the recorded block height, the side-to-main peg is added as a UTXO to our UTXO set.

If there are multiple such structures, the sidechain is in a contentious chainsplit condition (the "under attack" flag).  A side-to-main peg is valid (becomes a UTXO) only if it exists (i.e. is the same) on all forks of the sidechain, and the shortest fork is 288 higher than the side-to-main peg height.  This allows side-to-main pegs occurring before a contentious fork to be redeemed.

When there are multiple forks of a sidechain, the mainchain node keeps track of all of them.  It sorts these forks by blockheight.  The tallest chain is the reference.  If some fork has height less than the height of the tallest chain minus 288 (the SPV proof size), the mainchain node drops it.  Then that sidechain fork can no longer be extended; if it is the only fork lacking a particular side-to-main peg that exists on all the other forks, then the side-to-main peg becomes a UTXO.  Once all contentious forks have been dropped, the sidechain returns to normal operation.

Note that this implies that side-to-main pegs that occur after a contentious sidechain fork will be delayed.  This is to be expected as there is contention as to which chain is correct.

Note that this implies that sidechains must "run in lockstep" with mainchain.  In particular, if the mainchain splits, the sidechain also splits.  This allows two-way pegs to be asymmetrical, with sidechain fullnodes also being mainchain fullnodes, and immediate main-to-side pegs.

Finally, mainchain fullnodes validate side-to-main transfers, but do not need to run sidechain software.  Users of sidechains are expected to protect themselves by ensuring they have mainchain miners that will do their best to protect the sidechain by only extending the valid longest sidechain, and by spending maincoin on OP_BRIBEVERIFY.

--

Suppose I want to use a sidechain, but I worry some troll will want to attack the sidechain via the OP_BRIBEVERIFY vulnerability.  What can I do to protect my investment?

Perhaps a "protector" can be hired.  Such a protector will be paid in sidechain funds, at a premium, for use of its mainchain funds.  Such a protector will then use OP_BRIBEVERIFY on the mainchain to ensure a valid sidechain is extended on the mainchain.  Indeed, this is exactly the "sidechain miner" envisioned by Sztorc in blind merged mining: sidechain users offer a sidecoin fee to these protectors, who spend maincoin to perform OP_BRIBEVERIFY on the mainchain.  These protectors are paid in sidecoin in order to encourage them to protect the sidechain; they cannot spend sidecoin if the sidechain is successfully attacked.

Mainchain miners who wish to take on "protector" role can simply act as if they are being paid OP_BRIBEVERIFY for the sidechain they wish to protect.  However, in particular mainchain miners should not treat sidechain rules at the same level as mainchain rules: even if a sidechain block header is judged to be invalid, the mainchain miner should not reject the mainchain block.  It can only refuse to build a sidechain block header on top of an invalid sidechain block header.  Only if a sidechain is sufficiently in use can we propose the sidechain's rules to be added to mainchain as mainchain rules in a softfork.  Needless to say, miners taking on this role must have even larger datacenters in order to handle the increased bandwidth, storage, and processing load to handle both mainchain mining and sidechain protection.

--

The number 288 in all cases is a parameter that can be endlessly debated.

Regards,
ZmnSCPxj
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170905/def51eaf/attachment-0001.html>

From stick at satoshilabs.com  Tue Sep  5 15:41:37 2017
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Tue, 5 Sep 2017 17:41:37 +0200
Subject: [bitcoin-dev] BIP49 Derivation scheme changes
In-Reply-To: <CABuOfuiz9U=ZPWRUfVXHgBekZ74B4zkUikg6Svxbr6jrJA5Vyw@mail.gmail.com>
References: <CABuOfuiz9U=ZPWRUfVXHgBekZ74B4zkUikg6Svxbr6jrJA5Vyw@mail.gmail.com>
Message-ID: <9da64df3-c6a9-c232-c801-f379a6d65e44@satoshilabs.com>

On 05/09/17 09:10, shiva sitamraju via bitcoin-dev wrote:
> 0x042393df ,  sxpr ,   segwit mainnet private key
> 0x04239377 , sxpb , segwit mainnet public key
> 0x04222463 , stpb ,  segwit testnet public key
> 0x042224cc ,  stpr ,  segwit testnet private key 

I am fine with both your proposal and proposal from Thomas
({x,y,z}{pub,prv}).

Let's just decide ASAP which one we'll use.


-- 
Best Regards / S pozdravom,

Pavol "stick" Rusnak
CTO, SatoshiLabs

From stick at satoshilabs.com  Tue Sep  5 15:44:01 2017
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Tue, 5 Sep 2017 17:44:01 +0200
Subject: [bitcoin-dev] Proposal: bip32 version bytes for segwit scripts
In-Reply-To: <43636dd6-ab9e-da15-59ae-f31eb11ff7ff@electrum.org>
References: <43636dd6-ab9e-da15-59ae-f31eb11ff7ff@electrum.org>
Message-ID: <198be73d-4676-45e9-6e3d-b89f73e31702@satoshilabs.com>

On 05/09/17 12:25, Thomas Voegtlin via bitcoin-dev wrote:
> ========== =========== ===================================
> Version    Prefix      Description
> ========== =========== ===================================
> 0x0488ade4 xprv        P2PKH or P2SH
> 0x0488b21e xpub        P2PKH or P2SH
> 0x049d7878 yprv        (P2WPKH or P2WSH) nested in P2SH
> 0x049d7cb2 ypub        (P2WPKH or P2WSH) nested in P2SH
> 0x04b2430c zprv        P2WPKH or P2WSH
> 0x04b24746 zpub        P2WPKH or P2WSH
> ========== =========== ===================================
> (source: http://docs.electrum.org/en/latest/seedphrase.html)
> 
> I have heard the argument that xpub/xprv serialization is a format for
> keys, and that it should not be used to encode how these keys are used.

I used this argument for mnemonic/seed, not xpub/xprv. I am fine with
this proposal of yours, so don't worry.

-- 
Best Regards / S pozdravom,

Pavol "stick" Rusnak
CTO, SatoshiLabs

From thomasv at electrum.org  Tue Sep  5 16:33:00 2017
From: thomasv at electrum.org (Thomas Voegtlin)
Date: Tue, 5 Sep 2017 18:33:00 +0200
Subject: [bitcoin-dev] BIP49 Derivation scheme changes
In-Reply-To: <CABuOfuiz9U=ZPWRUfVXHgBekZ74B4zkUikg6Svxbr6jrJA5Vyw@mail.gmail.com>
References: <CABuOfuiz9U=ZPWRUfVXHgBekZ74B4zkUikg6Svxbr6jrJA5Vyw@mail.gmail.com>
Message-ID: <28d57503-c2b3-7736-bfea-46506636d999@electrum.org>



On 05.09.2017 09:10, shiva sitamraju via bitcoin-dev wrote:
> Hi,
> 
> Thanks Thomas. The procedure described in
> http://docs.electrum.org/en/latest/seedphrase.html is really what I was
> looking for ! I really don't see any point of following BIP49, If possible
> it would be great if you can propose an alternative to BIP49 that follows
> similar structure to what is used in electrum.
> 
> I have proposed following changes to BIP32 serialization format
> https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#serialization-format
> to differentiate segwit xpub/xprv. Below the list of new version bytes,
> resulting base58 prefix and network type:
> 
> 0x042393df ,  sxpr ,   segwit mainnet private key
> 0x04239377 , sxpb , segwit mainnet public key
> 0x04222463 , stpb ,  segwit testnet public key
> 0x042224cc ,  stpr ,  segwit testnet private key
> 

I have proposed a similar idea, with letters z,y,z combined with pub/prv
(see the electrum documentation page)

The point is that we need 3 types of keys, not 2, because there are two
types of segwit output scripts: native and nested in p2sh.

We could use t,u,v for testnet.

From luke at dashjr.org  Tue Sep  5 17:03:39 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Tue, 5 Sep 2017 13:03:39 -0400
Subject: [bitcoin-dev] Proposal: bip32 version bytes for segwit scripts
In-Reply-To: <43636dd6-ab9e-da15-59ae-f31eb11ff7ff@electrum.org>
References: <43636dd6-ab9e-da15-59ae-f31eb11ff7ff@electrum.org>
Message-ID: <201709051303.43410.luke@dashjr.org>

On Tuesday 05 September 2017 06:25:16 Thomas Voegtlin via bitcoin-dev wrote:
> I have heard the argument that xpub/xprv serialization is a format for
> keys, and that it should not be used to encode how these keys are used.
> However, the very existence of version bytes, and the fact that they are
> used to signal whether keys will be used on testnet or mainnet goes
> against that argument.
> 
> If we do not signal the script type in the version bytes, I believe
> wallet developers are going to use dirtier tricks, such as the bip32
> child number field in combination with bip43/bip44/bip49.

I think it makes more sense to use a child number field for this purpose.
It seems desirable to use the same seed for all different script formats...

As you note, xpub\xprv are already being used for both P2PKH and P2SH. It 
really doesn't make sense to differentiate segwit specifically.

Luke

From chris at suredbits.com  Tue Sep  5 17:06:32 2017
From: chris at suredbits.com (Chris Stewart)
Date: Tue, 5 Sep 2017 12:06:32 -0500
Subject: [bitcoin-dev] Sidechain headers on mainchain (unification of
 drivechains and spv proofs)
In-Reply-To: <H7RPmZGfkVC8opGMMCW7Orav6yD05-AVB9bNtNU8C0hKYokiXL32VSmn0wkjn77qh4MvacPOePdVQ5gQZuAMF6q2oEuvKDSu6crNcEoXx_0=@protonmail.com>
References: <H7RPmZGfkVC8opGMMCW7Orav6yD05-AVB9bNtNU8C0hKYokiXL32VSmn0wkjn77qh4MvacPOePdVQ5gQZuAMF6q2oEuvKDSu6crNcEoXx_0=@protonmail.com>
Message-ID: <CAGL6+mFHe_SfMea1oMZ3n-G3ey9yToAvTMTcfdxJ5qDD1dTXyQ@mail.gmail.com>

Hi ZmnSCPxj,

Basically, in case of a sidechain fork, the mainchain considers the longest
> chain to be valid if it is longer by the SPV proof required length.  In the
> above, at mainchain block 10, the sidechain H is now 4 blocks (H,G,F,E)
> longer than the other sidechain fork that ended at d.
>
> Mainchain nodes can validate this rule because the sidechain headers are
> embedded in the mainchain block's coinbase.  Thus, mainchain fullnodes can
> validate this part of the sidechain rule of "longest work chain".
>

What happens in the case that the provided merkle tree hash has a invalid
transaction in it? Wouldn't this mean that the mainchain nodes would think
the longest work chain is the valid chain, and it would kill off any
consensus valid chain that sidechain miners are trying to construct? It
seems that a malicious miner could extend the chain to whatever the SPV
proof block height is and make it impossible for the chain to reorg after
that. I guess if that is a sufficiently long block waiting period it may
not be a realistic concern, but something to think about any way.

Just a side note -- I think it should be highly recommended that the
coinbase maturity period on the sidechain to be longer than 288 (or
whatever we decide on the parameter). This incentivizes the s:miners to
work together to extend the chain by working with other s:miners (otherwise
they won't be able to claim their bribes). If they do not work together
they will not be able to spend their s:coinbase_tx outputs until they
extend their own sidechain by 288 blocks meaning they need to tie up a
large amount of capital to go rogue on their fork.

Another interesting thing might be to use the OP_WITHDRAWPROOFVERIFY op code
<https://github.com/ElementsProject/elements/blob/elements-0.14.1/src/script/interpreter.cpp#L1420>
used in the elements project. Since the cannonical merkle root hashes are
included in the mainchain, we can provide a merkle proof to the bitcoin
blockchain to initiate a withdrawl from the sidechain. I wrote up a blog
post on how OP_WPV works here
<https://medium.com/@Chris_Stewart_5/what-can-go-wrong-when-transferring-coins-into-a-sidechain-with-op-withdrawproofverify-b2f49b02ab60>.
This allows us to prove that a transaction occurred on the sidechain to
lock up those funds.

-Chris
?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170905/37b0bcbe/attachment.html>

From thomasv at electrum.org  Tue Sep  5 18:09:19 2017
From: thomasv at electrum.org (Thomas Voegtlin)
Date: Tue, 5 Sep 2017 20:09:19 +0200
Subject: [bitcoin-dev] Proposal: bip32 version bytes for segwit scripts
In-Reply-To: <201709051303.43410.luke@dashjr.org>
References: <43636dd6-ab9e-da15-59ae-f31eb11ff7ff@electrum.org>
	<201709051303.43410.luke@dashjr.org>
Message-ID: <41fb5a09-a964-a81b-497e-70a930b6923c@electrum.org>



On 05.09.2017 19:03, Luke Dashjr wrote:

> It seems desirable to use the same seed for all different script formats...

That does not seem desirable to everybody.

If you want to guarantee that users will be able to recover all their
funds from their mnemonic seed (and that is what they expect), then
wallets must implement all script formats, even the ones that are
deprecated. In addition, the list of script formats that must be
supported is not defined in advance, but it keeps growing. This makes
wallet implementation increasingly difficult. In the long run, seed
portability is guaranteed to fail in such a system.

> As you note, xpub\xprv are already being used for both P2PKH and P2SH. It 
> really doesn't make sense to differentiate segwit specifically.

That's not a reason. The fact that xpub/xprv can be used for both P2PKH
and P2SH has already resulted in users receiving coins on addresses they
do not control.

From jtimon at jtimon.cc  Tue Sep  5 21:51:45 2017
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Tue, 5 Sep 2017 23:51:45 +0200
Subject: [bitcoin-dev] SF proposal: prohibit unspendable outputs with
	amount=0
Message-ID: <CABm2gDojDQWMhw8wW1UkRGKtdbby2+6AFFZLPuRcUb7WF_u5qQ@mail.gmail.com>

This is not a priority, not very important either.
Right now it is possible to create 0-value outputs that are spendable
and thus stay in the utxo (potentially forever). Requiring at least 1
satoshi per output doesn't really do much against a spam attack to the
utxo, but I think it would be slightly better than the current
situation.

Is there any reason or use case to keep allowing spendable outputs
with null amounts in them?

If not, I'm happy to create a BIP with its code, this should be simple.

From andreas at schildbach.de  Tue Sep  5 22:13:12 2017
From: andreas at schildbach.de (Andreas Schildbach)
Date: Wed, 6 Sep 2017 00:13:12 +0200
Subject: [bitcoin-dev] Proposal: bip32 version bytes for segwit scripts
In-Reply-To: <43636dd6-ab9e-da15-59ae-f31eb11ff7ff@electrum.org>
References: <43636dd6-ab9e-da15-59ae-f31eb11ff7ff@electrum.org>
Message-ID: <oon7hh$7b4$1@blaine.gmane.org>

Generally I like the idea, but maybe we should come up with a
(Bech32-based?) new standard that also includes the key birthdate (aka
"wallet birthdate").

Also I heard Core will mix addresses of all types on the same HD chain.
What prefix would it pick? "*pub"?


On 09/05/2017 12:25 PM, Thomas Voegtlin via bitcoin-dev wrote:
> BIP32 extended public/private keys have version bytes that result in the
> user visible xpub/xprv prefix. The BIP's recommendation is to use
> different version bytes for other networks (such as tpub/tprv for testnet)
> 
> I would like to use additional version bytes to indicate the type of
> output script used with the public keys.
> 
> I believe the change should be user visible, because users are exposed
> to master public keys. I propose the following prefixes:
> 
> ========== =========== ===================================
> Version    Prefix      Description
> ========== =========== ===================================
> 0x0488ade4 xprv        P2PKH or P2SH
> 0x0488b21e xpub        P2PKH or P2SH
> 0x049d7878 yprv        (P2WPKH or P2WSH) nested in P2SH
> 0x049d7cb2 ypub        (P2WPKH or P2WSH) nested in P2SH
> 0x04b2430c zprv        P2WPKH or P2WSH
> 0x04b24746 zpub        P2WPKH or P2WSH
> ========== =========== ===================================
> (source: http://docs.electrum.org/en/latest/seedphrase.html)
> 
> I have heard the argument that xpub/xprv serialization is a format for
> keys, and that it should not be used to encode how these keys are used.
> However, the very existence of version bytes, and the fact that they are
> used to signal whether keys will be used on testnet or mainnet goes
> against that argument.
> 
> If we do not signal the script type in the version bytes, I believe
> wallet developers are going to use dirtier tricks, such as the bip32
> child number field in combination with bip43/bip44/bip49.


From ZmnSCPxj at protonmail.com  Tue Sep  5 23:32:17 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 05 Sep 2017 19:32:17 -0400
Subject: [bitcoin-dev] Sidechain headers on mainchain (unification of
	drivechains and spv proofs)
In-Reply-To: <CAGL6+mFHe_SfMea1oMZ3n-G3ey9yToAvTMTcfdxJ5qDD1dTXyQ@mail.gmail.com>
References: <H7RPmZGfkVC8opGMMCW7Orav6yD05-AVB9bNtNU8C0hKYokiXL32VSmn0wkjn77qh4MvacPOePdVQ5gQZuAMF6q2oEuvKDSu6crNcEoXx_0=@protonmail.com>
	<CAGL6+mFHe_SfMea1oMZ3n-G3ey9yToAvTMTcfdxJ5qDD1dTXyQ@mail.gmail.com>
Message-ID: <Cc5DW6tb6_Xhe3DaXisRJzqYtnWHCGcHkOsXDJLIRvv9WP2lCVocsM1atkdQOSE8-reUbCp_ZKfEDIaA0Qh5CRwFeIrHFJcNkFsqmZx70XQ=@protonmail.com>

Good morning Chris,

>>Basically, in case of a sidechain fork, the mainchain considers the longest chain to be valid if it is longer by the SPV proof required length.  In the above, at mainchain block 10, the sidechain H is now 4 blocks (H,G,F,E) longer than the other sidechain fork that ended at d.
>>
>>Mainchain nodes can validate this rule because the sidechain headers are embedded in the mainchain block's coinbase.  Thus, mainchain fullnodes can validate this part of the sidechain rule of "longest work chain".
>>
>What happens in the case that the provided merkle tree hash has a invalid transaction in it? Wouldn't this mean that the mainchain nodes would think the longest work chain is the valid chain, and it would kill off any consensus valid chain that sidechain miners are trying to construct? It seems that a malicious miner could extend the chain to whatever the SPV proof block height is and make it impossible for the chain to reorg after that. I guess if that is a sufficiently long block waiting period it may not be a realistic concern, but something to think about any way.

This is exactly the problem, and one which exists in a different form in any sidechain proposal.  In drivechain, malicious mainchain miners may arbitrarily downvote any side-to-main peg even if the side-to-main peg is valid on the sidechain, with mainchain fullnodes unable to gainsay them.  In original sidechain's SPV proofs, malicious mainchain miners may provide an invalid SPV proof and then censor any reorg proof against that SPV proof.  In both of those cases, trust in the sidechain and the value of sidecoin necessarily takes a hit.

Of course, in both of those two cases, the hit is "temporary" and the sidechain could theoretically recover.  In sidechain-headers-on-mainchain, the hit would permanently kill the sidechain.

The fact that sidechains are merge mined and cannot be mined off-mainchain makes sidechains entirely dependent on mainchain miner's support.  I agree with Sztorc that sidechains must be merge mined entirely, otherwise the sidechain will effectively reduce mainchain security by pulling away potential miners from mainchain.

OP_BRIBEVERIFY, which is intended to allow sidechain miners/protectors to be a separate datacenter from miners, allows anyone with either enough hashpower or enough maincoin to disrupt a sidechain by spamming its slot with random hash values.  With enough disruption, the sidechain may become unusable in drivechains, but may indeed be killed that way in sidechain-headers-on-mainchain.

>
>Just a side note -- I think it should be highly recommended that the coinbase maturity period on the sidechain to be longer than 288 (or whatever we decide on the parameter). This incentivizes the s:miners to work together to extend the chain by working with other s:miners (otherwise they won't be able to claim their bribes). If they do not work together they will not be able to spend their s:coinbase_tx outputs until they extend their own sidechain by 288 blocks meaning they need to tie up a large amount of capital to go rogue on their fork.

Yes, this seems sensible.

>
>Another interesting thing might be to use the OP_WITHDRAWPROOFVERIFY op code used in the elements project. Since the cannonical merkle root hashes are included in the mainchain, we can provide a merkle proof to the bitcoin blockchain to initiate a withdrawl from the sidechain. I wrote up a blog post on how OP_WPV works here. This allows us to prove that a transaction occurred on the sidechain to lock up those funds.

Yes.

Even without sidechain headers on mainchain, one might consider plain blind merged mining to have put even the "previous block hash" in the sidechain block coinbase transaction.  Thus, one might consider that in blind merged mining, h' commitments are really merkle tree roots, and the previous block hash is encoded in a special sidechain transaction on one side of the merkle tree, while sidechain block transactions are encoded in the other side of the merkle tree root.  This allows OP_WITHDRAWPROOFVERIFY to be used on blind merged mining, but without sidechain headers on mainchain, a compact SPV proof somehow must still be provided, or we are forced to use drivechain miner voting.

Regards,
ZmnSCPxj
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170905/e263f3ff/attachment.html>

From kabuto at samouraiwallet.com  Tue Sep  5 19:00:04 2017
From: kabuto at samouraiwallet.com (Kabuto Samourai)
Date: Tue, 5 Sep 2017 14:00:04 -0500
Subject: [bitcoin-dev] Proposal: bip32 version bytes for segwit scripts
Message-ID: <CA+_kfXJPfbGD6cDiPZ+7Z_rwUVS6JQNW8Vb-YsgD2wsPhHoBjw@mail.gmail.com>

We support a change to the version bits of the HD serialization that will
inform the receiving utility of the exact derivation method used for the
pubkeys. Third-parties handling xpubs must not require additional
information from the user about the derivation path or serialization format
of the addresses under that xpub. When you have to ask, "Is this a SegWit
xpub?" then you've already lost.

Avoiding a total UX nightmare is in everyone's interests.

I think Luke and Thomas may be talking past one another. When exporting a
root master HD seed, encoding the {x,y,z}{pub,prv} distinctions makes no
sense, as the root seed should derive all paths for all coins. Wallets may
need additional code to discover which paths have been used when importing
a root seed. But when exporting / importing an account-level seed for
watch-only and receive address generation, changing the serialization
version bytes is appropriate and (in our view) essential to avoid loss of
funds.

The Electrum approach is nice but may not go far enough, as xpub and zpub
both list "P2PKH or P2SH." Why not expand the number of version prefixes to
eliminate the ambiguity?


On Tue, Sep 5, 2017 at 1:09 PM, Thomas Voegtlin via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
>
> On 05.09.2017 19:03, Luke Dashjr wrote:
>
> > It seems desirable to use the same seed for all different script
> formats...
>
> That does not seem desirable to everybody.
>
> If you want to guarantee that users will be able to recover all their
> funds from their mnemonic seed (and that is what they expect), then
> wallets must implement all script formats, even the ones that are
> deprecated. In addition, the list of script formats that must be
> supported is not defined in advance, but it keeps growing. This makes
> wallet implementation increasingly difficult. In the long run, seed
> portability is guaranteed to fail in such a system.
>
> > As you note, xpub\xprv are already being used for both P2PKH and P2SH. It
> > really doesn't make sense to differentiate segwit specifically.
>
> That's not a reason. The fact that xpub/xprv can be used for both P2PKH
> and P2SH has already resulted in users receiving coins on addresses they
> do not control.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>



-- 
-Kabuto

PGP Fingerprint: 1A83 4A96 EDE7 E286 2C5A  B065 320F B934 A79B 6A99
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170905/2725c4f2/attachment.html>

From shiva at blockonomics.co  Wed Sep  6 05:20:31 2017
From: shiva at blockonomics.co (shiva sitamraju)
Date: Wed, 6 Sep 2017 10:50:31 +0530
Subject: [bitcoin-dev] BIP49 Derivation scheme changes
Message-ID: <CABuOfujTuZADkrb_zcWGy0Wx72nEuctMDge2yTXFNYPEzYRO3A@mail.gmail.com>

Hi Thomas,

Can you explain why P2WPKH nested in BIP16 P2SH require a different version
than P2WPKH? It seems to me both would would generate same bitcoin address
in txout and hence would be in the same wallet account.

I am fine with your proposal too. Would be great if you can list all new
versions including testnet ones. I would prefer all testnet ones start with
t (easier to identify) instead of having t,u,v

Thanks



On Wed, Sep 6, 2017 at 3:21 AM, <
bitcoin-dev-request at lists.linuxfoundation.org> wrote:

> Send bitcoin-dev mailing list submissions to
>         bitcoin-dev at lists.linuxfoundation.org
>
> To subscribe or unsubscribe via the World Wide Web, visit
>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> or, via email, send a message with subject or body 'help' to
>         bitcoin-dev-request at lists.linuxfoundation.org
>
> You can reach the person managing the list at
>         bitcoin-dev-owner at lists.linuxfoundation.org
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of bitcoin-dev digest..."
>
>
> Today's Topics:
>
>    1. Re: BIP49 Derivation scheme changes (Pavol Rusnak)
>    2. Re: Proposal: bip32 version bytes for segwit scripts
>       (Pavol Rusnak)
>    3. Re: BIP49 Derivation scheme changes (Thomas Voegtlin)
>    4. Re: Proposal: bip32 version bytes for segwit scripts (Luke Dashjr)
>    5. Re: Sidechain headers on mainchain (unification of
>       drivechains and spv proofs) (Chris Stewart)
>    6. Re: Proposal: bip32 version bytes for segwit scripts
>       (Thomas Voegtlin)
>    7. SF proposal: prohibit unspendable outputs with    amount=0
>       (Jorge Tim?n)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Tue, 5 Sep 2017 17:41:37 +0200
> From: Pavol Rusnak <stick at satoshilabs.com>
> To: shiva sitamraju <shiva at blockonomics.co>,    Bitcoin Protocol
>         Discussion <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] BIP49 Derivation scheme changes
> Message-ID: <9da64df3-c6a9-c232-c801-f379a6d65e44 at satoshilabs.com>
> Content-Type: text/plain; charset=windows-1252
>
> On 05/09/17 09:10, shiva sitamraju via bitcoin-dev wrote:
> > 0x042393df ,  sxpr ,   segwit mainnet private key
> > 0x04239377 , sxpb , segwit mainnet public key
> > 0x04222463 , stpb ,  segwit testnet public key
> > 0x042224cc ,  stpr ,  segwit testnet private key
>
> I am fine with both your proposal and proposal from Thomas
> ({x,y,z}{pub,prv}).
>
> Let's just decide ASAP which one we'll use.
>
>
> --
> Best Regards / S pozdravom,
>
> Pavol "stick" Rusnak
> CTO, SatoshiLabs
>
>
> ------------------------------
>
> Message: 2
> Date: Tue, 5 Sep 2017 17:44:01 +0200
> From: Pavol Rusnak <stick at satoshilabs.com>
> To: Thomas Voegtlin <thomasv at electrum.org>,     Bitcoin Protocol
>         Discussion <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] Proposal: bip32 version bytes for segwit
>         scripts
> Message-ID: <198be73d-4676-45e9-6e3d-b89f73e31702 at satoshilabs.com>
> Content-Type: text/plain; charset=windows-1252
>
> On 05/09/17 12:25, Thomas Voegtlin via bitcoin-dev wrote:
> > ========== =========== ===================================
> > Version    Prefix      Description
> > ========== =========== ===================================
> > 0x0488ade4 xprv        P2PKH or P2SH
> > 0x0488b21e xpub        P2PKH or P2SH
> > 0x049d7878 yprv        (P2WPKH or P2WSH) nested in P2SH
> > 0x049d7cb2 ypub        (P2WPKH or P2WSH) nested in P2SH
> > 0x04b2430c zprv        P2WPKH or P2WSH
> > 0x04b24746 zpub        P2WPKH or P2WSH
> > ========== =========== ===================================
> > (source: http://docs.electrum.org/en/latest/seedphrase.html)
> >
> > I have heard the argument that xpub/xprv serialization is a format for
> > keys, and that it should not be used to encode how these keys are used.
>
> I used this argument for mnemonic/seed, not xpub/xprv. I am fine with
> this proposal of yours, so don't worry.
>
> --
> Best Regards / S pozdravom,
>
> Pavol "stick" Rusnak
> CTO, SatoshiLabs
>
>
> ------------------------------
>
> Message: 3
> Date: Tue, 5 Sep 2017 18:33:00 +0200
> From: Thomas Voegtlin <thomasv at electrum.org>
> To: bitcoin-dev at lists.linuxfoundation.org
> Subject: Re: [bitcoin-dev] BIP49 Derivation scheme changes
> Message-ID: <28d57503-c2b3-7736-bfea-46506636d999 at electrum.org>
> Content-Type: text/plain; charset=utf-8
>
>
>
> On 05.09.2017 09:10, shiva sitamraju via bitcoin-dev wrote:
> > Hi,
> >
> > Thanks Thomas. The procedure described in
> > http://docs.electrum.org/en/latest/seedphrase.html is really what I was
> > looking for ! I really don't see any point of following BIP49, If
> possible
> > it would be great if you can propose an alternative to BIP49 that follows
> > similar structure to what is used in electrum.
> >
> > I have proposed following changes to BIP32 serialization format
> > https://github.com/bitcoin/bips/blob/master/bip-0032.
> mediawiki#serialization-format
> > to differentiate segwit xpub/xprv. Below the list of new version bytes,
> > resulting base58 prefix and network type:
> >
> > 0x042393df ,  sxpr ,   segwit mainnet private key
> > 0x04239377 , sxpb , segwit mainnet public key
> > 0x04222463 , stpb ,  segwit testnet public key
> > 0x042224cc ,  stpr ,  segwit testnet private key
> >
>
> I have proposed a similar idea, with letters z,y,z combined with pub/prv
> (see the electrum documentation page)
>
> The point is that we need 3 types of keys, not 2, because there are two
> types of segwit output scripts: native and nested in p2sh.
>
> We could use t,u,v for testnet.
>
>
> ------------------------------
>
> Message: 4
> Date: Tue, 5 Sep 2017 13:03:39 -0400
> From: Luke Dashjr <luke at dashjr.org>
> To: bitcoin-dev at lists.linuxfoundation.org,      Thomas Voegtlin
>         <thomasv at electrum.org>
> Subject: Re: [bitcoin-dev] Proposal: bip32 version bytes for segwit
>         scripts
> Message-ID: <201709051303.43410.luke at dashjr.org>
> Content-Type: Text/Plain;  charset="iso-8859-1"
>
> On Tuesday 05 September 2017 06:25:16 Thomas Voegtlin via bitcoin-dev
> wrote:
> > I have heard the argument that xpub/xprv serialization is a format for
> > keys, and that it should not be used to encode how these keys are used.
> > However, the very existence of version bytes, and the fact that they are
> > used to signal whether keys will be used on testnet or mainnet goes
> > against that argument.
> >
> > If we do not signal the script type in the version bytes, I believe
> > wallet developers are going to use dirtier tricks, such as the bip32
> > child number field in combination with bip43/bip44/bip49.
>
> I think it makes more sense to use a child number field for this purpose.
> It seems desirable to use the same seed for all different script formats...
>
> As you note, xpub\xprv are already being used for both P2PKH and P2SH. It
> really doesn't make sense to differentiate segwit specifically.
>
> Luke
>
>
> ------------------------------
>
> Message: 5
> Date: Tue, 5 Sep 2017 12:06:32 -0500
> From: Chris Stewart <chris at suredbits.com>
> To: ZmnSCPxj <ZmnSCPxj at protonmail.com>,         Bitcoin Protocol
> Discussion
>         <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] Sidechain headers on mainchain (unification
>         of drivechains and spv proofs)
> Message-ID:
>         <CAGL6+mFHe_SfMea1oMZ3n-G3ey9yToAvTMTcfdxJ5qDD1dTXyQ@
> mail.gmail.com>
> Content-Type: text/plain; charset="utf-8"
>
> Hi ZmnSCPxj,
>
> Basically, in case of a sidechain fork, the mainchain considers the longest
> > chain to be valid if it is longer by the SPV proof required length.  In
> the
> > above, at mainchain block 10, the sidechain H is now 4 blocks (H,G,F,E)
> > longer than the other sidechain fork that ended at d.
> >
> > Mainchain nodes can validate this rule because the sidechain headers are
> > embedded in the mainchain block's coinbase.  Thus, mainchain fullnodes
> can
> > validate this part of the sidechain rule of "longest work chain".
> >
>
> What happens in the case that the provided merkle tree hash has a invalid
> transaction in it? Wouldn't this mean that the mainchain nodes would think
> the longest work chain is the valid chain, and it would kill off any
> consensus valid chain that sidechain miners are trying to construct? It
> seems that a malicious miner could extend the chain to whatever the SPV
> proof block height is and make it impossible for the chain to reorg after
> that. I guess if that is a sufficiently long block waiting period it may
> not be a realistic concern, but something to think about any way.
>
> Just a side note -- I think it should be highly recommended that the
> coinbase maturity period on the sidechain to be longer than 288 (or
> whatever we decide on the parameter). This incentivizes the s:miners to
> work together to extend the chain by working with other s:miners (otherwise
> they won't be able to claim their bribes). If they do not work together
> they will not be able to spend their s:coinbase_tx outputs until they
> extend their own sidechain by 288 blocks meaning they need to tie up a
> large amount of capital to go rogue on their fork.
>
> Another interesting thing might be to use the OP_WITHDRAWPROOFVERIFY op
> code
> <https://github.com/ElementsProject/elements/blob/
> elements-0.14.1/src/script/interpreter.cpp#L1420>
> used in the elements project. Since the cannonical merkle root hashes are
> included in the mainchain, we can provide a merkle proof to the bitcoin
> blockchain to initiate a withdrawl from the sidechain. I wrote up a blog
> post on how OP_WPV works here
> <https://medium.com/@Chris_Stewart_5/what-can-go-wrong-
> when-transferring-coins-into-a-sidechain-with-op-withdrawproofverify-
> b2f49b02ab60>.
> This allows us to prove that a transaction occurred on the sidechain to
> lock up those funds.
>
> -Chris
> ?
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> attachments/20170905/37b0bcbe/attachment-0001.html>
>
> ------------------------------
>
> Message: 6
> Date: Tue, 5 Sep 2017 20:09:19 +0200
> From: Thomas Voegtlin <thomasv at electrum.org>
> To: Luke Dashjr <luke at dashjr.org>,
>         "bitcoin-dev at lists.linuxfoundation.org"
>         <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] Proposal: bip32 version bytes for segwit
>         scripts
> Message-ID: <41fb5a09-a964-a81b-497e-70a930b6923c at electrum.org>
> Content-Type: text/plain; charset=utf-8
>
>
>
> On 05.09.2017 19:03, Luke Dashjr wrote:
>
> > It seems desirable to use the same seed for all different script
> formats...
>
> That does not seem desirable to everybody.
>
> If you want to guarantee that users will be able to recover all their
> funds from their mnemonic seed (and that is what they expect), then
> wallets must implement all script formats, even the ones that are
> deprecated. In addition, the list of script formats that must be
> supported is not defined in advance, but it keeps growing. This makes
> wallet implementation increasingly difficult. In the long run, seed
> portability is guaranteed to fail in such a system.
>
> > As you note, xpub\xprv are already being used for both P2PKH and P2SH. It
> > really doesn't make sense to differentiate segwit specifically.
>
> That's not a reason. The fact that xpub/xprv can be used for both P2PKH
> and P2SH has already resulted in users receiving coins on addresses they
> do not control.
>
>
> ------------------------------
>
> Message: 7
> Date: Tue, 5 Sep 2017 23:51:45 +0200
> From: Jorge Tim?n <jtimon at jtimon.cc>
> To: Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>
> Subject: [bitcoin-dev] SF proposal: prohibit unspendable outputs with
>         amount=0
> Message-ID:
>         <CABm2gDojDQWMhw8wW1UkRGKtdbby2+6AFFZLPuRcUb7WF_u5qQ at mail.
> gmail.com>
> Content-Type: text/plain; charset="UTF-8"
>
> This is not a priority, not very important either.
> Right now it is possible to create 0-value outputs that are spendable
> and thus stay in the utxo (potentially forever). Requiring at least 1
> satoshi per output doesn't really do much against a spam attack to the
> utxo, but I think it would be slightly better than the current
> situation.
>
> Is there any reason or use case to keep allowing spendable outputs
> with null amounts in them?
>
> If not, I'm happy to create a BIP with its code, this should be simple.
>
>
> ------------------------------
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> End of bitcoin-dev Digest, Vol 28, Issue 6
> ******************************************
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170906/4a418ba1/attachment-0001.html>

From thomasv at electrum.org  Wed Sep  6 09:26:48 2017
From: thomasv at electrum.org (Thomas Voegtlin)
Date: Wed, 6 Sep 2017 11:26:48 +0200
Subject: [bitcoin-dev] Proposal: bip32 version bytes for segwit scripts
In-Reply-To: <CA+_kfXJPfbGD6cDiPZ+7Z_rwUVS6JQNW8Vb-YsgD2wsPhHoBjw@mail.gmail.com>
References: <CA+_kfXJPfbGD6cDiPZ+7Z_rwUVS6JQNW8Vb-YsgD2wsPhHoBjw@mail.gmail.com>
Message-ID: <56a0c721-4bae-7b99-0ca3-d0834756fc31@electrum.org>



On 05.09.2017 21:00, Kabuto Samourai wrote:
> 
> The Electrum approach is nice but may not go far enough, as xpub and zpub
> both list "P2PKH or P2SH." Why not expand the number of version prefixes to
> eliminate the ambiguity?
> 

I agree that this would make sense if we had done it from the start.
However, fixing that now might be difficult.

My "xyz" proposal extends the current format in a way that is very easy
to deploy, because existing software will require minimal changes.
However, if we eliminate the p2sh ambiguity now, wallets will need to
add extra safeguards, in order to prevent scenarios that are currently
allowed, and they will need to handle legacy xpub/xprv differently than
ypub and zpub. This would take much more time to deploy.

In addition, consensus might be more difficult to reach on that; I guess
not all developers will not agree that removing that ambiguity is
useful. Since there is an infinity of possible P2SH scripts, it will
never be possible to remove ambiguity from a master key associated to a
P2SH script. Thus, the benefit of separating P2SH from P2PKH is not as
strong.

From dan at osc.co.cr  Wed Sep  6 07:19:31 2017
From: dan at osc.co.cr (Dan Libby)
Date: Wed, 6 Sep 2017 00:19:31 -0700
Subject: [bitcoin-dev] BIP49 Derivation scheme changes
In-Reply-To: <CABuOfuijNyNrdSfCXKySw0Qf7E1db8sgzWYgW9uOg_ZJJbuixA@mail.gmail.com>
References: <CABuOfuijNyNrdSfCXKySw0Qf7E1db8sgzWYgW9uOg_ZJJbuixA@mail.gmail.com>
Message-ID: <c4924b25-96db-57e4-dd01-461e10cab503@osc.co.cr>

On 08/30/2017 12:24 AM, shiva sitamraju via bitcoin-dev wrote:

> What would happen if you recover a wallet  using seed words ?
>   1. Since there is no difference in seed words between segwit/non
> segwit, the wallet would discover both m/44' and m/49' accounts
>   2. Note that we cannot ask the user to choose an account he wants to
> operate on (Segwit/Non segwit). This is like asking him the HD
> derivation path and a really bad UI
>   3. The wallet now has to constantly monitor both m/44' and m/49'
> accounts for transactions

small nit with 3.

It seems to me that the wallet would perform initial discovery on m/44
and m/49, and then would find transactions at one or the other, so it
can then record the type somewhere and from then on need only monitor
one branch.

Still, I agree it is ugly, makes initial discovery up to 2x slower, etc.

> *- XPUB Derivation*
> This is something not addressed in the BIP yet.
> 
> 1. Right now you can get an xpub balance/transaction history. With m/49'
> there is no way to know whether an xpub is from m/44' or m/49'
> 
> 2. This breaks lots of things. Wallets like electrum/armory/mycelium
> <https://blog.trezor.io/using-mycelium-to-watch-your-trezor-accounts-a836dce0b954>support
> importing  xpub as a watch only wallet. Also services like
> blockonomics/blockchain.info <http://blockchain.info> use xpub for
> displaying balance/generating merchant addresses
> 
> Looking forward to hearing your thoughts

speaking as author of tools hd-wallet-addrs and hd-wallet-derive, I
agree this is problematic.

would be great if xpub/xprv could somehow encode their absolute path in
wallet for tools to read.  Users cannot be expected to know.



From kabuto at samouraiwallet.com  Wed Sep  6 13:47:20 2017
From: kabuto at samouraiwallet.com (Kabuto Samourai)
Date: Wed, 6 Sep 2017 08:47:20 -0500
Subject: [bitcoin-dev] Proposal: bip32 version bytes for segwit scripts
In-Reply-To: <56a0c721-4bae-7b99-0ca3-d0834756fc31@electrum.org>
References: <CA+_kfXJPfbGD6cDiPZ+7Z_rwUVS6JQNW8Vb-YsgD2wsPhHoBjw@mail.gmail.com>
	<56a0c721-4bae-7b99-0ca3-d0834756fc31@electrum.org>
Message-ID: <CA+_kfXLO-bBoRR5fZeXXFz-Vi1w+jTEcp3VRCBfKXgijAkysOw@mail.gmail.com>

> In addition, consensus might be more difficult to reach on that

Let's move forward with the simplest solution that solves the problem and
achieves consensus! Version bytes {x,y,z} fits the bill.

On Wed, Sep 6, 2017 at 4:26 AM, Thomas Voegtlin via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
>
> On 05.09.2017 21:00, Kabuto Samourai wrote:
> >
> > The Electrum approach is nice but may not go far enough, as xpub and zpub
> > both list "P2PKH or P2SH." Why not expand the number of version prefixes
> to
> > eliminate the ambiguity?
> >
>
> I agree that this would make sense if we had done it from the start.
> However, fixing that now might be difficult.
>
> My "xyz" proposal extends the current format in a way that is very easy
> to deploy, because existing software will require minimal changes.
> However, if we eliminate the p2sh ambiguity now, wallets will need to
> add extra safeguards, in order to prevent scenarios that are currently
> allowed, and they will need to handle legacy xpub/xprv differently than
> ypub and zpub. This would take much more time to deploy.
>
> In addition, consensus might be more difficult to reach on that; I guess
> not all developers will not agree that removing that ambiguity is
> useful. Since there is an infinity of possible P2SH scripts, it will
> never be possible to remove ambiguity from a master key associated to a
> P2SH script. Thus, the benefit of separating P2SH from P2PKH is not as
> strong.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>



-- 
-Kabuto

PGP Fingerprint: 1A83 4A96 EDE7 E286 2C5A  B065 320F B934 A79B 6A99
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170906/57f3bc91/attachment.html>

From luca at token21.com  Wed Sep  6 15:44:47 2017
From: luca at token21.com (Luca Venturini)
Date: Wed, 6 Sep 2017 17:44:47 +0200
Subject: [bitcoin-dev] [BIP Proposal] Token Protocol Specification
Message-ID: <a72b52aa-10b5-d256-280b-a72cac3bf92d@token21.com>

Hi everyone,

I would like to propose a standard protocol to manage tokens on top of 
the Bitcoin blockchain.

The full text is enclosed and can be found here:

https://github.com/token21/token-protocol-specification

Any feedback will be appreciated.

Luca Venturini

---

Abstract
========
This document describes a protocol to manage digital assets (tokens) on 
top of the bitcoin blockchain. The protocol enables a semantic layer 
that permits reading the bitcoin transactions as operations related to 
tokens.

The protocol allows a new level of plausible deniability, while 
permitting statefull public auditability on each issued token. It allows 
both the user and the issuer to deny that an existing bitcoin 
transaction between the two is actually a token transaction, or a new 
token issuance. While both the token sender and the token issuer cannot 
deny to have sent bitcoins, nobody can prove the transaction was related 
to a digital asset. On top of that, to guarantee plausible deniability, 
tokens can be issued, sent, and received using any existing bitcoin 
client software.

There is no need to have a wallet exclusively dedicated to manage the 
tokens. With a few simple precautions by the user, tokens can be managed 
using any existing Bitcoin wallet, while it is used for normal bitcoin 
transactions as well.

Since it is possible to infinitely split a token in parts, there is no 
definition of the number of decimals of token generated and transferred. 
The number of tokens is always an integer.

Every operation of the protocol is performed with Bitcoin transactions, 
without the use of OP_RETURN and without any form of pollution of the 
blockchain, or of the UTXO set.

The protocol permits atomic buy and sell transactions between tokens and 
Bitcoin, and between different types of tokens. The only operations that 
require a coin selection enabled wallet are the split and join special 
operations and the token offering issuance operations. Those are used to 
modify the token unit of measure and to receive bitcoins from third 
parties during a token offering issuance.

Copyright
=========
This document is licensed under the 2-clause BSD license.

Motivation
==========
The current protocols that permit to issue tokens based on the bitcoin 
blockchain (i.e. Counterparty, Omni, Colored Coins, Coinprism, Colu) are 
flawed.

The existing solutions usually need dedicated wallets and/or 
verification nodes. Usually, a "pivot" currency is involved and atomic 
transactions are not permitted unless they use the pivot currency. Those 
protocols pollute the blockchain (30% or more) and in some cases they do 
not accept P2SH scripts. Since the use of a dedicated wallet is 
required, the users cannot plausibly deny they have got tokens. 
Plausible deniability on the issuer side is not available either. None 
of these protocols permits infinite division of the tokens, so usually 
the number of decimals has to be specified at issuance time. The 
automatic token offering issuance is not enabled as well.

Rationale
=========
Let's take an example from the real world, a yacht. We write on the 
yacht's license that the owner is any person that can show a one dollar 
bill having the serial number F82119977F. Thus the one dollar bill can 
be exchanged between owners with extreme simplicity and full plausible 
deniability. The US government will guarantee that there is no other 
person having the same dollar bill.

The protocol permits managing a token in the same way. The underlying 
Bitcoin protocol will guarantee against double spending.

Features:

  - Easy of use. Tokens can be managed using any wallet. Even if the 
wallet has no coin selection feature.
  - Plausible Deniability by the issuer. The issuer can generate a new 
type of token and nobody analyzing the blockchain will understand that 
the transaction is issuing a token. Even if a token is known, the issuer 
can issue other tokens. Since a single output contains a large number of 
different token types, the issuer is actually generating different types 
of tokens every time she sends a new Bitcoin transaction to the network.
  - Plausible Deniability by the user (no use of tokens at all, or use 
of a different token type). A transaction that sends tokens from Alice 
to Bob is a normal transaction. Nobody can understand that this 
transaction is moving tokens unless they explicitly know which 
transaction is the token issuance. In fact a single address contains a 
large number of token types, and the use of tokens itself can be denied.
  - Accountability. Everybody can see the state of the distribution of a 
type of token.
  - Tunnel mode (confidentiality by issuer and user versus a third 
party). Alice can send tokens to Bob and ask him to give the tokens to 
Charlie, without telling to Bob what is the type of the token given. 
Alice can disclose this information in the future, if she wants.
  - It is possible to perform open or closed issuances. While an open 
issuance permits to continue the issuance of tokens in the future, 
closed issuance guarantees that no other token of the same type will 
ever be issued.
  - The power to continue the issuance of an open token can be sent to 
another address, using a transaction. Once the power to continue the 
issuance is sent to someone, the former issuer cannot issue any more tokens.
  - The power to continue the issuance has the same features of 
plausible deniability of the possess of a token.
  - Since a token type is uniquely identified by a transaction hash, or, 
in some cases, by a Bitcoin address, a user can prove to be the issuer 
by signing a message using the Bitcoin protocol.
  - Future proof. Tokens can move following P2PKH, P2SH, P2SH-P2WPKH 
outputs or any other type of script
  - Blockchain pollution of the protocol transactions is almost zero. 
There is no OP_RETURN involved, nor any other type of "fake" addresses 
that pollute the UTXO database.
  - The protocol is based on the Bitcoin blockchain, but, with small 
changes, can be considered blockchain agnostic.
  - Atomic transactions between tokens and Bitcoin are possible.
  - Atomic transactions between different types of tokens are possible.
  - Tokens of different types can be held by the same address and by the 
same output.
  - Tokens can be divided indefintely, thus having any number of decimals.
  - Tokens can be issued automatically on the receiving of bitcoins. 
This operation performs a token offering issuance (also known as Initial 
Coin Offering).

Introduction
============

Where are the tokens?
---------------------
As with bitcoins, tokens are contained in unspent Bitcoin outputs. In 
some cases, defined below, the last five digits of the satoshi value 
sent to the output represent the number of tokens contained in the output.

When an output is spent, the tokens contained in the output are fully 
spent in the same transaction. There are no tokens outside of the tokens 
contained in the UTXO database.

Token issuance
--------------
The large majority of bitcoin transactions can be semantically seen as 
token issuances. There are two types of token issuances: closed and 
opened. A closed token issuance guarantees that no other token of the 
same type will ever be issued.

Issuance chains
---------------
An open issuance gives to one, or more, of its output the power to 
continue the issuance of tokens of the same type. We define such a power 
as Power of Continuation (POC). The transaction that will spend the 
output appointed with the POC will be a continuation of the same 
issuance chain.

Every transaction of the chain will issue the same type of token. On top 
of that, every transaction that is part of the chain, can also be seen 
as as issuance of tokens of its, new, type. A chain will be closed by a 
transaction having more than one output and the first output with five 
zeros as the last five digits of the satoshis value. No other 
transactions can send tokens of the same type after the close of the 
issuance.

Token names
-----------
A token type can have multiple names. The default name is the hash of 
the first transaction that issued the token.

i.e: 68330b6ab26e44f9c3e515f04d15ffe6547f29e60b809a47e50d9abf59045c1e

As alternative names, a token type can be named after the bitcoin 
address of one of the outputs of the transaction that first issued the 
token, provided the fact that the address has never been used before in 
the blockchain.

Note: it is better to use one of the alternate names in cases when 
transaction malleability is a concern.

Vanity token names
------------------
A token can be identified using only the first characters of the Bitcoin 
address, as alternate name defined above, if the characters are 
different from every previous Bitcoin address seen in the blockchain. An 
example is provided below.

Tokens can coexist
-------------------
Token of different types can coexist in a single output while remaining 
of different types. Thus a bitcoin address (actually an output of the 
UTXO database) can hold tokens of different types. Every Bitcoin address 
contains a lot of types of tokens, so that a user usually does not know 
all the type of tokens contained in an address.

A single transaction can send a type of token to some of the outputs 
while sending another type of token to a different set of its outputs. 
Tokens are never burned or deleted.

Use the protocol
================
This section explains a basic use case. In all the examples provided, we 
do not consider the fee. We assume that there is another input, not 
listed, that pays the transaction fee.

Alice, Bob, Charlie, and Daniel decides that they want to start a new 
company. Each of them will give to the new company some time, money, 
furniture, knowledge. They decide everyone contributed to the company 
with a percentage of value as follows: Alice - 40%, Bob - 12%, Charlie - 
34% and Daniel - 14%. They decide that the shares of the new company can 
be freely resold to others and that they will accept that the annual 
meeting will consent vote through messages signed using the Bitcoin 
protocol by the owners of the shares.

Issue tokens
------------
Alice asks Bob, Charlie, and Daniel to send her 1 Bitcoin each. She asks 
each of them to give her a bitcoin address where they want to receive 
back the bitcoins along with the tokens.

She asks Charlie to generate a vanity address that has never been used 
before of type 1CompanyXWXjLgud9jxwxm34u.... Since there has been a 
previous address in the blockchain having 1Companx as the first 
characters, but this is the first address seen in the blockchain that 
has 1Company as the first characters, they will call the token with the 
name 1Company. This step is optional.

Then she sends, from her wallet, a transaction having the following outputs:

  - 1.00000040 to an address controlled by Alice
  - 1.00000012 to an address controlled by Bob
  - 1.00000034 to the vanity address 1CompanyXWXjLgud9jxwxm34u... 
controlled by Charlie
  - 1.00000014 to an address controlled by Daniel
  - 3.45322112 is the change generated by Alice's wallet

This transaction gives 40, 12, 34, 14 tokens to each one. The newly 
generated token type can be named after the transaction hash, or after 
the vanity address (optional), or after one of the addresses of the 
persons involved, provided that the address has never been used before.

The issuance is still open. Since they do not want to issue more shares, 
they decide to close the issuance (on the other side, they could decide 
to leave the issuance open and to hold the issuing key somewhere, or to 
have a multisignature address and to give the keys to the directors of 
the company). In order to close the issuance, Alice generates the 
following transaction that sends bitcoins from her wallet to addresses 
of her same wallet, using the change output of the previous transaction 
as an input:

  - 0.45000000 to an address of her wallet
  - 3.00322112 change generated by the wallet

This closes the issuance.

Send tokens
--------------
After some while, Bob decides to give some shares of the company to his 
husband Giacomo. He generates a new transaction spending the output of 
the issuance transaction:

  - 0.03400008 to Giacomo
  - 0.96600004 change generated by Bob's wallet

This transaction gives to Giacomo 8 shares of the company.

Atomic transactions
-------------------
Daniel wants to sell 3 of his 14 shares to Frank. They negotiate a price 
of 0.00323200 bitcoin per share. This is a total of 0.00969600 bitcoin 
to buy the three shares. They do not know each other very well, so they 
decide to make an atomic transaction that will give 0.00969600 bitcoins 
to Daniel and 3 shares to Frank. Daniel set an input of the new 
transaction with his issuance transaction output. Frank put in another 
input of 1.23242454 bitcoins from his wallet. The outputs of the 
transaction are as follows:

  - 0.22400003 to an address controlled by Frank (this gives the 3 
shares to Frank)
  - 0.23200000 to an address controlled by Daniel (this is part of the 
payment to Daniel)
  - 0.77769614 to an address controlled by Daniel (this can be 
considered the change of the original issuance output of 1.00000014)
  - 0.99872851 to an address controlled by Frank (change to Frank)

Daniel sent to the inputs of the transaction 1.00000014 bitcoins and 
receives back 1.00969614. This gives to Daniel the 0.00969600 paid by 
Frank. On the other side, Frank sends 1.23242454 as an input of the 
transaction and receives back 1.22272854 bitcoins, thus paying exactly 
the 0.00969600 that needs to be paid to Daniel. This transaction sends 3 
tokens from Daniel to Frank. Another 11 tokens are the tokens that are 
given as a change to Daniel, along with 0.23200000 bitcoins.

Specification
=============

Definitions
-----------
In order to evaluate a transaction, the outputs are sorted by the 
satoshis value. Once sorted, we define a "cut" output the first output 
having five zeros as the last five digits of the satoshi value (satoshis 
modulo 10^5 == 0). In the following, "first", "second", "last" are all 
referred to the sorted outputs.

We define as "signal" of an output the value of satoshis of the output 
modulo 10^5. This is the last five digits of the value, as expressed in 
satoshis.

Despite not mandatory, we sometimes call "c", or "change", the output 
having the biggest value in Satoshi. This is the last output, as sorted 
above. Such behavior follows the "Guidelines" section, explained below.

We use n=0 related to a sequence a1, ..., an, to indicate that there are 
no elements in the sequence.

Issuance of a token
-------------------
A transaction that has only one output, or has the first output that is 
a cut, issues no token. Every other Bitcoin transaction is an issuance 
of tokens of the type of the transaction.

When a issuance is open, Power of Continuation (POC), will be given to 
an output that will be spent in a transaction that continues the 
issuance of the same type of tokens.

As for the protocol behavior, we divide the structure of the sorted 
outputs of a bitcoin transaction in the following groups. For each 
group, a description of the behavior of the protocol is provided.

  - a1, ..., an, cut(POC), z1(POC), ... zm(POC), b1, ..., bl, with n>0, 
m>=0, m+l>0
      * zi are outputs signaling zero. They are optional.
      * This is an open issuance. It generates the number of tokens 
signaled by the outputs before the cut: a1, ..., an. Every output of 
that set receives a number of tokens as signaled by the output satoshis' 
value.
      * The cut output, and every other output zi, signaling zero, that 
is directly after the cut, receive the POC. This means that the 
transactions that will spend the POC will be a continuation of this 
issuance and a continuation of every issuance that gave the POC to the 
this transaction.
  - cut, b1, ..., bm with m>0 (a cut alone is a case of the fourth type)
      * This is a particular case of the first group, having n=0 and 
m=0. This transaction *closes the issuance forever*. Every token's chain 
that ends into this transaction is closed as well.
      * It generates no tokens and there are no other outputs that can 
continue the issuance in the future.
      * If b1 or b2 have a signal of zero and m>2, this is a token 
offering issuance transaction. It will be described in a following section.
  - a1, ..., an, c(POC) with n>0
      * This is an open issuance. It generates the number of tokens that 
are signaled in a1, ..., an. The last output c will not receive tokens.
      * The last output c will receive the POC. A following transaction 
that spends the output c is an issuance transaction of the same type of 
token.
      * The fact that c is a cut (or not) does not modify the behavior 
of the transactions of this group
  - c(POC) (single output, also seen as the previous one, with n=0)
      * This transaction generates no tokens at all.
      * The output c receives the POC. Thus a following transaction that 
spends the output c is an issuance transaction of the same type of token.

Notes on token issuances
------------------------
The number of tokens generated by an issuance transaction is always the 
sum of the signals of all the outputs, excluding the last one and the 
outputs that are listed after a cut. Thus the number of tokens sent to 
each output, that receives tokens, is always the number signaled by the 
output.

Who has the power to generate other tokens of the same issuance (POC):

  - If there is no cut, the issuance is open and the transaction that 
will spend the last (biggest) output can continue to generate token of 
the same type.
  - If there is a cut, in a position different than the first, the 
issuance is open. The cut output will be the input of a following 
transaction that issues more tokens of the same issuance chain. The 
following transaction can close tha chain, or can be an open issuance, 
thus having another output that will continue the generation chain.

In order to close forever the issuance of tokens, the transaction should 
have a cut as the first output and have more than one output.

Transfer of tokens
------------------
Every bitcoin transaction spends all the tokens' content of the inputs 
and sends them to the outputs. Some of the outputs receive the number of 
tokens exactly stated in the last five digits of the satoshis sent (the 
signal), in a way similar to an issuance transaction.

A transaction can be seen as having one of the three following shapes 
(ai means an output that is not a cut, bi and c are outputs that can be 
cut):

  - a1, ..., an, cut, b1, ..., bm, c (transactions with a cut) (n=0 is 
described here)
      * No output (bi) after a cut receives tokens.
      * Tokens will be assigned to outputs a1, ..., an trying to follow 
the signal as follows:
          - If there are enough tokens, the tokens signaled by the first 
output are assigned to that output.
          - If there are still remaining tokens, the tokens are sent to 
the following output based on the signal.
          - This continues until there is a cut or the tokens signaled 
by an output are more than the remaining tokens. In these cases:
              * If there is a cut, it receives all the remaining tokens.
              * If there is an output receiving more tokens than the 
remaining tokens (we define it a "remaining error"), the output receives 
no token at all. No other output will receive tokens after this and all 
the remaining tokens will be sent to the last output c (thus, if there 
is a cut in the transaction, the algorithm "jumps" the cut).
              * If there is a "remaining error" and the transaction is a 
special transaction as defined in the next section, and the number of 
tokens in input is exactly the same of the two types (big and small) 
that are the result of a previous split or join special transaction, the 
"remaining error" output gets one of the smallest tokens involved. This 
will be better explained in the following section about "special 
transactions".
      * If the first output is a cut, and the transaction is not a 
special one as defined below in the document, the last output (c) 
receives all the tokens
  - a1, ..., an, c (ai is not a cut, for every i; c can be a cut)
      * The tokens are assigned to a1, ..., an as described in the 
previous group.
      * The last output c receives all the remaining tokens. This 
behavior is not modified by the fact that the last output is a cut.
  - c (single output transaction, also seen as the previous one, with n=0)
      * The output receives all the tokens received from the inputs

Transactions receiving both the POC of an issuance and some tokens of 
the same issuance
---------------------------------------------------------------------------------------
The protocol is designed such that a transaction of an issuance chain 
never issue new tokens to an output, that receives the POC of the same 
type of token. But two different inputs can give to a transaction both 
some tokens and the POC of the same type of token. In this case, there 
is a double role for the transaction that is both a continuation of the 
issuance and a transfer transaction sending tokens of the same type.

In this case, the tokens will be allocated as defined in the following 
four different shapes of transaction:

  - a1, ..., an, cut, b1, ..., bm, c (transaction with a cut)
      * The generated tokens are sent to the outputs a1, ..., an as 
described in the definition of an issuance of tokens
      * All the tokens received in input of the same type of the 
issuance we are continuing will be sent to the cut output
  - a1, ..., an, c (transaction without a cut, or with c that is a cut: 
ai is not a cut, for every i)
      * The generated tokens are sent to the outputs a1, ..., an as 
described in the definition of an issuance of tokens transaction
      * All the tokens received in input, of the same type of the 
issuance we are continuing, will be sent to the last output c
  - cut, b1, ..., bm
      * The issuance will be closed and all the tokens will be given to 
the last output bm. The behavior described in the issuance transaction 
and in the transaction sending tokens do not influence each other, in 
this case.
      * If it is a special transaction, as defined below, there is no 
overlap between the definitions. The issuance chain is closed and the 
received tokens will be given as defined.
  - c only
      * The definitions of issuance transaction and transfer transaction 
can be used. The issuance will remain open and the address will receive 
all the tokens received from the inputs

Since both the first and the second group of transactions are giving the 
POC to the same output that receives the tokens, the output will 
continue to carry both the tokens received and the POC. This delegates 
someone to issue new tokens and allocates some tokens from a previous 
issuance that are still not assigned.

Split and join transactions
---------------------------
A split or join transaction is one that has one of the following formats 
of outputs:

  - cut, a1, ..., an, z, b1, ..., bm (z is an output signaling zero, 
like a cut)
  - cut, a1, ..., an, c

having the added condition that the sum of the signals of the outputs 
a1, ..., an is:

  - equal to the number of tokens received in input divided by 1000 (we 
call it a join transaction), or
  - equal to the number of tokens received in input multiplied by 1000 
(we call it a split transaction)

Since the presence of these two extra conditions, the fact that a 
transaction is a join or split transaction, or it is not (hence it is a 
simple transfer transaction), depends on the number of tokens received 
in the input. A given transaction can be both split or join for some 
type of tokens, and normal for other types of tokens.

Note: this is the same format that closes an issuance chain. If the 
transaction receives both POC and tokens of the same type, the 
transaction chain will be closed and the received tokens will be sent as 
described here.

Note: this is also the format of a transfer transaction that assigns to 
the change c or bm, the token received in the input. But, if a 
transaction is a special one of the first two types, that behavior 
should not be considered and no tokens will be transferred to the change.

The split transaction generates a new type of tokens with a value that 
is one thousandth of the value of the type of tokens received in the 
input. This new type can be mixed with tokens generated by other similar 
split transactions, based on the same original token. Split tokens have 
the same value and can be joined in the future with join transactions.

The join transaction generates a new type of tokens with one thousand 
times the value of the type of tokens received in the input. This new 
type of token can coexist with tokens generated by other similar join 
transactions, based on the same original token. Joined tokens from the 
same original token, have the same value and can be split in the future 
with split transactions. Thus becoming again original tokens.

In a special transaction of the second group, without "the second cut" 
z, the change is mandatory and does not receive tokens. This means that 
the number of tokens sent is summed up without the last output. If the 
number is not correct, then it is not a split or join transaction.

Tokens split or joined are of a different type than their original 
source. This means that they can coexist in the same output and will 
never mix together. Thus a output having 3 big tokens and 456 tokens 
obtained by a split transaction, seems to have 3.456 tokens, but, in 
fact, has 3 tokens of a type and 456 tokens of another type (the second 
type is referred as the original type with a 0.001 unit of measure).

Note: as described below, there is a procedure of separating tokens of 
different types contained in the same output. This procedure will not 
work if the two type of tokens are present in the same output in the 
same number. Thus if an output contains exactly 3.003 tokens (3 big and 
3 small), the tokens cannot be separated anymore. This is why we 
introduced, in the transfer transaction definition, the rule that 
assigns in this case one single token of the smallest type to the 
"remaining error" output.

Token offering issuance transactions
------------------------------------
A token offering issuance transaction is a transaction having one of the 
following formats (z is an output signaling zero, like a cut; r and s 
are outputs that signal a value greater than zero; the group of outputs 
(t1, t2, z) is optional; t1 or t2 can signal zero, but not both):

  - cut, z, r, (t1, t2, z,) a1, ..., an, c
      * price of tokens are predefined
  - cut, s, z, (t1, t2, z,) a1, ..., an, c
      * price of tokens are not predefined

The tokens will be assigned to one of the outputs of every transaction 
that sends bitcoin to the address of the outputs r or s, as follows:
  - if the sending transaction has only two outputs (r, c), (c, r), (s, 
c) or (c, s), the "other" output c receives the tokens.
  - if the sending transaction has more than two outputs, the last 
(biggest) output that is not the one sending bitcoins to r or s, will 
receive the tokens.
  - if the sending transaction has only one output, the generated tokens 
will be assigned to the output r or s itself. This can be considered as 
a donation: it generates tokens, but the tokens remain in the 
availability of the issuer.
  - since the number of token emitted is always an integer, the 
remaining satoshis are not considered in the number of tokens issued and 
are sent to the issuer without any token generation.

Note: this is the second place, in this document, where the bitcoin 
address of an output is used. The other place regards the alternate 
names of an issuance. Everything else in the protocol is based on 
outputs, not addresses.

If the group (t1, t2, z) is present, it signals how many token will be 
issued. The total number of tokens that will be issued is the number 
signaled by t1 * 10^6 + the number signaled by t2. In any block, the 
issuance can be closed by the transaction that spends the outputs r or s.

Timeline:
  - The offer starts in the block that contains the token offering 
issuance transaction. Every transaction of the starting block receives 
tokens, without order.
  - If there is a defined total number of tokens, the issuance will end 
when the total number of tokens has been reached.
      * Inside the last block, the transactions are considered in the 
order they are listed. So if a transaction takes the last tokens, every 
other transaction sending bitcoins to r or s, do not receive tokens.
  - The transaction that spends the outputs r or s ends the issuance. 
This transaction suspends the issuance even if a defined number of 
tokens was defined in the token offering issuance transaction.
      * In case of an issuance suspeded, or ended, by a transaction 
spending r or s, every transaction of the block containing the spending 
transaction will be considered valid as a receiver of tokens.
      * Thus, sending bitcoins to the address of the outputs r or s will 
be considered as part of the offering, only if it is included in a block 
between the block of the transaction that has r or s as an output 
(start), and the block of the transaction that spends the output r or s 
(end), inclusive.

A token offering issuance transaction of the first type permits to set a 
rate, and to issue tokens every time bitcoins are received by an 
address. The rate is defined by the number signaled by the output r. One 
token will be issued for every r satoshis received.

A token offering issuance transaction of the second type does not set a 
predefined rate at the start. The rate will be defined by the 
transaction that closes the issuance by spending the output s. The first 
(smallest) output of the closing transaction, or the first output after 
the cut (if a cut is present), will signal the rate. This type of token 
offering issuance, having the price defined at the end, permits to issue 
token based on parameters related to the issuance itself. This is the 
case, for example, of Dutch Auctions.

Note: A token offering issuance transaction can be seen as a transfer 
transaction, that sends all the tokens that receives to the output c.

Note: the type of token issued is defined by the token offering issuance 
transaction, seen as an issuance transaction. Since a token offering 
transaction is also the closure of some issuing chains, this means that 
the same token offer will issue different type of tokens. In fact, a 
different type of token will be issued for every issuance chain that 
ends with the same token offering issuance transaction. Thus a token 
type can be first issued in a controlled way (this is usually called 
pre-ICO) and then the rate can be stated, and the same type of token can 
be offered to the public (this is usually called the ICO). Since the 
token offering issuance transaction closes the issuance forever, there 
is the guarantee that no other tokens of the same type will ever be 
issued after the offer is closed. In order to offer tokens at different 
prices, multiple issuance transactions can be generated with POCs 
originating from the same issuance chain.

Atomic transactions between bitcoins and tokens
-----------------------------------------------
Using the cut signal and software that allows full "coin selection", 
it's possible to make atomic exchange transactions. The outputs before 
the cut will determine who will receive the tokens and the following 
outputs will define the rest of the transaction. Both the changes (the 
one of the token wallet and the one of the Bitcoin wallet), should be in 
the second set (after the cut). Since the cut will receive the remaining 
tokens, it is suggested that the cut is sent to the seller of tokens. 
Using this method, the remaining tokens can be sent without involving a 
calculation of the remaining tokens. The outputs of an atomic exchange 
transaction will have the following format (seller is the token seller, 
buyer is the token buyer).

  - a1: tokens sent from the seller to the buyer
  - a2: tokens sent from the seller to the buyer
  - cut: part of the bitcoin payment sent from buyer to seller
  - b1: part of the bitcoin payment sent from buyer to seller (or change 
sent from seller to buyer, if the price to be paid is less than the 
value of the cut)
  - b2: Bitcoin change sent to the token wallet
  - b3: Bitcoin change sent to the bitcoin wallet

It is impossible to make an atomic exchange transaction if the wallet in 
use does not allow coin selection.

Cross token atomic transactions
-------------------------------
Let's say that Alice wants to sell a number x of tokens of type Ta and 
Bob wants to pay using y tokens of type Tb. Token of type Tb are of 
lesser value than the tokens of type Ta, so Bob will pay more Tb tokens 
and Alice will pay fewer Ta tokens (x < y). Let's say that the 
transaction spends an output from Alice containing BTCa bitcoins and 
*exactly* x tokens, while Bob sends to the same transaction BTCb 
bitcoins and a number z of tokens of type Tb. Since z > y, Bob will 
receive a change c in tokens of type Tb.

Alice managed the previous transactions so that a fixed number x of 
tokens can be sent as the input with a number BTCa of bitcoins. Bob is 
not required do the same, because there is the cut that gives the 
remaining tokens back to Bob. In order to simplify let's say that there 
is another input giving the fee for the transaction and the Bitcoin 
assigned to each output will be calculated accordingly.

The atomic transaction can be made by signaling with the first output 
the number y of tokens that Bob should pay to Alice. This output will go 
to Alice. Since y is higher than x, all the x tokens of type Ta will go 
to the change (directed to Bob), while the y tokens of type Tb will go 
to the first output. A following cut can be used to send the change to 
Bob. The addresses following the cut can be used as changes of bitcoins.

The inputs of the transaction will have a content in Bitcoin and tokens 
as follows:

  - Alice will spend an output having BTCa bitcoins and containing 
*exactly* x tokens of type Ta
  - Bob will spend an output having BTCb bitcoins and containing y + c 
tokens of type Tb

The outputs of the transaction will have the following form:

  - Bitcoin sent: BTCa1; Signal sent: y; Directed to Alice (the output 
gets y tokens of type Tb, but does not get any token of type Ta, because 
x < y)
  - Bitcoin sent: BTCb1; Signal sent: cut; Directed to Bob (no token of 
type Ta given, but receives c tokens of type Tb)
  - Bitcoin sent: BTCa - BTCa1; Signal sent: not important; Directed to 
Alice (no token sent, but useful to send a change in Bitcoin to Alice, 
if needed)
  - Bitcoin sent: BTCb - BTCb1; Signal sent: not important; Directed to 
Bob (this output gets number x tokens of type Ta)

Cross token atomic transactions in the case of the same number of tokens 
to be exchanged
----------------------------------------------------------------------------------------
The atomic transactions described above do not work if the value of 
tokens of type Ta is equal to the value of tokens of type Tb. In this 
case, there is no way of doing an atomic exchange.

Let's say that we need to do a transaction between two tokens that have 
the same value: TetherA and TetherB. Let's say that Alice and Bob want 
to change 199 tokens. The atomic transaction cannot be made, but, with a 
small risk, two transactions can be made. The first will be an atomic 
transaction giving 100 tokens of type TetherA from Alice to Bob and 
receiving 99 of type TetherB back, and the second will be 99 to 100.

How to separate different types of token
----------------------------------------
Let's say that an output contains two different types of tokens of 
interest to the user. Is there a way to separate the tokens so that they 
can be sent to different outputs? If the tokens are exactly the same 
number, there is not. If the tokens are two different numbers: x tokens 
of type A and y tokens of type B, then the separation can be done. Since 
the "remaining error" of an output goes to the change, we can send the 
higher value of the two and have the change receive the lower. We assume 
that x < y.

Let's call A1 the output that will receive A and B1 the output that will 
receive the tokens of type B.

The transaction will be similar to the cross token atomic transaction:

  - Signal sent: x (the output gets x tokens of type B, but does not get 
any token of type A, because x < y)
  - Signal sent: cut (no token of type A given, but receives a change in 
token of type B if the previous signal was less than y)
  - Other outputs
  - Signal sent: not important (this output gets number x tokens of type A)

Guidelines
==========
There are some suggestions that, if followed by the user, permit 
managing tokens in a simple manner, without technical knowledge of the 
rest of the protocol, with plausible deniability. This can be done using 
any existing wallet.

The guidelines described here are based on a wallet that will be 
"consolidated". This means that all the outputs of the wallet are linked 
toghether. In some cases, this behavior diminish the level of privacy of 
the user. Thus, it is advised to use a number of different wallets, in 
order to reach the desired level of privacy.

Plausible deniability: how to use a wallet to manage tokens
-----------------------------------------------------------
Some of the protocol's operations are designed to be managed using a 
coin selection software, however, any wallet without coin selection can 
be used to generate, send, or receive tokens. The option to use any 
existing Bitcoin wallet is the base of the plausible deniability of the 
protocol. The user can send, receive and generate tokens by using any 
wallet in a way that seems a normal use of the Bitcoin protocol to 
manage bitcoins.

Thus, the guidelines in this section are based on a use of a wallet by a 
user without involving any "coin selection".

In order to send or generate tokens, the user needs to have, at any 
time, only one output in the wallet. Let's call it a "consolidated" 
wallet. In order to consolidate a wallet:

  - Send all the bitcoins contained in the wallet to a new address of 
the same wallet

If the user departs from these guidelines by mistake, he can "fix" his 
wallet and re-consolidate it without losing the tokens contained in the 
wallet. If the wallet is consolidated, it remains consolidated while 
tokens are generated or sent, and while bitcoins from the wallet are 
spent. If bitcoins or tokens are received by any address of the wallet, 
then the wallet needs to be consolidated again.

Issuance of tokens
------------------
In order to generate tokens:

  - Consolidate the wallet if it is not already consolidated.
  - Send a minority of the bitcoins contained in the wallet to a new 
address (outside of the wallet). The last five digits of the satoshis 
sent are the number of tokens generated.
  - From the same wallet, other tokens can be generated by sending again 
a number of satoshis, having the last five digits that are the number of 
tokens to issue to the new address.
  - The value of bitcoins sent should always be less than the bitcoin 
that remains in the wallet
  - If during the process of generating tokens the wallet receives 
bitcoins, it should be consolidated again before continuing to generate 
tokens.
  - The type (or name) of tokens will be the txid of the transaction. If 
the transaction sends bitcoin to a new, never used, address, the address 
can be used as the name of the tokens, as well.

In order to give the power to generate new tokens to another person:

  - Send all the Bitcoin content of the wallet to the other person, with 
a single transaction

In order to close an issuance:

  - To close the issuance and guarantee that no other tokens of this 
type will ever be generated again, send to another address of the same 
wallet a number of bitcoins with the last five digits of the satoshis 
that is zero. Be aware that this shouldn't be all the content of the 
wallet. If all the content of the wallet is sent to some address, the 
issuance will not be closed. Instead, this gives to the receiver the 
power to generate new tokens.

Spending bitcoins and not tokens
--------------------------------
In order to spend bitcoins from the wallet without sending any tokens, 
the user should spend less than half of the bitcoin value contained in 
the wallet, and:

  - Spend a number of satoshis where the last five digits are all zeros,
  or
  - Spend a number of satoshis where the last five digits are a number 
greater than the tokens that are in the wallet,

Transfer of tokens
------------------
In order to send tokens to another person:

  - Consolidate the wallet if it is not already consolidated.
  - Send a value less than half of the content of the wallet and having 
the number of satoshis where the last five digits are the number of 
tokens that need to be transferred,
  or
  - Send all the bitcoins of the wallet (even if the wallet is not 
consolidated).

If the user sends all the content of the wallet to a single address (no 
change), then he's emptying the token content from the wallet, as well. 
All the tokens will go to the address and nothing will remain to the user.

In order to receive tokens from other users:

  - Give to the other person a Bitcoin address of the wallet and ask to 
send tokens as explained above.
  - If the wallet was empty before of receiving tokens, then it is 
already consolidated. Instead, if the wallet already had some bitcoins, 
then the wallet needs to be consolidated before sending or generating 
tokens.

Effects of the use of these guidelines
--------------------------------------
When using the guidelines, the number of tokens sent to the recipient is 
always stated in the last five digits of the satoshis sent. There are 
three exceptions:

  - In a single output transaction, all the tokens of the wallet will be 
sent to the recipient.
  - In a transaction where the amount of satoshis sent ends with five 
zeros, no tokens are sent.
  - In a transaction sending more tokens than the number of tokens of 
that type held in the wallet, no tokens are sent.

Technical notes
---------------
  - Sending a number of bitcoins that is greater than half of the 
bitcoins contained in the wallet brings to unpredicted results.
  - Thus, if there are not enough bitcoins to continue to operate, the 
wallet needs to be "re-charged" by sending some bitcoins to it. By doing 
so, there will be more than one UTXO in the wallet. This departs from 
"consolidated mode" and the wallet needs to be consolidated again.
  - A consolidated wallet contains only one UTXO.
  - Every transaction made from a consolidated wallet contains only two 
outputs: one is the address outside of the wallet, and the other is the 
change.
  - Every transaction spends all the content of the wallet.

Reference Implementation
========================
A reference implementation will be included when the protocol will be 
reviewed and accepted by the community.

From stick at satoshilabs.com  Wed Sep  6 17:02:59 2017
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Wed, 6 Sep 2017 19:02:59 +0200
Subject: [bitcoin-dev] Proposal: bip32 version bytes for segwit scripts
In-Reply-To: <201709051303.43410.luke@dashjr.org>
References: <43636dd6-ab9e-da15-59ae-f31eb11ff7ff@electrum.org>
	<201709051303.43410.luke@dashjr.org>
Message-ID: <64a6ae8c-f553-8930-50b0-5681ab7ca75b@satoshilabs.com>

On 05/09/17 19:03, Luke Dashjr via bitcoin-dev wrote:
> I think it makes more sense to use a child number field for this purpose.
> It seems desirable to use the same seed for all different script formats...

If I were designing the serialization format today, I would drop the
fingerprint and expand child number to full BIP32 path. Good thing is
that we already have depth, so we know how long the BIP32 path would be.

So I suggest the following:

4 byte: version bytes
1 byte: depth
depth * 4 bytes: bip32 path
32 bytes
33 bytes

-- 
Best Regards / S pozdravom,

Pavol "stick" Rusnak
CTO, SatoshiLabs

From luca at token21.com  Wed Sep  6 18:32:47 2017
From: luca at token21.com (Luca Venturini)
Date: Wed, 6 Sep 2017 20:32:47 +0200
Subject: [bitcoin-dev] [BIP Proposal] Token Protocol Specification
In-Reply-To: <E76332FD-4B67-49F2-9E36-8EE66D490193@droplister.com>
References: <a72b52aa-10b5-d256-280b-a72cac3bf92d@token21.com>
	<E76332FD-4B67-49F2-9E36-8EE66D490193@droplister.com>
Message-ID: <31863284-d944-b90c-8e62-7d4f38d39476@token21.com>

Hi Dan,

thank you for your feedback. Let me clarify that the plausible 
deniability is a property of the protocol. If this will become a BIP, 
and will be approved, there will be wallets that will manage tokens. In 
the meantime, and in the future, it is important that a person with a 
legacy bitcoin wallet can hold, issue and transfer bitcoins without 
disclose that there are tokens involved. Tokens are contained in Bitcoin 
transactions without any modification.

Vanity addresses are on option. They are not mandatory. In situations 
where plausible deniability is a concern they will, probably, not be used.

Sending to someone 0.23000012 bitcoin is really easy. You don't need any 
form of math and you are sending exactly 12 tokens from your wallet. 
Sometimes it is suspect, but sending 0.03423122 in order to send 23122 
tokens does not seem suspect to me. The large majority of the 
transactions have strange numbers like this one.

In the document, when I say "wallet" I mean every single bitcoin wallet 
that you can use today to hold bitcoins. The base of the plausible 
deniability is that there is no "special" wallet involved. Maybe there 
will be special wallets to manage tokens, but they are not mandatory. 
The consolidation is needed only when using wallets that do not allow 
coin selection.

The state of the tokens is fully contained in the bitcoin blockchain. 
There is no need for verification nodes, nor for any other software. 
Maybe you already issued some tokens using this protocol and I cannot 
know it. Unless you disclose it.

There is no "special" need to create small outputs. In order to send a 
transaction containing tokens, you need to send a bitcoin transaction. 
The bitcoin value will be transfered along with the token value. If you 
issue tokens with a token offering transactions (aka ICO), the value of 
the bitcoin transferred to you is exactly the price of the tokens, so 
there is no "extra" bitcoin value involved.

I'm sorry if the example of the corporation is not clear. The idea was 
only that Alice receives from the shareholders the bitcoin value, in 
order to use that same value to give back the tokens. There is no 
interest. As I wrote, people got equity for "time, money, furniture, 
knowledge". I could simply write that Alice sends small outputs without 
receiving the underlying bitcoin value beforehand.

I agree that memorable names are great to social scalability. This is 
why you can use a vanity address or only the first part of the vanity 
address to identify a token type.

Cheers,

Luca

On 09/06/2017 07:24 PM, Dan Anderson wrote:
> Hi Luca,
>
> Here are some comments...
>
> 1. This is clever, but it has a lot of "gotchas" that I think will work against its ability to scale socially. Especially, when you suggest that following the rules by memory/manually gains users the most advantage in terms of deniability.
>
> 2. The plausible deniability of this protocol is suspect as it would seem fairy apparent to a third party that it was being used. Vanity addresses, satoshis adding to tidy amounts, frequent "consolidation". Especially, when you make a mistake and perform actions to try again.
>
> 3. In your docs, when you say "wallet" do you mean a single Bitcoin address or do you mean an HD wallet? I become confused while reading. Address vs same wallet vs other wallet.
>
> 4. It's not clear to me how this protocol does not need verification nodes or some kind of node software to compute state.
>
> 5. I don't think it's a given that this design will cause less UTXOs. I could see people creating many small outputs as a result of trying to get the right amount of signal satoshis.
>
> 6. In your example of a corporation, it seems like people got equity for free. Why do they need to send 1 BTC at all, if they just get it back, plus interest?
>
> 7. I wouldn't underestimate the value of memorable names for social scalability.
>
> I will keep thinking about it, as the ICO portion is something I have been looking for ideas on and I have similar reservations about existing token protocols, so I hope these comments help you.
>
> ---------------------------------
> Dan Anderson
>


From luke at dashjr.org  Wed Sep  6 18:58:44 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Wed, 6 Sep 2017 14:58:44 -0400
Subject: [bitcoin-dev] [BIP Proposal] Token Protocol Specification
In-Reply-To: <a72b52aa-10b5-d256-280b-a72cac3bf92d@token21.com>
References: <a72b52aa-10b5-d256-280b-a72cac3bf92d@token21.com>
Message-ID: <201709061458.46420.luke@dashjr.org>

I think you could check out and coordinate with the OpenAssets proposal.

Your current draft also claims to solve a lot of problems that it doesn't 
actually solve technically...

Luke


On Wednesday 06 September 2017 11:44:47 Luca Venturini via bitcoin-dev wrote:
> Hi everyone,
> 
> I would like to propose a standard protocol to manage tokens on top of
> the Bitcoin blockchain.
> 
> The full text is enclosed and can be found here:
> 
> https://github.com/token21/token-protocol-specification
> 
> Any feedback will be appreciated.
> 
> Luca Venturini
> 
> ---
> 
> Abstract
> ========
> This document describes a protocol to manage digital assets (tokens) on
> top of the bitcoin blockchain. The protocol enables a semantic layer
> that permits reading the bitcoin transactions as operations related to
> tokens.
> 
> The protocol allows a new level of plausible deniability, while
> permitting statefull public auditability on each issued token. It allows
> both the user and the issuer to deny that an existing bitcoin
> transaction between the two is actually a token transaction, or a new
> token issuance. While both the token sender and the token issuer cannot
> deny to have sent bitcoins, nobody can prove the transaction was related
> to a digital asset. On top of that, to guarantee plausible deniability,
> tokens can be issued, sent, and received using any existing bitcoin
> client software.
> 
> There is no need to have a wallet exclusively dedicated to manage the
> tokens. With a few simple precautions by the user, tokens can be managed
> using any existing Bitcoin wallet, while it is used for normal bitcoin
> transactions as well.
> 
> Since it is possible to infinitely split a token in parts, there is no
> definition of the number of decimals of token generated and transferred.
> The number of tokens is always an integer.
> 
> Every operation of the protocol is performed with Bitcoin transactions,
> without the use of OP_RETURN and without any form of pollution of the
> blockchain, or of the UTXO set.
> 
> The protocol permits atomic buy and sell transactions between tokens and
> Bitcoin, and between different types of tokens. The only operations that
> require a coin selection enabled wallet are the split and join special
> operations and the token offering issuance operations. Those are used to
> modify the token unit of measure and to receive bitcoins from third
> parties during a token offering issuance.
> 
> Copyright
> =========
> This document is licensed under the 2-clause BSD license.
> 
> Motivation
> ==========
> The current protocols that permit to issue tokens based on the bitcoin
> blockchain (i.e. Counterparty, Omni, Colored Coins, Coinprism, Colu) are
> flawed.
> 
> The existing solutions usually need dedicated wallets and/or
> verification nodes. Usually, a "pivot" currency is involved and atomic
> transactions are not permitted unless they use the pivot currency. Those
> protocols pollute the blockchain (30% or more) and in some cases they do
> not accept P2SH scripts. Since the use of a dedicated wallet is
> required, the users cannot plausibly deny they have got tokens.
> Plausible deniability on the issuer side is not available either. None
> of these protocols permits infinite division of the tokens, so usually
> the number of decimals has to be specified at issuance time. The
> automatic token offering issuance is not enabled as well.
> 
> Rationale
> =========
> Let's take an example from the real world, a yacht. We write on the
> yacht's license that the owner is any person that can show a one dollar
> bill having the serial number F82119977F. Thus the one dollar bill can
> be exchanged between owners with extreme simplicity and full plausible
> deniability. The US government will guarantee that there is no other
> person having the same dollar bill.
> 
> The protocol permits managing a token in the same way. The underlying
> Bitcoin protocol will guarantee against double spending.
> 
> Features:
> 
>   - Easy of use. Tokens can be managed using any wallet. Even if the
> wallet has no coin selection feature.
>   - Plausible Deniability by the issuer. The issuer can generate a new
> type of token and nobody analyzing the blockchain will understand that
> the transaction is issuing a token. Even if a token is known, the issuer
> can issue other tokens. Since a single output contains a large number of
> different token types, the issuer is actually generating different types
> of tokens every time she sends a new Bitcoin transaction to the network.
>   - Plausible Deniability by the user (no use of tokens at all, or use
> of a different token type). A transaction that sends tokens from Alice
> to Bob is a normal transaction. Nobody can understand that this
> transaction is moving tokens unless they explicitly know which
> transaction is the token issuance. In fact a single address contains a
> large number of token types, and the use of tokens itself can be denied.
>   - Accountability. Everybody can see the state of the distribution of a
> type of token.
>   - Tunnel mode (confidentiality by issuer and user versus a third
> party). Alice can send tokens to Bob and ask him to give the tokens to
> Charlie, without telling to Bob what is the type of the token given.
> Alice can disclose this information in the future, if she wants.
>   - It is possible to perform open or closed issuances. While an open
> issuance permits to continue the issuance of tokens in the future,
> closed issuance guarantees that no other token of the same type will
> ever be issued.
>   - The power to continue the issuance of an open token can be sent to
> another address, using a transaction. Once the power to continue the
> issuance is sent to someone, the former issuer cannot issue any more
> tokens. - The power to continue the issuance has the same features of
> plausible deniability of the possess of a token.
>   - Since a token type is uniquely identified by a transaction hash, or,
> in some cases, by a Bitcoin address, a user can prove to be the issuer
> by signing a message using the Bitcoin protocol.
>   - Future proof. Tokens can move following P2PKH, P2SH, P2SH-P2WPKH
> outputs or any other type of script
>   - Blockchain pollution of the protocol transactions is almost zero.
> There is no OP_RETURN involved, nor any other type of "fake" addresses
> that pollute the UTXO database.
>   - The protocol is based on the Bitcoin blockchain, but, with small
> changes, can be considered blockchain agnostic.
>   - Atomic transactions between tokens and Bitcoin are possible.
>   - Atomic transactions between different types of tokens are possible.
>   - Tokens of different types can be held by the same address and by the
> same output.
>   - Tokens can be divided indefintely, thus having any number of decimals.
>   - Tokens can be issued automatically on the receiving of bitcoins.
> This operation performs a token offering issuance (also known as Initial
> Coin Offering).
> 
> Introduction
> ============
> 
> Where are the tokens?
> ---------------------
> As with bitcoins, tokens are contained in unspent Bitcoin outputs. In
> some cases, defined below, the last five digits of the satoshi value
> sent to the output represent the number of tokens contained in the output.
> 
> When an output is spent, the tokens contained in the output are fully
> spent in the same transaction. There are no tokens outside of the tokens
> contained in the UTXO database.
> 
> Token issuance
> --------------
> The large majority of bitcoin transactions can be semantically seen as
> token issuances. There are two types of token issuances: closed and
> opened. A closed token issuance guarantees that no other token of the
> same type will ever be issued.
> 
> Issuance chains
> ---------------
> An open issuance gives to one, or more, of its output the power to
> continue the issuance of tokens of the same type. We define such a power
> as Power of Continuation (POC). The transaction that will spend the
> output appointed with the POC will be a continuation of the same
> issuance chain.
> 
> Every transaction of the chain will issue the same type of token. On top
> of that, every transaction that is part of the chain, can also be seen
> as as issuance of tokens of its, new, type. A chain will be closed by a
> transaction having more than one output and the first output with five
> zeros as the last five digits of the satoshis value. No other
> transactions can send tokens of the same type after the close of the
> issuance.
> 
> Token names
> -----------
> A token type can have multiple names. The default name is the hash of
> the first transaction that issued the token.
> 
> i.e: 68330b6ab26e44f9c3e515f04d15ffe6547f29e60b809a47e50d9abf59045c1e
> 
> As alternative names, a token type can be named after the bitcoin
> address of one of the outputs of the transaction that first issued the
> token, provided the fact that the address has never been used before in
> the blockchain.
> 
> Note: it is better to use one of the alternate names in cases when
> transaction malleability is a concern.
> 
> Vanity token names
> ------------------
> A token can be identified using only the first characters of the Bitcoin
> address, as alternate name defined above, if the characters are
> different from every previous Bitcoin address seen in the blockchain. An
> example is provided below.
> 
> Tokens can coexist
> -------------------
> Token of different types can coexist in a single output while remaining
> of different types. Thus a bitcoin address (actually an output of the
> UTXO database) can hold tokens of different types. Every Bitcoin address
> contains a lot of types of tokens, so that a user usually does not know
> all the type of tokens contained in an address.
> 
> A single transaction can send a type of token to some of the outputs
> while sending another type of token to a different set of its outputs.
> Tokens are never burned or deleted.
> 
> Use the protocol
> ================
> This section explains a basic use case. In all the examples provided, we
> do not consider the fee. We assume that there is another input, not
> listed, that pays the transaction fee.
> 
> Alice, Bob, Charlie, and Daniel decides that they want to start a new
> company. Each of them will give to the new company some time, money,
> furniture, knowledge. They decide everyone contributed to the company
> with a percentage of value as follows: Alice - 40%, Bob - 12%, Charlie -
> 34% and Daniel - 14%. They decide that the shares of the new company can
> be freely resold to others and that they will accept that the annual
> meeting will consent vote through messages signed using the Bitcoin
> protocol by the owners of the shares.
> 
> Issue tokens
> ------------
> Alice asks Bob, Charlie, and Daniel to send her 1 Bitcoin each. She asks
> each of them to give her a bitcoin address where they want to receive
> back the bitcoins along with the tokens.
> 
> She asks Charlie to generate a vanity address that has never been used
> before of type 1CompanyXWXjLgud9jxwxm34u.... Since there has been a
> previous address in the blockchain having 1Companx as the first
> characters, but this is the first address seen in the blockchain that
> has 1Company as the first characters, they will call the token with the
> name 1Company. This step is optional.
> 
> Then she sends, from her wallet, a transaction having the following
> outputs:
> 
>   - 1.00000040 to an address controlled by Alice
>   - 1.00000012 to an address controlled by Bob
>   - 1.00000034 to the vanity address 1CompanyXWXjLgud9jxwxm34u...
> controlled by Charlie
>   - 1.00000014 to an address controlled by Daniel
>   - 3.45322112 is the change generated by Alice's wallet
> 
> This transaction gives 40, 12, 34, 14 tokens to each one. The newly
> generated token type can be named after the transaction hash, or after
> the vanity address (optional), or after one of the addresses of the
> persons involved, provided that the address has never been used before.
> 
> The issuance is still open. Since they do not want to issue more shares,
> they decide to close the issuance (on the other side, they could decide
> to leave the issuance open and to hold the issuing key somewhere, or to
> have a multisignature address and to give the keys to the directors of
> the company). In order to close the issuance, Alice generates the
> following transaction that sends bitcoins from her wallet to addresses
> of her same wallet, using the change output of the previous transaction
> as an input:
> 
>   - 0.45000000 to an address of her wallet
>   - 3.00322112 change generated by the wallet
> 
> This closes the issuance.
> 
> Send tokens
> --------------
> After some while, Bob decides to give some shares of the company to his
> husband Giacomo. He generates a new transaction spending the output of
> the issuance transaction:
> 
>   - 0.03400008 to Giacomo
>   - 0.96600004 change generated by Bob's wallet
> 
> This transaction gives to Giacomo 8 shares of the company.
> 
> Atomic transactions
> -------------------
> Daniel wants to sell 3 of his 14 shares to Frank. They negotiate a price
> of 0.00323200 bitcoin per share. This is a total of 0.00969600 bitcoin
> to buy the three shares. They do not know each other very well, so they
> decide to make an atomic transaction that will give 0.00969600 bitcoins
> to Daniel and 3 shares to Frank. Daniel set an input of the new
> transaction with his issuance transaction output. Frank put in another
> input of 1.23242454 bitcoins from his wallet. The outputs of the
> transaction are as follows:
> 
>   - 0.22400003 to an address controlled by Frank (this gives the 3
> shares to Frank)
>   - 0.23200000 to an address controlled by Daniel (this is part of the
> payment to Daniel)
>   - 0.77769614 to an address controlled by Daniel (this can be
> considered the change of the original issuance output of 1.00000014)
>   - 0.99872851 to an address controlled by Frank (change to Frank)
> 
> Daniel sent to the inputs of the transaction 1.00000014 bitcoins and
> receives back 1.00969614. This gives to Daniel the 0.00969600 paid by
> Frank. On the other side, Frank sends 1.23242454 as an input of the
> transaction and receives back 1.22272854 bitcoins, thus paying exactly
> the 0.00969600 that needs to be paid to Daniel. This transaction sends 3
> tokens from Daniel to Frank. Another 11 tokens are the tokens that are
> given as a change to Daniel, along with 0.23200000 bitcoins.
> 
> Specification
> =============
> 
> Definitions
> -----------
> In order to evaluate a transaction, the outputs are sorted by the
> satoshis value. Once sorted, we define a "cut" output the first output
> having five zeros as the last five digits of the satoshi value (satoshis
> modulo 10^5 == 0). In the following, "first", "second", "last" are all
> referred to the sorted outputs.
> 
> We define as "signal" of an output the value of satoshis of the output
> modulo 10^5. This is the last five digits of the value, as expressed in
> satoshis.
> 
> Despite not mandatory, we sometimes call "c", or "change", the output
> having the biggest value in Satoshi. This is the last output, as sorted
> above. Such behavior follows the "Guidelines" section, explained below.
> 
> We use n=0 related to a sequence a1, ..., an, to indicate that there are
> no elements in the sequence.
> 
> Issuance of a token
> -------------------
> A transaction that has only one output, or has the first output that is
> a cut, issues no token. Every other Bitcoin transaction is an issuance
> of tokens of the type of the transaction.
> 
> When a issuance is open, Power of Continuation (POC), will be given to
> an output that will be spent in a transaction that continues the
> issuance of the same type of tokens.
> 
> As for the protocol behavior, we divide the structure of the sorted
> outputs of a bitcoin transaction in the following groups. For each
> group, a description of the behavior of the protocol is provided.
> 
>   - a1, ..., an, cut(POC), z1(POC), ... zm(POC), b1, ..., bl, with n>0,
> m>=0, m+l>0
>       * zi are outputs signaling zero. They are optional.
>       * This is an open issuance. It generates the number of tokens
> signaled by the outputs before the cut: a1, ..., an. Every output of
> that set receives a number of tokens as signaled by the output satoshis'
> value.
>       * The cut output, and every other output zi, signaling zero, that
> is directly after the cut, receive the POC. This means that the
> transactions that will spend the POC will be a continuation of this
> issuance and a continuation of every issuance that gave the POC to the
> this transaction.
>   - cut, b1, ..., bm with m>0 (a cut alone is a case of the fourth type)
>       * This is a particular case of the first group, having n=0 and
> m=0. This transaction *closes the issuance forever*. Every token's chain
> that ends into this transaction is closed as well.
>       * It generates no tokens and there are no other outputs that can
> continue the issuance in the future.
>       * If b1 or b2 have a signal of zero and m>2, this is a token
> offering issuance transaction. It will be described in a following section.
>   - a1, ..., an, c(POC) with n>0
>       * This is an open issuance. It generates the number of tokens that
> are signaled in a1, ..., an. The last output c will not receive tokens.
>       * The last output c will receive the POC. A following transaction
> that spends the output c is an issuance transaction of the same type of
> token.
>       * The fact that c is a cut (or not) does not modify the behavior
> of the transactions of this group
>   - c(POC) (single output, also seen as the previous one, with n=0)
>       * This transaction generates no tokens at all.
>       * The output c receives the POC. Thus a following transaction that
> spends the output c is an issuance transaction of the same type of token.
> 
> Notes on token issuances
> ------------------------
> The number of tokens generated by an issuance transaction is always the
> sum of the signals of all the outputs, excluding the last one and the
> outputs that are listed after a cut. Thus the number of tokens sent to
> each output, that receives tokens, is always the number signaled by the
> output.
> 
> Who has the power to generate other tokens of the same issuance (POC):
> 
>   - If there is no cut, the issuance is open and the transaction that
> will spend the last (biggest) output can continue to generate token of
> the same type.
>   - If there is a cut, in a position different than the first, the
> issuance is open. The cut output will be the input of a following
> transaction that issues more tokens of the same issuance chain. The
> following transaction can close tha chain, or can be an open issuance,
> thus having another output that will continue the generation chain.
> 
> In order to close forever the issuance of tokens, the transaction should
> have a cut as the first output and have more than one output.
> 
> Transfer of tokens
> ------------------
> Every bitcoin transaction spends all the tokens' content of the inputs
> and sends them to the outputs. Some of the outputs receive the number of
> tokens exactly stated in the last five digits of the satoshis sent (the
> signal), in a way similar to an issuance transaction.
> 
> A transaction can be seen as having one of the three following shapes
> (ai means an output that is not a cut, bi and c are outputs that can be
> cut):
> 
>   - a1, ..., an, cut, b1, ..., bm, c (transactions with a cut) (n=0 is
> described here)
>       * No output (bi) after a cut receives tokens.
>       * Tokens will be assigned to outputs a1, ..., an trying to follow
> the signal as follows:
>           - If there are enough tokens, the tokens signaled by the first
> output are assigned to that output.
>           - If there are still remaining tokens, the tokens are sent to
> the following output based on the signal.
>           - This continues until there is a cut or the tokens signaled
> by an output are more than the remaining tokens. In these cases:
>               * If there is a cut, it receives all the remaining tokens.
>               * If there is an output receiving more tokens than the
> remaining tokens (we define it a "remaining error"), the output receives
> no token at all. No other output will receive tokens after this and all
> the remaining tokens will be sent to the last output c (thus, if there
> is a cut in the transaction, the algorithm "jumps" the cut).
>               * If there is a "remaining error" and the transaction is a
> special transaction as defined in the next section, and the number of
> tokens in input is exactly the same of the two types (big and small)
> that are the result of a previous split or join special transaction, the
> "remaining error" output gets one of the smallest tokens involved. This
> will be better explained in the following section about "special
> transactions".
>       * If the first output is a cut, and the transaction is not a
> special one as defined below in the document, the last output (c)
> receives all the tokens
>   - a1, ..., an, c (ai is not a cut, for every i; c can be a cut)
>       * The tokens are assigned to a1, ..., an as described in the
> previous group.
>       * The last output c receives all the remaining tokens. This
> behavior is not modified by the fact that the last output is a cut.
>   - c (single output transaction, also seen as the previous one, with n=0)
>       * The output receives all the tokens received from the inputs
> 
> Transactions receiving both the POC of an issuance and some tokens of
> the same issuance
> ---------------------------------------------------------------------------
> ------------ The protocol is designed such that a transaction of an
> issuance chain never issue new tokens to an output, that receives the POC
> of the same type of token. But two different inputs can give to a
> transaction both some tokens and the POC of the same type of token. In
> this case, there is a double role for the transaction that is both a
> continuation of the issuance and a transfer transaction sending tokens of
> the same type.
> 
> In this case, the tokens will be allocated as defined in the following
> four different shapes of transaction:
> 
>   - a1, ..., an, cut, b1, ..., bm, c (transaction with a cut)
>       * The generated tokens are sent to the outputs a1, ..., an as
> described in the definition of an issuance of tokens
>       * All the tokens received in input of the same type of the
> issuance we are continuing will be sent to the cut output
>   - a1, ..., an, c (transaction without a cut, or with c that is a cut:
> ai is not a cut, for every i)
>       * The generated tokens are sent to the outputs a1, ..., an as
> described in the definition of an issuance of tokens transaction
>       * All the tokens received in input, of the same type of the
> issuance we are continuing, will be sent to the last output c
>   - cut, b1, ..., bm
>       * The issuance will be closed and all the tokens will be given to
> the last output bm. The behavior described in the issuance transaction
> and in the transaction sending tokens do not influence each other, in
> this case.
>       * If it is a special transaction, as defined below, there is no
> overlap between the definitions. The issuance chain is closed and the
> received tokens will be given as defined.
>   - c only
>       * The definitions of issuance transaction and transfer transaction
> can be used. The issuance will remain open and the address will receive
> all the tokens received from the inputs
> 
> Since both the first and the second group of transactions are giving the
> POC to the same output that receives the tokens, the output will
> continue to carry both the tokens received and the POC. This delegates
> someone to issue new tokens and allocates some tokens from a previous
> issuance that are still not assigned.
> 
> Split and join transactions
> ---------------------------
> A split or join transaction is one that has one of the following formats
> of outputs:
> 
>   - cut, a1, ..., an, z, b1, ..., bm (z is an output signaling zero,
> like a cut)
>   - cut, a1, ..., an, c
> 
> having the added condition that the sum of the signals of the outputs
> a1, ..., an is:
> 
>   - equal to the number of tokens received in input divided by 1000 (we
> call it a join transaction), or
>   - equal to the number of tokens received in input multiplied by 1000
> (we call it a split transaction)
> 
> Since the presence of these two extra conditions, the fact that a
> transaction is a join or split transaction, or it is not (hence it is a
> simple transfer transaction), depends on the number of tokens received
> in the input. A given transaction can be both split or join for some
> type of tokens, and normal for other types of tokens.
> 
> Note: this is the same format that closes an issuance chain. If the
> transaction receives both POC and tokens of the same type, the
> transaction chain will be closed and the received tokens will be sent as
> described here.
> 
> Note: this is also the format of a transfer transaction that assigns to
> the change c or bm, the token received in the input. But, if a
> transaction is a special one of the first two types, that behavior
> should not be considered and no tokens will be transferred to the change.
> 
> The split transaction generates a new type of tokens with a value that
> is one thousandth of the value of the type of tokens received in the
> input. This new type can be mixed with tokens generated by other similar
> split transactions, based on the same original token. Split tokens have
> the same value and can be joined in the future with join transactions.
> 
> The join transaction generates a new type of tokens with one thousand
> times the value of the type of tokens received in the input. This new
> type of token can coexist with tokens generated by other similar join
> transactions, based on the same original token. Joined tokens from the
> same original token, have the same value and can be split in the future
> with split transactions. Thus becoming again original tokens.
> 
> In a special transaction of the second group, without "the second cut"
> z, the change is mandatory and does not receive tokens. This means that
> the number of tokens sent is summed up without the last output. If the
> number is not correct, then it is not a split or join transaction.
> 
> Tokens split or joined are of a different type than their original
> source. This means that they can coexist in the same output and will
> never mix together. Thus a output having 3 big tokens and 456 tokens
> obtained by a split transaction, seems to have 3.456 tokens, but, in
> fact, has 3 tokens of a type and 456 tokens of another type (the second
> type is referred as the original type with a 0.001 unit of measure).
> 
> Note: as described below, there is a procedure of separating tokens of
> different types contained in the same output. This procedure will not
> work if the two type of tokens are present in the same output in the
> same number. Thus if an output contains exactly 3.003 tokens (3 big and
> 3 small), the tokens cannot be separated anymore. This is why we
> introduced, in the transfer transaction definition, the rule that
> assigns in this case one single token of the smallest type to the
> "remaining error" output.
> 
> Token offering issuance transactions
> ------------------------------------
> A token offering issuance transaction is a transaction having one of the
> following formats (z is an output signaling zero, like a cut; r and s
> are outputs that signal a value greater than zero; the group of outputs
> (t1, t2, z) is optional; t1 or t2 can signal zero, but not both):
> 
>   - cut, z, r, (t1, t2, z,) a1, ..., an, c
>       * price of tokens are predefined
>   - cut, s, z, (t1, t2, z,) a1, ..., an, c
>       * price of tokens are not predefined
> 
> The tokens will be assigned to one of the outputs of every transaction
> that sends bitcoin to the address of the outputs r or s, as follows:
>   - if the sending transaction has only two outputs (r, c), (c, r), (s,
> c) or (c, s), the "other" output c receives the tokens.
>   - if the sending transaction has more than two outputs, the last
> (biggest) output that is not the one sending bitcoins to r or s, will
> receive the tokens.
>   - if the sending transaction has only one output, the generated tokens
> will be assigned to the output r or s itself. This can be considered as
> a donation: it generates tokens, but the tokens remain in the
> availability of the issuer.
>   - since the number of token emitted is always an integer, the
> remaining satoshis are not considered in the number of tokens issued and
> are sent to the issuer without any token generation.
> 
> Note: this is the second place, in this document, where the bitcoin
> address of an output is used. The other place regards the alternate
> names of an issuance. Everything else in the protocol is based on
> outputs, not addresses.
> 
> If the group (t1, t2, z) is present, it signals how many token will be
> issued. The total number of tokens that will be issued is the number
> signaled by t1 * 10^6 + the number signaled by t2. In any block, the
> issuance can be closed by the transaction that spends the outputs r or s.
> 
> Timeline:
>   - The offer starts in the block that contains the token offering
> issuance transaction. Every transaction of the starting block receives
> tokens, without order.
>   - If there is a defined total number of tokens, the issuance will end
> when the total number of tokens has been reached.
>       * Inside the last block, the transactions are considered in the
> order they are listed. So if a transaction takes the last tokens, every
> other transaction sending bitcoins to r or s, do not receive tokens.
>   - The transaction that spends the outputs r or s ends the issuance.
> This transaction suspends the issuance even if a defined number of
> tokens was defined in the token offering issuance transaction.
>       * In case of an issuance suspeded, or ended, by a transaction
> spending r or s, every transaction of the block containing the spending
> transaction will be considered valid as a receiver of tokens.
>       * Thus, sending bitcoins to the address of the outputs r or s will
> be considered as part of the offering, only if it is included in a block
> between the block of the transaction that has r or s as an output
> (start), and the block of the transaction that spends the output r or s
> (end), inclusive.
> 
> A token offering issuance transaction of the first type permits to set a
> rate, and to issue tokens every time bitcoins are received by an
> address. The rate is defined by the number signaled by the output r. One
> token will be issued for every r satoshis received.
> 
> A token offering issuance transaction of the second type does not set a
> predefined rate at the start. The rate will be defined by the
> transaction that closes the issuance by spending the output s. The first
> (smallest) output of the closing transaction, or the first output after
> the cut (if a cut is present), will signal the rate. This type of token
> offering issuance, having the price defined at the end, permits to issue
> token based on parameters related to the issuance itself. This is the
> case, for example, of Dutch Auctions.
> 
> Note: A token offering issuance transaction can be seen as a transfer
> transaction, that sends all the tokens that receives to the output c.
> 
> Note: the type of token issued is defined by the token offering issuance
> transaction, seen as an issuance transaction. Since a token offering
> transaction is also the closure of some issuing chains, this means that
> the same token offer will issue different type of tokens. In fact, a
> different type of token will be issued for every issuance chain that
> ends with the same token offering issuance transaction. Thus a token
> type can be first issued in a controlled way (this is usually called
> pre-ICO) and then the rate can be stated, and the same type of token can
> be offered to the public (this is usually called the ICO). Since the
> token offering issuance transaction closes the issuance forever, there
> is the guarantee that no other tokens of the same type will ever be
> issued after the offer is closed. In order to offer tokens at different
> prices, multiple issuance transactions can be generated with POCs
> originating from the same issuance chain.
> 
> Atomic transactions between bitcoins and tokens
> -----------------------------------------------
> Using the cut signal and software that allows full "coin selection",
> it's possible to make atomic exchange transactions. The outputs before
> the cut will determine who will receive the tokens and the following
> outputs will define the rest of the transaction. Both the changes (the
> one of the token wallet and the one of the Bitcoin wallet), should be in
> the second set (after the cut). Since the cut will receive the remaining
> tokens, it is suggested that the cut is sent to the seller of tokens.
> Using this method, the remaining tokens can be sent without involving a
> calculation of the remaining tokens. The outputs of an atomic exchange
> transaction will have the following format (seller is the token seller,
> buyer is the token buyer).
> 
>   - a1: tokens sent from the seller to the buyer
>   - a2: tokens sent from the seller to the buyer
>   - cut: part of the bitcoin payment sent from buyer to seller
>   - b1: part of the bitcoin payment sent from buyer to seller (or change
> sent from seller to buyer, if the price to be paid is less than the
> value of the cut)
>   - b2: Bitcoin change sent to the token wallet
>   - b3: Bitcoin change sent to the bitcoin wallet
> 
> It is impossible to make an atomic exchange transaction if the wallet in
> use does not allow coin selection.
> 
> Cross token atomic transactions
> -------------------------------
> Let's say that Alice wants to sell a number x of tokens of type Ta and
> Bob wants to pay using y tokens of type Tb. Token of type Tb are of
> lesser value than the tokens of type Ta, so Bob will pay more Tb tokens
> and Alice will pay fewer Ta tokens (x < y). Let's say that the
> transaction spends an output from Alice containing BTCa bitcoins and
> *exactly* x tokens, while Bob sends to the same transaction BTCb
> bitcoins and a number z of tokens of type Tb. Since z > y, Bob will
> receive a change c in tokens of type Tb.
> 
> Alice managed the previous transactions so that a fixed number x of
> tokens can be sent as the input with a number BTCa of bitcoins. Bob is
> not required do the same, because there is the cut that gives the
> remaining tokens back to Bob. In order to simplify let's say that there
> is another input giving the fee for the transaction and the Bitcoin
> assigned to each output will be calculated accordingly.
> 
> The atomic transaction can be made by signaling with the first output
> the number y of tokens that Bob should pay to Alice. This output will go
> to Alice. Since y is higher than x, all the x tokens of type Ta will go
> to the change (directed to Bob), while the y tokens of type Tb will go
> to the first output. A following cut can be used to send the change to
> Bob. The addresses following the cut can be used as changes of bitcoins.
> 
> The inputs of the transaction will have a content in Bitcoin and tokens
> as follows:
> 
>   - Alice will spend an output having BTCa bitcoins and containing
> *exactly* x tokens of type Ta
>   - Bob will spend an output having BTCb bitcoins and containing y + c
> tokens of type Tb
> 
> The outputs of the transaction will have the following form:
> 
>   - Bitcoin sent: BTCa1; Signal sent: y; Directed to Alice (the output
> gets y tokens of type Tb, but does not get any token of type Ta, because
> x < y)
>   - Bitcoin sent: BTCb1; Signal sent: cut; Directed to Bob (no token of
> type Ta given, but receives c tokens of type Tb)
>   - Bitcoin sent: BTCa - BTCa1; Signal sent: not important; Directed to
> Alice (no token sent, but useful to send a change in Bitcoin to Alice,
> if needed)
>   - Bitcoin sent: BTCb - BTCb1; Signal sent: not important; Directed to
> Bob (this output gets number x tokens of type Ta)
> 
> Cross token atomic transactions in the case of the same number of tokens
> to be exchanged
> ---------------------------------------------------------------------------
> ------------- The atomic transactions described above do not work if the
> value of tokens of type Ta is equal to the value of tokens of type Tb. In
> this case, there is no way of doing an atomic exchange.
> 
> Let's say that we need to do a transaction between two tokens that have
> the same value: TetherA and TetherB. Let's say that Alice and Bob want
> to change 199 tokens. The atomic transaction cannot be made, but, with a
> small risk, two transactions can be made. The first will be an atomic
> transaction giving 100 tokens of type TetherA from Alice to Bob and
> receiving 99 of type TetherB back, and the second will be 99 to 100.
> 
> How to separate different types of token
> ----------------------------------------
> Let's say that an output contains two different types of tokens of
> interest to the user. Is there a way to separate the tokens so that they
> can be sent to different outputs? If the tokens are exactly the same
> number, there is not. If the tokens are two different numbers: x tokens
> of type A and y tokens of type B, then the separation can be done. Since
> the "remaining error" of an output goes to the change, we can send the
> higher value of the two and have the change receive the lower. We assume
> that x < y.
> 
> Let's call A1 the output that will receive A and B1 the output that will
> receive the tokens of type B.
> 
> The transaction will be similar to the cross token atomic transaction:
> 
>   - Signal sent: x (the output gets x tokens of type B, but does not get
> any token of type A, because x < y)
>   - Signal sent: cut (no token of type A given, but receives a change in
> token of type B if the previous signal was less than y)
>   - Other outputs
>   - Signal sent: not important (this output gets number x tokens of type A)
> 
> Guidelines
> ==========
> There are some suggestions that, if followed by the user, permit
> managing tokens in a simple manner, without technical knowledge of the
> rest of the protocol, with plausible deniability. This can be done using
> any existing wallet.
> 
> The guidelines described here are based on a wallet that will be
> "consolidated". This means that all the outputs of the wallet are linked
> toghether. In some cases, this behavior diminish the level of privacy of
> the user. Thus, it is advised to use a number of different wallets, in
> order to reach the desired level of privacy.
> 
> Plausible deniability: how to use a wallet to manage tokens
> -----------------------------------------------------------
> Some of the protocol's operations are designed to be managed using a
> coin selection software, however, any wallet without coin selection can
> be used to generate, send, or receive tokens. The option to use any
> existing Bitcoin wallet is the base of the plausible deniability of the
> protocol. The user can send, receive and generate tokens by using any
> wallet in a way that seems a normal use of the Bitcoin protocol to
> manage bitcoins.
> 
> Thus, the guidelines in this section are based on a use of a wallet by a
> user without involving any "coin selection".
> 
> In order to send or generate tokens, the user needs to have, at any
> time, only one output in the wallet. Let's call it a "consolidated"
> wallet. In order to consolidate a wallet:
> 
>   - Send all the bitcoins contained in the wallet to a new address of
> the same wallet
> 
> If the user departs from these guidelines by mistake, he can "fix" his
> wallet and re-consolidate it without losing the tokens contained in the
> wallet. If the wallet is consolidated, it remains consolidated while
> tokens are generated or sent, and while bitcoins from the wallet are
> spent. If bitcoins or tokens are received by any address of the wallet,
> then the wallet needs to be consolidated again.
> 
> Issuance of tokens
> ------------------
> In order to generate tokens:
> 
>   - Consolidate the wallet if it is not already consolidated.
>   - Send a minority of the bitcoins contained in the wallet to a new
> address (outside of the wallet). The last five digits of the satoshis
> sent are the number of tokens generated.
>   - From the same wallet, other tokens can be generated by sending again
> a number of satoshis, having the last five digits that are the number of
> tokens to issue to the new address.
>   - The value of bitcoins sent should always be less than the bitcoin
> that remains in the wallet
>   - If during the process of generating tokens the wallet receives
> bitcoins, it should be consolidated again before continuing to generate
> tokens.
>   - The type (or name) of tokens will be the txid of the transaction. If
> the transaction sends bitcoin to a new, never used, address, the address
> can be used as the name of the tokens, as well.
> 
> In order to give the power to generate new tokens to another person:
> 
>   - Send all the Bitcoin content of the wallet to the other person, with
> a single transaction
> 
> In order to close an issuance:
> 
>   - To close the issuance and guarantee that no other tokens of this
> type will ever be generated again, send to another address of the same
> wallet a number of bitcoins with the last five digits of the satoshis
> that is zero. Be aware that this shouldn't be all the content of the
> wallet. If all the content of the wallet is sent to some address, the
> issuance will not be closed. Instead, this gives to the receiver the
> power to generate new tokens.
> 
> Spending bitcoins and not tokens
> --------------------------------
> In order to spend bitcoins from the wallet without sending any tokens,
> the user should spend less than half of the bitcoin value contained in
> the wallet, and:
> 
>   - Spend a number of satoshis where the last five digits are all zeros,
>   or
>   - Spend a number of satoshis where the last five digits are a number
> greater than the tokens that are in the wallet,
> 
> Transfer of tokens
> ------------------
> In order to send tokens to another person:
> 
>   - Consolidate the wallet if it is not already consolidated.
>   - Send a value less than half of the content of the wallet and having
> the number of satoshis where the last five digits are the number of
> tokens that need to be transferred,
>   or
>   - Send all the bitcoins of the wallet (even if the wallet is not
> consolidated).
> 
> If the user sends all the content of the wallet to a single address (no
> change), then he's emptying the token content from the wallet, as well.
> All the tokens will go to the address and nothing will remain to the user.
> 
> In order to receive tokens from other users:
> 
>   - Give to the other person a Bitcoin address of the wallet and ask to
> send tokens as explained above.
>   - If the wallet was empty before of receiving tokens, then it is
> already consolidated. Instead, if the wallet already had some bitcoins,
> then the wallet needs to be consolidated before sending or generating
> tokens.
> 
> Effects of the use of these guidelines
> --------------------------------------
> When using the guidelines, the number of tokens sent to the recipient is
> always stated in the last five digits of the satoshis sent. There are
> three exceptions:
> 
>   - In a single output transaction, all the tokens of the wallet will be
> sent to the recipient.
>   - In a transaction where the amount of satoshis sent ends with five
> zeros, no tokens are sent.
>   - In a transaction sending more tokens than the number of tokens of
> that type held in the wallet, no tokens are sent.
> 
> Technical notes
> ---------------
>   - Sending a number of bitcoins that is greater than half of the
> bitcoins contained in the wallet brings to unpredicted results.
>   - Thus, if there are not enough bitcoins to continue to operate, the
> wallet needs to be "re-charged" by sending some bitcoins to it. By doing
> so, there will be more than one UTXO in the wallet. This departs from
> "consolidated mode" and the wallet needs to be consolidated again.
>   - A consolidated wallet contains only one UTXO.
>   - Every transaction made from a consolidated wallet contains only two
> outputs: one is the address outside of the wallet, and the other is the
> change.
>   - Every transaction spends all the content of the wallet.
> 
> Reference Implementation
> ========================
> A reference implementation will be included when the protocol will be
> reviewed and accepted by the community.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From luca at token21.com  Wed Sep  6 19:25:16 2017
From: luca at token21.com (Luca Venturini)
Date: Wed, 6 Sep 2017 21:25:16 +0200
Subject: [bitcoin-dev] [BIP Proposal] Token Protocol Specification
In-Reply-To: <201709061458.46420.luke@dashjr.org>
References: <a72b52aa-10b5-d256-280b-a72cac3bf92d@token21.com>
	<201709061458.46420.luke@dashjr.org>
Message-ID: <701cf7e5-ab83-497f-38a3-f5df01b597ce@token21.com>

Hi Luke,

thanks for your feedback.

I can try to coordinate with the OpenAssets group, but the base 
requirements are completely different. For example, they are very far 
from any form of plausible deniability.

Please tell me which problems are not solved technically, so that I can 
try to fix the differences between the claims and the technical part, if 
any.

Luca

On 09/06/2017 08:58 PM, Luke Dashjr wrote:
> I think you could check out and coordinate with the OpenAssets proposal.
>
> Your current draft also claims to solve a lot of problems that it doesn't
> actually solve technically...
>
> Luke
>
>
> On Wednesday 06 September 2017 11:44:47 Luca Venturini via bitcoin-dev wrote:
>> Hi everyone,
>>
>> I would like to propose a standard protocol to manage tokens on top of
>> the Bitcoin blockchain.
>>
>> The full text is enclosed and can be found here:
>>
>> https://github.com/token21/token-protocol-specification
>>
>> Any feedback will be appreciated.
>>
>> Luca Venturini
>>
>> ---
>>
>> Abstract
>> ========
>> This document describes a protocol to manage digital assets (tokens) on
>> top of the bitcoin blockchain. The protocol enables a semantic layer
>> that permits reading the bitcoin transactions as operations related to
>> tokens.
>>
>> The protocol allows a new level of plausible deniability, while
>> permitting statefull public auditability on each issued token. It allows
>> both the user and the issuer to deny that an existing bitcoin
>> transaction between the two is actually a token transaction, or a new
>> token issuance. While both the token sender and the token issuer cannot
>> deny to have sent bitcoins, nobody can prove the transaction was related
>> to a digital asset. On top of that, to guarantee plausible deniability,
>> tokens can be issued, sent, and received using any existing bitcoin
>> client software.
>>
>> There is no need to have a wallet exclusively dedicated to manage the
>> tokens. With a few simple precautions by the user, tokens can be managed
>> using any existing Bitcoin wallet, while it is used for normal bitcoin
>> transactions as well.
>>
>> Since it is possible to infinitely split a token in parts, there is no
>> definition of the number of decimals of token generated and transferred.
>> The number of tokens is always an integer.
>>
>> Every operation of the protocol is performed with Bitcoin transactions,
>> without the use of OP_RETURN and without any form of pollution of the
>> blockchain, or of the UTXO set.
>>
>> The protocol permits atomic buy and sell transactions between tokens and
>> Bitcoin, and between different types of tokens. The only operations that
>> require a coin selection enabled wallet are the split and join special
>> operations and the token offering issuance operations. Those are used to
>> modify the token unit of measure and to receive bitcoins from third
>> parties during a token offering issuance.
>>
>> Copyright
>> =========
>> This document is licensed under the 2-clause BSD license.
>>
>> Motivation
>> ==========
>> The current protocols that permit to issue tokens based on the bitcoin
>> blockchain (i.e. Counterparty, Omni, Colored Coins, Coinprism, Colu) are
>> flawed.
>>
>> The existing solutions usually need dedicated wallets and/or
>> verification nodes. Usually, a "pivot" currency is involved and atomic
>> transactions are not permitted unless they use the pivot currency. Those
>> protocols pollute the blockchain (30% or more) and in some cases they do
>> not accept P2SH scripts. Since the use of a dedicated wallet is
>> required, the users cannot plausibly deny they have got tokens.
>> Plausible deniability on the issuer side is not available either. None
>> of these protocols permits infinite division of the tokens, so usually
>> the number of decimals has to be specified at issuance time. The
>> automatic token offering issuance is not enabled as well.
>>
>> Rationale
>> =========
>> Let's take an example from the real world, a yacht. We write on the
>> yacht's license that the owner is any person that can show a one dollar
>> bill having the serial number F82119977F. Thus the one dollar bill can
>> be exchanged between owners with extreme simplicity and full plausible
>> deniability. The US government will guarantee that there is no other
>> person having the same dollar bill.
>>
>> The protocol permits managing a token in the same way. The underlying
>> Bitcoin protocol will guarantee against double spending.
>>
>> Features:
>>
>>   - Easy of use. Tokens can be managed using any wallet. Even if the
>> wallet has no coin selection feature.
>>   - Plausible Deniability by the issuer. The issuer can generate a new
>> type of token and nobody analyzing the blockchain will understand that
>> the transaction is issuing a token. Even if a token is known, the issuer
>> can issue other tokens. Since a single output contains a large number of
>> different token types, the issuer is actually generating different types
>> of tokens every time she sends a new Bitcoin transaction to the network.
>>   - Plausible Deniability by the user (no use of tokens at all, or use
>> of a different token type). A transaction that sends tokens from Alice
>> to Bob is a normal transaction. Nobody can understand that this
>> transaction is moving tokens unless they explicitly know which
>> transaction is the token issuance. In fact a single address contains a
>> large number of token types, and the use of tokens itself can be denied.
>>   - Accountability. Everybody can see the state of the distribution of a
>> type of token.
>>   - Tunnel mode (confidentiality by issuer and user versus a third
>> party). Alice can send tokens to Bob and ask him to give the tokens to
>> Charlie, without telling to Bob what is the type of the token given.
>> Alice can disclose this information in the future, if she wants.
>>   - It is possible to perform open or closed issuances. While an open
>> issuance permits to continue the issuance of tokens in the future,
>> closed issuance guarantees that no other token of the same type will
>> ever be issued.
>>   - The power to continue the issuance of an open token can be sent to
>> another address, using a transaction. Once the power to continue the
>> issuance is sent to someone, the former issuer cannot issue any more
>> tokens. - The power to continue the issuance has the same features of
>> plausible deniability of the possess of a token.
>>   - Since a token type is uniquely identified by a transaction hash, or,
>> in some cases, by a Bitcoin address, a user can prove to be the issuer
>> by signing a message using the Bitcoin protocol.
>>   - Future proof. Tokens can move following P2PKH, P2SH, P2SH-P2WPKH
>> outputs or any other type of script
>>   - Blockchain pollution of the protocol transactions is almost zero.
>> There is no OP_RETURN involved, nor any other type of "fake" addresses
>> that pollute the UTXO database.
>>   - The protocol is based on the Bitcoin blockchain, but, with small
>> changes, can be considered blockchain agnostic.
>>   - Atomic transactions between tokens and Bitcoin are possible.
>>   - Atomic transactions between different types of tokens are possible.
>>   - Tokens of different types can be held by the same address and by the
>> same output.
>>   - Tokens can be divided indefintely, thus having any number of decimals.
>>   - Tokens can be issued automatically on the receiving of bitcoins.
>> This operation performs a token offering issuance (also known as Initial
>> Coin Offering).
>>
>> Introduction
>> ============
>>
>> Where are the tokens?
>> ---------------------
>> As with bitcoins, tokens are contained in unspent Bitcoin outputs. In
>> some cases, defined below, the last five digits of the satoshi value
>> sent to the output represent the number of tokens contained in the output.
>>
>> When an output is spent, the tokens contained in the output are fully
>> spent in the same transaction. There are no tokens outside of the tokens
>> contained in the UTXO database.
>>
>> Token issuance
>> --------------
>> The large majority of bitcoin transactions can be semantically seen as
>> token issuances. There are two types of token issuances: closed and
>> opened. A closed token issuance guarantees that no other token of the
>> same type will ever be issued.
>>
>> Issuance chains
>> ---------------
>> An open issuance gives to one, or more, of its output the power to
>> continue the issuance of tokens of the same type. We define such a power
>> as Power of Continuation (POC). The transaction that will spend the
>> output appointed with the POC will be a continuation of the same
>> issuance chain.
>>
>> Every transaction of the chain will issue the same type of token. On top
>> of that, every transaction that is part of the chain, can also be seen
>> as as issuance of tokens of its, new, type. A chain will be closed by a
>> transaction having more than one output and the first output with five
>> zeros as the last five digits of the satoshis value. No other
>> transactions can send tokens of the same type after the close of the
>> issuance.
>>
>> Token names
>> -----------
>> A token type can have multiple names. The default name is the hash of
>> the first transaction that issued the token.
>>
>> i.e: 68330b6ab26e44f9c3e515f04d15ffe6547f29e60b809a47e50d9abf59045c1e
>>
>> As alternative names, a token type can be named after the bitcoin
>> address of one of the outputs of the transaction that first issued the
>> token, provided the fact that the address has never been used before in
>> the blockchain.
>>
>> Note: it is better to use one of the alternate names in cases when
>> transaction malleability is a concern.
>>
>> Vanity token names
>> ------------------
>> A token can be identified using only the first characters of the Bitcoin
>> address, as alternate name defined above, if the characters are
>> different from every previous Bitcoin address seen in the blockchain. An
>> example is provided below.
>>
>> Tokens can coexist
>> -------------------
>> Token of different types can coexist in a single output while remaining
>> of different types. Thus a bitcoin address (actually an output of the
>> UTXO database) can hold tokens of different types. Every Bitcoin address
>> contains a lot of types of tokens, so that a user usually does not know
>> all the type of tokens contained in an address.
>>
>> A single transaction can send a type of token to some of the outputs
>> while sending another type of token to a different set of its outputs.
>> Tokens are never burned or deleted.
>>
>> Use the protocol
>> ================
>> This section explains a basic use case. In all the examples provided, we
>> do not consider the fee. We assume that there is another input, not
>> listed, that pays the transaction fee.
>>
>> Alice, Bob, Charlie, and Daniel decides that they want to start a new
>> company. Each of them will give to the new company some time, money,
>> furniture, knowledge. They decide everyone contributed to the company
>> with a percentage of value as follows: Alice - 40%, Bob - 12%, Charlie -
>> 34% and Daniel - 14%. They decide that the shares of the new company can
>> be freely resold to others and that they will accept that the annual
>> meeting will consent vote through messages signed using the Bitcoin
>> protocol by the owners of the shares.
>>
>> Issue tokens
>> ------------
>> Alice asks Bob, Charlie, and Daniel to send her 1 Bitcoin each. She asks
>> each of them to give her a bitcoin address where they want to receive
>> back the bitcoins along with the tokens.
>>
>> She asks Charlie to generate a vanity address that has never been used
>> before of type 1CompanyXWXjLgud9jxwxm34u.... Since there has been a
>> previous address in the blockchain having 1Companx as the first
>> characters, but this is the first address seen in the blockchain that
>> has 1Company as the first characters, they will call the token with the
>> name 1Company. This step is optional.
>>
>> Then she sends, from her wallet, a transaction having the following
>> outputs:
>>
>>   - 1.00000040 to an address controlled by Alice
>>   - 1.00000012 to an address controlled by Bob
>>   - 1.00000034 to the vanity address 1CompanyXWXjLgud9jxwxm34u...
>> controlled by Charlie
>>   - 1.00000014 to an address controlled by Daniel
>>   - 3.45322112 is the change generated by Alice's wallet
>>
>> This transaction gives 40, 12, 34, 14 tokens to each one. The newly
>> generated token type can be named after the transaction hash, or after
>> the vanity address (optional), or after one of the addresses of the
>> persons involved, provided that the address has never been used before.
>>
>> The issuance is still open. Since they do not want to issue more shares,
>> they decide to close the issuance (on the other side, they could decide
>> to leave the issuance open and to hold the issuing key somewhere, or to
>> have a multisignature address and to give the keys to the directors of
>> the company). In order to close the issuance, Alice generates the
>> following transaction that sends bitcoins from her wallet to addresses
>> of her same wallet, using the change output of the previous transaction
>> as an input:
>>
>>   - 0.45000000 to an address of her wallet
>>   - 3.00322112 change generated by the wallet
>>
>> This closes the issuance.
>>
>> Send tokens
>> --------------
>> After some while, Bob decides to give some shares of the company to his
>> husband Giacomo. He generates a new transaction spending the output of
>> the issuance transaction:
>>
>>   - 0.03400008 to Giacomo
>>   - 0.96600004 change generated by Bob's wallet
>>
>> This transaction gives to Giacomo 8 shares of the company.
>>
>> Atomic transactions
>> -------------------
>> Daniel wants to sell 3 of his 14 shares to Frank. They negotiate a price
>> of 0.00323200 bitcoin per share. This is a total of 0.00969600 bitcoin
>> to buy the three shares. They do not know each other very well, so they
>> decide to make an atomic transaction that will give 0.00969600 bitcoins
>> to Daniel and 3 shares to Frank. Daniel set an input of the new
>> transaction with his issuance transaction output. Frank put in another
>> input of 1.23242454 bitcoins from his wallet. The outputs of the
>> transaction are as follows:
>>
>>   - 0.22400003 to an address controlled by Frank (this gives the 3
>> shares to Frank)
>>   - 0.23200000 to an address controlled by Daniel (this is part of the
>> payment to Daniel)
>>   - 0.77769614 to an address controlled by Daniel (this can be
>> considered the change of the original issuance output of 1.00000014)
>>   - 0.99872851 to an address controlled by Frank (change to Frank)
>>
>> Daniel sent to the inputs of the transaction 1.00000014 bitcoins and
>> receives back 1.00969614. This gives to Daniel the 0.00969600 paid by
>> Frank. On the other side, Frank sends 1.23242454 as an input of the
>> transaction and receives back 1.22272854 bitcoins, thus paying exactly
>> the 0.00969600 that needs to be paid to Daniel. This transaction sends 3
>> tokens from Daniel to Frank. Another 11 tokens are the tokens that are
>> given as a change to Daniel, along with 0.23200000 bitcoins.
>>
>> Specification
>> =============
>>
>> Definitions
>> -----------
>> In order to evaluate a transaction, the outputs are sorted by the
>> satoshis value. Once sorted, we define a "cut" output the first output
>> having five zeros as the last five digits of the satoshi value (satoshis
>> modulo 10^5 == 0). In the following, "first", "second", "last" are all
>> referred to the sorted outputs.
>>
>> We define as "signal" of an output the value of satoshis of the output
>> modulo 10^5. This is the last five digits of the value, as expressed in
>> satoshis.
>>
>> Despite not mandatory, we sometimes call "c", or "change", the output
>> having the biggest value in Satoshi. This is the last output, as sorted
>> above. Such behavior follows the "Guidelines" section, explained below.
>>
>> We use n=0 related to a sequence a1, ..., an, to indicate that there are
>> no elements in the sequence.
>>
>> Issuance of a token
>> -------------------
>> A transaction that has only one output, or has the first output that is
>> a cut, issues no token. Every other Bitcoin transaction is an issuance
>> of tokens of the type of the transaction.
>>
>> When a issuance is open, Power of Continuation (POC), will be given to
>> an output that will be spent in a transaction that continues the
>> issuance of the same type of tokens.
>>
>> As for the protocol behavior, we divide the structure of the sorted
>> outputs of a bitcoin transaction in the following groups. For each
>> group, a description of the behavior of the protocol is provided.
>>
>>   - a1, ..., an, cut(POC), z1(POC), ... zm(POC), b1, ..., bl, with n>0,
>> m>=0, m+l>0
>>       * zi are outputs signaling zero. They are optional.
>>       * This is an open issuance. It generates the number of tokens
>> signaled by the outputs before the cut: a1, ..., an. Every output of
>> that set receives a number of tokens as signaled by the output satoshis'
>> value.
>>       * The cut output, and every other output zi, signaling zero, that
>> is directly after the cut, receive the POC. This means that the
>> transactions that will spend the POC will be a continuation of this
>> issuance and a continuation of every issuance that gave the POC to the
>> this transaction.
>>   - cut, b1, ..., bm with m>0 (a cut alone is a case of the fourth type)
>>       * This is a particular case of the first group, having n=0 and
>> m=0. This transaction *closes the issuance forever*. Every token's chain
>> that ends into this transaction is closed as well.
>>       * It generates no tokens and there are no other outputs that can
>> continue the issuance in the future.
>>       * If b1 or b2 have a signal of zero and m>2, this is a token
>> offering issuance transaction. It will be described in a following section.
>>   - a1, ..., an, c(POC) with n>0
>>       * This is an open issuance. It generates the number of tokens that
>> are signaled in a1, ..., an. The last output c will not receive tokens.
>>       * The last output c will receive the POC. A following transaction
>> that spends the output c is an issuance transaction of the same type of
>> token.
>>       * The fact that c is a cut (or not) does not modify the behavior
>> of the transactions of this group
>>   - c(POC) (single output, also seen as the previous one, with n=0)
>>       * This transaction generates no tokens at all.
>>       * The output c receives the POC. Thus a following transaction that
>> spends the output c is an issuance transaction of the same type of token.
>>
>> Notes on token issuances
>> ------------------------
>> The number of tokens generated by an issuance transaction is always the
>> sum of the signals of all the outputs, excluding the last one and the
>> outputs that are listed after a cut. Thus the number of tokens sent to
>> each output, that receives tokens, is always the number signaled by the
>> output.
>>
>> Who has the power to generate other tokens of the same issuance (POC):
>>
>>   - If there is no cut, the issuance is open and the transaction that
>> will spend the last (biggest) output can continue to generate token of
>> the same type.
>>   - If there is a cut, in a position different than the first, the
>> issuance is open. The cut output will be the input of a following
>> transaction that issues more tokens of the same issuance chain. The
>> following transaction can close tha chain, or can be an open issuance,
>> thus having another output that will continue the generation chain.
>>
>> In order to close forever the issuance of tokens, the transaction should
>> have a cut as the first output and have more than one output.
>>
>> Transfer of tokens
>> ------------------
>> Every bitcoin transaction spends all the tokens' content of the inputs
>> and sends them to the outputs. Some of the outputs receive the number of
>> tokens exactly stated in the last five digits of the satoshis sent (the
>> signal), in a way similar to an issuance transaction.
>>
>> A transaction can be seen as having one of the three following shapes
>> (ai means an output that is not a cut, bi and c are outputs that can be
>> cut):
>>
>>   - a1, ..., an, cut, b1, ..., bm, c (transactions with a cut) (n=0 is
>> described here)
>>       * No output (bi) after a cut receives tokens.
>>       * Tokens will be assigned to outputs a1, ..., an trying to follow
>> the signal as follows:
>>           - If there are enough tokens, the tokens signaled by the first
>> output are assigned to that output.
>>           - If there are still remaining tokens, the tokens are sent to
>> the following output based on the signal.
>>           - This continues until there is a cut or the tokens signaled
>> by an output are more than the remaining tokens. In these cases:
>>               * If there is a cut, it receives all the remaining tokens.
>>               * If there is an output receiving more tokens than the
>> remaining tokens (we define it a "remaining error"), the output receives
>> no token at all. No other output will receive tokens after this and all
>> the remaining tokens will be sent to the last output c (thus, if there
>> is a cut in the transaction, the algorithm "jumps" the cut).
>>               * If there is a "remaining error" and the transaction is a
>> special transaction as defined in the next section, and the number of
>> tokens in input is exactly the same of the two types (big and small)
>> that are the result of a previous split or join special transaction, the
>> "remaining error" output gets one of the smallest tokens involved. This
>> will be better explained in the following section about "special
>> transactions".
>>       * If the first output is a cut, and the transaction is not a
>> special one as defined below in the document, the last output (c)
>> receives all the tokens
>>   - a1, ..., an, c (ai is not a cut, for every i; c can be a cut)
>>       * The tokens are assigned to a1, ..., an as described in the
>> previous group.
>>       * The last output c receives all the remaining tokens. This
>> behavior is not modified by the fact that the last output is a cut.
>>   - c (single output transaction, also seen as the previous one, with n=0)
>>       * The output receives all the tokens received from the inputs
>>
>> Transactions receiving both the POC of an issuance and some tokens of
>> the same issuance
>> ---------------------------------------------------------------------------
>> ------------ The protocol is designed such that a transaction of an
>> issuance chain never issue new tokens to an output, that receives the POC
>> of the same type of token. But two different inputs can give to a
>> transaction both some tokens and the POC of the same type of token. In
>> this case, there is a double role for the transaction that is both a
>> continuation of the issuance and a transfer transaction sending tokens of
>> the same type.
>>
>> In this case, the tokens will be allocated as defined in the following
>> four different shapes of transaction:
>>
>>   - a1, ..., an, cut, b1, ..., bm, c (transaction with a cut)
>>       * The generated tokens are sent to the outputs a1, ..., an as
>> described in the definition of an issuance of tokens
>>       * All the tokens received in input of the same type of the
>> issuance we are continuing will be sent to the cut output
>>   - a1, ..., an, c (transaction without a cut, or with c that is a cut:
>> ai is not a cut, for every i)
>>       * The generated tokens are sent to the outputs a1, ..., an as
>> described in the definition of an issuance of tokens transaction
>>       * All the tokens received in input, of the same type of the
>> issuance we are continuing, will be sent to the last output c
>>   - cut, b1, ..., bm
>>       * The issuance will be closed and all the tokens will be given to
>> the last output bm. The behavior described in the issuance transaction
>> and in the transaction sending tokens do not influence each other, in
>> this case.
>>       * If it is a special transaction, as defined below, there is no
>> overlap between the definitions. The issuance chain is closed and the
>> received tokens will be given as defined.
>>   - c only
>>       * The definitions of issuance transaction and transfer transaction
>> can be used. The issuance will remain open and the address will receive
>> all the tokens received from the inputs
>>
>> Since both the first and the second group of transactions are giving the
>> POC to the same output that receives the tokens, the output will
>> continue to carry both the tokens received and the POC. This delegates
>> someone to issue new tokens and allocates some tokens from a previous
>> issuance that are still not assigned.
>>
>> Split and join transactions
>> ---------------------------
>> A split or join transaction is one that has one of the following formats
>> of outputs:
>>
>>   - cut, a1, ..., an, z, b1, ..., bm (z is an output signaling zero,
>> like a cut)
>>   - cut, a1, ..., an, c
>>
>> having the added condition that the sum of the signals of the outputs
>> a1, ..., an is:
>>
>>   - equal to the number of tokens received in input divided by 1000 (we
>> call it a join transaction), or
>>   - equal to the number of tokens received in input multiplied by 1000
>> (we call it a split transaction)
>>
>> Since the presence of these two extra conditions, the fact that a
>> transaction is a join or split transaction, or it is not (hence it is a
>> simple transfer transaction), depends on the number of tokens received
>> in the input. A given transaction can be both split or join for some
>> type of tokens, and normal for other types of tokens.
>>
>> Note: this is the same format that closes an issuance chain. If the
>> transaction receives both POC and tokens of the same type, the
>> transaction chain will be closed and the received tokens will be sent as
>> described here.
>>
>> Note: this is also the format of a transfer transaction that assigns to
>> the change c or bm, the token received in the input. But, if a
>> transaction is a special one of the first two types, that behavior
>> should not be considered and no tokens will be transferred to the change.
>>
>> The split transaction generates a new type of tokens with a value that
>> is one thousandth of the value of the type of tokens received in the
>> input. This new type can be mixed with tokens generated by other similar
>> split transactions, based on the same original token. Split tokens have
>> the same value and can be joined in the future with join transactions.
>>
>> The join transaction generates a new type of tokens with one thousand
>> times the value of the type of tokens received in the input. This new
>> type of token can coexist with tokens generated by other similar join
>> transactions, based on the same original token. Joined tokens from the
>> same original token, have the same value and can be split in the future
>> with split transactions. Thus becoming again original tokens.
>>
>> In a special transaction of the second group, without "the second cut"
>> z, the change is mandatory and does not receive tokens. This means that
>> the number of tokens sent is summed up without the last output. If the
>> number is not correct, then it is not a split or join transaction.
>>
>> Tokens split or joined are of a different type than their original
>> source. This means that they can coexist in the same output and will
>> never mix together. Thus a output having 3 big tokens and 456 tokens
>> obtained by a split transaction, seems to have 3.456 tokens, but, in
>> fact, has 3 tokens of a type and 456 tokens of another type (the second
>> type is referred as the original type with a 0.001 unit of measure).
>>
>> Note: as described below, there is a procedure of separating tokens of
>> different types contained in the same output. This procedure will not
>> work if the two type of tokens are present in the same output in the
>> same number. Thus if an output contains exactly 3.003 tokens (3 big and
>> 3 small), the tokens cannot be separated anymore. This is why we
>> introduced, in the transfer transaction definition, the rule that
>> assigns in this case one single token of the smallest type to the
>> "remaining error" output.
>>
>> Token offering issuance transactions
>> ------------------------------------
>> A token offering issuance transaction is a transaction having one of the
>> following formats (z is an output signaling zero, like a cut; r and s
>> are outputs that signal a value greater than zero; the group of outputs
>> (t1, t2, z) is optional; t1 or t2 can signal zero, but not both):
>>
>>   - cut, z, r, (t1, t2, z,) a1, ..., an, c
>>       * price of tokens are predefined
>>   - cut, s, z, (t1, t2, z,) a1, ..., an, c
>>       * price of tokens are not predefined
>>
>> The tokens will be assigned to one of the outputs of every transaction
>> that sends bitcoin to the address of the outputs r or s, as follows:
>>   - if the sending transaction has only two outputs (r, c), (c, r), (s,
>> c) or (c, s), the "other" output c receives the tokens.
>>   - if the sending transaction has more than two outputs, the last
>> (biggest) output that is not the one sending bitcoins to r or s, will
>> receive the tokens.
>>   - if the sending transaction has only one output, the generated tokens
>> will be assigned to the output r or s itself. This can be considered as
>> a donation: it generates tokens, but the tokens remain in the
>> availability of the issuer.
>>   - since the number of token emitted is always an integer, the
>> remaining satoshis are not considered in the number of tokens issued and
>> are sent to the issuer without any token generation.
>>
>> Note: this is the second place, in this document, where the bitcoin
>> address of an output is used. The other place regards the alternate
>> names of an issuance. Everything else in the protocol is based on
>> outputs, not addresses.
>>
>> If the group (t1, t2, z) is present, it signals how many token will be
>> issued. The total number of tokens that will be issued is the number
>> signaled by t1 * 10^6 + the number signaled by t2. In any block, the
>> issuance can be closed by the transaction that spends the outputs r or s.
>>
>> Timeline:
>>   - The offer starts in the block that contains the token offering
>> issuance transaction. Every transaction of the starting block receives
>> tokens, without order.
>>   - If there is a defined total number of tokens, the issuance will end
>> when the total number of tokens has been reached.
>>       * Inside the last block, the transactions are considered in the
>> order they are listed. So if a transaction takes the last tokens, every
>> other transaction sending bitcoins to r or s, do not receive tokens.
>>   - The transaction that spends the outputs r or s ends the issuance.
>> This transaction suspends the issuance even if a defined number of
>> tokens was defined in the token offering issuance transaction.
>>       * In case of an issuance suspeded, or ended, by a transaction
>> spending r or s, every transaction of the block containing the spending
>> transaction will be considered valid as a receiver of tokens.
>>       * Thus, sending bitcoins to the address of the outputs r or s will
>> be considered as part of the offering, only if it is included in a block
>> between the block of the transaction that has r or s as an output
>> (start), and the block of the transaction that spends the output r or s
>> (end), inclusive.
>>
>> A token offering issuance transaction of the first type permits to set a
>> rate, and to issue tokens every time bitcoins are received by an
>> address. The rate is defined by the number signaled by the output r. One
>> token will be issued for every r satoshis received.
>>
>> A token offering issuance transaction of the second type does not set a
>> predefined rate at the start. The rate will be defined by the
>> transaction that closes the issuance by spending the output s. The first
>> (smallest) output of the closing transaction, or the first output after
>> the cut (if a cut is present), will signal the rate. This type of token
>> offering issuance, having the price defined at the end, permits to issue
>> token based on parameters related to the issuance itself. This is the
>> case, for example, of Dutch Auctions.
>>
>> Note: A token offering issuance transaction can be seen as a transfer
>> transaction, that sends all the tokens that receives to the output c.
>>
>> Note: the type of token issued is defined by the token offering issuance
>> transaction, seen as an issuance transaction. Since a token offering
>> transaction is also the closure of some issuing chains, this means that
>> the same token offer will issue different type of tokens. In fact, a
>> different type of token will be issued for every issuance chain that
>> ends with the same token offering issuance transaction. Thus a token
>> type can be first issued in a controlled way (this is usually called
>> pre-ICO) and then the rate can be stated, and the same type of token can
>> be offered to the public (this is usually called the ICO). Since the
>> token offering issuance transaction closes the issuance forever, there
>> is the guarantee that no other tokens of the same type will ever be
>> issued after the offer is closed. In order to offer tokens at different
>> prices, multiple issuance transactions can be generated with POCs
>> originating from the same issuance chain.
>>
>> Atomic transactions between bitcoins and tokens
>> -----------------------------------------------
>> Using the cut signal and software that allows full "coin selection",
>> it's possible to make atomic exchange transactions. The outputs before
>> the cut will determine who will receive the tokens and the following
>> outputs will define the rest of the transaction. Both the changes (the
>> one of the token wallet and the one of the Bitcoin wallet), should be in
>> the second set (after the cut). Since the cut will receive the remaining
>> tokens, it is suggested that the cut is sent to the seller of tokens.
>> Using this method, the remaining tokens can be sent without involving a
>> calculation of the remaining tokens. The outputs of an atomic exchange
>> transaction will have the following format (seller is the token seller,
>> buyer is the token buyer).
>>
>>   - a1: tokens sent from the seller to the buyer
>>   - a2: tokens sent from the seller to the buyer
>>   - cut: part of the bitcoin payment sent from buyer to seller
>>   - b1: part of the bitcoin payment sent from buyer to seller (or change
>> sent from seller to buyer, if the price to be paid is less than the
>> value of the cut)
>>   - b2: Bitcoin change sent to the token wallet
>>   - b3: Bitcoin change sent to the bitcoin wallet
>>
>> It is impossible to make an atomic exchange transaction if the wallet in
>> use does not allow coin selection.
>>
>> Cross token atomic transactions
>> -------------------------------
>> Let's say that Alice wants to sell a number x of tokens of type Ta and
>> Bob wants to pay using y tokens of type Tb. Token of type Tb are of
>> lesser value than the tokens of type Ta, so Bob will pay more Tb tokens
>> and Alice will pay fewer Ta tokens (x < y). Let's say that the
>> transaction spends an output from Alice containing BTCa bitcoins and
>> *exactly* x tokens, while Bob sends to the same transaction BTCb
>> bitcoins and a number z of tokens of type Tb. Since z > y, Bob will
>> receive a change c in tokens of type Tb.
>>
>> Alice managed the previous transactions so that a fixed number x of
>> tokens can be sent as the input with a number BTCa of bitcoins. Bob is
>> not required do the same, because there is the cut that gives the
>> remaining tokens back to Bob. In order to simplify let's say that there
>> is another input giving the fee for the transaction and the Bitcoin
>> assigned to each output will be calculated accordingly.
>>
>> The atomic transaction can be made by signaling with the first output
>> the number y of tokens that Bob should pay to Alice. This output will go
>> to Alice. Since y is higher than x, all the x tokens of type Ta will go
>> to the change (directed to Bob), while the y tokens of type Tb will go
>> to the first output. A following cut can be used to send the change to
>> Bob. The addresses following the cut can be used as changes of bitcoins.
>>
>> The inputs of the transaction will have a content in Bitcoin and tokens
>> as follows:
>>
>>   - Alice will spend an output having BTCa bitcoins and containing
>> *exactly* x tokens of type Ta
>>   - Bob will spend an output having BTCb bitcoins and containing y + c
>> tokens of type Tb
>>
>> The outputs of the transaction will have the following form:
>>
>>   - Bitcoin sent: BTCa1; Signal sent: y; Directed to Alice (the output
>> gets y tokens of type Tb, but does not get any token of type Ta, because
>> x < y)
>>   - Bitcoin sent: BTCb1; Signal sent: cut; Directed to Bob (no token of
>> type Ta given, but receives c tokens of type Tb)
>>   - Bitcoin sent: BTCa - BTCa1; Signal sent: not important; Directed to
>> Alice (no token sent, but useful to send a change in Bitcoin to Alice,
>> if needed)
>>   - Bitcoin sent: BTCb - BTCb1; Signal sent: not important; Directed to
>> Bob (this output gets number x tokens of type Ta)
>>
>> Cross token atomic transactions in the case of the same number of tokens
>> to be exchanged
>> ---------------------------------------------------------------------------
>> ------------- The atomic transactions described above do not work if the
>> value of tokens of type Ta is equal to the value of tokens of type Tb. In
>> this case, there is no way of doing an atomic exchange.
>>
>> Let's say that we need to do a transaction between two tokens that have
>> the same value: TetherA and TetherB. Let's say that Alice and Bob want
>> to change 199 tokens. The atomic transaction cannot be made, but, with a
>> small risk, two transactions can be made. The first will be an atomic
>> transaction giving 100 tokens of type TetherA from Alice to Bob and
>> receiving 99 of type TetherB back, and the second will be 99 to 100.
>>
>> How to separate different types of token
>> ----------------------------------------
>> Let's say that an output contains two different types of tokens of
>> interest to the user. Is there a way to separate the tokens so that they
>> can be sent to different outputs? If the tokens are exactly the same
>> number, there is not. If the tokens are two different numbers: x tokens
>> of type A and y tokens of type B, then the separation can be done. Since
>> the "remaining error" of an output goes to the change, we can send the
>> higher value of the two and have the change receive the lower. We assume
>> that x < y.
>>
>> Let's call A1 the output that will receive A and B1 the output that will
>> receive the tokens of type B.
>>
>> The transaction will be similar to the cross token atomic transaction:
>>
>>   - Signal sent: x (the output gets x tokens of type B, but does not get
>> any token of type A, because x < y)
>>   - Signal sent: cut (no token of type A given, but receives a change in
>> token of type B if the previous signal was less than y)
>>   - Other outputs
>>   - Signal sent: not important (this output gets number x tokens of type A)
>>
>> Guidelines
>> ==========
>> There are some suggestions that, if followed by the user, permit
>> managing tokens in a simple manner, without technical knowledge of the
>> rest of the protocol, with plausible deniability. This can be done using
>> any existing wallet.
>>
>> The guidelines described here are based on a wallet that will be
>> "consolidated". This means that all the outputs of the wallet are linked
>> toghether. In some cases, this behavior diminish the level of privacy of
>> the user. Thus, it is advised to use a number of different wallets, in
>> order to reach the desired level of privacy.
>>
>> Plausible deniability: how to use a wallet to manage tokens
>> -----------------------------------------------------------
>> Some of the protocol's operations are designed to be managed using a
>> coin selection software, however, any wallet without coin selection can
>> be used to generate, send, or receive tokens. The option to use any
>> existing Bitcoin wallet is the base of the plausible deniability of the
>> protocol. The user can send, receive and generate tokens by using any
>> wallet in a way that seems a normal use of the Bitcoin protocol to
>> manage bitcoins.
>>
>> Thus, the guidelines in this section are based on a use of a wallet by a
>> user without involving any "coin selection".
>>
>> In order to send or generate tokens, the user needs to have, at any
>> time, only one output in the wallet. Let's call it a "consolidated"
>> wallet. In order to consolidate a wallet:
>>
>>   - Send all the bitcoins contained in the wallet to a new address of
>> the same wallet
>>
>> If the user departs from these guidelines by mistake, he can "fix" his
>> wallet and re-consolidate it without losing the tokens contained in the
>> wallet. If the wallet is consolidated, it remains consolidated while
>> tokens are generated or sent, and while bitcoins from the wallet are
>> spent. If bitcoins or tokens are received by any address of the wallet,
>> then the wallet needs to be consolidated again.
>>
>> Issuance of tokens
>> ------------------
>> In order to generate tokens:
>>
>>   - Consolidate the wallet if it is not already consolidated.
>>   - Send a minority of the bitcoins contained in the wallet to a new
>> address (outside of the wallet). The last five digits of the satoshis
>> sent are the number of tokens generated.
>>   - From the same wallet, other tokens can be generated by sending again
>> a number of satoshis, having the last five digits that are the number of
>> tokens to issue to the new address.
>>   - The value of bitcoins sent should always be less than the bitcoin
>> that remains in the wallet
>>   - If during the process of generating tokens the wallet receives
>> bitcoins, it should be consolidated again before continuing to generate
>> tokens.
>>   - The type (or name) of tokens will be the txid of the transaction. If
>> the transaction sends bitcoin to a new, never used, address, the address
>> can be used as the name of the tokens, as well.
>>
>> In order to give the power to generate new tokens to another person:
>>
>>   - Send all the Bitcoin content of the wallet to the other person, with
>> a single transaction
>>
>> In order to close an issuance:
>>
>>   - To close the issuance and guarantee that no other tokens of this
>> type will ever be generated again, send to another address of the same
>> wallet a number of bitcoins with the last five digits of the satoshis
>> that is zero. Be aware that this shouldn't be all the content of the
>> wallet. If all the content of the wallet is sent to some address, the
>> issuance will not be closed. Instead, this gives to the receiver the
>> power to generate new tokens.
>>
>> Spending bitcoins and not tokens
>> --------------------------------
>> In order to spend bitcoins from the wallet without sending any tokens,
>> the user should spend less than half of the bitcoin value contained in
>> the wallet, and:
>>
>>   - Spend a number of satoshis where the last five digits are all zeros,
>>   or
>>   - Spend a number of satoshis where the last five digits are a number
>> greater than the tokens that are in the wallet,
>>
>> Transfer of tokens
>> ------------------
>> In order to send tokens to another person:
>>
>>   - Consolidate the wallet if it is not already consolidated.
>>   - Send a value less than half of the content of the wallet and having
>> the number of satoshis where the last five digits are the number of
>> tokens that need to be transferred,
>>   or
>>   - Send all the bitcoins of the wallet (even if the wallet is not
>> consolidated).
>>
>> If the user sends all the content of the wallet to a single address (no
>> change), then he's emptying the token content from the wallet, as well.
>> All the tokens will go to the address and nothing will remain to the user.
>>
>> In order to receive tokens from other users:
>>
>>   - Give to the other person a Bitcoin address of the wallet and ask to
>> send tokens as explained above.
>>   - If the wallet was empty before of receiving tokens, then it is
>> already consolidated. Instead, if the wallet already had some bitcoins,
>> then the wallet needs to be consolidated before sending or generating
>> tokens.
>>
>> Effects of the use of these guidelines
>> --------------------------------------
>> When using the guidelines, the number of tokens sent to the recipient is
>> always stated in the last five digits of the satoshis sent. There are
>> three exceptions:
>>
>>   - In a single output transaction, all the tokens of the wallet will be
>> sent to the recipient.
>>   - In a transaction where the amount of satoshis sent ends with five
>> zeros, no tokens are sent.
>>   - In a transaction sending more tokens than the number of tokens of
>> that type held in the wallet, no tokens are sent.
>>
>> Technical notes
>> ---------------
>>   - Sending a number of bitcoins that is greater than half of the
>> bitcoins contained in the wallet brings to unpredicted results.
>>   - Thus, if there are not enough bitcoins to continue to operate, the
>> wallet needs to be "re-charged" by sending some bitcoins to it. By doing
>> so, there will be more than one UTXO in the wallet. This departs from
>> "consolidated mode" and the wallet needs to be consolidated again.
>>   - A consolidated wallet contains only one UTXO.
>>   - Every transaction made from a consolidated wallet contains only two
>> outputs: one is the address outside of the wallet, and the other is the
>> change.
>>   - Every transaction spends all the content of the wallet.
>>
>> Reference Implementation
>> ========================
>> A reference implementation will be included when the protocol will be
>> reviewed and accepted by the community.
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From tier.nolan at gmail.com  Wed Sep  6 22:20:02 2017
From: tier.nolan at gmail.com (Tier Nolan)
Date: Wed, 6 Sep 2017 23:20:02 +0100
Subject: [bitcoin-dev] SF proposal: prohibit unspendable outputs with
	amount=0
In-Reply-To: <CABm2gDojDQWMhw8wW1UkRGKtdbby2+6AFFZLPuRcUb7WF_u5qQ@mail.gmail.com>
References: <CABm2gDojDQWMhw8wW1UkRGKtdbby2+6AFFZLPuRcUb7WF_u5qQ@mail.gmail.com>
Message-ID: <CAE-z3OWQZK1z7WFOSQOu15ri2cOGx9vCzyd1P=Q1t6MPDBOcLw@mail.gmail.com>

On Tue, Sep 5, 2017 at 10:51 PM, Jorge Tim?n via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Is there any reason or use case to keep allowing spendable outputs
> with null amounts in them?
>

Someone could have created a timelocked transaction that depends on a zero
value output.

This could be protected by requiring a tx version number change.  Only zero
outputs in the new version would be affected.

I am not sure how strictly people are sticking to that rule though.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170906/ea09555c/attachment.html>

From stick at satoshilabs.com  Wed Sep  6 22:29:23 2017
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Thu, 7 Sep 2017 00:29:23 +0200
Subject: [bitcoin-dev] Proposal: Extended serialization format for BIP-32
	wallets
Message-ID: <0d405f5d-c0a4-bad7-b6c3-08ba4424bf17@satoshilabs.com>

The discussion about changing bip32 version bytes for SegWit got me
thinking and I ended up with what I think is the best proposal:

https://github.com/satoshilabs/slips/blob/master/slip-0032.md

(It is hosted in SL repo for now, but if there is will, I would love to
have this added to BIP repo as an extension to BIP32)

Feel free to comment.

-- 
Best Regards / S pozdravom,

Pavol "stick" Rusnak
CTO, SatoshiLabs

From mark at friedenbach.org  Thu Sep  7 00:38:55 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Wed, 6 Sep 2017 17:38:55 -0700
Subject: [bitcoin-dev] Merkle branch verification & tail-call semantics for
	generalized MAST
Message-ID: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>

I would like to propose two new script features to be added to the
bitcoin protocol by means of soft-fork activation. These features are
a new opcode, MERKLE-BRANCH-VERIFY (MBV) and tail-call execution
semantics.

In brief summary, MERKLE-BRANCH-VERIFY allows script authors to force
redemption to use values selected from a pre-determined set committed
to in the scriptPubKey, but without requiring revelation of unused
elements in the set for both enhanced privacy and smaller script
sizes. Tail-call execution semantics allows a single level of
recursion into a subscript, providing properties similar to P2SH while
at the same time more flexible.

These two features together are enough to enable a range of
applications such as tree signatures (minus Schnorr aggregation) as
described by Pieter Wuille [1], and a generalized MAST useful for
constructing private smart contracts. It also brings privacy and
fungibility improvements to users of counter-signing wallet/vault
services as unique redemption policies need only be revealed if/when
exceptional circumstances demand it, leaving most transactions looking
the same as any other MAST-enabled multi-sig script.

I believe that the implementation of these features is simple enough,
and the use cases compelling enough that we could BIP 8/9 rollout of
these features in relatively short order, perhaps before the end of
the year.

I have written three BIPs to describe these features, and their
associated implementation, for which I now invite public review and
discussion:

Fast Merkle Trees
BIP: https://gist.github.com/maaku/41b0054de0731321d23e9da90ba4ee0a
Code: https://github.com/maaku/bitcoin/tree/fast-merkle-tree

MERKLEBRANCHVERIFY
BIP: https://gist.github.com/maaku/bcf63a208880bbf8135e453994c0e431
Code: https://github.com/maaku/bitcoin/tree/merkle-branch-verify

Tail-call execution semantics
BIP: https://gist.github.com/maaku/f7b2e710c53f601279549aa74eeb5368
Code: https://github.com/maaku/bitcoin/tree/tail-call-semantics

Note: I have circulated this idea privately among a few people, and I
will note that there is one piece of feedback which I agree with but
is not incorporated yet: there should be a multi-element MBV opcode
that allows verifying multiple items are extracted from a single
tree. It is not obvious how MBV could be modified to support this
without sacrificing important properties, or whether should be a
separate multi-MBV opcode instead.

Kind regards,
Mark Friedenbach

From cryptaxe at gmail.com  Wed Sep  6 23:54:03 2017
From: cryptaxe at gmail.com (CryptAxe)
Date: Wed, 6 Sep 2017 16:54:03 -0700
Subject: [bitcoin-dev] SF proposal: prohibit unspendable outputs with
	amount=0
In-Reply-To: <CABm2gDojDQWMhw8wW1UkRGKtdbby2+6AFFZLPuRcUb7WF_u5qQ@mail.gmail.com>
References: <CABm2gDojDQWMhw8wW1UkRGKtdbby2+6AFFZLPuRcUb7WF_u5qQ@mail.gmail.com>
Message-ID: <CAF5CFkh4DWE6Ca-5LFrgkGxWgYqqJdEdv+JZ+3wp+0eTm_vqCw@mail.gmail.com>

As long as an unspendable outputs (OP_RETURN outputs for example) with
amount=0 are still allowed I don't see it being an issue for anything.

On Sep 5, 2017 2:52 PM, "Jorge Tim?n via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> This is not a priority, not very important either.
> Right now it is possible to create 0-value outputs that are spendable
> and thus stay in the utxo (potentially forever). Requiring at least 1
> satoshi per output doesn't really do much against a spam attack to the
> utxo, but I think it would be slightly better than the current
> situation.
>
> Is there any reason or use case to keep allowing spendable outputs
> with null amounts in them?
>
> If not, I'm happy to create a BIP with its code, this should be simple.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170906/83476b7f/attachment.html>

From adam.back at gmail.com  Thu Sep  7 01:29:55 2017
From: adam.back at gmail.com (Adam Back)
Date: Thu, 7 Sep 2017 02:29:55 +0100
Subject: [bitcoin-dev] SF proposal: prohibit unspendable outputs with
	amount=0
In-Reply-To: <CAF5CFkh4DWE6Ca-5LFrgkGxWgYqqJdEdv+JZ+3wp+0eTm_vqCw@mail.gmail.com>
References: <CABm2gDojDQWMhw8wW1UkRGKtdbby2+6AFFZLPuRcUb7WF_u5qQ@mail.gmail.com>
	<CAF5CFkh4DWE6Ca-5LFrgkGxWgYqqJdEdv+JZ+3wp+0eTm_vqCw@mail.gmail.com>
Message-ID: <CALqxMTHxdLqms_OgT71EtS2kY2=_8yfNsatNNnOjfSHrLnQL-Q@mail.gmail.com>

The pattern used by Felix Weiss' BIP for Confidential Transactions
depends on or is tidier with 0-value outputs.

Adam


On 7 September 2017 at 00:54, CryptAxe via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> As long as an unspendable outputs (OP_RETURN outputs for example) with
> amount=0 are still allowed I don't see it being an issue for anything.
>
> On Sep 5, 2017 2:52 PM, "Jorge Tim?n via bitcoin-dev"
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> This is not a priority, not very important either.
>> Right now it is possible to create 0-value outputs that are spendable
>> and thus stay in the utxo (potentially forever). Requiring at least 1
>> satoshi per output doesn't really do much against a spam attack to the
>> utxo, but I think it would be slightly better than the current
>> situation.
>>
>> Is there any reason or use case to keep allowing spendable outputs
>> with null amounts in them?
>>
>> If not, I'm happy to create a BIP with its code, this should be simple.
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From roconnor at blockstream.io  Thu Sep  7 01:59:54 2017
From: roconnor at blockstream.io (Russell O'Connor)
Date: Wed, 6 Sep 2017 21:59:54 -0400
Subject: [bitcoin-dev] Fast Merkle Trees
Message-ID: <CAMZUoKmD4v4vn9L=kdyJNk-km3XHpNVkD_tmS+SseMsf6YaVPg@mail.gmail.com>

The fast hash for internal nodes needs to use an IV that is not the
standard SHA-256 IV. Instead needs to use some other fixed value, which
should itself be the SHA-256 hash of some fixed string (e.g. the string
"BIP ???" or "Fash SHA-256").

As it stands, I believe someone can claim a leaf node as an internal node
by creating a proof that provides a phony right-hand branch claiming to
have hash 0x80000..0000100 (which is really the padding value for the
second half of a double SHA-256 hash).

(I was schooled by Peter Todd by a similar issue in the past.)

On Wed, Sep 6, 2017 at 8:38 PM, Mark Friedenbach via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Fast Merkle Trees
> BIP: https://gist.github.com/maaku/41b0054de0731321d23e9da90ba4ee0a
> Code: https://github.com/maaku/bitcoin/tree/fast-merkle-tree
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170906/59d742fe/attachment-0001.html>

From thomasv at electrum.org  Thu Sep  7 04:29:32 2017
From: thomasv at electrum.org (Thomas Voegtlin)
Date: Thu, 7 Sep 2017 06:29:32 +0200
Subject: [bitcoin-dev] Proposal: Extended serialization format for
 BIP-32 wallets
In-Reply-To: <0d405f5d-c0a4-bad7-b6c3-08ba4424bf17@satoshilabs.com>
References: <0d405f5d-c0a4-bad7-b6c3-08ba4424bf17@satoshilabs.com>
Message-ID: <8b4831a4-791e-c03e-baa4-16d9e5ead442@electrum.org>



On 07.09.2017 00:29, Pavol Rusnak via bitcoin-dev wrote:
> The discussion about changing bip32 version bytes for SegWit got me
> thinking and I ended up with what I think is the best proposal:
> 
> https://github.com/satoshilabs/slips/blob/master/slip-0032.md
> 
> (It is hosted in SL repo for now, but if there is will, I would love to
> have this added to BIP repo as an extension to BIP32)
> 
> Feel free to comment.
> 


Your proposal forces wallets to use the derivation path in order to
determine the type of output script. it will work only in the context of
BIP43.

Therefore, it should not be proposed as a BIP32 improvement, but as a
improvement of BIP43.

A solution is still needed to wallets who do not wish to use BIP43

From kabuto at samouraiwallet.com  Thu Sep  7 03:52:57 2017
From: kabuto at samouraiwallet.com (Kabuto Samourai)
Date: Wed, 6 Sep 2017 22:52:57 -0500
Subject: [bitcoin-dev] Proposal: Extended serialization format for
	BIP-32 wallets
In-Reply-To: <0d405f5d-c0a4-bad7-b6c3-08ba4424bf17@satoshilabs.com>
References: <0d405f5d-c0a4-bad7-b6c3-08ba4424bf17@satoshilabs.com>
Message-ID: <CA+_kfXLvTKwkuYmtt94OPUEPPwsEzhRoryy7srKMbLxYDxnmFA@mail.gmail.com>

Thanks for the proposal. Aside from potential privacy implications of
revealing the derivation path for non BIP-44, 45, 49 HD nodes, this scheme
is superior to the alternate {x,y,z}pub idea. Since coin_type is part of
the path, the 'xpub' prefix may be shared across all coins if they so
choose. This format provides lock-in for BIP-49 going forward and opens the
door for a parallel native-SegWit BIP.

The birthday field is interesting. Could you provide some motivation for
its inclusion?

Could you also add some test vectors?

There are a few minor grammar / spelling errors, but we can nitpick those
after this goes to the pull request stage on bitcoin/bips.

On Wed, Sep 6, 2017 at 5:29 PM, Pavol Rusnak via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> The discussion about changing bip32 version bytes for SegWit got me
> thinking and I ended up with what I think is the best proposal:
>
> https://github.com/satoshilabs/slips/blob/master/slip-0032.md
>
> (It is hosted in SL repo for now, but if there is will, I would love to
> have this added to BIP repo as an extension to BIP32)
>
> Feel free to comment.
>
> --
> Best Regards / S pozdravom,
>
> Pavol "stick" Rusnak
> CTO, SatoshiLabs
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>



-Kabuto

PGP Fingerprint: 1A83 4A96 EDE7 E286 2C5A  B065 320F B934 A79B 6A99
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170906/de229129/attachment.html>

From mark at friedenbach.org  Thu Sep  7 02:20:06 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Wed, 6 Sep 2017 19:20:06 -0700
Subject: [bitcoin-dev] Fast Merkle Trees
In-Reply-To: <CAMZUoKmD4v4vn9L=kdyJNk-km3XHpNVkD_tmS+SseMsf6YaVPg@mail.gmail.com>
References: <CAMZUoKmD4v4vn9L=kdyJNk-km3XHpNVkD_tmS+SseMsf6YaVPg@mail.gmail.com>
Message-ID: <F1D041D0-FC5A-425C-835D-37E7A9C0CFC5@friedenbach.org>

This design purposefully does not distinguish leaf nodes from internal nodes. That way it chained invocations can be used to validate paths longer than 32 branches. Do you see a vulnerability due to this lack of distinction?

> On Sep 6, 2017, at 6:59 PM, Russell O'Connor <roconnor at blockstream.io> wrote:
> 
> The fast hash for internal nodes needs to use an IV that is not the standard SHA-256 IV. Instead needs to use some other fixed value, which should itself be the SHA-256 hash of some fixed string (e.g. the string "BIP ???" or "Fash SHA-256").
> 
> As it stands, I believe someone can claim a leaf node as an internal node by creating a proof that provides a phony right-hand branch claiming to have hash 0x80000..0000100 (which is really the padding value for the second half of a double SHA-256 hash).
> 
> (I was schooled by Peter Todd by a similar issue in the past.)
> 
>> On Wed, Sep 6, 2017 at 8:38 PM, Mark Friedenbach via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> Fast Merkle Trees
>> BIP: https://gist.github.com/maaku/41b0054de0731321d23e9da90ba4ee0a
>> Code: https://github.com/maaku/bitcoin/tree/fast-merkle-tree
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170906/e53c24c8/attachment.html>

From cryptaxe at gmail.com  Thu Sep  7 03:41:49 2017
From: cryptaxe at gmail.com (CryptAxe)
Date: Wed, 6 Sep 2017 20:41:49 -0700
Subject: [bitcoin-dev] SF proposal: prohibit unspendable outputs with
 amount=0
In-Reply-To: <CALqxMTHxdLqms_OgT71EtS2kY2=_8yfNsatNNnOjfSHrLnQL-Q@mail.gmail.com>
References: <CABm2gDojDQWMhw8wW1UkRGKtdbby2+6AFFZLPuRcUb7WF_u5qQ@mail.gmail.com>
	<CAF5CFkh4DWE6Ca-5LFrgkGxWgYqqJdEdv+JZ+3wp+0eTm_vqCw@mail.gmail.com>
	<CALqxMTHxdLqms_OgT71EtS2kY2=_8yfNsatNNnOjfSHrLnQL-Q@mail.gmail.com>
Message-ID: <1ffab7c0-7005-283e-07e5-4e85fc54de51@gmail.com>

After reading
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-January/012194.html
I see that Adam is correct. Unfortunately this SF would make Felix's
confidential transactions
more complicated. The blinding and unblinding transactions would have to
be created with
minimal output values, and this will need to be considered when checking
that the fee is equal
to the total amount of input. (it would now be SUM(inputs) -
SUM(minimalOutputs))

Blinding transaction:
  Ins:
    All non-confidential inputs are valid
  Outs:
  - 0..N: (new confidential outputs)
    amount: 0
    scriptPubkey: OP_2 <0x{32-byte-hash-value}>
    witnessOut: <0x{petersen-commitment}> <0x{range-proof}>
  - last:
    amount: 0
    scriptPubkey: OP_RETURN OP_2 {blinding-fee-amount}
  Fee: Sum of the all inputs value


However, looking at the format of the blinding transaction, and how the
GCTXO is added to the UTXO set
by miners, it seems that a change to the blinding scriptPubKey could
allow for the use of 0 value
outputs. Even with the SF proposed by this email thread.

OP_RETURN could be added to the scriptPubKey during blinding. The amount
and scriptPubKey destination of
unblinded funds is part of the witness and the outputs of an unblinded
transaction are unspendable, so
why not also make them unspendable in the blind transaction? As far as I
can tell those outputs don't need to
be spendable, they are really just encoding data. It doesn't seem like
anything besides the confidential base
transaction and the fee output from the blind transaction need to be in
the UTXO set.

Is it still possible to add this data to the witness if the scriptPubKey
is unspendable? :

witnessOut: <0x{petersen-commitment}> <0x{range-proof}>

I think I'm missing something obvious, someone point out why this is
stupid please :)

On 09/06/2017 06:29 PM, Adam Back wrote:
> The pattern used by Felix Weiss' BIP for Confidential Transactions
> depends on or is tidier with 0-value outputs.
>
> Adam
>
>
> On 7 September 2017 at 00:54, CryptAxe via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> As long as an unspendable outputs (OP_RETURN outputs for example) with
>> amount=0 are still allowed I don't see it being an issue for anything.
>>
>> On Sep 5, 2017 2:52 PM, "Jorge Tim?n via bitcoin-dev"
>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>> This is not a priority, not very important either.
>>> Right now it is possible to create 0-value outputs that are spendable
>>> and thus stay in the utxo (potentially forever). Requiring at least 1
>>> satoshi per output doesn't really do much against a spam attack to the
>>> utxo, but I think it would be slightly better than the current
>>> situation.
>>>
>>> Is there any reason or use case to keep allowing spendable outputs
>>> with null amounts in them?
>>>
>>> If not, I'm happy to create a BIP with its code, this should be simple.
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>


From pete at petertodd.org  Thu Sep  7 05:55:57 2017
From: pete at petertodd.org (Peter Todd)
Date: Thu, 7 Sep 2017 01:55:57 -0400
Subject: [bitcoin-dev] Fast Merkle Trees
In-Reply-To: <CAMZUoKmD4v4vn9L=kdyJNk-km3XHpNVkD_tmS+SseMsf6YaVPg@mail.gmail.com>
References: <CAMZUoKmD4v4vn9L=kdyJNk-km3XHpNVkD_tmS+SseMsf6YaVPg@mail.gmail.com>
Message-ID: <20170907055557.GA12638@fedora-23-dvm>

On Wed, Sep 06, 2017 at 09:59:54PM -0400, Russell O'Connor via bitcoin-dev wrote:
> The fast hash for internal nodes needs to use an IV that is not the
> standard SHA-256 IV. Instead needs to use some other fixed value, which
> should itself be the SHA-256 hash of some fixed string (e.g. the string
> "BIP ???" or "Fash SHA-256").

Note that in general, designs should *not* create new hash functions by using
custom IVs, but rather use bog-standard SHA256, and make a fixed first block.
That allows unoptimised implementations to just hash a block with the second
initialization value, and optimized implementations to start with the fixed
midstate.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/357fa2db/attachment-0001.sig>

From hampus.sjoberg at gmail.com  Thu Sep  7 09:56:19 2017
From: hampus.sjoberg at gmail.com (=?UTF-8?Q?Hampus_Sj=C3=B6berg?=)
Date: Thu, 7 Sep 2017 11:56:19 +0200
Subject: [bitcoin-dev] SF proposal: prohibit unspendable outputs with
	amount=0
In-Reply-To: <1ffab7c0-7005-283e-07e5-4e85fc54de51@gmail.com>
References: <CABm2gDojDQWMhw8wW1UkRGKtdbby2+6AFFZLPuRcUb7WF_u5qQ@mail.gmail.com>
	<CAF5CFkh4DWE6Ca-5LFrgkGxWgYqqJdEdv+JZ+3wp+0eTm_vqCw@mail.gmail.com>
	<CALqxMTHxdLqms_OgT71EtS2kY2=_8yfNsatNNnOjfSHrLnQL-Q@mail.gmail.com>
	<1ffab7c0-7005-283e-07e5-4e85fc54de51@gmail.com>
Message-ID: <CAFMkqK8t+iADAbpWeTLZy+YjLQC5DsxHPFAWCcp063k-Dc9DYg@mail.gmail.com>

Forbidding 0 satoshi outputs (I wasn't actually aware that it was possible,
is 0 satoshi inputs also allowed?) would complicate a divisibility increase
softfork (I'm working on an idea for >= 1 satoshi transactions, but now it
seems like < 1 satoshi transactions would work too).

I don't think it's a good idea to deploy this softfork.

Hampus

2017-09-07 5:41 GMT+02:00 CryptAxe via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org>:

> After reading
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> 2016-January/012194.html
> I see that Adam is correct. Unfortunately this SF would make Felix's
> confidential transactions
> more complicated. The blinding and unblinding transactions would have to
> be created with
> minimal output values, and this will need to be considered when checking
> that the fee is equal
> to the total amount of input. (it would now be SUM(inputs) -
> SUM(minimalOutputs))
>
> Blinding transaction:
>   Ins:
>     All non-confidential inputs are valid
>   Outs:
>   - 0..N: (new confidential outputs)
>     amount: 0
>     scriptPubkey: OP_2 <0x{32-byte-hash-value}>
>     witnessOut: <0x{petersen-commitment}> <0x{range-proof}>
>   - last:
>     amount: 0
>     scriptPubkey: OP_RETURN OP_2 {blinding-fee-amount}
>   Fee: Sum of the all inputs value
>
>
> However, looking at the format of the blinding transaction, and how the
> GCTXO is added to the UTXO set
> by miners, it seems that a change to the blinding scriptPubKey could
> allow for the use of 0 value
> outputs. Even with the SF proposed by this email thread.
>
> OP_RETURN could be added to the scriptPubKey during blinding. The amount
> and scriptPubKey destination of
> unblinded funds is part of the witness and the outputs of an unblinded
> transaction are unspendable, so
> why not also make them unspendable in the blind transaction? As far as I
> can tell those outputs don't need to
> be spendable, they are really just encoding data. It doesn't seem like
> anything besides the confidential base
> transaction and the fee output from the blind transaction need to be in
> the UTXO set.
>
> Is it still possible to add this data to the witness if the scriptPubKey
> is unspendable? :
>
> witnessOut: <0x{petersen-commitment}> <0x{range-proof}>
>
> I think I'm missing something obvious, someone point out why this is
> stupid please :)
>
> On 09/06/2017 06:29 PM, Adam Back wrote:
> > The pattern used by Felix Weiss' BIP for Confidential Transactions
> > depends on or is tidier with 0-value outputs.
> >
> > Adam
> >
> >
> > On 7 September 2017 at 00:54, CryptAxe via bitcoin-dev
> > <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >> As long as an unspendable outputs (OP_RETURN outputs for example) with
> >> amount=0 are still allowed I don't see it being an issue for anything.
> >>
> >> On Sep 5, 2017 2:52 PM, "Jorge Tim?n via bitcoin-dev"
> >> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>> This is not a priority, not very important either.
> >>> Right now it is possible to create 0-value outputs that are spendable
> >>> and thus stay in the utxo (potentially forever). Requiring at least 1
> >>> satoshi per output doesn't really do much against a spam attack to the
> >>> utxo, but I think it would be slightly better than the current
> >>> situation.
> >>>
> >>> Is there any reason or use case to keep allowing spendable outputs
> >>> with null amounts in them?
> >>>
> >>> If not, I'm happy to create a BIP with its code, this should be simple.
> >>> _______________________________________________
> >>> bitcoin-dev mailing list
> >>> bitcoin-dev at lists.linuxfoundation.org
> >>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >>
> >> _______________________________________________
> >> bitcoin-dev mailing list
> >> bitcoin-dev at lists.linuxfoundation.org
> >> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/52539276/attachment.html>

From tier.nolan at gmail.com  Thu Sep  7 10:31:41 2017
From: tier.nolan at gmail.com (Tier Nolan)
Date: Thu, 7 Sep 2017 11:31:41 +0100
Subject: [bitcoin-dev] SF proposal: prohibit unspendable outputs with
	amount=0
In-Reply-To: <CAF5CFkh4DWE6Ca-5LFrgkGxWgYqqJdEdv+JZ+3wp+0eTm_vqCw@mail.gmail.com>
References: <CABm2gDojDQWMhw8wW1UkRGKtdbby2+6AFFZLPuRcUb7WF_u5qQ@mail.gmail.com>
	<CAF5CFkh4DWE6Ca-5LFrgkGxWgYqqJdEdv+JZ+3wp+0eTm_vqCw@mail.gmail.com>
Message-ID: <CAE-z3OWYmi+4jVO8kKB1EBT7mYhPE=MNf6JvNVYteVfZ24qqkg@mail.gmail.com>

You could have a timelocked transaction that has a zero value input (and
other non-zero inputs).  If the SF happened, that transaction would become
unspendable.

The keys to the outputs may be lost or the co-signer may refuse to
cooperate.

There seems to be some objections to long term timelocked transactions.

If someone asked me about it, I would recommend that any timelocked
transactions should very carefully make sure that they use forms that are
popular.

I think the fairest rule would be that any change which makes some
transactions invalid should be opt-in and only apply to new transaction
version numbers.

If you create a timelocked transactions with an undefined version number,
then you have little to complain about.

If the version number is defined and in-use, then transactions should not
suddenly lose validity.

A refusal to commit to that makes long term locktime use much more risky.

On Thu, Sep 7, 2017 at 12:54 AM, CryptAxe via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> As long as an unspendable outputs (OP_RETURN outputs for example) with
> amount=0 are still allowed I don't see it being an issue for anything.
>
> On Sep 5, 2017 2:52 PM, "Jorge Tim?n via bitcoin-dev" <bitcoin-dev at lists.
> linuxfoundation.org> wrote:
>
>> This is not a priority, not very important either.
>> Right now it is possible to create 0-value outputs that are spendable
>> and thus stay in the utxo (potentially forever). Requiring at least 1
>> satoshi per output doesn't really do much against a spam attack to the
>> utxo, but I think it would be slightly better than the current
>> situation.
>>
>> Is there any reason or use case to keep allowing spendable outputs
>> with null amounts in them?
>>
>> If not, I'm happy to create a BIP with its code, this should be simple.
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/d1dfecc7/attachment.html>

From roconnor at blockstream.io  Thu Sep  7 15:43:52 2017
From: roconnor at blockstream.io (Russell O'Connor)
Date: Thu, 7 Sep 2017 11:43:52 -0400
Subject: [bitcoin-dev] Fast Merkle Trees
In-Reply-To: <F1D041D0-FC5A-425C-835D-37E7A9C0CFC5@friedenbach.org>
References: <CAMZUoKmD4v4vn9L=kdyJNk-km3XHpNVkD_tmS+SseMsf6YaVPg@mail.gmail.com>
	<F1D041D0-FC5A-425C-835D-37E7A9C0CFC5@friedenbach.org>
Message-ID: <CAMZUoKmhN=m4TFwJi7u1bibLJ6mYvpnkddWTZZWdHn7+mVcJvw@mail.gmail.com>

In that case, you may as well remove all references to leaves and double
SHA-256 from your BIP since your design has no method for distinguishing
between internal nodes and leaves.

I think that if this design stands, it will play a role in some future
CVEs.  The BIP itself is too abstract about its data contents to
specifically say that it has a vulnerability; however, I believe it is
inviting vulnerabilities.
For example, I might agree with a counterparty to a design of some sort of
smart contract in the form of a MAST.  My counterparty has shown me all the
"leaves" of our MAST and I can verify its Merkle root computation.
After being deployed, I found out that one of the leaves wasn't really a
leaf but is instead a specially crafted "script" with a fake pubkey chosen
by my couterparty so that this leaf can also be interpreted as a fake
internal node (i.e. an internal node with a right branch of 0x8000...100).
Because the Fast Merkle Tree design doesn't distinguish between leaves and
internal nodes my counter party gets away with building an Inclusion Proof
through this "leaf" to reveal the evil code that they had designed into the
MAST at a deeper level.

Turns out my counterparty was grinding their evil code to produce an
internal node that can also be parsed as an innocent script.  They used
their "pubkey" to absorb excess random data from their grinding that they
cannot eliminate.
(The counterparty doesn't actually know the discrete log of this "pubkey",
they just claimed it was their pubkey and I believed them).


Having ambiguity about whether a node is a leaf or an internal node is a
security risk. Furthermore, changing the design so that internal node and
leaves are distinguishable still allows chained invocations.
Arbitrary data can be stored in Fast Merkle Tree leaves, including the
Merkle root of another Fast Merkle Tree.
Applications that are limited to proof with paths no longer than 32
branches can still circumvent this limit by staging these Fast Merkle Trees
in explicit layers (as opposed to the implicit layers with the current
design).

By storing a inner Fast Merkle Tree root inside the (explicit) leaf of an
outer Fast Merkle Tree, the application can verify a Inclusion Proof of the
inner Fast Merkle Tree Root in the outer Fast Merkle Tree Root, and then
verify a second Inclusion Proof of the desired data in the inner Faster
Merkle Tree Root.  The application will need to tag their data to
distinguish between inner Fast Merkle Tree Roots and other application
data, but that is just part of the general expectation that applications
not store ambiguous data inside the leaves of Fast Merkle Trees.


On Wed, Sep 6, 2017 at 10:20 PM, Mark Friedenbach <mark at friedenbach.org>
wrote:

> This design purposefully does not distinguish leaf nodes from internal
> nodes. That way it chained invocations can be used to validate paths longer
> than 32 branches. Do you see a vulnerability due to this lack of
> distinction?
>
> On Sep 6, 2017, at 6:59 PM, Russell O'Connor <roconnor at blockstream.io>
> wrote:
>
> The fast hash for internal nodes needs to use an IV that is not the
> standard SHA-256 IV. Instead needs to use some other fixed value, which
> should itself be the SHA-256 hash of some fixed string (e.g. the string
> "BIP ???" or "Fash SHA-256").
>
> As it stands, I believe someone can claim a leaf node as an internal node
> by creating a proof that provides a phony right-hand branch claiming to
> have hash 0x80000..0000100 (which is really the padding value for the
> second half of a double SHA-256 hash).
>
> (I was schooled by Peter Todd by a similar issue in the past.)
>
> On Wed, Sep 6, 2017 at 8:38 PM, Mark Friedenbach via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Fast Merkle Trees
>> BIP: https://gist.github.com/maaku/41b0054de0731321d23e9da90ba4ee0a
>> Code: https://github.com/maaku/bitcoin/tree/fast-merkle-tree
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/87bc87d5/attachment-0001.html>

From roconnor at blockstream.io  Thu Sep  7 15:51:14 2017
From: roconnor at blockstream.io (Russell O'Connor)
Date: Thu, 7 Sep 2017 11:51:14 -0400
Subject: [bitcoin-dev] Fast Merkle Trees
In-Reply-To: <20170907055557.GA12638@fedora-23-dvm>
References: <CAMZUoKmD4v4vn9L=kdyJNk-km3XHpNVkD_tmS+SseMsf6YaVPg@mail.gmail.com>
	<20170907055557.GA12638@fedora-23-dvm>
Message-ID: <CAMZUoKk=00AJbtq602P=MWtGhWUY_7oCrWEUj+K7xp_+DOOTYg@mail.gmail.com>

On Thu, Sep 7, 2017 at 1:55 AM, Peter Todd <pete at petertodd.org> wrote:

> On Wed, Sep 06, 2017 at 09:59:54PM -0400, Russell O'Connor via bitcoin-dev
> wrote:
> > The fast hash for internal nodes needs to use an IV that is not the
> > standard SHA-256 IV. Instead needs to use some other fixed value, which
> > should itself be the SHA-256 hash of some fixed string (e.g. the string
> > "BIP ???" or "Fash SHA-256").
>
> Note that in general, designs should *not* create new hash functions by
> using
> custom IVs, but rather use bog-standard SHA256, and make a fixed first
> block.
> That allows unoptimised implementations to just hash a block with the
> second
> initialization value, and optimized implementations to start with the fixed
> midstate.


I 100% agree.

With SHA256 every final state is also a valid midstate.  Therefore, using a
custom IV of the SHA256 hash of some fixed string results in a hash of data
that is functionally equivalent to prefixing the data with the padded
version of the fixed string and using a regular SHA256 hash of the combined
data.  This is important and I should have explicitly pointed it out.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/98006cd2/attachment.html>

From stick at satoshilabs.com  Thu Sep  7 16:23:13 2017
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Thu, 7 Sep 2017 18:23:13 +0200
Subject: [bitcoin-dev] Proposal: Extended serialization format for
 BIP-32 wallets
In-Reply-To: <8b4831a4-791e-c03e-baa4-16d9e5ead442@electrum.org>
References: <0d405f5d-c0a4-bad7-b6c3-08ba4424bf17@satoshilabs.com>
	<8b4831a4-791e-c03e-baa4-16d9e5ead442@electrum.org>
Message-ID: <84f4a4b8-fcbd-433b-9556-174ec5475f61@satoshilabs.com>

On 07/09/17 06:29, Thomas Voegtlin via bitcoin-dev wrote:
> A solution is still needed to wallets who do not wish to use BIP43

What if we added another byte field OutputType for wallets that do not
follow BIP43?

0x00 - P2PKH output type
0x01 - P2WPKH-in-P2SH output type
0x02 - native Segwit output type

Would that work for you?

The question is whether this field should be present only if depth==0x00
or at all times. What is your suggestion, Thomas?

-- 
Best Regards / S pozdravom,

Pavol "stick" Rusnak
CTO, SatoshiLabs

From stick at satoshilabs.com  Thu Sep  7 16:25:30 2017
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Thu, 7 Sep 2017 18:25:30 +0200
Subject: [bitcoin-dev] Proposal: Extended serialization format for
 BIP-32 wallets
In-Reply-To: <CA+_kfXLvTKwkuYmtt94OPUEPPwsEzhRoryy7srKMbLxYDxnmFA@mail.gmail.com>
References: <0d405f5d-c0a4-bad7-b6c3-08ba4424bf17@satoshilabs.com>
	<CA+_kfXLvTKwkuYmtt94OPUEPPwsEzhRoryy7srKMbLxYDxnmFA@mail.gmail.com>
Message-ID: <200b706a-f6ac-479a-2dce-fd66fe943949@satoshilabs.com>

On 07/09/17 05:52, Kabuto Samourai wrote:
> The birthday field is interesting. Could you provide some motivation for
> its inclusion?

Birthday is something SPV wallet developers have been wanting for years.
It helps them with the initial scan, so SPV wallet does not have to
download every block in the blockchain, but only the ones after birthday.

> Could you also add some test vectors?

I will add some test vectors, when we agree this is the way to go.

> There are a few minor grammar / spelling errors, but we can nitpick
> those after this goes to the pull request stage on bitcoin/bips.

+1

-- 
Best Regards / S pozdravom,

Pavol "stick" Rusnak
CTO, SatoshiLabs

From stick at satoshilabs.com  Thu Sep  7 16:37:19 2017
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Thu, 7 Sep 2017 18:37:19 +0200
Subject: [bitcoin-dev] Proposal: Extended serialization format for
 BIP-32 wallets
In-Reply-To: <CA+_kfXL7bkV+PqR7GdQ9GdDz9AnEBoRXFCgYyJdMJQ8zuCKOEA@mail.gmail.com>
References: <0d405f5d-c0a4-bad7-b6c3-08ba4424bf17@satoshilabs.com>
	<CA+_kfXLvTKwkuYmtt94OPUEPPwsEzhRoryy7srKMbLxYDxnmFA@mail.gmail.com>
	<200b706a-f6ac-479a-2dce-fd66fe943949@satoshilabs.com>
	<CA+_kfXL7bkV+PqR7GdQ9GdDz9AnEBoRXFCgYyJdMJQ8zuCKOEA@mail.gmail.com>
Message-ID: <7bf726e1-f4e2-8d68-f934-671a0f2b9033@satoshilabs.com>

On 07/09/17 18:30, Kabuto Samourai wrote:
> Why not make this block height, rather than a timestamp?

Blockheight depends on the chain. XPUB is not tied to particular
chain/coin.

Also there are already cryptocurrencies that do not use blockchain, but
directed acyclic graph (DAG) for storing transactions. So it would not
be obvious what number to use as a blockheight.

OTOH all blockchains contain timestamps in their blocks, so we can use that.

-- 
Best Regards / S pozdravom,

Pavol "stick" Rusnak
CTO, SatoshiLabs

From kabuto at samouraiwallet.com  Thu Sep  7 16:30:06 2017
From: kabuto at samouraiwallet.com (Kabuto Samourai)
Date: Thu, 7 Sep 2017 11:30:06 -0500
Subject: [bitcoin-dev] Proposal: Extended serialization format for
	BIP-32 wallets
In-Reply-To: <200b706a-f6ac-479a-2dce-fd66fe943949@satoshilabs.com>
References: <0d405f5d-c0a4-bad7-b6c3-08ba4424bf17@satoshilabs.com>
	<CA+_kfXLvTKwkuYmtt94OPUEPPwsEzhRoryy7srKMbLxYDxnmFA@mail.gmail.com>
	<200b706a-f6ac-479a-2dce-fd66fe943949@satoshilabs.com>
Message-ID: <CA+_kfXL7bkV+PqR7GdQ9GdDz9AnEBoRXFCgYyJdMJQ8zuCKOEA@mail.gmail.com>

> Birthday

Why not make this block height, rather than a timestamp?

On Thu, Sep 7, 2017 at 11:25 AM, Pavol Rusnak <stick at satoshilabs.com> wrote:

> On 07/09/17 05:52, Kabuto Samourai wrote:
> > The birthday field is interesting. Could you provide some motivation for
> > its inclusion?
>
> Birthday is something SPV wallet developers have been wanting for years.
> It helps them with the initial scan, so SPV wallet does not have to
> download every block in the blockchain, but only the ones after birthday.
>
> > Could you also add some test vectors?
>
> I will add some test vectors, when we agree this is the way to go.
>
> > There are a few minor grammar / spelling errors, but we can nitpick
> > those after this goes to the pull request stage on bitcoin/bips.
>
> +1
>
> --
> Best Regards / S pozdravom,
>
> Pavol "stick" Rusnak
> CTO, SatoshiLabs
>



-- 
-Kabuto

PGP Fingerprint: 1A83 4A96 EDE7 E286 2C5A  B065 320F B934 A79B 6A99
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/ac71a65b/attachment-0001.html>

From kabuto at samouraiwallet.com  Thu Sep  7 16:33:09 2017
From: kabuto at samouraiwallet.com (Kabuto Samourai)
Date: Thu, 7 Sep 2017 11:33:09 -0500
Subject: [bitcoin-dev] Proposal: Extended serialization format for
	BIP-32 wallets
In-Reply-To: <84f4a4b8-fcbd-433b-9556-174ec5475f61@satoshilabs.com>
References: <0d405f5d-c0a4-bad7-b6c3-08ba4424bf17@satoshilabs.com>
	<8b4831a4-791e-c03e-baa4-16d9e5ead442@electrum.org>
	<84f4a4b8-fcbd-433b-9556-174ec5475f61@satoshilabs.com>
Message-ID: <CA+_kfXLjeQJbJGy5=ssynGOTaGkzvzWQ2RMdhcqCG1DNjqvFWA@mail.gmail.com>

OutputType byte solution is nearly equivalent to {x,y,z} and adds redundant
data. Implementations could erroneously (maliciously) assign the wrong
output type for the given purpose field.

We could reduce the scope of this improvement to BIP43, as suggested by
Thomas. BIP32-generic wallets may implement something else.

On Thu, Sep 7, 2017 at 11:23 AM, Pavol Rusnak via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On 07/09/17 06:29, Thomas Voegtlin via bitcoin-dev wrote:
> > A solution is still needed to wallets who do not wish to use BIP43
>
> What if we added another byte field OutputType for wallets that do not
> follow BIP43?
>
> 0x00 - P2PKH output type
> 0x01 - P2WPKH-in-P2SH output type
> 0x02 - native Segwit output type
>
> Would that work for you?
>
> The question is whether this field should be present only if depth==0x00
> or at all times. What is your suggestion, Thomas?
>
> --
> Best Regards / S pozdravom,
>
> Pavol "stick" Rusnak
> CTO, SatoshiLabs
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>



-- 
-Kabuto

PGP Fingerprint: 1A83 4A96 EDE7 E286 2C5A  B065 320F B934 A79B 6A99
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/e1d48d43/attachment-0001.html>

From dev at jonasschnelli.ch  Thu Sep  7 16:47:16 2017
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Thu, 7 Sep 2017 09:47:16 -0700
Subject: [bitcoin-dev] Proposal: Extended serialization format for
 BIP-32 wallets
In-Reply-To: <0d405f5d-c0a4-bad7-b6c3-08ba4424bf17@satoshilabs.com>
References: <0d405f5d-c0a4-bad7-b6c3-08ba4424bf17@satoshilabs.com>
Message-ID: <A806D2EB-744F-41A9-91C1-603F89E9005B@jonasschnelli.ch>

Thanks for the proposal.

Three points it could see as possible improvements:

1.
From what I know, the exact birthday in seconds doesn?t matter that much therefore it may be possible to just use 13 or 16bits to create a representation in week from 2009-01-09 00:00 UTC. 13bits would give you 157 years.
Always round down to the beginning of the week when the key was created.
But not sure if it?s worth to save ~two bytes for that.
Also not sure if the key-birthday in seconds could have a security or privacy implication (week maybe better).

2.
Would it make sense to have special depth bytes that directly implies it?s a BIP44 master key (and therefore avoid the bip32 path serialisation)? I know some ?centralised? table need to be available for that which may be not a good idea. But maybe the BIP could reserve a couple of depth-bytes (maybe 0xF0 to 0xFF) for predefined paths.

3.
Would adding a version bit make sense to allow future extensions?


/jonas


> Am 06.09.2017 um 15:29 schrieb Pavol Rusnak via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>:
> 
> The discussion about changing bip32 version bytes for SegWit got me
> thinking and I ended up with what I think is the best proposal:
> 
> https://github.com/satoshilabs/slips/blob/master/slip-0032.md
> 
> (It is hosted in SL repo for now, but if there is will, I would love to
> have this added to BIP repo as an extension to BIP32)
> 
> Feel free to comment.
> 
> --
> Best Regards / S pozdravom,
> 
> Pavol "stick" Rusnak
> CTO, SatoshiLabs
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/01c4fef5/attachment.sig>

From mark at friedenbach.org  Thu Sep  7 17:42:13 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Thu, 7 Sep 2017 10:42:13 -0700
Subject: [bitcoin-dev] Fast Merkle Trees
In-Reply-To: <CAMZUoKmhN=m4TFwJi7u1bibLJ6mYvpnkddWTZZWdHn7+mVcJvw@mail.gmail.com>
References: <CAMZUoKmD4v4vn9L=kdyJNk-km3XHpNVkD_tmS+SseMsf6YaVPg@mail.gmail.com>
	<F1D041D0-FC5A-425C-835D-37E7A9C0CFC5@friedenbach.org>
	<CAMZUoKmhN=m4TFwJi7u1bibLJ6mYvpnkddWTZZWdHn7+mVcJvw@mail.gmail.com>
Message-ID: <EB804508-715A-4CD6-9B87-09845368DAC0@friedenbach.org>

I've been puzzling over your email since receiving it. I'm not sure it
is possible to perform the attack you describe with the tree structure
specified in the BIP. If I may rephrase your attack, I believe you are
seeking a solution to the following:

Want: An innocuous script and a malign script for which

   double-SHA256(innocuous)

is equal to either

   fast-SHA256(double-SHA256(malign) || r) or
   fast-SHA256(r || double-SHA256(malign))

where r is a freely chosen 32-byte nonce. This would allow the
attacker to reveal the innocuous script before funds are sent to the
MAST, then use the malign script to spend.

Because of the double-SHA256 construction I do not see how this can be
accomplished without a full break of SHA256. The trick of setting r
equal to the padding only works when a single SHA256 is used for leaf
values. This is why double-SHA256 is specified in the BIP, and I will
edit the text to make that more clear.

Which brings us to the point that I think your original request of
separating the hash function of leaves from internal nodes is already
in the specification. I misunderstood your request at first to be that
MERKLEBRANCHVERIFY should itself perform this hash, which I objected
to as it closes of certain use cases such as chained verification of
proofs. But it is explicitly the case that leaf values and internal
updates are calculated with different hash functions.

I'm not intrinsicly opposed to using a different IV for fast-SHA256 so
as to remove the incompatability with single-SHA256 as the leaf hash
function, if that is the consensus of the community. It just adds
complication to implementations and so I want to make sure that
complication is well justified.

Sincerely,
Mark Friedenbach

> On Sep 7, 2017, at 8:43 AM, Russell O'Connor <roconnor at blockstream.io> wrote:
> 
> In that case, you may as well remove all references to leaves and double SHA-256 from your BIP since your design has no method for distinguishing between internal nodes and leaves.
> 
> I think that if this design stands, it will play a role in some future CVEs.  The BIP itself is too abstract about its data contents to specifically say that it has a vulnerability; however, I believe it is inviting vulnerabilities.
> For example, I might agree with a counterparty to a design of some sort of smart contract in the form of a MAST.  My counterparty has shown me all the "leaves" of our MAST and I can verify its Merkle root computation.
> After being deployed, I found out that one of the leaves wasn't really a leaf but is instead a specially crafted "script" with a fake pubkey chosen by my couterparty so that this leaf can also be interpreted as a fake internal node (i.e. an internal node with a right branch of 0x8000...100).
> Because the Fast Merkle Tree design doesn't distinguish between leaves and internal nodes my counter party gets away with building an Inclusion Proof through this "leaf" to reveal the evil code that they had designed into the MAST at a deeper level.
> 
> Turns out my counterparty was grinding their evil code to produce an internal node that can also be parsed as an innocent script.  They used their "pubkey" to absorb excess random data from their grinding that they cannot eliminate.
> (The counterparty doesn't actually know the discrete log of this "pubkey", they just claimed it was their pubkey and I believed them).
> 
> 
> Having ambiguity about whether a node is a leaf or an internal node is a security risk. Furthermore, changing the design so that internal node and leaves are distinguishable still allows chained invocations.
> Arbitrary data can be stored in Fast Merkle Tree leaves, including the Merkle root of another Fast Merkle Tree.
> Applications that are limited to proof with paths no longer than 32 branches can still circumvent this limit by staging these Fast Merkle Trees in explicit layers (as opposed to the implicit layers with the current design).
> 
> By storing a inner Fast Merkle Tree root inside the (explicit) leaf of an outer Fast Merkle Tree, the application can verify a Inclusion Proof of the inner Fast Merkle Tree Root in the outer Fast Merkle Tree Root, and then verify a second Inclusion Proof of the desired data in the inner Faster Merkle Tree Root.  The application will need to tag their data to distinguish between inner Fast Merkle Tree Roots and other application data, but that is just part of the general expectation that applications not store ambiguous data inside the leaves of Fast Merkle Trees.
> 
> 
> On Wed, Sep 6, 2017 at 10:20 PM, Mark Friedenbach <mark at friedenbach.org <mailto:mark at friedenbach.org>> wrote:
> This design purposefully does not distinguish leaf nodes from internal nodes. That way it chained invocations can be used to validate paths longer than 32 branches. Do you see a vulnerability due to this lack of distinction?
> 
> On Sep 6, 2017, at 6:59 PM, Russell O'Connor <roconnor at blockstream.io <mailto:roconnor at blockstream.io>> wrote:
> 
>> The fast hash for internal nodes needs to use an IV that is not the standard SHA-256 IV. Instead needs to use some other fixed value, which should itself be the SHA-256 hash of some fixed string (e.g. the string "BIP ???" or "Fash SHA-256").
>> 
>> As it stands, I believe someone can claim a leaf node as an internal node by creating a proof that provides a phony right-hand branch claiming to have hash 0x80000..0000100 (which is really the padding value for the second half of a double SHA-256 hash).
>> 
>> (I was schooled by Peter Todd by a similar issue in the past.)
>> 
>> On Wed, Sep 6, 2017 at 8:38 PM, Mark Friedenbach via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>> Fast Merkle Trees
>> BIP: https://gist.github.com/maaku/41b0054de0731321d23e9da90ba4ee0a <https://gist.github.com/maaku/41b0054de0731321d23e9da90ba4ee0a>
>> Code: https://github.com/maaku/bitcoin/tree/fast-merkle-tree <https://github.com/maaku/bitcoin/tree/fast-merkle-tree>
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/9a429e2c/attachment.html>

From pete at petertodd.org  Thu Sep  7 18:00:14 2017
From: pete at petertodd.org (Peter Todd)
Date: Thu, 7 Sep 2017 14:00:14 -0400
Subject: [bitcoin-dev] SF proposal: prohibit unspendable outputs with
 amount=0
In-Reply-To: <CABm2gDojDQWMhw8wW1UkRGKtdbby2+6AFFZLPuRcUb7WF_u5qQ@mail.gmail.com>
References: <CABm2gDojDQWMhw8wW1UkRGKtdbby2+6AFFZLPuRcUb7WF_u5qQ@mail.gmail.com>
Message-ID: <20170907180014.GA13727@fedora-23-dvm>

On Tue, Sep 05, 2017 at 11:51:45PM +0200, Jorge Tim?n via bitcoin-dev wrote:
> This is not a priority, not very important either.
> Right now it is possible to create 0-value outputs that are spendable
> and thus stay in the utxo (potentially forever). Requiring at least 1
> satoshi per output doesn't really do much against a spam attack to the
> utxo, but I think it would be slightly better than the current
> situation.

Given that this has a very minimal cost for spammers - just a single satoshi -
I don't think this is worth the risk of making future upgrades more complex as
other posters have brought up.

Secondly, I think we have good reason to think that things like my own TXO
commitments and Bram's related work will make UTXO growth a non-issue in the
future.

So, I'd NACK such a proposal myself.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/da9b038a/attachment-0001.sig>

From pete at petertodd.org  Thu Sep  7 18:02:56 2017
From: pete at petertodd.org (Peter Todd)
Date: Thu, 7 Sep 2017 14:02:56 -0400
Subject: [bitcoin-dev] Proposal: Extended serialization format for
 BIP-32 wallets
In-Reply-To: <7bf726e1-f4e2-8d68-f934-671a0f2b9033@satoshilabs.com>
References: <0d405f5d-c0a4-bad7-b6c3-08ba4424bf17@satoshilabs.com>
	<CA+_kfXLvTKwkuYmtt94OPUEPPwsEzhRoryy7srKMbLxYDxnmFA@mail.gmail.com>
	<200b706a-f6ac-479a-2dce-fd66fe943949@satoshilabs.com>
	<CA+_kfXL7bkV+PqR7GdQ9GdDz9AnEBoRXFCgYyJdMJQ8zuCKOEA@mail.gmail.com>
	<7bf726e1-f4e2-8d68-f934-671a0f2b9033@satoshilabs.com>
Message-ID: <20170907180256.GB13727@fedora-23-dvm>

On Thu, Sep 07, 2017 at 06:37:19PM +0200, Pavol Rusnak via bitcoin-dev wrote:
> On 07/09/17 18:30, Kabuto Samourai wrote:
> > Why not make this block height, rather than a timestamp?
> 
> Blockheight depends on the chain. XPUB is not tied to particular
> chain/coin.
> 
> Also there are already cryptocurrencies that do not use blockchain, but
> directed acyclic graph (DAG) for storing transactions. So it would not
> be obvious what number to use as a blockheight.
> 
> OTOH all blockchains contain timestamps in their blocks, so we can use that.

More to the point, even for the blockchains that don't contain timestamps in
their blocks, their blocks do exist in our spacetime continum and thus are
created at a specific point in time. :)

If someone does however come up with an example of a blockchain that does not
occupy our spacetime continum, I'd love to hear about it!

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/313a6629/attachment.sig>

From pete at petertodd.org  Thu Sep  7 18:09:02 2017
From: pete at petertodd.org (Peter Todd)
Date: Thu, 7 Sep 2017 14:09:02 -0400
Subject: [bitcoin-dev] Proposal: Extended serialization format for
 BIP-32 wallets
In-Reply-To: <A806D2EB-744F-41A9-91C1-603F89E9005B@jonasschnelli.ch>
References: <0d405f5d-c0a4-bad7-b6c3-08ba4424bf17@satoshilabs.com>
	<A806D2EB-744F-41A9-91C1-603F89E9005B@jonasschnelli.ch>
Message-ID: <20170907180902.GC13727@fedora-23-dvm>

On Thu, Sep 07, 2017 at 09:47:16AM -0700, Jonas Schnelli via bitcoin-dev wrote:
> Thanks for the proposal.
> 
> Three points it could see as possible improvements:
> 
> 1.
> From what I know, the exact birthday in seconds doesn?t matter that much therefore it may be possible to just use 13 or 16bits to create a representation in week from 2009-01-09 00:00 UTC. 13bits would give you 157 years.
> Always round down to the beginning of the week when the key was created.
> But not sure if it?s worth to save ~two bytes for that.
> Also not sure if the key-birthday in seconds could have a security or privacy implication (week maybe better).

Note how private key birthday is a potential privacy issue in certain cases.
Rare of course, because usually you don't release your private keys! But users
will on occasion have those keys be compromised.

Personally, I'd advocate rounding down to month-level resolution, as that
should be both enough to handle any likely reorg scenario, and it's still a
precision that won't add much extra scanning ot any reasonably old (~1yr)
wallet.

Note also how if transactions created with private keys in a seed use
nLockTime, you can ensure coins won't exist in a block older than the seed
birthday by simply ensuring that nLockTime is set to a more recent date then
that birthday under all circumstances.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/08ad4b1a/attachment.sig>

From stick at satoshilabs.com  Thu Sep  7 18:38:37 2017
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Thu, 7 Sep 2017 20:38:37 +0200
Subject: [bitcoin-dev] Proposal: Extended serialization format for
 BIP-32 wallets
In-Reply-To: <A806D2EB-744F-41A9-91C1-603F89E9005B@jonasschnelli.ch>
References: <0d405f5d-c0a4-bad7-b6c3-08ba4424bf17@satoshilabs.com>
	<A806D2EB-744F-41A9-91C1-603F89E9005B@jonasschnelli.ch>
Message-ID: <e4cb31ca-7552-760e-5029-d017f2616778@satoshilabs.com>

On 07/09/17 18:47, Jonas Schnelli wrote:
> But not sure if it?s worth to save ~two bytes for that.

I think it's not worth complicating the field just to save two bytes.

But if we agree (for privacy reasons) that resolution of this field
should be reduced to week-level (as suggested by Jonas) or month-level
(as sugested by Peter), we could use just 16 bits for this.

TBH I think TREZOR will provide hardcoded constant for this field
(1.1.2014 for all its P2PKH xpubs and 1.8.2017 for all its
P2WPKH-in-P2SH xpubs). So no privacy is lost in this case, but if we
want to ENFORCE this on BIP level, we should decrease the resolution.

> 2.
> Would it make sense to have special depth bytes that directly implies it?s a BIP44 master key (and therefore avoid the bip32 path serialisation)? I know some ?centralised? table need to be available for that which may be not a good idea. But maybe the BIP could reserve a couple of depth-bytes (maybe 0xF0 to 0xFF) for predefined paths.

I think this is exactly what Thomas meant by "wallet developers are
going to use dirtier tricks" in his email, that's why I specifically
tried to avoid this. I see no good reason to do this, unless we want to
save some bytes and I don't think we are in need of doing this.

> 3.
> Would adding a version bit make sense to allow future extensions?

I think changing the human-readable part is the way to go. That way the
wallet can immediately say if it understands the format or not, without
parsing the binary data contents. Version bits were introduced in older
standards, because there was no such thing as human-readable prefix.

-- 
Best Regards / S pozdravom,

Pavol "stick" Rusnak
CTO, SatoshiLabs

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/1bdc5fe7/attachment.sig>

From roconnor at blockstream.io  Thu Sep  7 18:55:25 2017
From: roconnor at blockstream.io (Russell O'Connor)
Date: Thu, 7 Sep 2017 14:55:25 -0400
Subject: [bitcoin-dev] Fast Merkle Trees
In-Reply-To: <EB804508-715A-4CD6-9B87-09845368DAC0@friedenbach.org>
References: <CAMZUoKmD4v4vn9L=kdyJNk-km3XHpNVkD_tmS+SseMsf6YaVPg@mail.gmail.com>
	<F1D041D0-FC5A-425C-835D-37E7A9C0CFC5@friedenbach.org>
	<CAMZUoKmhN=m4TFwJi7u1bibLJ6mYvpnkddWTZZWdHn7+mVcJvw@mail.gmail.com>
	<EB804508-715A-4CD6-9B87-09845368DAC0@friedenbach.org>
Message-ID: <CAMZUoKk7dHy6urnGRzAB2UG_fkwXmQrRHDfFYOHa0sTStr=yAQ@mail.gmail.com>

On Thu, Sep 7, 2017 at 1:42 PM, Mark Friedenbach <mark at friedenbach.org>
wrote:

> I've been puzzling over your email since receiving it. I'm not sure it
> is possible to perform the attack you describe with the tree structure
> specified in the BIP. If I may rephrase your attack, I believe you are
> seeking a solution to the following:
>
> Want: An innocuous script and a malign script for which
>
>    double-SHA256(innocuous)
>
> is equal to either
>
>    fast-SHA256(double-SHA256(malign) || r) or
>    fast-SHA256(r || double-SHA256(malign))
>

or  fast-SHA256(fast-SHA256(double-SHA256(malign) || r1) || r0)
or  fast-SHA256(fast-SHA256(r1 || double-SHA256(malign)) || r0)
or ...


> where r is a freely chosen 32-byte nonce. This would allow the
> attacker to reveal the innocuous script before funds are sent to the
> MAST, then use the malign script to spend.
>
> Because of the double-SHA256 construction I do not see how this can be
> accomplished without a full break of SHA256.
>

The particular scenario I'm imagining is a collision between

    double-SHA256(innocuous)

and

    fast-SHA256(fast-SHA256(fast-SHA256(double-SHA256(malign) || r2) || r1)
|| r0).

where innocuous is a Bitcoin Script that is between 32 and 55 bytes long.

Observe that when data is less than 55 bytes then double-SHA256(data) =
fast-SHA256(fast-SHA256(padding-SHA256(data)) || 0x8000...100) (which is
really the crux of the matter).

Therefore, to get our collision it suffices to find a collision between

    padding-SHA256(innocuous)

and

    fast-SHA256(double-SHA256(malign) || r2) || r1

r1 can freely be set to the second half of padding-SHA256(innocuous), so it
suffices to find a collision between

   fast-SHA256(double-SHA256(malign) || r2)

and the first half of padding-SHA256(innocuous) which is equal to the first
32 bytes of innocuous.

Imagine the first opcode of innocuous is the push of a value that the
attacker claims to be his 33-byte public key.
So long as the attacker doesn't need to prove that they know the discrete
log of this pubkey, they can grind r2 until the result of
fast-SHA256(double-SHA256(malign) || r2) contains the correct first couple
of bytes for the script header and the opcode for a 33-byte push.  I
believe that is only about 3 or 4 bytes of they need to grind out.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/724c4de6/attachment.html>

From luke at dashjr.org  Thu Sep  7 19:02:17 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Thu, 7 Sep 2017 15:02:17 -0400
Subject: [bitcoin-dev] Proposal: bip32 version bytes for segwit scripts
In-Reply-To: <CA+_kfXJPfbGD6cDiPZ+7Z_rwUVS6JQNW8Vb-YsgD2wsPhHoBjw@mail.gmail.com>
References: <CA+_kfXJPfbGD6cDiPZ+7Z_rwUVS6JQNW8Vb-YsgD2wsPhHoBjw@mail.gmail.com>
Message-ID: <201709071502.19413.luke@dashjr.org>

On Tuesday 05 September 2017 15:00:04 Kabuto Samourai via bitcoin-dev wrote:
> I think Luke and Thomas may be talking past one another. When exporting a
> root master HD seed, encoding the {x,y,z}{pub,prv} distinctions makes no
> sense, as the root seed should derive all paths for all coins. Wallets may
> need additional code to discover which paths have been used when importing
> a root seed. But when exporting / importing an account-level seed for
> watch-only and receive address generation, changing the serialization
> version bytes is appropriate and (in our view) essential to avoid loss of
> funds.

In that case, I think we should go back to the proposal I started with in 
March...

https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013726.html

This handles not only simple HD seeds, but also multisig HD and such.

Luke

From andreas at schildbach.de  Thu Sep  7 19:35:49 2017
From: andreas at schildbach.de (Andreas Schildbach)
Date: Thu, 7 Sep 2017 21:35:49 +0200
Subject: [bitcoin-dev] Proposal: Extended serialization format for
	BIP-32 wallets
In-Reply-To: <84f4a4b8-fcbd-433b-9556-174ec5475f61@satoshilabs.com>
References: <0d405f5d-c0a4-bad7-b6c3-08ba4424bf17@satoshilabs.com>
	<8b4831a4-791e-c03e-baa4-16d9e5ead442@electrum.org>
	<84f4a4b8-fcbd-433b-9556-174ec5475f61@satoshilabs.com>
Message-ID: <oos72e$rjp$1@blaine.gmane.org>

On 09/07/2017 06:23 PM, Pavol Rusnak via bitcoin-dev wrote:
> On 07/09/17 06:29, Thomas Voegtlin via bitcoin-dev wrote:
>> A solution is still needed to wallets who do not wish to use BIP43
> 
> What if we added another byte field OutputType for wallets that do not
> follow BIP43?
> 
> 0x00 - P2PKH output type
> 0x01 - P2WPKH-in-P2SH output type
> 0x02 - native Segwit output type
> 
> Would that work for you?

I think that would work.

> The question is whether this field should be present only if depth==0x00
> or at all times. What is your suggestion, Thomas?

In case of Bitcoin Wallet, the depth is not null (m/0'/[0,1]) and still
we need this field. I think it should always be present if a chain is
limited to a certain script type.

There is however the case where even on one chain, script types are
mixed. In this case the field should be omitted and the wallet needs to
scan for all (known) types. Afaik Bitcoin Core is taking this path.


From stick at satoshilabs.com  Thu Sep  7 20:00:05 2017
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Thu, 7 Sep 2017 22:00:05 +0200
Subject: [bitcoin-dev] Proposal: Extended serialization format for
 BIP-32 wallets
In-Reply-To: <oos72e$rjp$1@blaine.gmane.org>
References: <0d405f5d-c0a4-bad7-b6c3-08ba4424bf17@satoshilabs.com>
	<8b4831a4-791e-c03e-baa4-16d9e5ead442@electrum.org>
	<84f4a4b8-fcbd-433b-9556-174ec5475f61@satoshilabs.com>
	<oos72e$rjp$1@blaine.gmane.org>
Message-ID: <40ed03a1-915c-33b0-c4ac-e898c8c733ba@satoshilabs.com>

On 07/09/17 21:35, Andreas Schildbach via bitcoin-dev wrote:
> In case of Bitcoin Wallet, the depth is not null (m/0'/[0,1]) and still
> we need this field.

But the depth of exported public key will be null. It does not make
sense to export xpub for m or m/0' for your particular case.

> I think it should always be present if a chain is
> limited to a certain script type.

I am fine with having the path there all the time.

> There is however the case where even on one chain, script types are
> mixed. In this case the field should be omitted and the wallet needs to
> scan for all (known) types. Afaik Bitcoin Core is taking this path.

Is that really the case? Why come up with a hierarchy and then don't use it?

-- 
Best Regards / S pozdravom,

Pavol "stick" Rusnak
CTO, SatoshiLabs

From mark at friedenbach.org  Thu Sep  7 20:04:30 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Thu, 7 Sep 2017 13:04:30 -0700
Subject: [bitcoin-dev] Fast Merkle Trees
In-Reply-To: <CAMZUoKk7dHy6urnGRzAB2UG_fkwXmQrRHDfFYOHa0sTStr=yAQ@mail.gmail.com>
References: <CAMZUoKmD4v4vn9L=kdyJNk-km3XHpNVkD_tmS+SseMsf6YaVPg@mail.gmail.com>
	<F1D041D0-FC5A-425C-835D-37E7A9C0CFC5@friedenbach.org>
	<CAMZUoKmhN=m4TFwJi7u1bibLJ6mYvpnkddWTZZWdHn7+mVcJvw@mail.gmail.com>
	<EB804508-715A-4CD6-9B87-09845368DAC0@friedenbach.org>
	<CAMZUoKk7dHy6urnGRzAB2UG_fkwXmQrRHDfFYOHa0sTStr=yAQ@mail.gmail.com>
Message-ID: <40D6F502-3380-4B64-BCD9-80D361EED35C@friedenbach.org>

TL;DR I'll be updating the fast Merkle-tree spec to use a different
      IV, using (for infrastructure compatability reasons) the scheme
      provided by Peter Todd.

This is a specific instance of a general problem where you cannot
trust scripts given to you by another party. Notice that we run into
the same sort of problem when doing key aggregation, in which you must
require the other party to prove knowledge of the discrete log before
using their public key, or else key cancellation can occur.

With script it is a little bit more complicated as you might want
zero-knowledge proofs of hash pre-images for HTLCs as well as proofs
of DL knowledge (signatures), but the basic idea is the same. Multi-
party wallet level protocols for jointly constructing scriptPubKeys
should require a 'delinearization' step that proves knowledge of
information necessary to complete each part of the script, as part of
proving the safety of a construct.

I think my hangup before in understanding the attack you describe was
in actualizing it into a practical attack that actually escalates the
attacker's capabilities. If the attacker can get you to agree to a
MAST policy that is nothing more than a CHECKSIG over a key they
presumably control, then they don't need to do any complicated
grinding. The attacker in that scenario would just actually specify a
key they control and take the funds that way.

Where this presumably leads to an actual exploit is when you specify a
script that a curious counter-party actually takes the time to
investigate and believes to be secure. For example, a script that
requires a signature or pre-image revelation from that counter-party.
That would require grinding not a few bytes, but at minimum 20-33
bytes for either a HASH160 image or the counter-party's key.

If I understand the revised attack description correctly, then there
is a small window in which the attacker can create a script less than
55 bytes in length, where nearly all of the first 32 bytes are
selected by the attacker, yet nevertheless the script seems safe to
the counter-party. The smallest such script I was able to construct
was the following:

    <fake-pubkey> CHECKSIGVERIFY HASH160 <preimage> EQUAL

This is 56 bytes and requires only 7 bits of grinding in the fake
pubkey. But 56 bytes is too large. Switching to secp256k1 serialized
32-byte pubkeys (in a script version upgrade, for example) would
reduce this to the necessary 55 bytes with 0 bits of grinding. A
smaller variant is possible:

    DUP HASH160 <fake-pubkey-hash> EQUALVERIFY CHECKSIGVERIFY HASH160 <preimage> EQUAL

This is 46 bytes, but requires grinding 96 bits, which is a bit less
plausible.

Belts and suspenders are not so terrible together, however, and I
think there is enough of a justification here to look into modifying
the scheme to use a different IV for hash tree updates. This would
prevent even the above implausible attacks.


> On Sep 7, 2017, at 11:55 AM, Russell O'Connor <roconnor at blockstream.io> wrote:
> 
> 
> 
> On Thu, Sep 7, 2017 at 1:42 PM, Mark Friedenbach <mark at friedenbach.org <mailto:mark at friedenbach.org>> wrote:
> I've been puzzling over your email since receiving it. I'm not sure it
> is possible to perform the attack you describe with the tree structure
> specified in the BIP. If I may rephrase your attack, I believe you are
> seeking a solution to the following:
> 
> Want: An innocuous script and a malign script for which
> 
>    double-SHA256(innocuous)
> 
> is equal to either
> 
>    fast-SHA256(double-SHA256(malign) || r) or
>    fast-SHA256(r || double-SHA256(malign))
> 
> or  fast-SHA256(fast-SHA256(double-SHA256(malign) || r1) || r0)
> or  fast-SHA256(fast-SHA256(r1 || double-SHA256(malign)) || r0)
> or ...
>  
> where r is a freely chosen 32-byte nonce. This would allow the
> attacker to reveal the innocuous script before funds are sent to the
> MAST, then use the malign script to spend.
> 
> Because of the double-SHA256 construction I do not see how this can be
> accomplished without a full break of SHA256. 
> 
> The particular scenario I'm imagining is a collision between
> 
>     double-SHA256(innocuous)
> 
> and 
> 
>     fast-SHA256(fast-SHA256(fast-SHA256(double-SHA256(malign) || r2) || r1) || r0).
> 
> where innocuous is a Bitcoin Script that is between 32 and 55 bytes long.
> 
> Observe that when data is less than 55 bytes then double-SHA256(data) = fast-SHA256(fast-SHA256(padding-SHA256(data)) || 0x8000...100) (which is really the crux of the matter).
> 
> Therefore, to get our collision it suffices to find a collision between
> 
>     padding-SHA256(innocuous)
> 
> and
> 
>     fast-SHA256(double-SHA256(malign) || r2) || r1
> 
> r1 can freely be set to the second half of padding-SHA256(innocuous), so it suffices to find a collision between
> 
>    fast-SHA256(double-SHA256(malign) || r2)
> 
> and the first half of padding-SHA256(innocuous) which is equal to the first 32 bytes of innocuous.
> 
> Imagine the first opcode of innocuous is the push of a value that the attacker claims to be his 33-byte public key.
> So long as the attacker doesn't need to prove that they know the discrete log of this pubkey, they can grind r2 until the result of fast-SHA256(double-SHA256(malign) || r2) contains the correct first couple of bytes for the script header and the opcode for a 33-byte push.  I believe that is only about 3 or 4 bytes of they need to grind out.
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170907/63af0292/attachment.html>

From thomasv at electrum.org  Thu Sep  7 20:39:17 2017
From: thomasv at electrum.org (Thomas Voegtlin)
Date: Thu, 7 Sep 2017 22:39:17 +0200
Subject: [bitcoin-dev] Proposal: Extended serialization format for
 BIP-32 wallets
In-Reply-To: <84f4a4b8-fcbd-433b-9556-174ec5475f61@satoshilabs.com>
References: <0d405f5d-c0a4-bad7-b6c3-08ba4424bf17@satoshilabs.com>
	<8b4831a4-791e-c03e-baa4-16d9e5ead442@electrum.org>
	<84f4a4b8-fcbd-433b-9556-174ec5475f61@satoshilabs.com>
Message-ID: <9e74dc17-105c-b43c-7780-4fa690043fe2@electrum.org>



On 07.09.2017 18:23, Pavol Rusnak wrote:
> On 07/09/17 06:29, Thomas Voegtlin via bitcoin-dev wrote:
>> A solution is still needed to wallets who do not wish to use BIP43
> 
> What if we added another byte field OutputType for wallets that do not
> follow BIP43?
> 
> 0x00 - P2PKH output type
> 0x01 - P2WPKH-in-P2SH output type
> 0x02 - native Segwit output type
> 
> Would that work for you?
> 
> The question is whether this field should be present only if depth==0x00
> or at all times. What is your suggestion, Thomas?
> 


well, in my initial proposal, I wrote that this value should be user
visible. That is why I used version bytes. If you create an extra byte
field, and then use base58 or bech32 encoding, the value will not be
user visible anymore.

The initial implementation of segwit xpub/xprv in Electrum used a flag
that was not user visible (I added 1 to the bip32 version bytes, which
leaves the xpub/xprv prefix unchanged). I have experimented with that
invisible flag for more than 6 months now, and I am now convinced that
it is better to make that flag user visible.

The reason is that when users create wallets with multisig scripts, they
need to combine several master public keys. However, these master public
keys should all be of the same type: it would not make sense to create a
2 of 3 multisig wallet with a one xpub, one ypub and one zpub. By
imposing that all master keys are of the same type, we ensure that all
cosigners agree on the script type that will be used to derive addresses.

In other words, if users are exposed to master keys and need to
manipulate them, it is better to let them see what they are doing.

OTOH if you do not plan to expose your users to these keys, you probably
do not need a serialization format.

From jl2012 at xbt.hk  Fri Sep  8 09:21:22 2017
From: jl2012 at xbt.hk (Johnson Lau)
Date: Fri, 8 Sep 2017 17:21:22 +0800
Subject: [bitcoin-dev] Merkle branch verification & tail-call semantics
 for generalized MAST
In-Reply-To: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
Message-ID: <26AD157C-A5A9-48C3-8D29-0AD1ED35EDDD@xbt.hk>

Some comments with the tail-call execution semantics BIP:

Tail-call execution semantics require ?unclean stake?, i.e. final stake with more than one item. However, ?unclean stake? is invalid (not just non-standard) in BIP141, so you could only use it with legacy P2SH (which is totally pointless?.). A different design like OP_EVAL might be needed, or you need a new witness script version.

I think you have also missed the sigOp counting of the executed script. As you can?t count it without executing the script, the current static analysability is lost. This was one of the reasons for OP_EVAL being rejected. Since sigOp is a per-block limit, any OP_EVAL-like operation means block validity will depend on the precise outcome of script execution (instead of just pass or fail), which is a layer violation.

(An alternative is to make sigOp a per-input limit instead of per-block limit, just like the 201 nOp limit. But this is a very different security model)

Witness script versioning is by design fully compatible with P2SH and BIP173, so there will be no hurdle for existing wallets to pay to BIP114. Actually it should be completely transparent to them.

For code complexity, the minimal BIP114 could be really simple, like <30 lines of code? It looks complex now because it does much more than simply hiding scripts in a hash.



> On 7 Sep 2017, at 8:38 AM, Mark Friedenbach via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> I would like to propose two new script features to be added to the
> bitcoin protocol by means of soft-fork activation. These features are
> a new opcode, MERKLE-BRANCH-VERIFY (MBV) and tail-call execution
> semantics.
> 
> In brief summary, MERKLE-BRANCH-VERIFY allows script authors to force
> redemption to use values selected from a pre-determined set committed
> to in the scriptPubKey, but without requiring revelation of unused
> elements in the set for both enhanced privacy and smaller script
> sizes. Tail-call execution semantics allows a single level of
> recursion into a subscript, providing properties similar to P2SH while
> at the same time more flexible.
> 
> These two features together are enough to enable a range of
> applications such as tree signatures (minus Schnorr aggregation) as
> described by Pieter Wuille [1], and a generalized MAST useful for
> constructing private smart contracts. It also brings privacy and
> fungibility improvements to users of counter-signing wallet/vault
> services as unique redemption policies need only be revealed if/when
> exceptional circumstances demand it, leaving most transactions looking
> the same as any other MAST-enabled multi-sig script.
> 
> I believe that the implementation of these features is simple enough,
> and the use cases compelling enough that we could BIP 8/9 rollout of
> these features in relatively short order, perhaps before the end of
> the year.
> 
> I have written three BIPs to describe these features, and their
> associated implementation, for which I now invite public review and
> discussion:
> 
> Fast Merkle Trees
> BIP: https://gist.github.com/maaku/41b0054de0731321d23e9da90ba4ee0a
> Code: https://github.com/maaku/bitcoin/tree/fast-merkle-tree
> 
> MERKLEBRANCHVERIFY
> BIP: https://gist.github.com/maaku/bcf63a208880bbf8135e453994c0e431
> Code: https://github.com/maaku/bitcoin/tree/merkle-branch-verify
> 
> Tail-call execution semantics
> BIP: https://gist.github.com/maaku/f7b2e710c53f601279549aa74eeb5368
> Code: https://github.com/maaku/bitcoin/tree/tail-call-semantics
> 
> Note: I have circulated this idea privately among a few people, and I
> will note that there is one piece of feedback which I agree with but
> is not incorporated yet: there should be a multi-element MBV opcode
> that allows verifying multiple items are extracted from a single
> tree. It is not obvious how MBV could be modified to support this
> without sacrificing important properties, or whether should be a
> separate multi-MBV opcode instead.
> 
> Kind regards,
> Mark Friedenbach
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From jl2012 at xbt.hk  Fri Sep  8 09:49:46 2017
From: jl2012 at xbt.hk (Johnson Lau)
Date: Fri, 8 Sep 2017 17:49:46 +0800
Subject: [bitcoin-dev] BIP114 Merklized Script update and 5 BIPs for new
	script functions
Message-ID: <7009A9E5-BC68-4830-991B-36C3837618D6@xbt.hk>

I have rewritten and simplified BIP114, and renamed it to ?Merklized Script?, as a more accurate description after consulting the original proposers of MAST. It could be considered as a special case of MAST, but has basically the same functions and scaling properties of MAST.

Compared with Friedenbach?s latest tail-call execution semantics proposal, I think the most notable difference is BIP114 focuses on maintaining the static analysability, which was a reason of OP_EVAL (BIP12) being rejected. Currently we could count the number of sigOp without executing the script, and this remains true with BIP114. Since sigOp is a block-level limit, any OP_EVAL-like operation means block validity will depend on the precise outcome of script execution (instead of just pass or fail), which is a layer violation.

Link to the revised BIP114: https://github.com/jl2012/bips/blob/vault/bip-0114.mediawiki

On top of BIP114, new script functions are defined with 5 BIPs:

VVV: Pay-to-witness-public-key: https://github.com/jl2012/bips/blob/vault/bip-0VVV.mediawiki
WWW: String and Bitwise Operations in Merklized Script Version 0: https://github.com/jl2012/bips/blob/vault/bip-0WWW.mediawiki
XXX: Numeric Operations in Merklized Script Version 0: https://github.com/jl2012/bips/blob/vault/bip-0XXX.mediawiki
YYY: ECDSA signature operations in Merklized Script Version 0: https://github.com/jl2012/bips/blob/vault/bip-0YYY.mediawiki
ZZZ: OP_PUSHTXDATA: https://github.com/jl2012/bips/blob/vault/bip-0ZZZ.mediawiki

As a summary, these BIPs have the following major features:

1. Merklized Script: a special case of MAST, allows users to hide unexecuted branches in their scripts (BIP114)
2. Delegation: key holder(s) may delegate the right of spending to other keys (scripts), with or without additional conditions such as locktime. (BIP114, VVV)
3. Enabling all OP codes disabled by Satoshi (based on Elements project with modification. BIPWWW and XXX)
4. New SIGHASH definition with very high flexibility (BIPYYY)
5. Covenant (BIPZZZ)
6. OP_CHECKSIGFROMSTACK, modified from Elements project (BIPYYY)
7. Replace ~72 byte DER sig with fixed size 64 byte compact sig. (BIPYYY)

All of these features are modular and no need to be deployed at once. The very basic BIP114 (merklized script only, no delegation) could be done quite easily. BIP114 has its own versioning system which makes introducing new functions very easy.

Things I?d like to have:

1. BIP114 now uses SHA256, but I?m open to other hash design
2. Using Schnorr or similar signature scheme, instead of ECDSA, in BIPYYY.

Reference implementation: https://github.com/jl2012/bitcoin/commits/vault

From kravets at gmail.com  Fri Sep  8 08:06:01 2017
From: kravets at gmail.com (Alex Kravets)
Date: Fri, 08 Sep 2017 08:06:01 +0000
Subject: [bitcoin-dev] [BIP Proposal] Token Protocol Specification
In-Reply-To: <a72b52aa-10b5-d256-280b-a72cac3bf92d@token21.com>
References: <a72b52aa-10b5-d256-280b-a72cac3bf92d@token21.com>
Message-ID: <CALMbsiJ5_YWfyFcEV19mvKUFazAbrbe0ZABO2PsCvfbu4zv6KA@mail.gmail.com>

Hi Luca,

Bravissimo!

Please allow me to encourage your to follow the BIP workflow as specified
here
https://github.com/bitcoin/bips/blob/master/bip-0002.mediawiki#BIP_workflow

BIP Editor freely allocates BIP numberss, however that does not constitute
approval but allows for much easier discussion of and communication about
the proposal.

Good luck !


On Wed, Sep 6, 2017 at 9:08 AM Luca Venturini via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi everyone,
>
> I would like to propose a standard protocol to manage tokens on top of
> the Bitcoin blockchain.
>
> The full text is enclosed and can be found here:
>
> https://github.com/token21/token-protocol-specification
>
> Any feedback will be appreciated.
>
> Luca Venturini
>
> ---
>
> Abstract
> ========
> This document describes a protocol to manage digital assets (tokens) on
> top of the bitcoin blockchain. The protocol enables a semantic layer
> that permits reading the bitcoin transactions as operations related to
> tokens.
>
> The protocol allows a new level of plausible deniability, while
> permitting statefull public auditability on each issued token. It allows
> both the user and the issuer to deny that an existing bitcoin
> transaction between the two is actually a token transaction, or a new
> token issuance. While both the token sender and the token issuer cannot
> deny to have sent bitcoins, nobody can prove the transaction was related
> to a digital asset. On top of that, to guarantee plausible deniability,
> tokens can be issued, sent, and received using any existing bitcoin
> client software.
>
> There is no need to have a wallet exclusively dedicated to manage the
> tokens. With a few simple precautions by the user, tokens can be managed
> using any existing Bitcoin wallet, while it is used for normal bitcoin
> transactions as well.
>
> Since it is possible to infinitely split a token in parts, there is no
> definition of the number of decimals of token generated and transferred.
> The number of tokens is always an integer.
>
> Every operation of the protocol is performed with Bitcoin transactions,
> without the use of OP_RETURN and without any form of pollution of the
> blockchain, or of the UTXO set.
>
> The protocol permits atomic buy and sell transactions between tokens and
> Bitcoin, and between different types of tokens. The only operations that
> require a coin selection enabled wallet are the split and join special
> operations and the token offering issuance operations. Those are used to
> modify the token unit of measure and to receive bitcoins from third
> parties during a token offering issuance.
>
> Copyright
> =========
> This document is licensed under the 2-clause BSD license.
>
> Motivation
> ==========
> The current protocols that permit to issue tokens based on the bitcoin
> blockchain (i.e. Counterparty, Omni, Colored Coins, Coinprism, Colu) are
> flawed.
>
> The existing solutions usually need dedicated wallets and/or
> verification nodes. Usually, a "pivot" currency is involved and atomic
> transactions are not permitted unless they use the pivot currency. Those
> protocols pollute the blockchain (30% or more) and in some cases they do
> not accept P2SH scripts. Since the use of a dedicated wallet is
> required, the users cannot plausibly deny they have got tokens.
> Plausible deniability on the issuer side is not available either. None
> of these protocols permits infinite division of the tokens, so usually
> the number of decimals has to be specified at issuance time. The
> automatic token offering issuance is not enabled as well.
>
> Rationale
> =========
> Let's take an example from the real world, a yacht. We write on the
> yacht's license that the owner is any person that can show a one dollar
> bill having the serial number F82119977F. Thus the one dollar bill can
> be exchanged between owners with extreme simplicity and full plausible
> deniability. The US government will guarantee that there is no other
> person having the same dollar bill.
>
> The protocol permits managing a token in the same way. The underlying
> Bitcoin protocol will guarantee against double spending.
>
> Features:
>
>   - Easy of use. Tokens can be managed using any wallet. Even if the
> wallet has no coin selection feature.
>   - Plausible Deniability by the issuer. The issuer can generate a new
> type of token and nobody analyzing the blockchain will understand that
> the transaction is issuing a token. Even if a token is known, the issuer
> can issue other tokens. Since a single output contains a large number of
> different token types, the issuer is actually generating different types
> of tokens every time she sends a new Bitcoin transaction to the network.
>   - Plausible Deniability by the user (no use of tokens at all, or use
> of a different token type). A transaction that sends tokens from Alice
> to Bob is a normal transaction. Nobody can understand that this
> transaction is moving tokens unless they explicitly know which
> transaction is the token issuance. In fact a single address contains a
> large number of token types, and the use of tokens itself can be denied.
>   - Accountability. Everybody can see the state of the distribution of a
> type of token.
>   - Tunnel mode (confidentiality by issuer and user versus a third
> party). Alice can send tokens to Bob and ask him to give the tokens to
> Charlie, without telling to Bob what is the type of the token given.
> Alice can disclose this information in the future, if she wants.
>   - It is possible to perform open or closed issuances. While an open
> issuance permits to continue the issuance of tokens in the future,
> closed issuance guarantees that no other token of the same type will
> ever be issued.
>   - The power to continue the issuance of an open token can be sent to
> another address, using a transaction. Once the power to continue the
> issuance is sent to someone, the former issuer cannot issue any more
> tokens.
>   - The power to continue the issuance has the same features of
> plausible deniability of the possess of a token.
>   - Since a token type is uniquely identified by a transaction hash, or,
> in some cases, by a Bitcoin address, a user can prove to be the issuer
> by signing a message using the Bitcoin protocol.
>   - Future proof. Tokens can move following P2PKH, P2SH, P2SH-P2WPKH
> outputs or any other type of script
>   - Blockchain pollution of the protocol transactions is almost zero.
> There is no OP_RETURN involved, nor any other type of "fake" addresses
> that pollute the UTXO database.
>   - The protocol is based on the Bitcoin blockchain, but, with small
> changes, can be considered blockchain agnostic.
>   - Atomic transactions between tokens and Bitcoin are possible.
>   - Atomic transactions between different types of tokens are possible.
>   - Tokens of different types can be held by the same address and by the
> same output.
>   - Tokens can be divided indefintely, thus having any number of decimals.
>   - Tokens can be issued automatically on the receiving of bitcoins.
> This operation performs a token offering issuance (also known as Initial
> Coin Offering).
>
> Introduction
> ============
>
> Where are the tokens?
> ---------------------
> As with bitcoins, tokens are contained in unspent Bitcoin outputs. In
> some cases, defined below, the last five digits of the satoshi value
> sent to the output represent the number of tokens contained in the output.
>
> When an output is spent, the tokens contained in the output are fully
> spent in the same transaction. There are no tokens outside of the tokens
> contained in the UTXO database.
>
> Token issuance
> --------------
> The large majority of bitcoin transactions can be semantically seen as
> token issuances. There are two types of token issuances: closed and
> opened. A closed token issuance guarantees that no other token of the
> same type will ever be issued.
>
> Issuance chains
> ---------------
> An open issuance gives to one, or more, of its output the power to
> continue the issuance of tokens of the same type. We define such a power
> as Power of Continuation (POC). The transaction that will spend the
> output appointed with the POC will be a continuation of the same
> issuance chain.
>
> Every transaction of the chain will issue the same type of token. On top
> of that, every transaction that is part of the chain, can also be seen
> as as issuance of tokens of its, new, type. A chain will be closed by a
> transaction having more than one output and the first output with five
> zeros as the last five digits of the satoshis value. No other
> transactions can send tokens of the same type after the close of the
> issuance.
>
> Token names
> -----------
> A token type can have multiple names. The default name is the hash of
> the first transaction that issued the token.
>
> i.e: 68330b6ab26e44f9c3e515f04d15ffe6547f29e60b809a47e50d9abf59045c1e
>
> As alternative names, a token type can be named after the bitcoin
> address of one of the outputs of the transaction that first issued the
> token, provided the fact that the address has never been used before in
> the blockchain.
>
> Note: it is better to use one of the alternate names in cases when
> transaction malleability is a concern.
>
> Vanity token names
> ------------------
> A token can be identified using only the first characters of the Bitcoin
> address, as alternate name defined above, if the characters are
> different from every previous Bitcoin address seen in the blockchain. An
> example is provided below.
>
> Tokens can coexist
> -------------------
> Token of different types can coexist in a single output while remaining
> of different types. Thus a bitcoin address (actually an output of the
> UTXO database) can hold tokens of different types. Every Bitcoin address
> contains a lot of types of tokens, so that a user usually does not know
> all the type of tokens contained in an address.
>
> A single transaction can send a type of token to some of the outputs
> while sending another type of token to a different set of its outputs.
> Tokens are never burned or deleted.
>
> Use the protocol
> ================
> This section explains a basic use case. In all the examples provided, we
> do not consider the fee. We assume that there is another input, not
> listed, that pays the transaction fee.
>
> Alice, Bob, Charlie, and Daniel decides that they want to start a new
> company. Each of them will give to the new company some time, money,
> furniture, knowledge. They decide everyone contributed to the company
> with a percentage of value as follows: Alice - 40%, Bob - 12%, Charlie -
> 34% and Daniel - 14%. They decide that the shares of the new company can
> be freely resold to others and that they will accept that the annual
> meeting will consent vote through messages signed using the Bitcoin
> protocol by the owners of the shares.
>
> Issue tokens
> ------------
> Alice asks Bob, Charlie, and Daniel to send her 1 Bitcoin each. She asks
> each of them to give her a bitcoin address where they want to receive
> back the bitcoins along with the tokens.
>
> She asks Charlie to generate a vanity address that has never been used
> before of type 1CompanyXWXjLgud9jxwxm34u.... Since there has been a
> previous address in the blockchain having 1Companx as the first
> characters, but this is the first address seen in the blockchain that
> has 1Company as the first characters, they will call the token with the
> name 1Company. This step is optional.
>
> Then she sends, from her wallet, a transaction having the following
> outputs:
>
>   - 1.00000040 to an address controlled by Alice
>   - 1.00000012 to an address controlled by Bob
>   - 1.00000034 to the vanity address 1CompanyXWXjLgud9jxwxm34u...
> controlled by Charlie
>   - 1.00000014 to an address controlled by Daniel
>   - 3.45322112 is the change generated by Alice's wallet
>
> This transaction gives 40, 12, 34, 14 tokens to each one. The newly
> generated token type can be named after the transaction hash, or after
> the vanity address (optional), or after one of the addresses of the
> persons involved, provided that the address has never been used before.
>
> The issuance is still open. Since they do not want to issue more shares,
> they decide to close the issuance (on the other side, they could decide
> to leave the issuance open and to hold the issuing key somewhere, or to
> have a multisignature address and to give the keys to the directors of
> the company). In order to close the issuance, Alice generates the
> following transaction that sends bitcoins from her wallet to addresses
> of her same wallet, using the change output of the previous transaction
> as an input:
>
>   - 0.45000000 to an address of her wallet
>   - 3.00322112 change generated by the wallet
>
> This closes the issuance.
>
> Send tokens
> --------------
> After some while, Bob decides to give some shares of the company to his
> husband Giacomo. He generates a new transaction spending the output of
> the issuance transaction:
>
>   - 0.03400008 to Giacomo
>   - 0.96600004 change generated by Bob's wallet
>
> This transaction gives to Giacomo 8 shares of the company.
>
> Atomic transactions
> -------------------
> Daniel wants to sell 3 of his 14 shares to Frank. They negotiate a price
> of 0.00323200 bitcoin per share. This is a total of 0.00969600 bitcoin
> to buy the three shares. They do not know each other very well, so they
> decide to make an atomic transaction that will give 0.00969600 bitcoins
> to Daniel and 3 shares to Frank. Daniel set an input of the new
> transaction with his issuance transaction output. Frank put in another
> input of 1.23242454 bitcoins from his wallet. The outputs of the
> transaction are as follows:
>
>   - 0.22400003 to an address controlled by Frank (this gives the 3
> shares to Frank)
>   - 0.23200000 to an address controlled by Daniel (this is part of the
> payment to Daniel)
>   - 0.77769614 to an address controlled by Daniel (this can be
> considered the change of the original issuance output of 1.00000014)
>   - 0.99872851 to an address controlled by Frank (change to Frank)
>
> Daniel sent to the inputs of the transaction 1.00000014 bitcoins and
> receives back 1.00969614. This gives to Daniel the 0.00969600 paid by
> Frank. On the other side, Frank sends 1.23242454 as an input of the
> transaction and receives back 1.22272854 bitcoins, thus paying exactly
> the 0.00969600 that needs to be paid to Daniel. This transaction sends 3
> tokens from Daniel to Frank. Another 11 tokens are the tokens that are
> given as a change to Daniel, along with 0.23200000 bitcoins.
>
> Specification
> =============
>
> Definitions
> -----------
> In order to evaluate a transaction, the outputs are sorted by the
> satoshis value. Once sorted, we define a "cut" output the first output
> having five zeros as the last five digits of the satoshi value (satoshis
> modulo 10^5 == 0). In the following, "first", "second", "last" are all
> referred to the sorted outputs.
>
> We define as "signal" of an output the value of satoshis of the output
> modulo 10^5. This is the last five digits of the value, as expressed in
> satoshis.
>
> Despite not mandatory, we sometimes call "c", or "change", the output
> having the biggest value in Satoshi. This is the last output, as sorted
> above. Such behavior follows the "Guidelines" section, explained below.
>
> We use n=0 related to a sequence a1, ..., an, to indicate that there are
> no elements in the sequence.
>
> Issuance of a token
> -------------------
> A transaction that has only one output, or has the first output that is
> a cut, issues no token. Every other Bitcoin transaction is an issuance
> of tokens of the type of the transaction.
>
> When a issuance is open, Power of Continuation (POC), will be given to
> an output that will be spent in a transaction that continues the
> issuance of the same type of tokens.
>
> As for the protocol behavior, we divide the structure of the sorted
> outputs of a bitcoin transaction in the following groups. For each
> group, a description of the behavior of the protocol is provided.
>
>   - a1, ..., an, cut(POC), z1(POC), ... zm(POC), b1, ..., bl, with n>0,
> m>=0, m+l>0
>       * zi are outputs signaling zero. They are optional.
>       * This is an open issuance. It generates the number of tokens
> signaled by the outputs before the cut: a1, ..., an. Every output of
> that set receives a number of tokens as signaled by the output satoshis'
> value.
>       * The cut output, and every other output zi, signaling zero, that
> is directly after the cut, receive the POC. This means that the
> transactions that will spend the POC will be a continuation of this
> issuance and a continuation of every issuance that gave the POC to the
> this transaction.
>   - cut, b1, ..., bm with m>0 (a cut alone is a case of the fourth type)
>       * This is a particular case of the first group, having n=0 and
> m=0. This transaction *closes the issuance forever*. Every token's chain
> that ends into this transaction is closed as well.
>       * It generates no tokens and there are no other outputs that can
> continue the issuance in the future.
>       * If b1 or b2 have a signal of zero and m>2, this is a token
> offering issuance transaction. It will be described in a following section.
>   - a1, ..., an, c(POC) with n>0
>       * This is an open issuance. It generates the number of tokens that
> are signaled in a1, ..., an. The last output c will not receive tokens.
>       * The last output c will receive the POC. A following transaction
> that spends the output c is an issuance transaction of the same type of
> token.
>       * The fact that c is a cut (or not) does not modify the behavior
> of the transactions of this group
>   - c(POC) (single output, also seen as the previous one, with n=0)
>       * This transaction generates no tokens at all.
>       * The output c receives the POC. Thus a following transaction that
> spends the output c is an issuance transaction of the same type of token.
>
> Notes on token issuances
> ------------------------
> The number of tokens generated by an issuance transaction is always the
> sum of the signals of all the outputs, excluding the last one and the
> outputs that are listed after a cut. Thus the number of tokens sent to
> each output, that receives tokens, is always the number signaled by the
> output.
>
> Who has the power to generate other tokens of the same issuance (POC):
>
>   - If there is no cut, the issuance is open and the transaction that
> will spend the last (biggest) output can continue to generate token of
> the same type.
>   - If there is a cut, in a position different than the first, the
> issuance is open. The cut output will be the input of a following
> transaction that issues more tokens of the same issuance chain. The
> following transaction can close tha chain, or can be an open issuance,
> thus having another output that will continue the generation chain.
>
> In order to close forever the issuance of tokens, the transaction should
> have a cut as the first output and have more than one output.
>
> Transfer of tokens
> ------------------
> Every bitcoin transaction spends all the tokens' content of the inputs
> and sends them to the outputs. Some of the outputs receive the number of
> tokens exactly stated in the last five digits of the satoshis sent (the
> signal), in a way similar to an issuance transaction.
>
> A transaction can be seen as having one of the three following shapes
> (ai means an output that is not a cut, bi and c are outputs that can be
> cut):
>
>   - a1, ..., an, cut, b1, ..., bm, c (transactions with a cut) (n=0 is
> described here)
>       * No output (bi) after a cut receives tokens.
>       * Tokens will be assigned to outputs a1, ..., an trying to follow
> the signal as follows:
>           - If there are enough tokens, the tokens signaled by the first
> output are assigned to that output.
>           - If there are still remaining tokens, the tokens are sent to
> the following output based on the signal.
>           - This continues until there is a cut or the tokens signaled
> by an output are more than the remaining tokens. In these cases:
>               * If there is a cut, it receives all the remaining tokens.
>               * If there is an output receiving more tokens than the
> remaining tokens (we define it a "remaining error"), the output receives
> no token at all. No other output will receive tokens after this and all
> the remaining tokens will be sent to the last output c (thus, if there
> is a cut in the transaction, the algorithm "jumps" the cut).
>               * If there is a "remaining error" and the transaction is a
> special transaction as defined in the next section, and the number of
> tokens in input is exactly the same of the two types (big and small)
> that are the result of a previous split or join special transaction, the
> "remaining error" output gets one of the smallest tokens involved. This
> will be better explained in the following section about "special
> transactions".
>       * If the first output is a cut, and the transaction is not a
> special one as defined below in the document, the last output (c)
> receives all the tokens
>   - a1, ..., an, c (ai is not a cut, for every i; c can be a cut)
>       * The tokens are assigned to a1, ..., an as described in the
> previous group.
>       * The last output c receives all the remaining tokens. This
> behavior is not modified by the fact that the last output is a cut.
>   - c (single output transaction, also seen as the previous one, with n=0)
>       * The output receives all the tokens received from the inputs
>
> Transactions receiving both the POC of an issuance and some tokens of
> the same issuance
>
> ---------------------------------------------------------------------------------------
> The protocol is designed such that a transaction of an issuance chain
> never issue new tokens to an output, that receives the POC of the same
> type of token. But two different inputs can give to a transaction both
> some tokens and the POC of the same type of token. In this case, there
> is a double role for the transaction that is both a continuation of the
> issuance and a transfer transaction sending tokens of the same type.
>
> In this case, the tokens will be allocated as defined in the following
> four different shapes of transaction:
>
>   - a1, ..., an, cut, b1, ..., bm, c (transaction with a cut)
>       * The generated tokens are sent to the outputs a1, ..., an as
> described in the definition of an issuance of tokens
>       * All the tokens received in input of the same type of the
> issuance we are continuing will be sent to the cut output
>   - a1, ..., an, c (transaction without a cut, or with c that is a cut:
> ai is not a cut, for every i)
>       * The generated tokens are sent to the outputs a1, ..., an as
> described in the definition of an issuance of tokens transaction
>       * All the tokens received in input, of the same type of the
> issuance we are continuing, will be sent to the last output c
>   - cut, b1, ..., bm
>       * The issuance will be closed and all the tokens will be given to
> the last output bm. The behavior described in the issuance transaction
> and in the transaction sending tokens do not influence each other, in
> this case.
>       * If it is a special transaction, as defined below, there is no
> overlap between the definitions. The issuance chain is closed and the
> received tokens will be given as defined.
>   - c only
>       * The definitions of issuance transaction and transfer transaction
> can be used. The issuance will remain open and the address will receive
> all the tokens received from the inputs
>
> Since both the first and the second group of transactions are giving the
> POC to the same output that receives the tokens, the output will
> continue to carry both the tokens received and the POC. This delegates
> someone to issue new tokens and allocates some tokens from a previous
> issuance that are still not assigned.
>
> Split and join transactions
> ---------------------------
> A split or join transaction is one that has one of the following formats
> of outputs:
>
>   - cut, a1, ..., an, z, b1, ..., bm (z is an output signaling zero,
> like a cut)
>   - cut, a1, ..., an, c
>
> having the added condition that the sum of the signals of the outputs
> a1, ..., an is:
>
>   - equal to the number of tokens received in input divided by 1000 (we
> call it a join transaction), or
>   - equal to the number of tokens received in input multiplied by 1000
> (we call it a split transaction)
>
> Since the presence of these two extra conditions, the fact that a
> transaction is a join or split transaction, or it is not (hence it is a
> simple transfer transaction), depends on the number of tokens received
> in the input. A given transaction can be both split or join for some
> type of tokens, and normal for other types of tokens.
>
> Note: this is the same format that closes an issuance chain. If the
> transaction receives both POC and tokens of the same type, the
> transaction chain will be closed and the received tokens will be sent as
> described here.
>
> Note: this is also the format of a transfer transaction that assigns to
> the change c or bm, the token received in the input. But, if a
> transaction is a special one of the first two types, that behavior
> should not be considered and no tokens will be transferred to the change.
>
> The split transaction generates a new type of tokens with a value that
> is one thousandth of the value of the type of tokens received in the
> input. This new type can be mixed with tokens generated by other similar
> split transactions, based on the same original token. Split tokens have
> the same value and can be joined in the future with join transactions.
>
> The join transaction generates a new type of tokens with one thousand
> times the value of the type of tokens received in the input. This new
> type of token can coexist with tokens generated by other similar join
> transactions, based on the same original token. Joined tokens from the
> same original token, have the same value and can be split in the future
> with split transactions. Thus becoming again original tokens.
>
> In a special transaction of the second group, without "the second cut"
> z, the change is mandatory and does not receive tokens. This means that
> the number of tokens sent is summed up without the last output. If the
> number is not correct, then it is not a split or join transaction.
>
> Tokens split or joined are of a different type than their original
> source. This means that they can coexist in the same output and will
> never mix together. Thus a output having 3 big tokens and 456 tokens
> obtained by a split transaction, seems to have 3.456 tokens, but, in
> fact, has 3 tokens of a type and 456 tokens of another type (the second
> type is referred as the original type with a 0.001 unit of measure).
>
> Note: as described below, there is a procedure of separating tokens of
> different types contained in the same output. This procedure will not
> work if the two type of tokens are present in the same output in the
> same number. Thus if an output contains exactly 3.003 tokens (3 big and
> 3 small), the tokens cannot be separated anymore. This is why we
> introduced, in the transfer transaction definition, the rule that
> assigns in this case one single token of the smallest type to the
> "remaining error" output.
>
> Token offering issuance transactions
> ------------------------------------
> A token offering issuance transaction is a transaction having one of the
> following formats (z is an output signaling zero, like a cut; r and s
> are outputs that signal a value greater than zero; the group of outputs
> (t1, t2, z) is optional; t1 or t2 can signal zero, but not both):
>
>   - cut, z, r, (t1, t2, z,) a1, ..., an, c
>       * price of tokens are predefined
>   - cut, s, z, (t1, t2, z,) a1, ..., an, c
>       * price of tokens are not predefined
>
> The tokens will be assigned to one of the outputs of every transaction
> that sends bitcoin to the address of the outputs r or s, as follows:
>   - if the sending transaction has only two outputs (r, c), (c, r), (s,
> c) or (c, s), the "other" output c receives the tokens.
>   - if the sending transaction has more than two outputs, the last
> (biggest) output that is not the one sending bitcoins to r or s, will
> receive the tokens.
>   - if the sending transaction has only one output, the generated tokens
> will be assigned to the output r or s itself. This can be considered as
> a donation: it generates tokens, but the tokens remain in the
> availability of the issuer.
>   - since the number of token emitted is always an integer, the
> remaining satoshis are not considered in the number of tokens issued and
> are sent to the issuer without any token generation.
>
> Note: this is the second place, in this document, where the bitcoin
> address of an output is used. The other place regards the alternate
> names of an issuance. Everything else in the protocol is based on
> outputs, not addresses.
>
> If the group (t1, t2, z) is present, it signals how many token will be
> issued. The total number of tokens that will be issued is the number
> signaled by t1 * 10^6 + the number signaled by t2. In any block, the
> issuance can be closed by the transaction that spends the outputs r or s.
>
> Timeline:
>   - The offer starts in the block that contains the token offering
> issuance transaction. Every transaction of the starting block receives
> tokens, without order.
>   - If there is a defined total number of tokens, the issuance will end
> when the total number of tokens has been reached.
>       * Inside the last block, the transactions are considered in the
> order they are listed. So if a transaction takes the last tokens, every
> other transaction sending bitcoins to r or s, do not receive tokens.
>   - The transaction that spends the outputs r or s ends the issuance.
> This transaction suspends the issuance even if a defined number of
> tokens was defined in the token offering issuance transaction.
>       * In case of an issuance suspeded, or ended, by a transaction
> spending r or s, every transaction of the block containing the spending
> transaction will be considered valid as a receiver of tokens.
>       * Thus, sending bitcoins to the address of the outputs r or s will
> be considered as part of the offering, only if it is included in a block
> between the block of the transaction that has r or s as an output
> (start), and the block of the transaction that spends the output r or s
> (end), inclusive.
>
> A token offering issuance transaction of the first type permits to set a
> rate, and to issue tokens every time bitcoins are received by an
> address. The rate is defined by the number signaled by the output r. One
> token will be issued for every r satoshis received.
>
> A token offering issuance transaction of the second type does not set a
> predefined rate at the start. The rate will be defined by the
> transaction that closes the issuance by spending the output s. The first
> (smallest) output of the closing transaction, or the first output after
> the cut (if a cut is present), will signal the rate. This type of token
> offering issuance, having the price defined at the end, permits to issue
> token based on parameters related to the issuance itself. This is the
> case, for example, of Dutch Auctions.
>
> Note: A token offering issuance transaction can be seen as a transfer
> transaction, that sends all the tokens that receives to the output c.
>
> Note: the type of token issued is defined by the token offering issuance
> transaction, seen as an issuance transaction. Since a token offering
> transaction is also the closure of some issuing chains, this means that
> the same token offer will issue different type of tokens. In fact, a
> different type of token will be issued for every issuance chain that
> ends with the same token offering issuance transaction. Thus a token
> type can be first issued in a controlled way (this is usually called
> pre-ICO) and then the rate can be stated, and the same type of token can
> be offered to the public (this is usually called the ICO). Since the
> token offering issuance transaction closes the issuance forever, there
> is the guarantee that no other tokens of the same type will ever be
> issued after the offer is closed. In order to offer tokens at different
> prices, multiple issuance transactions can be generated with POCs
> originating from the same issuance chain.
>
> Atomic transactions between bitcoins and tokens
> -----------------------------------------------
> Using the cut signal and software that allows full "coin selection",
> it's possible to make atomic exchange transactions. The outputs before
> the cut will determine who will receive the tokens and the following
> outputs will define the rest of the transaction. Both the changes (the
> one of the token wallet and the one of the Bitcoin wallet), should be in
> the second set (after the cut). Since the cut will receive the remaining
> tokens, it is suggested that the cut is sent to the seller of tokens.
> Using this method, the remaining tokens can be sent without involving a
> calculation of the remaining tokens. The outputs of an atomic exchange
> transaction will have the following format (seller is the token seller,
> buyer is the token buyer).
>
>   - a1: tokens sent from the seller to the buyer
>   - a2: tokens sent from the seller to the buyer
>   - cut: part of the bitcoin payment sent from buyer to seller
>   - b1: part of the bitcoin payment sent from buyer to seller (or change
> sent from seller to buyer, if the price to be paid is less than the
> value of the cut)
>   - b2: Bitcoin change sent to the token wallet
>   - b3: Bitcoin change sent to the bitcoin wallet
>
> It is impossible to make an atomic exchange transaction if the wallet in
> use does not allow coin selection.
>
> Cross token atomic transactions
> -------------------------------
> Let's say that Alice wants to sell a number x of tokens of type Ta and
> Bob wants to pay using y tokens of type Tb. Token of type Tb are of
> lesser value than the tokens of type Ta, so Bob will pay more Tb tokens
> and Alice will pay fewer Ta tokens (x < y). Let's say that the
> transaction spends an output from Alice containing BTCa bitcoins and
> *exactly* x tokens, while Bob sends to the same transaction BTCb
> bitcoins and a number z of tokens of type Tb. Since z > y, Bob will
> receive a change c in tokens of type Tb.
>
> Alice managed the previous transactions so that a fixed number x of
> tokens can be sent as the input with a number BTCa of bitcoins. Bob is
> not required do the same, because there is the cut that gives the
> remaining tokens back to Bob. In order to simplify let's say that there
> is another input giving the fee for the transaction and the Bitcoin
> assigned to each output will be calculated accordingly.
>
> The atomic transaction can be made by signaling with the first output
> the number y of tokens that Bob should pay to Alice. This output will go
> to Alice. Since y is higher than x, all the x tokens of type Ta will go
> to the change (directed to Bob), while the y tokens of type Tb will go
> to the first output. A following cut can be used to send the change to
> Bob. The addresses following the cut can be used as changes of bitcoins.
>
> The inputs of the transaction will have a content in Bitcoin and tokens
> as follows:
>
>   - Alice will spend an output having BTCa bitcoins and containing
> *exactly* x tokens of type Ta
>   - Bob will spend an output having BTCb bitcoins and containing y + c
> tokens of type Tb
>
> The outputs of the transaction will have the following form:
>
>   - Bitcoin sent: BTCa1; Signal sent: y; Directed to Alice (the output
> gets y tokens of type Tb, but does not get any token of type Ta, because
> x < y)
>   - Bitcoin sent: BTCb1; Signal sent: cut; Directed to Bob (no token of
> type Ta given, but receives c tokens of type Tb)
>   - Bitcoin sent: BTCa - BTCa1; Signal sent: not important; Directed to
> Alice (no token sent, but useful to send a change in Bitcoin to Alice,
> if needed)
>   - Bitcoin sent: BTCb - BTCb1; Signal sent: not important; Directed to
> Bob (this output gets number x tokens of type Ta)
>
> Cross token atomic transactions in the case of the same number of tokens
> to be exchanged
>
> ----------------------------------------------------------------------------------------
> The atomic transactions described above do not work if the value of
> tokens of type Ta is equal to the value of tokens of type Tb. In this
> case, there is no way of doing an atomic exchange.
>
> Let's say that we need to do a transaction between two tokens that have
> the same value: TetherA and TetherB. Let's say that Alice and Bob want
> to change 199 tokens. The atomic transaction cannot be made, but, with a
> small risk, two transactions can be made. The first will be an atomic
> transaction giving 100 tokens of type TetherA from Alice to Bob and
> receiving 99 of type TetherB back, and the second will be 99 to 100.
>
> How to separate different types of token
> ----------------------------------------
> Let's say that an output contains two different types of tokens of
> interest to the user. Is there a way to separate the tokens so that they
> can be sent to different outputs? If the tokens are exactly the same
> number, there is not. If the tokens are two different numbers: x tokens
> of type A and y tokens of type B, then the separation can be done. Since
> the "remaining error" of an output goes to the change, we can send the
> higher value of the two and have the change receive the lower. We assume
> that x < y.
>
> Let's call A1 the output that will receive A and B1 the output that will
> receive the tokens of type B.
>
> The transaction will be similar to the cross token atomic transaction:
>
>   - Signal sent: x (the output gets x tokens of type B, but does not get
> any token of type A, because x < y)
>   - Signal sent: cut (no token of type A given, but receives a change in
> token of type B if the previous signal was less than y)
>   - Other outputs
>   - Signal sent: not important (this output gets number x tokens of type A)
>
> Guidelines
> ==========
> There are some suggestions that, if followed by the user, permit
> managing tokens in a simple manner, without technical knowledge of the
> rest of the protocol, with plausible deniability. This can be done using
> any existing wallet.
>
> The guidelines described here are based on a wallet that will be
> "consolidated". This means that all the outputs of the wallet are linked
> toghether. In some cases, this behavior diminish the level of privacy of
> the user. Thus, it is advised to use a number of different wallets, in
> order to reach the desired level of privacy.
>
> Plausible deniability: how to use a wallet to manage tokens
> -----------------------------------------------------------
> Some of the protocol's operations are designed to be managed using a
> coin selection software, however, any wallet without coin selection can
> be used to generate, send, or receive tokens. The option to use any
> existing Bitcoin wallet is the base of the plausible deniability of the
> protocol. The user can send, receive and generate tokens by using any
> wallet in a way that seems a normal use of the Bitcoin protocol to
> manage bitcoins.
>
> Thus, the guidelines in this section are based on a use of a wallet by a
> user without involving any "coin selection".
>
> In order to send or generate tokens, the user needs to have, at any
> time, only one output in the wallet. Let's call it a "consolidated"
> wallet. In order to consolidate a wallet:
>
>   - Send all the bitcoins contained in the wallet to a new address of
> the same wallet
>
> If the user departs from these guidelines by mistake, he can "fix" his
> wallet and re-consolidate it without losing the tokens contained in the
> wallet. If the wallet is consolidated, it remains consolidated while
> tokens are generated or sent, and while bitcoins from the wallet are
> spent. If bitcoins or tokens are received by any address of the wallet,
> then the wallet needs to be consolidated again.
>
> Issuance of tokens
> ------------------
> In order to generate tokens:
>
>   - Consolidate the wallet if it is not already consolidated.
>   - Send a minority of the bitcoins contained in the wallet to a new
> address (outside of the wallet). The last five digits of the satoshis
> sent are the number of tokens generated.
>   - From the same wallet, other tokens can be generated by sending again
> a number of satoshis, having the last five digits that are the number of
> tokens to issue to the new address.
>   - The value of bitcoins sent should always be less than the bitcoin
> that remains in the wallet
>   - If during the process of generating tokens the wallet receives
> bitcoins, it should be consolidated again before continuing to generate
> tokens.
>   - The type (or name) of tokens will be the txid of the transaction. If
> the transaction sends bitcoin to a new, never used, address, the address
> can be used as the name of the tokens, as well.
>
> In order to give the power to generate new tokens to another person:
>
>   - Send all the Bitcoin content of the wallet to the other person, with
> a single transaction
>
> In order to close an issuance:
>
>   - To close the issuance and guarantee that no other tokens of this
> type will ever be generated again, send to another address of the same
> wallet a number of bitcoins with the last five digits of the satoshis
> that is zero. Be aware that this shouldn't be all the content of the
> wallet. If all the content of the wallet is sent to some address, the
> issuance will not be closed. Instead, this gives to the receiver the
> power to generate new tokens.
>
> Spending bitcoins and not tokens
> --------------------------------
> In order to spend bitcoins from the wallet without sending any tokens,
> the user should spend less than half of the bitcoin value contained in
> the wallet, and:
>
>   - Spend a number of satoshis where the last five digits are all zeros,
>   or
>   - Spend a number of satoshis where the last five digits are a number
> greater than the tokens that are in the wallet,
>
> Transfer of tokens
> ------------------
> In order to send tokens to another person:
>
>   - Consolidate the wallet if it is not already consolidated.
>   - Send a value less than half of the content of the wallet and having
> the number of satoshis where the last five digits are the number of
> tokens that need to be transferred,
>   or
>   - Send all the bitcoins of the wallet (even if the wallet is not
> consolidated).
>
> If the user sends all the content of the wallet to a single address (no
> change), then he's emptying the token content from the wallet, as well.
> All the tokens will go to the address and nothing will remain to the user.
>
> In order to receive tokens from other users:
>
>   - Give to the other person a Bitcoin address of the wallet and ask to
> send tokens as explained above.
>   - If the wallet was empty before of receiving tokens, then it is
> already consolidated. Instead, if the wallet already had some bitcoins,
> then the wallet needs to be consolidated before sending or generating
> tokens.
>
> Effects of the use of these guidelines
> --------------------------------------
> When using the guidelines, the number of tokens sent to the recipient is
> always stated in the last five digits of the satoshis sent. There are
> three exceptions:
>
>   - In a single output transaction, all the tokens of the wallet will be
> sent to the recipient.
>   - In a transaction where the amount of satoshis sent ends with five
> zeros, no tokens are sent.
>   - In a transaction sending more tokens than the number of tokens of
> that type held in the wallet, no tokens are sent.
>
> Technical notes
> ---------------
>   - Sending a number of bitcoins that is greater than half of the
> bitcoins contained in the wallet brings to unpredicted results.
>   - Thus, if there are not enough bitcoins to continue to operate, the
> wallet needs to be "re-charged" by sending some bitcoins to it. By doing
> so, there will be more than one UTXO in the wallet. This departs from
> "consolidated mode" and the wallet needs to be consolidated again.
>   - A consolidated wallet contains only one UTXO.
>   - Every transaction made from a consolidated wallet contains only two
> outputs: one is the address outside of the wallet, and the other is the
> change.
>   - Every transaction spends all the content of the wallet.
>
> Reference Implementation
> ========================
> A reference implementation will be included when the protocol will be
> reviewed and accepted by the community.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-- 
Alex Kravets
@alexkravets <https://twitter.com/alexkravets>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170908/883d0e5e/attachment-0001.html>

From chris at suredbits.com  Fri Sep  8 20:14:30 2017
From: chris at suredbits.com (Chris Stewart)
Date: Fri, 8 Sep 2017 15:14:30 -0500
Subject: [bitcoin-dev] Sidechain headers on mainchain (unification of
 drivechains and spv proofs)
In-Reply-To: <Imrd8VOoGb1nVRp10RedyHoeJYajcvlhrwZQg9OtTk3vDMpc7DEFgw7CSQR_AiqNDwmMECV_fn53WY2i9NZcJKx2jtyd_psyQf6VNg3S7Gc=@protonmail.com>
References: <H7RPmZGfkVC8opGMMCW7Orav6yD05-AVB9bNtNU8C0hKYokiXL32VSmn0wkjn77qh4MvacPOePdVQ5gQZuAMF6q2oEuvKDSu6crNcEoXx_0=@protonmail.com>
	<CAGL6+mFHe_SfMea1oMZ3n-G3ey9yToAvTMTcfdxJ5qDD1dTXyQ@mail.gmail.com>
	<Cc5DW6tb6_Xhe3DaXisRJzqYtnWHCGcHkOsXDJLIRvv9WP2lCVocsM1atkdQOSE8-reUbCp_ZKfEDIaA0Qh5CRwFeIrHFJcNkFsqmZx70XQ=@protonmail.com>
	<Imrd8VOoGb1nVRp10RedyHoeJYajcvlhrwZQg9OtTk3vDMpc7DEFgw7CSQR_AiqNDwmMECV_fn53WY2i9NZcJKx2jtyd_psyQf6VNg3S7Gc=@protonmail.com>
Message-ID: <CAGL6+mFqrnTXOwse3Zuu-GuRYxgQQV9Bs9OUU+RmyUqOsm0UTQ@mail.gmail.com>

Hi ZmnSCPxj,

However, a lockbox on one chain is a WT on the other
> chain.  We can create a free lockbox on Ess, then use that lockbox as
> a WT on Tee, inflating TeeCoin.


I'm not sure if I follow what you are saying here. What do you mean by
'free lockbox'? I was assuming that I created an arbitrary blockchain, say
ChrisChain, that is NOT pegged to the bitcoin blockchain? I.e. the tokens
on ChrisChain are worthless. Then I create a lockbox on ChrisChain with my
worthless tokens and attempt to transfer them into TeeCoin's chain? However
this doesn't make sense with


However, this parameter is used to determine if it is a WT.  Sidechain
> consensus should require that freely-created lockboxes set this
> parameter to 0, so that a side block that creates free lockboxes where
> this parameter is non-zero is an invalid side block.  Then a sidechain
> will only treat a lockbox on another chain as a WT if the wtFlag
> parameter is nonzero.  This way, freely-created lockboxes are not
> valid WT.  Valid WT must lock actual, already unlocked coins, not
> create new locked coins.
>

because I could arbitrarily set this parameter to 0. It seems that a
sidechain upon inception should pay all of it's tokens to a single UTXO and
prevent minting of coins after that. I'm fairly certain this is what
elements does in it's genesis block.

The is unrelated to the problem above, but it will be a problem in
sidchain-headers-on-mainchain if we have a limited amount of mining slots
in the coinbase_tx output vector.

Let us assume we have a fixed set of sidechain slots in the coinbase output
vector, in this case 10. However there are 15 competing sidechains for
these 10 slots. It may be possible for sidechains (say 15 sidechains) to
compete indefinitely for these 10 slots -- causing indefinite forks. Let us
say sidechain 10 and sidechain 11 alternate block hashes in
coinbase_tx.vout[10] output. This means that a WT^ will never be considered
valid because it will appear to mainchain miners that there are competing
forks of the SAME sidechain, when in reality it is two unique sidechains
competing to mine the the limited coinbase output vector space.

-Chris

On Fri, Sep 8, 2017 at 9:56 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning,
>
> Chris mentioned the use of OP_WITHDRAWPROOFVERIFY.  I've come to realize
> that this is actually superior to use OP_WITHDRAWPROOFVERIFY with a
> sidechain-headers-on-mainchain approach.
>
> Briefly, a payment to OP_WITHDRAWPROOFVERIFY is an instruction to transfer
> value from the mainchain to a sidechain.  Thus, a payment to
> OP_WITHDRAWPROOFVERIFY includes the sidechain to pay to, and a commitment
> to a sidechain address (or whatever is the equivalent to a sidechain
> address).
>
> Various OP_WITHDRAWPROOFVERIFY explanations exist.  Most of them include
> OP_REORGPROOFVERIFY.  With sidechain-headers-on-mainchain, however, there
> is
> no need for reorg proofs.  This is because, the mainchain can see, in real
> time, which branch of the sidechain is getting extended.  Thus if someone
> attempts to defraud a sidechain by forking the sidechain to an invalid
> state, sidechainers can immediately detect this on the mainchain and
> immediately act to prevent the invalid fork from being advanced.  After
> all, a reorg proof is really just an SPV proof that is longer than some
> previous SPV proof, that shows that the previous SPV proof is incorrect,
> by showing that the block at the specified height of the WT is not present
> on a longer SPV proof.
>
> Since sidechain-headers-on-mainchain implies merge mining of sidechains,
> with no option to have independent proof-of-work of sidechains, the
> sidechain's entire history is recorded on the mainchain, visible to all
> mainchain nodes.
>
> --
>
> An advantage of sidechain-headers-on-mainchain is a side-to-side peg
> without
> passing through the mainchain.
> That is, a 2-way peg between any two chains, whether side or main.
>
> Sidechains supporting side-to-side transfer would require supporting
> OP_WITHDRAWPROOFVERIFY, but not any of the other parts of sidechains.
>
> We must consider a WT format (withdrawal transaction) that is compatible
> with an OP_WITHDRAWPROOFVERIFY Bitcoin transaction.
>
> ***That is, a lockbox UTXO on one chain is a WT on another chain.***
>
> Sidechains need not follow the mainchain format for its normal
> transactions, only for WT transactions that move coins across chains.
>
> For this, mainchain should also have its own "sidechain ID".  Perhaps a
> sidechain ID of 0 would be appropriate for mainchain, as its status as
> mainchain.
>
> Suppose we have two sidechains, Ess and Tee, both of which support
> side-to-side pegs.
>
> An Ess fullnode is a Bitcoin fullnode, but an Ess fullnode is not
> necessarily a Tee fullnode, and vice versa.
>
> A lockbox redemption in sidechain-headers-on-mainchain is simply a spend of
> a lockbox, pointing to the sidechain header containing WT, the merkle tree
> path to the WT transaction from the h* commitment of the header, the output
> which locks, and so on as per usual OP_WITHDRAWPROOFVERIFY.
>
> Then a sidechain can create tokens from nothing, that are locked in a
> OP_WITHDRAWPROOFVERIFY lockbox; this is the only way to create sidecoin.
> When transferring into a sidechain from mainchain, or anywhere, the
> sidechain either creates tokens locked into OP_WITHDRAWPROOFVERIFY, or
> looks for an existing UTXO with OP_WITHDRAWPROOFVERIFY from the source
> chain and spends them (the latter is preferred as it is fewer
> transactions and less space on the sideblock, reducing sidechain fees).
>
> OP_WITHDRAWPROOFVERIFY on a sidechain would query the mainchain fullnodes.
> Whatever rules allow lockbox unlocking on mainchain, will also be the same
> rules that allow lockbox unlocking on sidechains.
> A mainchain RPC can even be made to simplify sidechain verification of
> side-to-side pegs, and to ensure that sidechains follow the same consensus
> rules for OP_WITHDRAWPROOFVERIFY.
>
> So if we want transfer TeeCoin to EssCoin, we spend into a
> OP_WITHDRAWPROOFVERIFY lockbox on Teechain pointing to Esschain (i.e. a
> Tee->Ess lockbox).  This lockbox is itself a WT from the point of view of
> Esschain.  On Esschain, we look for an existing Ess->Tee lockbox, or
> create a Ess->Tee lockbox of our own for a EssCoin fee.  Then we create a
> spend of the Ess->Tee lockbox on Esschain, wait until spending is
> possible, and then post that transaction on Esschain.
>
> Again, with sidechain-headers-on-mainchain, reorg proofs are unnecessary,
> since any invalid chain should be quickly buried by a valid chain,
> unless the economic majority decides that a sidechain is not worth
> protecting.
>
> --
>
> All is not well, however.  Remember, on a sidechain, we can create new
> sidecoin for free, provided they are in a lockbox.  Unlocking that
> lockbox would require a valid WT on the chain that the lockbox is
> dedicated to.  However, a lockbox on one chain is a WT on the other
> chain.  We can create a free lockbox on Ess, then use that lockbox as
> a WT on Tee, inflating TeeCoin.
>
> Instead, we add an additional parameter, wtFlag, to
> OP_WITHDRAWPROOFVERIFY.
> This parameter is ignored by OP_WITHDRAWPROOFVERIFY opcode.
>
> However, this parameter is used to determine if it is a WT.  Sidechain
> consensus should require that freely-created lockboxes set this
> parameter to 0, so that a side block that creates free lockboxes where
> this parameter is non-zero is an invalid side block.  Then a sidechain
> will only treat a lockbox on another chain as a WT if the wtFlag
> parameter is nonzero.  This way, freely-created lockboxes are not
> valid WT.  Valid WT must lock actual, already unlocked coins, not
> create new locked coins.
>
> On Bitcoin, of course, this parameter must always be nonzero, since
> freely-created lockboxes are not allowed on mainchain, as asset
> issuance on mainchain is already fixed.
>
> --
>
> Let us now flesh out how WT and lockboxes look like.  As we mentioned, a
> lockbox on one chain is a WT on the destination chain.  Or to be more
> precise, what a destination chain sees as a WT, is a lockbox on the source
> chain.
>
> Thus, a lockbox is a Bitcoin-formatted transaction output paying to the
> scriptPubKey:
>
>   <sidechain address commitment> <sidechain ID> OP_WITHDRAWPROOFVERIFY
>
> (assuming a softfork, additional OP_DROP operations may occur after
> OP_WITHDRAWPROOFVERIFY)
>
> Suppose the above lockbox is paid to in the Bitcoin mainchain, with the
> sidechain ID being the ID of Esschain.  This is itself a WT transaction
> from the point of view of Esschain, on the principle that a lockbox on
> one chain is a WT on another chain.
>
> Assuming Esschain is a brand-new sidechain, it has no EssCoins yet.  The
> sidechain allows the arbitrary creation of sidecoin provided the new
> sidecoins are in a lockbox whose sidechain address commitment is 0.  So
> in Esschain, we create the same coins on a UTXO paying to the
> scriptPubKey:
>
>   0 0 OP_WITHDRAWPROOFVERIFY
>
> The first 0 is the sidechain address commitment, which is 0 since this
> output was not created by transferring to a sidechain; we
> reuse the sidechain address commitment as the wtFlag.  The
> second 0 is the mainchain's ID.  The above is a lockbox from the point of
> view of Esschain.  It is not a WT on mainchain, however, because the
> sidechain address commitment is 0, which we use also as the wtFlag
> parameter.
>
> Now, how does a main-to-side peg work?  After creating the above output on
> Esschain, we now spend the output with the below scriptSig:
>
>   <mainchain output ID> <mainchain WT transaction> <merkle path to WT
> transaction> <mainchain block hash>
>
> On Esschain, OP_WITHDRAWPROOFVERIFY then verifies that the mainchain block
> hash is a valid past block of the mainchain, then locates the mainchain
> header.  It then checks the merkle tree path to the mainchain WT
> transaction,
> confirming that the mainchain contains that transaction, and confirms that
> the
> indicated output is in fact, a payment to an OP_WITHDRAWPROOFVERIFY, which
> pushes the Esschain ID, and with a nonzero sidechain address commitment.
>
> (Esschain also needs to ensure that a single WT is not used to unlock
> multiple lockboxes on Esschain; the easiest way is to add it to a set,
> but this set cannot be pruned; other ways of ensuring only a WT is only
> used to unlock once might be designed)
>
> On Esschain, the sidechain does one final check: the transaction that
> spends
> an OP_WITHDRAWPROOFVERIFY must have an output that pays to the sidechain
> address committed to, and that output's value must be the same as the value
> locked in the mainchain.
>
> (for now, I think all lockboxes must have the same fixed amount, for
> simplicity)
>
> Now suppose we want to convert back our EssCoin to Bitcoin.  We create a
> lockbox on Esschain, paying to the below:
>
>   <bitcoin P2SH address> 0 OP_WITHDRAWPROOFVERIFY
>
> The bitcoin P2SH address is mainchain address commitment; for simplicity
> we just use P2SH on mainchain as it can encode any address.  The 0 is the
> mainchain ID.  The above Esschain lockbox is itself a WT from Esschain to
> mainchain.
>
> Then, we look for an unspent lockbox on Esschain whose sidechain ID is the
> Esschain ID.  Note that we can select any lockbox with the correct
> sidechain ID, regardless of the sidechain address commitment it may have.
>
> Locating an appropriate mainchain lockbox for Esschain coins, we then
> provide the below scriptSig, paying out to the bitcoin P2SH address we
> selected:
>
>   <esschain output ID> <esschain WT tx> <merkle path to WT tx> <esschain
> block header hash>
>
> On mainchain, we check that the indicated sidechain block header hash is a
> block header on the longest chain of Esschain.  We check it has sufficient
> depth.  Then we check if the merkle path to the WT tx is correct and goes
> to esschain WT tx.  Finally, we check the indicated output ID, and check
> that
> it is indeed an Esschain lockbox dedicated to mainchain.  Finally, we check
> that the transaction has an output that spends the lockbox amount to the
> specified bitcoin P2SH address.
>
> (similarly mainchain nees to ensure that the Esschain WT is only used
> once)
>
> The key insight here is that side-to-side pegs are just like side-to-main
> pegs.  Suppose instead we want to transfer our coins from Esscoin to
> Teecoin.  We would instead pay to the following lockbox on Esschain:
>
>   <teecoin address commitment> <teechain ID> OP_WITHDRAWPROOFVERIFY
>
> Then a Teechain transaction spending some Tee->Ess lockbox (or a fresh
> lockbox if there are no Tee->Ess lockboxes on Teechain) is created.
> We proceed as if it were a side-to-main peg, except it is a peg to
> Teechain, either creating or unlocking TeeCoins.  Indeed, mainchain
> fullnodes may even provide an RPC for checking OP_WITHDRAWPROOFVERIFY,
> so as to reduce risk that a sidechain breaks consensus due to buggy
> code.
>
> --
>
> All is still not well with side-to-side pegs, however.
>
> Suppose the economic majority decides that Esschain must die.  Perhaps it
> has some irrecoverable security bug, perhaps it adds features that allow
> Esschain fullnodes to kill baby seals, perhaps a successful theft of
> Esschain lockboxes was performed and Esscoins are now functionally
> worthless.  Killing a sidechain is done by bribing miners to put invalid
> values into h*, and thus stealing Bitcoin->Ess lockboxes.
>
> If Esschain dies, however, and the economic majority is not prepared to
> keep
> Esschain dead, it is possible to unlock Tee->Ess lockboxes on Teechain.
> Unlocking existing Tee->Ess lockboxes on Teechain is safe, since they
> represent coins that were locked into Bitcoin->Tee lockboxes.  However,
> it is still possible to create "free" Tee->Ess lockboxes on Teechain, then
> provide an invalid Tee->Ess WT lockbox on the now-moribund Esschain to
> unlock the free Tee->Ess lockbox on Teechain, inflating TeeCoin value.
> Thus in the presence of side-to-side pegs, the death of even one sidechain
> represents the death of every other sidechain!
>
> Thus, to properly kill Esschain, the economic majority should spam the
> Esschain headers slot with a fixed value, say 0, forever.  This makes it
> very difficult to create a Tee->Ess WT lockbox on Esschain, as you would
> now be able to reverse a one-way hash function.
>
> Alternatively, Teechain can softfork so that Tee->Ess lockboxes are no
> longer creatable or spendable.  However, the death of Esschain requires
> that all other sidechains, including Youchain, Veechain, Dubyachain, and
> so on, to softfork similarly.
>
> Perhaps both can be done: first the economic majority wanting to kill
> Esschain starts spamming it with invalid spends of Bitcoin->Ess lockboxes,
> then when all Bitcoin->Ess lockboxes have been stolen, spam it with 0s
> until all other sidechains have banned free Ess lockboxes on their chains.
> Then, the economic majority can leave Esschain dead, and a later softfork
> of mainchain prevents Esschain from being extended and allows mainchain
> fullnodes to prune Esschain headers.
>
> --
>
> Thieves will still have the same difficulty stealing from sidechains, but
> now their payoff is increased.  If a thief wants to steal Esschain
> lockboxes, then it is possible to pack an invalid Esschain block full of
> invalid WT to other chains.  Even chains that don't have lockboxes to
> Esschain can create lockboxes to Esschain for free.  Thus, instead of
> stealing only one lockbox at a time on mainchain, the thief can steal one
> lockbox on mainchain, and on every sidechain that supports side-to-side
> pegs, at a time.  The risk/reward ratio may shift drastically in that case.
>
> However, this does mean that users of one chain must pay attention to
> attacks on other chains, not just the chain they use.  If Teechain has no
> side-to-side pegs, then Teechain users will not care if Esschain is under
> attack.  But if side-to-side pegs are allowed on Teechain, then Teechain
> users must also care about Esschain's health, as well as the health of
> every other sidechain in existence.  Mainchain is protected since free
> lockboxes are not creatable on mainchain.  Each sidechain is not; thus
> the user of any sidechain must also stand by users of every other
> sidechain, or else they all fall apart.  Of course, this could more
> simply lead to "I will not use Teechain even if it would be useful to me,
> because if I use Teechain, I have to care about Esschain and Youchain and
> whatever."
>
> --
>
> Side-to-side pegs are useful to allow better liquidity and provide
> arbitrage quickly between sidechains, without having to pass through
> mainchain.  Otherwise, Esscoin may be valued slightly lower than Bitcoin,
> then Teecoin valued slightly higher than Bitcoin, creating a larger
> difference between Esscoin and Teecoin values than what a full
> side-to-side peg could support.  2-way pegs from mainchain
> to sidechain stabilize sidecoin with respect to maincoin.  Side-to-side
> pegs stabilize all sidecoins to all other sidecoins.
>
> Side-to-side pegs are enabled implicitly by sidechain-headers-on-
> mainchain,
> as all sidechain fullnodes must necessarily be mainchain fullnodes, and
> any mainchain fullnode can judge the validity of any WT from any sidechain
> without a miner voting period.
>
> Side-to-side pegs are a generalization of main-to-side and side-to-main
> pegs.  A sidechain can simply implement OP_WITHDRAWPROOFVERIFY and allow
> free lockboxes, and that is sufficient for the sidechain to support
> imports of bitcoin from mainchain and from any other sidechain.
>
> Side-to-side pegs seem to imply that all pegs must have the same bitcoin
> value transferred.  What that value must be, is something that may be
> debated endlessly.
>
> A side-to-side peg is a cut-through of a side-to-main peg from
> one sidechain into a main-to-side peg into another sidechain.  If a
> withdrawal from side-to-main peg would be accepted by mainchain, then
> another sidechain could, in principle, accept a proof that would
> authorize a side-to-main peg directly as a side-to-side peg.
>
> Side-to-side pegs make attacks on sidechains more lucrative, as it
> becomes possible to print sidecoins by successfully attacking a
> different sidechain.
>
> Drivechain cannot implement side-to-side pegs, as WT validity is
> voted on by mainchain miners, and asking mainchain miners about
> side-to-side pegs requires mainchain miners to be aware of both
> sidechains.  Sidechain-headers-on-mainchain publishes SPV proofs
> continuously to the mainchain, and since any sidechain fullnode is
> also a mainchain fullnode (since sidechains are mergemined), then
> every sidechain fullnode is automatically capable of accessing
> and verifying SPV proofs for every other sidechain.
>
> However, the pegging here seems less flexible than the pegging
> supported by drivechain.  Drivechain lets pegs be any size, with
> miner voting being the basis of knowing how much money is owned
> by whom.
>
> Regards,
> ZmnSCPxj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170908/c9a39c04/attachment-0001.html>

From shiva at blockonomics.co  Sat Sep  9 14:08:21 2017
From: shiva at blockonomics.co (shiva sitamraju)
Date: Sat, 9 Sep 2017 19:38:21 +0530
Subject: [bitcoin-dev] Proposal: Extended serialization format for BIP-32
Message-ID: <CABuOfuhN6jXgd+KTjFLjM+YkDOVg9=G3tWpeKBJvpUAkpkzjDg@mail.gmail.com>

Hi,

I understand the motivation of adding the birthdate field. However, not
very comfortable with having this in the public key serialization. There
are privacy implication of both the birthday field and having the complete
derivation path, which takes space.

I am fine with Thomas proposal of {x,y,z}. Having additional version byte
field looks modular but since since we already have the big enough version
field in bip32, better to use that instead of adding more bytes.

Thomas, can you please explain why we require different version for P2WPKH
or P2WSH versus (P2WPKH or P2WSH) nested in P2SH. It looked to me that they
would have the same output bitcoin address and under same account.

On Fri, Sep 8, 2017 at 2:09 AM, <
bitcoin-dev-request at lists.linuxfoundation.org> wrote:

> Send bitcoin-dev mailing list submissions to
>         bitcoin-dev at lists.linuxfoundation.org
>
> To subscribe or unsubscribe via the World Wide Web, visit
>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> or, via email, send a message with subject or body 'help' to
>         bitcoin-dev-request at lists.linuxfoundation.org
>
> You can reach the person managing the list at
>         bitcoin-dev-owner at lists.linuxfoundation.org
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of bitcoin-dev digest..."
>
>
> Today's Topics:
>
>    1. Re: Proposal: Extended serialization format for   BIP-32
>       wallets (Andreas Schildbach)
>    2. Re: Proposal: Extended serialization format for BIP-32
>       wallets (Pavol Rusnak)
>    3. Re: Fast Merkle Trees (Mark Friedenbach)
>    4. Re: Proposal: Extended serialization format for BIP-32
>       wallets (Thomas Voegtlin)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Thu, 7 Sep 2017 21:35:49 +0200
> From: Andreas Schildbach <andreas at schildbach.de>
> To: bitcoin-dev at lists.linuxfoundation.org
> Subject: Re: [bitcoin-dev] Proposal: Extended serialization format for
>         BIP-32 wallets
> Message-ID: <oos72e$rjp$1 at blaine.gmane.org>
> Content-Type: text/plain; charset=utf-8
>
> On 09/07/2017 06:23 PM, Pavol Rusnak via bitcoin-dev wrote:
> > On 07/09/17 06:29, Thomas Voegtlin via bitcoin-dev wrote:
> >> A solution is still needed to wallets who do not wish to use BIP43
> >
> > What if we added another byte field OutputType for wallets that do not
> > follow BIP43?
> >
> > 0x00 - P2PKH output type
> > 0x01 - P2WPKH-in-P2SH output type
> > 0x02 - native Segwit output type
> >
> > Would that work for you?
>
> I think that would work.
>
> > The question is whether this field should be present only if depth==0x00
> > or at all times. What is your suggestion, Thomas?
>
> In case of Bitcoin Wallet, the depth is not null (m/0'/[0,1]) and still
> we need this field. I think it should always be present if a chain is
> limited to a certain script type.
>
> There is however the case where even on one chain, script types are
> mixed. In this case the field should be omitted and the wallet needs to
> scan for all (known) types. Afaik Bitcoin Core is taking this path.
>
>
>
> ------------------------------
>
> Message: 2
> Date: Thu, 7 Sep 2017 22:00:05 +0200
> From: Pavol Rusnak <stick at satoshilabs.com>
> To: Andreas Schildbach <andreas at schildbach.de>, Bitcoin Protocol
>         Discussion <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] Proposal: Extended serialization format for
>         BIP-32 wallets
> Message-ID: <40ed03a1-915c-33b0-c4ac-e898c8c733ba at satoshilabs.com>
> Content-Type: text/plain; charset=windows-1252
>
> On 07/09/17 21:35, Andreas Schildbach via bitcoin-dev wrote:
> > In case of Bitcoin Wallet, the depth is not null (m/0'/[0,1]) and still
> > we need this field.
>
> But the depth of exported public key will be null. It does not make
> sense to export xpub for m or m/0' for your particular case.
>
> > I think it should always be present if a chain is
> > limited to a certain script type.
>
> I am fine with having the path there all the time.
>
> > There is however the case where even on one chain, script types are
> > mixed. In this case the field should be omitted and the wallet needs to
> > scan for all (known) types. Afaik Bitcoin Core is taking this path.
>
> Is that really the case? Why come up with a hierarchy and then don't use
> it?
>
> --
> Best Regards / S pozdravom,
>
> Pavol "stick" Rusnak
> CTO, SatoshiLabs
>
>
> ------------------------------
>
> Message: 3
> Date: Thu, 7 Sep 2017 13:04:30 -0700
> From: Mark Friedenbach <mark at friedenbach.org>
> To: Russell O'Connor <roconnor at blockstream.io>
> Cc: Bitcoin Protocol Discussion
>         <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] Fast Merkle Trees
> Message-ID: <40D6F502-3380-4B64-BCD9-80D361EED35C at friedenbach.org>
> Content-Type: text/plain; charset="us-ascii"
>
> TL;DR I'll be updating the fast Merkle-tree spec to use a different
>       IV, using (for infrastructure compatability reasons) the scheme
>       provided by Peter Todd.
>
> This is a specific instance of a general problem where you cannot
> trust scripts given to you by another party. Notice that we run into
> the same sort of problem when doing key aggregation, in which you must
> require the other party to prove knowledge of the discrete log before
> using their public key, or else key cancellation can occur.
>
> With script it is a little bit more complicated as you might want
> zero-knowledge proofs of hash pre-images for HTLCs as well as proofs
> of DL knowledge (signatures), but the basic idea is the same. Multi-
> party wallet level protocols for jointly constructing scriptPubKeys
> should require a 'delinearization' step that proves knowledge of
> information necessary to complete each part of the script, as part of
> proving the safety of a construct.
>
> I think my hangup before in understanding the attack you describe was
> in actualizing it into a practical attack that actually escalates the
> attacker's capabilities. If the attacker can get you to agree to a
> MAST policy that is nothing more than a CHECKSIG over a key they
> presumably control, then they don't need to do any complicated
> grinding. The attacker in that scenario would just actually specify a
> key they control and take the funds that way.
>
> Where this presumably leads to an actual exploit is when you specify a
> script that a curious counter-party actually takes the time to
> investigate and believes to be secure. For example, a script that
> requires a signature or pre-image revelation from that counter-party.
> That would require grinding not a few bytes, but at minimum 20-33
> bytes for either a HASH160 image or the counter-party's key.
>
> If I understand the revised attack description correctly, then there
> is a small window in which the attacker can create a script less than
> 55 bytes in length, where nearly all of the first 32 bytes are
> selected by the attacker, yet nevertheless the script seems safe to
> the counter-party. The smallest such script I was able to construct
> was the following:
>
>     <fake-pubkey> CHECKSIGVERIFY HASH160 <preimage> EQUAL
>
> This is 56 bytes and requires only 7 bits of grinding in the fake
> pubkey. But 56 bytes is too large. Switching to secp256k1 serialized
> 32-byte pubkeys (in a script version upgrade, for example) would
> reduce this to the necessary 55 bytes with 0 bits of grinding. A
> smaller variant is possible:
>
>     DUP HASH160 <fake-pubkey-hash> EQUALVERIFY CHECKSIGVERIFY HASH160
> <preimage> EQUAL
>
> This is 46 bytes, but requires grinding 96 bits, which is a bit less
> plausible.
>
> Belts and suspenders are not so terrible together, however, and I
> think there is enough of a justification here to look into modifying
> the scheme to use a different IV for hash tree updates. This would
> prevent even the above implausible attacks.
>
>
> > On Sep 7, 2017, at 11:55 AM, Russell O'Connor <roconnor at blockstream.io>
> wrote:
> >
> >
> >
> > On Thu, Sep 7, 2017 at 1:42 PM, Mark Friedenbach <mark at friedenbach.org
> <mailto:mark at friedenbach.org>> wrote:
> > I've been puzzling over your email since receiving it. I'm not sure it
> > is possible to perform the attack you describe with the tree structure
> > specified in the BIP. If I may rephrase your attack, I believe you are
> > seeking a solution to the following:
> >
> > Want: An innocuous script and a malign script for which
> >
> >    double-SHA256(innocuous)
> >
> > is equal to either
> >
> >    fast-SHA256(double-SHA256(malign) || r) or
> >    fast-SHA256(r || double-SHA256(malign))
> >
> > or  fast-SHA256(fast-SHA256(double-SHA256(malign) || r1) || r0)
> > or  fast-SHA256(fast-SHA256(r1 || double-SHA256(malign)) || r0)
> > or ...
> >
> > where r is a freely chosen 32-byte nonce. This would allow the
> > attacker to reveal the innocuous script before funds are sent to the
> > MAST, then use the malign script to spend.
> >
> > Because of the double-SHA256 construction I do not see how this can be
> > accomplished without a full break of SHA256.
> >
> > The particular scenario I'm imagining is a collision between
> >
> >     double-SHA256(innocuous)
> >
> > and
> >
> >     fast-SHA256(fast-SHA256(fast-SHA256(double-SHA256(malign) || r2) ||
> r1) || r0).
> >
> > where innocuous is a Bitcoin Script that is between 32 and 55 bytes long.
> >
> > Observe that when data is less than 55 bytes then double-SHA256(data) =
> fast-SHA256(fast-SHA256(padding-SHA256(data)) || 0x8000...100) (which is
> really the crux of the matter).
> >
> > Therefore, to get our collision it suffices to find a collision between
> >
> >     padding-SHA256(innocuous)
> >
> > and
> >
> >     fast-SHA256(double-SHA256(malign) || r2) || r1
> >
> > r1 can freely be set to the second half of padding-SHA256(innocuous), so
> it suffices to find a collision between
> >
> >    fast-SHA256(double-SHA256(malign) || r2)
> >
> > and the first half of padding-SHA256(innocuous) which is equal to the
> first 32 bytes of innocuous.
> >
> > Imagine the first opcode of innocuous is the push of a value that the
> attacker claims to be his 33-byte public key.
> > So long as the attacker doesn't need to prove that they know the
> discrete log of this pubkey, they can grind r2 until the result of
> fast-SHA256(double-SHA256(malign) || r2) contains the correct first
> couple of bytes for the script header and the opcode for a 33-byte push.  I
> believe that is only about 3 or 4 bytes of they need to grind out.
> >
>
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> attachments/20170907/63af0292/attachment-0001.html>
>
> ------------------------------
>
> Message: 4
> Date: Thu, 7 Sep 2017 22:39:17 +0200
> From: Thomas Voegtlin <thomasv at electrum.org>
> To: "bitcoin-dev at lists.linuxfoundation.org"
>         <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] Proposal: Extended serialization format for
>         BIP-32 wallets
> Message-ID: <9e74dc17-105c-b43c-7780-4fa690043fe2 at electrum.org>
> Content-Type: text/plain; charset=windows-1252
>
>
>
> On 07.09.2017 18:23, Pavol Rusnak wrote:
> > On 07/09/17 06:29, Thomas Voegtlin via bitcoin-dev wrote:
> >> A solution is still needed to wallets who do not wish to use BIP43
> >
> > What if we added another byte field OutputType for wallets that do not
> > follow BIP43?
> >
> > 0x00 - P2PKH output type
> > 0x01 - P2WPKH-in-P2SH output type
> > 0x02 - native Segwit output type
> >
> > Would that work for you?
> >
> > The question is whether this field should be present only if depth==0x00
> > or at all times. What is your suggestion, Thomas?
> >
>
>
> well, in my initial proposal, I wrote that this value should be user
> visible. That is why I used version bytes. If you create an extra byte
> field, and then use base58 or bech32 encoding, the value will not be
> user visible anymore.
>
> The initial implementation of segwit xpub/xprv in Electrum used a flag
> that was not user visible (I added 1 to the bip32 version bytes, which
> leaves the xpub/xprv prefix unchanged). I have experimented with that
> invisible flag for more than 6 months now, and I am now convinced that
> it is better to make that flag user visible.
>
> The reason is that when users create wallets with multisig scripts, they
> need to combine several master public keys. However, these master public
> keys should all be of the same type: it would not make sense to create a
> 2 of 3 multisig wallet with a one xpub, one ypub and one zpub. By
> imposing that all master keys are of the same type, we ensure that all
> cosigners agree on the script type that will be used to derive addresses.
>
> In other words, if users are exposed to master keys and need to
> manipulate them, it is better to let them see what they are doing.
>
> OTOH if you do not plan to expose your users to these keys, you probably
> do not need a serialization format.
>
>
> ------------------------------
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> End of bitcoin-dev Digest, Vol 28, Issue 17
> *******************************************
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170909/93b760d3/attachment-0001.html>

From truthcoin at gmail.com  Sat Sep  9 15:33:28 2017
From: truthcoin at gmail.com (Paul Sztorc)
Date: Sat, 9 Sep 2017 11:33:28 -0400
Subject: [bitcoin-dev] Fwd: Sidechain headers on mainchain (unification
 of drivechains and spv proofs)
In-Reply-To: <E-mvls0CjntrzO4fWx84mYQtc0agV4KdP5QvX3ie3fLXC_YaB58OFvRYTRZhwo7vOn5OPQnlITFwOwyFgDAAZpQ2rvtCgsi-FCy95dBEP0s=@protonmail.com>
References: <H7RPmZGfkVC8opGMMCW7Orav6yD05-AVB9bNtNU8C0hKYokiXL32VSmn0wkjn77qh4MvacPOePdVQ5gQZuAMF6q2oEuvKDSu6crNcEoXx_0=@protonmail.com>
	<CAGL6+mG-jD6L5b0LepyotDd2+POjkrgV98c2fLFGM0ZokD4afA@mail.gmail.com>
	<wkUkYK_kYwSQx7JKzvgrfUiZYPLPrORMT_zBL5Tg-Spnr8tOyC_o4nZT4yFOD-FE86FvshRhWTfPblYqVmaZHi-VnMbKwpDDkAOjI8b9ap8=@protonmail.com>
	<CAGL6+mGy7nTK1yA8YZcG59r9GZmVb+XWgQ1HjuPD4_pD7ZWThw@mail.gmail.com>
	<6S1lfiXnljmQiZLorMOenBXGeve0K_LHKiCIZ75Gfc8LZieB7sq_bV_UWV-kJ197FYWywzDaQE7kOEqguYxlDFWZnLdzONhFZ7OAaWFgn64=@protonmail.com>
	<CAGL6+mHqKXbm5nAHq+ghaTihCQQe0Rs1sd82ff2NiFKSq6Be+A@mail.gmail.com>
	<yDICafWAbOJEbNvT9o8fltfCuJry5ZOLGwjQ-Ji6xfLjTP3XI_DXb8UbFJ6tA8jclqIEudFABAVEbXuLN9HLnN2nv-WTDE7q9vyjcALtufc=@protonmail.com>
	<CAGL6+mGrN1m_zWs0KM4sfPHCdYUjuJ+E6hjVCFOtz2RoBDZyoQ@mail.gmail.com>
	<E-mvls0CjntrzO4fWx84mYQtc0agV4KdP5QvX3ie3fLXC_YaB58OFvRYTRZhwo7vOn5OPQnlITFwOwyFgDAAZpQ2rvtCgsi-FCy95dBEP0s=@protonmail.com>
Message-ID: <1e3f1e8d-c5c9-9ee5-7069-6db47bec5879@gmail.com>


Hi everyone,

I have some agreements and disagreements.

I agree with Zmn:

1. That the sidechain's header is fully defined by the bits of data
included in mainchain headers. These bits include "h*" (some hash that
is either of the header itself or side:hashMerkleRoot), something that
forces these hashes into a DAG-like structure (in Zmn's case, it is a
full hashPrevBlock, whereas for us it is just a tiny integer).
2. That "miner-voting" (for lack of better phrase) accomplishes the same
task as any SPV Proof of any kind.
3. That sidechains basically need to be merged-mined; to do otherwise,
there are marginal costs but really no marginal benefits.

However:

On 9/8/2017 12:19 AM, ZmnSCPxj wrote:
> Good morning.
>
> The obvious reply to all this is: what does
> sidechain-headers-on-mainchain do that drivechain cannot do cheaper?
>
> 1.  Unifies merge mining (h* commitment) and WT^ validity voting.
> Merge-mined headers increase the vote on a WT^, by increasing the depth
> of the WT^.



1. I think it is a mistake for SHOM ("Sidechain Headers on Mainchain")
to "unify merged-mining and the WT^ validity voting". This causes the
SHOM to regress to mere extension blocks, and they therefore take on
many of the negative properties of extension blocks.

See: http://www.drivechain.info/faq/index.html#usefulness


> 2.  Through OP_BRIBEVERIFY, the power to decide the validity of a
> sidechain lies in the economic majority rather than in the miners.


I don't think that this is true. 51% miner-group can pay bribes to
themselves, and orphan any block or txn that disagrees with them.

I also don't think that there is any meaningful difference between "what
the economic majority wants" and "what the miners do". To me it is a
blindingly obvious fact: miners are paid more, only if they increase the
value of { exchange_rate * ([x>=0] + txn_fees) }. This only increases if
Bitcoin is expected to be more objectively useful, and if its users
treasure its use sufficiently to warrant the payment of high tx fees.

When miners disagree with, for example, the bitcoin-dev mailing list,
this is because miners are attempting to guess what the economic
majority wants, and, in making this earnest attempt, miners believe that
the bitcoin-dev interest is different from the economic majority interest.

Obviously, I don't expect to change any minds on this list. After all,
(since no one dares oppose the economic majority), it is a smart
strategy to pretend that the economic majority always agrees with you.
And it is extra smart to avoid examining that belief too carefully.


  2.2.1.  This seems to imply that sidechains where unified merge-mining
> and WT^ voting are paid for by economic majority, effectively work as
> proof-of-stake.  The difference here is that the proof does not have to
> cover itself (i.e. the stake being used to prove is outside the system
> which the proof is proving) and it is really more of a
> proof-of-sacrifice-of-stake, since the economic majority needs to pay
> (and thus lose) the stake for continued operation of the sidechain.  One
> can argue that proof-of-work is just an instance of
> proof-of-sacrifice-of-stake anyway.

I agree with most of this, but I think in proof of work and proof of
stake the security guarantee is more reasonable.. In SHOM, there is no
reason to believe that the the quantity "total amount of money available
for withdrawal in a given time" will always be smaller than "sum of 288
bribes".

> 2.2.2.  Miner behavior on Bcash and Bitcoin suggests to me that a good
> portion of the miners are interested more in short-term profits than
> long-term.

As long as some critical mass of investors exist, there is no difference
between short and long term profits. It is impossible for an investor to
act in a way that affects the long term, but does not immediately also
affect the short term.


> I have not seen a good explanation of how drivechain WT^ validity voting
> works in detail; my understanding is that a WT^ is presented on the
> mainchain, then a voting period is established during which miners
> somehow vote for whether the WT^ is valid or not, then the voting ends
> and a UTXO is somehow created.  If it is in some Sztorc video, I
> apologize, I am unable to usefully view them.
Some documentation is here:
https://github.com/drivechain-project/docs/blob/master/bip1-hashrate-escrow.md


> --
>
> I think lockboxes should have fixed value.  The value should be big
> enough that the cost of OP_WITHDRAWPROOFVERIFY is low.  Particularly for
> privacy-oriented sidechains, all lockboxes having the same value will
> help tremendously in continuing obscurity after side-to-main transfers.
> However, I am uncertain whether sidechain or mainchain should enforce
> this fixed value.  This parameter is something to be endlessly debated.
> Perhaps it should be sidechain that enforces this, but then mistakes
> could occur on the mainchain where some lockbox on the mainchain is
> deemed invalid on the sidechain, and cannot be unlocked validly except
> by destroying the sidechain.
I don't think this makes any sense, because it implies that the value of
288 block's worth of mainchain BTC transaction fees should always be
worth more than the entire market capitalization of Bitcoin.

Specifically, in this case, the error it introduces is that someone
could get around the fixed value by just using multiple sidechains. Then
the miners would just attack all the sidechains simultaneously. (And
these smaller sidechains would themselves have much smaller fees.)


>
> Sidechains may first be deployed as federated peg, then at some
> sidechain height the federation may announce a move to
> drivechain/sidechain-headers-on-mainchain.  The move from federated to
> economic-majority-controlled would involve the federation moving its
> controlled lockboxes to OP_WITHDRAWPROOFVERIFY lockboxes.
Sergio likes this idea, but I think that this attitude represents a lack
of faith in the design. Either the design works or it does not. Either
the federation works or it does not.
>
> Sidechain hardforks would be very contentious, with only one clear
> winner that can unlock lockboxes.  I think, part of sidechain design
> must be the understanding that sidechains must never be hardforked, and
> only softforked.  Indeed, I am very much convinced that it is impossible
> to safely hardfork mainchain at all, and any block size increase must by
> necessity be softforked in.
This is already the case in what we have done...the only way to
guarantee that all clients report the same WT^ is if they are all
running softforks of the first version.


> The mechanism that supports sidechains supports any financial system,
> including centralized, non blockchain ones.  The h* commitments can be
> made into commitments to the financial system's state.  Basically, it is
> an implementation of CoinWitness, without using zk-SNARKs and instead
> using some mainchain-voted proof, where validity is judged by how much
> maincoin was sacrified to advance that proof.  The supported financial
> system might even allow arbitrary execution of Turing-complete code for
> more vulnerabilities.
This is why I do not want ultra-easy, completely-permissionless creation
of sidechains. Miners (and therefore, users) may NOT desire the EXPECTED
behavior of the sidechain.
> Is there some spec for WT^ layout?
Yes, see above.

Thanks,
Paul


From jtimon at jtimon.cc  Sat Sep  9 21:11:57 2017
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Sat, 9 Sep 2017 23:11:57 +0200
Subject: [bitcoin-dev] SF proposal: prohibit unspendable outputs with
	amount=0
In-Reply-To: <20170907180014.GA13727@fedora-23-dvm>
References: <CABm2gDojDQWMhw8wW1UkRGKtdbby2+6AFFZLPuRcUb7WF_u5qQ@mail.gmail.com>
	<20170907180014.GA13727@fedora-23-dvm>
Message-ID: <CABm2gDpy3a0vc+4=0a2vFSQ2d1gaAWFkPtzdbXLpNKYFepDU3A@mail.gmail.com>

Tier Nolan, right, a new tx version would be required.

I have to look deeper into the CT as sf proposal.

What futures upgrades could this conflict with it's precisely the
question here. So that vague statement without providing any example
it's not very valuable.

Although TXO commitments are interesting, I don't think they make UTXO
growth a "non-issue" and I also don't think they justify not doing
this.

Yeah, the costs for spammers are very small and doesn't really improve
things all that much, as acknowledged in the initial post.



On Thu, Sep 7, 2017 at 8:00 PM, Peter Todd <pete at petertodd.org> wrote:
> On Tue, Sep 05, 2017 at 11:51:45PM +0200, Jorge Tim?n via bitcoin-dev wrote:
>> This is not a priority, not very important either.
>> Right now it is possible to create 0-value outputs that are spendable
>> and thus stay in the utxo (potentially forever). Requiring at least 1
>> satoshi per output doesn't really do much against a spam attack to the
>> utxo, but I think it would be slightly better than the current
>> situation.
>
> Given that this has a very minimal cost for spammers - just a single satoshi -
> I don't think this is worth the risk of making future upgrades more complex as
> other posters have brought up.
>
> Secondly, I think we have good reason to think that things like my own TXO
> commitments and Bram's related work will make UTXO growth a non-issue in the
> future.
>
> So, I'd NACK such a proposal myself.
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org

From simon at bitcartel.com  Sun Sep 10 22:03:48 2017
From: simon at bitcartel.com (Simon Liu)
Date: Sun, 10 Sep 2017 15:03:48 -0700
Subject: [bitcoin-dev] Responsible disclosure of bugs
Message-ID: <3e4541f3-f65c-5199-5e85-9a65ea5142e7@bitcartel.com>

Hi,

Given today's presentation by Chris Jeffrey at the Breaking Bitcoin
conference, and the subsequent discussion around responsible disclosure
and industry practice, perhaps now would be a good time to discuss
"Bitcoin and CVEs" which has gone unanswered for 6 months.

https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013751.html

To quote:

"Are there are any vulnerabilities in Bitcoin which have been fixed but
not yet publicly disclosed?  Is the following list of Bitcoin CVEs
up-to-date?

https://en.bitcoin.it/wiki/Common_Vulnerabilities_and_Exposures

There have been no new CVEs posted for almost three years, except for
CVE-2015-3641, but there appears to be no information publicly available
for that issue:

https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-3641

It would be of great benefit to end users if the community of clients
and altcoins derived from Bitcoin Core could be patched for any known
vulnerabilities.

Does anyone keep track of security related bugs and patches, where the
defect severity is similar to those found on the CVE list above?  If
yes, can that list be shared with other developers?"

Best Regards,
Simon

From ZmnSCPxj at protonmail.com  Sun Sep 10 05:32:42 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sun, 10 Sep 2017 01:32:42 -0400
Subject: [bitcoin-dev] Fwd: Sidechain headers on mainchain (unification
	of drivechains and spv proofs)
In-Reply-To: <1e3f1e8d-c5c9-9ee5-7069-6db47bec5879@gmail.com>
References: <H7RPmZGfkVC8opGMMCW7Orav6yD05-AVB9bNtNU8C0hKYokiXL32VSmn0wkjn77qh4MvacPOePdVQ5gQZuAMF6q2oEuvKDSu6crNcEoXx_0=@protonmail.com>
	<CAGL6+mG-jD6L5b0LepyotDd2+POjkrgV98c2fLFGM0ZokD4afA@mail.gmail.com>
	<wkUkYK_kYwSQx7JKzvgrfUiZYPLPrORMT_zBL5Tg-Spnr8tOyC_o4nZT4yFOD-FE86FvshRhWTfPblYqVmaZHi-VnMbKwpDDkAOjI8b9ap8=@protonmail.com>
	<CAGL6+mGy7nTK1yA8YZcG59r9GZmVb+XWgQ1HjuPD4_pD7ZWThw@mail.gmail.com>
	<6S1lfiXnljmQiZLorMOenBXGeve0K_LHKiCIZ75Gfc8LZieB7sq_bV_UWV-kJ197FYWywzDaQE7kOEqguYxlDFWZnLdzONhFZ7OAaWFgn64=@protonmail.com>
	<CAGL6+mHqKXbm5nAHq+ghaTihCQQe0Rs1sd82ff2NiFKSq6Be+A@mail.gmail.com>
	<yDICafWAbOJEbNvT9o8fltfCuJry5ZOLGwjQ-Ji6xfLjTP3XI_DXb8UbFJ6tA8jclqIEudFABAVEbXuLN9HLnN2nv-WTDE7q9vyjcALtufc=@protonmail.com>
	<CAGL6+mGrN1m_zWs0KM4sfPHCdYUjuJ+E6hjVCFOtz2RoBDZyoQ@mail.gmail.com>
	<E-mvls0CjntrzO4fWx84mYQtc0agV4KdP5QvX3ie3fLXC_YaB58OFvRYTRZhwo7vOn5OPQnlITFwOwyFgDAAZpQ2rvtCgsi-FCy95dBEP0s=@protonmail.com>
	<1e3f1e8d-c5c9-9ee5-7069-6db47bec5879@gmail.com>
Message-ID: <lU8kHQr4ixxKuItNEaXMGLnNdLMMFbHKdFL8wl7Pd_4dH3rzOLD2FPsy4rv6Kj1QB64b_bws90ZovcYofemBe4KegUCgAXYKYUMUjVfmoE4=@protonmail.com>

Good morning Paul,

Thank you for your consideration.

>> 1. Unifies merge mining (h* commitment) and WT^ validity voting.
>> Merge-mined headers increase the vote on a WT^, by increasing the depth
>> of the WT^.
>
>1. I think it is a mistake for SHOM ("Sidechain Headers on Mainchain")
>to "unify merged-mining and the WT^ validity voting". This causes the
>SHOM to regress to mere extension blocks, and they therefore take on
>many of the negative properties of extension blocks.
>
>See: http://www.drivechain.info/faq/index.html#usefulness

I don't see how this regress occurs.  Perhaps I need more information on extension blocks.

>> 2. Through OP_BRIBEVERIFY, the power to decide the validity of a
>> sidechain lies in the economic majority rather than in the miners.
>
>I don"t think that this is true. 51% miner-group can pay bribes to
>themselves, and orphan any block or txn that disagrees with them.

Any miner that rejects a bribe from outside the miner-group in order to put their desired hash on the sidechain, values their desired hash more than the bribe to put a different hash.  This rejection is a loss of potential proift, and other miners who accept the bribe gain the profit from it.

>I also don"t think that there is any meaningful difference between "what
>the economic majority wants" and "what the miners do". To me it is a
>blindingly obvious fact: miners are paid more, only if they increase the
>value of { exchange_rate * ([x>=0] + txn_fees) }. This only increases if
>Bitcoin is expected to be more objectively useful, and if its users
>treasure its use sufficiently to warrant the payment of high tx fees.
>
>When miners disagree with, for example, the bitcoin-dev mailing list,
>this is because miners are attempting to guess what the economic
>majority wants, and, in making this earnest attempt, miners believe that
>the bitcoin-dev interest is different from the economic majority interest.
>
>Obviously, I don"t expect to change any minds on this list. After all,
>(since no one dares oppose the economic majority), it is a smart
>strategy to pretend that the economic majority always agrees with you.
>And it is extra smart to avoid examining that belief too carefully.

Your last paragraph does not make sense to me.  I suspect I have hit upon a nerve and will make no further comment on this sub-topic.

>>2.2.1. This seems to imply that sidechains where unified merge-mining
>> and WT^ voting are paid for by economic majority, effectively work as
>> proof-of-stake. The difference here is that the proof does not have to
>> cover itself (i.e. the stake being used to prove is outside the system
>> which the proof is proving) and it is really more of a
>> proof-of-sacrifice-of-stake, since the economic majority needs to pay
>> (and thus lose) the stake for continued operation of the sidechain. One
>> can argue that proof-of-work is just an instance of
>> proof-of-sacrifice-of-stake anyway.
>
>I agree with most of this, but I think in proof of work and proof of
>stake the security guarantee is more reasonable.. In SHOM, there is no
>reason to believe that the the quantity "total amount of money available
>for withdrawal in a given time" will always be smaller than "sum of 288
>bribes".

This is indeed the problem.  SHOM, as it unifies merge mining and WT^ voting, also allows theft attempts, and once the money available for withdrawal exceeds the sum of 288 bribes, we enter a dollar auction game between the thief and the sidechain users: https://en.wikipedia.org/wiki/Dollar_auction

As thieves are expected to follow the simple greedy algorithm, sidechain death can be triggered by a single theft attempt.

Assuming potential thieves understand the dollar-auction irrationality, they may be disincentivized, as presumably there are more sidechain protectors than thieves, and the sidechain protectors can (we hope) all outbid the thief.  But the problem is that this require rational behavior from thieves.  Mere greedy algorithm, or disruption for the sake of disruption, would still collapse SHOM sidechains.

But given the many parallels between SHOM and drivechains: what happens if 26% of miners disrupt all sidechains by always downvoting WT^?  In that case, sidechains still collapse as a whole, with practically the same effect as the SHOM thief.

We could limit the money available for withdrawal, but that weakens the side-to-main peg, reducing the value of the sidecoin relative to the maincoin.

The problem, to my mind, is that blind merge mining is pointless if it does not also allow voting on WT^.  In the end, no matter how novel a sidechain may be, what is valued is the maincoin backing the sidecoin; that is the whole point of the two-way peg.  A sidechain user may OP_BRIBEVERIFY valid sideblocks onto the mainchain, but if that user cannot vote on WT^ anyway, no matter how valid sideblocks committed on the mainchain, it would be pointless if the sidechain is attacked by mainchain miners.  You may as well remove blind merge mining, as miners who must vote on WT^ will need to understand the sidechain validity rules anyway.

>> 2.2.2. Miner behavior on Bcash and Bitcoin suggests to me that a good
>> portion of the miners are interested more in short-term profits than
>> long-term.
>
>As long as some critical mass of investors exist, there is no difference
>between short and long term profits. It is impossible for an investor to
>act in a way that affects the long term, but does not immediately also
>affect the short term.

I do not quite follow.  Can you expand more on this?

>> I have not seen a good explanation of how drivechain WT^ validity voting
>> works in detail; my understanding is that a WT^ is presented on the
>> mainchain, then a voting period is established during which miners
>> somehow vote for whether the WT^ is valid or not, then the voting ends
>> and a UTXO is somehow created. If it is in some Sztorc video, I
>> apologize, I am unable to usefully view them.
>Some documentation is here:
>https://github.com/drivechain-project/docs/blob/master/bip1-hashrate-escrow.md

Thank you.

>> I think lockboxes should have fixed value. The value should be big
>> enough that the cost of OP_WITHDRAWPROOFVERIFY is low. Particularly for
>> privacy-oriented sidechains, all lockboxes having the same value will
>> help tremendously in continuing obscurity after side-to-main transfers.
>> However, I am uncertain whether sidechain or mainchain should enforce
>> this fixed value. This parameter is something to be endlessly debated.
>> Perhaps it should be sidechain that enforces this, but then mistakes
>> could occur on the mainchain where some lockbox on the mainchain is
>> deemed invalid on the sidechain, and cannot be unlocked validly except
>> by destroying the sidechain.
>I don"t think this makes any sense, because it implies that the value of
>288 block"s worth of mainchain BTC transaction fees should always be
>worth more than the entire market capitalization of Bitcoin.
>
>Specifically, in this case, the error it introduces is that someone
>could get around the fixed value by just using multiple sidechains. Then
>the miners would just attack all the sidechains simultaneously. (And
>these smaller sidechains would themselves have much smaller fees.)

In order to attack multiple sidechains, bribing thieves must pay bribes for each sidechain being attacked.  Even if a miner attacks, bribes for valid sidechains must be rejected by the miner, effectively reducing the miner's profits, and the bribes to be rejected must be for all the sidechains to be attacked.

If withdrawals have a fixed or maximum value, then the bribe a thief must be prepared to pay (or turn down, in the case of thieving miners) must be no more than the maximum value / 288.

Unfortunately, capping withdrawals weakens the side-to-main peg, which weakens the reason for even using SHOM.  This is the true weakness of SHOM: it provides only a very weak side-to-main peg.

>>
>> Sidechains may first be deployed as federated peg, then at some
>> sidechain height the federation may announce a move to
>> drivechain/sidechain-headers-on-mainchain. The move from federated to
>> economic-majority-controlled would involve the federation moving its
>> controlled lockboxes to OP_WITHDRAWPROOFVERIFY lockboxes.
>Sergio likes this idea, but I think that this attitude represents a lack
>of faith in the design. Either the design works or it does not. Either
>the federation works or it does not.

I agree.

>>
>> Sidechain hardforks would be very contentious, with only one clear
>> winner that can unlock lockboxes. I think, part of sidechain design
>> must be the understanding that sidechains must never be hardforked, and
>> only softforked. Indeed, I am very much convinced that it is impossible
>> to safely hardfork mainchain at all, and any block size increase must by
>> necessity be softforked in.
>This is already the case in what we have done...the only way to
>guarantee that all clients report the same WT^ is if they are all
>running softforks of the first version.

Yes.

>> The mechanism that supports sidechains supports any financial system,
>> including centralized, non blockchain ones. The h* commitments can be
>> made into commitments to the financial system"s state. Basically, it is
>> an implementation of CoinWitness, without using zk-SNARKs and instead
>> using some mainchain-voted proof, where validity is judged by how much
>> maincoin was sacrified to advance that proof. The supported financial
>> system might even allow arbitrary execution of Turing-complete code for
>> more vulnerabilities.
>This is why I do not want ultra-easy, completely-permissionless creation
>of sidechains. Miners (and therefore, users) may NOT desire the EXPECTED
>behavior of the sidechain.

I am fine with some economic bond or proof-of-burn to start a sidechain.  But I am opposed to any permissioned method of starting sidechains.  To my mind, asking miners to install your software is already permissioned.

>> Is there some spec for WT^ layout?
>Yes, see above.

Thank you.

Regards,
ZmnSCPxj
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170910/12f519b9/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Sun Sep 10 05:33:06 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sun, 10 Sep 2017 01:33:06 -0400
Subject: [bitcoin-dev] Fwd: Sidechain headers on mainchain (unification
	of drivechains and spv proofs)
In-Reply-To: <1e3f1e8d-c5c9-9ee5-7069-6db47bec5879@gmail.com>
References: <H7RPmZGfkVC8opGMMCW7Orav6yD05-AVB9bNtNU8C0hKYokiXL32VSmn0wkjn77qh4MvacPOePdVQ5gQZuAMF6q2oEuvKDSu6crNcEoXx_0=@protonmail.com>
	<CAGL6+mG-jD6L5b0LepyotDd2+POjkrgV98c2fLFGM0ZokD4afA@mail.gmail.com>
	<wkUkYK_kYwSQx7JKzvgrfUiZYPLPrORMT_zBL5Tg-Spnr8tOyC_o4nZT4yFOD-FE86FvshRhWTfPblYqVmaZHi-VnMbKwpDDkAOjI8b9ap8=@protonmail.com>
	<CAGL6+mGy7nTK1yA8YZcG59r9GZmVb+XWgQ1HjuPD4_pD7ZWThw@mail.gmail.com>
	<6S1lfiXnljmQiZLorMOenBXGeve0K_LHKiCIZ75Gfc8LZieB7sq_bV_UWV-kJ197FYWywzDaQE7kOEqguYxlDFWZnLdzONhFZ7OAaWFgn64=@protonmail.com>
	<CAGL6+mHqKXbm5nAHq+ghaTihCQQe0Rs1sd82ff2NiFKSq6Be+A@mail.gmail.com>
	<yDICafWAbOJEbNvT9o8fltfCuJry5ZOLGwjQ-Ji6xfLjTP3XI_DXb8UbFJ6tA8jclqIEudFABAVEbXuLN9HLnN2nv-WTDE7q9vyjcALtufc=@protonmail.com>
	<CAGL6+mGrN1m_zWs0KM4sfPHCdYUjuJ+E6hjVCFOtz2RoBDZyoQ@mail.gmail.com>
	<E-mvls0CjntrzO4fWx84mYQtc0agV4KdP5QvX3ie3fLXC_YaB58OFvRYTRZhwo7vOn5OPQnlITFwOwyFgDAAZpQ2rvtCgsi-FCy95dBEP0s=@protonmail.com>
	<1e3f1e8d-c5c9-9ee5-7069-6db47bec5879@gmail.com>
Message-ID: <9F0W8wmZ5V5ibzeO8-_gKfVFgTsMjJMTNp2T9LwfBnJy-FBDWRcI-52fk3sQN_wjrulE04nJGsLcLRqO7zOzMztI5tleeX10iQUHJxWQqdk=@protonmail.com>

Sent with [ProtonMail](https://protonmail.com) Secure Email.

> -------- Original Message --------
> Subject: Re: Fwd: [bitcoin-dev] Sidechain headers on mainchain (unification of drivechains and spv proofs)
> Local Time: September 9, 2017 3:33 PM
> UTC Time: September 9, 2017 3:33 PM
> From: truthcoin at gmail.com
> To: Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>, ZmnSCPxj <ZmnSCPxj at protonmail.com>
>
> Hi everyone,
>
> I have some agreements and disagreements.
>
> I agree with Zmn:
>
> 1. That the sidechain"s header is fully defined by the bits of data
> included in mainchain headers. These bits include "h*" (some hash that
> is either of the header itself or side:hashMerkleRoot), something that
> forces these hashes into a DAG-like structure (in Zmn"s case, it is a
> full hashPrevBlock, whereas for us it is just a tiny integer).
> 2. That "miner-voting" (for lack of better phrase) accomplishes the same
> task as any SPV Proof of any kind.
> 3. That sidechains basically need to be merged-mined; to do otherwise,
> there are marginal costs but really no marginal benefits.
>
> However:
>
> On 9/8/2017 12:19 AM, ZmnSCPxj wrote:
>> Good morning.
>>
>> The obvious reply to all this is: what does
>> sidechain-headers-on-mainchain do that drivechain cannot do cheaper?
>>
>> 1. Unifies merge mining (h* commitment) and WT^ validity voting.
>> Merge-mined headers increase the vote on a WT^, by increasing the depth
>> of the WT^.
>
> 1. I think it is a mistake for SHOM ("Sidechain Headers on Mainchain")
> to "unify merged-mining and the WT^ validity voting". This causes the
> SHOM to regress to mere extension blocks, and they therefore take on
> many of the negative properties of extension blocks.
>
> See: http://www.drivechain.info/faq/index.html#usefulness
>
>> 2. Through OP_BRIBEVERIFY, the power to decide the validity of a
>> sidechain lies in the economic majority rather than in the miners.
>
> I don"t think that this is true. 51% miner-group can pay bribes to
> themselves, and orphan any block or txn that disagrees with them.
>
> I also don"t think that there is any meaningful difference between "what
> the economic majority wants" and "what the miners do". To me it is a
> blindingly obvious fact: miners are paid more, only if they increase the
> value of { exchange_rate * ([x>=0] + txn_fees) }. This only increases if
> Bitcoin is expected to be more objectively useful, and if its users
> treasure its use sufficiently to warrant the payment of high tx fees.
>
> When miners disagree with, for example, the bitcoin-dev mailing list,
> this is because miners are attempting to guess what the economic
> majority wants, and, in making this earnest attempt, miners believe that
> the bitcoin-dev interest is different from the economic majority interest.
>
> Obviously, I don"t expect to change any minds on this list. After all,
> (since no one dares oppose the economic majority), it is a smart
> strategy to pretend that the economic majority always agrees with you.
> And it is extra smart to avoid examining that belief too carefully.
>
> 2.2.1. This seems to imply that sidechains where unified merge-mining
>> and WT^ voting are paid for by economic majority, effectively work as
>> proof-of-stake. The difference here is that the proof does not have to
>> cover itself (i.e. the stake being used to prove is outside the system
>> which the proof is proving) and it is really more of a
>> proof-of-sacrifice-of-stake, since the economic majority needs to pay
>> (and thus lose) the stake for continued operation of the sidechain. One
>> can argue that proof-of-work is just an instance of
>> proof-of-sacrifice-of-stake anyway.
>
> I agree with most of this, but I think in proof of work and proof of
> stake the security guarantee is more reasonable.. In SHOM, there is no
> reason to believe that the the quantity "total amount of money available
> for withdrawal in a given time" will always be smaller than "sum of 288
> bribes".
>
>> 2.2.2. Miner behavior on Bcash and Bitcoin suggests to me that a good
>> portion of the miners are interested more in short-term profits than
>> long-term.
>
> As long as some critical mass of investors exist, there is no difference
> between short and long term profits. It is impossible for an investor to
> act in a way that affects the long term, but does not immediately also
> affect the short term.
>
>> I have not seen a good explanation of how drivechain WT^ validity voting
>> works in detail; my understanding is that a WT^ is presented on the
>> mainchain, then a voting period is established during which miners
>> somehow vote for whether the WT^ is valid or not, then the voting ends
>> and a UTXO is somehow created. If it is in some Sztorc video, I
>> apologize, I am unable to usefully view them.
> Some documentation is here:
> https://github.com/drivechain-project/docs/blob/master/bip1-hashrate-escrow.md
>
>> --
>>
>> I think lockboxes should have fixed value. The value should be big
>> enough that the cost of OP_WITHDRAWPROOFVERIFY is low. Particularly for
>> privacy-oriented sidechains, all lockboxes having the same value will
>> help tremendously in continuing obscurity after side-to-main transfers.
>> However, I am uncertain whether sidechain or mainchain should enforce
>> this fixed value. This parameter is something to be endlessly debated.
>> Perhaps it should be sidechain that enforces this, but then mistakes
>> could occur on the mainchain where some lockbox on the mainchain is
>> deemed invalid on the sidechain, and cannot be unlocked validly except
>> by destroying the sidechain.
> I don"t think this makes any sense, because it implies that the value of
> 288 block"s worth of mainchain BTC transaction fees should always be
> worth more than the entire market capitalization of Bitcoin.
>
> Specifically, in this case, the error it introduces is that someone
> could get around the fixed value by just using multiple sidechains. Then
> the miners would just attack all the sidechains simultaneously. (And
> these smaller sidechains would themselves have much smaller fees.)
>
>>
>> Sidechains may first be deployed as federated peg, then at some
>> sidechain height the federation may announce a move to
>> drivechain/sidechain-headers-on-mainchain. The move from federated to
>> economic-majority-controlled would involve the federation moving its
>> controlled lockboxes to OP_WITHDRAWPROOFVERIFY lockboxes.
> Sergio likes this idea, but I think that this attitude represents a lack
> of faith in the design. Either the design works or it does not. Either
> the federation works or it does not.
>>
>> Sidechain hardforks would be very contentious, with only one clear
>> winner that can unlock lockboxes. I think, part of sidechain design
>> must be the understanding that sidechains must never be hardforked, and
>> only softforked. Indeed, I am very much convinced that it is impossible
>> to safely hardfork mainchain at all, and any block size increase must by
>> necessity be softforked in.
> This is already the case in what we have done...the only way to
> guarantee that all clients report the same WT^ is if they are all
> running softforks of the first version.
>
>> The mechanism that supports sidechains supports any financial system,
>> including centralized, non blockchain ones. The h* commitments can be
>> made into commitments to the financial system"s state. Basically, it is
>> an implementation of CoinWitness, without using zk-SNARKs and instead
>> using some mainchain-voted proof, where validity is judged by how much
>> maincoin was sacrified to advance that proof. The supported financial
>> system might even allow arbitrary execution of Turing-complete code for
>> more vulnerabilities.
> This is why I do not want ultra-easy, completely-permissionless creation
> of sidechains. Miners (and therefore, users) may NOT desire the EXPECTED
> behavior of the sidechain.
>> Is there some spec for WT^ layout?
> Yes, see above.
>
> Thanks,
> Paul
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170910/f2f8e653/attachment.html>

From lf-lists at mattcorallo.com  Sun Sep 10 23:02:36 2017
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Sun, 10 Sep 2017 19:02:36 -0400
Subject: [bitcoin-dev] Responsible disclosure of bugs
In-Reply-To: <3e4541f3-f65c-5199-5e85-9a65ea5142e7@bitcartel.com>
References: <3e4541f3-f65c-5199-5e85-9a65ea5142e7@bitcartel.com>
Message-ID: <cb968a34-f8d2-ab61-dd15-9bd282afd18c@mattcorallo.com>

I believe there continues to be concern over a number of altcoins which
are running old, unpatched forks of Bitcoin Core, making it rather
difficult to disclose issues without putting people at risk (see, eg,
some of the dos issues which are preventing release of the alert key).
I'd encourage the list to have a discussion about what reasonable
approaches could be taken there.

On 09/10/17 18:03, Simon Liu via bitcoin-dev wrote:
> Hi,
> 
> Given today's presentation by Chris Jeffrey at the Breaking Bitcoin
> conference, and the subsequent discussion around responsible disclosure
> and industry practice, perhaps now would be a good time to discuss
> "Bitcoin and CVEs" which has gone unanswered for 6 months.
> 
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013751.html
> 
> To quote:
> 
> "Are there are any vulnerabilities in Bitcoin which have been fixed but
> not yet publicly disclosed?  Is the following list of Bitcoin CVEs
> up-to-date?
> 
> https://en.bitcoin.it/wiki/Common_Vulnerabilities_and_Exposures
> 
> There have been no new CVEs posted for almost three years, except for
> CVE-2015-3641, but there appears to be no information publicly available
> for that issue:
> 
> https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-3641
> 
> It would be of great benefit to end users if the community of clients
> and altcoins derived from Bitcoin Core could be patched for any known
> vulnerabilities.
> 
> Does anyone keep track of security related bugs and patches, where the
> defect severity is similar to those found on the CVE list above?  If
> yes, can that list be shared with other developers?"
> 
> Best Regards,
> Simon
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From cryptaxe at gmail.com  Sun Sep 10 23:28:18 2017
From: cryptaxe at gmail.com (CryptAxe)
Date: Sun, 10 Sep 2017 16:28:18 -0700
Subject: [bitcoin-dev] Responsible disclosure of bugs
In-Reply-To: <cb968a34-f8d2-ab61-dd15-9bd282afd18c@mattcorallo.com>
References: <3e4541f3-f65c-5199-5e85-9a65ea5142e7@bitcartel.com>
	<cb968a34-f8d2-ab61-dd15-9bd282afd18c@mattcorallo.com>
Message-ID: <CAF5CFkifQYnLC4vhLy5EtyFrpk4tAE_VqXobeWBvKEzgegxipw@mail.gmail.com>

I don't think we should put any Bitcoin users at additional risk to help
altcoins. If they fork the code they are making maintenance their own
responsibly.

It's hard to disclose a bitcoin vulnerability considering the network is
decentralised and core can't force everyone to update. Maybe a timeout
period for vulnerabilities could be decided. People might be expected to
patched before then at which point the vulnerability can be published. Is
that not already sort of how it works?

On Sep 10, 2017 4:10 PM, "Matt Corallo via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I believe there continues to be concern over a number of altcoins which
> are running old, unpatched forks of Bitcoin Core, making it rather
> difficult to disclose issues without putting people at risk (see, eg,
> some of the dos issues which are preventing release of the alert key).
> I'd encourage the list to have a discussion about what reasonable
> approaches could be taken there.
>
> On 09/10/17 18:03, Simon Liu via bitcoin-dev wrote:
> > Hi,
> >
> > Given today's presentation by Chris Jeffrey at the Breaking Bitcoin
> > conference, and the subsequent discussion around responsible disclosure
> > and industry practice, perhaps now would be a good time to discuss
> > "Bitcoin and CVEs" which has gone unanswered for 6 months.
> >
> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> 2017-March/013751.html
> >
> > To quote:
> >
> > "Are there are any vulnerabilities in Bitcoin which have been fixed but
> > not yet publicly disclosed?  Is the following list of Bitcoin CVEs
> > up-to-date?
> >
> > https://en.bitcoin.it/wiki/Common_Vulnerabilities_and_Exposures
> >
> > There have been no new CVEs posted for almost three years, except for
> > CVE-2015-3641, but there appears to be no information publicly available
> > for that issue:
> >
> > https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-3641
> >
> > It would be of great benefit to end users if the community of clients
> > and altcoins derived from Bitcoin Core could be patched for any known
> > vulnerabilities.
> >
> > Does anyone keep track of security related bugs and patches, where the
> > defect severity is similar to those found on the CVE list above?  If
> > yes, can that list be shared with other developers?"
> >
> > Best Regards,
> > Simon
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170910/1b3bfb59/attachment.html>

From aj at erisian.com.au  Mon Sep 11 02:15:07 2017
From: aj at erisian.com.au (Anthony Towns)
Date: Mon, 11 Sep 2017 12:15:07 +1000
Subject: [bitcoin-dev] Responsible disclosure of bugs
In-Reply-To: <cb968a34-f8d2-ab61-dd15-9bd282afd18c@mattcorallo.com>
References: <3e4541f3-f65c-5199-5e85-9a65ea5142e7@bitcartel.com>
	<cb968a34-f8d2-ab61-dd15-9bd282afd18c@mattcorallo.com>
Message-ID: <20170911021506.GA19080@erisian.com.au>

On Sun, Sep 10, 2017 at 07:02:36PM -0400, Matt Corallo via bitcoin-dev wrote:
> I believe there continues to be concern over a number of altcoins which
> are running old, unpatched forks of Bitcoin Core, making it rather
> difficult to disclose issues without putting people at risk (see, eg,
> some of the dos issues which are preventing release of the alert key).
> I'd encourage the list to have a discussion about what reasonable
> approaches could be taken there.

That seems like it just says bitcoin core has two classes of users:
people who use it directly following mainnet or testnet, and people who
make derived works based on it to run altcoins.

Having a "responsible disclosure" timeline something like:

 * day -N: vulnerability reported privately
 * day -N+1: details shared amongst private trusted bitcoin core group
 * day 0: patch/workaround/mitigation determined, CVE reserved
 * day 1: basic information shared with small group of trusted users
      (eg, altcoin maintainers, exchanges, maybe wallet devs)
 * day ~7: patches can be included in git repo
      (without references to vulnerability)
 * day 90: release candidate with fix available
 * day 120: official release including fix
 * day 134: CVE published with details and acknowledgements

could make sense. 90 days / 3 months is hopefully a fair strict upper
bound for how long it should take to get a fix into a rc; but that's still
a lot longer than many responsible disclosure timeframes, like CERT's at
45 days, but also shorter than some bitcoin core minor update cycles...
Obviously, those timelines could be varied down if something is more
urgent (or just easy).

As it is, not publishing vulnerability info just seems like it gives
everyone a false sense of security, and encourages ignoring good security
practices, either not upgrading bitcoind nodes, or not ensuring altcoin
implementations keep up to date...

I suppose both "trusted bitcoin core group" and "small group of trusted
users" isn't 100% cypherpunk, but it sure seems better than not both not
disclosing vulnerability details, and not disclosing vulnerabilities
at all... (And maybe it could be made more cypherpunk by, say, having
the disclosures to trusted groups have the description/patches get
automatically fuzzed to perhaps allow identification of leakers?)

Cheers,
aj

> On 09/10/17 18:03, Simon Liu via bitcoin-dev wrote:
> > Hi,
> > 
> > Given today's presentation by Chris Jeffrey at the Breaking Bitcoin
> > conference, and the subsequent discussion around responsible disclosure
> > and industry practice, perhaps now would be a good time to discuss
> > "Bitcoin and CVEs" which has gone unanswered for 6 months.
> > 
> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013751.html
> > 
> > To quote:
> > 
> > "Are there are any vulnerabilities in Bitcoin which have been fixed but
> > not yet publicly disclosed?  Is the following list of Bitcoin CVEs
> > up-to-date?
> > 
> > https://en.bitcoin.it/wiki/Common_Vulnerabilities_and_Exposures
> > 
> > There have been no new CVEs posted for almost three years, except for
> > CVE-2015-3641, but there appears to be no information publicly available
> > for that issue:
> > 
> > https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-3641
> > 
> > It would be of great benefit to end users if the community of clients
> > and altcoins derived from Bitcoin Core could be patched for any known
> > vulnerabilities.
> > 
> > Does anyone keep track of security related bugs and patches, where the
> > defect severity is similar to those found on the CVE list above?  If
> > yes, can that list be shared with other developers?"
> > 
> > Best Regards,
> > Simon
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> > 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From morcos at gmail.com  Mon Sep 11 11:34:33 2017
From: morcos at gmail.com (Alex Morcos)
Date: Mon, 11 Sep 2017 07:34:33 -0400
Subject: [bitcoin-dev] Responsible disclosure of bugs
In-Reply-To: <20170911021506.GA19080@erisian.com.au>
References: <3e4541f3-f65c-5199-5e85-9a65ea5142e7@bitcartel.com>
	<cb968a34-f8d2-ab61-dd15-9bd282afd18c@mattcorallo.com>
	<20170911021506.GA19080@erisian.com.au>
Message-ID: <CAPWm=eVCh2FYp=SpOcZFLqz1ZCq3=Z_F9Sj+EAXFvqU-8aMuTg@mail.gmail.com>

I don't think I know the right answer here, but I will point out two things
that make this a little more complicated.

1 - There are lots of altcoin developers and while I'm sure the majority
would greatly appreciate the disclosure and would behave responsibly with
the information, I don't know where you draw the line on who you tell and
who you don't.

2- Unlike other software, I'm not sure good security for bitcoin is defined
by constant upgrading.  Obviously upgrading has an important benefit, but
one of the security considerations for Bitcoin is knowing that your
definition of the money hasn't changed.  Much harder to know that if you
change software.



On Sun, Sep 10, 2017 at 10:15 PM, Anthony Towns via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Sun, Sep 10, 2017 at 07:02:36PM -0400, Matt Corallo via bitcoin-dev
> wrote:
> > I believe there continues to be concern over a number of altcoins which
> > are running old, unpatched forks of Bitcoin Core, making it rather
> > difficult to disclose issues without putting people at risk (see, eg,
> > some of the dos issues which are preventing release of the alert key).
> > I'd encourage the list to have a discussion about what reasonable
> > approaches could be taken there.
>
> That seems like it just says bitcoin core has two classes of users:
> people who use it directly following mainnet or testnet, and people who
> make derived works based on it to run altcoins.
>
> Having a "responsible disclosure" timeline something like:
>
>  * day -N: vulnerability reported privately
>  * day -N+1: details shared amongst private trusted bitcoin core group
>  * day 0: patch/workaround/mitigation determined, CVE reserved
>  * day 1: basic information shared with small group of trusted users
>       (eg, altcoin maintainers, exchanges, maybe wallet devs)
>  * day ~7: patches can be included in git repo
>       (without references to vulnerability)
>  * day 90: release candidate with fix available
>  * day 120: official release including fix
>  * day 134: CVE published with details and acknowledgements
>
> could make sense. 90 days / 3 months is hopefully a fair strict upper
> bound for how long it should take to get a fix into a rc; but that's still
> a lot longer than many responsible disclosure timeframes, like CERT's at
> 45 days, but also shorter than some bitcoin core minor update cycles...
> Obviously, those timelines could be varied down if something is more
> urgent (or just easy).
>
> As it is, not publishing vulnerability info just seems like it gives
> everyone a false sense of security, and encourages ignoring good security
> practices, either not upgrading bitcoind nodes, or not ensuring altcoin
> implementations keep up to date...
>
> I suppose both "trusted bitcoin core group" and "small group of trusted
> users" isn't 100% cypherpunk, but it sure seems better than not both not
> disclosing vulnerability details, and not disclosing vulnerabilities
> at all... (And maybe it could be made more cypherpunk by, say, having
> the disclosures to trusted groups have the description/patches get
> automatically fuzzed to perhaps allow identification of leakers?)
>
> Cheers,
> aj
>
> > On 09/10/17 18:03, Simon Liu via bitcoin-dev wrote:
> > > Hi,
> > >
> > > Given today's presentation by Chris Jeffrey at the Breaking Bitcoin
> > > conference, and the subsequent discussion around responsible disclosure
> > > and industry practice, perhaps now would be a good time to discuss
> > > "Bitcoin and CVEs" which has gone unanswered for 6 months.
> > >
> > > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> 2017-March/013751.html
> > >
> > > To quote:
> > >
> > > "Are there are any vulnerabilities in Bitcoin which have been fixed but
> > > not yet publicly disclosed?  Is the following list of Bitcoin CVEs
> > > up-to-date?
> > >
> > > https://en.bitcoin.it/wiki/Common_Vulnerabilities_and_Exposures
> > >
> > > There have been no new CVEs posted for almost three years, except for
> > > CVE-2015-3641, but there appears to be no information publicly
> available
> > > for that issue:
> > >
> > > https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-3641
> > >
> > > It would be of great benefit to end users if the community of clients
> > > and altcoins derived from Bitcoin Core could be patched for any known
> > > vulnerabilities.
> > >
> > > Does anyone keep track of security related bugs and patches, where the
> > > defect severity is similar to those found on the CVE list above?  If
> > > yes, can that list be shared with other developers?"
> > >
> > > Best Regards,
> > > Simon
> > > _______________________________________________
> > > bitcoin-dev mailing list
> > > bitcoin-dev at lists.linuxfoundation.org
> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> > >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170911/e2ab7b78/attachment-0001.html>

From dstadulis at gmail.com  Mon Sep 11 17:43:52 2017
From: dstadulis at gmail.com (Daniel Stadulis)
Date: Mon, 11 Sep 2017 10:43:52 -0700
Subject: [bitcoin-dev] Responsible disclosure of bugs
In-Reply-To: <CAPWm=eVCh2FYp=SpOcZFLqz1ZCq3=Z_F9Sj+EAXFvqU-8aMuTg@mail.gmail.com>
References: <3e4541f3-f65c-5199-5e85-9a65ea5142e7@bitcartel.com>
	<cb968a34-f8d2-ab61-dd15-9bd282afd18c@mattcorallo.com>
	<20170911021506.GA19080@erisian.com.au>
	<CAPWm=eVCh2FYp=SpOcZFLqz1ZCq3=Z_F9Sj+EAXFvqU-8aMuTg@mail.gmail.com>
Message-ID: <CAHpxFbH_5Pb5ZmNCW==fmZWxN3bH7KNjzJsMV5KJ=bjCPWMx6A@mail.gmail.com>

I think it's relevant to treat different bug severity levels with different
response plans.

E.g.
Compromising UTXO custody (In CVE-2010-5141, OP_RETURN vulnerability)
Compromising UTXO state (In CVE-2013-3220, blockchain split due to Berkeley
DB -> LevelDB upgrade, CVE-2010-5139 Overflow bug, unscheduled inflation of
coins)
Compromising Node performance (Various node-specific DoS attacks)

Should have different disclosure policies, IMO

On Mon, Sep 11, 2017 at 4:34 AM, Alex Morcos via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I don't think I know the right answer here, but I will point out two
> things that make this a little more complicated.
>
> 1 - There are lots of altcoin developers and while I'm sure the majority
> would greatly appreciate the disclosure and would behave responsibly with
> the information, I don't know where you draw the line on who you tell and
> who you don't.
>
> 2- Unlike other software, I'm not sure good security for bitcoin is
> defined by constant upgrading.  Obviously upgrading has an important
> benefit, but one of the security considerations for Bitcoin is knowing that
> your definition of the money hasn't changed.  Much harder to know that if
> you change software.
>
>
>
> On Sun, Sep 10, 2017 at 10:15 PM, Anthony Towns via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> On Sun, Sep 10, 2017 at 07:02:36PM -0400, Matt Corallo via bitcoin-dev
>> wrote:
>> > I believe there continues to be concern over a number of altcoins which
>> > are running old, unpatched forks of Bitcoin Core, making it rather
>> > difficult to disclose issues without putting people at risk (see, eg,
>> > some of the dos issues which are preventing release of the alert key).
>> > I'd encourage the list to have a discussion about what reasonable
>> > approaches could be taken there.
>>
>> That seems like it just says bitcoin core has two classes of users:
>> people who use it directly following mainnet or testnet, and people who
>> make derived works based on it to run altcoins.
>>
>> Having a "responsible disclosure" timeline something like:
>>
>>  * day -N: vulnerability reported privately
>>  * day -N+1: details shared amongst private trusted bitcoin core group
>>  * day 0: patch/workaround/mitigation determined, CVE reserved
>>  * day 1: basic information shared with small group of trusted users
>>       (eg, altcoin maintainers, exchanges, maybe wallet devs)
>>  * day ~7: patches can be included in git repo
>>       (without references to vulnerability)
>>  * day 90: release candidate with fix available
>>  * day 120: official release including fix
>>  * day 134: CVE published with details and acknowledgements
>>
>> could make sense. 90 days / 3 months is hopefully a fair strict upper
>> bound for how long it should take to get a fix into a rc; but that's still
>> a lot longer than many responsible disclosure timeframes, like CERT's at
>> 45 days, but also shorter than some bitcoin core minor update cycles...
>> Obviously, those timelines could be varied down if something is more
>> urgent (or just easy).
>>
>> As it is, not publishing vulnerability info just seems like it gives
>> everyone a false sense of security, and encourages ignoring good security
>> practices, either not upgrading bitcoind nodes, or not ensuring altcoin
>> implementations keep up to date...
>>
>> I suppose both "trusted bitcoin core group" and "small group of trusted
>> users" isn't 100% cypherpunk, but it sure seems better than not both not
>> disclosing vulnerability details, and not disclosing vulnerabilities
>> at all... (And maybe it could be made more cypherpunk by, say, having
>> the disclosures to trusted groups have the description/patches get
>> automatically fuzzed to perhaps allow identification of leakers?)
>>
>> Cheers,
>> aj
>>
>> > On 09/10/17 18:03, Simon Liu via bitcoin-dev wrote:
>> > > Hi,
>> > >
>> > > Given today's presentation by Chris Jeffrey at the Breaking Bitcoin
>> > > conference, and the subsequent discussion around responsible
>> disclosure
>> > > and industry practice, perhaps now would be a good time to discuss
>> > > "Bitcoin and CVEs" which has gone unanswered for 6 months.
>> > >
>> > > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017
>> -March/013751.html
>> > >
>> > > To quote:
>> > >
>> > > "Are there are any vulnerabilities in Bitcoin which have been fixed
>> but
>> > > not yet publicly disclosed?  Is the following list of Bitcoin CVEs
>> > > up-to-date?
>> > >
>> > > https://en.bitcoin.it/wiki/Common_Vulnerabilities_and_Exposures
>> > >
>> > > There have been no new CVEs posted for almost three years, except for
>> > > CVE-2015-3641, but there appears to be no information publicly
>> available
>> > > for that issue:
>> > >
>> > > https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-3641
>> > >
>> > > It would be of great benefit to end users if the community of clients
>> > > and altcoins derived from Bitcoin Core could be patched for any known
>> > > vulnerabilities.
>> > >
>> > > Does anyone keep track of security related bugs and patches, where the
>> > > defect severity is similar to those found on the CVE list above?  If
>> > > yes, can that list be shared with other developers?"
>> > >
>> > > Best Regards,
>> > > Simon
>> > > _______________________________________________
>> > > bitcoin-dev mailing list
>> > > bitcoin-dev at lists.linuxfoundation.org
>> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> > >
>> > _______________________________________________
>> > bitcoin-dev mailing list
>> > bitcoin-dev at lists.linuxfoundation.org
>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170911/06bf75a1/attachment.html>

From greg at xiph.org  Mon Sep 11 18:29:46 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Mon, 11 Sep 2017 18:29:46 +0000
Subject: [bitcoin-dev] Responsible disclosure of bugs
In-Reply-To: <CAHpxFbH_5Pb5ZmNCW==fmZWxN3bH7KNjzJsMV5KJ=bjCPWMx6A@mail.gmail.com>
References: <3e4541f3-f65c-5199-5e85-9a65ea5142e7@bitcartel.com>
	<cb968a34-f8d2-ab61-dd15-9bd282afd18c@mattcorallo.com>
	<20170911021506.GA19080@erisian.com.au>
	<CAPWm=eVCh2FYp=SpOcZFLqz1ZCq3=Z_F9Sj+EAXFvqU-8aMuTg@mail.gmail.com>
	<CAHpxFbH_5Pb5ZmNCW==fmZWxN3bH7KNjzJsMV5KJ=bjCPWMx6A@mail.gmail.com>
Message-ID: <CAAS2fgRD_poPjFaG6QD3L7R1GYKEO5LikrzXz+niBFBPbLCRQg@mail.gmail.com>

On Mon, Sep 11, 2017 at 5:43 PM, Daniel Stadulis via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> I think it's relevant to treat different bug severity levels with different
> response plans.
>
> E.g.
> Compromising UTXO custody (In CVE-2010-5141, OP_RETURN vulnerability)
> Compromising UTXO state (In CVE-2013-3220, blockchain split due to Berkeley
> DB -> LevelDB upgrade, CVE-2010-5139 Overflow bug, unscheduled inflation of
> coins)
> Compromising Node performance (Various node-specific DoS attacks)
>
> Should have different disclosure policies, IMO

This assumes the states are discernible.  They often aren't cleanly.
You obviously know how bad it is in the best case, but the worst could
be much worse.

I've multiple time seen a hard to exploit issue turn out to be trivial
when you find the right trick, or a minor dos issue turn our to far
more serious.

Simple performance bugs, expertly deployed, can potentially be used to
carve up the network--- miner A and exchange B go in one partition,
everyone else in another.. and doublespend.

And so on.  So while I absolutely do agree that different things
should and can be handled differently, it is not always so clear cut.
It's prudent to treat things as more severe than you know them to be.

In fact, someone pointed out to me a major amplifier of the
utxo-memory attack thing today that Bitcoin Core narrowly dodges which
would have made it very easy to exploit against some users, and which
it seems no one previously considered.

I also think it's somewhat incorrect to call this thread anything
about disclosure, this thread is not about disclosure. Disclosure is
when you tell the vendor.  This thread is about publication and that
has very different implications. Publication is when you're sure
you've told the prospective attackers.

From adan at stampery.co  Mon Sep 11 20:37:55 2017
From: adan at stampery.co (=?UTF-8?Q?Ad=c3=a1n_S=c3=a1nchez_de_Pedro_Crespo?=)
Date: Mon, 11 Sep 2017 22:37:55 +0200
Subject: [bitcoin-dev] Merkle branch verification & tail-call semantics
 for generalized MAST
In-Reply-To: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
Message-ID: <cf9d913a-17c5-a406-6b10-98b796de932f@stampery.com>

Coincidentally, the kind of Merkle tree that Mark describes in his
proposal is exactly the one that we use at Stampery.

The Stampery BTA whitepaper[1] includes pseudocode for many of the
algorithms outlined by this proposal, including fast-SHA256, the tree
building process and the inclusion proving routine.

The wording is slightly different but the logic is just the same, so I
hope it helps future implementations in case of eventual adoption.


[1]
https://s3.amazonaws.com/stampery-cdn/docs/Stampery-BTA-v6-whitepaper.pdf


Best,
-- 
Ad?n S?nchez de Pedro Crespo
CTO, Stampery Inc.
San Francisco - Madrid
T: +34 663 163 375

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170911/bcc880d1/attachment-0001.sig>

From mark at friedenbach.org  Tue Sep 12 02:03:42 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Mon, 11 Sep 2017 19:03:42 -0700
Subject: [bitcoin-dev] Merkle branch verification & tail-call semantics
 for generalized MAST
In-Reply-To: <26AD157C-A5A9-48C3-8D29-0AD1ED35EDDD@xbt.hk>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<26AD157C-A5A9-48C3-8D29-0AD1ED35EDDD@xbt.hk>
Message-ID: <2419914E-E196-44B4-8663-599AF616A897@friedenbach.org>

My apologies for a delay in responding to emails on this list; I have
been fighting a cold.

(Also my apologies to Johnson Lau, as I forgot to forward this to the list.)

On Sep 8, 2017, at 2:21 AM, Johnson Lau <jl2012 at xbt.hk> wrote:

> Tail-call execution semantics require "unclean stake" , i.e. final
> stake with more than one item. However, "unclean stake" is invalid
> (not just non-standard) in BIP141, so you could only use it with
> legacy P2SH (which is totally pointless....). A different design
> like OP_EVAL might be needed, or you need a new witness script
> version.

I believe you meant "unclean stack," and you are correct. This was
also pointed out last tuesday by a participant at the in-person
CoreDev meetup where the idea was presented.

This doesn't kill the idea, it just complicates the implementation
slightly. A simple fix would be to allow tail-recursion to occur if
the stack is not clean (as can happen with legacy P2SH as you point
out, or yet to be defined version 1+ forms of segwit script), OR if
there is a single item on the stack and the alt-stack is not empty.
For segwit v0 scripts you then have to move any arguments to the alt
stack before ending the redeem script, leaving just the policy script
on the main stack.

> I think you have also missed the sigOp counting of the executed
> script. As you can't count it without executing the script, the
> current static analysability is lost. This was one of the reasons
> for OP_EVAL being rejected. Since sigOp is a per-block limit, any
> OP_EVAL-like operation means block validity will depend on the
> precise outcome of script execution (instead of just pass or fail),
> which is a layer violation.

I disagree with this design requirement.

The SigOp counting method used by bitcoin is flawed. It incorrectly
limits not the number of signature operations necessary to validate a
block, but rather the number of CHECKSIGs potentially encountered in
script execution, even if in an unexecuted branch. (Admitedly MAST
makes this less of an issue, but there are still useful compact
scripts that use if/else constructs to elide a CHECKSIG.) Nor will it
account for aggregation when that feature is added, or properly
differentiate between signature operations that can be batched and
those that can not.

Additionally there are other resources used by script that should be
globally limited, such as hash operations, which are not accounted for
at this time and cannot be statically assessed, even by the flawed
mechanism by which SigOps are counted. I have maintained for some time
that bitcoin should move from having multiple separate global limits
(weight and sigops, hashed bytes in XT/Classic/BCH) to a single linear
metric that combines all of these factors with appropriate
coefficients.

A better way of handling this problem, which works for both SigOps and
HashOps, is to have the witness commit to the maximum resources
consumed by validation of the spend of the coin, to relay this data
with the transaction and include it in the SigHash, and to use the
committed maximum for block validation. This could be added in a
future script version upgrade. This change would also resolve the
issue that led to the clean stack rule in segwit, allowing future
versions of script to use tail-call recursion without involving the
alt-stack.

Nevertheless it is constructive feedback that the current draft of the
BIP and its implementation do not count SigOps, at all. There are a
couple of ways this can be fixed by evaluating the top-level script
and then doing static analysis of the resulting policy script, or by
running the script and counting operations actually performed.

Additionally, it is possible that we take this time to re-evaluate
whether we should be counting SigOps other than for legacy consensus
rule compliance. The speed of verification in secp256k1 has made
signature operations no longer the chief concern in block validation
times.

> Witness script versioning is by design fully compatible with P2SH
> and BIP173, so there will be no hurdle for existing wallets to pay
> to BIP114. Actually it should be completely transparent to them.

This is correct. Your feedback will be incorporated.

> For code complexity, the minimal BIP114 could be really simple, like
> <30 lines of code? It looks complex now because it does much more
> than simply hiding scripts in a hash.

Is there a repo that contains the latest implementation of BIP 114,
for comparison purposes?

Kind regards,
Mark Friedenbach


From kanzure at gmail.com  Tue Sep 12 02:13:24 2017
From: kanzure at gmail.com (Bryan Bishop)
Date: Mon, 11 Sep 2017 21:13:24 -0500
Subject: [bitcoin-dev] Merkle branch verification & tail-call semantics
 for generalized MAST
In-Reply-To: <2419914E-E196-44B4-8663-599AF616A897@friedenbach.org>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<26AD157C-A5A9-48C3-8D29-0AD1ED35EDDD@xbt.hk>
	<2419914E-E196-44B4-8663-599AF616A897@friedenbach.org>
Message-ID: <CABaSBazcE59CczaPLLVz4yuB7qt-kTaZECFYo4_fEWNP_vRt7g@mail.gmail.com>

On Mon, Sep 11, 2017 at 9:03 PM, Mark Friedenbach via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> I believe you meant "unclean stack," and you are correct. This was
> also pointed out last tuesday by a participant at the in-person
> CoreDev meetup where the idea was presented.

http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2017-09-07-merkleized-abstract-syntax-trees/

> > For code complexity, the minimal BIP114 could be really simple, like
> > <30 lines of code? It looks complex now because it does much more
> > than simply hiding scripts in a hash.
>
> Is there a repo that contains the latest implementation of BIP 114,
> for comparison purposes?

original bip114:
https://github.com/bitcoin/bips/blob/775f26c02696e772dac4060aa092d35dedbc647c/bip-0114.mediawiki
revised bip114: https://github.com/jl2012/bips/blob/vault/bip-0114.mediawiki
https://github.com/jl2012/bitcoin/commits/vault
from https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/014963.html

- Bryan
http://heybryan.org/
1 512 203 0507

From aj at erisian.com.au  Tue Sep 12 03:37:03 2017
From: aj at erisian.com.au (Anthony Towns)
Date: Tue, 12 Sep 2017 13:37:03 +1000
Subject: [bitcoin-dev] Responsible disclosure of bugs
In-Reply-To: <CAPWm=eVCh2FYp=SpOcZFLqz1ZCq3=Z_F9Sj+EAXFvqU-8aMuTg@mail.gmail.com>
References: <3e4541f3-f65c-5199-5e85-9a65ea5142e7@bitcartel.com>
	<cb968a34-f8d2-ab61-dd15-9bd282afd18c@mattcorallo.com>
	<20170911021506.GA19080@erisian.com.au>
	<CAPWm=eVCh2FYp=SpOcZFLqz1ZCq3=Z_F9Sj+EAXFvqU-8aMuTg@mail.gmail.com>
Message-ID: <20170912033703.GD19080@erisian.com.au>

On Mon, Sep 11, 2017 at 07:34:33AM -0400, Alex Morcos wrote:
> I don't think I know the right answer here, but I will point out two things
> that make this a little more complicated.
> 1 - There are lots of altcoin developers and while I'm sure the majority would
> greatly appreciate the disclosure and would behave responsibly with the
> information, I don't know where you draw the line on who you tell and who you
> don't.

If you can't pick even a small group that's trustworthy (top five by
market cap as a start [0]? or just major bitcoin wallets / exchanges /
alt node implementations?), then it still seems better to (eventually)
disclose publically than keep it unrevealed and let it be a potential
advantage for attackers against people who haven't upgraded for other
reasons?

I find it hard to imagine bitcoin's still obscure enough that people
aren't tracking git commit logs to use them as inspiration for attacks
on bitcoin users and businesses; at best I would have thought it'd
only be a few months of development time between a fix being proposed
as a PR or committed to master and black hats having the ability to
exploit it in users who are running older nodes. (Or for that matter,
being able to be exploited by otherwise legitimate bitcoin businesses
with an agenda to push, a strong financial motive behind that agenda,
and a legal team that says they'll get away with it)

> 2- Unlike other software, I'm not sure good security for bitcoin is defined by
> constant upgrading.? Obviously upgrading has an important benefit, but one of
> the security considerations for Bitcoin is knowing that your definition of the
> money hasn't changed.? Much harder to know that if you change software.

Isn't that just an argument for putting more effort into backporting
fixes/workarounds? (I don't see how you do that without essentially
publically disclosing which patches have a security impact -- "oh,
gosh, this patch gets a backport, I wonder if maybe it has security
implications...")

(In so far as bitcoin is a consensus system, there can sometimes be a
positive network effect, where having other people upgrade can help your
security, even if you don't upgrade; "herd immunity" if you will. That
way a new release going out to other people helps keep you safe, even
while you continue to maintain the same definition of money by not
upgrading at all)

If altcoin maintainers are inconvenienced by tracking bitcoin-core
updates, that would be an argument for them to contribute back to their
upstream to make their own job easier; either helping with backports,
or perhaps contributing to patches like PR#8994 might help.

All of those things seem like they'd help not just altcoins but bitcoin
investors/traders too, so it's not even a trade-off between classes of
bitcoin core users.  And if in the end various altcoins aren't able to
keep up with security fixes, that's probably valuable information to
provide to the market...

Cheers,
aj

[0] Roughly: BCash, Litecoin, Dash, BitConnect, ZCash, Dogecoin?
    I've no idea which of those might have trustworthy devs to work with,
    but surely at least a couple do?


From aj at erisian.com.au  Tue Sep 12 04:47:58 2017
From: aj at erisian.com.au (Anthony Towns)
Date: Tue, 12 Sep 2017 14:47:58 +1000
Subject: [bitcoin-dev] Responsible disclosure of bugs
In-Reply-To: <CAHpxFbH_5Pb5ZmNCW==fmZWxN3bH7KNjzJsMV5KJ=bjCPWMx6A@mail.gmail.com>
References: <3e4541f3-f65c-5199-5e85-9a65ea5142e7@bitcartel.com>
	<cb968a34-f8d2-ab61-dd15-9bd282afd18c@mattcorallo.com>
	<20170911021506.GA19080@erisian.com.au>
	<CAPWm=eVCh2FYp=SpOcZFLqz1ZCq3=Z_F9Sj+EAXFvqU-8aMuTg@mail.gmail.com>
	<CAHpxFbH_5Pb5ZmNCW==fmZWxN3bH7KNjzJsMV5KJ=bjCPWMx6A@mail.gmail.com>
Message-ID: <20170912044758.GE19080@erisian.com.au>

On Mon, Sep 11, 2017 at 10:43:52AM -0700, Daniel Stadulis wrote:
> I think it's relevant to treat different bug severity levels with different
> response plans.?

That makes sense.

For comparison, Monero defines a response process that has three levels
and varies the response for each:

]     a. HIGH: impacts network as a whole, has potential to break entire
]        network, results in the loss of monero, or is on a scale of great
]        catastrophe
]     b. MEDIUM: impacts individual nodes, wallets, or must be carefully
]        exploited
]     c. LOW: is not easily exploitable

 -- https://github.com/monero-project/monero/blob/master/VULNERABILITY_RESPONSE_PROCESS.md

Among other things, HIGH gets treated as an emergency, MEDIUM get fixed
in a point release; LOW get deferred to the next regular release eg.

Additionally, independently of the severity, Monero's doc says they'll
either get their act together with a fix and report within 90 days,
or otherwise the researcher that found the vulnerability has the right
to publically disclose the issue themselves...

I wouldn't say that's a perfect fit for bitcoin core (at a minimum, given
the size of the ecosystem and how much care needs to go into releases,
I think 90 days is probably too short), but it seems better than current
practice...

For comparison, if you're an altcoin developer or just bitcoin core user,
and are trying to work out whether the software you're using is secure;
if you do a quick google and end up at:

  https://en.bitcoin.it/wiki/Common_Vulnerabilities_and_Exposures

you might conclude that as long as you're running version 0.11 or later,
you're fine. That doesn't seem like an accurate conclusion for people
to draw; but if you're not tracking every commit/PR, how do you do any
better than that?

Maybe transitioning from keeping things private indefinitely to having
a public disclosure policy is tricky. Maybe it might work to build up to it,
something like:

  * We'll start releasing info about security vulnerabilities fixed in
    0.12.0 and earlier releases as of 2018-01-01
  * Then we'll continue with 0.13.0 and earlier as of 2018-03-01
  * Likewise for 0.14.0 as of 2018-05-01
  * Thereafter we'll adopt a regular policy at http://...

That or something like it at least gives people relying on older,
potentially vulnerable versions a realistic chance to privately prepare
and deploy any upgrades or fixes they've missed out on until now.

Cheers,
aj


From kanzure at gmail.com  Tue Sep 12 05:18:14 2017
From: kanzure at gmail.com (Bryan Bishop)
Date: Tue, 12 Sep 2017 00:18:14 -0500
Subject: [bitcoin-dev] Responsible disclosure of bugs
In-Reply-To: <20170912033703.GD19080@erisian.com.au>
References: <3e4541f3-f65c-5199-5e85-9a65ea5142e7@bitcartel.com>
	<cb968a34-f8d2-ab61-dd15-9bd282afd18c@mattcorallo.com>
	<20170911021506.GA19080@erisian.com.au>
	<CAPWm=eVCh2FYp=SpOcZFLqz1ZCq3=Z_F9Sj+EAXFvqU-8aMuTg@mail.gmail.com>
	<20170912033703.GD19080@erisian.com.au>
Message-ID: <CABaSBawaN8GTES96yZBKa574A0TiDAHvukipYH9MGk0Euev6PA@mail.gmail.com>

On Mon, Sep 11, 2017 at 10:37 PM, Anthony Towns via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> All of those things seem like they'd help not just altcoins but bitcoin
> investors/traders too, so it's not even a trade-off between classes of
> bitcoin core users.  And if in the end various altcoins aren't able to
> keep up with security fixes, that's probably valuable information to
> provide to the market...

I have a reply to your point, but I want to clarify first that I am
not trying to provide any sort of criticism of your character, and to
any extent that my text is misinterpreted that way, that's entirely my
fault here. Anyway, here goes.

It's not enough to defend bitcoin and its users from active threats,
there is a more general responsibility to defend all kinds of users
and different software from many kinds of threats in whatever forms,
even if folks are using stupid and insecure software that you
personally don't maintain or contribute to or advocate for. Handling
knowledge of a vulnerability is a delicate matter and you might be
receiving knowledge with more serious direct or indirect impact than
originally described.

Besides the moral and ethical reasons to not unduly accelerate the
exploitation of a vulnerability, there is also a reputational
standpoint to consider, in that your position that your own (security)
work is credible is actually harmed by showing negative care for other
works by being first to publish either insecure software or knowledge
of a vulnerability. And sometimes the opposite is true: by not
disclosing knowledge of how a design is broken to someone inviting its
review, you're showing negative care in that way too, such as by
unintentionally encouraging the implementation of really bad ideas or
entirely novel misunderstandings of what you once thought were clear
concepts. So there is a difficult path to walk and especially in
security not all may be as it seems; caution is highly recommended.

Yes it would be good for "the market" to "get the signal" that
altcoins are insecure, and that some altcoin vendors are literally and
actively malicious entities, but I think everyone needs to take a step
back here and very carefully consider the color of their hats,
including those who advocate in the name of insecure downstream/forked
software.

The downside of the approach I've advocated for is that it requires
knowledge, thinking and outsmarting the red teams; I am certainly
aware of the allure of the approaches that involve absolutist
statements like "anything weak [including bitcoin if it does have
weaknesses] deserves to die and be actively exploited" but it's not
something I am interested in espousing...nor do I think it would be
healthy for this community to internalize that perspective. Instead we
should continue to work on highly defensible software, and keep
vigilant in regards to security. In "the [civilized] garden" I would
expect there to be a general understanding that people collaborate and
work together to build highly defensible evolving systems even if
there exists knowledge of vulnerabilities. But we shouldn't be
surprised when we don't go out of our way to contribute to
alternative/parasitic systems... and we shouldn't be encouraging each
other to actively bring about the eschaton by way of mishandling
knowledge of vulnerabilities...

I know these issues are difficult to get a handle on. Hopefully I've
provided some useful perspective.

- Bryan
http://heybryan.org/
1 512 203 0507

From jl2012 at xbt.hk  Tue Sep 12 08:55:59 2017
From: jl2012 at xbt.hk (Johnson Lau)
Date: Tue, 12 Sep 2017 16:55:59 +0800
Subject: [bitcoin-dev] Merkle branch verification & tail-call semantics
 for generalized MAST
In-Reply-To: <2419914E-E196-44B4-8663-599AF616A897@friedenbach.org>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<26AD157C-A5A9-48C3-8D29-0AD1ED35EDDD@xbt.hk>
	<2419914E-E196-44B4-8663-599AF616A897@friedenbach.org>
Message-ID: <DA22C531-2FAE-4332-B158-A3F96BF34002@xbt.hk>


> On 12 Sep 2017, at 10:03 AM, Mark Friedenbach <mark at friedenbach.org> wrote:
> 
> My apologies for a delay in responding to emails on this list; I have
> been fighting a cold.
> 
> (Also my apologies to Johnson Lau, as I forgot to forward this to the list.)
> 
> On Sep 8, 2017, at 2:21 AM, Johnson Lau <jl2012 at xbt.hk> wrote:
> 
>> Tail-call execution semantics require "unclean stake" , i.e. final
>> stake with more than one item. However, "unclean stake" is invalid
>> (not just non-standard) in BIP141, so you could only use it with
>> legacy P2SH (which is totally pointless....). A different design
>> like OP_EVAL might be needed, or you need a new witness script
>> version.
> 
> I believe you meant "unclean stack," and you are correct. This was
> also pointed out last tuesday by a participant at the in-person
> CoreDev meetup where the idea was presented.
> 
> This doesn't kill the idea, it just complicates the implementation
> slightly. A simple fix would be to allow tail-recursion to occur if
> the stack is not clean (as can happen with legacy P2SH as you point
> out, or yet to be defined version 1+ forms of segwit script), OR if
> there is a single item on the stack and the alt-stack is not empty.
> For segwit v0 scripts you then have to move any arguments to the alt
> stack before ending the redeem script, leaving just the policy script
> on the main stack.

This is ugly and actually broken, as different script path may require different number of stack items, so you don?t know how many OP_TOALTSTACK do you need. Easier to just use a new witness version

> 
>> I think you have also missed the sigOp counting of the executed
>> script. As you can't count it without executing the script, the
>> current static analysability is lost. This was one of the reasons
>> for OP_EVAL being rejected. Since sigOp is a per-block limit, any
>> OP_EVAL-like operation means block validity will depend on the
>> precise outcome of script execution (instead of just pass or fail),
>> which is a layer violation.
> 
> I disagree with this design requirement.
> 
> The SigOp counting method used by bitcoin is flawed. It incorrectly
> limits not the number of signature operations necessary to validate a
> block, but rather the number of CHECKSIGs potentially encountered in
> script execution, even if in an unexecuted branch. (Admitedly MAST
> makes this less of an issue, but there are still useful compact
> scripts that use if/else constructs to elide a CHECKSIG.) Nor will it
> account for aggregation when that feature is added, or properly
> differentiate between signature operations that can be batched and
> those that can not.
> 
> Additionally there are other resources used by script that should be
> globally limited, such as hash operations, which are not accounted for
> at this time and cannot be statically assessed, even by the flawed
> mechanism by which SigOps are counted. I have maintained for some time
> that bitcoin should move from having multiple separate global limits
> (weight and sigops, hashed bytes in XT/Classic/BCH) to a single linear
> metric that combines all of these factors with appropriate
> coefficients.
> 

I like the idea to have an unified global limit and suggested a way to do it (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-January/013472.html). But I think this is off-topic here.



> A better way of handling this problem, which works for both SigOps and
> HashOps, is to have the witness commit to the maximum resources
> consumed by validation of the spend of the coin, to relay this data
> with the transaction and include it in the SigHash, and to use the
> committed maximum for block validation. This could be added in a
> future script version upgrade. This change would also resolve the
> issue that led to the clean stack rule in segwit, allowing future
> versions of script to use tail-call recursion without involving the
> alt-stack.
> 
> Nevertheless it is constructive feedback that the current draft of the
> BIP and its implementation do not count SigOps, at all. There are a
> couple of ways this can be fixed by evaluating the top-level script
> and then doing static analysis of the resulting policy script, or by
> running the script and counting operations actually performed.


In any case, I think maintaining static analysability for global limit(s) is very important. Ethereum had to give up their DAO softfork plan at the last minute, exactly due to the lack of this: http://hackingdistributed.com/2016/06/28/ethereum-soft-fork-dos-vector/

Otherwise, one could attack relay and mining nodes by sending many small size txs with many sigops, forcing them to validate, and discard due to insufficient fees.

Technically it might be ok if we commit the total validation cost (sigop + hashop + whatever) as the first witness stack item, but that?d take more space and I?m not sure if it is desirable. Anyway, giving up static analysability for scripts is a fundamental change to our existing model.

> 
> Additionally, it is possible that we take this time to re-evaluate
> whether we should be counting SigOps other than for legacy consensus
> rule compliance. The speed of verification in secp256k1 has made
> signature operations no longer the chief concern in block validation
> times.

Without the limit I think we would be DoS-ed to dead


>> Witness script versioning is by design fully compatible with P2SH
>> and BIP173, so there will be no hurdle for existing wallets to pay
>> to BIP114. Actually it should be completely transparent to them.
> 
> This is correct. Your feedback will be incorporated.
> 
>> For code complexity, the minimal BIP114 could be really simple, like
>> <30 lines of code? It looks complex now because it does much more
>> than simply hiding scripts in a hash.
> 
> Is there a repo that contains the latest implementation of BIP 114,
> for comparison purposes?


You can find it here: https://github.com/jl2012/bitcoin/commits/vault
https://github.com/jl2012/bitcoin/commit/f3f201d232d3995db38e09b171e4d1dea8d04ad2

But this does more than your proposal as it allows users adding extra scripts when spending a coin. The rationale is described in the revised BIP114:
https://github.com/jl2012/bips/blob/vault/bip-0114.mediawiki#Additional_scripts_in_witness

So to make it functionally comparable with your proposal, the IsMSV0Stack() function is not needed. The new 249-254 lines in interpreter.cpp could be removed. The new 1480-1519 lines could be replaced by a few lines copied from the existing P2WSH code. I can make a minimal version if you want to see how it looks like


> 
> Kind regards,
> Mark Friedenbach
> 



From thomasv at electrum.org  Tue Sep 12 09:06:15 2017
From: thomasv at electrum.org (Thomas Voegtlin)
Date: Tue, 12 Sep 2017 11:06:15 +0200
Subject: [bitcoin-dev] Proposal: Extended serialization format for BIP-32
In-Reply-To: <CABuOfuhN6jXgd+KTjFLjM+YkDOVg9=G3tWpeKBJvpUAkpkzjDg@mail.gmail.com>
References: <CABuOfuhN6jXgd+KTjFLjM+YkDOVg9=G3tWpeKBJvpUAkpkzjDg@mail.gmail.com>
Message-ID: <99643f72-f72f-e4e9-ac2b-72bf519c25b5@electrum.org>



On 09.09.2017 16:08, shiva sitamraju via bitcoin-dev wrote:
> Hi,
> 
> I understand the motivation of adding the birthdate field. However, not
> very comfortable with having this in the public key serialization. There
> are privacy implication of both the birthday field and having the complete
> derivation path, which takes space.
> > I am fine with Thomas proposal of {x,y,z}. Having additional version byte
> field looks modular but since since we already have the big enough version
> field in bip32, better to use that instead of adding more bytes.
> 
> Thomas, can you please explain why we require different version for P2WPKH
> or P2WSH versus (P2WPKH or P2WSH) nested in P2SH. It looked to me that they
> would have the same output bitcoin address and under same account.

no, native scripts do not have the same address. see bip173


> 
> On Fri, Sep 8, 2017 at 2:09 AM, <
> bitcoin-dev-request at lists.linuxfoundation.org> wrote:
> 
>> Send bitcoin-dev mailing list submissions to
>>         bitcoin-dev at lists.linuxfoundation.org
>>
>> To subscribe or unsubscribe via the World Wide Web, visit
>>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> or, via email, send a message with subject or body 'help' to
>>         bitcoin-dev-request at lists.linuxfoundation.org
>>
>> You can reach the person managing the list at
>>         bitcoin-dev-owner at lists.linuxfoundation.org
>>
>> When replying, please edit your Subject line so it is more specific
>> than "Re: Contents of bitcoin-dev digest..."
>>
>>
>> Today's Topics:
>>
>>    1. Re: Proposal: Extended serialization format for   BIP-32
>>       wallets (Andreas Schildbach)
>>    2. Re: Proposal: Extended serialization format for BIP-32
>>       wallets (Pavol Rusnak)
>>    3. Re: Fast Merkle Trees (Mark Friedenbach)
>>    4. Re: Proposal: Extended serialization format for BIP-32
>>       wallets (Thomas Voegtlin)
>>
>>
>> ----------------------------------------------------------------------
>>
>> Message: 1
>> Date: Thu, 7 Sep 2017 21:35:49 +0200
>> From: Andreas Schildbach <andreas at schildbach.de>
>> To: bitcoin-dev at lists.linuxfoundation.org
>> Subject: Re: [bitcoin-dev] Proposal: Extended serialization format for
>>         BIP-32 wallets
>> Message-ID: <oos72e$rjp$1 at blaine.gmane.org>
>> Content-Type: text/plain; charset=utf-8
>>
>> On 09/07/2017 06:23 PM, Pavol Rusnak via bitcoin-dev wrote:
>>> On 07/09/17 06:29, Thomas Voegtlin via bitcoin-dev wrote:
>>>> A solution is still needed to wallets who do not wish to use BIP43
>>>
>>> What if we added another byte field OutputType for wallets that do not
>>> follow BIP43?
>>>
>>> 0x00 - P2PKH output type
>>> 0x01 - P2WPKH-in-P2SH output type
>>> 0x02 - native Segwit output type
>>>
>>> Would that work for you?
>>
>> I think that would work.
>>
>>> The question is whether this field should be present only if depth==0x00
>>> or at all times. What is your suggestion, Thomas?
>>
>> In case of Bitcoin Wallet, the depth is not null (m/0'/[0,1]) and still
>> we need this field. I think it should always be present if a chain is
>> limited to a certain script type.
>>
>> There is however the case where even on one chain, script types are
>> mixed. In this case the field should be omitted and the wallet needs to
>> scan for all (known) types. Afaik Bitcoin Core is taking this path.
>>
>>
>>
>> ------------------------------
>>
>> Message: 2
>> Date: Thu, 7 Sep 2017 22:00:05 +0200
>> From: Pavol Rusnak <stick at satoshilabs.com>
>> To: Andreas Schildbach <andreas at schildbach.de>, Bitcoin Protocol
>>         Discussion <bitcoin-dev at lists.linuxfoundation.org>
>> Subject: Re: [bitcoin-dev] Proposal: Extended serialization format for
>>         BIP-32 wallets
>> Message-ID: <40ed03a1-915c-33b0-c4ac-e898c8c733ba at satoshilabs.com>
>> Content-Type: text/plain; charset=windows-1252
>>
>> On 07/09/17 21:35, Andreas Schildbach via bitcoin-dev wrote:
>>> In case of Bitcoin Wallet, the depth is not null (m/0'/[0,1]) and still
>>> we need this field.
>>
>> But the depth of exported public key will be null. It does not make
>> sense to export xpub for m or m/0' for your particular case.
>>
>>> I think it should always be present if a chain is
>>> limited to a certain script type.
>>
>> I am fine with having the path there all the time.
>>
>>> There is however the case where even on one chain, script types are
>>> mixed. In this case the field should be omitted and the wallet needs to
>>> scan for all (known) types. Afaik Bitcoin Core is taking this path.
>>
>> Is that really the case? Why come up with a hierarchy and then don't use
>> it?
>>
>> --
>> Best Regards / S pozdravom,
>>
>> Pavol "stick" Rusnak
>> CTO, SatoshiLabs
>>
>>
>> ------------------------------
>>
>> Message: 3
>> Date: Thu, 7 Sep 2017 13:04:30 -0700
>> From: Mark Friedenbach <mark at friedenbach.org>
>> To: Russell O'Connor <roconnor at blockstream.io>
>> Cc: Bitcoin Protocol Discussion
>>         <bitcoin-dev at lists.linuxfoundation.org>
>> Subject: Re: [bitcoin-dev] Fast Merkle Trees
>> Message-ID: <40D6F502-3380-4B64-BCD9-80D361EED35C at friedenbach.org>
>> Content-Type: text/plain; charset="us-ascii"
>>
>> TL;DR I'll be updating the fast Merkle-tree spec to use a different
>>       IV, using (for infrastructure compatability reasons) the scheme
>>       provided by Peter Todd.
>>
>> This is a specific instance of a general problem where you cannot
>> trust scripts given to you by another party. Notice that we run into
>> the same sort of problem when doing key aggregation, in which you must
>> require the other party to prove knowledge of the discrete log before
>> using their public key, or else key cancellation can occur.
>>
>> With script it is a little bit more complicated as you might want
>> zero-knowledge proofs of hash pre-images for HTLCs as well as proofs
>> of DL knowledge (signatures), but the basic idea is the same. Multi-
>> party wallet level protocols for jointly constructing scriptPubKeys
>> should require a 'delinearization' step that proves knowledge of
>> information necessary to complete each part of the script, as part of
>> proving the safety of a construct.
>>
>> I think my hangup before in understanding the attack you describe was
>> in actualizing it into a practical attack that actually escalates the
>> attacker's capabilities. If the attacker can get you to agree to a
>> MAST policy that is nothing more than a CHECKSIG over a key they
>> presumably control, then they don't need to do any complicated
>> grinding. The attacker in that scenario would just actually specify a
>> key they control and take the funds that way.
>>
>> Where this presumably leads to an actual exploit is when you specify a
>> script that a curious counter-party actually takes the time to
>> investigate and believes to be secure. For example, a script that
>> requires a signature or pre-image revelation from that counter-party.
>> That would require grinding not a few bytes, but at minimum 20-33
>> bytes for either a HASH160 image or the counter-party's key.
>>
>> If I understand the revised attack description correctly, then there
>> is a small window in which the attacker can create a script less than
>> 55 bytes in length, where nearly all of the first 32 bytes are
>> selected by the attacker, yet nevertheless the script seems safe to
>> the counter-party. The smallest such script I was able to construct
>> was the following:
>>
>>     <fake-pubkey> CHECKSIGVERIFY HASH160 <preimage> EQUAL
>>
>> This is 56 bytes and requires only 7 bits of grinding in the fake
>> pubkey. But 56 bytes is too large. Switching to secp256k1 serialized
>> 32-byte pubkeys (in a script version upgrade, for example) would
>> reduce this to the necessary 55 bytes with 0 bits of grinding. A
>> smaller variant is possible:
>>
>>     DUP HASH160 <fake-pubkey-hash> EQUALVERIFY CHECKSIGVERIFY HASH160
>> <preimage> EQUAL
>>
>> This is 46 bytes, but requires grinding 96 bits, which is a bit less
>> plausible.
>>
>> Belts and suspenders are not so terrible together, however, and I
>> think there is enough of a justification here to look into modifying
>> the scheme to use a different IV for hash tree updates. This would
>> prevent even the above implausible attacks.
>>
>>
>>> On Sep 7, 2017, at 11:55 AM, Russell O'Connor <roconnor at blockstream.io>
>> wrote:
>>>
>>>
>>>
>>> On Thu, Sep 7, 2017 at 1:42 PM, Mark Friedenbach <mark at friedenbach.org
>> <mailto:mark at friedenbach.org>> wrote:
>>> I've been puzzling over your email since receiving it. I'm not sure it
>>> is possible to perform the attack you describe with the tree structure
>>> specified in the BIP. If I may rephrase your attack, I believe you are
>>> seeking a solution to the following:
>>>
>>> Want: An innocuous script and a malign script for which
>>>
>>>    double-SHA256(innocuous)
>>>
>>> is equal to either
>>>
>>>    fast-SHA256(double-SHA256(malign) || r) or
>>>    fast-SHA256(r || double-SHA256(malign))
>>>
>>> or  fast-SHA256(fast-SHA256(double-SHA256(malign) || r1) || r0)
>>> or  fast-SHA256(fast-SHA256(r1 || double-SHA256(malign)) || r0)
>>> or ...
>>>
>>> where r is a freely chosen 32-byte nonce. This would allow the
>>> attacker to reveal the innocuous script before funds are sent to the
>>> MAST, then use the malign script to spend.
>>>
>>> Because of the double-SHA256 construction I do not see how this can be
>>> accomplished without a full break of SHA256.
>>>
>>> The particular scenario I'm imagining is a collision between
>>>
>>>     double-SHA256(innocuous)
>>>
>>> and
>>>
>>>     fast-SHA256(fast-SHA256(fast-SHA256(double-SHA256(malign) || r2) ||
>> r1) || r0).
>>>
>>> where innocuous is a Bitcoin Script that is between 32 and 55 bytes long.
>>>
>>> Observe that when data is less than 55 bytes then double-SHA256(data) =
>> fast-SHA256(fast-SHA256(padding-SHA256(data)) || 0x8000...100) (which is
>> really the crux of the matter).
>>>
>>> Therefore, to get our collision it suffices to find a collision between
>>>
>>>     padding-SHA256(innocuous)
>>>
>>> and
>>>
>>>     fast-SHA256(double-SHA256(malign) || r2) || r1
>>>
>>> r1 can freely be set to the second half of padding-SHA256(innocuous), so
>> it suffices to find a collision between
>>>
>>>    fast-SHA256(double-SHA256(malign) || r2)
>>>
>>> and the first half of padding-SHA256(innocuous) which is equal to the
>> first 32 bytes of innocuous.
>>>
>>> Imagine the first opcode of innocuous is the push of a value that the
>> attacker claims to be his 33-byte public key.
>>> So long as the attacker doesn't need to prove that they know the
>> discrete log of this pubkey, they can grind r2 until the result of
>> fast-SHA256(double-SHA256(malign) || r2) contains the correct first
>> couple of bytes for the script header and the opcode for a 33-byte push.  I
>> believe that is only about 3 or 4 bytes of they need to grind out.
>>>
>>
>> -------------- next part --------------
>> An HTML attachment was scrubbed...
>> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/
>> attachments/20170907/63af0292/attachment-0001.html>
>>
>> ------------------------------
>>
>> Message: 4
>> Date: Thu, 7 Sep 2017 22:39:17 +0200
>> From: Thomas Voegtlin <thomasv at electrum.org>
>> To: "bitcoin-dev at lists.linuxfoundation.org"
>>         <bitcoin-dev at lists.linuxfoundation.org>
>> Subject: Re: [bitcoin-dev] Proposal: Extended serialization format for
>>         BIP-32 wallets
>> Message-ID: <9e74dc17-105c-b43c-7780-4fa690043fe2 at electrum.org>
>> Content-Type: text/plain; charset=windows-1252
>>
>>
>>
>> On 07.09.2017 18:23, Pavol Rusnak wrote:
>>> On 07/09/17 06:29, Thomas Voegtlin via bitcoin-dev wrote:
>>>> A solution is still needed to wallets who do not wish to use BIP43
>>>
>>> What if we added another byte field OutputType for wallets that do not
>>> follow BIP43?
>>>
>>> 0x00 - P2PKH output type
>>> 0x01 - P2WPKH-in-P2SH output type
>>> 0x02 - native Segwit output type
>>>
>>> Would that work for you?
>>>
>>> The question is whether this field should be present only if depth==0x00
>>> or at all times. What is your suggestion, Thomas?
>>>
>>
>>
>> well, in my initial proposal, I wrote that this value should be user
>> visible. That is why I used version bytes. If you create an extra byte
>> field, and then use base58 or bech32 encoding, the value will not be
>> user visible anymore.
>>
>> The initial implementation of segwit xpub/xprv in Electrum used a flag
>> that was not user visible (I added 1 to the bip32 version bytes, which
>> leaves the xpub/xprv prefix unchanged). I have experimented with that
>> invisible flag for more than 6 months now, and I am now convinced that
>> it is better to make that flag user visible.
>>
>> The reason is that when users create wallets with multisig scripts, they
>> need to combine several master public keys. However, these master public
>> keys should all be of the same type: it would not make sense to create a
>> 2 of 3 multisig wallet with a one xpub, one ypub and one zpub. By
>> imposing that all master keys are of the same type, we ensure that all
>> cosigners agree on the script type that will be used to derive addresses.
>>
>> In other words, if users are exposed to master keys and need to
>> manipulate them, it is better to let them see what they are doing.
>>
>> OTOH if you do not plan to expose your users to these keys, you probably
>> do not need a serialization format.
>>
>>
>> ------------------------------
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>> End of bitcoin-dev Digest, Vol 28, Issue 17
>> *******************************************
>>
> 
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

-- 
Electrum Technologies GmbH / Waldemarstr 37a / 10999 Berlin / Germany
Sitz, Registergericht: Berlin, Amtsgericht Charlottenburg, HRB 164636
Gesch?ftsf?hrer: Thomas Voegtlin

From sergio.d.lerner at gmail.com  Tue Sep 12 04:49:34 2017
From: sergio.d.lerner at gmail.com (Sergio Demian Lerner)
Date: Tue, 12 Sep 2017 01:49:34 -0300
Subject: [bitcoin-dev] Responsible disclosure of bugs
In-Reply-To: <20170912033703.GD19080@erisian.com.au>
References: <3e4541f3-f65c-5199-5e85-9a65ea5142e7@bitcartel.com>
	<cb968a34-f8d2-ab61-dd15-9bd282afd18c@mattcorallo.com>
	<20170911021506.GA19080@erisian.com.au>
	<CAPWm=eVCh2FYp=SpOcZFLqz1ZCq3=Z_F9Sj+EAXFvqU-8aMuTg@mail.gmail.com>
	<20170912033703.GD19080@erisian.com.au>
Message-ID: <CAKzdR-oYQ8EchpJVE56yJbfBgNHihx7WO_gtFtp6QKOcK7uT-w@mail.gmail.com>

Historically people have published vulnerabilities in Bitcoin only after
>80% of the nodes have upgraded. This seems to be the general (but not
publicly stated) policy. If you're a core developer and you know better,
please correct me.

This means that:

- a critical vulnerability, like a remote code execution, will be patched
immediately (without disclosing the actual problem) and all participants
will be notified asap. This is no different from any other open source
project. An example of this case was the OpenSSL Heartbleed vulnerability
that affected Bitcoin.

- a non-critical vulnerability, either because miners only can exploit it
or because it requires vast resources to pull, may require a wait of years
before publication, after a vulnerability was found and reported. This is
because the "natural" node upgrade rate is slow.

It also implies that some times a researcher works hard to investigate a
vulnerability and later he finds out it was previously reported. It also
means that the researcher cannot report to alt-coins which have a different
policy.

This policy has nothing to do with a loyalty to Bitcoin Core (or in fact,
the two or so developers that actually receive the e-mails to
security at bitcoincore.org).

This is a policy that has simply proven to work to protect Bitcoiners. It
began long long ago.



On Tue, Sep 12, 2017 at 12:37 AM, Anthony Towns via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Mon, Sep 11, 2017 at 07:34:33AM -0400, Alex Morcos wrote:
> > I don't think I know the right answer here, but I will point out two
> things
> > that make this a little more complicated.
> > 1 - There are lots of altcoin developers and while I'm sure the majority
> would
> > greatly appreciate the disclosure and would behave responsibly with the
> > information, I don't know where you draw the line on who you tell and
> who you
> > don't.
>
> If you can't pick even a small group that's trustworthy (top five by
> market cap as a start [0]? or just major bitcoin wallets / exchanges /
> alt node implementations?), then it still seems better to (eventually)
> disclose publically than keep it unrevealed and let it be a potential
> advantage for attackers against people who haven't upgraded for other
> reasons?
>
> I find it hard to imagine bitcoin's still obscure enough that people
> aren't tracking git commit logs to use them as inspiration for attacks
> on bitcoin users and businesses; at best I would have thought it'd
> only be a few months of development time between a fix being proposed
> as a PR or committed to master and black hats having the ability to
> exploit it in users who are running older nodes. (Or for that matter,
> being able to be exploited by otherwise legitimate bitcoin businesses
> with an agenda to push, a strong financial motive behind that agenda,
> and a legal team that says they'll get away with it)
>
> > 2- Unlike other software, I'm not sure good security for bitcoin is
> defined by
> > constant upgrading.  Obviously upgrading has an important benefit, but
> one of
> > the security considerations for Bitcoin is knowing that your definition
> of the
> > money hasn't changed.  Much harder to know that if you change software.
>
> Isn't that just an argument for putting more effort into backporting
> fixes/workarounds? (I don't see how you do that without essentially
> publically disclosing which patches have a security impact -- "oh,
> gosh, this patch gets a backport, I wonder if maybe it has security
> implications...")
>
> (In so far as bitcoin is a consensus system, there can sometimes be a
> positive network effect, where having other people upgrade can help your
> security, even if you don't upgrade; "herd immunity" if you will. That
> way a new release going out to other people helps keep you safe, even
> while you continue to maintain the same definition of money by not
> upgrading at all)
>
> If altcoin maintainers are inconvenienced by tracking bitcoin-core
> updates, that would be an argument for them to contribute back to their
> upstream to make their own job easier; either helping with backports,
> or perhaps contributing to patches like PR#8994 might help.
>
> All of those things seem like they'd help not just altcoins but bitcoin
> investors/traders too, so it's not even a trade-off between classes of
> bitcoin core users.  And if in the end various altcoins aren't able to
> keep up with security fixes, that's probably valuable information to
> provide to the market...
>
> Cheers,
> aj
>
> [0] Roughly: BCash, Litecoin, Dash, BitConnect, ZCash, Dogecoin?
>     I've no idea which of those might have trustworthy devs to work with,
>     but surely at least a couple do?
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170912/78a88c9e/attachment-0001.html>

From jl2012 at xbt.hk  Tue Sep 12 11:44:48 2017
From: jl2012 at xbt.hk (Johnson Lau)
Date: Tue, 12 Sep 2017 19:44:48 +0800
Subject: [bitcoin-dev] Fast Merkle Trees
In-Reply-To: <40D6F502-3380-4B64-BCD9-80D361EED35C@friedenbach.org>
References: <CAMZUoKmD4v4vn9L=kdyJNk-km3XHpNVkD_tmS+SseMsf6YaVPg@mail.gmail.com>
	<F1D041D0-FC5A-425C-835D-37E7A9C0CFC5@friedenbach.org>
	<CAMZUoKmhN=m4TFwJi7u1bibLJ6mYvpnkddWTZZWdHn7+mVcJvw@mail.gmail.com>
	<EB804508-715A-4CD6-9B87-09845368DAC0@friedenbach.org>
	<CAMZUoKk7dHy6urnGRzAB2UG_fkwXmQrRHDfFYOHa0sTStr=yAQ@mail.gmail.com>
	<40D6F502-3380-4B64-BCD9-80D361EED35C@friedenbach.org>
Message-ID: <14F84E09-5B25-4604-B210-A5CC2271C78C@xbt.hk>


> On 8 Sep 2017, at 4:04 AM, Mark Friedenbach via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> If I understand the revised attack description correctly, then there
> is a small window in which the attacker can create a script less than
> 55 bytes in length, where nearly all of the first 32 bytes are
> selected by the attacker, yet nevertheless the script seems safe to
> the counter-party. The smallest such script I was able to construct
> was the following:
> 
>     <fake-pubkey> CHECKSIGVERIFY HASH160 <preimage> EQUAL
> 
> This is 56 bytes and requires only 7 bits of grinding in the fake
> pubkey. But 56 bytes is too large. Switching to secp256k1 serialized
> 32-byte pubkeys (in a script version upgrade, for example) would
> reduce this to the necessary 55 bytes with 0 bits of grinding. A
> smaller variant is possible:
> 
>     DUP HASH160 <fake-pubkey-hash> EQUALVERIFY CHECKSIGVERIFY HASH160 <preimage> EQUAL
> 
> This is 46 bytes, but requires grinding 96 bits, which is a bit less
> plausible.
> 
> Belts and suspenders are not so terrible together, however, and I
> think there is enough of a justification here to look into modifying
> the scheme to use a different IV for hash tree updates. This would
> prevent even the above implausible attacks.
> 

I think you overestimated the difficulty. Consider this MAST branch (an example in BIP114)

"Timestamp" CHECKLOCKTIMEVERIFY <fake-pubkey> CHECKSIGVERIFY

This requires just a few bytes of collision.





From shiva at blockonomics.co  Tue Sep 12 12:06:40 2017
From: shiva at blockonomics.co (shiva sitamraju)
Date: Tue, 12 Sep 2017 17:36:40 +0530
Subject: [bitcoin-dev] Proposal: Extended serialization format for BIP-32
Message-ID: <CABuOfugNbyF-O0p42ghHm546XvV3FcMscb-pb4MeQA_akNHipw@mail.gmail.com>

Thanks Thomas for pointing me to bip173. If everyone is fine, we should go
forward with formalizing Thomas' proposal asap. Already segwit wallet
usage/demand is increasing !

On Tue, Sep 12, 2017 at 4:54 PM, <
bitcoin-dev-request at lists.linuxfoundation.org> wrote:

> Send bitcoin-dev mailing list submissions to
>         bitcoin-dev at lists.linuxfoundation.org
>
> To subscribe or unsubscribe via the World Wide Web, visit
>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> or, via email, send a message with subject or body 'help' to
>         bitcoin-dev-request at lists.linuxfoundation.org
>
> You can reach the person managing the list at
>         bitcoin-dev-owner at lists.linuxfoundation.org
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of bitcoin-dev digest..."
>
>
> Today's Topics:
>
>    1. Re: Merkle branch verification & tail-call semantics for
>       generalized MAST (Johnson Lau)
>    2. Re: Proposal: Extended serialization format for BIP-32
>       (Thomas Voegtlin)
>    3. Re: Responsible disclosure of bugs (Sergio Demian Lerner)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Tue, 12 Sep 2017 16:55:59 +0800
> From: Johnson Lau <jl2012 at xbt.hk>
> To: Mark Friedenbach <mark at friedenbach.org>
> Cc: bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] Merkle branch verification & tail-call
>         semantics for generalized MAST
> Message-ID: <DA22C531-2FAE-4332-B158-A3F96BF34002 at xbt.hk>
> Content-Type: text/plain; charset=utf-8
>
>
> > On 12 Sep 2017, at 10:03 AM, Mark Friedenbach <mark at friedenbach.org>
> wrote:
> >
> > My apologies for a delay in responding to emails on this list; I have
> > been fighting a cold.
> >
> > (Also my apologies to Johnson Lau, as I forgot to forward this to the
> list.)
> >
> > On Sep 8, 2017, at 2:21 AM, Johnson Lau <jl2012 at xbt.hk> wrote:
> >
> >> Tail-call execution semantics require "unclean stake" , i.e. final
> >> stake with more than one item. However, "unclean stake" is invalid
> >> (not just non-standard) in BIP141, so you could only use it with
> >> legacy P2SH (which is totally pointless....). A different design
> >> like OP_EVAL might be needed, or you need a new witness script
> >> version.
> >
> > I believe you meant "unclean stack," and you are correct. This was
> > also pointed out last tuesday by a participant at the in-person
> > CoreDev meetup where the idea was presented.
> >
> > This doesn't kill the idea, it just complicates the implementation
> > slightly. A simple fix would be to allow tail-recursion to occur if
> > the stack is not clean (as can happen with legacy P2SH as you point
> > out, or yet to be defined version 1+ forms of segwit script), OR if
> > there is a single item on the stack and the alt-stack is not empty.
> > For segwit v0 scripts you then have to move any arguments to the alt
> > stack before ending the redeem script, leaving just the policy script
> > on the main stack.
>
> This is ugly and actually broken, as different script path may require
> different number of stack items, so you don?t know how many OP_TOALTSTACK
> do you need. Easier to just use a new witness version
>
> >
> >> I think you have also missed the sigOp counting of the executed
> >> script. As you can't count it without executing the script, the
> >> current static analysability is lost. This was one of the reasons
> >> for OP_EVAL being rejected. Since sigOp is a per-block limit, any
> >> OP_EVAL-like operation means block validity will depend on the
> >> precise outcome of script execution (instead of just pass or fail),
> >> which is a layer violation.
> >
> > I disagree with this design requirement.
> >
> > The SigOp counting method used by bitcoin is flawed. It incorrectly
> > limits not the number of signature operations necessary to validate a
> > block, but rather the number of CHECKSIGs potentially encountered in
> > script execution, even if in an unexecuted branch. (Admitedly MAST
> > makes this less of an issue, but there are still useful compact
> > scripts that use if/else constructs to elide a CHECKSIG.) Nor will it
> > account for aggregation when that feature is added, or properly
> > differentiate between signature operations that can be batched and
> > those that can not.
> >
> > Additionally there are other resources used by script that should be
> > globally limited, such as hash operations, which are not accounted for
> > at this time and cannot be statically assessed, even by the flawed
> > mechanism by which SigOps are counted. I have maintained for some time
> > that bitcoin should move from having multiple separate global limits
> > (weight and sigops, hashed bytes in XT/Classic/BCH) to a single linear
> > metric that combines all of these factors with appropriate
> > coefficients.
> >
>
> I like the idea to have an unified global limit and suggested a way to do
> it (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-January/
> 013472.html). But I think this is off-topic here.
>
>
>
> > A better way of handling this problem, which works for both SigOps and
> > HashOps, is to have the witness commit to the maximum resources
> > consumed by validation of the spend of the coin, to relay this data
> > with the transaction and include it in the SigHash, and to use the
> > committed maximum for block validation. This could be added in a
> > future script version upgrade. This change would also resolve the
> > issue that led to the clean stack rule in segwit, allowing future
> > versions of script to use tail-call recursion without involving the
> > alt-stack.
> >
> > Nevertheless it is constructive feedback that the current draft of the
> > BIP and its implementation do not count SigOps, at all. There are a
> > couple of ways this can be fixed by evaluating the top-level script
> > and then doing static analysis of the resulting policy script, or by
> > running the script and counting operations actually performed.
>
>
> In any case, I think maintaining static analysability for global limit(s)
> is very important. Ethereum had to give up their DAO softfork plan at the
> last minute, exactly due to the lack of this:
> http://hackingdistributed.com/2016/06/28/ethereum-soft-fork-dos-vector/
>
> Otherwise, one could attack relay and mining nodes by sending many small
> size txs with many sigops, forcing them to validate, and discard due to
> insufficient fees.
>
> Technically it might be ok if we commit the total validation cost (sigop +
> hashop + whatever) as the first witness stack item, but that?d take more
> space and I?m not sure if it is desirable. Anyway, giving up static
> analysability for scripts is a fundamental change to our existing model.
>
> >
> > Additionally, it is possible that we take this time to re-evaluate
> > whether we should be counting SigOps other than for legacy consensus
> > rule compliance. The speed of verification in secp256k1 has made
> > signature operations no longer the chief concern in block validation
> > times.
>
> Without the limit I think we would be DoS-ed to dead
>
>
> >> Witness script versioning is by design fully compatible with P2SH
> >> and BIP173, so there will be no hurdle for existing wallets to pay
> >> to BIP114. Actually it should be completely transparent to them.
> >
> > This is correct. Your feedback will be incorporated.
> >
> >> For code complexity, the minimal BIP114 could be really simple, like
> >> <30 lines of code? It looks complex now because it does much more
> >> than simply hiding scripts in a hash.
> >
> > Is there a repo that contains the latest implementation of BIP 114,
> > for comparison purposes?
>
>
> You can find it here: https://github.com/jl2012/bitcoin/commits/vault
> https://github.com/jl2012/bitcoin/commit/f3f201d232d3995db38e09b171e4d1
> dea8d04ad2
>
> But this does more than your proposal as it allows users adding extra
> scripts when spending a coin. The rationale is described in the revised
> BIP114:
> https://github.com/jl2012/bips/blob/vault/bip-0114.
> mediawiki#Additional_scripts_in_witness
>
> So to make it functionally comparable with your proposal, the
> IsMSV0Stack() function is not needed. The new 249-254 lines in
> interpreter.cpp could be removed. The new 1480-1519 lines could be replaced
> by a few lines copied from the existing P2WSH code. I can make a minimal
> version if you want to see how it looks like
>
>
> >
> > Kind regards,
> > Mark Friedenbach
> >
>
>
>
>
> ------------------------------
>
> Message: 2
> Date: Tue, 12 Sep 2017 11:06:15 +0200
> From: Thomas Voegtlin <thomasv at electrum.org>
> To: bitcoin-dev at lists.linuxfoundation.org
> Subject: Re: [bitcoin-dev] Proposal: Extended serialization format for
>         BIP-32
> Message-ID: <99643f72-f72f-e4e9-ac2b-72bf519c25b5 at electrum.org>
> Content-Type: text/plain; charset=utf-8
>
>
>
> On 09.09.2017 16:08, shiva sitamraju via bitcoin-dev wrote:
> > Hi,
> >
> > I understand the motivation of adding the birthdate field. However, not
> > very comfortable with having this in the public key serialization. There
> > are privacy implication of both the birthday field and having the
> complete
> > derivation path, which takes space.
> > > I am fine with Thomas proposal of {x,y,z}. Having additional version
> byte
> > field looks modular but since since we already have the big enough
> version
> > field in bip32, better to use that instead of adding more bytes.
> >
> > Thomas, can you please explain why we require different version for
> P2WPKH
> > or P2WSH versus (P2WPKH or P2WSH) nested in P2SH. It looked to me that
> they
> > would have the same output bitcoin address and under same account.
>
> no, native scripts do not have the same address. see bip173
>
>
> >
> > On Fri, Sep 8, 2017 at 2:09 AM, <
> > bitcoin-dev-request at lists.linuxfoundation.org> wrote:
> >
> >> Send bitcoin-dev mailing list submissions to
> >>         bitcoin-dev at lists.linuxfoundation.org
> >>
> >> To subscribe or unsubscribe via the World Wide Web, visit
> >>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >> or, via email, send a message with subject or body 'help' to
> >>         bitcoin-dev-request at lists.linuxfoundation.org
> >>
> >> You can reach the person managing the list at
> >>         bitcoin-dev-owner at lists.linuxfoundation.org
> >>
> >> When replying, please edit your Subject line so it is more specific
> >> than "Re: Contents of bitcoin-dev digest..."
> >>
> >>
> >> Today's Topics:
> >>
> >>    1. Re: Proposal: Extended serialization format for   BIP-32
> >>       wallets (Andreas Schildbach)
> >>    2. Re: Proposal: Extended serialization format for BIP-32
> >>       wallets (Pavol Rusnak)
> >>    3. Re: Fast Merkle Trees (Mark Friedenbach)
> >>    4. Re: Proposal: Extended serialization format for BIP-32
> >>       wallets (Thomas Voegtlin)
> >>
> >>
> >> ----------------------------------------------------------------------
> >>
> >> Message: 1
> >> Date: Thu, 7 Sep 2017 21:35:49 +0200
> >> From: Andreas Schildbach <andreas at schildbach.de>
> >> To: bitcoin-dev at lists.linuxfoundation.org
> >> Subject: Re: [bitcoin-dev] Proposal: Extended serialization format for
> >>         BIP-32 wallets
> >> Message-ID: <oos72e$rjp$1 at blaine.gmane.org>
> >> Content-Type: text/plain; charset=utf-8
> >>
> >> On 09/07/2017 06:23 PM, Pavol Rusnak via bitcoin-dev wrote:
> >>> On 07/09/17 06:29, Thomas Voegtlin via bitcoin-dev wrote:
> >>>> A solution is still needed to wallets who do not wish to use BIP43
> >>>
> >>> What if we added another byte field OutputType for wallets that do not
> >>> follow BIP43?
> >>>
> >>> 0x00 - P2PKH output type
> >>> 0x01 - P2WPKH-in-P2SH output type
> >>> 0x02 - native Segwit output type
> >>>
> >>> Would that work for you?
> >>
> >> I think that would work.
> >>
> >>> The question is whether this field should be present only if
> depth==0x00
> >>> or at all times. What is your suggestion, Thomas?
> >>
> >> In case of Bitcoin Wallet, the depth is not null (m/0'/[0,1]) and still
> >> we need this field. I think it should always be present if a chain is
> >> limited to a certain script type.
> >>
> >> There is however the case where even on one chain, script types are
> >> mixed. In this case the field should be omitted and the wallet needs to
> >> scan for all (known) types. Afaik Bitcoin Core is taking this path.
> >>
> >>
> >>
> >> ------------------------------
> >>
> >> Message: 2
> >> Date: Thu, 7 Sep 2017 22:00:05 +0200
> >> From: Pavol Rusnak <stick at satoshilabs.com>
> >> To: Andreas Schildbach <andreas at schildbach.de>, Bitcoin Protocol
> >>         Discussion <bitcoin-dev at lists.linuxfoundation.org>
> >> Subject: Re: [bitcoin-dev] Proposal: Extended serialization format for
> >>         BIP-32 wallets
> >> Message-ID: <40ed03a1-915c-33b0-c4ac-e898c8c733ba at satoshilabs.com>
> >> Content-Type: text/plain; charset=windows-1252
> >>
> >> On 07/09/17 21:35, Andreas Schildbach via bitcoin-dev wrote:
> >>> In case of Bitcoin Wallet, the depth is not null (m/0'/[0,1]) and still
> >>> we need this field.
> >>
> >> But the depth of exported public key will be null. It does not make
> >> sense to export xpub for m or m/0' for your particular case.
> >>
> >>> I think it should always be present if a chain is
> >>> limited to a certain script type.
> >>
> >> I am fine with having the path there all the time.
> >>
> >>> There is however the case where even on one chain, script types are
> >>> mixed. In this case the field should be omitted and the wallet needs to
> >>> scan for all (known) types. Afaik Bitcoin Core is taking this path.
> >>
> >> Is that really the case? Why come up with a hierarchy and then don't use
> >> it?
> >>
> >> --
> >> Best Regards / S pozdravom,
> >>
> >> Pavol "stick" Rusnak
> >> CTO, SatoshiLabs
> >>
> >>
> >> ------------------------------
> >>
> >> Message: 3
> >> Date: Thu, 7 Sep 2017 13:04:30 -0700
> >> From: Mark Friedenbach <mark at friedenbach.org>
> >> To: Russell O'Connor <roconnor at blockstream.io>
> >> Cc: Bitcoin Protocol Discussion
> >>         <bitcoin-dev at lists.linuxfoundation.org>
> >> Subject: Re: [bitcoin-dev] Fast Merkle Trees
> >> Message-ID: <40D6F502-3380-4B64-BCD9-80D361EED35C at friedenbach.org>
> >> Content-Type: text/plain; charset="us-ascii"
> >>
> >> TL;DR I'll be updating the fast Merkle-tree spec to use a different
> >>       IV, using (for infrastructure compatability reasons) the scheme
> >>       provided by Peter Todd.
> >>
> >> This is a specific instance of a general problem where you cannot
> >> trust scripts given to you by another party. Notice that we run into
> >> the same sort of problem when doing key aggregation, in which you must
> >> require the other party to prove knowledge of the discrete log before
> >> using their public key, or else key cancellation can occur.
> >>
> >> With script it is a little bit more complicated as you might want
> >> zero-knowledge proofs of hash pre-images for HTLCs as well as proofs
> >> of DL knowledge (signatures), but the basic idea is the same. Multi-
> >> party wallet level protocols for jointly constructing scriptPubKeys
> >> should require a 'delinearization' step that proves knowledge of
> >> information necessary to complete each part of the script, as part of
> >> proving the safety of a construct.
> >>
> >> I think my hangup before in understanding the attack you describe was
> >> in actualizing it into a practical attack that actually escalates the
> >> attacker's capabilities. If the attacker can get you to agree to a
> >> MAST policy that is nothing more than a CHECKSIG over a key they
> >> presumably control, then they don't need to do any complicated
> >> grinding. The attacker in that scenario would just actually specify a
> >> key they control and take the funds that way.
> >>
> >> Where this presumably leads to an actual exploit is when you specify a
> >> script that a curious counter-party actually takes the time to
> >> investigate and believes to be secure. For example, a script that
> >> requires a signature or pre-image revelation from that counter-party.
> >> That would require grinding not a few bytes, but at minimum 20-33
> >> bytes for either a HASH160 image or the counter-party's key.
> >>
> >> If I understand the revised attack description correctly, then there
> >> is a small window in which the attacker can create a script less than
> >> 55 bytes in length, where nearly all of the first 32 bytes are
> >> selected by the attacker, yet nevertheless the script seems safe to
> >> the counter-party. The smallest such script I was able to construct
> >> was the following:
> >>
> >>     <fake-pubkey> CHECKSIGVERIFY HASH160 <preimage> EQUAL
> >>
> >> This is 56 bytes and requires only 7 bits of grinding in the fake
> >> pubkey. But 56 bytes is too large. Switching to secp256k1 serialized
> >> 32-byte pubkeys (in a script version upgrade, for example) would
> >> reduce this to the necessary 55 bytes with 0 bits of grinding. A
> >> smaller variant is possible:
> >>
> >>     DUP HASH160 <fake-pubkey-hash> EQUALVERIFY CHECKSIGVERIFY HASH160
> >> <preimage> EQUAL
> >>
> >> This is 46 bytes, but requires grinding 96 bits, which is a bit less
> >> plausible.
> >>
> >> Belts and suspenders are not so terrible together, however, and I
> >> think there is enough of a justification here to look into modifying
> >> the scheme to use a different IV for hash tree updates. This would
> >> prevent even the above implausible attacks.
> >>
> >>
> >>> On Sep 7, 2017, at 11:55 AM, Russell O'Connor <roconnor at blockstream.io
> >
> >> wrote:
> >>>
> >>>
> >>>
> >>> On Thu, Sep 7, 2017 at 1:42 PM, Mark Friedenbach <mark at friedenbach.org
> >> <mailto:mark at friedenbach.org>> wrote:
> >>> I've been puzzling over your email since receiving it. I'm not sure it
> >>> is possible to perform the attack you describe with the tree structure
> >>> specified in the BIP. If I may rephrase your attack, I believe you are
> >>> seeking a solution to the following:
> >>>
> >>> Want: An innocuous script and a malign script for which
> >>>
> >>>    double-SHA256(innocuous)
> >>>
> >>> is equal to either
> >>>
> >>>    fast-SHA256(double-SHA256(malign) || r) or
> >>>    fast-SHA256(r || double-SHA256(malign))
> >>>
> >>> or  fast-SHA256(fast-SHA256(double-SHA256(malign) || r1) || r0)
> >>> or  fast-SHA256(fast-SHA256(r1 || double-SHA256(malign)) || r0)
> >>> or ...
> >>>
> >>> where r is a freely chosen 32-byte nonce. This would allow the
> >>> attacker to reveal the innocuous script before funds are sent to the
> >>> MAST, then use the malign script to spend.
> >>>
> >>> Because of the double-SHA256 construction I do not see how this can be
> >>> accomplished without a full break of SHA256.
> >>>
> >>> The particular scenario I'm imagining is a collision between
> >>>
> >>>     double-SHA256(innocuous)
> >>>
> >>> and
> >>>
> >>>     fast-SHA256(fast-SHA256(fast-SHA256(double-SHA256(malign) || r2)
> ||
> >> r1) || r0).
> >>>
> >>> where innocuous is a Bitcoin Script that is between 32 and 55 bytes
> long.
> >>>
> >>> Observe that when data is less than 55 bytes then double-SHA256(data) =
> >> fast-SHA256(fast-SHA256(padding-SHA256(data)) || 0x8000...100) (which
> is
> >> really the crux of the matter).
> >>>
> >>> Therefore, to get our collision it suffices to find a collision between
> >>>
> >>>     padding-SHA256(innocuous)
> >>>
> >>> and
> >>>
> >>>     fast-SHA256(double-SHA256(malign) || r2) || r1
> >>>
> >>> r1 can freely be set to the second half of padding-SHA256(innocuous),
> so
> >> it suffices to find a collision between
> >>>
> >>>    fast-SHA256(double-SHA256(malign) || r2)
> >>>
> >>> and the first half of padding-SHA256(innocuous) which is equal to the
> >> first 32 bytes of innocuous.
> >>>
> >>> Imagine the first opcode of innocuous is the push of a value that the
> >> attacker claims to be his 33-byte public key.
> >>> So long as the attacker doesn't need to prove that they know the
> >> discrete log of this pubkey, they can grind r2 until the result of
> >> fast-SHA256(double-SHA256(malign) || r2) contains the correct first
> >> couple of bytes for the script header and the opcode for a 33-byte
> push.  I
> >> believe that is only about 3 or 4 bytes of they need to grind out.
> >>>
> >>
> >> -------------- next part --------------
> >> An HTML attachment was scrubbed...
> >> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> >> attachments/20170907/63af0292/attachment-0001.html>
> >>
> >> ------------------------------
> >>
> >> Message: 4
> >> Date: Thu, 7 Sep 2017 22:39:17 +0200
> >> From: Thomas Voegtlin <thomasv at electrum.org>
> >> To: "bitcoin-dev at lists.linuxfoundation.org"
> >>         <bitcoin-dev at lists.linuxfoundation.org>
> >> Subject: Re: [bitcoin-dev] Proposal: Extended serialization format for
> >>         BIP-32 wallets
> >> Message-ID: <9e74dc17-105c-b43c-7780-4fa690043fe2 at electrum.org>
> >> Content-Type: text/plain; charset=windows-1252
> >>
> >>
> >>
> >> On 07.09.2017 18:23, Pavol Rusnak wrote:
> >>> On 07/09/17 06:29, Thomas Voegtlin via bitcoin-dev wrote:
> >>>> A solution is still needed to wallets who do not wish to use BIP43
> >>>
> >>> What if we added another byte field OutputType for wallets that do not
> >>> follow BIP43?
> >>>
> >>> 0x00 - P2PKH output type
> >>> 0x01 - P2WPKH-in-P2SH output type
> >>> 0x02 - native Segwit output type
> >>>
> >>> Would that work for you?
> >>>
> >>> The question is whether this field should be present only if
> depth==0x00
> >>> or at all times. What is your suggestion, Thomas?
> >>>
> >>
> >>
> >> well, in my initial proposal, I wrote that this value should be user
> >> visible. That is why I used version bytes. If you create an extra byte
> >> field, and then use base58 or bech32 encoding, the value will not be
> >> user visible anymore.
> >>
> >> The initial implementation of segwit xpub/xprv in Electrum used a flag
> >> that was not user visible (I added 1 to the bip32 version bytes, which
> >> leaves the xpub/xprv prefix unchanged). I have experimented with that
> >> invisible flag for more than 6 months now, and I am now convinced that
> >> it is better to make that flag user visible.
> >>
> >> The reason is that when users create wallets with multisig scripts, they
> >> need to combine several master public keys. However, these master public
> >> keys should all be of the same type: it would not make sense to create a
> >> 2 of 3 multisig wallet with a one xpub, one ypub and one zpub. By
> >> imposing that all master keys are of the same type, we ensure that all
> >> cosigners agree on the script type that will be used to derive
> addresses.
> >>
> >> In other words, if users are exposed to master keys and need to
> >> manipulate them, it is better to let them see what they are doing.
> >>
> >> OTOH if you do not plan to expose your users to these keys, you probably
> >> do not need a serialization format.
> >>
> >>
> >> ------------------------------
> >>
> >> _______________________________________________
> >> bitcoin-dev mailing list
> >> bitcoin-dev at lists.linuxfoundation.org
> >> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >>
> >>
> >> End of bitcoin-dev Digest, Vol 28, Issue 17
> >> *******************************************
> >>
> >
> >
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
>
> --
> Electrum Technologies GmbH / Waldemarstr 37a / 10999 Berlin / Germany
> Sitz, Registergericht: Berlin, Amtsgericht Charlottenburg, HRB 164636
> Gesch?ftsf?hrer: Thomas Voegtlin
>
>
> ------------------------------
>
> Message: 3
> Date: Tue, 12 Sep 2017 01:49:34 -0300
> From: Sergio Demian Lerner <sergio.d.lerner at gmail.com>
> To: Anthony Towns <aj at erisian.com.au>,  Bitcoin Protocol Discussion
>         <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] Responsible disclosure of bugs
> Message-ID:
>         <CAKzdR-oYQ8EchpJVE56yJbfBgNHihx7WO_gtFtp6QKOcK7uT-w at mail.gmail.
> com>
> Content-Type: text/plain; charset="utf-8"
>
> Historically people have published vulnerabilities in Bitcoin only after
> >80% of the nodes have upgraded. This seems to be the general (but not
> publicly stated) policy. If you're a core developer and you know better,
> please correct me.
>
> This means that:
>
> - a critical vulnerability, like a remote code execution, will be patched
> immediately (without disclosing the actual problem) and all participants
> will be notified asap. This is no different from any other open source
> project. An example of this case was the OpenSSL Heartbleed vulnerability
> that affected Bitcoin.
>
> - a non-critical vulnerability, either because miners only can exploit it
> or because it requires vast resources to pull, may require a wait of years
> before publication, after a vulnerability was found and reported. This is
> because the "natural" node upgrade rate is slow.
>
> It also implies that some times a researcher works hard to investigate a
> vulnerability and later he finds out it was previously reported. It also
> means that the researcher cannot report to alt-coins which have a different
> policy.
>
> This policy has nothing to do with a loyalty to Bitcoin Core (or in fact,
> the two or so developers that actually receive the e-mails to
> security at bitcoincore.org).
>
> This is a policy that has simply proven to work to protect Bitcoiners. It
> began long long ago.
>
>
>
> On Tue, Sep 12, 2017 at 12:37 AM, Anthony Towns via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > On Mon, Sep 11, 2017 at 07:34:33AM -0400, Alex Morcos wrote:
> > > I don't think I know the right answer here, but I will point out two
> > things
> > > that make this a little more complicated.
> > > 1 - There are lots of altcoin developers and while I'm sure the
> majority
> > would
> > > greatly appreciate the disclosure and would behave responsibly with the
> > > information, I don't know where you draw the line on who you tell and
> > who you
> > > don't.
> >
> > If you can't pick even a small group that's trustworthy (top five by
> > market cap as a start [0]? or just major bitcoin wallets / exchanges /
> > alt node implementations?), then it still seems better to (eventually)
> > disclose publically than keep it unrevealed and let it be a potential
> > advantage for attackers against people who haven't upgraded for other
> > reasons?
> >
> > I find it hard to imagine bitcoin's still obscure enough that people
> > aren't tracking git commit logs to use them as inspiration for attacks
> > on bitcoin users and businesses; at best I would have thought it'd
> > only be a few months of development time between a fix being proposed
> > as a PR or committed to master and black hats having the ability to
> > exploit it in users who are running older nodes. (Or for that matter,
> > being able to be exploited by otherwise legitimate bitcoin businesses
> > with an agenda to push, a strong financial motive behind that agenda,
> > and a legal team that says they'll get away with it)
> >
> > > 2- Unlike other software, I'm not sure good security for bitcoin is
> > defined by
> > > constant upgrading.  Obviously upgrading has an important benefit, but
> > one of
> > > the security considerations for Bitcoin is knowing that your definition
> > of the
> > > money hasn't changed.  Much harder to know that if you change software.
> >
> > Isn't that just an argument for putting more effort into backporting
> > fixes/workarounds? (I don't see how you do that without essentially
> > publically disclosing which patches have a security impact -- "oh,
> > gosh, this patch gets a backport, I wonder if maybe it has security
> > implications...")
> >
> > (In so far as bitcoin is a consensus system, there can sometimes be a
> > positive network effect, where having other people upgrade can help your
> > security, even if you don't upgrade; "herd immunity" if you will. That
> > way a new release going out to other people helps keep you safe, even
> > while you continue to maintain the same definition of money by not
> > upgrading at all)
> >
> > If altcoin maintainers are inconvenienced by tracking bitcoin-core
> > updates, that would be an argument for them to contribute back to their
> > upstream to make their own job easier; either helping with backports,
> > or perhaps contributing to patches like PR#8994 might help.
> >
> > All of those things seem like they'd help not just altcoins but bitcoin
> > investors/traders too, so it's not even a trade-off between classes of
> > bitcoin core users.  And if in the end various altcoins aren't able to
> > keep up with security fixes, that's probably valuable information to
> > provide to the market...
> >
> > Cheers,
> > aj
> >
> > [0] Roughly: BCash, Litecoin, Dash, BitConnect, ZCash, Dogecoin?
> >     I've no idea which of those might have trustworthy devs to work with,
> >     but surely at least a couple do?
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> attachments/20170912/78a88c9e/attachment.html>
>
> ------------------------------
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> End of bitcoin-dev Digest, Vol 28, Issue 26
> *******************************************
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170912/39e7a072/attachment-0001.html>

From simon at bitcartel.com  Tue Sep 12 16:10:18 2017
From: simon at bitcartel.com (Simon Liu)
Date: Tue, 12 Sep 2017 09:10:18 -0700
Subject: [bitcoin-dev] Responsible disclosure of bugs
In-Reply-To: <CAKzdR-oYQ8EchpJVE56yJbfBgNHihx7WO_gtFtp6QKOcK7uT-w@mail.gmail.com>
References: <3e4541f3-f65c-5199-5e85-9a65ea5142e7@bitcartel.com>
	<cb968a34-f8d2-ab61-dd15-9bd282afd18c@mattcorallo.com>
	<20170911021506.GA19080@erisian.com.au>
	<CAPWm=eVCh2FYp=SpOcZFLqz1ZCq3=Z_F9Sj+EAXFvqU-8aMuTg@mail.gmail.com>
	<20170912033703.GD19080@erisian.com.au>
	<CAKzdR-oYQ8EchpJVE56yJbfBgNHihx7WO_gtFtp6QKOcK7uT-w@mail.gmail.com>
Message-ID: <e28e151a-1a67-4e90-f5fd-721cbc7f213d@bitcartel.com>

It would be a good starting point if the current policy could be
clarified, so everyone is on the same page, and there is no confusion.


On 09/11/2017 09:49 PM, Sergio Demian Lerner via bitcoin-dev wrote:
> Historically people have published vulnerabilities in Bitcoin only after
>>80% of the nodes have upgraded. This seems to be the general (but not
> publicly stated) policy. If you're a core developer and you know better,
> please correct me.
> 

From greg at xiph.org  Tue Sep 12 17:41:42 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Tue, 12 Sep 2017 17:41:42 +0000
Subject: [bitcoin-dev] Responsible disclosure of bugs
In-Reply-To: <20170912033703.GD19080@erisian.com.au>
References: <3e4541f3-f65c-5199-5e85-9a65ea5142e7@bitcartel.com>
	<cb968a34-f8d2-ab61-dd15-9bd282afd18c@mattcorallo.com>
	<20170911021506.GA19080@erisian.com.au>
	<CAPWm=eVCh2FYp=SpOcZFLqz1ZCq3=Z_F9Sj+EAXFvqU-8aMuTg@mail.gmail.com>
	<20170912033703.GD19080@erisian.com.au>
Message-ID: <CAAS2fgRNkM3cSF8YpE8u8Znh-0nMCNR2oD_tMpyC91yOuAZFNA@mail.gmail.com>

On Tue, Sep 12, 2017 at 3:37 AM, Anthony Towns via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> If you can't pick even a small group that's trustworthy

No.

> I find it hard to imagine bitcoin's still obscure enough that people
> aren't tracking git commit logs to use them as inspiration for attacks

For embargoed fixes we test the specific fixes against experienced
developers inside the project, handing them the proposed commit and
informing them that it fixes a vulnerability and asking them to
identify it.

This does not guarantee that the fix won't leak the issue, but in
virtually all cases in the past the issues we've dealt with would not
be made worse off being leaked in that way vs just making it public
outright.

If we had an issue that would be-- e.g. an RCE that could lead to
private key theft, we would likely handle it differently (e.g. making
a public notice to take sensitive systems offline before attempting
any fix).

>  I would have thought it'd
> only be a few months of development time between a fix being proposed
> as a PR or committed to master and black hats having the ability to
> exploit it in users who are running older nodes. (Or for that matter,
> being able to be exploited by otherwise legitimate bitcoin businesses
> with an agenda to push, a strong financial motive behind that agenda,
> and a legal team that says they'll get away with it)

History does not support your assumptions.

>> 2- Unlike other software, I'm not sure good security for bitcoin is defined by
>> constant upgrading.  Obviously upgrading has an important benefit, but one of
>> the security considerations for Bitcoin is knowing that your definition of the
>> money hasn't changed.  Much harder to know that if you change software.
>
> Isn't that just an argument for putting more effort into backporting
> fixes/workarounds?

Not really.  Any forced change still creates centralization,
dependence, and an opportunity for insecurity.

> (I don't see how you do that without essentially
> publically disclosing which patches have a security impact -- "oh,
> gosh, this patch gets a backport, I wonder if maybe it has security
> implications...")

That is a concern too, but our bar for backport fixes is low enough
that they're often able to include more serious fixes without calling
attention to them.

> (In so far as bitcoin is a consensus system, there can sometimes be a
> positive network effect, where having other people upgrade can help your
> security, even if you don't upgrade; "herd immunity" if you will.

This is true even outside of the consensus critical parts.  In the P2P
network other people upgrading can be protective.

> If altcoin maintainers are inconvenienced by tracking bitcoin-core
> updates, that would be an argument for them to contribute back to their

Sure, a few have. Most do not because they are either not focused on
software quality or consider themselves as having an adversarial
relationship with Bitcoin.

> keep up with security fixes, that's probably valuable information to
> provide to the market...

If you'd like to provide the sort of valuable information to the
market which may get you sued or targeted for harassment of physical
attack-- feel free. Don't ask the rest of us to do so.

From greg at xiph.org  Tue Sep 12 17:57:32 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Tue, 12 Sep 2017 17:57:32 +0000
Subject: [bitcoin-dev] Responsible disclosure of bugs
In-Reply-To: <CAKzdR-oYQ8EchpJVE56yJbfBgNHihx7WO_gtFtp6QKOcK7uT-w@mail.gmail.com>
References: <3e4541f3-f65c-5199-5e85-9a65ea5142e7@bitcartel.com>
	<cb968a34-f8d2-ab61-dd15-9bd282afd18c@mattcorallo.com>
	<20170911021506.GA19080@erisian.com.au>
	<CAPWm=eVCh2FYp=SpOcZFLqz1ZCq3=Z_F9Sj+EAXFvqU-8aMuTg@mail.gmail.com>
	<20170912033703.GD19080@erisian.com.au>
	<CAKzdR-oYQ8EchpJVE56yJbfBgNHihx7WO_gtFtp6QKOcK7uT-w@mail.gmail.com>
Message-ID: <CAAS2fgRE+0Nv6S8a8-v4U16Sn1Es4LCTvwVZocUSsJ5P7X6VYg@mail.gmail.com>

On Tue, Sep 12, 2017 at 4:49 AM, Sergio Demian Lerner via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> It also implies that some times a researcher works hard to investigate a
> vulnerability and later he finds out it was previously reported. It also
> means that the researcher cannot report to alt-coins which have a different
> policy.

I agree with your post, but wanted to make a point of clarification on
the use of "can't".

If someone wants to report something to the Bitcoin project we're
obviously at your mercy in how we handle it. If we disagree on the
handling approach we may try to talk you into a different position
based with a rational judgement based on our experience (or, if
justified, advice that we're likely to whine about your approach in
public). But if you still want to go also report a common issue to
something else with a different approach then you can. Even our
ire/whining can be avoided by a sincere effort to communicate and give
us an opportunity to mitigate harm.

That said, as mentioned, we'd encourage otherwise for issues that
warrant it-- and I think with cause enough that the reporter will
agree. So that is a different kind of "cant". :)

In Bitcoin the overwhelming majority of serious issues we've
encountered have been found by people I'd consider 'inside the
project' (frequent regular contributors who aren't seriously involved
in other things).  That hasn't been so obviously the case for other
open source projects that I've been involved with; but Bitcoin is
pretty good from a basic security perspective and finding additional
issues often requires specialized experience that few people outside
of the project regulars have (though some, like Sergio, clearly do).

I know through direct experience that both Mozilla and the Chrome
project fix _serious_ (like RCE bugs) issues based on internal
discoveries which they do not make public (apparently ever), though
they may coordinate with distributors on some of them.   (Some of
these experiences are also why I give the advice that you should not
consider any computer which has ever run a web browser to be strongly
secure...)

From mark at friedenbach.org  Tue Sep 12 19:57:10 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Tue, 12 Sep 2017 12:57:10 -0700
Subject: [bitcoin-dev] Merkle branch verification & tail-call semantics
 for generalized MAST
In-Reply-To: <DA22C531-2FAE-4332-B158-A3F96BF34002@xbt.hk>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<26AD157C-A5A9-48C3-8D29-0AD1ED35EDDD@xbt.hk>
	<2419914E-E196-44B4-8663-599AF616A897@friedenbach.org>
	<DA22C531-2FAE-4332-B158-A3F96BF34002@xbt.hk>
Message-ID: <61D84B62-0F3F-48E1-B749-F628AD91BC12@friedenbach.org>

On Sep 12, 2017, at 1:55 AM, Johnson Lau <jl2012 at xbt.hk> wrote:

> This is ugly and actually broken, as different script path may
> require different number of stack items, so you don't know how many
> OP_TOALTSTACK do you need. Easier to just use a new witness version

DEPTH makes this relatively easy to do. Just repeat the following for
the maximum number of stack elements that might be used:

  DEPTH 1SUB IF SWAP TOALTSTACK ENDIF

There are probably more compact alternatives.

Using a new script version is easier, but not faster. There's a number
of things that might be fixed in a v1 upgrade, and various design
decisions to sort out regarding specification of a witness version
(version in the witness rather than the scriptPubKey).

Tree signatures and MAST are immediately useful to many services,
however, and I would hate to delay usage by six months to a year or
more by serializing dependencies instead of doing them in parallel.

> Otherwise, one could attack relay and mining nodes by sending many
> small size txs with many sigops, forcing them to validate, and
> discard due to insufficient fees.
>
> Technically it might be ok if we commit the total validation cost
> (sigop + hashop + whatever) as the first witness stack item

That is what I'm suggesting. And yes, there are changes that would
have to be made to the p2p layer and transaction processing to handle
this safely. I'm arguing that the cost of doing so is worth it, and a
better path forward.

> Without the limit I think we would be DoS-ed to dead

4MB of secp256k1 signatures takes 10s to validate on my 5 year old
laptop (125,000 signatures, ignoring public keys and other things that
would consume space). That's much less than bad blocks that can be
constructed using other vulnerabilities.

> So to make it functionally comparable with your proposal, the
> IsMSV0Stack() function is not needed. The new 249-254 lines in
> interpreter.cpp could be removed. The new 1480-1519 lines could be
> replaced by a few lines copied from the existing P2WSH code. I can
> make a minimal version if you want to see how it looks like

That's alright, I don't think it's necessary to purposefully restrict
one to compare them head to head with the same features. They are
different proposals with different pros and cons.

Kind regards,
Mark Friedenbach


From karljohan-alm at garage.co.jp  Tue Sep 12 23:27:36 2017
From: karljohan-alm at garage.co.jp (Karl Johan Alm)
Date: Wed, 13 Sep 2017 08:27:36 +0900
Subject: [bitcoin-dev] Merkle branch verification & tail-call semantics
 for generalized MAST
In-Reply-To: <61D84B62-0F3F-48E1-B749-F628AD91BC12@friedenbach.org>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<26AD157C-A5A9-48C3-8D29-0AD1ED35EDDD@xbt.hk>
	<2419914E-E196-44B4-8663-599AF616A897@friedenbach.org>
	<DA22C531-2FAE-4332-B158-A3F96BF34002@xbt.hk>
	<61D84B62-0F3F-48E1-B749-F628AD91BC12@friedenbach.org>
Message-ID: <CALJw2w49t5Wt1Czf4VTNj10opzPOS8ZDrRgoAwmeVFTeWWzBLg@mail.gmail.com>

On Wed, Sep 13, 2017 at 4:57 AM, Mark Friedenbach via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>> Without the limit I think we would be DoS-ed to dead
>
> 4MB of secp256k1 signatures takes 10s to validate on my 5 year old
> laptop (125,000 signatures, ignoring public keys and other things that
> would consume space). That's much less than bad blocks that can be
> constructed using other vulnerabilities.

Sidenote-ish, but I also believe it would be fairly trivial to keep a
per UTXO tally and demand additional fees when trying to respend a
UTXO which was previously "spent" with an invalid op count. I.e. if
you sign off on an input for a tx that you know is bad, the UTXO in
question will be penalized proportionately to the wasted ops when
included in another transaction later. That would probably kill that
DoS attack as the attacker would effectively lose bitcoin every time,
even if it was postponed until they spent the UTXO. The only thing
clients would need to do is to add a fee rate penalty ivar and a
mapping of outpoint to penalty value, probably stored as a separate
.dat file. I think.

From iopoiti at yahoo.it  Tue Sep 12 22:58:35 2017
From: iopoiti at yahoo.it (michele terzi)
Date: Tue, 12 Sep 2017 22:58:35 +0000 (UTC)
Subject: [bitcoin-dev] 2 softforks to cut the blockchain and IBD time
References: <351373080.1326948.1505257115533.ref@mail.yahoo.com>
Message-ID: <351373080.1326948.1505257115533@mail.yahoo.com>

the blockchain is 160Gb and this is literally the biggest problem bitcoin has right now. syncing a new node is a nightmare that discourages a lot of people.
this single aspect is what hurts bitcoin's decentralization the most and it is getting worse by the day.

to solve this problem i propose 2 softfork.

both of them have been partially discussed so you may be already familiar with them. I'll just try to highlight problems and benefits.


first SF)
a snapshot of the UTXO set plus all the relevant info (like OP_RETURNs) is hashed in the coinbase.
this can be repeated automatically every given period of x blocks. I suggest 55k blocks (1 year)

second SF)
after a given amount of time the UTXO hash is written in the consensus code.
this hash becomes the hash of a new genesis block and all the older blocks are chopped away


Pros:

you gain a much faster syncing for new nodes.
full non pruning nodes need a lot less HD space.
dropping old history results in more difficult future chainanalysis (at least by small entities)
freezing old history in one new genesis block means the chain can no longer be reorged prior to that point

old status

genesis |----- x ------| newgenesis |----- y ------| now

new status

???????????????????????? newgenesis |----- y ------| now

while the old chain can be reorged to the genesis block the new chain can be reorged only to the newgenesisblock

cutting the chain has also some other small benefits: without the need to validate old blocks we can clean old no more usefull consensus code


Cons: 

a small amount of space is consumed on the blockchain
every node needs to perform the calculations

full nodes with old software can no longer be fired up and sync with the existing network
full nodes that went off line prior to the second fork cannot sync back once they turn back on line again.

if these things are concerning (which for me are not) we can just keep online a few archive nodes.
old clients will sync only from archivial nodes with full history and new full nodes will sync from everywere


Addressing security concerns:

being able to write a new genesis block means that an evil core has the power to steal/destroy/censor/whatever coins.

this is possible only in theory, but not in practice. right now devs can misbehave with every softfork, but the community tests and inspects every new release.

the 2 forks will be tested and inspected as well so they are no more risky than other softforks.

additionally the process is divided into 2 separate steps and the first step (the critical one) is effectively void without the second (which is substantially delayed) this gives the community additional time to test it and thus is actually more secure than a standard softfork.
besides after the first softfork locks in there is no more room for mistakes. either the hashes match or they do not so spotting a misbehaviour is trivially simple

kind regards,Michele
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170912/07a24423/attachment.html>

From tier.nolan at gmail.com  Wed Sep 13 09:09:52 2017
From: tier.nolan at gmail.com (Tier Nolan)
Date: Wed, 13 Sep 2017 10:09:52 +0100
Subject: [bitcoin-dev] 2 softforks to cut the blockchain and IBD time
In-Reply-To: <351373080.1326948.1505257115533@mail.yahoo.com>
References: <351373080.1326948.1505257115533.ref@mail.yahoo.com>
	<351373080.1326948.1505257115533@mail.yahoo.com>
Message-ID: <CAE-z3OUeHfPh28MqjVhJ9pRZ=P8MecaGFwR48Ggw4UaHDjNr6A@mail.gmail.com>

On Tue, Sep 12, 2017 at 11:58 PM, michele terzi via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> Pros:
>
> you gain a much faster syncing for new nodes.
> full non pruning nodes need a lot less HD space.
> dropping old history results in more difficult future chainanalysis (at
> least by small entities)
> freezing old history in one new genesis block means the chain can no
> longer be reorged prior to that point
>

Current nodes allow pruning so you can save disk space that way.  Users
still need to download/verify the new blocks though.

Under your scheme, you don't need to throw the data away.  Nodes can decide
how far back that they want to go.

"Fast" IBD

- download header chain from genesis (~4MB per year)
- check headers against "soft" checkpoints (every 50k blocks)
- download the UTXO set of the most recent soft checkpoint (and verify
against hash)
- download blocks starting from the most recent soft checkpoint
- node is now ready to use
- [Optional] Slowly download the remaining blocks

This requires some new protocol messages to allow requesting and send the
UTXO set, though the inv and getdata messages could be used.

If you add a new services bit, NODE_NETWORK_RECENT, then nodes can find
other nodes that have the most recent blocks.  This indicates that you have
all blocks since the most recent snapshot.

The slow download doesn't have to download the blocks in order.  It can
just check against the header chain.  Once a node has all the blocks, it
would switch from NODE_NETWORK_RECENT to NODE_NETWORK.

(Multiple bits could be used to indicate that the node has 2 or more recent
time periods).

"Soft" checkpoints mean that re-orgs can't cause a network partition.  Each
soft checkpoint is a mapping of {block_hash: utxo_hash}.

A re-org of 1 year or more would be devastating so it is probably
academic.  Some people may object to centralized checkpointing and soft
checkpoints cover that objection.

full nodes with old software can no longer be fired up and sync with the
> existing network
> full nodes that went off line prior to the second fork cannot sync back
> once they turn back on line again.
>
>
This is why having archive nodes (and a way to find them) is important.

You could have a weaker requirement that nodes shouldn't delete blocks
unless they are at least 3 time periods (~3 years) old.

The software should have a setting which allows the user to specify maximum
disk space.  Disk space is cheap, so it is likely that a reasonable number
of people will leave that set to infinite.

This automatically results in lots of archive nodes.  Another setting could
decide how many time periods to download.  2-3 seem reasonable as a default
(or maybe infinite too).


> Addressing security concerns:
>
> being able to write a new genesis block means that an evil core has the
> power to steal/destroy/censor/whatever coins.
>
> this is possible only in theory, but not in practice. right now devs can
> misbehave with every softfork, but the community tests and inspects every
> new release.
>

Soft forks are inherently backward compatible.  Coins cannot be stolen
using a soft fork.  It has nothing to do with inspecting new releases.

It is possible for a majority of miners to re-write history, but that is
separate to a soft fork.

A soft fork can lock coins away.  This effectively destroys the coins, but
doesn't steal them.  It could be part of a extortion scheme I guess, but if
a majority of miners did that, then I think Bitcoin has bigger problems.


> the 2 forks will be tested and inspected as well so they are no more risky
> than other softforks.
>
>
For it to be a soft fork, you need to maintain archive nodes.  That is the
whole point.  The old network and the new network rules agree that the new
network rules are valid (and that miners only mine blocks that are valid
under the new rules).  If IBD is impossible for old nodes, then that counts
as a network split.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170913/c246eebe/attachment.html>

From pete at petertodd.org  Wed Sep 13 09:24:34 2017
From: pete at petertodd.org (Peter Todd)
Date: Wed, 13 Sep 2017 05:24:34 -0400
Subject: [bitcoin-dev] SF proposal: prohibit unspendable outputs with
 amount=0
In-Reply-To: <CABm2gDpy3a0vc+4=0a2vFSQ2d1gaAWFkPtzdbXLpNKYFepDU3A@mail.gmail.com>
References: <CABm2gDojDQWMhw8wW1UkRGKtdbby2+6AFFZLPuRcUb7WF_u5qQ@mail.gmail.com>
	<20170907180014.GA13727@fedora-23-dvm>
	<CABm2gDpy3a0vc+4=0a2vFSQ2d1gaAWFkPtzdbXLpNKYFepDU3A@mail.gmail.com>
Message-ID: <20170913092434.GA1094@savin.petertodd.org>

On Sat, Sep 09, 2017 at 11:11:57PM +0200, Jorge Tim?n wrote:
> Tier Nolan, right, a new tx version would be required.
> 
> I have to look deeper into the CT as sf proposal.
> 
> What futures upgrades could this conflict with it's precisely the
> question here. So that vague statement without providing any example
> it's not very valuable.

So with Confidential Transactions, the only thing that's changed relative to a
normal Bitcoin transaction is that fact that the sum of input values is >= the
sum of output values is proven via a CT proof, rather than revealing the actual
sums. Other than that, CT transactions don't need to be any different from
regular transactions.

For CT to be a softfork, we have to ensure that each CT transaction's sum of
inputs and outputs is valid. An obvious way to do this is to have a pool of
"shielded" outputs, whose total value is the sum of all CT-protected outputs.
Outputs in this pool would appear to be anyone-can-spend outputs to pre-CT
nodes.

This gives us three main cases:

1) Spending unshielded outputs to CT-shielded outputs

Since the CT-shielded output's value is unknown, we can simply set their value
to zero. Secondly, we will add the newly CT-shielded value to the pool with an
additional output whose value is the sum of all newly created CT-shielded
outputs.


2) Spending CT-shielded outputs to unshielded outputs

Here one or more CT-shielded outputs will be spent. Since their value is zero,
we make up the difference by spending one or more outputs from the CT pool,
with the change - if any - assigned to a CT-pool output.


3) Spending CT-shielded outputs to CT-shielded outputs

Since both the inputs and outputs are zero-valued, to pre-CT nodes the
transaction is perfectly valid: the sum of coins spent is 0 BTC, and the sum of
coins created is also 0 BTC. We do have the problem of paying miners fees, but
that could be done with an additional CT output that the miner can spend, a
child-pays-for-parent transaction, or something else entirely that I haven't
thought of.


> Although TXO commitments are interesting, I don't think they make UTXO
> growth a "non-issue" and I also don't think they justify not doing
> this.
> 
> Yeah, the costs for spammers are very small and doesn't really improve
> things all that much, as acknowledged in the initial post.

Suppose zero-valued outputs are prohibited. In case #3 above, if there are more
outputs than inputs, we need to add an additional input from the CT-shielded
pool to make up the difference, and an additional change output back to the
CT-shielded pool.

If shielded-to-shielded transactions are common, these extra outputs could
consume a significant % of the total blockchain space - that's a significant
cost. Meanwhile the benefit is so small it's essentially theoretical: an
additional satoshi per output is an almost trivial cost to an attacker.

Quite simply, I just don't think the cost-benefit tradeoff of what you're
proposing makes sense.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170913/e57a0a4e/attachment-0001.sig>

From greg at xiph.org  Wed Sep 13 09:34:37 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Wed, 13 Sep 2017 09:34:37 +0000
Subject: [bitcoin-dev] SF proposal: prohibit unspendable outputs with
	amount=0
In-Reply-To: <20170913092434.GA1094@savin.petertodd.org>
References: <CABm2gDojDQWMhw8wW1UkRGKtdbby2+6AFFZLPuRcUb7WF_u5qQ@mail.gmail.com>
	<20170907180014.GA13727@fedora-23-dvm>
	<CABm2gDpy3a0vc+4=0a2vFSQ2d1gaAWFkPtzdbXLpNKYFepDU3A@mail.gmail.com>
	<20170913092434.GA1094@savin.petertodd.org>
Message-ID: <CAAS2fgT+bfte1PRy4tn0O_cUSBEEKNvGm2+LRBLObgLWcEVuqA@mail.gmail.com>

On Wed, Sep 13, 2017 at 9:24 AM, Peter Todd via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Quite simply, I just don't think the cost-benefit tradeoff of what you're
> proposing makes sense.

I agree that dropping zero value outputs is a needless loss of
flexibility.  In addition to the CT example, something similar could
be done for increased precision (nanobitcoin!).

Maybe if in the future the value of 1e-8 btc is high enough then an
argument could be made that requiring one is a meaningful reduction in
a miner's ability to spam up the network... but the argument doesn't
fly today... the cost in lost fee income from the spam just totally
dwarfs it.

From greg at xiph.org  Wed Sep 13 09:39:28 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Wed, 13 Sep 2017 09:39:28 +0000
Subject: [bitcoin-dev] Minutia in CT for Bitcoin. Was: SF proposal: prohibit
 unspendable outputs with amount=0
Message-ID: <CAAS2fgTGhCztV5bwLQj28_M7e=uzwbdF2Rum_7gmQGjhgxqLuQ@mail.gmail.com>

On Wed, Sep 13, 2017 at 9:24 AM, Peter Todd via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> 2) Spending CT-shielded outputs to unshielded outputs
>
> Here one or more CT-shielded outputs will be spent. Since their value is zero,
> we make up the difference by spending one or more outputs from the CT pool,
> with the change - if any - assigned to a CT-pool output.

Can we solve the problem that pool inputs are gratuitously non-reorg
safe, without creating something like a maturity limit for shielded to
unshielded?

So far the best I have is this:  Support unshielded coins in shielded
space too. So the only time you transition out of the pool is paying
to a legacy wallet.  If support were phased in (e.g. addresses that
say you can pay me in the pool after its enabled), and the pool only
used long after wallets supported getting payments in it, then this
would be pretty rare and a maturity limit wouldn't be a big deal.

Can better be done?

From pete at petertodd.org  Wed Sep 13 09:41:07 2017
From: pete at petertodd.org (Peter Todd)
Date: Wed, 13 Sep 2017 05:41:07 -0400
Subject: [bitcoin-dev] Merkle branch verification & tail-call semantics
 for generalized MAST
In-Reply-To: <CALJw2w49t5Wt1Czf4VTNj10opzPOS8ZDrRgoAwmeVFTeWWzBLg@mail.gmail.com>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<26AD157C-A5A9-48C3-8D29-0AD1ED35EDDD@xbt.hk>
	<2419914E-E196-44B4-8663-599AF616A897@friedenbach.org>
	<DA22C531-2FAE-4332-B158-A3F96BF34002@xbt.hk>
	<61D84B62-0F3F-48E1-B749-F628AD91BC12@friedenbach.org>
	<CALJw2w49t5Wt1Czf4VTNj10opzPOS8ZDrRgoAwmeVFTeWWzBLg@mail.gmail.com>
Message-ID: <20170913094107.GA1527@savin.petertodd.org>

On Wed, Sep 13, 2017 at 08:27:36AM +0900, Karl Johan Alm via bitcoin-dev wrote:
> On Wed, Sep 13, 2017 at 4:57 AM, Mark Friedenbach via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >> Without the limit I think we would be DoS-ed to dead
> >
> > 4MB of secp256k1 signatures takes 10s to validate on my 5 year old
> > laptop (125,000 signatures, ignoring public keys and other things that
> > would consume space). That's much less than bad blocks that can be
> > constructed using other vulnerabilities.
> 
> Sidenote-ish, but I also believe it would be fairly trivial to keep a
> per UTXO tally and demand additional fees when trying to respend a
> UTXO which was previously "spent" with an invalid op count. I.e. if
> you sign off on an input for a tx that you know is bad, the UTXO in
> question will be penalized proportionately to the wasted ops when
> included in another transaction later. That would probably kill that
> DoS attack as the attacker would effectively lose bitcoin every time,
> even if it was postponed until they spent the UTXO. The only thing
> clients would need to do is to add a fee rate penalty ivar and a
> mapping of outpoint to penalty value, probably stored as a separate
> .dat file. I think.

Ethereum does something quite like this; it's a very bad idea for a few
reasons:

1) If you bailed out of verifying a script due to wasted ops, how did you know the
transaction trying to spend that txout did in fact come from the owner of it?

2) How do you verify that transactions were penalized correctly without *all*
nodes re-running the DoS script?

3) If the DoS is significant enough to matter on a per-node level, you're going
to have serious problems anyway, quite possibly so serious that the attacker
manages to cause consensus to fail. They can then spend the txouts in a block
that does *not* penalize their outputs, negating the deterrent.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170913/fe142009/attachment.sig>

From pete at petertodd.org  Wed Sep 13 10:03:28 2017
From: pete at petertodd.org (Peter Todd)
Date: Wed, 13 Sep 2017 06:03:28 -0400
Subject: [bitcoin-dev] Minutia in CT for Bitcoin. Was: SF proposal:
 prohibit unspendable outputs with amount=0
In-Reply-To: <CAAS2fgTGhCztV5bwLQj28_M7e=uzwbdF2Rum_7gmQGjhgxqLuQ@mail.gmail.com>
References: <CAAS2fgTGhCztV5bwLQj28_M7e=uzwbdF2Rum_7gmQGjhgxqLuQ@mail.gmail.com>
Message-ID: <20170913100328.GA1613@savin.petertodd.org>

On Wed, Sep 13, 2017 at 09:39:28AM +0000, Gregory Maxwell wrote:
> On Wed, Sep 13, 2017 at 9:24 AM, Peter Todd via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > 2) Spending CT-shielded outputs to unshielded outputs
> >
> > Here one or more CT-shielded outputs will be spent. Since their value is zero,
> > we make up the difference by spending one or more outputs from the CT pool,
> > with the change - if any - assigned to a CT-pool output.
> 
> Can we solve the problem that pool inputs are gratuitously non-reorg
> safe, without creating something like a maturity limit for shielded to
> unshielded?

So to be clear, we have two versions of this problem:

1) CT signatures do *not* sign which pool input they're using

Here, obviously the inputs can be changed at will by miners. An implementation
could have the exact CT pool input be something miners add; the CT transactions
broadcast on the P2P network wouldn't actually need them.


2) CT signatures *do* sign which pool input they're using

Wallets would pick the input at random. This is required if you want to have a
transaction spending both CT and legacy inputs. This reduces the reorg risk to
double-spends. While double-spends are always a potential problem, the problem
is somewhat worse here, as even regular wallets are spending inputs that anyone
can choose to spend.


> So far the best I have is this:  Support unshielded coins in shielded
> space too. So the only time you transition out of the pool is paying
> to a legacy wallet.  If support were phased in (e.g. addresses that
> say you can pay me in the pool after its enabled), and the pool only
> used long after wallets supported getting payments in it, then this
> would be pretty rare and a maturity limit wouldn't be a big deal.

So basically, you're essentially observing that in the event that everyone uses
CT, this isn't actually a problem; you're allowing everyone to "use" CT, by
trying to allow even unshielded outputs to "use" it.

Which means by "unshielded output", what you *actuall* mean is creating a CT
transaction where the output - even though it's a zero-valued CT output - is
constructed such that the value is public information.

Or do you mean trying to have non-CT outputs in the pool somehow? I don't think
that makes sense, because the whole point of the pool is that the outputs in it
are anyone-can-spend, and thus any CT transaction may spend them; which CT
transaction spends them gives no information about the ownership of the coins.
This is incompatible with anything but anyone-can-spend outputs.

> Can better be done?

Note that the order in which outputs in the pool are spent can be
deterministic. For example, you could say that each transaction must spend the
oldest outputs in the pool (that sum to the value needed). You could probably
come up with a scheme where the outputs that will be spent in the future in the
event that the output is spent back to an unshielded output is fixed when the
output was created, for example, by picking a random index. While this wouldn't
prevent all collisions, it'd may be possible to make reorgs relatively safe, by
constraining how miners could txids.

Specifically, you could imagine a scheme where if a given input set can only be
satisified by unspent pool outputs with index's >= i, then the miner would need
to have the ability to mine a conflicting transaction that also happened to
have the same pool output set. Given a sufficiently large set of pool outputs,
this may be an impractical attack most of the time.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170913/ff9d3b6e/attachment.sig>

From roconnor at blockstream.io  Wed Sep 13 13:24:14 2017
From: roconnor at blockstream.io (Russell O'Connor)
Date: Wed, 13 Sep 2017 09:24:14 -0400
Subject: [bitcoin-dev] SigOps limit.
Message-ID: <CAMZUoKkgr-5ziDL09jkC1wOVprcZ2=jcd-PhHnSn79hcVhrrTA@mail.gmail.com>

On Tue, Sep 12, 2017 at 3:57 PM, Mark Friedenbach via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> 4MB of secp256k1 signatures takes 10s to validate on my 5 year old
> laptop (125,000 signatures, ignoring public keys and other things that
> would consume space). That's much less than bad blocks that can be
> constructed using other vulnerabilities.


If there were no sigops limits, I believe the worst case block could have
closer to 1,000,000 CHECKSIG operations.  Signature checks are cached so
while repeating the sequence "2DUP CHECKSIGVERIFY" does create a lot of
checksig operations, the cached values prevent a lot of work being done.

To defeat the cache one can repeat the sequence "2DUP CHECKSIG DROP
CODESEPARATOR", which will create unique signature validation requests
every 4 bytes.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170913/dee1f60d/attachment.html>

From aj at erisian.com.au  Thu Sep 14 05:27:40 2017
From: aj at erisian.com.au (Anthony Towns)
Date: Thu, 14 Sep 2017 15:27:40 +1000
Subject: [bitcoin-dev] Responsible disclosure of bugs
In-Reply-To: <e28e151a-1a67-4e90-f5fd-721cbc7f213d@bitcartel.com>
References: <3e4541f3-f65c-5199-5e85-9a65ea5142e7@bitcartel.com>
	<cb968a34-f8d2-ab61-dd15-9bd282afd18c@mattcorallo.com>
	<20170911021506.GA19080@erisian.com.au>
	<CAPWm=eVCh2FYp=SpOcZFLqz1ZCq3=Z_F9Sj+EAXFvqU-8aMuTg@mail.gmail.com>
	<20170912033703.GD19080@erisian.com.au>
	<CAKzdR-oYQ8EchpJVE56yJbfBgNHihx7WO_gtFtp6QKOcK7uT-w@mail.gmail.com>
	<e28e151a-1a67-4e90-f5fd-721cbc7f213d@bitcartel.com>
Message-ID: <20170914052740.GA2674@erisian.com.au>

On Tue, Sep 12, 2017 at 09:10:18AM -0700, Simon Liu wrote:
> It would be a good starting point if the current policy could be
> clarified, so everyone is on the same page, and there is no confusion.

Collecting various commentary from here and reddit, I think current de
facto policy is something like:

 * Vulnerabilities should be reported via security at bitcoincore.org [0]

 * A critical issue (that can be exploited immediately or is already
   being exploited causing large harm) will be dealt with by:
     * a released patch ASAP
     * wide notification of the need to upgrade (or to disable affected
       systems)
     * minimal disclosure of the actual problem, to delay attacks
   [1] [2]

 * A non-critical vulnerability (because it is difficult or expensive to
   exploit) will be dealt with by:
     * patch and review undertaken in the ordinary flow of development
     * backport of a fix or workaround from master to the current
       released version [2]

 * Devs will attempt to ensure that publication of the fix does not
   reveal the nature of the vulnerability by providing the proposed fix
   to experienced devs who have not been informed of the vulnerability,
   telling them that it fixes a vulnerability, and asking them to identify
   the vulnerability. [2]

 * Devs may recommend other bitcoin implementations adopt vulnerability
   fixes prior to the fix being released and widely deployed, if they
   can do so without revealing the vulnerability; eg, if the fix has
   significant performance benefits that would justify its inclusion. [3]

 * Prior to a vulnerability becoming public, devs will generally recommend
   to friendly altcoin devs that they should catch up with fixes. But this
   is only after the fixes are widely deployed in the bitcoin network. [4]

 * Devs will generally not notify altcoin developers who have behaved
   in a hostile manner (eg, using vulnerabilities to attack others, or
   who violate embargoes). [5]

 * Bitcoin devs won't disclose vulnerability details until >80% of bitcoin
   nodes have deployed the fixes. Vulnerability discovers are encouraged
   and requested to follow the same policy. [1] [6]

Those seem like pretty good policies to me, for what it's worth.

I haven't seen anything that indicates bitcoin devs will *ever* encourage
public disclosure of vulnerabilities (as opposed to tolerating other
people publishing them [6]). So I'm guessing current de facto policy is
more along the lines of:

 * Where possible, Bitcoin devs will never disclose vulnerabilities
   publically while affected code may still be in use (including by
   altcoins).

rather than something like:

 * Bitcoin devs will disclose vulnerabilities publically after 99% of the
   bitcoin network has upgraded [7], and fixes have been released for
   at least 12 months.


Instinctively, I'd say documenting this policy (or whatever it actually
is) would be good, and having all vulnerabilities get publically released
eventually would also be good; that's certainly the more "open source"
approach. But arguing the other side:

 - documenting security policy gives attackers a better handle on where
   to find weak points; this may be more harm than there is benefit to
   improving legitimate users' understanding of and confidence in the
   development process

 - the main benefit of public vulnerability disclosure is a better
   working relationship with security researchers and perhaps better
   understanding of what sort of bugs happen in practice in general;
   but if most of your security research is effectively in house [6],
   maybe those benefits aren't as great as the harm done by revealing
   even old vulnerabilities to attackers

If the first of those arguments holds, well, hopefully this message has
egregious errors that no one will correct, or it will quickly get lost
in this list's archives...

Cheers,
aj

[0] http://bitcoincore.org/en/contact
    referenced from .github/ISSUE_TEMPLATE.md in git

[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/014986.html

[2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/014990.html

[3] https://www.reddit.com/r/btc/comments/6zf1qo/peter_todd_nicely_pulled_away_attention_from_jjs/dmxcw70/

[4] https://www.reddit.com/r/btc/comments/6z827o/chris_jeffrey_jj_discloses_bitcoin_attack_vector/dmxdg83/

[5] https://www.reddit.com/r/btc/comments/6zb3lp/maxwell_admits_core_sat_on_vulnerability/dmv4y7g/

[6] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/014991.html 

[7] Per http://luke.dashjr.org/programs/bitcoin/files/charts/branches.html
    it seems like 1.7% of the network is running known-vulnerable versions
    0.8 and 0.9; but only 0.37% are running 0.10 or 0.11, so that might argue
    revealing any vulnerabilities fixed since 0.12.0 would be fine...
    (bitnodes.21.co doesn't seem to break down anything earlier than 0.12)


From laanwj at gmail.com  Thu Sep 14 13:20:35 2017
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Thu, 14 Sep 2017 15:20:35 +0200
Subject: [bitcoin-dev] Bitcoin Core 0.15.0 released
Message-ID: <20170914132034.GA17610@amethyst.visucore.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Bitcoin Core version *0.15.0* is now available from:

  <https://bitcoin.org/bin/bitcoin-core-0.15.0/>

and

  <https://bitcoincore.org/bin/bitcoin-core-0.15.0/>

Or through bittorrent:

    magnet:?xt=urn:btih:e17a5823dd84fe5100386c69e91bc0671e4b4ed2&dn=bitcoin-core-0.15.0&tr=udp%3A%2F%2Ftracker.skyts.net%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.safe.moe%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.piratepublic.com%3A1337%2Fannounce&tr=udp%3A%2F%2Ftracker.pirateparty.gr%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969%2Fannounce

This is a new major version release, including new features, various bugfixes
and performance improvements, as well as updated translations.

Please report bugs using the issue tracker at GitHub:

  <https://github.com/bitcoin/bitcoin/issues>

To receive security and update notifications, please subscribe to:

  <https://bitcoincore.org/en/list/announcements/join/>

How to Upgrade
==============

If you are running an older version, shut it down. Wait until it has completely
shut down (which might take a few minutes for older versions), then run the 
installer (on Windows) or just copy over `/Applications/Bitcoin-Qt` (on Mac)
or `bitcoind`/`bitcoin-qt` (on Linux).

The first time you run version 0.15.0, your chainstate database will be converted to a
new format, which will take anywhere from a few minutes to half an hour,
depending on the speed of your machine.

The file format of `fee_estimates.dat` changed in version 0.15.0. Hence, a
downgrade from version 0.15.0 or upgrade to version 0.15.0 will cause all fee
estimates to be discarded.

Note that the block database format also changed in version 0.8.0 and there is no
automatic upgrade code from before version 0.8 to version 0.15.0. Upgrading
directly from 0.7.x and earlier without redownloading the blockchain is not supported.
However, as usual, old wallet versions are still supported.

Downgrading warning
- -------------------

The chainstate database for this release is not compatible with previous
releases, so if you run 0.15 and then decide to switch back to any
older version, you will need to run the old release with the `-reindex-chainstate`
option to rebuild the chainstate data structures in the old format.

If your node has pruning enabled, this will entail re-downloading and
processing the entire blockchain.

Compatibility
==============

Bitcoin Core is extensively tested on multiple operating systems using
the Linux kernel, macOS 10.8+, and Windows Vista and later. Windows XP is not supported.

Bitcoin Core should also work on most other Unix-like systems but is not
frequently tested on them.

Notes for 0.15.0
================

Current SegWit support
- ----------------------

Version 0.15.0 supports adding a segregated witness address via the `addwitnessaddress` RPC, but
please note that this is a testing/expert RPC, which does not guarantee recovery from backup. Only use
this RPC if you know what you are doing. More complete wallet support for segregated witness is coming
in a next version.

Rescanning with encrypted wallets
- ---------------------------------

As in previous versions, when using an encrypted HD wallet, the keypool cannot be topped up without unlocking
the wallet. This means that currently, in order to recover from a backup of an encrypted HD wallet, the user
must unlock the wallet with a really long timeout and manually trigger a rescan, otherwise they risk missing
some keys when auto-topup cannot run. Unfortunately there is no `rescan` RPC in this version, that will be
included in a future version, so for now a rescan can be triggered using one of the `import*` commands, using
a dummy address generated by another (trusted) wallet.

Notable changes
===============

Performance Improvements
- ------------------------

Version 0.15 contains a number of significant performance improvements, which make
Initial Block Download, startup, transaction and block validation much faster:

- - The chainstate database (which is used for tracking UTXOs) has been changed
  from a per-transaction model to a per-output model (See [PR 10195](https://github.com/bitcoin/bitcoin/pull/10195)). Advantages of this model
  are that it:
    - avoids the CPU overhead of deserializing and serializing the unused outputs;
    - has more predictable memory usage;
    - uses simpler code;
    - is adaptable to various future cache flushing strategies.

  As a result, validating the blockchain during Initial Block Download (IBD) and reindex
  is ~30-40% faster, uses 10-20% less memory, and flushes to disk far less frequently.
  The only downside is that the on-disk database is 15% larger. During the conversion from the previous format
  a few extra gigabytes may be used.
- - Earlier versions experienced a spike in memory usage while flushing UTXO updates to disk.
  As a result, only half of the available memory was actually used as cache, and the other half was
  reserved to accommodate flushing. This is no longer the case (See [PR 10148](https://github.com/bitcoin/bitcoin/pull/10148)), and the entirety of
  the available cache (see `-dbcache`) is now actually used as cache. This reduces the flushing
  frequency by a factor 2 or more.
- - In previous versions, signature validation for transactions has been cached when the
  transaction is accepted to the mempool. Version 0.15 extends this to cache the entire script
  validity (See [PR 10192](https://github.com/bitcoin/bitcoin/pull/10192)). This means that if a transaction in a block has already been accepted to the
  mempool, the scriptSig does not need to be re-evaluated. Empirical tests show that
  this results in new block validation being 40-50% faster.
- - LevelDB has been upgraded to version 1.20 (See [PR 10544](https://github.com/bitcoin/bitcoin/pull/10544)). This version contains hardware acceleration for CRC
  on architectures supporting SSE 4.2. As a result, synchronization and block validation are now faster.
- - SHA256 hashing has been optimized for architectures supporting SSE 4 (See [PR 10821](https://github.com/bitcoin/bitcoin/pull/10821)). SHA256 is around
  50% faster on supported hardware, which results in around 5% faster IBD and block
  validation. In version 0.15, SHA256 hardware optimization is disabled in release builds by
  default, but can be enabled by using `--enable-experimental-asm` when building.
- - Refill of the keypool no longer flushes the wallet between each key which resulted in a ~20x speedup in creating a new wallet. Part of this speedup was used to increase the default keypool to 1000 keys to make recovery more robust. (See [PR 10831](https://github.com/bitcoin/bitcoin/pull/10831)).

Fee Estimation Improvements
- ---------------------------

Fee estimation has been significantly improved in version 0.15, with more accurate fee estimates used by the wallet and a wider range of options for advanced users of the `estimatesmartfee` and `estimaterawfee` RPCs (See [PR 10199](https://github.com/bitcoin/bitcoin/pull/10199)).

### Changes to internal logic and wallet behavior

- - Internally, estimates are now tracked on 3 different time horizons. This allows for longer targets and means estimates adjust more quickly to changes in conditions.
- - Estimates can now be *conservative* or *economical*. *Conservative* estimates use longer time horizons to produce an estimate which is less susceptible to rapid changes in fee conditions. *Economical* estimates use shorter time horizons and will be more affected by short-term changes in fee conditions. Economical estimates may be considerably lower during periods of low transaction activity (for example over weekends), but may result in transactions being unconfirmed if prevailing fees increase rapidly.
- - By default, the wallet will use conservative fee estimates to increase the reliability of transactions being confirmed within the desired target. For transactions that are marked as replaceable, the wallet will use an economical estimate by default, since the fee can be 'bumped' if the fee conditions change rapidly (See [PR 10589](https://github.com/bitcoin/bitcoin/pull/10589)).
- - Estimates can now be made for confirmation targets up to 1008 blocks (one week).
- - More data on historical fee rates is stored, leading to more precise fee estimates.
- - Transactions which leave the mempool due to eviction or other non-confirmed reasons are now taken into account by the fee estimation logic, leading to more accurate fee estimates.
- - The fee estimation logic will make sure enough data has been gathered to return a meaningful estimate. If there is insufficient data, a fallback default fee is used.

### Changes to fee estimate RPCs

- - The `estimatefee` RPC is now deprecated in favor of using only `estimatesmartfee` (which is the implementation used by the GUI)
- - The `estimatesmartfee` RPC interface has been changed (See [PR 10707](https://github.com/bitcoin/bitcoin/pull/10707)):
    - The `nblocks` argument has been renamed to `conf_target` (to be consistent with other RPC methods).
    - An `estimate_mode` argument has been added. This argument takes one of the following strings: `CONSERVATIVE`, `ECONOMICAL` or `UNSET` (which defaults to `CONSERVATIVE`).
    - The RPC return object now contains an `errors` member, which returns errors encountered during processing.
    - If Bitcoin Core has not been running for long enough and has not seen enough blocks or transactions to produce an accurate fee estimation, an error will be returned (previously a value of -1 was used to indicate an error, which could be confused for a feerate).
- - A new `estimaterawfee` RPC is added to provide raw fee data. External clients can query and use this data in their own fee estimation logic.

Multi-wallet support
- --------------------

Bitcoin Core now supports loading multiple, separate wallets (See [PR 8694](https://github.com/bitcoin/bitcoin/pull/8694), [PR 10849](https://github.com/bitcoin/bitcoin/pull/10849)). The wallets are completely separated, with individual balances, keys and received transactions.

Multi-wallet is enabled by using more than one `-wallet` argument when starting Bitcoin, either on the command line or in the Bitcoin config file.

**In Bitcoin-Qt, only the first wallet will be displayed and accessible for creating and signing transactions.** GUI selectable multiple wallets will be supported in a future version. However, even in 0.15 other loaded wallets will remain synchronized to the node's current tip in the background. This can be useful if running a pruned node, since loading a wallet where the most recent sync is beyond the pruned height results in having to download and revalidate the whole blockchain. Continuing to synchronize all wallets in the background avoids this problem.

Bitcoin Core 0.15.0 contains the following changes to the RPC interface and `bitcoin-cli` for multi-wallet:

* When running Bitcoin Core with a single wallet, there are **no** changes to the RPC interface or `bitcoin-cli`. All RPC calls and `bitcoin-cli` commands continue to work as before.
* When running Bitcoin Core with multi-wallet, all *node-level* RPC methods continue to work as before. HTTP RPC requests should be send to the normal `<RPC IP address>:<RPC port>/` endpoint, and `bitcoin-cli` commands should be run as before. A *node-level* RPC method is any method which does not require access to the wallet.
* When running Bitcoin Core with multi-wallet, *wallet-level* RPC methods must specify the wallet for which they're intended in every request. HTTP RPC requests should be send to the `<RPC IP address>:<RPC port>/wallet/<wallet name>/` endpoint, for example `127.0.0.1:8332/wallet/wallet1.dat/`. `bitcoin-cli` commands should be run with a `-rpcwallet` option, for example `bitcoin-cli -rpcwallet=wallet1.dat getbalance`.
* A new *node-level* `listwallets` RPC method is added to display which wallets are currently loaded. The names returned by this method are the same as those used in the HTTP endpoint and for the `rpcwallet` argument.

Note that while multi-wallet is now fully supported, the RPC multi-wallet interface should be considered unstable for version 0.15.0, and there may backwards-incompatible changes in future versions.

Replace-by-fee control in the GUI
- ---------------------------------

Bitcoin Core has supported creating opt-in replace-by-fee (RBF) transactions
since version 0.12.0, and since version 0.14.0 has included a `bumpfee` RPC method to
replace unconfirmed opt-in RBF transactions with a new transaction that pays
a higher fee.

In version 0.15, creating an opt-in RBF transaction and replacing the unconfirmed
transaction with a higher-fee transaction are both supported in the GUI (See [PR 9592](https://github.com/bitcoin/bitcoin/pull/9592)).

Removal of Coin Age Priority
- ----------------------------

In previous versions of Bitcoin Core, a portion of each block could be reserved for transactions based on the age and value of UTXOs they spent. This concept (Coin Age Priority) is a policy choice by miners, and there are no consensus rules around the inclusion of Coin Age Priority transactions in blocks. In practice, only a few miners continue to use Coin Age Priority for transaction selection in blocks. Bitcoin Core 0.15 removes all remaining support for Coin Age Priority (See [PR 9602](https://github.com/bitcoin/bitcoin/pull/9602)). This has the following implications:

- - The concept of *free transactions* has been removed. High Coin Age Priority transactions would previously be allowed to be relayed even if they didn't attach a miner fee. This is no longer possible since there is no concept of Coin Age Priority. The `-limitfreerelay` and `-relaypriority` options which controlled relay of free transactions have therefore been removed.
- - The `-sendfreetransactions` option has been removed, since almost all miners do not include transactions which do not attach a transaction fee.
- - The `-blockprioritysize` option has been removed.
- - The `estimatepriority` and `estimatesmartpriority` RPCs have been removed.
- - The `getmempoolancestors`, `getmempooldescendants`, `getmempoolentry` and `getrawmempool` RPCs no longer return `startingpriority` and `currentpriority`.
- - The `prioritisetransaction` RPC no longer takes a `priority_delta` argument, which is replaced by a `dummy` argument for backwards compatibility with clients using positional arguments. The RPC is still used to change the apparent fee-rate of the transaction by using the `fee_delta` argument.
- - `-minrelaytxfee` can now be set to 0. If `minrelaytxfee` is set, then fees smaller than `minrelaytxfee` (per kB) are rejected from relaying, mining and transaction creation. This defaults to 1000 satoshi/kB.
- - The `-printpriority` option has been updated to only output the fee rate and hash of transactions included in a block by the mining code.

Mempool Persistence Across Restarts
- -----------------------------------

Version 0.14 introduced mempool persistence across restarts (the mempool is saved to a `mempool.dat` file in the data directory prior to shutdown and restores the mempool when the node is restarted). Version 0.15 allows this feature to be switched on or off using the `-persistmempool` command-line option (See [PR 9966](https://github.com/bitcoin/bitcoin/pull/9966)). By default, the option is set to true, and the mempool is saved on shutdown and reloaded on startup. If set to false, the `mempool.dat` file will not be loaded on startup or saved on shutdown.

New RPC methods
- ---------------

Version 0.15 introduces several new RPC methods:

- - `abortrescan` stops current wallet rescan, e.g. when triggered by an `importprivkey` call (See [PR 10208](https://github.com/bitcoin/bitcoin/pull/10208)).
- - `combinerawtransaction` accepts a JSON array of raw transactions and combines them into a single raw transaction (See [PR 10571](https://github.com/bitcoin/bitcoin/pull/10571)).
- - `estimaterawfee` returns raw fee data so that customized logic can be implemented to analyze the data and calculate estimates. See [Fee Estimation Improvements](#fee-estimation-improvements) for full details on changes to the fee estimation logic and interface.
- - `getchaintxstats` returns statistics about the total number and rate of transactions
  in the chain (See [PR 9733](https://github.com/bitcoin/bitcoin/pull/9733)).
- - `listwallets` lists wallets which are currently loaded. See the *Multi-wallet* section
  of these release notes for full details (See [Multi-wallet support](#multi-wallet-support)).
- - `uptime` returns the total runtime of the `bitcoind` server since its last start (See [PR 10400](https://github.com/bitcoin/bitcoin/pull/10400)).

Low-level RPC changes
- ---------------------

- - When using Bitcoin Core in multi-wallet mode, RPC requests for wallet methods must specify
  the wallet that they're intended for. See [Multi-wallet support](#multi-wallet-support) for full details.

- - The new database model no longer stores information about transaction
  versions of unspent outputs (See [Performance improvements](#performance-improvements)). This means that:
  - The `gettxout` RPC no longer has a `version` field in the response.
  - The `gettxoutsetinfo` RPC reports `hash_serialized_2` instead of `hash_serialized`,
    which does not commit to the transaction versions of unspent outputs, but does
    commit to the height and coinbase information.
  - The `getutxos` REST path no longer reports the `txvers` field in JSON format,
    and always reports 0 for transaction versions in the binary format

- - The `estimatefee` RPC is deprecated. Clients should switch to using the `estimatesmartfee` RPC, which returns better fee estimates. See [Fee Estimation Improvements](#fee-estimation-improvements) for full details on changes to the fee estimation logic and interface.

- - The `gettxoutsetinfo` response now contains `disk_size` and `bogosize` instead of
  `bytes_serialized`. The first is a more accurate estimate of actual disk usage, but
  is not deterministic. The second is unrelated to disk usage, but is a
  database-independent metric of UTXO set size: it counts every UTXO entry as 50 + the
  length of its scriptPubKey (See [PR 10426](https://github.com/bitcoin/bitcoin/pull/10426)).

- - `signrawtransaction` can no longer be used to combine multiple transactions into a single transaction. Instead, use the new `combinerawtransaction` RPC (See [PR 10571](https://github.com/bitcoin/bitcoin/pull/10571)).

- - `fundrawtransaction` no longer accepts a `reserveChangeKey` option. This option used to allow RPC users to fund a raw transaction using an key from the keypool for the change address without removing it from the available keys in the keypool. The key could then be re-used for a `getnewaddress` call, which could potentially result in confusing or dangerous behaviour (See [PR 10784](https://github.com/bitcoin/bitcoin/pull/10784)).

- - `estimatepriority` and `estimatesmartpriority` have been removed. See [Removal of Coin Age Priority](#removal-of-coin-age-priority).

- - The `listunspent` RPC now takes a `query_options` argument (see [PR 8952](https://github.com/bitcoin/bitcoin/pull/8952)), which is a JSON object
  containing one or more of the following members:
  - `minimumAmount` - a number specifying the minimum value of each UTXO
  - `maximumAmount` - a number specifying the maximum value of each UTXO
  - `maximumCount` - a number specifying the minimum number of UTXOs
  - `minimumSumAmount` - a number specifying the minimum sum value of all UTXOs

- - The `getmempoolancestors`, `getmempooldescendants`, `getmempoolentry` and `getrawmempool` RPCs no longer return `startingpriority` and `currentpriority`. See [Removal of Coin Age Priority](#removal-of-coin-age-priority).

- - The `dumpwallet` RPC now returns the full absolute path to the dumped wallet. It
  used to return no value, even if successful (See [PR 9740](https://github.com/bitcoin/bitcoin/pull/9740)).

- - In the `getpeerinfo` RPC, the return object for each peer now returns an `addrbind` member, which contains the ip address and port of the connection to the peer. This is in addition to the `addrlocal` member which contains the ip address and port of the local node as reported by the peer (See [PR 10478](https://github.com/bitcoin/bitcoin/pull/10478)).

- - The `disconnectnode` RPC can now disconnect a node specified by node ID (as well as by IP address/port). To disconnect a node based on node ID, call the RPC with the new `nodeid` argument (See [PR 10143](https://github.com/bitcoin/bitcoin/pull/10143)).

- - The second argument in `prioritisetransaction` has been renamed from `priority_delta` to `dummy` since Bitcoin Core no longer has a concept of coin age priority. The `dummy` argument has no functional effect, but is retained for positional argument compatibility. See [Removal of Coin Age Priority](#removal-of-coin-age-priority).

- - The `resendwallettransactions` RPC throws an error if the `-walletbroadcast` option is set to false (See [PR 10995](https://github.com/bitcoin/bitcoin/pull/10995)).

- - The second argument in the `submitblock` RPC argument has been renamed from `parameters` to `dummy`. This argument never had any effect, and the renaming is simply to communicate this fact to the user (See [PR 10191](https://github.com/bitcoin/bitcoin/pull/10191))
  (Clients should, however, use positional arguments for `submitblock` in order to be compatible with BIP 22.)

- - The `verbose` argument of `getblock` has been renamed to `verbosity` and now takes an integer from 0 to 2. Verbose level 0 is equivalent to `verbose=false`. Verbose level 1 is equivalent to `verbose=true`. Verbose level 2 will give the full transaction details of each transaction in the output as given by `getrawtransaction`. The old behavior of using the `verbose` named argument and a boolean value is still maintained for compatibility.

- - Error codes have been updated to be more accurate for the following error cases (See [PR 9853](https://github.com/bitcoin/bitcoin/pull/9853)):
  - `getblock` now returns RPC_MISC_ERROR if the block can't be found on disk (for
  example if the block has been pruned). Previously returned RPC_INTERNAL_ERROR.
  - `pruneblockchain` now returns RPC_MISC_ERROR if the blocks cannot be pruned
  because the node is not in pruned mode. Previously returned RPC_METHOD_NOT_FOUND.
  - `pruneblockchain` now returns RPC_INVALID_PARAMETER if the blocks cannot be pruned
  because the supplied timestamp is too late. Previously returned RPC_INTERNAL_ERROR.
  - `pruneblockchain` now returns RPC_MISC_ERROR if the blocks cannot be pruned
  because the blockchain is too short. Previously returned RPC_INTERNAL_ERROR.
  - `setban` now returns RPC_CLIENT_INVALID_IP_OR_SUBNET if the supplied IP address
  or subnet is invalid. Previously returned RPC_CLIENT_NODE_ALREADY_ADDED.
  - `setban` now returns RPC_CLIENT_INVALID_IP_OR_SUBNET if the user tries to unban
  a node that has not previously been banned. Previously returned RPC_MISC_ERROR.
  - `removeprunedfunds` now returns RPC_WALLET_ERROR if `bitcoind` is unable to remove
  the transaction. Previously returned RPC_INTERNAL_ERROR.
  - `removeprunedfunds` now returns RPC_INVALID_PARAMETER if the transaction does not
  exist in the wallet. Previously returned RPC_INTERNAL_ERROR.
  - `fundrawtransaction` now returns RPC_INVALID_ADDRESS_OR_KEY if an invalid change
  address is provided. Previously returned RPC_INVALID_PARAMETER.
  - `fundrawtransaction` now returns RPC_WALLET_ERROR if `bitcoind` is unable to create
  the transaction. The error message provides further details. Previously returned
  RPC_INTERNAL_ERROR.
  - `bumpfee` now returns RPC_INVALID_PARAMETER if the provided transaction has
  descendants in the wallet. Previously returned RPC_MISC_ERROR.
  - `bumpfee` now returns RPC_INVALID_PARAMETER if the provided transaction has
  descendants in the mempool. Previously returned RPC_MISC_ERROR.
  - `bumpfee` now returns RPC_WALLET_ERROR if the provided transaction has
  has been mined or conflicts with a mined transaction. Previously returned
  RPC_INVALID_ADDRESS_OR_KEY.
  - `bumpfee` now returns RPC_WALLET_ERROR if the provided transaction is not
  BIP 125 replaceable. Previously returned RPC_INVALID_ADDRESS_OR_KEY.
  - `bumpfee` now returns RPC_WALLET_ERROR if the provided transaction has already
  been bumped by a different transaction. Previously returned RPC_INVALID_REQUEST.
  - `bumpfee` now returns RPC_WALLET_ERROR if the provided transaction contains
  inputs which don't belong to this wallet. Previously returned RPC_INVALID_ADDRESS_OR_KEY.
  - `bumpfee` now returns RPC_WALLET_ERROR if the provided transaction has multiple change
  outputs. Previously returned RPC_MISC_ERROR.
  - `bumpfee` now returns RPC_WALLET_ERROR if the provided transaction has no change
  output. Previously returned RPC_MISC_ERROR.
  - `bumpfee` now returns RPC_WALLET_ERROR if the fee is too high. Previously returned
  RPC_MISC_ERROR.
  - `bumpfee` now returns RPC_WALLET_ERROR if the fee is too low. Previously returned
  RPC_MISC_ERROR.
  - `bumpfee` now returns RPC_WALLET_ERROR if the change output is too small to bump the
  fee. Previously returned RPC_MISC_ERROR.

0.15.0 Change log
=================

### RPC and other APIs
- - #9485 `61a640e` ZMQ example using python3 and asyncio (mcelrath)
- - #9894 `0496e15` remove 'label' filter for rpc command help (instagibbs)
- - #9853 `02bd6e9` Fix error codes from various RPCs (jnewbery)
- - #9842 `598ef9c` Fix RPC failure testing (continuation of #9707) (jnewbery)
- - #10038 `d34995a` Add mallocinfo mode to `getmemoryinfo` RPC (laanwj)
- - #9500 `3568b30` [Qt][RPC] Autocomplete commands for 'help' command in debug console (achow101)
- - #10056 `e6156a0` [zmq] Call va_end() on va_start()ed args (kallewoof)
- - #10086 `7438cea` Trivial: move rpcserialversion into RPC option group (jlopp)
- - #10150 `350b224` [rpc] Add logging rpc (jnewbery)
- - #10208 `393160c` [wallet] Rescan abortability (kallewoof)
- - #10143 `a987def` [net] Allow disconnectnode RPC to be called with node id (jnewbery)
- - #10281 `0e8499c` doc: Add RPC interface guidelines (laanwj)
- - #9733 `d4732f3` Add getchaintxstats RPC (sipa)
- - #10310 `f4b15e2` [doc] Add hint about getmempoolentry to getrawmempool help (kallewoof)
- - #8704 `96c850c` [RPC] Transaction details in getblock (achow101)
- - #8952 `9390845` Add query options to listunspent RPC call (pedrobranco)
- - #10413 `08ac35a` Fix docs (there's no rpc command setpaytxfee) (RHavar)
- - #8384 `e317c0d` Add witness data output to TxInError messages (instagibbs)
- - #9571 `4677151` RPC: getblockchaininfo returns BIP signaling statistics  (pinheadmz)
- - #10450 `ef2d062` Fix bumpfee rpc "errors" return value (ryanofsky)
- - #10475 `39039b1` [RPC] getmempoolinfo mempoolminfee is a BTC/KB feerate (instagibbs)
- - #10478 `296928e` rpc: Add listen address to incoming connections in `getpeerinfo` (laanwj)
- - #10403 `08d0390` Fix importmulti failure to return rescan errors (ryanofsky)
- - #9740 `9fec4da` Add friendly output to dumpwallet (aideca)
- - #10426 `16f6c98` Replace bytes_serialized with bogosize (sipa)
- - #10252 `980deaf` RPC/Mining: Restore API compatibility for prioritisetransaction (luke-jr)
- - #9672 `46311e7` Opt-into-RBF for RPC & bitcoin-tx (luke-jr)
- - #10481 `9c248e3` Decodehextx scripts sanity check  (achow101)
- - #10488 `fa1f106` Note that the prioritizetransaction dummy value is deprecated, and has no meaning (TheBlueMatt)
- - #9738 `c94b89e` gettxoutproof() should return consistent result (jnewbery)
- - #10191 `00350bd` [trivial] Rename unused RPC arguments 'dummy' (jnewbery)
- - #10627 `b62b4c8` fixed listunspent rpc convert parameter (tnakagawa)
- - #10412 `bef02fb` Improve wallet rescan API (ryanofsky)
- - #10400 `1680ee0` [RPC] Add an uptime command that displays the amount of time (in seconds) bitcoind has been running (rvelhote)
- - #10683 `d81bec7` rpc: Move the `generate` RPC call to rpcwallet (laanwj)
- - #10710 `30bc0f6` REST/RPC example update (Mirobit)
- - #10747 `9edda0c` [rpc] fix verbose argument for getblock in bitcoin-cli (jnewbery)
- - #10589 `104f5f2` More economical fee estimates for RBF and RPC options to control (morcos)
- - #10543 `b27b004` Change API to estimaterawfee (morcos)
- - #10807 `afd2fca` getbalance example covers at least 6 confirms (instagibbs)
- - #10707 `75b5643` Better API for estimatesmartfee RPC  (morcos)
- - #10784 `9e8d6a3` Do not allow users to get keys from keypool without reserving them (TheBlueMatt)
- - #10857 `d445a2c` [RPC] Add a deprecation warning to getinfo's output (achow101)
- - #10571 `adf170d` [RPC]Move transaction combining from signrawtransaction to new RPC (achow101)
- - #10783 `041dad9` [RPC] Various rpc argument fixes (instagibbs)
- - #9622 `6ef3c7e` [rpc] listsinceblock should include lost transactions when parameter is a reorg'd block (kallewoof)
- - #10799 `8537187` Prevent user from specifying conflicting parameters to fundrawtx (TheBlueMatt)
- - #10931 `0b11a07` Fix misleading "Method not found" multiwallet errors (ryanofsky)
- - #10788 `f66c596` [RPC] Fix addwitnessaddress by replacing ismine with producesignature (achow101)
- - #10999 `627c3c0` Fix amounts formatting in `decoderawtransaction` (laanwj)
- - #11002 `4268426` [wallet] return correct error code from resendwallettransaction (jnewbery)
- - #11029 `96a63a3` [RPC] trivial: gettxout no longer shows version of tx (FelixWeis)
- - #11083 `6c2b008` Fix combinerawtransaction RPC help result section (jonasnick)
- - #11027 `07164bb` [RPC] Only return hex field once in getrawtransaction (achow101)
- - #10698 `5af6572` Be consistent in calling transactions "replaceable" for Opt-In RBF (TheBlueMatt)

### Block and transaction handling
- - #9801 `a8c5751` Removed redundant parameter from mempool.PrioritiseTransaction (gubatron)
- - #9819 `1efc99c` Remove harmless read of unusued priority estimates (morcos)
- - #9822 `b7547fa` Remove block file location upgrade code (benma)
- - #9602 `30ff3a2` Remove coin age priority and free transactions - implementation (morcos)
- - #9548 `47510ad` Remove min reasonable fee (morcos)
- - #10249 `c73af54` Switch CCoinsMap from boost to std unordered_map (sipa)
- - #9966 `2a183de` Control mempool persistence using a command line parameter (jnewbery)
- - #10199 `318ea50` Better fee estimates (morcos)
- - #10196 `bee3529` Bugfix: PrioritiseTransaction updates the mempool tx counter (sdaftuar)
- - #10195 `1088b02` Switch chainstate db and cache to per-txout model (sipa)
- - #10284 `c2ab38b` Always log debug information for fee calculation in CreateTransaction (morcos)
- - #10503 `efbcf2b` Use REJECT_DUPLICATE for already known and conflicted txn (sipa)
- - #10537 `b3eb0d6` Few Minor per-utxo assert-semantics re-adds and tweak (TheBlueMatt)
- - #10626 `8c841a3` doc: Remove outdated minrelaytxfee comment (MarcoFalke)
- - #10559 `234ffc6` Change semantics of HaveCoinInCache to match HaveCoin (morcos)
- - #10581 `7878353` Simplify return values of GetCoin/HaveCoin(InCache) (sipa)
- - #10684 `a381f6a` Remove no longer used mempool.exists(outpoint) (morcos)
- - #10148 `d4e551a` Use non-atomic flushing with block replay (sipa)
- - #10685 `30c2130` Clarify CCoinsViewMemPool documentation (TheBlueMatt)
- - #10558 `90a002e` Address nits from per-utxo change (morcos)
- - #10706 `6859ad2` Improve wallet fee logic and fix GUI bugs (morcos)
- - #10526 `754aa02` Force on-the-fly compaction during pertxout upgrade (sipa)
- - #10985 `d896d5c` Add undocumented -forcecompactdb to force LevelDB compactions (sipa)
- - #10292 `e4bbd3d` Improved efficiency in COutPoint constructors (mm-s)
- - #10290 `8d6d43e` Add -stopatheight for benchmarking (sipa)

### P2P protocol and network code
- - #9726 `7639d38` netbase: Do not print an error on connection timeouts through proxy (laanwj)
- - #9805 `5b583ef` Add seed.btc.petertodd.org to mainnet DNS seeds (petertodd)
- - #9861 `22f609f` Trivial: Debug log ambiguity fix for peer addrs (keystrike)
- - #9774 `90cb2a2` Enable host lookups for -proxy and -onion parameters (jmcorgan)
- - #9558 `7b585cf` Clarify assumptions made about when BlockCheck is called (TheBlueMatt)
- - #10135 `e19586a` [p2p] Send the correct error code in reject messages (jnewbery)
- - #9665 `eab00d9` Use cached [compact] blocks to respond to getdata messages (TheBlueMatt)
- - #10215 `a077a90` Check interruptNet during dnsseed lookups (TheBlueMatt)
- - #10234 `faf2dea` [net] listbanned RPC and QT should show correct banned subnets (jnewbery)
- - #10134 `314ebdf` [qa] Fixes segwit block relay test after inv-direct-fetch was disabled (sdaftuar)
- - #10351 `3f57c55` removed unused code in INV message (Greg-Griffith)
- - #10061 `ae78609` [net] Added SetSocketNoDelay() utility function (tjps)
- - #10408 `28c6e8d` Net: Improvements to Tor control port parser (str4d)
- - #10460 `5c63d66` Broadcast address every day, not 9 hours (sipa)
- - #10471 `400fdd0` Denote functions CNode::GetRecvVersion() and CNode::GetRefCount()  as const (pavlosantoniou)
- - #10345 `67700b3` [P2P] Timeout for headers sync (sdaftuar)
- - #10564 `8d9f45e` Return early in IsBanned (gmaxwell)
- - #10587 `de8db47` Net: Fix resource leak in ReadBinaryFile(...) (practicalswift)
- - #9549 `b33ca14` [net] Avoid possibility of NULL pointer dereference in MarkBlockAsInFlight(...) (practicalswift)
- - #10446 `2772dc9` net: avoid extra dns query per seed (theuni)
- - #10824 `9dd6a2b` Avoid unnecessary work in SetNetworkActive (promag)
- - #10948 `df3a6f4` p2p: Hardcoded seeds update pre-0.15 branch (laanwj)
- - #10977 `02f4c4a` [net] Fix use of uninitialized value in getnetworkinfo(const JSONRPCRequest&) (practicalswift)
- - #10982 `c8b62c7` Disconnect network service bits 6 and 8 until Aug 1, 2018 (TheBlueMatt)
- - #11012 `0e5cff6` Make sure to clean up mapBlockSource if we've already seen the block (theuni)

### Validation
- - #9725 `67023e9` CValidationInterface Cleanups (TheBlueMatt)
- - #10178 `2584925` Remove CValidationInterface::UpdatedTransaction (TheBlueMatt)
- - #10201 `a6548a4` pass Consensus::Params& to functions in validation.cpp and make them static (mariodian)
- - #10297 `431a548` Simplify DisconnectBlock arguments/return value (sipa)
- - #10464 `f94b7d5` Introduce static DoWarning (simplify UpdateTip) (jtimon)
- - #10569 `2e7d8f8` Fix stopatheight (achow101)
- - #10192 `2935b46` Cache full script execution results in addition to signatures (TheBlueMatt)
- - #10179 `21ed30a` Give CValidationInterface Support for calling notifications on the CScheduler Thread (TheBlueMatt)
- - #10557 `66270a4` Make check to distinguish between orphan txs and old txs more efficient (morcos)
- - #10775 `7c2400c` nCheckDepth chain height fix (romanornr)
- - #10821 `16240f4` Add SSE4 optimized SHA256 (sipa)
- - #10854 `04d395e` Avoid using sizes on non-fixed-width types to derive protocol constants (gmaxwell)
- - #10945 `2a50b11` Update defaultAssumeValid according to release-process.md (gmaxwell)
- - #10986 `2361208` Update chain transaction statistics (sipa)
- - #11028 `6bdf4b3` Avoid masking of difficulty adjustment errors by checkpoints (sipa)
- - #9533 `cb598cf` Allow non-power-of-2 signature cache sizes (sipa)
- - #9208 `acd9957` Improve DisconnectTip performance (sdaftuar)
- - #10618 `f90603a` Remove confusing MAX_BLOCK_BASE_SIZE (gmaxwell)
- - #10758 `bd92424` Fix some chainstate-init-order bugs (TheBlueMatt)
- - #10550 `b7296bc` Don't return stale data from CCoinsViewCache::Cursor() (ryanofsky)
- - #10998 `2507fd5` Fix upgrade cancel warnings (TheBlueMatt)
- - #9868 `cbdb473` Abstract out the command line options for block assembly (sipa)

### Build system
- - #9727 `5f0556d` Remove fallbacks for boost_filesystem < v3 (laanwj)
- - #9788 `50a2265` gitian: bump descriptors for master (theuni)
- - #9794 `7ca2f54` Minor update to qrencode package builder (mitchellcash)
- - #9514 `2cc0df1` release: Windows signing script (theuni)
- - #9921 `8b789d8` build: Probe MSG_DONTWAIT in the same way as MSG_NOSIGNAL (laanwj)
- - #10011 `32d1b34` build: Fix typo s/HAVE_DONTWAIT/HAVE_MSG_DONTWAIT (laanwj)
- - #9946 `90dd9e6` Fix build errors if spaces in path or parent directory (pinheadmz)
- - #10136 `81da4c7` build: Disable Wshadow warning (laanwj)
- - #10166 `64962ae` Ignore Doxyfile generated from Doxyfile.in template (paveljanik)
- - #10239 `0416ea9` Make Boost use std::atomic internally (sipa)
- - #10228 `27faa6c` build: regenerate bitcoin-config.h as necessary (theuni)
- - #10273 `8979f45` [scripts] Minor improvements to `macdeployqtplus` script (chrisgavin)
- - #10325 `a26280b` 0.15.0 Depends Updates (fanquake)
- - #10328 `79aeff6` Update contrib/debian to latest Ubuntu PPA upload (TheBlueMatt)
- - #7522 `d25449f` Bugfix: Only use git for build info if the repository is actually the right one (luke-jr)
- - #10489 `e654d61` build: silence gcc7's implicit fallthrough warning (theuni)
- - #10549 `ad1a13e` Avoid printing generic and duplicated "checking for QT" during ./configure (drizzt)
- - #10628 `8465b68` [depends] expat 2.2.1 (fanquake)
- - #10806 `db825d2` build: verify that the assembler can handle crc32 functions (theuni)
- - #10766 `b4d03be` Building Environment: Set ARFLAGS to cr (ReneNyffenegger)
- - #10803 `91edda8` Explicitly search for bdb5.3 (pstratem)
- - #10855 `81560b0` random: only use getentropy on openbsd (theuni)
- - #10508 `1caafa6` Run Qt wallet tests on travis (ryanofsky)
- - #10851 `e222618` depends: fix fontconfig with newer glibc (theuni)
- - #10971 `88b1e4b` build: fix missing sse42 in depends builds (theuni)
- - #11097 `129b03f` gitian: quick hack to fix version string in releases (theuni)
- - #10039 `919aaf6` Fix compile errors with Qt 5.3.2 and Boost 1.55.0 (ryanofsky)
- - #10168 `7032021` Fix build warning from #error text (jnewbery)
- - #10301 `318392c` Check if sys/random.h is required for getentropy (jameshilliard)

### GUI
- - #9724 `1a9fd5c` Qt/Intro: Add explanation of IBD process (luke-jr)
- - #9834 `b00ba62` qt: clean up initialize/shutdown signals (benma)
- - #9481 `ce01e62` [Qt] Show more significant warning if we fall back to the default fee (jonasschnelli)
- - #9974 `b9f930b` Add basic Qt wallet test (ryanofsky)
- - #9690 `a387d3a` Change 'Clear' button string to 'Reset' (da2x)
- - #9592 `9c7b7cf` [Qt] Add checkbox in the GUI to opt-in to RBF when creating a transaction (ryanofsky)
- - #10098 `2b477e6` Make qt wallet test compatible with qt4 (ryanofsky)
- - #9890 `1fa4ae6` Add a button to open the config file in a text editor (ericshawlinux)
- - #10156 `51833a1` Fix for issues with startup and multiple monitors on windows (AllanDoensen)
- - #10177 `de01da7` Changed "Send" button default status from true to false (KibbledJiveElkZoo)
- - #10221 `e96486c` Stop treating coinbase outputs differently in GUI: show them at 1conf (TheBlueMatt)
- - #10231 `987a6c0` [Qt] Reduce a significant cs_main lock freeze (jonasschnelli)
- - #10242 `f6f3b58` [qt] Don't call method on null WalletModel object (ryanofsky)
- - #10093 `a3e756b` [Qt] Don't add arguments of sensitive command to console window (jonasschnelli)
- - #10362 `95546c8` [GUI] Add OSX keystroke to RPCConsole info (spencerlievens)
- - #9697 `962cd3f` [Qt] simple fee bumper with user verification (jonasschnelli)
- - #10390 `e477516` [wallet] remove minimum total fee option (instagibbs)
- - #10420 `4314544` Add Qt tests for wallet spends & bumpfee (ryanofsky)
- - #10454 `c1c9a95` Fix broken q4 test build (ryanofsky)
- - #10449 `64beb13` Overhaul Qt fee bumper (jonasschnelli)
- - #10582 `7c72fb9` Pass in smart fee slider value to coin control dialog (morcos)
- - #10673 `4c72cc3` [qt] Avoid potential null pointer dereference in TransactionView::exportClicked() (practicalswift)
- - #10769 `8fdd23a` [Qt] replace fee slider with a Dropdown, extend conf. targets (jonasschnelli)
- - #10870 `412b466` [Qt] Use wallet 0 in rpc console if running with multiple wallets (jonasschnelli)
- - #10988 `a9dd111` qt: Increase BLOCK_CHAIN_SIZE constants (laanwj)
- - #10644 `e292140` Slightly overhaul NSI pixmaps (jonasschnelli)
- - #10660 `0c3542e` Allow to cancel the txdb upgrade via splashscreen keypress 'q' (jonasschnelli)

### Wallet
- - #9359 `f7ec7cf` Add test for CWalletTx::GetImmatureCredit() returning stale values (ryanofsky)
- - #9576 `56ab672` [wallet] Remove redundant initialization (practicalswift)
- - #9333 `fa625b0` Document CWalletTx::mapValue entries and remove erase of nonexistent "version" entry (ryanofsky)
- - #9906 `72fb515` Disallow copy constructor CReserveKeys (instagibbs)
- - #9369 `3178b2c` Factor out CWallet::nTimeSmart computation into a method (ryanofsky)
- - #9830 `afcd7c0` Add safe flag to listunspent result (NicolasDorier)
- - #9993 `c49355c` Initialize nRelockTime (pstratem)
- - #9818 `3d857f3` Save watch only key timestamps when reimporting keys (ryanofsky)
- - #9294 `f34cdcb` Use internal HD chain for change outputs (hd split) (jonasschnelli)
- - #10164 `e183ea2` Wallet: reduce excess logic InMempool() (kewde)
- - #10186 `c9ff4f8` Remove SYNC_TRANSACTION_NOT_IN_BLOCK magic number (jnewbery)
- - #10226 `64c45aa` wallet: Use boost to more portably ensure -wallet specifies only a filename (luke-jr)
- - #9827 `c91ca0a` Improve ScanForWalletTransactions return value (ryanofsky)
- - #9951 `fa1ac28` Wallet database handling abstractions/simplifications (laanwj)
- - #10265 `c29a0d4` [wallet] [moveonly] Check non-null pindex before potentially referencing (kallewoof)
- - #10283 `a550f6e` Cleanup: reduce to one GetMinimumFee call signature (morcos)
- - #10294 `e2b99b1` [Wallet] unset change position when there is no change (instagibbs)
- - #10115 `d3dce0e` Avoid reading the old hd master key during wallet encryption (TheBlueMatt)
- - #10341 `18c9deb` rpc/wallet: Workaround older UniValue which returns a std::string temporary for get_str (luke-jr)
- - #10308 `94e5227` [wallet] Securely erase potentially sensitive keys/values (tjps)
- - #10257 `ea1fd43` [test] Add test for getmemoryinfo (jimmysong)
- - #10295 `ce8176d` [qt] Move some WalletModel functions into CWallet (ryanofsky)
- - #10506 `7cc2c67` Fix bumpfee test after #10449 (ryanofsky)
- - #10500 `098b01d` Avoid CWalletTx copies in GetAddressBalances and GetAddressGroupings (ryanofsky)
- - #10455 `0747d33` Simplify feebumper minimum fee code slightly (ryanofsky)
- - #10522 `2805d60` [wallet] Remove unused variables (practicalswift)
- - #8694 `177433a` Basic multiwallet support (luke-jr)
- - #10598 `7a74f88` Supress struct/class mismatch warnings introduced in #10284 (paveljanik)
- - #9343 `209eef6` Don't create change at dust limit (morcos)
- - #10744 `ed88e31` Use method name via __func__ macro (darksh1ne)
- - #10712 `e8b9523` Add change output if necessary to reduce excess fee (morcos)
- - #10816 `1c011ff` Properly forbid -salvagewallet and -zapwallettxes for multi wallet (morcos)
- - #10235 `5cfdda2` Track keypool entries as internal vs external in memory (TheBlueMatt)
- - #10330 `bf0a08b` [wallet] fix zapwallettxes interaction with persistent mempool (jnewbery)
- - #10831 `0b01935` Batch flushing operations to the walletdb during top up and increase keypool size (gmaxwell)
- - #10795 `7b6e8bc` No longer ever reuse keypool indexes (TheBlueMatt)
- - #10849 `bde4f93` Multiwallet: simplest endpoint support (jonasschnelli)
- - #10817 `9022aa3` Redefine Dust and add a discard_rate (morcos)
- - #10883 `bf3b742` Rename -usewallet to -rpcwallet (morcos)
- - #10604 `420238d` [wallet] [tests] Add listwallets RPC, include wallet name in `getwalletinfo` and add multiwallet test (jnewbery)
- - #10885 `70888a3` Reject invalid wallets (promag)
- - #10949 `af56397` Clarify help message for -discardfee (morcos)
- - #10942 `2e857bb` Eliminate fee overpaying edge case when subtracting fee from recipients (morcos)
- - #10995 `fa64636` Fix resendwallettransactions assert failure if -walletbroadcast=0 (TheBlueMatt)
- - #11022 `653a46d` Basic keypool topup (jnewbery)
- - #11081 `9fe1f6b` Add length check for CExtKey deserialization (jonasschnelli, guidovranken)
- - #11044 `4ef8374` [wallet] Keypool topup cleanups (jnewbery)
- - #11145 `e51bb71` Fix rounding bug in calculation of minimum change (morcos)
- - #9605 `779f2f9` Use CScheduler for wallet flushing, remove ThreadFlushWalletDB (TheBlueMatt)
- - #10108 `4e3efd4` ApproximateBestSubset should take inputs by reference, not value (RHavar)

### Tests and QA
- - #9744 `8efd1c8` Remove unused module from rpc-tests (34ro)
- - #9657 `7ff4a53` Improve rpc-tests.py (jnewbery)
- - #9766 `7146d96` Add --exclude option to rpc-tests.py (jnewbery)
- - #9577 `d6064a8` Fix docstrings in qa tests (jnewbery)
- - #9823 `a13a417` qa: Set correct path for binaries in rpc tests (MarcoFalke)
- - #9847 `6206252` Extra test vector for BIP32 (sipa)
- - #9350 `88c2ae3` [Trivial] Adding label for amount inside of tx_valid/tx_invalid.json (Christewart)
- - #9888 `36afd4d` travis: Verify commits only for one target (MarcoFalke)
- - #9904 `58861ad` test: Fail if InitBlockIndex fails (laanwj)
- - #9828 `67c5cc1` Avoid -Wshadow warnings in wallet_tests (ryanofsky)
- - #9832 `48c3429` [qa] assert_start_raises_init_error (NicolasDorier)
- - #9739 `9d5fcbf` Fix BIP68 activation test (jnewbery)
- - #9547 `d32581c` bench: Assert that division by zero is unreachable (practicalswift)
- - #9843 `c78adbf` Fix segwit getblocktemplate test (jnewbery)
- - #9929 `d5ce14e` tests: Delete unused function _rpchost_to_args (laanwj)
- - #9555 `19be26a` [test] Avoid reading a potentially uninitialized variable in tx_invalid-test (transaction_tests.cpp) (practicalswift)
- - #9945 `ac23a7c` Improve logging in bctest.py if there is a formatting mismatch (jnewbery)
- - #9768 `8910b47` [qa] Add logging to test_framework.py (jnewbery)
- - #9972 `21833f9` Fix extended rpc tests broken by #9768 (jnewbery)
- - #9977 `857d1e1` QA: getblocktemplate_longpoll.py should always use >0 fee tx (sdaftuar)
- - #9970 `3cc13ea` Improve readability of segwit.py, smartfees.py (sdaftuar)
- - #9497 `2c781fb` CCheckQueue Unit Tests (JeremyRubin)
- - #10024 `9225de2` [trivial] Use log.info() instead of print() in remaining functional test cases (jnewbery)
- - #9956 `3192e52` Reorganise qa directory (jnewbery)
- - #10017 `02d64bd` combine_logs.py - aggregates log files from multiple bitcoinds during functional tests (jnewbery)
- - #10047 `dfef6b6` [tests] Remove unused variables and imports (practicalswift)
- - #9701 `a230b05` Make bumpfee tests less fragile (ryanofsky)
- - #10053 `ca20923` [test] Allow functional test cases to be skipped (jnewbery)
- - #10052 `a0b1e57` [test] Run extended tests once daily in Travis (jnewbery)
- - #10069 `1118493` [QA] Fix typo in fundrawtransaction test (NicolasDorier)
- - #10083 `c044f03` [QA] Renaming rawTx into rawtx (NicolasDorier)
- - #10073 `b1a4f27` Actually run assumevalid.py (jnewbery)
- - #9780 `c412fd8` Suppress noisy output from qa tests in Travis (jnewbery)
- - #10096 `79af9fb` Check that all test scripts in test/functional are being run (jnewbery)
- - #10076 `5b029aa` [qa] combine_logs: Use ordered list for logfiles (MarcoFalke)
- - #10107 `f2734c2` Remove unused variable. Remove accidental trailing semicolons in Python code (practicalswift)
- - #10109 `8ac8041` Remove SingleNodeConnCB (jnewbery)
- - #10114 `edc62c9` [tests] sync_with_ping should assert that ping hasn't timed out (jnewbery)
- - #10128 `427d2fd` Speed Up CuckooCache tests (JeremyRubin)
- - #10072 `12af74b` Remove sources of unreliablility in extended functional tests (jnewbery)
- - #10077 `ebfd653` [qa] Add setnetworkactive smoke test (MarcoFalke)
- - #10152 `080d7c7` [trivial] remove unused line in Travis config (jnewbery)
- - #10159 `df1ca9e` [tests] color test results and sort alphabetically (jnewbery)
- - #10124 `88799ea` [test] Suppress test logging spam (jnewbery)
- - #10142 `ed09dd3` Run bitcoin_test-qt under minimal QPA platform (ryanofsky)
- - #9949 `a27dbc5` [bench] Avoid function call arguments which are pointers to uninitialized values (practicalswift)
- - #10187 `b44adf9` tests: Fix test_runner return value in case of skipped test (laanwj)
- - #10197 `d86bb07` [tests] Functional test warnings (jnewbery)
- - #10219 `9111df9` Tests: Order Python Tests Differently (jimmysong)
- - #10229 `f3db4c6` Tests: Add test for getdifficulty (jimmysong)
- - #10224 `2723bcd` [test] Add test for getaddednodeinfo (jimmysong)
- - #10023 `c530c15` [tests] remove maxblocksinflight.py (functionality covered by other test) (jnewbery)
- - #10097 `1b25b6d` Move zmq test skipping logic into individual test case (jnewbery)
- - #10272 `54e2d87` [Tests] Prevent warning: variable 'x' is uninitialized (paveljanik)
- - #10225 `e0a7e19` [test] Add aborttrescan tests (kallewoof)
- - #10278 `8254a8a` [test] Add Unit Test for GetListenPort (jimmysong)
- - #10280 `47535d7` [test] Unit test amount.h/amount.cpp (jimmysong)
- - #10256 `80c3a73` [test] Add test for gettxout to wallet.py (jimmysong)
- - #10264 `492d22f` [test] Add tests for getconnectioncount, getnettotals and ping (jimmysong)
- - #10169 `8f3e384` [tests] Remove func test code duplication (jnewbery)
- - #10198 `dc8fc0c` [tests] Remove is_network_split from functional test framework (jnewbery)
- - #10255 `3c5e6c9` [test] Add test for listaddressgroupings (jimmysong)
- - #10137 `75171f0` Remove unused import. Remove accidental trailing semicolons (practicalswift)
- - #10307 `83073de` [tests] allow zmq test to be run in out-of-tree builds (jnewbery)
- - #10344 `e927483` [tests] Fix abandonconflict.py intermittency (jnewbery)
- - #10318 `170bc2c` [tests] fix wait_for_inv() (jnewbery)
- - #10171 `fff72de` [tests] Add node methods to test framework (jnewbery)
- - #10352 `23d78c4` test: Add elapsed time to RPC tracing (laanwj)
- - #10342 `6a796b2` [tests] Improve mempool_persist test (jnewbery)
- - #10287 `776ba23` [tests] Update Unit Test for addrman.h/addrman.cpp (jimmysong)
- - #10365 `7ee5236` [tests] increase timeouts in sendheaders test (jnewbery)
- - #10361 `f6241b3` qa: disablewallet: Check that wallet is really disabled (MarcoFalke)
- - #10371 `4b766fc` [tests] Clean up addrman_tests.cpp (jimmysong)
- - #10253 `87abe20` [test] Add test for getnetworkhashps (jimmysong)
- - #10376 `8bd16ee` [tests] fix disconnect_ban intermittency (jnewbery)
- - #10374 `5411997` qa: Warn when specified test is not found (MarcoFalke)
- - #10405 `0542978` tests: Correct testcase in script_tests.json for large number OP_EQUAL (laanwj)
- - #10429 `6b99daf` tests: fix spurious addrman test failure (theuni)
- - #10433 `8e57256` [tests] improve tmpdir structure (jnewbery)
- - #10415 `217b416` [tests] Speed up fuzzing by ~200x when using afl-fuzz (practicalswift)
- - #10445 `b4b057a` Add test for empty chain and reorg consistency for gettxoutsetinfo (gmaxwell)
- - #10423 `1aefc94` [tests] skipped tests should clean up after themselves (jnewbery)
- - #10359 `329fc1d` [tests] functional tests should call BitcoinTestFramework start/stop node methods (jnewbery)
- - #10514 `e103b3f` Bugfix: missing == 0 after randrange (sipa)
- - #10515 `c871f32` [test] Add test for getchaintxstats (jimmysong)
- - #10509 `bea5b00` Remove xvfb configuration from travis (ryanofsky)
- - #10535 `30853e1` [qa] fundrawtx: Fix shutdown race (MarcoFalke)
- - #9909 `300f8e7` tests: Add FindEarliestAtLeast test for edge cases (ryanofsky)
- - #10331 `75e898c` Share config between util and functional tests (jnewbery)
- - #10321 `e801084` Use FastRandomContext for all tests (sipa)
- - #10524 `6c2d81f` [tests] Remove printf(...) (practicalswift)
- - #10547 `71ab6e5` [tests] Use FastRandomContext instead of boost::random::{mt19937,uniform_int_distribution} (practicalswift)
- - #10551 `6702617` [Tests] Wallet encryption functional tests (achow101)
- - #10555 `643fa0b` [tests] various improvements to zmq_test.py (jnewbery)
- - #10533 `d083bd9` [tests] Use cookie auth instead of rpcuser and rpcpassword (achow101)
- - #10632 `c68a9a6` qa: Add stopatheight test (MarcoFalke)
- - #10636 `4bc853b` [qa] util: Check return code after closing bitcoind proc (MarcoFalke)
- - #10662 `e0a7801` Initialize randomness in benchmarks (achow101)
- - #10612 `7c87a9c` The young person's guide to the test_framework (jnewbery)
- - #10659 `acb1153` [qa] blockchain: Pass on closed connection during generate call (MarcoFalke)
- - #10690 `416af3e` [qa] Bugfix: allow overriding extra_args in ComparisonTestFramework (sdaftuar)
- - #10556 `65cc7aa` Move stop/start functions from utils.py into BitcoinTestFramework (jnewbery)
- - #10704 `dd07f47` [tests] nits in dbcrash.py (jnewbery)
- - #10743 `be82498` [test] don't run dbcrash.py on Travis (jnewbery)
- - #10761 `d3b5870` [tests] fix replace_by_fee.py (jnewbery)
- - #10759 `1d4805c` Fix multi_rpc test for hosts that dont default to utf8 (TheBlueMatt)
- - #10190 `e4f226a` [tests] mining functional tests (including regression test for submitblock) (jnewbery)
- - #10739 `1fc783f` test: Move variable `state` down where it is used (paveljanik)
- - #9980 `fee0d80` Fix mem access violation merkleblock (Christewart)
- - #10893 `0c173a1` [QA] Avoid running multiwallet.py twice (jonasschnelli)
- - #10927 `9d5e8f9` test: Make sure wallet.backup is created in temp path (laanwj)
- - #10899 `f29d5db` [test] Qt: Use _putenv_s instead of setenv on Windows builds (brianmcmichael)
- - #10912 `5c8eb79` [tests] Fix incorrect memory_cleanse(?) call in crypto_tests.cpp (practicalswift)
- - #11001 `fa8a063` [tests] Test disconnecting unsupported service bits logic (jnewbery)
- - #10695 `929fd72` [qa] Rewrite BIP65/BIP66 functional tests (sdaftuar)
- - #10963 `ecd2135` [bench] Restore format state of cout after printing with std::fixed/setprecision (practicalswift)
- - #11025 `e5d26e4` qa: Fix inv race in example_test (MarcoFalke)
- - #10765 `2c811e0` Tests: address placement should be deterministic by default (ReneNyffenegger)
- - #11000 `ac016e1` test: Add resendwallettransactions functional tests (promag)
- - #11032 `aeb3175` [qa] Fix block message processing error in sendheaders.py (sdaftuar)
- - #10105 `0b9fb68` [tests] fixup - make all Travis test runs quiet, non just cron job runs (jnewbery)
- - #10222 `6ce7337` [tests] test_runner - check unicode (jnewbery)
- - #10327 `35da2ae` [tests] remove import-abort-rescan.py (jnewbery)
- - #11023 `bf74d37` [tests] Add option to attach a python debugger if functional test fails (jnewbery)
- - #10565 `8c2098a` [coverage] Remove subtrees and benchmarks from coverage report (achow101)

### Miscellaneous
- - #9871 `be8ba2c` Add a tree sha512 hash to merge commits (sipa)
- - #9821 `d19d45a` util: Specific GetOSRandom for Linux/FreeBSD/OpenBSD (laanwj)
- - #9903 `ba80a68` Docs: add details to -rpcclienttimeout doc (ian-kelling)
- - #9910 `53c300f` Docs: correct and elaborate -rpcbind doc (ian-kelling)
- - #9905 `01b7cda` [contrib] gh-merge: Move second sha512 check to the end (MarcoFalke)
- - #9880 `4df8213` Verify Tree-SHA512s in merge commits, enforce sigs are not SHA1 (TheBlueMatt)
- - #9932 `00c13ea` Fix verify-commits on travis and always check top commit's tree (TheBlueMatt)
- - #9952 `6996e06` Add historical release notes for 0.14.0 (laanwj)
- - #9940 `fa99663` Fix verify-commits on OSX, update for new bad Tree-SHA512, point travis to different keyservers (TheBlueMatt)
- - #9963 `8040ae6` util: Properly handle errors during log message formatting (laanwj)
- - #9984 `cce056d` devtools: Make github-merge compute SHA512 from git, instead of worktree (laanwj)
- - #9995 `8bcf934` [doc] clarify blockchain size and pruning (askmike)
- - #9734 `0c17afc` Add updating of chainTxData to release process (sipa)
- - #10063 `530fcbd` add missing spaces so that markdown recognizes headline (flack)
- - #10085 `db1ae54` Docs: remove 'noconnect' option (jlopp)
- - #10090 `8e4f7e7` Update bitcoin.conf with example for pruning (coinables)
- - #9424 `1a5aaab` Change LogAcceptCategory to use uint32_t rather than sets of strings (gmaxwell)
- - #10036 `fbf36ca` Fix init README format to render correctly on github (jlopp)
- - #10058 `a2cd0b0` No need to use OpenSSL malloc/free (tjps)
- - #10123 `471ed00` Allow debug logs to be excluded from specified component (jnewbery)
- - #10104 `fadf078` linearize script: Option to use RPC cookie (achow101)
- - #10162 `a3a2160` [trivial] Log calls to getblocktemplate (jnewbery)
- - #10155 `928695b` build: Deduplicate version numbers (laanwj)
- - #10211 `a86255b` [doc] Contributor fixes & new "finding reviewers" section (kallewoof)
- - #10250 `1428f30` Fix some empty vector references (sipa)
- - #10270 `95f5e44` Remove Clang workaround for Boost 1.46 (fanquake)
- - #10263 `cb007e4` Trivial: fix fee estimate write error log message (CryptAxe)
- - #9670 `bd9ec0e` contrib: github-merge improvements (laanwj)
- - #10260 `1d75597` [doc] Minor corrections to osx dependencies (fanquake)
- - #10189 `750c5a5` devtools/net: add a verifier for scriptable changes. Use it to make CNode::id private (theuni)
- - #10322 `bc64b5a` Use hardware timestamps in RNG seeding (sipa)
- - #10381 `7f2b9e0` Shadowing warnings are not enabled by default, update doc accordingly (paveljanik)
- - #10380 `b6ee855` [doc] Removing comments about dirty entries on txmempool (madeo)
- - #10383 `d0c37ee` [logging] log system time and mock time (jnewbery)
- - #10404 `b45a52a` doc: Add logging to FinalizeNode() (sdaftuar)
- - #10388 `526e839` Output line to debug.log when IsInitialBlockDownload latches to false (morcos)
- - #10372 `15254e9` Add perf counter data to GetStrongRandBytes state in scheduler (TheBlueMatt)
- - #10461 `55b72f3` Update style guide (sipa)
- - #10486 `10e8c0a` devtools: Retry after signing fails in github-merge (laanwj)
- - #10447 `f259263` Make bitcoind invalid argument error message specific (laanwj)
- - #10495 `6a38b79` contrib: Update location of seeds.txt (laanwj)
- - #10469 `b6b150b` Fixing typo in rpcdump.cpp help message (keystrike)
- - #10451 `27b9931` contrib/init/bitcoind.openrcconf: Don't disable wallet by default (luke-jr)
- - #10323 `00d3692` Update to latest libsecp256k1 master (sipa)
- - #10422 `cec9e1e` Fix timestamp in fee estimate debug message (morcos)
- - #10566 `5d034ee` [docs] Use the "domain name setup" image (previously unused) in the gitian docs (practicalswift)
- - #10534 `a514ac3` Clarify prevector::erase and avoid swap-to-clear (sipa)
- - #10575 `22ec768` Header include guideline (sipa)
- - #10480 `fbf5d3b` Improve commit-check-script.sh (sipa)
- - #10502 `1ad3d4e` scripted-diff: Remove BOOST_FOREACH, Q_FOREACH and PAIRTYPE (jtimon)
- - #10377 `b63be2c` Use rdrand as entropy source on supported platforms (sipa)
- - #9895 `228c319` Turn TryCreateDirectory() into TryCreateDirectories() (benma)
- - #10602 `d76e84a` Make clang-format use C++11 features (e.g. A<A<int>> instead of A<A<int> >) (practicalswift)
- - #10623 `c38f540` doc: Add 0.14.2 release notes (MarcoFalke)
- - #10276 `b750b33` contrib/verifybinaries: allow filtering by platform (knocte)
- - #10248 `01c4b14` Rewrite addrdb with less duplication using CHashVerifier (sipa)
- - #10577 `232508f` Add an explanation of quickly hashing onto a non-power of two range (gmaxwell)
- - #10608 `eee398f` Add a comment explaining the use of MAX_BLOCK_BASE_SIZE (gmaxwell)
- - #10728 `7397af9` fix typo in help text for removeprunedfunds (AkioNak)
- - #10193 `6dbcc74` scripted-diff: Remove #include <boost/foreach.hpp> (jtimon)
- - #10676 `379aed0` document script-based return fields for validateaddress (instagibbs)
- - #10651 `cef4b5c` Verify binaries from bitcoincore.org and bitcoin.org (TheBlueMatt)
- - #10786 `ca4c545` Add PR description to merge commit in github-merge.py (sipa)
- - #10812 `c5904e8` [utils] Allow bitcoin-cli's -rpcconnect option to be used with square brackets (jnewbery)
- - #10842 `3895e25` Fix incorrect Doxygen tag (@ince ? @since). Doxygen parameter name matching (practicalswift)
- - #10681 `df0793f` add gdb attach process to test README (instagibbs)
- - #10789 `1124328` Punctuation/grammer fixes in rpcwallet.cpp (stevendlander)
- - #10655 `78f307b` Properly document target_confirmations in listsinceblock (RHavar)
- - #10917 `5c003cb` developer-notes: add reference to snake_case and PascalCase (benma)
- - #11003 `4b5a7ce` Docs: Capitalize bullet points in CONTRIBUTING guide (eklitzke)
- - #10968 `98aa3f6` Add instructions for parallel gitian builds (coblee)
- - #11076 `1c4b9b3` 0.15 release-notes nits: fix redundancy, remove accidental parenthesis & fix range style (practicalswift)
- - #11090 `8f0121c` Update contributor names in release-notes.md (Derek701)
- - #11056 `cbdd338` disable jni in builds (instagibbs)
- - #11080 `2b59cfb` doc: Update build-openbsd for 6.1 (laanwj)
- - #11119 `0a6af47` [doc] build-windows: Mention that only trusty works (MarcoFalke)
- - #11108 `e8ad101` Changing -txindex requires -reindex, not -reindex-chainstate (TheBlueMatt)
- - #9792 `342b9bc` FastRandomContext improvements and switch to ChaCha20 (sipa)
- - #9505 `67ed40e` Prevector Quick Destruct (JeremyRubin)
- - #10820 `ef37f20` Use cpuid intrinsics instead of asm code (sipa)
- - #9999 `a328904` [LevelDB] Plug leveldb logs to bitcoin logs (NicolasDorier)
- - #9693 `c5e9e42` Prevent integer overflow in ReadVarInt (gmaxwell)
- - #10129 `351d0ad` scheduler: fix sub-second precision with boost < 1.50 (theuni)
- - #10153 `fade788` logging: Fix off-by-one for shrinkdebugfile default (MarcoFalke)
- - #10305 `c45da32` Fix potential NPD introduced in b297426c (TheBlueMatt)
- - #10338 `daf3e7d` Maintain state across GetStrongRandBytes calls (sipa)
- - #10544 `a4fe077` Update to LevelDB 1.20 (sipa)
- - #10614 `cafe24f` random: fix crash on some 64bit platforms (theuni)
- - #10714 `2a09a38` Avoid printing incorrect block indexing time due to uninitialized variable (practicalswift)
- - #10837 `8bc6d1f` Fix resource leak on error in GetDevURandom (corebob)
- - #10832 `89bb036` init: Factor out AppInitLockDataDirectory and fix startup core dump issue (laanwj)
- - #10914 `b995a37` Add missing lock in CScheduler::AreThreadsServicingQueue() (TheBlueMatt)
- - #10958 `659c096` Update to latest Bitcoin patches for LevelDB (sipa)
- - #10919 `c1c671f` Fix more init bugs (TheBlueMatt)

Credits
=======

Thanks to everyone who directly contributed to this release:

- - ??? ??
- - Ahmad Kazi
- - aideca
- - Akio Nakamura
- - Alex Morcos
- - Allan Doensen
- - Andres G. Aragoneses
- - Andrew Chow
- - Angel Leon
- - Awemany
- - Bob McElrath
- - Brian McMichael
- - BtcDrak
- - Charlie Lee
- - Chris Gavin
- - Chris Stewart
- - Cory Fields
- - CryptAxe
- - Dag Robole
- - Daniel Aleksandersen
- - Daniel Cousens
- - darksh1ne
- - Dimitris Tsapakidis
- - Eric Shaw
- - Evan Klitzke
- - fanquake
- - Felix Weis
- - flack
- - Guido Vranken
- - Greg Griffith
- - Gregory Maxwell
- - Gregory Sanders
- - Ian Kelling
- - Jack Grigg
- - James Evans
- - James Hilliard
- - Jameson Lopp
- - Jeremy Rubin
- - Jimmy Song
- - Jo?o Barbosa
- - Johnathan Corgan
- - John Newbery
- - Jonas Schnelli
- - Jorge Tim?n
- - Karl-Johan Alm
- - kewde
- - KibbledJiveElkZoo
- - Kirit Thadaka
- - kobake
- - Kyle Honeycutt
- - Lawrence Nahum
- - Luke Dashjr
- - Marco Falke
- - Marcos Mayorga
- - Marijn Stollenga
- - Mario Dian
- - Mark Friedenbach
- - Marko Bencun
- - Masahiko Hyuga
- - Matt Corallo
- - Matthew Zipkin
- - Matthias Grundmann
- - Michael Goldstein
- - Michael Rotarius
- - Mikerah
- - Mike van Rossum
- - Mitchell Cash
- - Nicolas Dorier
- - Patrick Strateman
- - Pavel Jan?k
- - Pavlos Antoniou
- - Pavol Rusnak
- - Pedro Branco
- - Peter Todd
- - Pieter Wuille
- - practicalswift
- - Ren? Nyffenegger
- - Ricardo Velhote
- - romanornr
- - Russell Yanofsky
- - Rusty Russell
- - Ryan Havar
- - shaolinfry
- - Shigeya Suzuki
- - Simone Madeo
- - Spencer Lievens
- - Steven D. Lander
- - Suhas Daftuar
- - Takashi Mitsuta
- - Thomas Snider
- - Timothy Redaelli
- - tintinweb
- - tnaka
- - Warren Togami
- - Wladimir J. van der Laan

As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2

iQEcBAEBCgAGBQJZuoHVAAoJEB5K7WKYbNJdQRoH/2EAaO/tuR/TI8UGRrBYQzUy
WkEnctcx4XjrTS0FPssxrYKsndHaksgmJObpgUnzdiKbytRRQH/8A0W5izVE4Ojv
CzUZOX7MTSwyfzPFQRvSCzRANY0bSDgvT+A1TBRmkce/43UDZZma82mMl2vz8wL5
czKryyFsNzrB2qn6juRZQlUcmGGBZ298YG8SPx/aobIY/9DKDEkPCNnBe8d7XdT0
oAQ52pLmZ56E+QYkn0LYdc32dd4xizpQy7WIJgSQY4r54HWmEFY9ZE21aQjwMOET
tReNzae4mXh3T0Yja3DgDkQrbgqNuYRtnLWgfmYinwFo+JN5ujDZwNpcP5jnBa0=
=4llb
-----END PGP SIGNATURE-----

From dan at osc.co.cr  Wed Sep 13 09:50:53 2017
From: dan at osc.co.cr (Dan Libby)
Date: Wed, 13 Sep 2017 02:50:53 -0700
Subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?
Message-ID: <9e212eae-08d5-d083-80d9-a8e29679fcdc@osc.co.cr>

Hi, I am interested in the possibility of a cryptocurrency software
(future bitcoin or a future altcoin) that strives to have immutable
consensus rules.

The goal of such a cryptocurrency would not be to have the latest and
greatest tech, but rather to be a long-term store of value and to offer
investors great certainty and predictability... something that markets
tend to like.  And of course, zero consensus rule changes also means
less chance of new bugs and attack surface remains the same, which is
good for security.

Of course, hard-forks are always possible.  But that is a clear split
and something that people must opt into.  Each party has to make a
choice, and inertia is on the side of the status quo.  Whereas
soft-forks sort of drag people along with them, even those who oppose
the changes and never upgrade.  In my view, that is problematic,
especially for a coin with permanent consensus rule immutability as a
goal/ethic.

As I understand it, bitcoin soft-forks always rely on anyone-can-spend
transactions.  If those were removed, would it effectively prevent
soft-forks, or are there other possible mechanisms?  How important are
any-one-can spend tx for other uses?

More generally, do you think it is possible to programmatically
avoid/ban soft-forks, and if so, how would you go about it?






From ZmnSCPxj at protonmail.com  Fri Sep 15 04:01:47 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 15 Sep 2017 00:01:47 -0400
Subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?
In-Reply-To: <9e212eae-08d5-d083-80d9-a8e29679fcdc@osc.co.cr>
References: <9e212eae-08d5-d083-80d9-a8e29679fcdc@osc.co.cr>
Message-ID: <SU02clg--S4TtIK4TZIytgdnHE8SzXBwSEb_FN5edtPAaojLwCEd6OTNkBUrDiH1FwHPuD4D5yByE7r4Fz_-CVzzU9KK0xvmDGlWNxTp3aU=@protonmail.com>

Good morning Dan,

My understanding is that it is impossible for soft forks to be prevented.

1.  Anyone-can-spend

There are a very large number of anyone-can-spend scripts, and it would be very impractical to ban them all.

For example, the below output script is anyone-can-spend

 <random number> OP_TRUE

So is the below:

  OP_SIZE <random small number> OP_EQUAL

Or:

  OP_1ADD <random number> OP_EQUAL

Or:

  OP_BOOLAND

Or:

  OP_BOOLOR

And so on.

So no, it is not practically possible to ban anyone-can-spend outputs, as there are too many potential scriptPubKey that anyone can spend.

It is even possible to have an output that requires a proof-of-work, like so:

 OP_HASH256 <difficulty target> OP_LESSTHAN

All the above outputs are disallowed from propagation by IsStandard, but a miner can put them validly in a block, and IsStandard is not consensus code and can be modified.

2.  Soft fork = restrict

It is possible (although unlikely) for a majority of miners to run soft forking code which the rest of us are not privy to.

For example, for all we know, miners are already blacklisting spends on Satoshi's coins.  We would not be able to detect this at all, since no transaction that spends Satoshi's coins have been broadcast, ever.  It is thus indistinguishable from a world where Satoshi lost his private keys.  Of course, the world where Satoshi never spent his coins and miners are blacklisting Satoshi's coins, is more complex than the world where Satoshi never spent his coins, so it is more likely that miners are not blacklisting.

But the principle is there.  We may already be in a softfork whose rules we do not know, and it just so happens that all our transactions today do not violate those rules.  It is impossible for us to know this, but it is very unlikely.

Soft forks apply further restrictions on Bitcoin.  Hard forks do not.  Thus, if everyone else is entering a soft fork and we are oblivious, we do not even know about it.  Whereas, if everyone else is entering a hard fork, we will immediately see (and reject) invalid transactions and blocks.

Thus the only way to prevent soft fork is to hard fork against the new soft fork, like Bcash did.

Regards,
ZmnSCPxj

-------- Original Message --------
Subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?
Local Time: September 13, 2017 5:50 PM
UTC Time: September 13, 2017 9:50 AM
From: bitcoin-dev at lists.linuxfoundation.org
To: Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>

Hi, I am interested in the possibility of a cryptocurrency software
(future bitcoin or a future altcoin) that strives to have immutable
consensus rules.

The goal of such a cryptocurrency would not be to have the latest and
greatest tech, but rather to be a long-term store of value and to offer
investors great certainty and predictability... something that markets
tend to like. And of course, zero consensus rule changes also means
less chance of new bugs and attack surface remains the same, which is
good for security.

Of course, hard-forks are always possible. But that is a clear split
and something that people must opt into. Each party has to make a
choice, and inertia is on the side of the status quo. Whereas
soft-forks sort of drag people along with them, even those who oppose
the changes and never upgrade. In my view, that is problematic,
especially for a coin with permanent consensus rule immutability as a
goal/ethic.

As I understand it, bitcoin soft-forks always rely on anyone-can-spend
transactions. If those were removed, would it effectively prevent
soft-forks, or are there other possible mechanisms? How important are
any-one-can spend tx for other uses?

More generally, do you think it is possible to programmatically
avoid/ban soft-forks, and if so, how would you go about it?

_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170915/e6f45267/attachment.html>

From ZmnSCPxj at protonmail.com  Fri Sep 15 04:34:12 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 15 Sep 2017 00:34:12 -0400
Subject: [bitcoin-dev] Fw: Re: Sidechain headers on mainchain (unification
	of drivechains and spv proofs)
In-Reply-To: <Imrd8VOoGb1nVRp10RedyHoeJYajcvlhrwZQg9OtTk3vDMpc7DEFgw7CSQR_AiqNDwmMECV_fn53WY2i9NZcJKx2jtyd_psyQf6VNg3S7Gc=@protonmail.com>
References: <H7RPmZGfkVC8opGMMCW7Orav6yD05-AVB9bNtNU8C0hKYokiXL32VSmn0wkjn77qh4MvacPOePdVQ5gQZuAMF6q2oEuvKDSu6crNcEoXx_0=@protonmail.com>
	<CAGL6+mFHe_SfMea1oMZ3n-G3ey9yToAvTMTcfdxJ5qDD1dTXyQ@mail.gmail.com>
	<Cc5DW6tb6_Xhe3DaXisRJzqYtnWHCGcHkOsXDJLIRvv9WP2lCVocsM1atkdQOSE8-reUbCp_ZKfEDIaA0Qh5CRwFeIrHFJcNkFsqmZx70XQ=@protonmail.com>
	<Imrd8VOoGb1nVRp10RedyHoeJYajcvlhrwZQg9OtTk3vDMpc7DEFgw7CSQR_AiqNDwmMECV_fn53WY2i9NZcJKx2jtyd_psyQf6VNg3S7Gc=@protonmail.com>
Message-ID: <sTzHVTwUTLpm1bOQR5mKQ9OBcNvWiPI1nhdM5L6LWbTv9NkuzupsT_NsJg8SJNAuuQqylZl8x3erw5kn5sHF_BroUDNK993JyuXlF0PVZMg=@protonmail.com>

Good morning,

I'm re-sending this message below as it appears to have gotten lost before it reached cc: bitcoin-dev.

Paul even replied to it and the reply reached on-list, so I'm re-sending it as others might have gotten confused about the discussion.

So far I've come to realize that sidechain-headers-on-mainchain/SHOM/SHM/driveproofs creates a very weak peg, and that only sidechain-only miners can take advantage of this weak peg.  This is because, the fee paid by sidechain-only miners to mainchain miners will approach TRANSFERLIMIT / 288 to protect against theft, and then sidechain miners will be unable to replenish their maincoin stock (to pay for the blind-merge-mine) if they do not transfer *only* their sidecoins earned.

Regards,
ZmnSCPxj

-------- Original Message --------
Subject: Re: [bitcoin-dev] Sidechain headers on mainchain (unification of drivechains and spv proofs)
Local Time: September 8, 2017 10:56 PM
UTC Time: September 8, 2017 2:56 PM
From: ZmnSCPxj at protonmail.com
To: Chris Stewart <chris at suredbits.com>, CryptAxe <cryptaxe at gmail.com>, Paul Sztorc <truthcoin at gmail.com>
Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>

Good morning,

Chris mentioned the use of OP_WITHDRAWPROOFVERIFY.  I've come to realize
that this is actually superior to use OP_WITHDRAWPROOFVERIFY with a
sidechain-headers-on-mainchain approach.

Briefly, a payment to OP_WITHDRAWPROOFVERIFY is an instruction to transfer
value from the mainchain to a sidechain.  Thus, a payment to
OP_WITHDRAWPROOFVERIFY includes the sidechain to pay to, and a commitment
to a sidechain address (or whatever is the equivalent to a sidechain
address).

Various OP_WITHDRAWPROOFVERIFY explanations exist.  Most of them include
OP_REORGPROOFVERIFY.  With sidechain-headers-on-mainchain, however, there is
no need for reorg proofs.  This is because, the mainchain can see, in real
time, which branch of the sidechain is getting extended.  Thus if someone
attempts to defraud a sidechain by forking the sidechain to an invalid
state, sidechainers can immediately detect this on the mainchain and
immediately act to prevent the invalid fork from being advanced.  After
all, a reorg proof is really just an SPV proof that is longer than some
previous SPV proof, that shows that the previous SPV proof is incorrect,
by showing that the block at the specified height of the WT is not present
on a longer SPV proof.

Since sidechain-headers-on-mainchain implies merge mining of sidechains,
with no option to have independent proof-of-work of sidechains, the
sidechain's entire history is recorded on the mainchain, visible to all
mainchain nodes.

--

An advantage of sidechain-headers-on-mainchain is a side-to-side peg without
passing through the mainchain.
That is, a 2-way peg between any two chains, whether side or main.

Sidechains supporting side-to-side transfer would require supporting
OP_WITHDRAWPROOFVERIFY, but not any of the other parts of sidechains.

We must consider a WT format (withdrawal transaction) that is compatible
with an OP_WITHDRAWPROOFVERIFY Bitcoin transaction.

***That is, a lockbox UTXO on one chain is a WT on another chain.***

Sidechains need not follow the mainchain format for its normal
transactions, only for WT transactions that move coins across chains.

For this, mainchain should also have its own "sidechain ID".  Perhaps a
sidechain ID of 0 would be appropriate for mainchain, as its status as
mainchain.

Suppose we have two sidechains, Ess and Tee, both of which support
side-to-side pegs.

An Ess fullnode is a Bitcoin fullnode, but an Ess fullnode is not
necessarily a Tee fullnode, and vice versa.

A lockbox redemption in sidechain-headers-on-mainchain is simply a spend of
a lockbox, pointing to the sidechain header containing WT, the merkle tree
path to the WT transaction from the h* commitment of the header, the output
which locks, and so on as per usual OP_WITHDRAWPROOFVERIFY.

Then a sidechain can create tokens from nothing, that are locked in a
OP_WITHDRAWPROOFVERIFY lockbox; this is the only way to create sidecoin.
When transferring into a sidechain from mainchain, or anywhere, the
sidechain either creates tokens locked into OP_WITHDRAWPROOFVERIFY, or
looks for an existing UTXO with OP_WITHDRAWPROOFVERIFY from the source
chain and spends them (the latter is preferred as it is fewer
transactions and less space on the sideblock, reducing sidechain fees).

OP_WITHDRAWPROOFVERIFY on a sidechain would query the mainchain fullnodes.
Whatever rules allow lockbox unlocking on mainchain, will also be the same
rules that allow lockbox unlocking on sidechains.
A mainchain RPC can even be made to simplify sidechain verification of
side-to-side pegs, and to ensure that sidechains follow the same consensus
rules for OP_WITHDRAWPROOFVERIFY.

So if we want transfer TeeCoin to EssCoin, we spend into a
OP_WITHDRAWPROOFVERIFY lockbox on Teechain pointing to Esschain (i.e. a
Tee->Ess lockbox).  This lockbox is itself a WT from the point of view of
Esschain.  On Esschain, we look for an existing Ess->Tee lockbox, or
create a Ess->Tee lockbox of our own for a EssCoin fee.  Then we create a
spend of the Ess->Tee lockbox on Esschain, wait until spending is
possible, and then post that transaction on Esschain.

Again, with sidechain-headers-on-mainchain, reorg proofs are unnecessary,
since any invalid chain should be quickly buried by a valid chain,
unless the economic majority decides that a sidechain is not worth
protecting.

--

All is not well, however.  Remember, on a sidechain, we can create new
sidecoin for free, provided they are in a lockbox.  Unlocking that
lockbox would require a valid WT on the chain that the lockbox is
dedicated to.  However, a lockbox on one chain is a WT on the other
chain.  We can create a free lockbox on Ess, then use that lockbox as
a WT on Tee, inflating TeeCoin.

Instead, we add an additional parameter, wtFlag, to
OP_WITHDRAWPROOFVERIFY.
This parameter is ignored by OP_WITHDRAWPROOFVERIFY opcode.

However, this parameter is used to determine if it is a WT.  Sidechain
consensus should require that freely-created lockboxes set this
parameter to 0, so that a side block that creates free lockboxes where
this parameter is non-zero is an invalid side block.  Then a sidechain
will only treat a lockbox on another chain as a WT if the wtFlag
parameter is nonzero.  This way, freely-created lockboxes are not
valid WT.  Valid WT must lock actual, already unlocked coins, not
create new locked coins.

On Bitcoin, of course, this parameter must always be nonzero, since
freely-created lockboxes are not allowed on mainchain, as asset
issuance on mainchain is already fixed.

--

Let us now flesh out how WT and lockboxes look like.  As we mentioned, a
lockbox on one chain is a WT on the destination chain.  Or to be more
precise, what a destination chain sees as a WT, is a lockbox on the source
chain.

Thus, a lockbox is a Bitcoin-formatted transaction output paying to the
scriptPubKey:

  <sidechain address commitment> <sidechain ID> OP_WITHDRAWPROOFVERIFY

(assuming a softfork, additional OP_DROP operations may occur after
OP_WITHDRAWPROOFVERIFY)

Suppose the above lockbox is paid to in the Bitcoin mainchain, with the
sidechain ID being the ID of Esschain.  This is itself a WT transaction
from the point of view of Esschain, on the principle that a lockbox on
one chain is a WT on another chain.

Assuming Esschain is a brand-new sidechain, it has no EssCoins yet.  The
sidechain allows the arbitrary creation of sidecoin provided the new
sidecoins are in a lockbox whose sidechain address commitment is 0.  So
in Esschain, we create the same coins on a UTXO paying to the
scriptPubKey:

  0 0 OP_WITHDRAWPROOFVERIFY

The first 0 is the sidechain address commitment, which is 0 since this
output was not created by transferring to a sidechain; we
reuse the sidechain address commitment as the wtFlag.  The
second 0 is the mainchain's ID.  The above is a lockbox from the point of
view of Esschain.  It is not a WT on mainchain, however, because the
sidechain address commitment is 0, which we use also as the wtFlag
parameter.

Now, how does a main-to-side peg work?  After creating the above output on
Esschain, we now spend the output with the below scriptSig:

  <mainchain output ID> <mainchain WT transaction> <merkle path to WT transaction> <mainchain block hash>

On Esschain, OP_WITHDRAWPROOFVERIFY then verifies that the mainchain block
hash is a valid past block of the mainchain, then locates the mainchain
header.  It then checks the merkle tree path to the mainchain WT
transaction,
confirming that the mainchain contains that transaction, and confirms that
the
indicated output is in fact, a payment to an OP_WITHDRAWPROOFVERIFY, which
pushes the Esschain ID, and with a nonzero sidechain address commitment.

(Esschain also needs to ensure that a single WT is not used to unlock
multiple lockboxes on Esschain; the easiest way is to add it to a set,
but this set cannot be pruned; other ways of ensuring only a WT is only
used to unlock once might be designed)

On Esschain, the sidechain does one final check: the transaction that spends
an OP_WITHDRAWPROOFVERIFY must have an output that pays to the sidechain
address committed to, and that output's value must be the same as the value
locked in the mainchain.

(for now, I think all lockboxes must have the same fixed amount, for
simplicity)

Now suppose we want to convert back our EssCoin to Bitcoin.  We create a
lockbox on Esschain, paying to the below:

  <bitcoin P2SH address> 0 OP_WITHDRAWPROOFVERIFY

The bitcoin P2SH address is mainchain address commitment; for simplicity
we just use P2SH on mainchain as it can encode any address.  The 0 is the
mainchain ID.  The above Esschain lockbox is itself a WT from Esschain to
mainchain.

Then, we look for an unspent lockbox on Esschain whose sidechain ID is the
Esschain ID.  Note that we can select any lockbox with the correct
sidechain ID, regardless of the sidechain address commitment it may have.

Locating an appropriate mainchain lockbox for Esschain coins, we then
provide the below scriptSig, paying out to the bitcoin P2SH address we
selected:

  <esschain output ID> <esschain WT tx> <merkle path to WT tx> <esschain block header hash>

On mainchain, we check that the indicated sidechain block header hash is a
block header on the longest chain of Esschain.  We check it has sufficient
depth.  Then we check if the merkle path to the WT tx is correct and goes
to esschain WT tx.  Finally, we check the indicated output ID, and check that
it is indeed an Esschain lockbox dedicated to mainchain.  Finally, we check
that the transaction has an output that spends the lockbox amount to the
specified bitcoin P2SH address.

(similarly mainchain nees to ensure that the Esschain WT is only used
once)

The key insight here is that side-to-side pegs are just like side-to-main
pegs.  Suppose instead we want to transfer our coins from Esscoin to
Teecoin.  We would instead pay to the following lockbox on Esschain:

  <teecoin address commitment> <teechain ID> OP_WITHDRAWPROOFVERIFY

Then a Teechain transaction spending some Tee->Ess lockbox (or a fresh
lockbox if there are no Tee->Ess lockboxes on Teechain) is created.
We proceed as if it were a side-to-main peg, except it is a peg to
Teechain, either creating or unlocking TeeCoins.  Indeed, mainchain
fullnodes may even provide an RPC for checking OP_WITHDRAWPROOFVERIFY,
so as to reduce risk that a sidechain breaks consensus due to buggy
code.

--

All is still not well with side-to-side pegs, however.

Suppose the economic majority decides that Esschain must die.  Perhaps it
has some irrecoverable security bug, perhaps it adds features that allow
Esschain fullnodes to kill baby seals, perhaps a successful theft of
Esschain lockboxes was performed and Esscoins are now functionally
worthless.  Killing a sidechain is done by bribing miners to put invalid
values into h*, and thus stealing Bitcoin->Ess lockboxes.

If Esschain dies, however, and the economic majority is not prepared to keep
Esschain dead, it is possible to unlock Tee->Ess lockboxes on Teechain.
Unlocking existing Tee->Ess lockboxes on Teechain is safe, since they
represent coins that were locked into Bitcoin->Tee lockboxes.  However,
it is still possible to create "free" Tee->Ess lockboxes on Teechain, then
provide an invalid Tee->Ess WT lockbox on the now-moribund Esschain to
unlock the free Tee->Ess lockbox on Teechain, inflating TeeCoin value.
Thus in the presence of side-to-side pegs, the death of even one sidechain
represents the death of every other sidechain!

Thus, to properly kill Esschain, the economic majority should spam the
Esschain headers slot with a fixed value, say 0, forever.  This makes it
very difficult to create a Tee->Ess WT lockbox on Esschain, as you would
now be able to reverse a one-way hash function.

Alternatively, Teechain can softfork so that Tee->Ess lockboxes are no
longer creatable or spendable.  However, the death of Esschain requires
that all other sidechains, including Youchain, Veechain, Dubyachain, and
so on, to softfork similarly.

Perhaps both can be done: first the economic majority wanting to kill
Esschain starts spamming it with invalid spends of Bitcoin->Ess lockboxes,
then when all Bitcoin->Ess lockboxes have been stolen, spam it with 0s
until all other sidechains have banned free Ess lockboxes on their chains.
Then, the economic majority can leave Esschain dead, and a later softfork
of mainchain prevents Esschain from being extended and allows mainchain
fullnodes to prune Esschain headers.

--

Thieves will still have the same difficulty stealing from sidechains, but
now their payoff is increased.  If a thief wants to steal Esschain
lockboxes, then it is possible to pack an invalid Esschain block full of
invalid WT to other chains.  Even chains that don't have lockboxes to
Esschain can create lockboxes to Esschain for free.  Thus, instead of
stealing only one lockbox at a time on mainchain, the thief can steal one
lockbox on mainchain, and on every sidechain that supports side-to-side
pegs, at a time.  The risk/reward ratio may shift drastically in that case.

However, this does mean that users of one chain must pay attention to
attacks on other chains, not just the chain they use.  If Teechain has no
side-to-side pegs, then Teechain users will not care if Esschain is under
attack.  But if side-to-side pegs are allowed on Teechain, then Teechain
users must also care about Esschain's health, as well as the health of
every other sidechain in existence.  Mainchain is protected since free
lockboxes are not creatable on mainchain.  Each sidechain is not; thus
the user of any sidechain must also stand by users of every other
sidechain, or else they all fall apart.  Of course, this could more
simply lead to "I will not use Teechain even if it would be useful to me,
because if I use Teechain, I have to care about Esschain and Youchain and
whatever."

--

Side-to-side pegs are useful to allow better liquidity and provide
arbitrage quickly between sidechains, without having to pass through
mainchain.  Otherwise, Esscoin may be valued slightly lower than Bitcoin,
then Teecoin valued slightly higher than Bitcoin, creating a larger
difference between Esscoin and Teecoin values than what a full
side-to-side peg could support.  2-way pegs from mainchain
to sidechain stabilize sidecoin with respect to maincoin.  Side-to-side
pegs stabilize all sidecoins to all other sidecoins.

Side-to-side pegs are enabled implicitly by sidechain-headers-on-mainchain,
as all sidechain fullnodes must necessarily be mainchain fullnodes, and
any mainchain fullnode can judge the validity of any WT from any sidechain
without a miner voting period.

Side-to-side pegs are a generalization of main-to-side and side-to-main
pegs.  A sidechain can simply implement OP_WITHDRAWPROOFVERIFY and allow
free lockboxes, and that is sufficient for the sidechain to support
imports of bitcoin from mainchain and from any other sidechain.

Side-to-side pegs seem to imply that all pegs must have the same bitcoin
value transferred.  What that value must be, is something that may be
debated endlessly.

A side-to-side peg is a cut-through of a side-to-main peg from
one sidechain into a main-to-side peg into another sidechain.  If a
withdrawal from side-to-main peg would be accepted by mainchain, then
another sidechain could, in principle, accept a proof that would
authorize a side-to-main peg directly as a side-to-side peg.

Side-to-side pegs make attacks on sidechains more lucrative, as it
becomes possible to print sidecoins by successfully attacking a
different sidechain.

Drivechain cannot implement side-to-side pegs, as WT validity is
voted on by mainchain miners, and asking mainchain miners about
side-to-side pegs requires mainchain miners to be aware of both
sidechains.  Sidechain-headers-on-mainchain publishes SPV proofs
continuously to the mainchain, and since any sidechain fullnode is
also a mainchain fullnode (since sidechains are mergemined), then
every sidechain fullnode is automatically capable of accessing
and verifying SPV proofs for every other sidechain.

However, the pegging here seems less flexible than the pegging
supported by drivechain.  Drivechain lets pegs be any size, with
miner voting being the basis of knowing how much money is owned
by whom.

Regards,
ZmnSCPxj
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170915/03659763/attachment-0001.html>

From thomasv at electrum.org  Fri Sep 15 08:55:37 2017
From: thomasv at electrum.org (Thomas Voegtlin)
Date: Fri, 15 Sep 2017 10:55:37 +0200
Subject: [bitcoin-dev] proposal: extend WIF format for segwit
Message-ID: <34198916-cde9-c84d-ca41-9feb8956bd80@electrum.org>

The Wallet Import Format (WIF) currently appends a 0x01 byte after the
raw private key, when that key needs to be used in conjunction with a
compressed public key. This allows wallets to associate a single Bitcoin
address to a WIF key.

It would be useful to extend the semantics of that byte, to signal for
segwit scripts, because these scripts result in different addresses.
That way, a WIF private key can still be associated to a single Bitcoin
address.

What WIF currently does is:

Nothing -> uncompressed pubkey
0x01    -> compressed pubkeys, non-segwit (can be used in P2PKH or P2SH)

We could extend it as follows:

0x02 -> segwit script embedded in P2SH (P2WPKH or P2WSH)
0x03 -> native segwit script (P2WKH or P2WSH)


Note 1: This is similar to my {x,y,z}{pub,prv} proposal for bip32
extended keys. (see other thread)

Note 2: It is probably not useful to use distinct bytes for P2WKH and
P2WSH, because the P2SH script is not known anyway. We did not do it for
non-segwit addresses, I guess we should keep it the way it is.

Note 3: we could also use a bech32 format for the private key, if it is
going to be used with a bech32 address. I am not sure if such a format
has been proposed already.

Note 4: my proposal will not result in a user visible change at the
beginning of the string, like we have for compressed/uncompressed. This
could be improved.

From adam.back at gmail.com  Fri Sep 15 09:14:13 2017
From: adam.back at gmail.com (Adam Back)
Date: Fri, 15 Sep 2017 10:14:13 +0100
Subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?
In-Reply-To: <SU02clg--S4TtIK4TZIytgdnHE8SzXBwSEb_FN5edtPAaojLwCEd6OTNkBUrDiH1FwHPuD4D5yByE7r4Fz_-CVzzU9KK0xvmDGlWNxTp3aU=@protonmail.com>
References: <9e212eae-08d5-d083-80d9-a8e29679fcdc@osc.co.cr>
	<SU02clg--S4TtIK4TZIytgdnHE8SzXBwSEb_FN5edtPAaojLwCEd6OTNkBUrDiH1FwHPuD4D5yByE7r4Fz_-CVzzU9KK0xvmDGlWNxTp3aU=@protonmail.com>
Message-ID: <CALqxMTFEA2X0GJwF8rO=8twsgW=brrzScpDD=owiK9otocdjoA@mail.gmail.com>

True however in principle a soft-fork can also be soft-forked out. Eg say a
publicly known soft-fork done by miners only that user node software did
not upgrade for first by opt-in adoption. If there was consensus against by
users and ecosystem a node/user flag day soft fork could block it's
effects. Or if a soft fork was determined to have a major bug.

However most types of soft fork are opt-in and so mostly that situation
seems unlikely.  A censorship soft-fork is harder, that's a standard
hard-fork to bypass with current fungibility mechanisms.

Adam

On Sep 15, 2017 08:12, "ZmnSCPxj via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Good morning Dan,
>
> My understanding is that it is impossible for soft forks to be prevented.
>
> 1.  Anyone-can-spend
>
> There are a very large number of anyone-can-spend scripts, and it would be
> very impractical to ban them all.
>
> For example, the below output script is anyone-can-spend
>
>  <random number> OP_TRUE
>
> So is the below:
>
>   OP_SIZE <random small number> OP_EQUAL
>
> Or:
>
>   OP_1ADD <random number> OP_EQUAL
>
> Or:
>
>   OP_BOOLAND
>
> Or:
>
>   OP_BOOLOR
>
> And so on.
>
> So no, it is not practically possible to ban anyone-can-spend outputs, as
> there are too many potential scriptPubKey that anyone can spend.
>
> It is even possible to have an output that requires a proof-of-work, like
> so:
>
>  OP_HASH256 <difficulty target> OP_LESSTHAN
>
> All the above outputs are disallowed from propagation by IsStandard, but a
> miner can put them validly in a block, and IsStandard is not consensus code
> and can be modified.
>
> 2.  Soft fork = restrict
>
> It is possible (although unlikely) for a majority of miners to run soft
> forking code which the rest of us are not privy to.
>
> For example, for all we know, miners are already blacklisting spends on
> Satoshi's coins.  We would not be able to detect this at all, since no
> transaction that spends Satoshi's coins have been broadcast, ever.  It is
> thus indistinguishable from a world where Satoshi lost his private keys.
> Of course, the world where Satoshi never spent his coins and miners are
> blacklisting Satoshi's coins, is more complex than the world where Satoshi
> never spent his coins, so it is more likely that miners are not
> blacklisting.
>
> But the principle is there.  We may already be in a softfork whose rules
> we do not know, and it just so happens that all our transactions today do
> not violate those rules.  It is impossible for us to know this, but it is
> very unlikely.
>
> Soft forks apply further restrictions on Bitcoin.  Hard forks do not.
> Thus, if everyone else is entering a soft fork and we are oblivious, we do
> not even know about it.  Whereas, if everyone else is entering a hard fork,
> we will immediately see (and reject) invalid transactions and blocks.
>
> Thus the only way to prevent soft fork is to hard fork against the new
> soft fork, like Bcash did.
>
> Regards,
> ZmnSCPxj
>
> -------- Original Message --------
> Subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?
> Local Time: September 13, 2017 5:50 PM
> UTC Time: September 13, 2017 9:50 AM
> From: bitcoin-dev at lists.linuxfoundation.org
> To: Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>
>
> Hi, I am interested in the possibility of a cryptocurrency software
> (future bitcoin or a future altcoin) that strives to have immutable
> consensus rules.
>
> The goal of such a cryptocurrency would not be to have the latest and
> greatest tech, but rather to be a long-term store of value and to offer
> investors great certainty and predictability... something that markets
> tend to like. And of course, zero consensus rule changes also means
> less chance of new bugs and attack surface remains the same, which is
> good for security.
>
> Of course, hard-forks are always possible. But that is a clear split
> and something that people must opt into. Each party has to make a
> choice, and inertia is on the side of the status quo. Whereas
> soft-forks sort of drag people along with them, even those who oppose
> the changes and never upgrade. In my view, that is problematic,
> especially for a coin with permanent consensus rule immutability as a
> goal/ethic.
>
> As I understand it, bitcoin soft-forks always rely on anyone-can-spend
> transactions. If those were removed, would it effectively prevent
> soft-forks, or are there other possible mechanisms? How important are
> any-one-can spend tx for other uses?
>
> More generally, do you think it is possible to programmatically
> avoid/ban soft-forks, and if so, how would you go about it?
>
>
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170915/6bfa793b/attachment.html>

From tier.nolan at gmail.com  Fri Sep 15 11:47:32 2017
From: tier.nolan at gmail.com (Tier Nolan)
Date: Fri, 15 Sep 2017 12:47:32 +0100
Subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?
In-Reply-To: <CALqxMTFEA2X0GJwF8rO=8twsgW=brrzScpDD=owiK9otocdjoA@mail.gmail.com>
References: <9e212eae-08d5-d083-80d9-a8e29679fcdc@osc.co.cr>
	<SU02clg--S4TtIK4TZIytgdnHE8SzXBwSEb_FN5edtPAaojLwCEd6OTNkBUrDiH1FwHPuD4D5yByE7r4Fz_-CVzzU9KK0xvmDGlWNxTp3aU=@protonmail.com>
	<CALqxMTFEA2X0GJwF8rO=8twsgW=brrzScpDD=owiK9otocdjoA@mail.gmail.com>
Message-ID: <CAE-z3OWJo07mpsyZEqfBV_T55jbB+2Ur0JeO2hSqOb2g_19F4Q@mail.gmail.com>

On Fri, Sep 15, 2017 at 10:14 AM, Adam Back via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> True however in principle a soft-fork can also be soft-forked out. Eg say
> a publicly known soft-fork done by miners only that user node software did
> not upgrade for first by opt-in adoption.
>

It depends on what software that the general user-base is using (especially
exchanges).  If a majority of miners have deployed a hidden soft fork, then
the soft fork will only last as long as they can maintain their majority.

If they drop below 50%, then the majority of miners will eventually make
and then build on a block that is invalid according to their hidden soft
fork rules.

If the userbase doesn't support a censorship soft fork, then it will only
last as long as a majority of miners support it.  Once the cartel loses its
majority, there is a strong incentive for members to disable their soft
fork rule.  Any that don't will end up mining a lower POW, but valid, chain.

Users updating their nodes to enforce the soft fork is what makes the soft
fork irreversible (without a hard fork).


> A censorship soft-fork is harder, that's a standard hard-fork to bypass
> with current fungibility mechanisms.
>

It's only a hard fork to reverse if the community is enforcing the soft
fork.  Forking off a minority of miners doesn't make it a hard fork.


>
> Adam
>
> On Sep 15, 2017 08:12, "ZmnSCPxj via bitcoin-dev" <bitcoin-dev at lists.
> linuxfoundation.org> wrote:
>
>> Good morning Dan,
>>
>> My understanding is that it is impossible for soft forks to be prevented.
>>
>> 1.  Anyone-can-spend
>>
>> There are a very large number of anyone-can-spend scripts, and it would
>> be very impractical to ban them all.
>>
>> For example, the below output script is anyone-can-spend
>>
>>  <random number> OP_TRUE
>>
>> So is the below:
>>
>>   OP_SIZE <random small number> OP_EQUAL
>>
>> Or:
>>
>>   OP_1ADD <random number> OP_EQUAL
>>
>> Or:
>>
>>   OP_BOOLAND
>>
>> Or:
>>
>>   OP_BOOLOR
>>
>> And so on.
>>
>> So no, it is not practically possible to ban anyone-can-spend outputs, as
>> there are too many potential scriptPubKey that anyone can spend.
>>
>> It is even possible to have an output that requires a proof-of-work, like
>> so:
>>
>>  OP_HASH256 <difficulty target> OP_LESSTHAN
>>
>> All the above outputs are disallowed from propagation by IsStandard, but
>> a miner can put them validly in a block, and IsStandard is not consensus
>> code and can be modified.
>>
>> 2.  Soft fork = restrict
>>
>> It is possible (although unlikely) for a majority of miners to run soft
>> forking code which the rest of us are not privy to.
>>
>> For example, for all we know, miners are already blacklisting spends on
>> Satoshi's coins.  We would not be able to detect this at all, since no
>> transaction that spends Satoshi's coins have been broadcast, ever.  It is
>> thus indistinguishable from a world where Satoshi lost his private keys.
>> Of course, the world where Satoshi never spent his coins and miners are
>> blacklisting Satoshi's coins, is more complex than the world where Satoshi
>> never spent his coins, so it is more likely that miners are not
>> blacklisting.
>>
>> But the principle is there.  We may already be in a softfork whose rules
>> we do not know, and it just so happens that all our transactions today do
>> not violate those rules.  It is impossible for us to know this, but it is
>> very unlikely.
>>
>> Soft forks apply further restrictions on Bitcoin.  Hard forks do not.
>> Thus, if everyone else is entering a soft fork and we are oblivious, we do
>> not even know about it.  Whereas, if everyone else is entering a hard fork,
>> we will immediately see (and reject) invalid transactions and blocks.
>>
>> Thus the only way to prevent soft fork is to hard fork against the new
>> soft fork, like Bcash did.
>>
>> Regards,
>> ZmnSCPxj
>>
>> -------- Original Message --------
>> Subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?
>> Local Time: September 13, 2017 5:50 PM
>> UTC Time: September 13, 2017 9:50 AM
>> From: bitcoin-dev at lists.linuxfoundation.org
>> To: Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>
>>
>> Hi, I am interested in the possibility of a cryptocurrency software
>> (future bitcoin or a future altcoin) that strives to have immutable
>> consensus rules.
>>
>> The goal of such a cryptocurrency would not be to have the latest and
>> greatest tech, but rather to be a long-term store of value and to offer
>> investors great certainty and predictability... something that markets
>> tend to like. And of course, zero consensus rule changes also means
>> less chance of new bugs and attack surface remains the same, which is
>> good for security.
>>
>> Of course, hard-forks are always possible. But that is a clear split
>> and something that people must opt into. Each party has to make a
>> choice, and inertia is on the side of the status quo. Whereas
>> soft-forks sort of drag people along with them, even those who oppose
>> the changes and never upgrade. In my view, that is problematic,
>> especially for a coin with permanent consensus rule immutability as a
>> goal/ethic.
>>
>> As I understand it, bitcoin soft-forks always rely on anyone-can-spend
>> transactions. If those were removed, would it effectively prevent
>> soft-forks, or are there other possible mechanisms? How important are
>> any-one-can spend tx for other uses?
>>
>> More generally, do you think it is possible to programmatically
>> avoid/ban soft-forks, and if so, how would you go about it?
>>
>>
>>
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170915/05615e0f/attachment-0001.html>

From luke at dashjr.org  Fri Sep 15 18:04:58 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Fri, 15 Sep 2017 18:04:58 +0000
Subject: [bitcoin-dev] Bitcoin Knots 0.15.0.knots20170914 released
Message-ID: <201709151805.03616.luke@dashjr.org>

Bitcoin Knots version *0.15.0.knots20170914* is now available from:

  <https://bitcoinknots.org/files/0.15.x/0.15.0.knots20170914/>

This is a new major version release, including new features, various bugfixes
and performance improvements, as well as updated translations.

Please report bugs using the issue tracker at GitHub:

  <https://github.com/bitcoinknots/bitcoin/issues>

How to Upgrade
==============

If you are running an older version, shut it down. Wait until it has completely
shut down (which might take a few minutes for older versions), then run the 
installer (on Windows) or just copy over `/Applications/Bitcoin-Qt` (on Mac)
or `bitcoind`/`bitcoin-qt` (on Linux).

The first time you run version 0.15.0, your chainstate database will be converted to a
new format, which will take anywhere from a few minutes to half an hour,
depending on the speed of your machine.

The file format of `fee_estimates.dat` changed in version 0.15.0. Hence, a
downgrade from version 0.15.0 or upgrade to version 0.15.0 will cause all fee
estimates to be discarded.

Note that the block database format also changed in version 0.8.0 and there is no
automatic upgrade code from before version 0.8 to version 0.15.0. Upgrading
directly from 0.7.x and earlier without redownloading the blockchain is not supported.
However, as usual, old wallet versions are still supported.

Downgrading warning
-------------------

The chainstate database for this release is not compatible with previous
releases, so if you run 0.15 and then decide to switch back to any
older version, you will need to run the old release with the `-reindex-chainstate`
option to rebuild the chainstate data structures in the old format.

If your node has pruning enabled, this will entail re-downloading and
processing the entire blockchain.

Compatibility
==============

Bitcoin Knots is supported on multiple operating systems using the Linux kernel,
macOS 10.8+, and Windows Vista and later. Windows XP is not supported.

Bitcoin Knots should also work on most other Unix-like systems but is not
frequently tested on them.

Notable changes
===============

Performance Improvements
------------------------

Version 0.15 contains a number of significant performance improvements, which make
Initial Block Download, startup, transaction and block validation much faster:

- The chainstate database (which is used for tracking UTXOs) has been changed
  from a per-transaction model to a per-output model (See [PR 10195](https://github.com/bitcoin/bitcoin/pull/10195)). Advantages of this 
model
  are that it:
    - avoids the CPU overhead of deserializing and serializing the unused outputs;
    - has more predictable memory usage;
    - uses simpler code;
    - is adaptable to various future cache flushing strategies.

  As a result, validating the blockchain during Initial Block Download (IBD) and reindex
  is ~30-40% faster, uses 10-20% less memory, and flushes to disk far less frequently.
  The only downside is that the on-disk database is 15% larger. During the conversion from the previous format
  a few extra gigabytes may be used.
- Earlier versions experienced a spike in memory usage while flushing UTXO updates to disk.
  As a result, only half of the available memory was actually used as cache, and the other half was
  reserved to accommodate flushing. This is no longer the case (See [PR 10148](https://github.com/bitcoin/bitcoin/pull/10148)), and the 
entirety of
  the available cache (see `-dbcache`) is now actually used as cache. This reduces the flushing
  frequency by a factor 2 or more.
- In previous versions, signature validation for transactions has been cached when the
  transaction is accepted to the mempool. Version 0.15 extends this to cache the entire script
  validity (See [PR 10192](https://github.com/bitcoin/bitcoin/pull/10192)). This means that if a transaction in a block has already been 
accepted to the
  mempool, the scriptSig does not need to be re-evaluated. Empirical tests show that
  this results in new block validation being 40-50% faster.
- LevelDB has been upgraded to version 1.20 (See [PR 10544](https://github.com/bitcoin/bitcoin/pull/10544)). This version contains hardware 
acceleration for CRC
  on architectures supporting SSE 4.2. As a result, synchronization and block validation are now faster.
- SHA256 hashing has been optimized for architectures supporting SSE 4 (See [PR 10821](https://github.com/bitcoin/bitcoin/pull/10821)). 
SHA256 is around
  50% faster on supported hardware, which results in around 5% faster IBD and block
  validation. In version 0.15, SHA256 hardware optimization is disabled in release builds by
  default, but can be enabled by using `--enable-experimental-asm` when building.
- Refill of the keypool no longer flushes the wallet between each key which resulted in a ~20x speedup in creating a new wallet. Part of 
this speedup was used to increase the default keypool to 1000 keys to make recovery more robust. (See [PR 10831]
(https://github.com/bitcoin/bitcoin/pull/10831)).

Fee Estimation Improvements
---------------------------

Fee estimation has been significantly improved in version 0.15, with more accurate fee estimates used by the wallet and a wider range of 
options for advanced users of the `estimatesmartfee` and `estimaterawfee` RPCs (See [PR 10199]
(https://github.com/bitcoin/bitcoin/pull/10199)).

### Changes to internal logic and wallet behavior

- Internally, estimates are now tracked on 3 different time horizons. This allows for longer targets and means estimates adjust more 
quickly to changes in conditions.
- Estimates can now be *conservative* or *economical*. *Conservative* estimates use longer time horizons to produce an estimate which is 
less susceptible to rapid changes in fee conditions. *Economical* estimates use shorter time horizons and will be more affected by short-
term changes in fee conditions. Economical estimates may be considerably lower during periods of low transaction activity (for example over 
weekends), but may result in transactions being unconfirmed if prevailing fees increase rapidly.
- By default, the wallet will use conservative fee estimates to increase the reliability of transactions being confirmed within the desired 
target. For transactions that are marked as replaceable, the wallet will use an economical estimate by default, since the fee can be 
'bumped' if the fee conditions change rapidly (See [PR 10589](https://github.com/bitcoin/bitcoin/pull/10589)).
- Estimates can now be made for confirmation targets up to 1008 blocks (one week).
- More data on historical fee rates is stored, leading to more precise fee estimates.
- Transactions which leave the mempool due to eviction or other non-confirmed reasons are now taken into account by the fee estimation 
logic, leading to more accurate fee estimates.
- The fee estimation logic will make sure enough data has been gathered to return a meaningful estimate. If there is insufficient data, a 
fallback default fee is used.

### Changes to fee estimate RPCs

- The `estimatefee` RPC is now deprecated in favor of using only `estimatesmartfee` (which is the implementation used by the GUI)
- The `estimatesmartfee` RPC interface has been changed (See [PR 10707](https://github.com/bitcoin/bitcoin/pull/10707)):
    - The `nblocks` argument has been renamed to `conf_target` (to be consistent with other RPC methods).
    - An `estimate_mode` argument has been added. This argument takes one of the following strings: `CONSERVATIVE`, `ECONOMICAL` or `UNSET` 
(which defaults to `CONSERVATIVE`).
    - The RPC return object now contains an `errors` member, which returns errors encountered during processing.
    - If Bitcoin Knots has not been running for long enough and has not seen enough blocks or transactions to produce an accurate fee 
estimation, an error will be returned (previously a value of -1 was used to indicate an error, which could be confused for a feerate).
- A new `estimaterawfee` RPC is added to provide raw fee data. External clients can query and use this data in their own fee estimation 
logic.

Multi-wallet endpoint support
-----------------------------

Bitcoin Knots has supported loading multiple, separate wallets since
v0.13.1.knots20161027. However, due to the RPC API, RPC users could only access
a single wallet at a time - accessing multiple wallets over RPC required the
use of multiple RPC users. 0.15.0 adds support for specifying the wallet by
name using a URI path for the RPC endpoint.

To do this, HTTP RPC requests should be send to the `<RPC IP address>:<RPC port>/wallet/<wallet name>/` endpoint, for example 
`127.0.0.1:8332/wallet/wallet1.dat/`.

`bitcoin-cli` commands should be run with a `-rpcwallet` option, for example `bitcoin-cli -rpcwallet=wallet1.dat getbalance`.

Additionally, a new `listwallets` RPC method is added to display which wallets are currently loaded. The names returned by this method are 
the same as those used in the HTTP endpoint and for the `rpcwallet` argument.

This new wallet endpoint interface should be considered unstable for version 0.15.0, and there may backwards-incompatible changes in future 
versions.

The original RPC user based wallet selection continues to work as well, independently from the new endpoint support. `rpcauth` users that 
specify a specific wallet are prohibited from using endpoints to access others. However, note that (at least in this version) `listwallets` 
will always list all wallets on the node, even if access to them has been limited!

Removal of no-fee transactions
------------------------------

In previous versions of Bitcoin Knots, transactions without a fee would be allowed to be relayed if the node's memory pool was empty and 
the age and value of UTXOs they spent (coin age priority) was sufficiently high.

For a long time now, this has been effectively useless, due to wide adoption of Bitcoin as well as regular spam attacks. Since the code no 
longer has a purpose, support for no-fee transactions has been removed.

Segwit checkpoint
-----------------

Since Segwit has activated, this release adds a new checkpoint locking to the first Segwit block. This guarantees no matter what happens, 
your node will not accept a reorg to attempt theft of Segwit funds. (This isn't a real-world risk anyway, but there's no reason not to 
guarantee it with a checkpoint.)

Mempool Persistence Across Restarts
-----------------------------------

Version 0.13.1.knots20161212 introduced mempool persistence across restarts (the mempool is saved to a `mempool.dat` file in the data 
directory prior to shutdown and restores the mempool when the node is restarted). Version 0.15 allows this feature to be switched on or off 
using the `-persistmempool` command-line option (See [PR 9966](https://github.com/bitcoin/bitcoin/pull/9966)). By default, the option is 
set to true, and the mempool is saved on shutdown and reloaded on startup. If set to false, the `mempool.dat` file will neither be loaded 
on startup nor saved on shutdown.

The new `savemempool` RPC can be used to trigger an immediate save of the mempool state at any time.

New RPC methods
---------------

Version 0.15 introduces several new RPC methods:

- `abortrescan` stops current wallet rescan, e.g. when triggered by an `importprivkey` call (See [PR 10208]
(https://github.com/bitcoin/bitcoin/pull/10208)).
- `combinerawtransaction` accepts a JSON array of raw transactions and combines them into a single raw transaction (See [PR 10571]
(https://github.com/bitcoin/bitcoin/pull/10571)).
- `estimaterawfee` returns raw fee data so that customized logic can be implemented to analyze the data and calculate estimates. See [Fee 
Estimation Improvements](#fee-estimation-improvements) for full details on changes to the fee estimation logic and interface.
- `getchaintxstats` returns statistics about the total number and rate of transactions
  in the chain (See [PR 9733](https://github.com/bitcoin/bitcoin/pull/9733)).
- `listwallets` lists wallets which are currently loaded. See the *Multi-wallet* section
  of these release notes for full details (See [Multi-wallet endpoint support](#multi-wallet-endpoint-support)).
- `savemempool` causes the memory pool to immediately update `mempool.dat` with its current state.
- `uptime` returns the total runtime of the `bitcoind` server since its last start (See [PR 10400]
(https://github.com/bitcoin/bitcoin/pull/10400)).
- `verifyscript` allows verification of a specific Bitcoin Script, optionally including a full trace of the evaluation.

Additionally, the `bitcoin-cli` tool now supports a `-getinfo` command line option to fetch information from multiple `get*info` RPC 
methods. This is intended to replace the deprecated `getinfo` RPC method.

Wallet ZeroMQ publishers
------------------------

This release includes experimental ZeroMQ publishers for wallet transactions.

See [the ZMQ documentation](zmq.md) for details.

Low-level RPC changes
---------------------

- When using Bitcoin Knots in multi-wallet mode, RPC requests for wallet methods may specify
  the wallet that they're intended for. See [Multi-wallet endpoint support](#multi-wallet-endpoint-support) for full details.

- The `optintorbf` parameter for `createrawtransaction` and `fundrawtransaction` has been renamed to `replaceable` to match `bumpfee`.

- The new database model no longer stores information about transaction
  versions of unspent outputs (See [Performance improvements](#performance-improvements)). This means that:
  - The `gettxout` RPC no longer has a `version` field in the response.
  - The `gettxoutsetinfo` RPC reports `hash_serialized_2` instead of `hash_serialized`,
    which does not commit to the transaction versions of unspent outputs, but does
    commit to the height and coinbase information.
  - The `getutxos` REST path no longer reports the `txvers` field in JSON format,
    and always reports 0 for transaction versions in the binary format

- The `estimatefee` RPC is deprecated. Clients should switch to using the `estimatesmartfee` RPC, which returns better fee estimates. See 
[Fee Estimation Improvements](#fee-estimation-improvements) for full details on changes to the fee estimation logic and interface.

- The `gettxoutsetinfo` response now contains `disk_size` and `bogosize` instead of
  `bytes_serialized`. The first is a more accurate estimate of actual disk usage, but
  is not deterministic. The second is unrelated to disk usage, but is a
  database-independent metric of UTXO set size: it counts every UTXO entry as 50 + the
  length of its scriptPubKey (See [PR 10426](https://github.com/bitcoin/bitcoin/pull/10426)).

- `signrawtransaction` can no longer be used to combine multiple transactions into a single transaction. Instead, use the new 
`combinerawtransaction` RPC (See [PR 10571](https://github.com/bitcoin/bitcoin/pull/10571)).

- `fundrawtransaction` no longer accepts a `reserveChangeKey` option. This option used to allow RPC users to fund a raw transaction using 
an key from the keypool for the change address without removing it from the available keys in the keypool. The key could then be re-used 
for a `getnewaddress` call, which could potentially result in confusing or dangerous behaviour (See [PR 10784]
(https://github.com/bitcoin/bitcoin/pull/10784)).

- `estimatepriority` and `estimatesmartpriority` have been removed. Estimating coin age priority is no longer supported.

- In the `getpeerinfo` RPC, the return object for each peer now returns an `addrbind` member, which contains the ip address and port of the 
connection to the peer. This is in addition to the `addrlocal` member which contains the ip address and port of the local node as reported 
by the peer (See [PR 10478](https://github.com/bitcoin/bitcoin/pull/10478)).

- The `resendwallettransactions` RPC throws an error if the `-walletbroadcast` option is set to false (See [PR 10995]
(https://github.com/bitcoin/bitcoin/pull/10995)).

- The second argument in the `submitblock` RPC argument has been renamed from `parameters` to `dummy`. This argument never had any effect, 
and the renaming is simply to communicate this fact to the user (See [PR 10191](https://github.com/bitcoin/bitcoin/pull/10191))
  (Clients should, however, use positional arguments for `submitblock` in order to be compatible with BIP 22.)

- Mempool entries returned from RPC now include the hash of the entire transaction as a `wtxid` key.

Low-level p2p changes
---------------------

Support for a new kind of inventory item MSG_FILTERED_WITNESS_BLOCK has been added. This extends the functionality of BIP37, used 
identically to MSG_FILTERED_BLOCK. But whereas MSG_FILTERED_BLOCK returns transactions with no witness data, MSG_FILTERED_WITNESS_BLOCK 
returns the transactions serialized along with witness data. No merkle proof for witness inclusion in blocks is provided, but clients can 
still verify the witness is valid (although possibly not the same witness as in the blockchain).

BIP37 has well-known privacy issues and will likely be deprecated in favor of clientside block filtering in future software releases. 
MSG_FILTERED_WITNESS_BLOCK is provided to enable clients that rely on BIP37 to easily add Segregated Witness support immediately until 
better sync mechanisms gain widespread use.

Warning: BIP37 leaks private data and witness data is not authenticated. You must use a trusted node to use this mechanism securely.

0.15.0 Change log
=================

### RPC and other APIs
- #9485 `61a640e` ZMQ example using python3 and asyncio (mcelrath)
- #9894 `0496e15` remove 'label' filter for rpc command help (instagibbs)
- #9853 `02bd6e9` Fix error codes from various RPCs (jnewbery)
- #9842 `598ef9c` Fix RPC failure testing (continuation of #9707) (jnewbery)
- #10038 `d34995a` Add mallocinfo mode to `getmemoryinfo` RPC (laanwj)
- #9500 `3568b30` [Qt][RPC] Autocomplete commands for 'help' command in debug console (achow101)
- #10056 `e6156a0` [zmq] Call va_end() on va_start()ed args (kallewoof)
- #10086 `7438cea` Trivial: move rpcserialversion into RPC option group (jlopp)
- #10150 `350b224` [rpc] Add logging rpc (jnewbery)
- #10208 `393160c` [wallet] Rescan abortability (kallewoof)
- #10143 `a987def` [net] Allow disconnectnode RPC to be called with node id (jnewbery)
- #10281 `0e8499c` doc: Add RPC interface guidelines (laanwj)
- #9733 `d4732f3` Add getchaintxstats RPC (sipa)
- #10310 `f4b15e2` [doc] Add hint about getmempoolentry to getrawmempool help (kallewoof)
- #8704 `96c850c` [RPC] Transaction details in getblock (achow101)
- #8952 `9390845` Add query options to listunspent RPC call (pedrobranco)
- #10413 `08ac35a` Fix docs (there's no rpc command setpaytxfee) (RHavar)
- #8384 `e317c0d` Add witness data output to TxInError messages (instagibbs)
- #9571 `4677151` RPC: getblockchaininfo returns BIP signaling statistics  (pinheadmz)
- #10450 `ef2d062` Fix bumpfee rpc "errors" return value (ryanofsky)
- #10475 `39039b1` [RPC] getmempoolinfo mempoolminfee is a BTC/KB feerate (instagibbs)
- #10478 `296928e` rpc: Add listen address to incoming connections in `getpeerinfo` (laanwj)
- #10403 `08d0390` Fix importmulti failure to return rescan errors (ryanofsky)
- #9740 `9fec4da` Add friendly output to dumpwallet (aideca)
- #10426 `16f6c98` Replace bytes_serialized with bogosize (sipa)
- #10252 `980deaf` RPC/Mining: Restore API compatibility for prioritisetransaction (luke-jr)
- #9672 `46311e7` Opt-into-RBF for RPC & bitcoin-tx (luke-jr)
- #10481 `9c248e3` Decodehextx scripts sanity check  (achow101)
- #9738 `c94b89e` gettxoutproof() should return consistent result (jnewbery)
- #10191 `00350bd` [trivial] Rename unused RPC arguments 'dummy' (jnewbery)
- #10627 `b62b4c8` fixed listunspent rpc convert parameter (tnakagawa)
- #10412 `bef02fb` Improve wallet rescan API (ryanofsky)
- #10400 `1680ee0` [RPC] Add an uptime command that displays the amount of time (in seconds) bitcoind has been running (rvelhote)
- #10683 `d81bec7` rpc: Move the `generate` RPC call to rpcwallet (laanwj)
- #10710 `30bc0f6` REST/RPC example update (Mirobit)
- #10747 `9edda0c` [rpc] fix verbose argument for getblock in bitcoin-cli (jnewbery)
- #10589 `104f5f2` More economical fee estimates for RBF and RPC options to control (morcos)
- #10543 `b27b004` Change API to estimaterawfee (morcos)
- #10807 `afd2fca` getbalance example covers at least 6 confirms (instagibbs)
- #10707 `75b5643` Better API for estimatesmartfee RPC  (morcos)
- #10784 `9e8d6a3` Do not allow users to get keys from keypool without reserving them (TheBlueMatt)
- #10857 `d445a2c` [RPC] Add a deprecation warning to getinfo's output (achow101)
- #10571 `adf170d` [RPC]Move transaction combining from signrawtransaction to new RPC (achow101)
- #10783 `041dad9` [RPC] Various rpc argument fixes (instagibbs)
- #9622 `6ef3c7e` [rpc] listsinceblock should include lost transactions when parameter is a reorg'd block (kallewoof)
- #10799 `8537187` Prevent user from specifying conflicting parameters to fundrawtx (TheBlueMatt)
- #10931 `0b11a07` Fix misleading "Method not found" multiwallet errors (ryanofsky)
- #10788 `f66c596` [RPC] Fix addwitnessaddress by replacing ismine with producesignature (achow101)
- #10999 `627c3c0` Fix amounts formatting in `decoderawtransaction` (laanwj)
- #11002 `4268426` [wallet] return correct error code from resendwallettransaction (jnewbery)
- #11029 `96a63a3` [RPC] trivial: gettxout no longer shows version of tx (FelixWeis)
- #11083 `6c2b008` Fix combinerawtransaction RPC help result section (jonasnick)
- #11027 `07164bb` [RPC] Only return hex field once in getrawtransaction (achow101)
- #10698 `5af6572` Be consistent in calling transactions "replaceable" for Opt-In RBF (TheBlueMatt)
- n/a    `a92a946` *RPC: prioritisetransaction: Make both deltas optional (luke-jr)
- #7061 `e893d96` *RPC/Wallet: rescanblockchain: Support inverted height order (luke-jr)
- #10554 `e700ad2` *ZMQ: add publishers for wallet transactions. (somdoron)
- n/a    `0afed04` *Add script tracing capabilities to libbitcoinconsensus and a new RPC verifyscript method (luke-jr)
- #10871 `977d461` *Handle getinfo in bitcoin-cli w/ -getinfo (laanwj, achow101, jnewbery)
- #10997 `d6f667e` *RPC: Add option -stdinrpcpass to bitcoin-cli to allow RPC password to be read from standard input (jharvell)
- #11099 `941c2f6` *[RPC][mempool]: Add savemempool RPC (greenaddress)
- #11203 `e731a14` *rpc: add wtxid to mempool entry output (sdaftuar)
- #7533 `963da74` *AcceptToMemoryPool: Standardise rejection reason format (luke-jr)

### Block and transaction handling
- #9801 `a8c5751` Removed redundant parameter from mempool.PrioritiseTransaction (gubatron)
- #9819 `1efc99c` Remove harmless read of unusued priority estimates (morcos)
- #9822 `b7547fa` Remove block file location upgrade code (benma)
- #9602 `30ff3a2` Remove free transactions (but not coin-age priority, in Knots) - implementation (morcos)
- #9548 `47510ad` Remove min reasonable fee (morcos)
- #10249 `c73af54` Switch CCoinsMap from boost to std unordered_map (sipa)
- #9966 `2a183de` Control mempool persistence using a command line parameter (jnewbery)
- #10199 `318ea50` Better fee estimates (morcos)
- #10196 `bee3529` Bugfix: PrioritiseTransaction updates the mempool tx counter (sdaftuar)
- #10195 `1088b02` Switch chainstate db and cache to per-txout model (sipa)
- #10284 `c2ab38b` Always log debug information for fee calculation in CreateTransaction (morcos)
- #10503 `efbcf2b` Use REJECT_DUPLICATE for already known and conflicted txn (sipa)
- #10537 `b3eb0d6` Few Minor per-utxo assert-semantics re-adds and tweak (TheBlueMatt)
- #10626 `8c841a3` doc: Remove outdated minrelaytxfee comment (MarcoFalke)
- #10559 `234ffc6` Change semantics of HaveCoinInCache to match HaveCoin (morcos)
- #10581 `7878353` Simplify return values of GetCoin/HaveCoin(InCache) (sipa)
- #10684 `a381f6a` Remove no longer used mempool.exists(outpoint) (morcos)
- #10148 `d4e551a` Use non-atomic flushing with block replay (sipa)
- #10685 `30c2130` Clarify CCoinsViewMemPool documentation (TheBlueMatt)
- #10558 `90a002e` Address nits from per-utxo change (morcos)
- #10706 `6859ad2` Improve wallet fee logic and fix GUI bugs (morcos)
- #10526 `754aa02` Force on-the-fly compaction during pertxout upgrade (sipa)
- #10985 `d896d5c` Add undocumented -forcecompactdb to force LevelDB compactions (sipa)
- #10292 `e4bbd3d` Improved efficiency in COutPoint constructors (mm-s)
- #10290 `8d6d43e` Add -stopatheight for benchmarking (sipa)
- #7533 `916f12f` *AcceptToMemoryPool: Replace fLimitFree[=false] with rejectmsg_gratis in ignore_rejects (luke-jr)

### P2P protocol and network code
- #9726 `7639d38` netbase: Do not print an error on connection timeouts through proxy (laanwj)
- #9805 `5b583ef` Add seed.btc.petertodd.org to mainnet DNS seeds (petertodd)
- #9861 `22f609f` Trivial: Debug log ambiguity fix for peer addrs (keystrike)
- #9774 `90cb2a2` Enable host lookups for -proxy and -onion parameters (jmcorgan)
- #9558 `7b585cf` Clarify assumptions made about when BlockCheck is called (TheBlueMatt)
- #10135 `e19586a` [p2p] Send the correct error code in reject messages (jnewbery)
- #9665 `eab00d9` Use cached [compact] blocks to respond to getdata messages (TheBlueMatt)
- #10215 `a077a90` Check interruptNet during dnsseed lookups (TheBlueMatt)
- #10234 `faf2dea` [net] listbanned RPC and QT should show correct banned subnets (jnewbery)
- #10134 `314ebdf` [qa] Fixes segwit block relay test after inv-direct-fetch was disabled (sdaftuar)
- #10351 `3f57c55` removed unused code in INV message (Greg-Griffith)
- #10061 `ae78609` [net] Added SetSocketNoDelay() utility function (tjps)
- #10408 `28c6e8d` Net: Improvements to Tor control port parser (str4d)
- #10460 `5c63d66` Broadcast address every day, not 9 hours (sipa)
- #10471 `400fdd0` Denote functions CNode::GetRecvVersion() and CNode::GetRefCount()  as const (pavlosantoniou)
- #10345 `67700b3` [P2P] Timeout for headers sync (sdaftuar)
- #10564 `8d9f45e` Return early in IsBanned (gmaxwell)
- #10587 `de8db47` Net: Fix resource leak in ReadBinaryFile(...) (practicalswift)
- #9549 `b33ca14` [net] Avoid possibility of NULL pointer dereference in MarkBlockAsInFlight(...) (practicalswift)
- #10446 `2772dc9` net: avoid extra dns query per seed (theuni)
- #10824 `9dd6a2b` Avoid unnecessary work in SetNetworkActive (promag)
- #10948 `df3a6f4` p2p: Hardcoded seeds update pre-0.15 branch (laanwj)
- #10977 `02f4c4a` [net] Fix use of uninitialized value in getnetworkinfo(const JSONRPCRequest&) (practicalswift)
- #10982 `c8b62c7` Disconnect network service bits 6 and 8 until Aug 1, 2018 (TheBlueMatt)
- #11012 `0e5cff6` Make sure to clean up mapBlockSource if we've already seen the block (theuni)
- n/a    `bd5b64d` *utilioprio: Add Windows support as ioprio_set_file_idle (luke-jr)
- #10731 `69577ae` *Escape rather than remove any printable characters in UAs (luke-jr)
- #10350 `3f388dd` *Handle MSG_FILTERED_WITNESS_BLOCK messages (CodeShark)

### Validation
- #9725 `67023e9` CValidationInterface Cleanups (TheBlueMatt)
- #10178 `2584925` Remove CValidationInterface::UpdatedTransaction (TheBlueMatt)
- #10201 `a6548a4` pass Consensus::Params& to functions in validation.cpp and make them static (mariodian)
- #10297 `431a548` Simplify DisconnectBlock arguments/return value (sipa)
- #10464 `f94b7d5` Introduce static DoWarning (simplify UpdateTip) (jtimon)
- #10569 `2e7d8f8` Fix stopatheight (achow101)
- #10192 `2935b46` Cache full script execution results in addition to signatures (TheBlueMatt)
- #10179 `21ed30a` Give CValidationInterface Support for calling notifications on the CScheduler Thread (TheBlueMatt)
- #10557 `66270a4` Make check to distinguish between orphan txs and old txs more efficient (morcos)
- #10775 `7c2400c` nCheckDepth chain height fix (romanornr)
- #10821 `16240f4` Add SSE4 optimized SHA256 (sipa)
- #10854 `04d395e` Avoid using sizes on non-fixed-width types to derive protocol constants (gmaxwell)
- #10945 `2a50b11` Update defaultAssumeValid according to release-process.md (gmaxwell)
- #10986 `2361208` Update chain transaction statistics (sipa)
- #11028 `6bdf4b3` Avoid masking of difficulty adjustment errors by checkpoints (sipa)
- #9533 `cb598cf` Allow non-power-of-2 signature cache sizes (sipa)
- #9208 `acd9957` Improve DisconnectTip performance (sdaftuar)
- #10618 `f90603a` Remove confusing MAX_BLOCK_BASE_SIZE (gmaxwell)
- #10758 `bd92424` Fix some chainstate-init-order bugs (TheBlueMatt)
- #10550 `b7296bc` Don't return stale data from CCoinsViewCache::Cursor() (ryanofsky)
- #10998 `2507fd5` Fix upgrade cancel warnings (TheBlueMatt)
- #9868 `cbdb473` Abstract out the command line options for block assembly (sipa)
- n/a    `08c84c7` *Add a new checkpoint at block 481,824 (luke-jr)

### Build system
- #9727 `5f0556d` Remove fallbacks for boost_filesystem < v3 (laanwj)
- #9788 `50a2265` gitian: bump descriptors for master (theuni)
- #9794 `7ca2f54` Minor update to qrencode package builder (mitchellcash)
- #9514 `2cc0df1` release: Windows signing script (theuni)
- #9921 `8b789d8` build: Probe MSG_DONTWAIT in the same way as MSG_NOSIGNAL (laanwj)
- #10011 `32d1b34` build: Fix typo s/HAVE_DONTWAIT/HAVE_MSG_DONTWAIT (laanwj)
- #9946 `90dd9e6` Fix build errors if spaces in path or parent directory (pinheadmz)
- #10136 `81da4c7` build: Disable Wshadow warning (laanwj)
- #10166 `64962ae` Ignore Doxyfile generated from Doxyfile.in template (paveljanik)
- #10239 `0416ea9` Make Boost use std::atomic internally (sipa)
- #10228 `27faa6c` build: regenerate bitcoin-config.h as necessary (theuni)
- #10273 `8979f45` [scripts] Minor improvements to `macdeployqtplus` script (chrisgavin)
- #10325 `a26280b` 0.15.0 Depends Updates (fanquake)
- #10328 `79aeff6` Update contrib/debian to latest Ubuntu PPA upload (TheBlueMatt)
- #7522 `d25449f` Bugfix: Only use git for build info if the repository is actually the right one (luke-jr)
- #10489 `e654d61` build: silence gcc7's implicit fallthrough warning (theuni)
- #10549 `ad1a13e` Avoid printing generic and duplicated "checking for QT" during ./configure (drizzt)
- #10628 `8465b68` [depends] expat 2.2.1 (fanquake)
- #10806 `db825d2` build: verify that the assembler can handle crc32 functions (theuni)
- #10766 `b4d03be` Building Environment: Set ARFLAGS to cr (ReneNyffenegger)
- #10803 `91edda8` Explicitly search for bdb5.3 (pstratem)
- #10855 `81560b0` random: only use getentropy on openbsd (theuni)
- #10508 `1caafa6` Run Qt wallet tests on travis (ryanofsky)
- #10851 `e222618` depends: fix fontconfig with newer glibc (theuni)
- #10971 `88b1e4b` build: fix missing sse42 in depends builds (theuni)
- #11097 `129b03f` gitian: quick hack to fix version string in releases (theuni)
- #10039 `919aaf6` Fix compile errors with Qt 5.3.2 and Boost 1.55.0 (ryanofsky)
- #10168 `7032021` Fix build warning from #error text (jnewbery)
- #10301 `318392c` Check if sys/random.h is required for getentropy (jameshilliard)
- n/a    `699287a` *Move Win32 defines to configure.ac to ensure they are globally defined (luke-jr)
- n/a    `ad1b260` *nsis-header.bmp: Generate from SVG (luke-jr)

### GUI
- #9724 `1a9fd5c` Qt/Intro: Add explanation of IBD process (luke-jr)
- #9834 `b00ba62` qt: clean up initialize/shutdown signals (benma)
- #9481 `ce01e62` [Qt] Show more significant warning if we fall back to the default fee (jonasschnelli)
- #9974 `b9f930b` Add basic Qt wallet test (ryanofsky)
- #9690 `a387d3a` Change 'Clear' button string to 'Reset' (da2x)
- #9592 `9c7b7cf` [Qt] Add checkbox in the GUI to opt-in to RBF when creating a transaction (ryanofsky)
- #10098 `2b477e6` Make qt wallet test compatible with qt4 (ryanofsky)
- #9890 `1fa4ae6` Add a button to open the config file in a text editor (ericshawlinux)
- #10156 `51833a1` Fix for issues with startup and multiple monitors on windows (AllanDoensen)
- #10177 `de01da7` Changed "Send" button default status from true to false (KibbledJiveElkZoo)
- #10221 `e96486c` Stop treating coinbase outputs differently in GUI: show them at 1conf (TheBlueMatt)
- #10231 `987a6c0` [Qt] Reduce a significant cs_main lock freeze (jonasschnelli)
- #10242 `f6f3b58` [qt] Don't call method on null WalletModel object (ryanofsky)
- #10093 `a3e756b` [Qt] Don't add arguments of sensitive command to console window (jonasschnelli)
- #10362 `95546c8` [GUI] Add OSX keystroke to RPCConsole info (spencerlievens)
- #9697 `962cd3f` [Qt] simple fee bumper with user verification (jonasschnelli)
- #10390 `e477516` [wallet] remove minimum total fee option (instagibbs)
- #10420 `4314544` Add Qt tests for wallet spends & bumpfee (ryanofsky)
- #10454 `c1c9a95` Fix broken q4 test build (ryanofsky)
- #10449 `64beb13` Overhaul Qt fee bumper (jonasschnelli)
- #10582 `7c72fb9` Pass in smart fee slider value to coin control dialog (morcos)
- #10673 `4c72cc3` [qt] Avoid potential null pointer dereference in TransactionView::exportClicked() (practicalswift)
- #10769 `8fdd23a` [Qt] replace fee slider with a Dropdown, extend conf. targets (jonasschnelli)
- #10870 `412b466` [Qt] Use wallet 0 in rpc console if running with multiple wallets (jonasschnelli)
- #10988 `a9dd111` qt: Increase BLOCK_CHAIN_SIZE constants (laanwj)
- #10644 `e292140` Slightly overhaul NSI pixmaps (jonasschnelli)
- #10660 `0c3542e` Allow to cancel the txdb upgrade via splashscreen keypress 'q' (jonasschnelli)
- #11169 `ad55de9` *Make tabs toolbar no longer have a context menu (achow101)
- #11198 `14ccd4d` *Fix display of package name on 'open config file' tooltip (esotericnonsense)
- #11206 `819e3dd` *Move "Hide tray icon" accelerator to checkbox text where it belongs (polyetilen)
- #11208 `80b0f37` *Fixing offscreen GUI issue (MeshCollider)

### Wallet
- #9359 `f7ec7cf` Add test for CWalletTx::GetImmatureCredit() returning stale values (ryanofsky)
- #9576 `56ab672` [wallet] Remove redundant initialization (practicalswift)
- #9333 `fa625b0` Document CWalletTx::mapValue entries and remove erase of nonexistent "version" entry (ryanofsky)
- #9906 `72fb515` Disallow copy constructor CReserveKeys (instagibbs)
- #9369 `3178b2c` Factor out CWallet::nTimeSmart computation into a method (ryanofsky)
- #9830 `afcd7c0` Add safe flag to listunspent result (NicolasDorier)
- #9993 `c49355c` Initialize nRelockTime (pstratem)
- #9818 `3d857f3` Save watch only key timestamps when reimporting keys (ryanofsky)
- #9294 `f34cdcb` Use internal HD chain for change outputs (hd split) (jonasschnelli)
- #10164 `e183ea2` Wallet: reduce excess logic InMempool() (kewde)
- #10186 `c9ff4f8` Remove SYNC_TRANSACTION_NOT_IN_BLOCK magic number (jnewbery)
- #10226 `64c45aa` wallet: Use boost to more portably ensure -wallet specifies only a filename (luke-jr)
- #9827 `c91ca0a` Improve ScanForWalletTransactions return value (ryanofsky)
- #9951 `fa1ac28` Wallet database handling abstractions/simplifications (laanwj)
- #10265 `c29a0d4` [wallet] [moveonly] Check non-null pindex before potentially referencing (kallewoof)
- #10283 `a550f6e` Cleanup: reduce to one GetMinimumFee call signature (morcos)
- #10294 `e2b99b1` [Wallet] unset change position when there is no change (instagibbs)
- #10115 `d3dce0e` Avoid reading the old hd master key during wallet encryption (TheBlueMatt)
- #10341 `18c9deb` rpc/wallet: Workaround older UniValue which returns a std::string temporary for get_str (luke-jr)
- #10308 `94e5227` [wallet] Securely erase potentially sensitive keys/values (tjps)
- #10257 `ea1fd43` [test] Add test for getmemoryinfo (jimmysong)
- #10295 `ce8176d` [qt] Move some WalletModel functions into CWallet (ryanofsky)
- #10506 `7cc2c67` Fix bumpfee test after #10449 (ryanofsky)
- #10500 `098b01d` Avoid CWalletTx copies in GetAddressBalances and GetAddressGroupings (ryanofsky)
- #10455 `0747d33` Simplify feebumper minimum fee code slightly (ryanofsky)
- #10522 `2805d60` [wallet] Remove unused variables (practicalswift)
- #8694 `177433a` Basic multiwallet support (luke-jr)
- #10598 `7a74f88` Supress struct/class mismatch warnings introduced in #10284 (paveljanik)
- #9343 `209eef6` Don't create change at dust limit (morcos)
- #10744 `ed88e31` Use method name via __func__ macro (darksh1ne)
- #10712 `e8b9523` Add change output if necessary to reduce excess fee (morcos)
- #10816 `1c011ff` Properly forbid -salvagewallet and -zapwallettxes for multi wallet (morcos)
- #10235 `5cfdda2` Track keypool entries as internal vs external in memory (TheBlueMatt)
- #10330 `bf0a08b` [wallet] fix zapwallettxes interaction with persistent mempool (jnewbery)
- #10831 `0b01935` Batch flushing operations to the walletdb during top up and increase keypool size (gmaxwell)
- #10795 `7b6e8bc` No longer ever reuse keypool indexes (TheBlueMatt)
- #10849 `bde4f93` Multiwallet: simplest endpoint support (jonasschnelli)
- #10817 `9022aa3` Redefine Dust and add a discard_rate (morcos)
- #10883 `bf3b742` Rename -usewallet to -rpcwallet (morcos)
- #10604 `420238d` [wallet] [tests] Add listwallets RPC, include wallet name in `getwalletinfo` and add multiwallet test (jnewbery)
- #10885 `70888a3` Reject invalid wallets (promag)
- #10949 `af56397` Clarify help message for -discardfee (morcos)
- #10942 `2e857bb` Eliminate fee overpaying edge case when subtracting fee from recipients (morcos)
- #10995 `fa64636` Fix resendwallettransactions assert failure if -walletbroadcast=0 (TheBlueMatt)
- #11022 `653a46d` Basic keypool topup (jnewbery)
- #11081 `9fe1f6b` Add length check for CExtKey deserialization (jonasschnelli, guidovranken)
- #11044 `4ef8374` [wallet] Keypool topup cleanups (jnewbery)
- #11145 `e51bb71` Fix rounding bug in calculation of minimum change (morcos)
- #9605 `779f2f9` Use CScheduler for wallet flushing, remove ThreadFlushWalletDB (TheBlueMatt)
- #10108 `4e3efd4` ApproximateBestSubset should take inputs by reference, not value (RHavar)

### Mining

- n/a   `2421dd2` *coin_age_priority: Ensure nPackagesSelected and nDescendantsUpdated get updated for priority-mined transactions (luke-
jr)

### Tests and QA
- #9744 `8efd1c8` Remove unused module from rpc-tests (34ro)
- #9657 `7ff4a53` Improve rpc-tests.py (jnewbery)
- #9766 `7146d96` Add --exclude option to rpc-tests.py (jnewbery)
- #9577 `d6064a8` Fix docstrings in qa tests (jnewbery)
- #9823 `a13a417` qa: Set correct path for binaries in rpc tests (MarcoFalke)
- #9847 `6206252` Extra test vector for BIP32 (sipa)
- #9350 `88c2ae3` [Trivial] Adding label for amount inside of tx_valid/tx_invalid.json (Christewart)
- #9888 `36afd4d` travis: Verify commits only for one target (MarcoFalke)
- #9904 `58861ad` test: Fail if InitBlockIndex fails (laanwj)
- #9828 `67c5cc1` Avoid -Wshadow warnings in wallet_tests (ryanofsky)
- #9832 `48c3429` [qa] assert_start_raises_init_error (NicolasDorier)
- #9739 `9d5fcbf` Fix BIP68 activation test (jnewbery)
- #9547 `d32581c` bench: Assert that division by zero is unreachable (practicalswift)
- #9843 `c78adbf` Fix segwit getblocktemplate test (jnewbery)
- #9929 `d5ce14e` tests: Delete unused function _rpchost_to_args (laanwj)
- #9555 `19be26a` [test] Avoid reading a potentially uninitialized variable in tx_invalid-test (transaction_tests.cpp) (practicalswift)
- #9945 `ac23a7c` Improve logging in bctest.py if there is a formatting mismatch (jnewbery)
- #9768 `8910b47` [qa] Add logging to test_framework.py (jnewbery)
- #9972 `21833f9` Fix extended rpc tests broken by #9768 (jnewbery)
- #9977 `857d1e1` QA: getblocktemplate_longpoll.py should always use >0 fee tx (sdaftuar)
- #9970 `3cc13ea` Improve readability of segwit.py, smartfees.py (sdaftuar)
- #9497 `2c781fb` CCheckQueue Unit Tests (JeremyRubin)
- #10024 `9225de2` [trivial] Use log.info() instead of print() in remaining functional test cases (jnewbery)
- #9956 `3192e52` Reorganise qa directory (jnewbery)
- #10017 `02d64bd` combine_logs.py - aggregates log files from multiple bitcoinds during functional tests (jnewbery)
- #10047 `dfef6b6` [tests] Remove unused variables and imports (practicalswift)
- #9701 `a230b05` Make bumpfee tests less fragile (ryanofsky)
- #10053 `ca20923` [test] Allow functional test cases to be skipped (jnewbery)
- #10052 `a0b1e57` [test] Run extended tests once daily in Travis (jnewbery)
- #10069 `1118493` [QA] Fix typo in fundrawtransaction test (NicolasDorier)
- #10083 `c044f03` [QA] Renaming rawTx into rawtx (NicolasDorier)
- #10073 `b1a4f27` Actually run assumevalid.py (jnewbery)
- #9780 `c412fd8` Suppress noisy output from qa tests in Travis (jnewbery)
- #10096 `79af9fb` Check that all test scripts in test/functional are being run (jnewbery)
- #10076 `5b029aa` [qa] combine_logs: Use ordered list for logfiles (MarcoFalke)
- #10107 `f2734c2` Remove unused variable. Remove accidental trailing semicolons in Python code (practicalswift)
- #10109 `8ac8041` Remove SingleNodeConnCB (jnewbery)
- #10114 `edc62c9` [tests] sync_with_ping should assert that ping hasn't timed out (jnewbery)
- #10128 `427d2fd` Speed Up CuckooCache tests (JeremyRubin)
- #10072 `12af74b` Remove sources of unreliablility in extended functional tests (jnewbery)
- #10077 `ebfd653` [qa] Add setnetworkactive smoke test (MarcoFalke)
- #10152 `080d7c7` [trivial] remove unused line in Travis config (jnewbery)
- #10159 `df1ca9e` [tests] color test results and sort alphabetically (jnewbery)
- #10124 `88799ea` [test] Suppress test logging spam (jnewbery)
- #10142 `ed09dd3` Run bitcoin_test-qt under minimal QPA platform (ryanofsky)
- #9949 `a27dbc5` [bench] Avoid function call arguments which are pointers to uninitialized values (practicalswift)
- #10187 `b44adf9` tests: Fix test_runner return value in case of skipped test (laanwj)
- #10197 `d86bb07` [tests] Functional test warnings (jnewbery)
- #10219 `9111df9` Tests: Order Python Tests Differently (jimmysong)
- #10229 `f3db4c6` Tests: Add test for getdifficulty (jimmysong)
- #10224 `2723bcd` [test] Add test for getaddednodeinfo (jimmysong)
- #10023 `c530c15` [tests] remove maxblocksinflight.py (functionality covered by other test) (jnewbery)
- #10097 `1b25b6d` Move zmq test skipping logic into individual test case (jnewbery)
- #10272 `54e2d87` [Tests] Prevent warning: variable 'x' is uninitialized (paveljanik)
- #10225 `e0a7e19` [test] Add aborttrescan tests (kallewoof)
- #10278 `8254a8a` [test] Add Unit Test for GetListenPort (jimmysong)
- #10280 `47535d7` [test] Unit test amount.h/amount.cpp (jimmysong)
- #10256 `80c3a73` [test] Add test for gettxout to wallet.py (jimmysong)
- #10264 `492d22f` [test] Add tests for getconnectioncount, getnettotals and ping (jimmysong)
- #10169 `8f3e384` [tests] Remove func test code duplication (jnewbery)
- #10198 `dc8fc0c` [tests] Remove is_network_split from functional test framework (jnewbery)
- #10255 `3c5e6c9` [test] Add test for listaddressgroupings (jimmysong)
- #10137 `75171f0` Remove unused import. Remove accidental trailing semicolons (practicalswift)
- #10307 `83073de` [tests] allow zmq test to be run in out-of-tree builds (jnewbery)
- #10344 `e927483` [tests] Fix abandonconflict.py intermittency (jnewbery)
- #10318 `170bc2c` [tests] fix wait_for_inv() (jnewbery)
- #10171 `fff72de` [tests] Add node methods to test framework (jnewbery)
- #10352 `23d78c4` test: Add elapsed time to RPC tracing (laanwj)
- #10342 `6a796b2` [tests] Improve mempool_persist test (jnewbery)
- #10287 `776ba23` [tests] Update Unit Test for addrman.h/addrman.cpp (jimmysong)
- #10365 `7ee5236` [tests] increase timeouts in sendheaders test (jnewbery)
- #10361 `f6241b3` qa: disablewallet: Check that wallet is really disabled (MarcoFalke)
- #10371 `4b766fc` [tests] Clean up addrman_tests.cpp (jimmysong)
- #10253 `87abe20` [test] Add test for getnetworkhashps (jimmysong)
- #10376 `8bd16ee` [tests] fix disconnect_ban intermittency (jnewbery)
- #10374 `5411997` qa: Warn when specified test is not found (MarcoFalke)
- #10405 `0542978` tests: Correct testcase in script_tests.json for large number OP_EQUAL (laanwj)
- #10429 `6b99daf` tests: fix spurious addrman test failure (theuni)
- #10433 `8e57256` [tests] improve tmpdir structure (jnewbery)
- #10415 `217b416` [tests] Speed up fuzzing by ~200x when using afl-fuzz (practicalswift)
- #10445 `b4b057a` Add test for empty chain and reorg consistency for gettxoutsetinfo (gmaxwell)
- #10423 `1aefc94` [tests] skipped tests should clean up after themselves (jnewbery)
- #10359 `329fc1d` [tests] functional tests should call BitcoinTestFramework start/stop node methods (jnewbery)
- #10514 `e103b3f` Bugfix: missing == 0 after randrange (sipa)
- #10515 `c871f32` [test] Add test for getchaintxstats (jimmysong)
- #10509 `bea5b00` Remove xvfb configuration from travis (ryanofsky)
- #10535 `30853e1` [qa] fundrawtx: Fix shutdown race (MarcoFalke)
- #9909 `300f8e7` tests: Add FindEarliestAtLeast test for edge cases (ryanofsky)
- #10331 `75e898c` Share config between util and functional tests (jnewbery)
- #10321 `e801084` Use FastRandomContext for all tests (sipa)
- #10524 `6c2d81f` [tests] Remove printf(...) (practicalswift)
- #10547 `71ab6e5` [tests] Use FastRandomContext instead of boost::random::{mt19937,uniform_int_distribution} (practicalswift)
- #10551 `6702617` [Tests] Wallet encryption functional tests (achow101)
- #10555 `643fa0b` [tests] various improvements to zmq_test.py (jnewbery)
- #10533 `d083bd9` [tests] Use cookie auth instead of rpcuser and rpcpassword (achow101)
- #10632 `c68a9a6` qa: Add stopatheight test (MarcoFalke)
- #10636 `4bc853b` [qa] util: Check return code after closing bitcoind proc (MarcoFalke)
- #10662 `e0a7801` Initialize randomness in benchmarks (achow101)
- #10612 `7c87a9c` The young person's guide to the test_framework (jnewbery)
- #10659 `acb1153` [qa] blockchain: Pass on closed connection during generate call (MarcoFalke)
- #10690 `416af3e` [qa] Bugfix: allow overriding extra_args in ComparisonTestFramework (sdaftuar)
- #10556 `65cc7aa` Move stop/start functions from utils.py into BitcoinTestFramework (jnewbery)
- #10704 `dd07f47` [tests] nits in dbcrash.py (jnewbery)
- #10743 `be82498` [test] don't run dbcrash.py on Travis (jnewbery)
- #10761 `d3b5870` [tests] fix replace_by_fee.py (jnewbery)
- #10759 `1d4805c` Fix multi_rpc test for hosts that dont default to utf8 (TheBlueMatt)
- #10190 `e4f226a` [tests] mining functional tests (including regression test for submitblock) (jnewbery)
- #10739 `1fc783f` test: Move variable `state` down where it is used (paveljanik)
- #9980 `fee0d80` Fix mem access violation merkleblock (Christewart)
- #10893 `0c173a1` [QA] Avoid running multiwallet.py twice (jonasschnelli)
- #10927 `9d5e8f9` test: Make sure wallet.backup is created in temp path (laanwj)
- #10899 `f29d5db` [test] Qt: Use _putenv_s instead of setenv on Windows builds (brianmcmichael)
- #10912 `5c8eb79` [tests] Fix incorrect memory_cleanse(?) call in crypto_tests.cpp (practicalswift)
- #11001 `fa8a063` [tests] Test disconnecting unsupported service bits logic (jnewbery)
- #10695 `929fd72` [qa] Rewrite BIP65/BIP66 functional tests (sdaftuar)
- #10963 `ecd2135` [bench] Restore format state of cout after printing with std::fixed/setprecision (practicalswift)
- #11025 `e5d26e4` qa: Fix inv race in example_test (MarcoFalke)
- #10765 `2c811e0` Tests: address placement should be deterministic by default (ReneNyffenegger)
- #11000 `ac016e1` test: Add resendwallettransactions functional tests (promag)
- #11032 `aeb3175` [qa] Fix block message processing error in sendheaders.py (sdaftuar)
- #10105 `0b9fb68` [tests] fixup - make all Travis test runs quiet, non just cron job runs (jnewbery)
- #10222 `6ce7337` [tests] test_runner - check unicode (jnewbery)
- #10327 `35da2ae` [tests] remove import-abort-rescan.py (jnewbery)
- #11023 `bf74d37` [tests] Add option to attach a python debugger if functional test fails (jnewbery)
- #10565 `8c2098a` [coverage] Remove subtrees and benchmarks from coverage report (achow101)
- #7061 `21630f8` *Add RPC based rescan test (jonasschnelli)
- #9152 `d109d58` *QA: Functional test for sweepprivkeys (luke-jr)

### Miscellaneous
- #9871 `be8ba2c` Add a tree sha512 hash to merge commits (sipa)
- #9821 `d19d45a` util: Specific GetOSRandom for Linux/FreeBSD/OpenBSD (laanwj)
- #9903 `ba80a68` Docs: add details to -rpcclienttimeout doc (ian-kelling)
- #9910 `53c300f` Docs: correct and elaborate -rpcbind doc (ian-kelling)
- #9905 `01b7cda` [contrib] gh-merge: Move second sha512 check to the end (MarcoFalke)
- #9880 `4df8213` Verify Tree-SHA512s in merge commits, enforce sigs are not SHA1 (TheBlueMatt)
- #9932 `00c13ea` Fix verify-commits on travis and always check top commit's tree (TheBlueMatt)
- #9952 `6996e06` Add historical release notes for 0.14.0 (laanwj)
- #9940 `fa99663` Fix verify-commits on OSX, update for new bad Tree-SHA512, point travis to different keyservers (TheBlueMatt)
- #9963 `8040ae6` util: Properly handle errors during log message formatting (laanwj)
- #9984 `cce056d` devtools: Make github-merge compute SHA512 from git, instead of worktree (laanwj)
- #9995 `8bcf934` [doc] clarify blockchain size and pruning (askmike)
- #9734 `0c17afc` Add updating of chainTxData to release process (sipa)
- #10063 `530fcbd` add missing spaces so that markdown recognizes headline (flack)
- #10085 `db1ae54` Docs: remove 'noconnect' option (jlopp)
- #10090 `8e4f7e7` Update bitcoin.conf with example for pruning (coinables)
- #9424 `1a5aaab` Change LogAcceptCategory to use uint32_t rather than sets of strings (gmaxwell)
- #10036 `fbf36ca` Fix init README format to render correctly on github (jlopp)
- #10058 `a2cd0b0` No need to use OpenSSL malloc/free (tjps)
- #10123 `471ed00` Allow debug logs to be excluded from specified component (jnewbery)
- #10104 `fadf078` linearize script: Option to use RPC cookie (achow101)
- #10162 `a3a2160` [trivial] Log calls to getblocktemplate (jnewbery)
- #10155 `928695b` build: Deduplicate version numbers (laanwj)
- #10211 `a86255b` [doc] Contributor fixes & new "finding reviewers" section (kallewoof)
- #10250 `1428f30` Fix some empty vector references (sipa)
- #10270 `95f5e44` Remove Clang workaround for Boost 1.46 (fanquake)
- #10263 `cb007e4` Trivial: fix fee estimate write error log message (CryptAxe)
- #9670 `bd9ec0e` contrib: github-merge improvements (laanwj)
- #10260 `1d75597` [doc] Minor corrections to osx dependencies (fanquake)
- #10189 `750c5a5` devtools/net: add a verifier for scriptable changes. Use it to make CNode::id private (theuni)
- #10322 `bc64b5a` Use hardware timestamps in RNG seeding (sipa)
- #10381 `7f2b9e0` Shadowing warnings are not enabled by default, update doc accordingly (paveljanik)
- #10380 `b6ee855` [doc] Removing comments about dirty entries on txmempool (madeo)
- #10383 `d0c37ee` [logging] log system time and mock time (jnewbery)
- #10404 `b45a52a` doc: Add logging to FinalizeNode() (sdaftuar)
- #10388 `526e839` Output line to debug.log when IsInitialBlockDownload latches to false (morcos)
- #10372 `15254e9` Add perf counter data to GetStrongRandBytes state in scheduler (TheBlueMatt)
- #10461 `55b72f3` Update style guide (sipa)
- #10486 `10e8c0a` devtools: Retry after signing fails in github-merge (laanwj)
- #10447 `f259263` Make bitcoind invalid argument error message specific (laanwj)
- #10495 `6a38b79` contrib: Update location of seeds.txt (laanwj)
- #10469 `b6b150b` Fixing typo in rpcdump.cpp help message (keystrike)
- #10451 `27b9931` contrib/init/bitcoind.openrcconf: Don't disable wallet by default (luke-jr)
- #10323 `00d3692` Update to latest libsecp256k1 master (sipa)
- #10422 `cec9e1e` Fix timestamp in fee estimate debug message (morcos)
- #10566 `5d034ee` [docs] Use the "domain name setup" image (previously unused) in the gitian docs (practicalswift)
- #10534 `a514ac3` Clarify prevector::erase and avoid swap-to-clear (sipa)
- #10575 `22ec768` Header include guideline (sipa)
- #10480 `fbf5d3b` Improve commit-check-script.sh (sipa)
- #10502 `1ad3d4e` scripted-diff: Remove BOOST_FOREACH, Q_FOREACH and PAIRTYPE (jtimon)
- #10377 `b63be2c` Use rdrand as entropy source on supported platforms (sipa)
- #9895 `228c319` Turn TryCreateDirectory() into TryCreateDirectories() (benma)
- #10602 `d76e84a` Make clang-format use C++11 features (e.g. A<A<int>> instead of A<A<int> >) (practicalswift)
- #10623 `c38f540` doc: Add 0.14.2 release notes (MarcoFalke)
- #10276 `b750b33` contrib/verifybinaries: allow filtering by platform (knocte)
- #10248 `01c4b14` Rewrite addrdb with less duplication using CHashVerifier (sipa)
- #10577 `232508f` Add an explanation of quickly hashing onto a non-power of two range (gmaxwell)
- #10608 `eee398f` Add a comment explaining the use of MAX_BLOCK_BASE_SIZE (gmaxwell)
- #10728 `7397af9` fix typo in help text for removeprunedfunds (AkioNak)
- #10193 `6dbcc74` scripted-diff: Remove #include <boost/foreach.hpp> (jtimon)
- #10676 `379aed0` document script-based return fields for validateaddress (instagibbs)
- #10651 `cef4b5c` Verify binaries from bitcoincore.org and bitcoin.org (TheBlueMatt)
- #10786 `ca4c545` Add PR description to merge commit in github-merge.py (sipa)
- #10812 `c5904e8` [utils] Allow bitcoin-cli's -rpcconnect option to be used with square brackets (jnewbery)
- #10842 `3895e25` Fix incorrect Doxygen tag (@ince ? @since). Doxygen parameter name matching (practicalswift)
- #10681 `df0793f` add gdb attach process to test README (instagibbs)
- #10789 `1124328` Punctuation/grammer fixes in rpcwallet.cpp (stevendlander)
- #10655 `78f307b` Properly document target_confirmations in listsinceblock (RHavar)
- #10917 `5c003cb` developer-notes: add reference to snake_case and PascalCase (benma)
- #11003 `4b5a7ce` Docs: Capitalize bullet points in CONTRIBUTING guide (eklitzke)
- #10968 `98aa3f6` Add instructions for parallel gitian builds (coblee)
- #11076 `1c4b9b3` 0.15 release-notes nits: fix redundancy, remove accidental parenthesis & fix range style (practicalswift)
- #11090 `8f0121c` Update contributor names in release-notes.md (Derek701)
- #11056 `cbdd338` disable jni in builds (instagibbs)
- #11080 `2b59cfb` doc: Update build-openbsd for 6.1 (laanwj)
- #11119 `0a6af47` [doc] build-windows: Mention that only trusty works (MarcoFalke)
- #11108 `e8ad101` Changing -txindex requires -reindex, not -reindex-chainstate (TheBlueMatt)
- #9792 `342b9bc` FastRandomContext improvements and switch to ChaCha20 (sipa)
- #9505 `67ed40e` Prevector Quick Destruct (JeremyRubin)
- #10820 `ef37f20` Use cpuid intrinsics instead of asm code (sipa)
- #9999 `a328904` [LevelDB] Plug leveldb logs to bitcoin logs (NicolasDorier)
- #9693 `c5e9e42` Prevent integer overflow in ReadVarInt (gmaxwell)
- #10129 `351d0ad` scheduler: fix sub-second precision with boost < 1.50 (theuni)
- #10153 `fade788` logging: Fix off-by-one for shrinkdebugfile default (MarcoFalke)
- #10305 `c45da32` Fix potential NPD introduced in b297426c (TheBlueMatt)
- #10338 `daf3e7d` Maintain state across GetStrongRandBytes calls (sipa)
- #10544 `a4fe077` Update to LevelDB 1.20 (sipa)
- #10614 `cafe24f` random: fix crash on some 64bit platforms (theuni)
- #10714 `2a09a38` Avoid printing incorrect block indexing time due to uninitialized variable (practicalswift)
- #10837 `8bc6d1f` Fix resource leak on error in GetDevURandom (corebob)
- #10832 `89bb036` init: Factor out AppInitLockDataDirectory and fix startup core dump issue (laanwj)
- #10914 `b995a37` Add missing lock in CScheduler::AreThreadsServicingQueue() (TheBlueMatt)
- #10958 `659c096` Update to latest Bitcoin patches for LevelDB (sipa)
- #10919 `c1c671f` Fix more init bugs (TheBlueMatt)
- #7107 `9190a76` *ArgsManager: ForceSetArg with int64_t (luke-jr)
- #9849 `6091bf1` *CValidationInterface: ValidationInterfaceUnregistering, called when being unregistered (luke-jr)
- n/a    `c36f8ba` *Bump minimum Windows version to Vista
- #10729 `2eea64b` *script/interpreter: Wrap EvalScript in a ScriptExecution class (luke-jr)
- #10730 `7acd5fc` *Move script flag to/from-string logic from tests to script/interpreter (luke-jr)

Credits
=======

Thanks to everyone who directly contributed to this release:

- ??? ??
- Ahmad Kazi
- aideca
- Akio Nakamura
- Aleksandras Ragovskis
- Alex Morcos
- Allan Doensen
- Andres G. Aragoneses
- Andrew Chow
- Angel Leon
- Awemany
- Bob McElrath
- Brian McMichael
- BtcDrak
- Charlie Lee
- Chris Gavin
- Chris Stewart
- Cory Fields
- CryptAxe
- Dag Robole
- Daniel Aleksandersen
- Daniel Cousens
- Daniel Edgecumbe
- darksh1ne
- Dimitris Tsapakidis
- Doron Somech
- Eric Lombrozo
- Eric Shaw
- Evan Klitzke
- fanquake
- Felix Weis
- flack
- Guido Vranken
- Greg Griffith
- Gregory Maxwell
- Gregory Sanders
- Ian Kelling
- Jack Grigg
- James Evans
- James Hilliard
- Jameson Lopp
- Jeremy Rubin
- Jimmy Song
- Jo?o Barbosa
- Joe Harvell
- Johnathan Corgan
- John Newbery
- Jonas Schnelli
- Jorge Tim?n
- Karl-Johan Alm
- kewde
- KibbledJiveElkZoo
- Kirit Thadaka
- kobake
- Kyle Honeycutt
- Lawrence Nahum
- Luke Dashjr
- Marco Falke
- Marcos Mayorga
- Marijn Stollenga
- Mario Dian
- Mark Friedenbach
- Marko Bencun
- Masahiko Hyuga
- Matt Corallo
- Matthew Zipkin
- Matthias Grundmann
- MeshCollider
- Michael Goldstein
- Michael Rotarius
- Mikerah
- Mike van Rossum
- Mitchell Cash
- Nicolas Dorier
- Patrick Strateman
- Pavel Jan?k
- Pavlos Antoniou
- Pavol Rusnak
- Pedro Branco
- Peter Todd
- Pieter Wuille
- practicalswift
- Ren? Nyffenegger
- Ricardo Velhote
- romanornr
- Russell Yanofsky
- Rusty Russell
- Ryan Havar
- shaolinfry
- Shigeya Suzuki
- Simone Madeo
- Spencer Lievens
- Steven D. Lander
- Suhas Daftuar
- Takashi Mitsuta
- Thomas Snider
- Timothy Redaelli
- tintinweb
- tnaka
- Warren Togami
- Wladimir J. van der Laan

As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 1528 bytes
Desc: This is a digitally signed message part.
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170915/b7da0bb6/attachment-0001.sig>

From dan at osc.co.cr  Fri Sep 15 19:55:56 2017
From: dan at osc.co.cr (Dan Libby)
Date: Fri, 15 Sep 2017 12:55:56 -0700
Subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?
In-Reply-To: <SU02clg--S4TtIK4TZIytgdnHE8SzXBwSEb_FN5edtPAaojLwCEd6OTNkBUrDiH1FwHPuD4D5yByE7r4Fz_-CVzzU9KK0xvmDGlWNxTp3aU=@protonmail.com>
References: <9e212eae-08d5-d083-80d9-a8e29679fcdc@osc.co.cr>
	<SU02clg--S4TtIK4TZIytgdnHE8SzXBwSEb_FN5edtPAaojLwCEd6OTNkBUrDiH1FwHPuD4D5yByE7r4Fz_-CVzzU9KK0xvmDGlWNxTp3aU=@protonmail.com>
Message-ID: <9a541ba8-7c25-fdbb-505f-6426f61bdc63@osc.co.cr>

Ok, this is good stuff.  thanks for the thoughtful reply.

Regarding anyone-can-spend:

all of the examples you gave do not satisfy isStandard.  So if our
hypothetical cryptocurrency were to restrict all transactions to
isStandard at the consensus layer, would that not effectively prevent
anyone-can-spend?

Or more generally and with our thinking caps on, what would be the best
way to prevent anyone-can-spend, if that is our goal?


Regarding soft-fork = restrict:

Your example of miners running secret soft-fork code that blacklists
satoshi's utxo's is intriguing and somewhat troubling.

I think the main takeaways are that:
  1) there are other ways to soft-fork besides anyone-can-spend.
  2) it is impossible to prevent hidden soft-forks.

Is that accurate?

Still, I would put forth the following question:  If anyone-can-spend tx
were no longer allowed according to consensus rules (assuming that is
possible/practical), then could the network still be practically
"upgraded" with new features (eg opcodes) via soft-fork, and if so, what
would be the mechanism for backwards compatibility in this scenario?


or from another angle:  even if it is impossible to prevent all
soft-forks, can you see any way at all to make it logistically
infeasible to use soft-forks as a network-wide consensus change mechanism?

and another thought:  as I understand it, bitcoin is presently able to
add new opcodes via soft-fork because Satoshi added 10 unused opcodes
via hardfork. What will happen when these run out?  Can new opcodes
still be added without a hard-fork?


note: I ask these questions with the goal/vision of creating an
immutable altcoin or sidechain, not necessarily restricting bitcoin's path.





On 09/14/2017 09:01 PM, ZmnSCPxj wrote:
> Good morning Dan,
> 
> My understanding is that it is impossible for soft forks to be prevented.
> 
> 1.  Anyone-can-spend
> 
> There are a very large number of anyone-can-spend scripts, and it would
> be very impractical to ban them all.
> 
> For example, the below output script is anyone-can-spend
> 
>  <random number> OP_TRUE
> 
> So is the below:
> 
>   OP_SIZE <random small number> OP_EQUAL
> 
> Or:
> 
>   OP_1ADD <random number> OP_EQUAL
> 
> Or:
> 
>   OP_BOOLAND
> 
> Or:
> 
>   OP_BOOLOR
> 
> And so on.
> 
> So no, it is not practically possible to ban anyone-can-spend outputs,
> as there are too many potential scriptPubKey that anyone can spend.
> 
> It is even possible to have an output that requires a proof-of-work,
> like so:
> 
>  OP_HASH256 <difficulty target> OP_LESSTHAN
> 
> All the above outputs are disallowed from propagation by IsStandard, but
> a miner can put them validly in a block, and IsStandard is not consensus
> code and can be modified.
> 
> 2.  Soft fork = restrict
> 
> It is possible (although unlikely) for a majority of miners to run soft
> forking code which the rest of us are not privy to.
> 
> For example, for all we know, miners are already blacklisting spends on
> Satoshi's coins.  We would not be able to detect this at all, since no
> transaction that spends Satoshi's coins have been broadcast, ever.  It
> is thus indistinguishable from a world where Satoshi lost his private
> keys.  Of course, the world where Satoshi never spent his coins and
> miners are blacklisting Satoshi's coins, is more complex than the world
> where Satoshi never spent his coins, so it is more likely that miners
> are not blacklisting.
> 
> But the principle is there.  We may already be in a softfork whose rules
> we do not know, and it just so happens that all our transactions today
> do not violate those rules.  It is impossible for us to know this, but
> it is very unlikely.
> 
> Soft forks apply further restrictions on Bitcoin.  Hard forks do not. 
> Thus, if everyone else is entering a soft fork and we are oblivious, we
> do not even know about it.  Whereas, if everyone else is entering a hard
> fork, we will immediately see (and reject) invalid transactions and blocks.
> 
> Thus the only way to prevent soft fork is to hard fork against the new
> soft fork, like Bcash did.
> 
> Regards,
> ZmnSCPxj
> 
> -------- Original Message --------
> Subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?
> Local Time: September 13, 2017 5:50 PM
> UTC Time: September 13, 2017 9:50 AM
> From: bitcoin-dev at lists.linuxfoundation.org
> To: Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>
> 
> Hi, I am interested in the possibility of a cryptocurrency software
> (future bitcoin or a future altcoin) that strives to have immutable
> consensus rules.
> 
> The goal of such a cryptocurrency would not be to have the latest and
> greatest tech, but rather to be a long-term store of value and to offer
> investors great certainty and predictability... something that markets
> tend to like. And of course, zero consensus rule changes also means
> less chance of new bugs and attack surface remains the same, which is
> good for security.
> 
> Of course, hard-forks are always possible. But that is a clear split
> and something that people must opt into. Each party has to make a
> choice, and inertia is on the side of the status quo. Whereas
> soft-forks sort of drag people along with them, even those who oppose
> the changes and never upgrade. In my view, that is problematic,
> especially for a coin with permanent consensus rule immutability as a
> goal/ethic.
> 
> As I understand it, bitcoin soft-forks always rely on anyone-can-spend
> transactions. If those were removed, would it effectively prevent
> soft-forks, or are there other possible mechanisms? How important are
> any-one-can spend tx for other uses?
> 
> More generally, do you think it is possible to programmatically
> avoid/ban soft-forks, and if so, how would you go about it?
> 
> 
> 
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From dan at osc.co.cr  Fri Sep 15 20:01:48 2017
From: dan at osc.co.cr (Dan Libby)
Date: Fri, 15 Sep 2017 13:01:48 -0700
Subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?
In-Reply-To: <CALqxMTFEA2X0GJwF8rO=8twsgW=brrzScpDD=owiK9otocdjoA@mail.gmail.com>
References: <9e212eae-08d5-d083-80d9-a8e29679fcdc@osc.co.cr>
	<SU02clg--S4TtIK4TZIytgdnHE8SzXBwSEb_FN5edtPAaojLwCEd6OTNkBUrDiH1FwHPuD4D5yByE7r4Fz_-CVzzU9KK0xvmDGlWNxTp3aU=@protonmail.com>
	<CALqxMTFEA2X0GJwF8rO=8twsgW=brrzScpDD=owiK9otocdjoA@mail.gmail.com>
Message-ID: <bb4015e7-f69f-d273-115e-c115ec2d8f0a@osc.co.cr>

On 09/15/2017 02:14 AM, Adam Back wrote:
> However most types of soft fork are opt-in...

my concern is that the community can be manipulated via political means.
 marketing, social media, payoffs, fud, etc, etc, etc.  And essentially
degrades to tyranny of the majority.


So if there is any way to make opt-in forks impractical/infeasible for
purpose of network wide consensus rule change, I'd love to hear it.

From simone.bronzini at chainside.net  Fri Sep 15 20:40:12 2017
From: simone.bronzini at chainside.net (Simone Bronzini)
Date: Fri, 15 Sep 2017 22:40:12 +0200
Subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?
In-Reply-To: <9a541ba8-7c25-fdbb-505f-6426f61bdc63@osc.co.cr>
References: <9e212eae-08d5-d083-80d9-a8e29679fcdc@osc.co.cr>
	<SU02clg--S4TtIK4TZIytgdnHE8SzXBwSEb_FN5edtPAaojLwCEd6OTNkBUrDiH1FwHPuD4D5yByE7r4Fz_-CVzzU9KK0xvmDGlWNxTp3aU=@protonmail.com>
	<9a541ba8-7c25-fdbb-505f-6426f61bdc63@osc.co.cr>
Message-ID: <0c98e067-dff3-988b-af66-7c624de3eef4@chainside.net>

Since a soft-fork is a restriction of the consensus rules, I think the
only way to have an un-soft-forkable cryptocurrency is creating a
cryptocurrency where no transaction is valid.

Imagine I build a very minimal cryptocurrency where in the transaction
output you only indicate the public key to send your coins to and the
amount. One can still soft-fork it by deciding that, from now on, only
even amounts are valid or only public keys that are a multiple of 10 are
valid.


On 15/09/17 21:55, Dan Libby via bitcoin-dev wrote:
> Ok, this is good stuff.  thanks for the thoughtful reply.
>
> Regarding anyone-can-spend:
>
> all of the examples you gave do not satisfy isStandard.  So if our
> hypothetical cryptocurrency were to restrict all transactions to
> isStandard at the consensus layer, would that not effectively prevent
> anyone-can-spend?
>
> Or more generally and with our thinking caps on, what would be the best
> way to prevent anyone-can-spend, if that is our goal?
>
>
> Regarding soft-fork = restrict:
>
> Your example of miners running secret soft-fork code that blacklists
> satoshi's utxo's is intriguing and somewhat troubling.
>
> I think the main takeaways are that:
>   1) there are other ways to soft-fork besides anyone-can-spend.
>   2) it is impossible to prevent hidden soft-forks.
>
> Is that accurate?
>
> Still, I would put forth the following question:  If anyone-can-spend tx
> were no longer allowed according to consensus rules (assuming that is
> possible/practical), then could the network still be practically
> "upgraded" with new features (eg opcodes) via soft-fork, and if so, what
> would be the mechanism for backwards compatibility in this scenario?
>
>
> or from another angle:  even if it is impossible to prevent all
> soft-forks, can you see any way at all to make it logistically
> infeasible to use soft-forks as a network-wide consensus change mechanism?
>
> and another thought:  as I understand it, bitcoin is presently able to
> add new opcodes via soft-fork because Satoshi added 10 unused opcodes
> via hardfork. What will happen when these run out?  Can new opcodes
> still be added without a hard-fork?
>
>
> note: I ask these questions with the goal/vision of creating an
> immutable altcoin or sidechain, not necessarily restricting bitcoin's path.
>
>
>
>
>
> On 09/14/2017 09:01 PM, ZmnSCPxj wrote:
>> Good morning Dan,
>>
>> My understanding is that it is impossible for soft forks to be prevented.
>>
>> 1.  Anyone-can-spend
>>
>> There are a very large number of anyone-can-spend scripts, and it would
>> be very impractical to ban them all.
>>
>> For example, the below output script is anyone-can-spend
>>
>>  <random number> OP_TRUE
>>
>> So is the below:
>>
>>   OP_SIZE <random small number> OP_EQUAL
>>
>> Or:
>>
>>   OP_1ADD <random number> OP_EQUAL
>>
>> Or:
>>
>>   OP_BOOLAND
>>
>> Or:
>>
>>   OP_BOOLOR
>>
>> And so on.
>>
>> So no, it is not practically possible to ban anyone-can-spend outputs,
>> as there are too many potential scriptPubKey that anyone can spend.
>>
>> It is even possible to have an output that requires a proof-of-work,
>> like so:
>>
>>  OP_HASH256 <difficulty target> OP_LESSTHAN
>>
>> All the above outputs are disallowed from propagation by IsStandard, but
>> a miner can put them validly in a block, and IsStandard is not consensus
>> code and can be modified.
>>
>> 2.  Soft fork = restrict
>>
>> It is possible (although unlikely) for a majority of miners to run soft
>> forking code which the rest of us are not privy to.
>>
>> For example, for all we know, miners are already blacklisting spends on
>> Satoshi's coins.  We would not be able to detect this at all, since no
>> transaction that spends Satoshi's coins have been broadcast, ever.  It
>> is thus indistinguishable from a world where Satoshi lost his private
>> keys.  Of course, the world where Satoshi never spent his coins and
>> miners are blacklisting Satoshi's coins, is more complex than the world
>> where Satoshi never spent his coins, so it is more likely that miners
>> are not blacklisting.
>>
>> But the principle is there.  We may already be in a softfork whose rules
>> we do not know, and it just so happens that all our transactions today
>> do not violate those rules.  It is impossible for us to know this, but
>> it is very unlikely.
>>
>> Soft forks apply further restrictions on Bitcoin.  Hard forks do not. 
>> Thus, if everyone else is entering a soft fork and we are oblivious, we
>> do not even know about it.  Whereas, if everyone else is entering a hard
>> fork, we will immediately see (and reject) invalid transactions and blocks.
>>
>> Thus the only way to prevent soft fork is to hard fork against the new
>> soft fork, like Bcash did.
>>
>> Regards,
>> ZmnSCPxj
>>
>> -------- Original Message --------
>> Subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?
>> Local Time: September 13, 2017 5:50 PM
>> UTC Time: September 13, 2017 9:50 AM
>> From: bitcoin-dev at lists.linuxfoundation.org
>> To: Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>
>>
>> Hi, I am interested in the possibility of a cryptocurrency software
>> (future bitcoin or a future altcoin) that strives to have immutable
>> consensus rules.
>>
>> The goal of such a cryptocurrency would not be to have the latest and
>> greatest tech, but rather to be a long-term store of value and to offer
>> investors great certainty and predictability... something that markets
>> tend to like. And of course, zero consensus rule changes also means
>> less chance of new bugs and attack surface remains the same, which is
>> good for security.
>>
>> Of course, hard-forks are always possible. But that is a clear split
>> and something that people must opt into. Each party has to make a
>> choice, and inertia is on the side of the status quo. Whereas
>> soft-forks sort of drag people along with them, even those who oppose
>> the changes and never upgrade. In my view, that is problematic,
>> especially for a coin with permanent consensus rule immutability as a
>> goal/ethic.
>>
>> As I understand it, bitcoin soft-forks always rely on anyone-can-spend
>> transactions. If those were removed, would it effectively prevent
>> soft-forks, or are there other possible mechanisms? How important are
>> any-one-can spend tx for other uses?
>>
>> More generally, do you think it is possible to programmatically
>> avoid/ban soft-forks, and if so, how would you go about it?
>>
>>
>>
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0xB2E60C73.asc
Type: application/pgp-keys
Size: 15541 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170915/56ee44a1/attachment-0001.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 898 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170915/56ee44a1/attachment-0001.sig>

From dan at osc.co.cr  Fri Sep 15 20:15:36 2017
From: dan at osc.co.cr (Dan Libby)
Date: Fri, 15 Sep 2017 13:15:36 -0700
Subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?
In-Reply-To: <CADSvpf7sC-Rh0qoGKgagQV7Mo_BV6ymeadgfMzJ_oXPCTyJ6Mw@mail.gmail.com>
References: <9e212eae-08d5-d083-80d9-a8e29679fcdc@osc.co.cr>
	<CADSvpf7sC-Rh0qoGKgagQV7Mo_BV6ymeadgfMzJ_oXPCTyJ6Mw@mail.gmail.com>
Message-ID: <a4ed81de-68ed-1c72-2302-139a88ee886f@osc.co.cr>

Thanks for this link.  From my reading though, it seems that only
soft-forks that attempt to freeze funds are problematic on ethereum.

>From the article:
> The soft fork creates a new and fundamentally different class of 
> transactions in contrast with those that currently exist within the 
> protocol. Currently, transactions either complete successfully and
> cause a state transition, or run into an exception, in which case
> state is reverted but the maximum possible gas is still charged. With
> the soft fork, transactions which interact with a DAO will not fit
> within these two classes: they will fail execution but no gas will be
> charged. This must inevitably be the case in any soft fork that aims
> to freeze the stolen funds;

So in the general case ethereum can still soft-fork I think...


On 09/15/2017 04:19 AM, Andrew Quentson wrote:
> From my understanding, the blockchain can be designed in such a way as
> to make soft-forks be impossible or at least impractical due to attack
> vectors.
> 
> http://hackingdistributed.com/2016/06/28/ethereum-soft-fork-dos-vector/
> 
> Ethereum, for example, can't soft-fork. They have to always hardfork. 
> 
> On 13 September 2017 at 10:50, Dan Libby via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org
> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
> 
>     Hi, I am interested in the possibility of a cryptocurrency software
>     (future bitcoin or a future altcoin) that strives to have immutable
>     consensus rules.
> 
>     The goal of such a cryptocurrency would not be to have the latest and
>     greatest tech, but rather to be a long-term store of value and to offer
>     investors great certainty and predictability... something that markets
>     tend to like.  And of course, zero consensus rule changes also means
>     less chance of new bugs and attack surface remains the same, which is
>     good for security.
> 
>     Of course, hard-forks are always possible.  But that is a clear split
>     and something that people must opt into.  Each party has to make a
>     choice, and inertia is on the side of the status quo.  Whereas
>     soft-forks sort of drag people along with them, even those who oppose
>     the changes and never upgrade.  In my view, that is problematic,
>     especially for a coin with permanent consensus rule immutability as a
>     goal/ethic.
> 
>     As I understand it, bitcoin soft-forks always rely on anyone-can-spend
>     transactions.  If those were removed, would it effectively prevent
>     soft-forks, or are there other possible mechanisms?  How important are
>     any-one-can spend tx for other uses?
> 
>     More generally, do you think it is possible to programmatically
>     avoid/ban soft-forks, and if so, how would you go about it?
> 
> 
> 
> 
> 
>     _______________________________________________
>     bitcoin-dev mailing list
>     bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>     <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
> 
> 


-- 
Dan Libby

Open Source Consulting S.A.
Santa Ana, Costa Rica
http://osc.co.cr
phone: 011 506 2204 7018
Fax: 011 506 2223 7359

From apoelstra at wpsoftware.net  Sat Sep 16 01:42:53 2017
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Sat, 16 Sep 2017 01:42:53 +0000
Subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?
In-Reply-To: <0c98e067-dff3-988b-af66-7c624de3eef4@chainside.net>
References: <9e212eae-08d5-d083-80d9-a8e29679fcdc@osc.co.cr>
	<SU02clg--S4TtIK4TZIytgdnHE8SzXBwSEb_FN5edtPAaojLwCEd6OTNkBUrDiH1FwHPuD4D5yByE7r4Fz_-CVzzU9KK0xvmDGlWNxTp3aU=@protonmail.com>
	<9a541ba8-7c25-fdbb-505f-6426f61bdc63@osc.co.cr>
	<0c98e067-dff3-988b-af66-7c624de3eef4@chainside.net>
Message-ID: <20170916014252.GN24183@boulet>

On Fri, Sep 15, 2017 at 10:40:12PM +0200, Simone Bronzini via bitcoin-dev wrote:
> Since a soft-fork is a restriction of the consensus rules, I think the
> only way to have an un-soft-forkable cryptocurrency is creating a
> cryptocurrency where no transaction is valid.
> 

Even this can be soft-forked to add an extension block that contains transactions :)

Ultimately I think the best you can do in this direction is to design for
maximal fungibility and/or transaction structures that minimize interaction
with the blockchain. This minimizes the surface for transaction censorship,
which is somewhat in the spirit of your goal.

-- 
Andrew Poelstra
Mathematics Department, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

"A goose alone, I suppose, can know the loneliness of geese
 who can never find their peace,
 whether north or south or west or east"
       --Joanna Newsom

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170916/3fa2bec8/attachment.sig>

From dan at osc.co.cr  Fri Sep 15 21:48:57 2017
From: dan at osc.co.cr (Dan Libby)
Date: Fri, 15 Sep 2017 14:48:57 -0700
Subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?
In-Reply-To: <0c98e067-dff3-988b-af66-7c624de3eef4@chainside.net>
References: <9e212eae-08d5-d083-80d9-a8e29679fcdc@osc.co.cr>
	<SU02clg--S4TtIK4TZIytgdnHE8SzXBwSEb_FN5edtPAaojLwCEd6OTNkBUrDiH1FwHPuD4D5yByE7r4Fz_-CVzzU9KK0xvmDGlWNxTp3aU=@protonmail.com>
	<9a541ba8-7c25-fdbb-505f-6426f61bdc63@osc.co.cr>
	<0c98e067-dff3-988b-af66-7c624de3eef4@chainside.net>
Message-ID: <97b3b1a4-f588-65c7-d5cf-e8110ec3e4b5@osc.co.cr>

On 09/15/2017 01:40 PM, Simone Bronzini wrote:
> Since a soft-fork is a restriction of the consensus rules, I think the
> only way to have an un-soft-forkable cryptocurrency is creating a
> cryptocurrency where no transaction is valid.
> 
> Imagine I build a very minimal cryptocurrency where in the transaction
> output you only indicate the public key to send your coins to and the
> amount. One can still soft-fork it by deciding that, from now on, only
> even amounts are valid or only public keys that are a multiple of 10 are
> valid.

sure, but in this scenario how would one meaningfully "upgrade" the
functionality, eg add a new opcode?  We couldn't, right?  so....
success!   Preventing new functionality is the primary goal of this
thought experiment.  I believe that common sense and market incentives
would prevent arbitrary tightening of the rules for no good reason...



From ZmnSCPxj at protonmail.com  Sat Sep 16 03:38:23 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 15 Sep 2017 23:38:23 -0400
Subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?
In-Reply-To: <9a541ba8-7c25-fdbb-505f-6426f61bdc63@osc.co.cr>
References: <9e212eae-08d5-d083-80d9-a8e29679fcdc@osc.co.cr>
	<SU02clg--S4TtIK4TZIytgdnHE8SzXBwSEb_FN5edtPAaojLwCEd6OTNkBUrDiH1FwHPuD4D5yByE7r4Fz_-CVzzU9KK0xvmDGlWNxTp3aU=@protonmail.com>
	<9a541ba8-7c25-fdbb-505f-6426f61bdc63@osc.co.cr>
Message-ID: <whkInhlcljtKoQXmOL606NX21vwZ0Ewh4Oxd6_DaJhjAOc-WQBX_X9d_Hd71RAj9hXWKjKWSvGdHz1r6mDcSJxTVmak8UtBlllAJM18Pmb8=@protonmail.com>

Good Morning Dan,

No.

Let us suppose that IsStandard is applied to outputs, but we support P2SH. Then we could encode those scripts in P2SH. The softfork could require the script preimageto be put elsewhere, such as an OP_RETURN in the same tx, to determine the script that is anyone can spend.

We could ban P2SH or restrict P2SH to be IsStandard also, but you are now unable to support HTLC (no atomic swap) or LN, unless you specifically add those scripts to IsStandard. And if a better layer 2 comes along or LN is updated to use better scripts, you have to hardfork those in.

Even then, you can still be softforked. Remember that if we pay to a P2PKH, then publish the private key, every output paying to that address is now practically anyone can spend. Then a softfork can implement desired rules in an extensiom block, where money in UTXOs paying to the special publicized "private" key are controlled, post softfork, by data in a block that is not published to pre softfork nodes, like witness data is treated in SegWit.

Sent with [ProtonMail](https://protonmail.com) Secure Email.

> -------- Original Message --------
> Subject: Re: [bitcoin-dev] hypothetical: Could soft-forks be prevented?
> Local Time: September 16, 2017 3:55 AM
> UTC Time: September 15, 2017 7:55 PM
> From: dan at osc.co.cr
> To: ZmnSCPxj <ZmnSCPxj at protonmail.com>
> Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>
>
> Ok, this is good stuff. thanks for the thoughtful reply.
>
> Regarding anyone-can-spend:
>
> all of the examples you gave do not satisfy isStandard. So if our
> hypothetical cryptocurrency were to restrict all transactions to
> isStandard at the consensus layer, would that not effectively prevent
> anyone-can-spend?
>
> Or more generally and with our thinking caps on, what would be the best
> way to prevent anyone-can-spend, if that is our goal?
>
> Regarding soft-fork = restrict:
>
> Your example of miners running secret soft-fork code that blacklists
> satoshi"s utxo"s is intriguing and somewhat troubling.
>
> I think the main takeaways are that:
> 1) there are other ways to soft-fork besides anyone-can-spend.
> 2) it is impossible to prevent hidden soft-forks.
>
> Is that accurate?
>
> Still, I would put forth the following question: If anyone-can-spend tx
> were no longer allowed according to consensus rules (assuming that is
> possible/practical), then could the network still be practically
> "upgraded" with new features (eg opcodes) via soft-fork, and if so, what
> would be the mechanism for backwards compatibility in this scenario?
>
> or from another angle: even if it is impossible to prevent all
> soft-forks, can you see any way at all to make it logistically
> infeasible to use soft-forks as a network-wide consensus change mechanism?
>
> and another thought: as I understand it, bitcoin is presently able to
> add new opcodes via soft-fork because Satoshi added 10 unused opcodes
> via hardfork. What will happen when these run out? Can new opcodes
> still be added without a hard-fork?
>
> note: I ask these questions with the goal/vision of creating an
> immutable altcoin or sidechain, not necessarily restricting bitcoin"s path.
>
> On 09/14/2017 09:01 PM, ZmnSCPxj wrote:
>> Good morning Dan,
>>
>> My understanding is that it is impossible for soft forks to be prevented.
>>
>> 1. Anyone-can-spend
>>
>> There are a very large number of anyone-can-spend scripts, and it would
>> be very impractical to ban them all.
>>
>> For example, the below output script is anyone-can-spend
>>
>> <random number> OP_TRUE
>>
>> So is the below:
>>
>> OP_SIZE <random small number> OP_EQUAL
>>
>> Or:
>>
>> OP_1ADD <random number> OP_EQUAL
>>
>> Or:
>>
>> OP_BOOLAND
>>
>> Or:
>>
>> OP_BOOLOR
>>
>> And so on.
>>
>> So no, it is not practically possible to ban anyone-can-spend outputs,
>> as there are too many potential scriptPubKey that anyone can spend.
>>
>> It is even possible to have an output that requires a proof-of-work,
>> like so:
>>
>> OP_HASH256 <difficulty target> OP_LESSTHAN
>>
>> All the above outputs are disallowed from propagation by IsStandard, but
>> a miner can put them validly in a block, and IsStandard is not consensus
>> code and can be modified.
>>
>> 2. Soft fork = restrict
>>
>> It is possible (although unlikely) for a majority of miners to run soft
>> forking code which the rest of us are not privy to.
>>
>> For example, for all we know, miners are already blacklisting spends on
>> Satoshi"s coins. We would not be able to detect this at all, since no
>> transaction that spends Satoshi"s coins have been broadcast, ever. It
>> is thus indistinguishable from a world where Satoshi lost his private
>> keys. Of course, the world where Satoshi never spent his coins and
>> miners are blacklisting Satoshi"s coins, is more complex than the world
>> where Satoshi never spent his coins, so it is more likely that miners
>> are not blacklisting.
>>
>> But the principle is there. We may already be in a softfork whose rules
>> we do not know, and it just so happens that all our transactions today
>> do not violate those rules. It is impossible for us to know this, but
>> it is very unlikely.
>>
>> Soft forks apply further restrictions on Bitcoin. Hard forks do not.
>> Thus, if everyone else is entering a soft fork and we are oblivious, we
>> do not even know about it. Whereas, if everyone else is entering a hard
>> fork, we will immediately see (and reject) invalid transactions and blocks.
>>
>> Thus the only way to prevent soft fork is to hard fork against the new
>> soft fork, like Bcash did.
>>
>> Regards,
>> ZmnSCPxj
>>
>> -------- Original Message --------
>> Subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?
>> Local Time: September 13, 2017 5:50 PM
>> UTC Time: September 13, 2017 9:50 AM
>> From: bitcoin-dev at lists.linuxfoundation.org
>> To: Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>
>>
>> Hi, I am interested in the possibility of a cryptocurrency software
>> (future bitcoin or a future altcoin) that strives to have immutable
>> consensus rules.
>>
>> The goal of such a cryptocurrency would not be to have the latest and
>> greatest tech, but rather to be a long-term store of value and to offer
>> investors great certainty and predictability... something that markets
>> tend to like. And of course, zero consensus rule changes also means
>> less chance of new bugs and attack surface remains the same, which is
>> good for security.
>>
>> Of course, hard-forks are always possible. But that is a clear split
>> and something that people must opt into. Each party has to make a
>> choice, and inertia is on the side of the status quo. Whereas
>> soft-forks sort of drag people along with them, even those who oppose
>> the changes and never upgrade. In my view, that is problematic,
>> especially for a coin with permanent consensus rule immutability as a
>> goal/ethic.
>>
>> As I understand it, bitcoin soft-forks always rely on anyone-can-spend
>> transactions. If those were removed, would it effectively prevent
>> soft-forks, or are there other possible mechanisms? How important are
>> any-one-can spend tx for other uses?
>>
>> More generally, do you think it is possible to programmatically
>> avoid/ban soft-forks, and if so, how would you go about it?
>>
>>
>>
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170915/cc89dcfa/attachment-0001.html>

From pieter.wuille at gmail.com  Sun Sep 17 02:29:41 2017
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Sat, 16 Sep 2017 19:29:41 -0700
Subject: [bitcoin-dev] proposal: extend WIF format for segwit
In-Reply-To: <34198916-cde9-c84d-ca41-9feb8956bd80@electrum.org>
References: <34198916-cde9-c84d-ca41-9feb8956bd80@electrum.org>
Message-ID: <CAPg+sBgukwdRvfFcgdusrXoo8RiXm8OEL-WvHzjpiD8_HU5KmQ@mail.gmail.com>

On Sep 15, 2017 01:56, "Thomas Voegtlin via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

Note 3: we could also use a bech32 format for the private key, if it is
going to be used with a bech32 address. I am not sure if such a format
has been proposed already.


I've been working on an "extended bech32" format with 12 character checksum
rather than 6, for private keys and other things that need stronger
protection. It would guarantee correcting 4 errors, where normal bech32 can
only detect (but not correct) 4.

The rationale is that in the case of an address, if an error is detected,
you can ask the receiver for a corrected version. As that option doesn't
exist for private keys you want something stronger.

This has been a low-priority thing for me, though, and the computation work
to find a good checksum is significant.

Cheers,

-- 
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170916/e9b7ad89/attachment.html>

From thomasv at electrum.org  Sun Sep 17 08:10:17 2017
From: thomasv at electrum.org (Thomas Voegtlin)
Date: Sun, 17 Sep 2017 10:10:17 +0200
Subject: [bitcoin-dev] proposal: extend WIF format for segwit
In-Reply-To: <CAPg+sBgukwdRvfFcgdusrXoo8RiXm8OEL-WvHzjpiD8_HU5KmQ@mail.gmail.com>
References: <34198916-cde9-c84d-ca41-9feb8956bd80@electrum.org>
	<CAPg+sBgukwdRvfFcgdusrXoo8RiXm8OEL-WvHzjpiD8_HU5KmQ@mail.gmail.com>
Message-ID: <0dc0336b-d590-ffe9-8689-6ae06e98a39d@electrum.org>

On 17.09.2017 04:29, Pieter Wuille wrote:
> 
> This has been a low-priority thing for me, though, and the computation work
> to find a good checksum is significant.
> 

Thanks for the info. I guess this means that a bech32 format for private
keys is not going to happen soon. Even if such a format was available,
the issue would remain for segwit-in-p2sh addresses, which use base58.

The ambiguity of the WIF format is currently holding me from releasing a
segwit-capable version of Electrum. I believe it is not acceptable to
use the current WIF format with segwit scripts; that would just create
technological debt, forcing wallets to try all possible scripts. There
is a good reason why WIF adds a 0x01 byte for compressed pubkeys; it
makes it unambiguous.

I see only two options:
 1. Disable private keys export in Electrum Segwit wallets, until a
common WIF extension has been agreed on.
 2. Define my own WIF extension for Electrum, and go ahead with it.

Defining my own format does make sense for the xpub/xprv format, because
Electrum users need to share master public keys across Electrum wallets.
It makes much less sense for WIF, though, because WIF is mostly used to
import/sweep keys from other wallets.

I would love to know what other wallet developers are going to do,
especially Core. Are you going to export private keys used in segwit
scripts in the current WIF format?


From ajwest at gmail.com  Sun Sep 17 14:42:52 2017
From: ajwest at gmail.com (AJ West)
Date: Sun, 17 Sep 2017 10:42:52 -0400
Subject: [bitcoin-dev] proposal: extend WIF format for segwit
In-Reply-To: <0dc0336b-d590-ffe9-8689-6ae06e98a39d@electrum.org>
References: <34198916-cde9-c84d-ca41-9feb8956bd80@electrum.org>
	<CAPg+sBgukwdRvfFcgdusrXoo8RiXm8OEL-WvHzjpiD8_HU5KmQ@mail.gmail.com>
	<0dc0336b-d590-ffe9-8689-6ae06e98a39d@electrum.org>
Message-ID: <CABXVU6YKLwr-zev_=AmGDqwZ6ZkMwa=2ooPoDWv22XU8-QzajA@mail.gmail.com>

Hi I have a small interjection about the point on error correction (excuse
me if it seems elementary). Isn't there an argument to be made where a
wallet software should never attempt to figure out the 'correct' address,
or in this case private key? I don't think it's crazy to suggest somebody
could import a slightly erroneous WIF, the software gracefully
error-corrects any problem, but then the user copies that error onward such
as in their backup processes like a paper wallet. I always hate to advocate
against a feature, I'm just worried too much error correcting removes the
burden of exactitude and attention of the user (eg. "I know I can have up
to 4 errors").

I'm pretty sure I read those arguments somewhere in a documentation or
issue tracker/forum post. Maybe I'm misunderstanding the bigger picture in
this particular case, but I was just reminded of that concept (even if it
only applies generally).

Thanks,
AJ West

On Sun, Sep 17, 2017 at 4:10 AM, Thomas Voegtlin via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On 17.09.2017 04:29, Pieter Wuille wrote:
> >
> > This has been a low-priority thing for me, though, and the computation
> work
> > to find a good checksum is significant.
> >
>
> Thanks for the info. I guess this means that a bech32 format for private
> keys is not going to happen soon. Even if such a format was available,
> the issue would remain for segwit-in-p2sh addresses, which use base58.
>
> The ambiguity of the WIF format is currently holding me from releasing a
> segwit-capable version of Electrum. I believe it is not acceptable to
> use the current WIF format with segwit scripts; that would just create
> technological debt, forcing wallets to try all possible scripts. There
> is a good reason why WIF adds a 0x01 byte for compressed pubkeys; it
> makes it unambiguous.
>
> I see only two options:
>  1. Disable private keys export in Electrum Segwit wallets, until a
> common WIF extension has been agreed on.
>  2. Define my own WIF extension for Electrum, and go ahead with it.
>
> Defining my own format does make sense for the xpub/xprv format, because
> Electrum users need to share master public keys across Electrum wallets.
> It makes much less sense for WIF, though, because WIF is mostly used to
> import/sweep keys from other wallets.
>
> I would love to know what other wallet developers are going to do,
> especially Core. Are you going to export private keys used in segwit
> scripts in the current WIF format?
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170917/d9c8062b/attachment.html>

From mark at friedenbach.org  Sun Sep 17 15:36:48 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Sun, 17 Sep 2017 08:36:48 -0700
Subject: [bitcoin-dev] proposal: extend WIF format for segwit
In-Reply-To: <CABXVU6YKLwr-zev_=AmGDqwZ6ZkMwa=2ooPoDWv22XU8-QzajA@mail.gmail.com>
References: <34198916-cde9-c84d-ca41-9feb8956bd80@electrum.org>
	<CAPg+sBgukwdRvfFcgdusrXoo8RiXm8OEL-WvHzjpiD8_HU5KmQ@mail.gmail.com>
	<0dc0336b-d590-ffe9-8689-6ae06e98a39d@electrum.org>
	<CABXVU6YKLwr-zev_=AmGDqwZ6ZkMwa=2ooPoDWv22XU8-QzajA@mail.gmail.com>
Message-ID: <0071EC0D-44D4-47D0-8211-2158B288CC19@friedenbach.org>

Bech32 and WIF payload format are mostly orthogonal issues. You can design a new wallet import format now and later switch it to Bech32.

> On Sep 17, 2017, at 7:42 AM, AJ West via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Hi I have a small interjection about the point on error correction (excuse me if it seems elementary). Isn't there an argument to be made where a wallet software should never attempt to figure out the 'correct' address, or in this case private key? I don't think it's crazy to suggest somebody could import a slightly erroneous WIF, the software gracefully error-corrects any problem, but then the user copies that error onward such as in their backup processes like a paper wallet. I always hate to advocate against a feature, I'm just worried too much error correcting removes the burden of exactitude and attention of the user (eg. "I know I can have up to 4 errors").
> 
> I'm pretty sure I read those arguments somewhere in a documentation or issue tracker/forum post. Maybe I'm misunderstanding the bigger picture in this particular case, but I was just reminded of that concept (even if it only applies generally).
> 
> Thanks,
> AJ West
> 
>> On Sun, Sep 17, 2017 at 4:10 AM, Thomas Voegtlin via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> On 17.09.2017 04:29, Pieter Wuille wrote:
>> >
>> > This has been a low-priority thing for me, though, and the computation work
>> > to find a good checksum is significant.
>> >
>> 
>> Thanks for the info. I guess this means that a bech32 format for private
>> keys is not going to happen soon. Even if such a format was available,
>> the issue would remain for segwit-in-p2sh addresses, which use base58.
>> 
>> The ambiguity of the WIF format is currently holding me from releasing a
>> segwit-capable version of Electrum. I believe it is not acceptable to
>> use the current WIF format with segwit scripts; that would just create
>> technological debt, forcing wallets to try all possible scripts. There
>> is a good reason why WIF adds a 0x01 byte for compressed pubkeys; it
>> makes it unambiguous.
>> 
>> I see only two options:
>>  1. Disable private keys export in Electrum Segwit wallets, until a
>> common WIF extension has been agreed on.
>>  2. Define my own WIF extension for Electrum, and go ahead with it.
>> 
>> Defining my own format does make sense for the xpub/xprv format, because
>> Electrum users need to share master public keys across Electrum wallets.
>> It makes much less sense for WIF, though, because WIF is mostly used to
>> import/sweep keys from other wallets.
>> 
>> I would love to know what other wallet developers are going to do,
>> especially Core. Are you going to export private keys used in segwit
>> scripts in the current WIF format?
>> 
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170917/e911e5c6/attachment-0001.html>

From mark at friedenbach.org  Tue Sep 19 00:46:30 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Mon, 18 Sep 2017 17:46:30 -0700
Subject: [bitcoin-dev] Merkle branch verification & tail-call semantics
 for generalized MAST
In-Reply-To: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
Message-ID: <C623794E-F061-4C7A-B05D-378798ED2BF7@friedenbach.org>

As some of you may know, the MAST proposal I sent to the mailing list
on September 6th was discussed that the in-person CoreDev meetup in
San Francisco. In this email I hope to summarize the outcome of that
discussion. As chatham house rules were in effect, I will refrain from
attributing names to this summary..

* An introductory overview of the BIPs was presented, for the purpose
  of familiarizing the audience with what they are attempting to
  accomplish and how they do so.

* There was a discussion of a single vs multi-element MBV opcode. It
  was put forward that there should perhaps be different opcodes for
  the sake of script analysis, since a multi-element MBV will
  necessarily consume a variable number of inputs. However it was
  countered that if the script encodes the number of elements as an
  integer push to the top of the stack immediately before the opcode,
  then static analyzability is maintained in such instances. I took
  the action item to investigate what an ideal serialization format
  would be for a multi-element proof, which is the only thing holding
  back a multi-element MBV proposal.

* It was pointed out that the non-clean-stack tail-call semantics is
  not compatible with segwit's consensus-enforcement of the clean
  stack rule. Some alternatives were suggested, such as changing
  deployment mechanisms. After the main discussion session it was
  observed that tail-call semantics could still be maintained if the
  alt stack is used for transferring arguments to the policy script. I
  will be updating the BIP and example implementation accordingly.

* The observation was made that single-layer tail-call semantics can
  be thought of as really being P2SH with user-specified hashing. If
  the P2SH script template had been constructed slightly differently
  such as to not consume the script, it would even have been fully
  compatible with tail-call semantics.

* It was mentioned that using script versioning to deploy a MAST
  template allows for saving 32 bytes of witness per input, as the
  root hash is contained directly in the output being spent. The
  downside however is losing the permissionless innovation that comes
  with a programmable hashing mechanism.

* The discussion generally drifted into a wider discussion about
  script version upgrades and related issues, such as whether script
  versions should exist in the witness as well, and the difference in
  meaning between the two. This is an important subject, but only of
  relevance in far as using a script version upgrade to deploy MAST
  would add significant delay from having to sort through these issues
  first.

This feedback led to some minor tweaks to the proposal, which I will
be making, as well as the major feature request of a multi-element
MERKLE-BLOCK-VERIFY opcode which requires a little bit more effort to
accomplish. I will report back to this list again when that work is
done.

Sincerely,
Mark Friedenbach

From wilczynski.dan.dw at gmail.com  Mon Sep 18 06:40:18 2017
From: wilczynski.dan.dw at gmail.com (Daniel Wilczynski)
Date: Mon, 18 Sep 2017 16:10:18 +0930
Subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented?
Message-ID: <CAOC2iYWUX8cbUE=wqNUBOLY2egcO3d16=UzDn97uxGPthgFckg@mail.gmail.com>

Hi Dan.

What might be better aim is to have built in wipeout protection? In
softfork scenario this would protect a majority threatening a minority
with a wipeout if they do not opt in to some soft-fork consensus
change.


This could be partly done done by having automoated consensus critical
checkpoints, for example at 100 blocks deep. Maybe there are better
ways?


This would in effect turn softforks into hardforks.




Regards,


Daniel Wilczynski

From luke at dashjr.org  Tue Sep 19 03:09:08 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Tue, 19 Sep 2017 03:09:08 +0000
Subject: [bitcoin-dev] cleanstack alt stack & softfork improvements (Was:
	Merkle branch verification & tail-call semantics for
	generalized MAST)
In-Reply-To: <C623794E-F061-4C7A-B05D-378798ED2BF7@friedenbach.org>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<C623794E-F061-4C7A-B05D-378798ED2BF7@friedenbach.org>
Message-ID: <201709190309.08669.luke@dashjr.org>

On Tuesday 19 September 2017 12:46:30 AM Mark Friedenbach via bitcoin-dev 
wrote:
> After the main discussion session it was observed that tail-call semantics
> could still be maintained if the alt stack is used for transferring
> arguments to the policy script.

Isn't this a bug in the cleanstack rule?

(Unrelated...)

Another thing that came up during the discussion was the idea of replacing all 
the NOPs and otherwise-unallocated opcodes with a new OP_RETURNTRUE 
implementation, in future versions of Script. This would immediately exit the 
program (perhaps performing some semantic checks on the remainder of the 
Script) with a successful outcome.

This is similar to CVE-2010-5141 in a sense, but since signatures are no 
longer Scripts themselves, it shouldn't be exploitable.

The benefit of this is that it allows softforking in ANY new opcode, not only 
the -VERIFY opcode variants we've been doing. That is, instead of merely 
terminating the Script with a failure, the new opcode can also remove or push 
stack items. This is because old nodes, upon encountering the undefined 
opcode, will always succeed immediately, allowing the new opcode to do 
literally anything from that point onward.

Luke

From mark at friedenbach.org  Tue Sep 19 07:33:54 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Tue, 19 Sep 2017 00:33:54 -0700
Subject: [bitcoin-dev] cleanstack alt stack & softfork improvements
 (Was: Merkle branch verification & tail-call semantics for generalized
 MAST)
In-Reply-To: <201709190309.08669.luke@dashjr.org>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<C623794E-F061-4C7A-B05D-378798ED2BF7@friedenbach.org>
	<201709190309.08669.luke@dashjr.org>
Message-ID: <CAA2B000-6C54-4AD7-B931-43C99D615A61@friedenbach.org>


> On Sep 18, 2017, at 8:09 PM, Luke Dashjr <luke at dashjr.org> wrote:
> 
> On Tuesday 19 September 2017 12:46:30 AM Mark Friedenbach via bitcoin-dev 
> wrote:
>> After the main discussion session it was observed that tail-call semantics
>> could still be maintained if the alt stack is used for transferring
>> arguments to the policy script.
> 
> Isn't this a bug in the cleanstack rule?

Well in the sense that "cleanstack" doesn't do what it says, sure.

However cleanstack was introduced as a consensus rule to prevent a
possible denial of service vulnerability where a third party could
intercept any* transaction broadcast and arbitrarily add data to the
witness stack, since witness data is not covered by a checksig.

Cleanstack as-is accomplishes this because any extra items on the
stack would pass through all realistic scripts, remaining on the stack
and thereby violating the rule. There is no reason to prohibit extra
items on the altstack as those items can only arrive there
purposefully as an action of the script itself, not a third party
malleation of witness data. You could of course use DEPTH to write a
script that takes a variable number of parameters and sends them to
the altstack. Such a script would be malleable if those extra
parameters are not used. But that is predicated on the script being
specifically written in such a way as to be vulnerable; why protect
against that?

There are other solutions to this problem that could have been taken
instead, such as committing to the number of items or maximum size of
the stack as part of the sighash data, but cleanstack was the approach
taken. Arguably for a future script version upgrade one of these other
approaches should be taken to allow for shorter tail-call scripts.

Mark

* Well, almost any. You could end the script with DEPTH EQUAL and that
  is a compact way of ensuring the stack is clean (assuming the script
  finished with just "true" on the stack). Nobody does this however
  and burning two witness bytes of every redeem script going forward
  as a protective measure seems like an unnecessary ask.

From jl2012 at xbt.hk  Wed Sep 20 05:13:04 2017
From: jl2012 at xbt.hk (Johnson Lau)
Date: Wed, 20 Sep 2017 13:13:04 +0800
Subject: [bitcoin-dev] cleanstack alt stack & softfork improvements
 (Was: Merkle branch verification & tail-call semantics for generalized
 MAST)
In-Reply-To: <201709190309.08669.luke@dashjr.org>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<C623794E-F061-4C7A-B05D-378798ED2BF7@friedenbach.org>
	<201709190309.08669.luke@dashjr.org>
Message-ID: <B8C5E7EF-9062-4431-9B63-06FF855B1D78@xbt.hk>


> On 19 Sep 2017, at 11:09 AM, Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> On Tuesday 19 September 2017 12:46:30 AM Mark Friedenbach via bitcoin-dev 
> wrote:
>> After the main discussion session it was observed that tail-call semantics
>> could still be maintained if the alt stack is used for transferring
>> arguments to the policy script.
> 
> Isn't this a bug in the cleanstack rule?
> 
> (Unrelated...)
> 
> Another thing that came up during the discussion was the idea of replacing all 
> the NOPs and otherwise-unallocated opcodes with a new OP_RETURNTRUE 
> implementation, in future versions of Script. This would immediately exit the 
> program (perhaps performing some semantic checks on the remainder of the 
> Script) with a successful outcome.
> 
> This is similar to CVE-2010-5141 in a sense, but since signatures are no 
> longer Scripts themselves, it shouldn't be exploitable.
> 
> The benefit of this is that it allows softforking in ANY new opcode, not only 
> the -VERIFY opcode variants we've been doing. That is, instead of merely 
> terminating the Script with a failure, the new opcode can also remove or push 
> stack items. This is because old nodes, upon encountering the undefined 
> opcode, will always succeed immediately, allowing the new opcode to do 
> literally anything from that point onward.
> 
> Luke
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

I have implemented OP_RETURNTRUE in an earlier version of MAST (BIP114) but have given up the idea, for 2 reasons:

1. I?ve updated BIP114 to allow inclusion of scripts in witness, and require them to be signed. In this way users could add additional conditions for the validity of a signature. For example, with OP_CHECKBLOCKHASH, it is possible to make the transaction valid only in the specified chain. (More discussion in https://github.com/jl2012/bips/blob/vault/bip-0114.mediawiki#Additional_scripts_in_witness <https://github.com/jl2012/bips/blob/vault/bip-0114.mediawiki#Additional_scripts_in_witness> )

2. OP_RETURNTRUE does not work well with signature aggregation. Signature aggregation will collect (pubkey, message) pairs in a tx, combine them, and verify with one signature. However, consider the following case:

OP_RETURNTRUE OP_IF <pubkey> OP_CHECKSIGVERIFY OP_ENDIF OP_TRUE

For old nodes, the script terminates at OP_RETURNTRUE, and it will not collect the (pubkey, message) pair.

If we use a softfork to transform OP_RETURNTRUE into OP_17 (pushing the number 17 to the stack), new nodes will collect the (pubkey, message) pair and try to aggregate with other pairs. This becomes a hardfork.

--------
Technically, we could create ANY op code with an OP_NOP. For example, if we want OP_MUL, we could have OP_MULVERIFY, which verifies if the 3rd stack item is the product of the top 2 stack items. Therefore, OP_MULVERIFY OP_2DROP is functionally same as OP_MUL, which removes the top 2 items and returns the product. The problem is it takes more witness space.

If we don?t want this ugliness, we could use a new script version for every new op code we add. In the new BIP114 (see link above), I suggest to move the script version to the witness, which is cheaper.


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170920/c37d065c/attachment-0001.html>

From mark at friedenbach.org  Wed Sep 20 19:29:17 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Wed, 20 Sep 2017 12:29:17 -0700
Subject: [bitcoin-dev] cleanstack alt stack & softfork improvements
 (Was: Merkle branch verification & tail-call semantics for generalized
 MAST)
In-Reply-To: <B8C5E7EF-9062-4431-9B63-06FF855B1D78@xbt.hk>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<C623794E-F061-4C7A-B05D-378798ED2BF7@friedenbach.org>
	<201709190309.08669.luke@dashjr.org>
	<B8C5E7EF-9062-4431-9B63-06FF855B1D78@xbt.hk>
Message-ID: <34163C93-5F2C-4DC8-9FB2-7E28805C0184@friedenbach.org>


> On Sep 19, 2017, at 10:13 PM, Johnson Lau <jl2012 at xbt.hk> wrote:
> 
> If we don?t want this ugliness, we could use a new script version for every new op code we add. In the new BIP114 (see link above), I suggest to move the script version to the witness, which is cheaper.

To be clear, I don?t think it is so much that the version should be moved to the witness, but rather that there are two separate version values here ? one in the scriptPubKey which specifies the format and structure of the segwit commitment itself, and another in the witness which gates functionality in script or whatever else is used by that witness type. Segwit just unfortunately didn?t include the latter, an oversight that should be corrected on the on the next upgrade opportunity.

The address-visible ?script version? field should probably be renamed ?witness type? as it will only be used in the future to encode how to check the witness commitment in the scriptPubKey against the data provided in the witness. Upgrades and improvements to the features supported by those witness types won?t require new top-level witness types to be defined. Defining a new opcode, even one with modifies the stack, doesn?t change the hashing scheme used by the witness type.

v0,32-bytes is presently defined to calculate the double-SHA256 hash of the top-most serialized item on the stack, and compare that against the 32-byte commitment value. Arguably it probably should have hashed the top two values, one of which would have been the real script version. This could be fixed however, even without introducing a new witness type. Do a soft-fork upgrade that checks if the witness redeem script is push-only, and if so then pop the last push off as the script version (>= 1), and concatenate the rest to form the actual redeem script. We inherit a little technical debt from having to deal with push limits, but we avoid burning v0 in an upgrade to v1 that does little more than add a script version.

v1,32-bytes would then be used for a template version of MAST, or whatever other idea comes along that fundamentally changes the way the witness commitment is calculated.

Mark

From mark at friedenbach.org  Wed Sep 20 22:51:39 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Wed, 20 Sep 2017 15:51:39 -0700
Subject: [bitcoin-dev] An explanation and justification of the tail-call and
 MBV approach to MAST
Message-ID: <6856ECC5-06BF-4A03-869D-AA1132FE0705@friedenbach.org>

Over the past few weeks I've been explaining the MERKLEBRANCHVERIFY
opcode and tail-call execution semantics to a variety of developers,
and it's come to my attention that the BIPs presentation of the
concept is not as clear as it could be. Part of this is the fault of
standards documents being standards documents whose first and foremost
responsibility is precision, not pedagogy.

I think there's a better way to explain this approach to achieving
MAST, and it's worked better in the face to face and whiteboard
conversations I've had. I'm forwarding it to this list in case there
are others who desire a more clear explanation of what the
MERKLEBRANCHVERIFY and tail-call BIPs are trying to achieve, and what
any of it has to do with MAST / Merklized script.

I've written for all audiences so I apologize if it starts of at a
newbie level, but I encourage you to skim, not skip as I quickly start
varying this beginner material in atypical ways.


Review of P2SH

It's easiest to explain the behavior and purpose of these BIPs by
starting with P2SH, which we are generalizing from. BIP 16 (Pay to
Script Hash) specifies a form of implicit script recursion where a
redeem script is provided in the scriptSig, and the scriptPubKey is a
program that verifies the redeem script hashes to the committed value,
with the following template:

  HASH160 <hash> EQUAL

This script specifies that the redeem script is pulled from the stack,
its hash is compared against the expected value, and by fiat it is
declared that the redeem script is then executed with the remaining
stack items as arguments.

Sortof. What actually happens of course is that the above scriptPubKey
template is never executed, but rather the interpreter sees that it
matches this exact template format, and thereby proceeds to carry out
the same logic as a hard-coded behavior.


Generalizing P2SH with macro-op fusion

This template-matching is unfortunate because otherwise we could
imagine generalizing this approach to cover other use cases beyond
committing to and executing a single redeem script. For example, if we
instead said that anytime the script interpreter encountered the
3-opcode sequence "HASH160 <20-byte-push> EQUAL" it switched to
interpreting the top element as if it were a script, that would enable
not just BIP 16 but also constructs like this:

  IF
    HASH160 <hash-1> EQUAL
  ELSE
    HASH160 <hash-2> EQUAL
  ENDIF

This script conditionally executes one of two redeem scripts committed
to in the scriptPubKey, and at execution only reveals the script that
is actually used. All an observer learns of the other branch is the
script hash. This is a primitive form of MAST!

The "if 3-opcode P2SH template is encountered, switch to subscript"
rule is a bit difficult to work with however. It's not a true EVAL
opcode because control never returns back to the top-level script,
which makes some important aspects of the implementation easier, but
only at the cost of complexity somewhere else. What if there are
remaining opcodes in the script, such as the ELSE clause and ENDIF in
the script above?  They would never be executed, but does e.g. the
closing ENDIF still need to be present? Or what about the standard
pay-to-pubkey-hash "1Address" output:

  DUP HASH160 <20-byte-key-hash> EQUALVERIFY CHECKSIG

That almost looks like the magic P2SH template, except there is an
EQUALVERIFY instead of an EQUAL. The script interpreter should
obviously not treat the pubkey of a pay-to-pubkey-hash output as a
script and recurse into it, whereas it should for a P2SH style
script. But isn't the distinction kinda arbitrary?

And of course the elephant in the room is that by choosing not to
return to the original execution context we are no longer talking
about a soft-fork. Work out, for example, what will happen with the
following script:

  [TRUE] HASH160 <hash-of-[TRUE]> EQUAL FALSE

(It returns false on a node that doesn't understand generalized
3-opcode P2SH recursion, true on a node that does.)


Implicit tail-call execution semantics and P2SH

Well there's a better approach than trying to create a macro-op fusion
franken-EVAL. We have to run scripts to the end to for any proposal to
be a soft-fork, and we want to avoid saving state due to prior
experience of that leading to bugs in BIP 12. That narrows our design
space to one option: allow recursion only as the final act of a
script, as BIP 16 does, but for any script not just a certain
template. That way we can safely jump into the subscript without
bothering to save local state because termination of the subscript is
termination of the script as a whole. In computer science terms, this
is known as tail-call execution semantics.

To illustrate, consider the following scriptPubKey:

  DUP HASH160 <20-byte-hash> EQUALVERIFY

This script is almost exactly the same as the P2SH template, except
that it leaves the redeem script on the stack rather than consuming
it, thanks to the DUP, while it _does_ consume the boolean value at
the end because of the VERIFY. If executed, it leaves a stack exactly
as it was, which we assume will look like the following::

  <argN> ... <arg1> <redeemScript>

Now a normal script is supposed to finish with just true or false on
the stack. Any script that finishes execution with more than a single
element on the stack is in violation of the so-called clean-stack rule
and is considered non-standard -- not relayable and potentially broken
by future soft-fork upgrades. But so long as at least one bit of
<redeemScript> is set, it is interpreted as true and the script
interpreter would normally interpret a successful validation at this
point, albeit with a clean-stack violation.

Let's take advantage of that by changing what the script interpreter
does when a script finishes with multiple items remaining on the stack
and top-most one evaluates as true -- a state of affairs that would
pass validation under the old rules. Now instead the interpreter
treats the top-most item on the stack as a script, and tail-call
recurse into it, P2SH-style. In the above example, <redeemScript> is
popped off the stack and is executed with <arg1> ... <argN> remaining
on the stack as its arguments.

The above script can be interpreted in English as "Perform tail-call
recursion if and only if the HASH160 of the script on the top of the
stack exactly matches this 20-byte push." Which is, of course, what
BIP 16 accomplishes with template matching. However the implicit tail
call approach allows us to do much more than just P2SH!

For starters, it turns out that using HASH160 for P2SH was probably a
bad idea as it reduces the security of a multi-party constructed hash
to an unacceptable 80 bits. That's why segwit uses 256-bit hashes for
its pay to script hash format, for 128-bit security. Had we tail call
semantics instead of BIP 16, we could have just switched to a new
address type that decodes to the following script template instead:

  DUP HASH256 <32-byte-hash> EQUALVERIFY

Ta-da, we're back to full 128-bit security with no changes to the
consensus code, just a new address version to target this script
template.


MAST with tail-call alone?
Or: an aside on general recursion

Our IF-ELSE Merklized Abstract Syntax Tree example above, rewritten to
use tail-call evaluation, might look like this (there are more compact
formulations possible, but our purpose here is not code golf):

  IF
    DUP HASH160 <hash-1> EQUALVERIFY
  ELSE
    DUP HASH160 <hash-2> EQUALVERIFY
  ENDIF

Either execution pathway leaves us with one of the two allowed redeem
scripts on the top of the stack, and presumably its arguments beneath
it. We then execute that script via implicit tail-call.

We could write scripts using IF-ELSE branches or other tricks to
commit to more than two possible branches, although this unfortunately
scales linearly with the number of possible branches. If we allow the
subscript itself to do its own tail-call recursion, and its subscript
and so on, then we could nest these binary branches for a true MAST in
the original sense of the term.

However in doing so we would have enabled general recursion and
inherit all the difficulties that come with that. For example, some
doofus could use a script that consists of or has the same effect as a
single DUP to cause an infinite loop in the script interpreter. And
that's just the tip of the iceberg of problems general recursion can
bring, which stem generally from resource usage no longer being
correlated with the size of the witness stack, which is the primary
resource for which there are global limits.

This is fixable with a gas-like resource accounting scheme, which
would affect not just script but also mempool, p2p, and other
layers. And there is perhaps an argument for doing so, particularly as
part of a hard-fork block size increase as more accurate resource
accounting helps prevent many bad-block attacks and let us set
adversarial limits closer to measured capacity in the expected/average
use case. But that would immensely complicate things beyond what could
achieve consensus in a reasonably short amount of time, which is a
goal of this proposal.

Instead I suggest blocking off general recursion by only allowing the
script interpreter to do one tail-call per input. To get log-scaling
benefits without deep recursion we introduce instead one new script
feature, which we'll cover in the next section. But we do leave the
door open to possible future general recursion, as we will note that
going from one layer of recursion to many would itself be a soft-fork
for the same reason that the first tail-call recursion is.


Merkle branch verify to the rescue!

In #bitcoin-wizards and elsewhere there has been a desire for some
time to have an opcode that proves that an item was drawn from the set
used to construct a given Merkle tree. This is not a new idea although
I'm not aware of any actual proposal made for it until now. The most
simple version of the opcode, the version initially proposed, takes
three arguments:

  <proof> <leaf-hash> <root-hash> MERKLEBRANCHVERIFY 2DROP DROP

<root-hash> is the 32-byte hash label of the root of the Merkle tree,
calculated using a scheme defined in the fast Merkle hash tree BIP.

<leaf-hash> is 32 bytes of data which we are proving is part of the
Merkle hash tree -- usually the double-SHA256 hash of an item off the
stack.

<proof> is the path through the Merkle tree including the hashes of
branches not taken, which is the information necessary to recalculate
the root hash thereby proving that <leaf-hash> is in the Merkle tree.

The 2DROP and DROP are necessary to remove the 3 arguments from the
stack, as the opcode cannot consume them since it is soft-forked in.
There are two primary motivating applications of Merkle branch verify
(MBV), which will be covered next.

The MBV BIP will be extended to support extraction of more than one
item from the same Merkle tree, but for the rest of this explanation
we assume the current implementation of a single item proof, just for
simplicity.


MBV and MAST

This new opcode combines with single tail-call execution semantics to
allow for a very short and succinct MAST implementation:

  OVER HASH256 <root-hash> MERKLEBRANCHVERIFY 2DROP DROP

That's it. This script expects an input stack in the following format:

  <argN> ... <arg1> <policyScript> <proof>

At the end of execution the script has verified that <policyScript> is
part of the Merkle tree previously committed to, and <proof> is
dropped from the stack. This leaves the stack ready for a tail-call
recursion into <policyScript>.


MBV and Key Aggregation

If the signature scheme supports key aggregation, which it happens
that the the new signature aggregation scheme being worked on will
support as a side effect, then there is a very cool and useful
application that would be supported as well: tree signatures as
described by Pieter Wuille[1].  This looks almost exactly the same as
the MAST script, but with a CHECKSIG tacked on the end:

  OVER HASH256 <root-hash> MERKLEBRANCHVERIFY 2DROP DROP CHECKSIG

This script expects an input stack of the following form:

  <sig> <pubkey> <proof>

And proves that the pubkey is drawn from the set used to construct the
Merkle hash tree, and then its signature is checked. While it should
be clear this has 1-of-N semantics, what might be less obvious is that
key aggregation allows any signature policy expressible as a monotone
Boolean function (anything constructible with combinations of AND, OR,
and k-of-N thresholds) to be transformed to a 1-of-N over a set of key
aggregates. So the above script is a generic template able to verify
any monotone Boolean function over combinations of pubkeys, which
encompasses quite a number of use cases!

[1] https://blockstream.com/2015/08/24/treesignatures.html


An argument for permission-less innovation

The driving motivation for the tail-call and MBV proposals, and the
reason they are presented and considered together is to enable
Merklized Abstract Syntax Trees. However neither BIP actually defines
a MAST template, except as an example use case of the primitive
features. This is very much on purpose: it is the opinion of this
author that new bitcoin consensus features should follow the UNIX
philosophy as expressed by Peter Salus and Mike Gancarz and
paraphrased by yours truly:

  * Write features that do one thing and do it well.
  * Write features to work together.
  * Simple is beautiful.

By using modularity and composition of powerful but simple tools like
MERKLEBRANCHVERIFY and single tail-call recursion to construct MAST we
enable a complex and desirable feature while minimizing changes to the
consensus code, review burden, and acquired technical debt.

The reusability of the underlying primitives also means that they can
be combined with other modular features to support use cases other
than vanilla MAST, or reused in series to work around various limits
that might otherwise be imposed on a templated form of MAST. At the
moment the chief utility of these proposals is the straightforward
MAST script written above, but as primitives they do allow a few other
use cases and also combine well with features in the pipeline or on
the drawing board. For example, in addition to MAST you can:

1. Use MERKLEBRANCHVERIFY alone to support honeypot bounties, as
   discussed in the BIP.

2. Use a series of MERKLEBRANCHVERIFY opcodes to verify a branch with
   split proofs to stay under script and witness push limitations.

3. Combine MERKLEBRANCHVERIFY with key aggregation to get
   Wuille-Maxwell tree signatures which support arbitrary signing
   policies using a single, aggregatable signature.

4. Combine tail-call execution semantics with CHECKSIGFROMSTACK to get
   delegation and signature-time commitment to subscript policy.

5. Combine MERKLEBRANCHVERIFY with a Merkle proof prefix check opcode
   and Lamport signature support to get reusable Lamport keys.

I believe these benefits and possible future expansions to be strong
arguments in favor of extending bitcoin in the form of small, modular,
incremental, and reusable changes that can be combined and used even
in ways unforeseen even by their creators, creating a platform for
unrestricted innovation.

The alternative approach of rigid templates achieves the stated goals,
perhaps even with slightly better encoding efficiency, but at the cost
of requiring workaround for each future innovation. P2SH is just such
an example -- we couldn't even upgrade to 128-bit security without
designing an entirely different implementation because of the
limitations of template pattern matching.


Efficiency gains from templating

Finally, I need to point out that there is one efficiency gain that a
proper template-matching implementation has over user-specified
schemes: reduction of witness data. This is both a practical side
effect of more efficient serialization that doesn't need to encode
logic as opcodes, as well as the fact that since the hashing scheme is
fixed, one layer of hashes can be removed from the serialization. In
the case of MAST, rather than encode the Merkle root hash in the
redeem script, the hash is propagated upwards and compared against the
witness commitment. The amount space saved from adopting a template is
about equal to the size of the redeem script, which is approximately
40 bytes of witness data per MAST input.

That is arguably significant enough to matter, and in the long term I
think we will adopt a MAST template for those efficiency gains. But I
feel strongly that since MAST is not a feature in wide use at this
time, it is strongly in our interests to deploy MBV, tail-call, as
well overhaul the CHECKSIG operator before tackling what we feel an
ideal MAST-supporting witness type would look like, so that with some
experience under our belt we can adopt a system that is as simple and
as succinct as possible while supporting the necessary use cases
identified by actual use of the features.

Kind regards,
Mark Friedenbach

From andreas at antonopoulos.com  Thu Sep 21 00:15:37 2017
From: andreas at antonopoulos.com (Andreas M. Antonopoulos)
Date: Wed, 20 Sep 2017 20:15:37 -0400
Subject: [bitcoin-dev] An explanation and justification of the tail-call
 and MBV approach to MAST
In-Reply-To: <6856ECC5-06BF-4A03-869D-AA1132FE0705@friedenbach.org>
References: <6856ECC5-06BF-4A03-869D-AA1132FE0705@friedenbach.org>
Message-ID: <CAFmyj8y=1fvUcJGctx4pksQO1pYRUnBmncwwc0kVqvreLbJxkg@mail.gmail.com>

This was very helpful at least to me, thank you

I've been struggling to follow the discussion of tail-call execution and
understand the options for implementing MAST. This clarified everything. I
can now follow the previous discussions.




On Sep 20, 2017 18:56, "Mark Friedenbach via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

Over the past few weeks I've been explaining the MERKLEBRANCHVERIFY
opcode and tail-call execution semantics to a variety of developers,
and it's come to my attention that the BIPs presentation of the
concept is not as clear as it could be. Part of this is the fault of
standards documents being standards documents whose first and foremost
responsibility is precision, not pedagogy.

I think there's a better way to explain this approach to achieving
MAST, and it's worked better in the face to face and whiteboard
conversations I've had. I'm forwarding it to this list in case there
are others who desire a more clear explanation of what the
MERKLEBRANCHVERIFY and tail-call BIPs are trying to achieve, and what
any of it has to do with MAST / Merklized script.

I've written for all audiences so I apologize if it starts of at a
newbie level, but I encourage you to skim, not skip as I quickly start
varying this beginner material in atypical ways.


Review of P2SH

It's easiest to explain the behavior and purpose of these BIPs by
starting with P2SH, which we are generalizing from. BIP 16 (Pay to
Script Hash) specifies a form of implicit script recursion where a
redeem script is provided in the scriptSig, and the scriptPubKey is a
program that verifies the redeem script hashes to the committed value,
with the following template:

  HASH160 <hash> EQUAL

This script specifies that the redeem script is pulled from the stack,
its hash is compared against the expected value, and by fiat it is
declared that the redeem script is then executed with the remaining
stack items as arguments.

Sortof. What actually happens of course is that the above scriptPubKey
template is never executed, but rather the interpreter sees that it
matches this exact template format, and thereby proceeds to carry out
the same logic as a hard-coded behavior.


Generalizing P2SH with macro-op fusion

This template-matching is unfortunate because otherwise we could
imagine generalizing this approach to cover other use cases beyond
committing to and executing a single redeem script. For example, if we
instead said that anytime the script interpreter encountered the
3-opcode sequence "HASH160 <20-byte-push> EQUAL" it switched to
interpreting the top element as if it were a script, that would enable
not just BIP 16 but also constructs like this:

  IF
    HASH160 <hash-1> EQUAL
  ELSE
    HASH160 <hash-2> EQUAL
  ENDIF

This script conditionally executes one of two redeem scripts committed
to in the scriptPubKey, and at execution only reveals the script that
is actually used. All an observer learns of the other branch is the
script hash. This is a primitive form of MAST!

The "if 3-opcode P2SH template is encountered, switch to subscript"
rule is a bit difficult to work with however. It's not a true EVAL
opcode because control never returns back to the top-level script,
which makes some important aspects of the implementation easier, but
only at the cost of complexity somewhere else. What if there are
remaining opcodes in the script, such as the ELSE clause and ENDIF in
the script above?  They would never be executed, but does e.g. the
closing ENDIF still need to be present? Or what about the standard
pay-to-pubkey-hash "1Address" output:

  DUP HASH160 <20-byte-key-hash> EQUALVERIFY CHECKSIG

That almost looks like the magic P2SH template, except there is an
EQUALVERIFY instead of an EQUAL. The script interpreter should
obviously not treat the pubkey of a pay-to-pubkey-hash output as a
script and recurse into it, whereas it should for a P2SH style
script. But isn't the distinction kinda arbitrary?

And of course the elephant in the room is that by choosing not to
return to the original execution context we are no longer talking
about a soft-fork. Work out, for example, what will happen with the
following script:

  [TRUE] HASH160 <hash-of-[TRUE]> EQUAL FALSE

(It returns false on a node that doesn't understand generalized
3-opcode P2SH recursion, true on a node that does.)


Implicit tail-call execution semantics and P2SH

Well there's a better approach than trying to create a macro-op fusion
franken-EVAL. We have to run scripts to the end to for any proposal to
be a soft-fork, and we want to avoid saving state due to prior
experience of that leading to bugs in BIP 12. That narrows our design
space to one option: allow recursion only as the final act of a
script, as BIP 16 does, but for any script not just a certain
template. That way we can safely jump into the subscript without
bothering to save local state because termination of the subscript is
termination of the script as a whole. In computer science terms, this
is known as tail-call execution semantics.

To illustrate, consider the following scriptPubKey:

  DUP HASH160 <20-byte-hash> EQUALVERIFY

This script is almost exactly the same as the P2SH template, except
that it leaves the redeem script on the stack rather than consuming
it, thanks to the DUP, while it _does_ consume the boolean value at
the end because of the VERIFY. If executed, it leaves a stack exactly
as it was, which we assume will look like the following::

  <argN> ... <arg1> <redeemScript>

Now a normal script is supposed to finish with just true or false on
the stack. Any script that finishes execution with more than a single
element on the stack is in violation of the so-called clean-stack rule
and is considered non-standard -- not relayable and potentially broken
by future soft-fork upgrades. But so long as at least one bit of
<redeemScript> is set, it is interpreted as true and the script
interpreter would normally interpret a successful validation at this
point, albeit with a clean-stack violation.

Let's take advantage of that by changing what the script interpreter
does when a script finishes with multiple items remaining on the stack
and top-most one evaluates as true -- a state of affairs that would
pass validation under the old rules. Now instead the interpreter
treats the top-most item on the stack as a script, and tail-call
recurse into it, P2SH-style. In the above example, <redeemScript> is
popped off the stack and is executed with <arg1> ... <argN> remaining
on the stack as its arguments.

The above script can be interpreted in English as "Perform tail-call
recursion if and only if the HASH160 of the script on the top of the
stack exactly matches this 20-byte push." Which is, of course, what
BIP 16 accomplishes with template matching. However the implicit tail
call approach allows us to do much more than just P2SH!

For starters, it turns out that using HASH160 for P2SH was probably a
bad idea as it reduces the security of a multi-party constructed hash
to an unacceptable 80 bits. That's why segwit uses 256-bit hashes for
its pay to script hash format, for 128-bit security. Had we tail call
semantics instead of BIP 16, we could have just switched to a new
address type that decodes to the following script template instead:

  DUP HASH256 <32-byte-hash> EQUALVERIFY

Ta-da, we're back to full 128-bit security with no changes to the
consensus code, just a new address version to target this script
template.


MAST with tail-call alone?
Or: an aside on general recursion

Our IF-ELSE Merklized Abstract Syntax Tree example above, rewritten to
use tail-call evaluation, might look like this (there are more compact
formulations possible, but our purpose here is not code golf):

  IF
    DUP HASH160 <hash-1> EQUALVERIFY
  ELSE
    DUP HASH160 <hash-2> EQUALVERIFY
  ENDIF

Either execution pathway leaves us with one of the two allowed redeem
scripts on the top of the stack, and presumably its arguments beneath
it. We then execute that script via implicit tail-call.

We could write scripts using IF-ELSE branches or other tricks to
commit to more than two possible branches, although this unfortunately
scales linearly with the number of possible branches. If we allow the
subscript itself to do its own tail-call recursion, and its subscript
and so on, then we could nest these binary branches for a true MAST in
the original sense of the term.

However in doing so we would have enabled general recursion and
inherit all the difficulties that come with that. For example, some
doofus could use a script that consists of or has the same effect as a
single DUP to cause an infinite loop in the script interpreter. And
that's just the tip of the iceberg of problems general recursion can
bring, which stem generally from resource usage no longer being
correlated with the size of the witness stack, which is the primary
resource for which there are global limits.

This is fixable with a gas-like resource accounting scheme, which
would affect not just script but also mempool, p2p, and other
layers. And there is perhaps an argument for doing so, particularly as
part of a hard-fork block size increase as more accurate resource
accounting helps prevent many bad-block attacks and let us set
adversarial limits closer to measured capacity in the expected/average
use case. But that would immensely complicate things beyond what could
achieve consensus in a reasonably short amount of time, which is a
goal of this proposal.

Instead I suggest blocking off general recursion by only allowing the
script interpreter to do one tail-call per input. To get log-scaling
benefits without deep recursion we introduce instead one new script
feature, which we'll cover in the next section. But we do leave the
door open to possible future general recursion, as we will note that
going from one layer of recursion to many would itself be a soft-fork
for the same reason that the first tail-call recursion is.


Merkle branch verify to the rescue!

In #bitcoin-wizards and elsewhere there has been a desire for some
time to have an opcode that proves that an item was drawn from the set
used to construct a given Merkle tree. This is not a new idea although
I'm not aware of any actual proposal made for it until now. The most
simple version of the opcode, the version initially proposed, takes
three arguments:

  <proof> <leaf-hash> <root-hash> MERKLEBRANCHVERIFY 2DROP DROP

<root-hash> is the 32-byte hash label of the root of the Merkle tree,
calculated using a scheme defined in the fast Merkle hash tree BIP.

<leaf-hash> is 32 bytes of data which we are proving is part of the
Merkle hash tree -- usually the double-SHA256 hash of an item off the
stack.

<proof> is the path through the Merkle tree including the hashes of
branches not taken, which is the information necessary to recalculate
the root hash thereby proving that <leaf-hash> is in the Merkle tree.

The 2DROP and DROP are necessary to remove the 3 arguments from the
stack, as the opcode cannot consume them since it is soft-forked in.
There are two primary motivating applications of Merkle branch verify
(MBV), which will be covered next.

The MBV BIP will be extended to support extraction of more than one
item from the same Merkle tree, but for the rest of this explanation
we assume the current implementation of a single item proof, just for
simplicity.


MBV and MAST

This new opcode combines with single tail-call execution semantics to
allow for a very short and succinct MAST implementation:

  OVER HASH256 <root-hash> MERKLEBRANCHVERIFY 2DROP DROP

That's it. This script expects an input stack in the following format:

  <argN> ... <arg1> <policyScript> <proof>

At the end of execution the script has verified that <policyScript> is
part of the Merkle tree previously committed to, and <proof> is
dropped from the stack. This leaves the stack ready for a tail-call
recursion into <policyScript>.


MBV and Key Aggregation

If the signature scheme supports key aggregation, which it happens
that the the new signature aggregation scheme being worked on will
support as a side effect, then there is a very cool and useful
application that would be supported as well: tree signatures as
described by Pieter Wuille[1].  This looks almost exactly the same as
the MAST script, but with a CHECKSIG tacked on the end:

  OVER HASH256 <root-hash> MERKLEBRANCHVERIFY 2DROP DROP CHECKSIG

This script expects an input stack of the following form:

  <sig> <pubkey> <proof>

And proves that the pubkey is drawn from the set used to construct the
Merkle hash tree, and then its signature is checked. While it should
be clear this has 1-of-N semantics, what might be less obvious is that
key aggregation allows any signature policy expressible as a monotone
Boolean function (anything constructible with combinations of AND, OR,
and k-of-N thresholds) to be transformed to a 1-of-N over a set of key
aggregates. So the above script is a generic template able to verify
any monotone Boolean function over combinations of pubkeys, which
encompasses quite a number of use cases!

[1] https://blockstream.com/2015/08/24/treesignatures.html


An argument for permission-less innovation

The driving motivation for the tail-call and MBV proposals, and the
reason they are presented and considered together is to enable
Merklized Abstract Syntax Trees. However neither BIP actually defines
a MAST template, except as an example use case of the primitive
features. This is very much on purpose: it is the opinion of this
author that new bitcoin consensus features should follow the UNIX
philosophy as expressed by Peter Salus and Mike Gancarz and
paraphrased by yours truly:

  * Write features that do one thing and do it well.
  * Write features to work together.
  * Simple is beautiful.

By using modularity and composition of powerful but simple tools like
MERKLEBRANCHVERIFY and single tail-call recursion to construct MAST we
enable a complex and desirable feature while minimizing changes to the
consensus code, review burden, and acquired technical debt.

The reusability of the underlying primitives also means that they can
be combined with other modular features to support use cases other
than vanilla MAST, or reused in series to work around various limits
that might otherwise be imposed on a templated form of MAST. At the
moment the chief utility of these proposals is the straightforward
MAST script written above, but as primitives they do allow a few other
use cases and also combine well with features in the pipeline or on
the drawing board. For example, in addition to MAST you can:

1. Use MERKLEBRANCHVERIFY alone to support honeypot bounties, as
   discussed in the BIP.

2. Use a series of MERKLEBRANCHVERIFY opcodes to verify a branch with
   split proofs to stay under script and witness push limitations.

3. Combine MERKLEBRANCHVERIFY with key aggregation to get
   Wuille-Maxwell tree signatures which support arbitrary signing
   policies using a single, aggregatable signature.

4. Combine tail-call execution semantics with CHECKSIGFROMSTACK to get
   delegation and signature-time commitment to subscript policy.

5. Combine MERKLEBRANCHVERIFY with a Merkle proof prefix check opcode
   and Lamport signature support to get reusable Lamport keys.

I believe these benefits and possible future expansions to be strong
arguments in favor of extending bitcoin in the form of small, modular,
incremental, and reusable changes that can be combined and used even
in ways unforeseen even by their creators, creating a platform for
unrestricted innovation.

The alternative approach of rigid templates achieves the stated goals,
perhaps even with slightly better encoding efficiency, but at the cost
of requiring workaround for each future innovation. P2SH is just such
an example -- we couldn't even upgrade to 128-bit security without
designing an entirely different implementation because of the
limitations of template pattern matching.


Efficiency gains from templating

Finally, I need to point out that there is one efficiency gain that a
proper template-matching implementation has over user-specified
schemes: reduction of witness data. This is both a practical side
effect of more efficient serialization that doesn't need to encode
logic as opcodes, as well as the fact that since the hashing scheme is
fixed, one layer of hashes can be removed from the serialization. In
the case of MAST, rather than encode the Merkle root hash in the
redeem script, the hash is propagated upwards and compared against the
witness commitment. The amount space saved from adopting a template is
about equal to the size of the redeem script, which is approximately
40 bytes of witness data per MAST input.

That is arguably significant enough to matter, and in the long term I
think we will adopt a MAST template for those efficiency gains. But I
feel strongly that since MAST is not a feature in wide use at this
time, it is strongly in our interests to deploy MBV, tail-call, as
well overhaul the CHECKSIG operator before tackling what we feel an
ideal MAST-supporting witness type would look like, so that with some
experience under our belt we can adopt a system that is as simple and
as succinct as possible while supporting the necessary use cases
identified by actual use of the features.

Kind regards,
Mark Friedenbach
_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170920/8a904c22/attachment-0001.html>

From gfanti at andrew.cmu.edu  Thu Sep 21 02:10:29 2017
From: gfanti at andrew.cmu.edu (Giulia Fanti)
Date: Wed, 20 Sep 2017 22:10:29 -0400
Subject: [bitcoin-dev] BIP proposal - Dandelion: Privacy Preserving
 Transaction Propagation
Message-ID: <CAB6Q0ykK0X7G5pFh7+ga1Qzvi6Rw44X=N_LMC5RSimReWit1bQ@mail.gmail.com>

Greetings bitcoin-dev,

  We?re returning to this thread to give an update on the Dandelion project
after several months of additional work. (Dandelion is a new
privacy-preserving transaction propagation method, which we are proposing
as a BIP. See the original post in this thread
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-June/014571.html
for more background) The feedback on our initial BIP from Greg Maxwell in
this thread touched on several important issues affecting the protocol
design, which it has taken us until now to adequately address.

The focus of this update is a new variant of the Dandelion++ mechanism
presented earlier. The new variant is called ?Per-Incoming-Edge? routing.
In a nutshell, while the earlier Dandelion++ variant calls for routing
*each* stem transaction through a randomly chosen path, Per-Incoming Edge
routing causes each transaction from the same source to traverse the same
pseudorandom path. The most important benefit of Per-Incoming-Edge is that
it prevents ?intersection attacks? that result if a client broadcasts
multiple transactions over a short period of time. We validate this new
variant with new analysis and simulation as explained below.

Today?s update also includes an outline of our next development plans. We
have not yet completed a reference implementation, so this update does not
include a new BIP. Instead we?re just outlining the steps we plan to take
before an updated BIP. The new approach also  impacts our implementation
approach. Since Per-Incoming Edge routing simplifies the handling of orphan
transactions, we?re now planning on adopting Greg Maxwell?s suggestion to
bypass the txMempool for dandelion stem transactions.

======

The feedback on Dandelion from Greg Maxwell touched on a few important
issues: (1) robustness to observations over time, aka ?intersection
attacks?, (2) protocol- or implementation-level data leaks, and (3) graph
learning.

(1) With time, the adversary may be able to observe many message
trajectories, thereby eventually learning the underlying graph structure
and/or improving its deanonymization estimate for a given estimate of the
graph structure. In our original Dandelion BIP, we addressed this by
changing the anonymity graph topology from a directed line to a directed
4-regular graph. (In short, instead of a single outgoing edge for Dandelion
transactions, each node selects from  *two* such edges). This topology
provides robustness to adversaries who are able to learn the graph, but
those results still assume that each node generates only one transaction in
each ?epoch? (time between reshuffling the anonymity graph). Hence a big
remaining question is to understand the effect of intersection attacks--an
adversary observing multiple dependent transactions--on deanonymization
precision and recall.

(2) The second issue is protocol- or implementation-level behavior that
would allow an adversary to actively probe Dandelion to learn more
information than before. As you correctly note, we want to avoid the
adversary using conflicting transactions to infer which nodes are in the
stem. This issue is related to issue (1), in that our mechanism for
addressing intersection attacks will determine what data structures we need
in the implementation.

(3) The third issue is that an adversary may be able to infer the structure
of the graph by observing network traffic. We want to prevent this.

----------

Intersection Attacks

----------


An adversary?s ability to launch intersection attacks depends on the
internal Dandelion routing policy. Two natural ways to approach routing are
the following:

 1. Per-Hop: For each incoming stem transaction, make an independent random
decision of (a) whether to transition to ?fluff? phase, and (b) if ?stem?,
then which node should we relay to. This means that two transactions, even
starting from the same source, take independent random walks through the
anonymity graph. This is what our current implementation does.

 2. Per-Inbound-Edge: For each inbound edge e, randomly select one outbound
edge g, and relay all transactions arriving on edge e to edge g (assuming
the transaction remains in stem phase). Each node uses this relay mapping
for an entire epoch, which lasts about 10 min. Each source also randomly
chooses one outbound edge g? for its own transactions; so if a node
generates 5 transactions, they will all get propagated over edge g?. This
approach has the property that during an epoch, all transactions from a
single source will take the same path through the stem graph.

We have simulated and analyzed these two routing protocols, and find that
per-inbound-edge routing seems to be more robust to intersection attacks.
For our simulations we consider the ?first-spy? estimator --- this means
the rule where the attacker simply guesses that the first peer to relay a
transaction to a spy node is the real source. Figure 1 (link below)
illustrates the first-spy precision for per-incoming-edge routing and
per-transaction routing when each node has *one* transaction. Higher
precision means worse anonymity. For comparison, this figure includes
diffusion, which is the spreading mechanism currently used. Here ?p?
denotes the fraction of nodes in the network that are spies. (Recall that
in our model, we treat the attacker has having control over some fraction
of random nodes). The turquoise curve (labelled ?p?) is shown for
reference---it does not represent any routing protocol.

https://github.com/gfanti/bips/blob/master/per-edge-vs-per-tx.jpg

First, note that the first-spy estimator is thought to be significantly
suboptimal for diffusion (red line). Prior literature has shown that on
certain classes of graphs, there exist estimators that can detect diffusion
sources with much higher probability than the first-spy estimator. While
it?s unclear how to apply those algorithms to Bitcoin?s graph, it is likely
that strong algorithms exist. Hence the first-spy estimator serves as a
lower bound on precision for diffusion. On the other hand, we can show
theoretically that the first-spy precision for per-tx and per-incoming-edge
routing is within a small constant factor of the optimal precision for
per-incoming-edge routing. Thus, we expect that the green (per-edge) and
blue (per-tx) lines reflect the near-optimal attack, whereas the red line
(diffusion) could be much higher in practice.

The second issue to note is that the blue line (per-tx forwarding) has the
lowest precision of the three protocols for one tx per node. The green line
(per-edge forwarding) has higher precision than per-tx forwarding when
there are very few spies, but approaches per-tx forwarding as p increases.
Moreover, it has lower precision than diffusion for p>=0.05.

However, the real benefits of per-edge forwarding emerge as nodes start to
transmit multiple transactions. Under per-edge forwarding, even if nodes
transmit multiple transactions each, those transactions will traverse the
same path in the anonymity graph, thereby preventing the adversary from
learning any new information from later transactions. Meanwhile, under
per-tx routing, we find empirically that as nodes generate an increasing
number of transactions, each source generates a unique signature of
spy-node-observations (we are currently working on a more detailed
exploration of this question). We expect that such signatures can be used
to exactly deanonymize users in cases where the adversary learns the
graph. Hence
per-tx forwarding is actually quite fragile to adversaries learning the
graph, whereas per-incoming-edge is robust to intersection attacks. This is
one key reason for adopting per-incoming-edge forwarding.

Adopting per-incoming-edge forwarding has another important implication: it
becomes easy to enforce the condition that child transactions never enter
fluff mode before parent transactions. This significantly simplifies orphan
handling, and means that adversaries cannot infer that a preceding
transaction is still in stem mode just by passively listening to network
traffic. We revisit this issue in the next section.

----------

Implementation-Level Metadata Leaks

----------

tl;dr: concept ACK for gmaxwell?s suggestion on a new per-peer data
structure instead of mempool

Regardless of which routing policy we choose, it is important that
implementations do not leak more information about transactions than they
do in our model. It?s especially important that spies do not get an
?off-path? view of the nodes involved in the stem of a transaction. This
practically means that implementations must be careful not to expose
whether or not a stem transaction was received, to any node except the two
randomly chosen ones. (i.e., not to supernodes that may make inbound
connections to thousands of nodes).

We are currently developing a reference implementation for Dandelion++, as
a patch against Bitcoin Core. It requires thoughtful integration to make
this patch, and the choice of routing policy informs our approach. We have
so far considered two main integration approaches, whose main difference is
whether or not they reuse the existing *txMempool* data structure to store
stem mode transactions.

A. Mempool embargo:

This how is our current implementation works. Stem transactions are only
relayed if they are accepted to mempool. Stem transactions are ?embargoed?
by suppressing them from MEMPOOL and INV messages sent from the node. This
was the easiest to implement while preserving all of Bitcoin?s existing DoS
prevention. In particular, it simplifies the handling of orphan
transactions, because the AcceptToMempool routine already handles orphan
transactions. However, this approach comes with a risk of indirect leakage,
especially if some edge case is missed in implementation.

B. Avoid modifying mempool (or any global structure) for stem transactions:

This is the approach preferred by Greg Maxwell. The main benefit is that it
is much more clear that there is no indirect leakage, although it makes it
harder to argue there is no additional DoS concern. We have already taken a
couple of steps towards implementing this here:
https://github.com/gfanti/bitcoin/commits/dandelion-nomempool The main idea
is to avoid duplicating the rules for whether a transaction would be
accepted into mempool or not, by adding a ?dry run? option to the
AcceptToMempool function. Our implementation of this approach is not yet
finished; it still remains to develop the per-peer data structure.

Orphan transactions are important for per-tx routing, because with per-tx
routing, the child and the parent might travel along different stems. A
burst of transactions from a single sender would have to be queued so they
enter fluff mode sequentially. A lot of our testing (with the included test
framework) involved ensuring such transactions were handled effectively.
This was also the deciding factor for our choice of using Option B ?Mempool
Embargo? above. With Per-incoming Edge routing, however, orphan transaction
handling can be simplified, since out-of-order transactions would not be
sent along stems.

We therefore plan to re-engineer a much of our reference implementation to:

1) use per-incoming edge routing,

2) simplify handling of orphan transactions,

3) adopt the proposed approach of avoiding the mempool data structure for
stem transactions.

We?ll give an update soon on our development progress before updating the
BIP.

----------

Graph Learning

----------


Greg Maxwell also asked:

```

Has any work been given to the fact that dandelion propagation
potentially making to measure properties of the inter-node connection
graph?  e.g.  Say I wish to partition node X by disconnecting all of
its outbound connections, to do that it would be useful to learn whom
is connected to X.  I forward a transaction to X, observe the first
node to fluff it,  then DOS attack that node to take it offline.  Will
I need to DOS attack fewer or more nodes  to get all of X's outbounds
if X supports rapid stem forwarding?

```

In terms of graph learning, there are two graphs to consider: the anonymity
graph (i.e., the stem set of each node), and the main P2P graph. Dandelion
has at least as good graph-hiding properties as diffusion for a natural
class of attacks (which include the attack described in the comment above).


Consider the task of learning the main P2P graph in today?s network (under
diffusion spreading). Suppose a supernode is connected to all nodes, and
wants to learn the 1-hop neighbors of a given target node. The eavesdropper
passes a transaction to the target, and waits to hear which nodes relay the
transaction first. If the target has 8 outbound neighbors, then in each
experiment, the supernode will receive 8 independent relay timestamps from
the target?s 1-hop neighbors. By repeating this many times, the adversary
can infer the 1-hop neighbors as the nodes who relay the transaction with
the appropriate mean delay (taking into account the appropriate exponential
parameters). Eventually, this set will be learned with high certainty.

Now consider the same task if the target is a Dandelion node. Note that the
supernode?s probe tx must be relayed as a Dandelion message to observe any
difference with the prior experiment. First of all, the target will only
pass the tx to one node in its stem set. Hence, in each experiment, the
supernode can learn at most one timestamp from a relevant node, whereas
previously it learned eight per experiment. This inherently reduces the
adversary?s learning rate. Second, if the target?s relay is a Dandelion
node and chooses to extend the stem, then the supernode will not receive any
relevant timestamp (i.e. a timestamp from a 1-hop neighbor) unless the
supernode lies in the relay?s stem set. This happens with a probability
that depends on the level of deployment and the number of (seemingly)
distinct nodes being run by the supernode, but is strictly smaller than 1.

   _ Hence, the rate at which an attacker can learn the main P2P graph is
strictly higher under diffusion (as in Bitcoin Core today) compared to
using Dandelion. _

A similar argument can be made for the anonymity graph, which we currently
implement as an overlay to the main P2P graph.

=====

Responses to Other Miscellaneous Comments

====

```

An alternative construction would be that when a stem transaction goes
out there is a random chance that the stem flag is not set (with
suitable adjustment to keep the same expected path length)

For some reason I believe this would be a superior construction, but I
am only able to articulate one clear benefit:  It allows non-dandelion
capable nodes to take on the role of the last stem hop, which I
believe would improve the anonymity set during the transition phase.

```

Agreed, this is actually what we have implemented.


---------

Thanks!

Giulia Fanti <gfanti at andrew.cmu.edu>
Andrew Miller <soc1024 at illinois.edu>
Surya Bakshi <sbakshi3 at illinois.edu>
Shaileshh Bojja Venkatakrishnan <bjjvnkt2 at illinois.edu>
Pramod Viswanath <pramodv at illinois.edu>



Date: Tue, 13 Jun 2017 01:00:50 +0000
> From: Gregory Maxwell <greg at xiph.org>
> To: Andrew Miller <soc1024 at illinois.edu>
> Cc: Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] BIP proposal - Dandelion: Privacy
>         Preserving Transaction Propagation
> Message-ID:
>         <CAAS2fgRAnGMMxKPCaj1SL=z3O2wuGS8nyPrgtGhSpuGgAoVtKg at mail.
> gmail.com>
> Content-Type: text/plain; charset="UTF-8"
>
> On Mon, Jun 12, 2017 at 2:46 PM, Andrew Miller via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > Dear bitcoin-dev,
> >    We've put together a preliminary implementation and BIP for
> > Dandelion, and would love to get your feedback on it. Dandelion is a
> > privacy-enhancing modification to Bitcoin's transaction propagation
> > mechanism. Its goal is to obscure the original source IP of each
> > transaction.
>
> I'm glad to see this out now, so I'm not longer invading the git repo
> uninvited. :)
>
> >  - Stronger attacker model: we defend against an attacker that
> > actively tries to learn which nodes were involved in the stem phase.
> > Our approach is called "Mempool Embargo", meaning a node that receives
> > a "stem phase" transaction behaves as though it never heard of it,
> > until it receives it again from someone else (or until a random timer
> > elapsess).
>
>
> The description in the BIP appears inadequate:
>
>
> > That is, Alice will not include the embargoed transaction when
> responding to MEMPOOL requests, and will not respond to GETDATA requests
> from another node (Bob) unless Alice previously sent an INV to Bob. The
> embargo period ends as soon as Alice receives an INV advertising the
> transaction as being in fluff mode.
>
> For example, it's not clear if I can query for the existence of a
> transaction by sending a conflict.  If this doesn't seem problematic,
> consider the case where I, communicating with you over some private
> channel, send you a payment inside a payment protocol message. You
> announce it to the network and I concurrently send a double spend.
> Only nodes that were part of the stem will reject my double spend, so
> I just learned a lot about your network location.
>
> It's also appears clear that I can query by sending an inv and
> noticing that no getdata arrives.  An example attack in the latter is
> that when I get a stem transaction I rapidly INV interrogate the
> entire network and by observing who does and doesn't getdata I will
> likely learn the entire stem path upto permutation.
>
> The extra network capacity used by getdata-ing a transaction you
> already saw via dandelion would be pretty insignificant.
>
> I believe the text should be simplified and clarified so just say:
>
> "With the exception of her behavior towards the peer sending in the
> stem transaction and the peer sending out the transaction Alice's
> behavior should be indistinguishable from a node which has not seen
> the transaction at all until she receives it via ordinary forwarding
> or until after the timeout." -- then its up to the implementation to
> achieve indistinguishably regardless of what other protocol features
> it uses.
>
> > Are there other ways we haven't thought of? We think the alternative
> > approach (bypassing mempool entirely) seems even harder to get right,
> > and foregoes existing DoS protection.
>
> I think avoiding the is the most sensible way; and from a software
> maintenance perspective I expect that anything less will end up
> continually suffering from serious information leaks which are hard to
> avoid accidentally introducing via other changes.
>
> The primary functionality should be straightforward to implement,
> needing just a flag to determine if a transaction would be accepted to
> the mempool but for the flag, but which skips actually adding it.
>
> Handling chains of unconfirmed stem transactions is made more
> complicated by this and this deserves careful consideration. I'm not
> sure if its possible to forward stem children of stem transactions
> except via the same stem path as the parent without leaking
> information, it seems unlikely.
>
> This approach would mostly take additional complexity from the need to
> limit the amplification of double spends. I believe this can be
> resolved by maintaining a per-peer map of the not yet expired vin's
> consumed by stem fowards sent out via that peer. E.g. vin->{timeout,
> feerate}.  Then any new forward via that stem-peer is tested against
> that map and suppressed if it it spends a non-timed-out input and
> doesn't meet the feerate epsilon for replacement.
>
> Use of the orphan map is not indistinguishable as it is used for block
> propagation, and itself also a maintenance burden to make sure
> unrelated code is not inadvertently leaking the stem transactions.
>
> > After a random number of hops along the stem, the transaction enters the
> fluff phase,
>
> The BIP is a bit under-specified on this transition, I think-- but I
> know how it works from reading the prior implementation (I have not
> yet read the new implementation).
>
> The way it works (assuming I'm not confused and it hasn't changed) is
> that when a new stem transaction comes in there is a chance that it is
> treated as coming in as a normal transaction.
>
> An alternative construction would be that when a stem transaction goes
> out there is a random chance that the stem flag is not set (with
> suitable adjustment to keep the same expected path length)
>
> For some reason I believe this would be a superior construction, but I
> am only able to articulate one clear benefit:  It allows non-dandelion
> capable nodes to take on the role of the last stem hop, which I
> believe would improve the anonymity set during the transition phase.
>
> Unrelated:
>
> Has any work been given to the fact that dandelion propagation
> potentially making to measure properties of the inter-node connection
> graph?  e.g.  Say I wish to partition node X by disconnecting all of
> its outbound connections, to do that it would be useful to learn whom
> is connected to X.  I forward a transaction to X, observe the first
> node to fluff it,  then DOS attack that node to take it offline.  Will
> I need to DOS attack fewer or more nodes  to get all of X's outbounds
> if X supports rapid stem forwarding?
>
>
> ------------------------------
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170920/ca00a9c4/attachment-0001.html>

From jl2012 at xbt.hk  Thu Sep 21 03:58:05 2017
From: jl2012 at xbt.hk (Johnson Lau)
Date: Thu, 21 Sep 2017 11:58:05 +0800
Subject: [bitcoin-dev] cleanstack alt stack & softfork improvements
 (Was: Merkle branch verification & tail-call semantics for generalized
 MAST)
In-Reply-To: <34163C93-5F2C-4DC8-9FB2-7E28805C0184@friedenbach.org>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<C623794E-F061-4C7A-B05D-378798ED2BF7@friedenbach.org>
	<201709190309.08669.luke@dashjr.org>
	<B8C5E7EF-9062-4431-9B63-06FF855B1D78@xbt.hk>
	<34163C93-5F2C-4DC8-9FB2-7E28805C0184@friedenbach.org>
Message-ID: <02DA3C1D-2892-4D27-B646-A6E002C5DB12@xbt.hk>


> On 21 Sep 2017, at 3:29 AM, Mark Friedenbach <mark at friedenbach.org> wrote:
> 
> 
>> On Sep 19, 2017, at 10:13 PM, Johnson Lau <jl2012 at xbt.hk> wrote:
>> 
>> If we don?t want this ugliness, we could use a new script version for every new op code we add. In the new BIP114 (see link above), I suggest to move the script version to the witness, which is cheaper.
> 
> To be clear, I don?t think it is so much that the version should be moved to the witness, but rather that there are two separate version values here ? one in the scriptPubKey which specifies the format and structure of the segwit commitment itself, and another in the witness which gates functionality in script or whatever else is used by that witness type. Segwit just unfortunately didn?t include the latter, an oversight that should be corrected on the on the next upgrade opportunity.
> 
> The address-visible ?script version? field should probably be renamed ?witness type? as it will only be used in the future to encode how to check the witness commitment in the scriptPubKey against the data provided in the witness. Upgrades and improvements to the features supported by those witness types won?t require new top-level witness types to be defined. Defining a new opcode, even one with modifies the stack, doesn?t change the hashing scheme used by the witness type.
> 
> v0,32-bytes is presently defined to calculate the double-SHA256 hash of the top-most serialized item on the stack, and compare that against the 32-byte commitment value. Arguably it probably should have hashed the top two values, one of which would have been the real script version. This could be fixed however, even without introducing a new witness type. Do a soft-fork upgrade that checks if the witness redeem script is push-only, and if so then pop the last push off as the script version (>= 1), and concatenate the rest to form the actual redeem script. We inherit a little technical debt from having to deal with push limits, but we avoid burning v0 in an upgrade to v1 that does little more than add a script version.
> 
> v1,32-bytes would then be used for a template version of MAST, or whatever other idea comes along that fundamentally changes the way the witness commitment is calculated.
> 
> Mark

This is exactly what I suggest with BIP114. Using v1, 32-byte to define the basic structure of Merklized Script, and define the script version inside the witness

Johnson

From luke at dashjr.org  Thu Sep 21 04:11:49 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Thu, 21 Sep 2017 04:11:49 +0000
Subject: [bitcoin-dev] cleanstack alt stack & softfork improvements
	(Was: Merkle branch verification & tail-call semantics for
	generalized MAST)
In-Reply-To: <B8C5E7EF-9062-4431-9B63-06FF855B1D78@xbt.hk>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<201709190309.08669.luke@dashjr.org>
	<B8C5E7EF-9062-4431-9B63-06FF855B1D78@xbt.hk>
Message-ID: <201709210411.50642.luke@dashjr.org>

On Wednesday 20 September 2017 5:13:04 AM Johnson Lau wrote:
> 2. OP_RETURNTRUE does not work well with signature aggregation. Signature
> aggregation will collect (pubkey, message) pairs in a tx, combine them,
> and verify with one signature. However, consider the following case:
> 
> OP_RETURNTRUE OP_IF <pubkey> OP_CHECKSIGVERIFY OP_ENDIF OP_TRUE
> 
> For old nodes, the script terminates at OP_RETURNTRUE, and it will not
> collect the (pubkey, message) pair.
> 
> If we use a softfork to transform OP_RETURNTRUE into OP_17 (pushing the
> number 17 to the stack), new nodes will collect the (pubkey, message) pair
> and try to aggregate with other pairs. This becomes a hardfork.

This seems like a problem for signature aggregation to address, not a problem 
for OP_RETURNTRUE... In any case, I don't think it's insurmountable. Signature 
aggregation can simply be setup upfront, and have the Script verify inclusion 
of keys in the aggregation?

> Technically, we could create ANY op code with an OP_NOP. For example, if we
> want OP_MUL, we could have OP_MULVERIFY, which verifies if the 3rd stack
> item is the product of the top 2 stack items. Therefore, OP_MULVERIFY
> OP_2DROP is functionally same as OP_MUL, which removes the top 2 items and
> returns the product. The problem is it takes more witness space.

This is another approach, and one that seems like a good idea in general. I'm 
not sure it actually needs to take more witness space - in theory, such stack 
items could be implied if the Script engine is designed for it upfront. Then 
it would behave as if it were non-verify, while retaining backward 
compatibility.

Luke

From jl2012 at xbt.hk  Thu Sep 21 08:02:42 2017
From: jl2012 at xbt.hk (Johnson Lau)
Date: Thu, 21 Sep 2017 16:02:42 +0800
Subject: [bitcoin-dev] cleanstack alt stack & softfork improvements
 (Was: Merkle branch verification & tail-call semantics for generalized
 MAST)
In-Reply-To: <201709210411.50642.luke@dashjr.org>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<201709190309.08669.luke@dashjr.org>
	<B8C5E7EF-9062-4431-9B63-06FF855B1D78@xbt.hk>
	<201709210411.50642.luke@dashjr.org>
Message-ID: <21D6060D-97F0-439A-86D3-065C21BACC3F@xbt.hk>


> On 21 Sep 2017, at 12:11 PM, Luke Dashjr <luke at dashjr.org> wrote:
> 
> On Wednesday 20 September 2017 5:13:04 AM Johnson Lau wrote:
>> 2. OP_RETURNTRUE does not work well with signature aggregation. Signature
>> aggregation will collect (pubkey, message) pairs in a tx, combine them,
>> and verify with one signature. However, consider the following case:
>> 
>> OP_RETURNTRUE OP_IF <pubkey> OP_CHECKSIGVERIFY OP_ENDIF OP_TRUE
>> 
>> For old nodes, the script terminates at OP_RETURNTRUE, and it will not
>> collect the (pubkey, message) pair.
>> 
>> If we use a softfork to transform OP_RETURNTRUE into OP_17 (pushing the
>> number 17 to the stack), new nodes will collect the (pubkey, message) pair
>> and try to aggregate with other pairs. This becomes a hardfork.
> 
> This seems like a problem for signature aggregation to address, not a problem 
> for OP_RETURNTRUE... In any case, I don't think it's insurmountable. Signature 
> aggregation can simply be setup upfront, and have the Script verify inclusion 
> of keys in the aggregation?

I think it?s possible only if you spend more witness space to store the (pubkey, message) pairs, so that old clients could understand the aggregation produced by new clients. But this completely defeats the purpose of doing aggregation.

We use different skills to save space. For example, we use 1-byte SIGHASH flag to imply the 32-byte message. For maximal space saving, sig aggregation will also rely on such skills. However, the assumption is that all signatures aggregated must follow exactly the same set of rules.


> 
>> Technically, we could create ANY op code with an OP_NOP. For example, if we
>> want OP_MUL, we could have OP_MULVERIFY, which verifies if the 3rd stack
>> item is the product of the top 2 stack items. Therefore, OP_MULVERIFY
>> OP_2DROP is functionally same as OP_MUL, which removes the top 2 items and
>> returns the product. The problem is it takes more witness space.
> 
> This is another approach, and one that seems like a good idea in general. I'm 
> not sure it actually needs to take more witness space - in theory, such stack 
> items could be implied if the Script engine is designed for it upfront. Then 
> it would behave as if it were non-verify, while retaining backward 
> compatibility.

Sounds interesting but I don?t get it. For example, how could you make a OP_MUL out of OP_NOP?


> 
> Luke



From luke at dashjr.org  Thu Sep 21 16:33:16 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Thu, 21 Sep 2017 16:33:16 +0000
Subject: [bitcoin-dev] cleanstack alt stack & softfork improvements
	(Was: Merkle branch verification & tail-call semantics for
	generalized MAST)
In-Reply-To: <21D6060D-97F0-439A-86D3-065C21BACC3F@xbt.hk>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<201709210411.50642.luke@dashjr.org>
	<21D6060D-97F0-439A-86D3-065C21BACC3F@xbt.hk>
Message-ID: <201709211633.17714.luke@dashjr.org>

On Thursday 21 September 2017 8:02:42 AM Johnson Lau wrote:
> I think it?s possible only if you spend more witness space to store the
> (pubkey, message) pairs, so that old clients could understand the
> aggregation produced by new clients. But this completely defeats the
> purpose of doing aggregation.

SigAgg is a softfork, so old clients *won't* understand it... am I missing 
something?

For example, perhaps the lookup opcode could have a data payload itself (eg, 
like pushdata opcodes do), and the script can be parsed independently from 
execution to collect the applicable ones.

> > This is another approach, and one that seems like a good idea in general.
> > I'm not sure it actually needs to take more witness space - in theory,
> > such stack items could be implied if the Script engine is designed for
> > it upfront. Then it would behave as if it were non-verify, while
> > retaining backward compatibility.
> 
> Sounds interesting but I don?t get it. For example, how could you make a
> OP_MUL out of OP_NOP?

The same as your OP_MULVERIFY at the consensus level, except new clients would 
execute it as an OP_MUL, and inject pops/pushes when sending such a 
transaction to older clients. The hash committed to for the script would 
include the inferred values, but not the actual on-chain data. This would 
probably need to be part of some kind of MAST-like softfork to be viable, and 
maybe not even then.

Luke

From jl2012 at xbt.hk  Thu Sep 21 17:38:01 2017
From: jl2012 at xbt.hk (Johnson Lau)
Date: Fri, 22 Sep 2017 01:38:01 +0800
Subject: [bitcoin-dev] cleanstack alt stack & softfork improvements
 (Was: Merkle branch verification & tail-call semantics for generalized
 MAST)
In-Reply-To: <201709211633.17714.luke@dashjr.org>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<201709210411.50642.luke@dashjr.org>
	<21D6060D-97F0-439A-86D3-065C21BACC3F@xbt.hk>
	<201709211633.17714.luke@dashjr.org>
Message-ID: <7BF7D0B8-A38C-44B9-B6E9-44A74782CC81@xbt.hk>


> On 22 Sep 2017, at 12:33 AM, Luke Dashjr <luke at dashjr.org> wrote:
> 
> On Thursday 21 September 2017 8:02:42 AM Johnson Lau wrote:
>> I think it?s possible only if you spend more witness space to store the
>> (pubkey, message) pairs, so that old clients could understand the
>> aggregation produced by new clients. But this completely defeats the
>> purpose of doing aggregation.
> 
> SigAgg is a softfork, so old clients *won't* understand it... am I missing 
> something?
> 
> For example, perhaps the lookup opcode could have a data payload itself (eg, 
> like pushdata opcodes do), and the script can be parsed independently from 
> execution to collect the applicable ones.

I think the current idea of sigagg is something like this: the new OP_CHECKSIG still has 2 arguments: top stack must be a 33-byte public key, and the 2nd top stack item is signature. Depends on the sig size, it returns different value:

If sig size is 0, it returns a 0 to the top stack
If sig size is 1, it is treated as a SIGHASH flag, and the SignatureHash() ?message? is calculated. It sends the (pubkey, message) pair to the aggregator, and always returns a 1 to the top stack
If sig size is >1, it is treated as the aggregated signature. The last byte is SIGHASH flag. It sends the (pubkey, message) pair and the aggregated signature to the aggregator, and always returns a 1 to the top stack.

If all scripts pass, the aggregator will combine all pairs to obtain the aggkey and aggmsg, and verify against aggsig. A tx may have at most 1 aggsig.

(The version I presented above is somewhat simplified but should be enough to illustrate my point)

So if we have this script:

OP_1 OP_RETURNTRUE <pubkey> OP_CHECKSIG

Old clients would stop at the OP_RETURNTRUE, and will not send the pubkey to the aggregator

If we softfork OP_RETURNTRUE to something else, even as OP_NOP11, new clients will send the (key, msg) pair to the aggregator. Therefore, the aggregator of old and new clients will see different data, leading to a hardfork.

OTOH, OP_NOP based softfork would not have this problem because it won?t terminate script and return true.


> 
>>> This is another approach, and one that seems like a good idea in general.
>>> I'm not sure it actually needs to take more witness space - in theory,
>>> such stack items could be implied if the Script engine is designed for
>>> it upfront. Then it would behave as if it were non-verify, while
>>> retaining backward compatibility.
>> 
>> Sounds interesting but I don?t get it. For example, how could you make a
>> OP_MUL out of OP_NOP?
> 
> The same as your OP_MULVERIFY at the consensus level, except new clients would 
> execute it as an OP_MUL, and inject pops/pushes when sending such a 
> transaction to older clients. The hash committed to for the script would 
> include the inferred values, but not the actual on-chain data. This would 
> probably need to be part of some kind of MAST-like softfork to be viable, and 
> maybe not even then.
> 
> Luke

I don?t think it?s worth the code complexity, just to save a few bytes of data sent over wire; and to be a soft fork, it still takes the block space.

Maybe we could create many OP_DROPs and OP_2DROPs, so new VERIFY operations could pop the stack. This saves 1 byte and also looks cleaner.

Another approach is to use a new script version for every new non-verify type operation. Problem is we will end up with many versions. Also, signatures from different versions can?t be aggregated. (We may have multiple aggregators in a transaction)




From nathan at z.cash  Fri Sep 22 02:00:31 2017
From: nathan at z.cash (Nathan Wilcox)
Date: Fri, 22 Sep 2017 11:00:31 +0900
Subject: [bitcoin-dev] Responsible disclosure of bugs
In-Reply-To: <20170914052740.GA2674@erisian.com.au>
References: <3e4541f3-f65c-5199-5e85-9a65ea5142e7@bitcartel.com>
	<cb968a34-f8d2-ab61-dd15-9bd282afd18c@mattcorallo.com>
	<20170911021506.GA19080@erisian.com.au>
	<CAPWm=eVCh2FYp=SpOcZFLqz1ZCq3=Z_F9Sj+EAXFvqU-8aMuTg@mail.gmail.com>
	<20170912033703.GD19080@erisian.com.au>
	<CAKzdR-oYQ8EchpJVE56yJbfBgNHihx7WO_gtFtp6QKOcK7uT-w@mail.gmail.com>
	<e28e151a-1a67-4e90-f5fd-721cbc7f213d@bitcartel.com>
	<20170914052740.GA2674@erisian.com.au>
Message-ID: <CAK8perD5as_oTJ3tRvrG2pAjWZq91xbuzguuVD5ZY4UswyL5kQ@mail.gmail.com>

[inline responses]


On Thu, Sep 14, 2017 at 2:27 PM, Anthony Towns via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Tue, Sep 12, 2017 at 09:10:18AM -0700, Simon Liu wrote:
> > It would be a good starting point if the current policy could be
> > clarified, so everyone is on the same page, and there is no confusion.
>
> Collecting various commentary from here and reddit, I think current de
> facto policy is something like:
>
>  * Vulnerabilities should be reported via security at bitcoincore.org [0]
>
>  * A critical issue (that can be exploited immediately or is already
>    being exploited causing large harm) will be dealt with by:
>      * a released patch ASAP
>      * wide notification of the need to upgrade (or to disable affected
>        systems)
>      * minimal disclosure of the actual problem, to delay attacks
>    [1] [2]
>
>  * A non-critical vulnerability (because it is difficult or expensive to
>    exploit) will be dealt with by:
>      * patch and review undertaken in the ordinary flow of development
>      * backport of a fix or workaround from master to the current
>        released version [2]
>
>  * Devs will attempt to ensure that publication of the fix does not
>    reveal the nature of the vulnerability by providing the proposed fix
>    to experienced devs who have not been informed of the vulnerability,
>    telling them that it fixes a vulnerability, and asking them to identify
>    the vulnerability. [2]
>
>  * Devs may recommend other bitcoin implementations adopt vulnerability
>    fixes prior to the fix being released and widely deployed, if they
>    can do so without revealing the vulnerability; eg, if the fix has
>    significant performance benefits that would justify its inclusion. [3]
>
>  * Prior to a vulnerability becoming public, devs will generally recommend
>    to friendly altcoin devs that they should catch up with fixes. But this
>    is only after the fixes are widely deployed in the bitcoin network. [4]
>
>  * Devs will generally not notify altcoin developers who have behaved
>    in a hostile manner (eg, using vulnerabilities to attack others, or
>    who violate embargoes). [5]
>
>  * Bitcoin devs won't disclose vulnerability details until >80% of bitcoin
>    nodes have deployed the fixes. Vulnerability discovers are encouraged
>    and requested to follow the same policy. [1] [6]
>
> Those seem like pretty good policies to me, for what it's worth.
>
>
I advocate a policy like this, except I propose two modifications:

- Point 4 should include *zero or more* altcoin developers, such that those
altcoins also deploy mitigations as early as Bitcoin. (Call this "early
altcoin disclosure".)

- Disclose of vulnerabilities, by social convention, always explicitly
names which altcoin developers were included in my proposed Early Altcoin
Disclosure and Point 6.

The rationale is that the policy should allow closer coordination with
altcoins. If the goal is minimizing economic damage, including altcoins
earlier may be the better trade-off between inclusiveness and secrecy. At
the same time, the policy doesn't establish *which* altcoins, which is a
tricky choice. However it *does* require disclosure of those relationships,
which provides a form of feedback on the system.

Imagine if altcoin X is compromised, and later disclosure occurs that
reveals that altcoin X was not contacted early, then this *might* indicate
leaks, maliciousness in the Bitcoin mitigation organization, or it *might*
be coincidence or dumb luck. In the other case, if the Bitcoin disclosure
reveals that X was indeed contacted early, then it probably indicates
incompetence of the altoin X.

Finally, notice that this kind of loose early disclosure policy can be
symmetric. For example, Zcash developers may choose to disclose
vulnerabilities they discover which affect Bitcoin to Bitcoin developers
*before* Zcash releases fixes, or before those fixes are widely adopted in
Zcash. We actually have a policy of doing this, since it's obvious that if
our mitigation process leaks and that's used to attack Bitcoin the
potential economic damage is very large.



> I haven't seen anything that indicates bitcoin devs will *ever* encourage
> public disclosure of vulnerabilities (as opposed to tolerating other
> people publishing them [6]). So I'm guessing current de facto policy is
> more along the lines of:
>
>  * Where possible, Bitcoin devs will never disclose vulnerabilities
>    publically while affected code may still be in use (including by
>    altcoins).
>
> rather than something like:
>
>  * Bitcoin devs will disclose vulnerabilities publically after 99% of the
>    bitcoin network has upgraded [7], and fixes have been released for
>    at least 12 months.
>
>
I advocate for something like the latter case. I'd like to see a timeout on
disclosure. There's an endless tail of alt-coins that could be affected,
and no guarantee all will vigilantly upgrade. Meanwhile, deciding which of
them to disclose to confidentially versus which should just receive hints
to apply new patches is tricky and political.

Having a global timeout is a reasonable stop-gap. I consider the cost of
never disclosing, publicly, a known vulnerbility to be very high, even if
the fix is ubiquitously deployed, because it's a loss of security
knowledge, a precious public good.


>
> Instinctively, I'd say documenting this policy (or whatever it actually
> is) would be good, and having all vulnerabilities get publically released
> eventually would also be good; that's certainly the more "open source"
> approach. But arguing the other side:
>
>  - documenting security policy gives attackers a better handle on where
>    to find weak points; this may be more harm than there is benefit to
>    improving legitimate users' understanding of and confidence in the
>    development process
>
>
Publishing a policy *might* increase organizational vulnerability, but so
might *not publishing* a policy. It seems fairly neutral to me on
vulnerability impact, whereas the benefit is good for users and developers.



>  - the main benefit of public vulnerability disclosure is a better
>    working relationship with security researchers and perhaps better
>    understanding of what sort of bugs happen in practice in general;
>    but if most of your security research is effectively in house [6],
>    maybe those benefits aren't as great as the harm done by revealing
>    even old vulnerabilities to attackers
>
>
Publishing after a reasonable timeout has many benefits. Many security
researchers learn from vulnerability disclosures across many disciplines
and industries. Future protocol designers of things potentially unrelated
to blockchain altogether may also learn important lessons.


If the first of those arguments holds, well, hopefully this message has
> egregious errors that no one will correct, or it will quickly get lost
> in this list's archives...
>
> Cheers,
> aj
>
>
regards,
Nathan Wilcox
Zcash


> [0] http://bitcoincore.org/en/contact
>     referenced from .github/ISSUE_TEMPLATE.md in git
>
> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> 2017-September/014986.html
>
> [2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> 2017-September/014990.html
>
> [3] https://www.reddit.com/r/btc/comments/6zf1qo/peter_todd_
> nicely_pulled_away_attention_from_jjs/dmxcw70/
>
> [4] https://www.reddit.com/r/btc/comments/6z827o/chris_jeffrey_
> jj_discloses_bitcoin_attack_vector/dmxdg83/
>
> [5] https://www.reddit.com/r/btc/comments/6zb3lp/maxwell_
> admits_core_sat_on_vulnerability/dmv4y7g/
>
> [6] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> 2017-September/014991.html
>
> [7] Per http://luke.dashjr.org/programs/bitcoin/files/charts/branches.html
>     it seems like 1.7% of the network is running known-vulnerable versions
>     0.8 and 0.9; but only 0.37% are running 0.10 or 0.11, so that might
> argue
>     revealing any vulnerabilities fixed since 0.12.0 would be fine...
>     (bitnodes.21.co doesn't seem to break down anything earlier than 0.12)
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170922/db798f3b/attachment-0001.html>

From sergio.d.lerner at gmail.com  Fri Sep 22 19:53:46 2017
From: sergio.d.lerner at gmail.com (Sergio Demian Lerner)
Date: Fri, 22 Sep 2017 16:53:46 -0300
Subject: [bitcoin-dev] Responsible disclosure of bugs
In-Reply-To: <CAK8perD5as_oTJ3tRvrG2pAjWZq91xbuzguuVD5ZY4UswyL5kQ@mail.gmail.com>
References: <3e4541f3-f65c-5199-5e85-9a65ea5142e7@bitcartel.com>
	<cb968a34-f8d2-ab61-dd15-9bd282afd18c@mattcorallo.com>
	<20170911021506.GA19080@erisian.com.au>
	<CAPWm=eVCh2FYp=SpOcZFLqz1ZCq3=Z_F9Sj+EAXFvqU-8aMuTg@mail.gmail.com>
	<20170912033703.GD19080@erisian.com.au>
	<CAKzdR-oYQ8EchpJVE56yJbfBgNHihx7WO_gtFtp6QKOcK7uT-w@mail.gmail.com>
	<e28e151a-1a67-4e90-f5fd-721cbc7f213d@bitcartel.com>
	<20170914052740.GA2674@erisian.com.au>
	<CAK8perD5as_oTJ3tRvrG2pAjWZq91xbuzguuVD5ZY4UswyL5kQ@mail.gmail.com>
Message-ID: <CAKzdR-ok5Gd8fBbDuCcAuZ1S_iym4Ub3eXRvKBj31w1us5NG4Q@mail.gmail.com>

The policy seems good with the exception of this paragraph:

* Bitcoin devs will disclose vulnerabilities publically after 99% of the
   bitcoin network has upgraded [7], and fixes have been released for
   at least 12 months.

99% upgrade may never be reached. Some nodes cannot even be categorized. I
suggest a number close to 95%.
If the 95% of network has upgraded, it means we're pretty secure from the
point of view of consensus. It is supposed that from the time the fix has
been released, all other alt-coins will also have released their fixes.
Remember we must also incentivize security researchers to do the hard and
silent research work. Most of them do not hold Bitcoins. They do research
because of other interests, including getting public acknowledgment for
their findings. They'll be frustrated if they have to wait 2 years.

I propose this paragraph to replace the previous one:

* Bitcoin devs will disclose vulnerabilities publically after 95% of the
   bitcoin network has upgraded [7], and fixes have been released for
   at least 6 months.

Also I suggest we track vulnerabilities with standard CVE codes. IS there
any drawback of this?

regards


On Thu, Sep 21, 2017 at 11:00 PM, Nathan Wilcox via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> [inline responses]
>
>
> On Thu, Sep 14, 2017 at 2:27 PM, Anthony Towns via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> On Tue, Sep 12, 2017 at 09:10:18AM -0700, Simon Liu wrote:
>> > It would be a good starting point if the current policy could be
>> > clarified, so everyone is on the same page, and there is no confusion.
>>
>> Collecting various commentary from here and reddit, I think current de
>> facto policy is something like:
>>
>>  * Vulnerabilities should be reported via security at bitcoincore.org [0]
>>
>>  * A critical issue (that can be exploited immediately or is already
>>    being exploited causing large harm) will be dealt with by:
>>      * a released patch ASAP
>>      * wide notification of the need to upgrade (or to disable affected
>>        systems)
>>      * minimal disclosure of the actual problem, to delay attacks
>>    [1] [2]
>>
>>  * A non-critical vulnerability (because it is difficult or expensive to
>>    exploit) will be dealt with by:
>>      * patch and review undertaken in the ordinary flow of development
>>      * backport of a fix or workaround from master to the current
>>        released version [2]
>>
>>  * Devs will attempt to ensure that publication of the fix does not
>>    reveal the nature of the vulnerability by providing the proposed fix
>>    to experienced devs who have not been informed of the vulnerability,
>>    telling them that it fixes a vulnerability, and asking them to identify
>>    the vulnerability. [2]
>>
>>  * Devs may recommend other bitcoin implementations adopt vulnerability
>>    fixes prior to the fix being released and widely deployed, if they
>>    can do so without revealing the vulnerability; eg, if the fix has
>>    significant performance benefits that would justify its inclusion. [3]
>>
>>  * Prior to a vulnerability becoming public, devs will generally recommend
>>    to friendly altcoin devs that they should catch up with fixes. But this
>>    is only after the fixes are widely deployed in the bitcoin network. [4]
>>
>>  * Devs will generally not notify altcoin developers who have behaved
>>    in a hostile manner (eg, using vulnerabilities to attack others, or
>>    who violate embargoes). [5]
>>
>>  * Bitcoin devs won't disclose vulnerability details until >80% of bitcoin
>>    nodes have deployed the fixes. Vulnerability discovers are encouraged
>>    and requested to follow the same policy. [1] [6]
>>
>> Those seem like pretty good policies to me, for what it's worth.
>>
>>
> I advocate a policy like this, except I propose two modifications:
>
> - Point 4 should include *zero or more* altcoin developers, such that
> those altcoins also deploy mitigations as early as Bitcoin. (Call this
> "early altcoin disclosure".)
>
> - Disclose of vulnerabilities, by social convention, always explicitly
> names which altcoin developers were included in my proposed Early Altcoin
> Disclosure and Point 6.
>
> The rationale is that the policy should allow closer coordination with
> altcoins. If the goal is minimizing economic damage, including altcoins
> earlier may be the better trade-off between inclusiveness and secrecy. At
> the same time, the policy doesn't establish *which* altcoins, which is a
> tricky choice. However it *does* require disclosure of those relationships,
> which provides a form of feedback on the system.
>
> Imagine if altcoin X is compromised, and later disclosure occurs that
> reveals that altcoin X was not contacted early, then this *might* indicate
> leaks, maliciousness in the Bitcoin mitigation organization, or it *might*
> be coincidence or dumb luck. In the other case, if the Bitcoin disclosure
> reveals that X was indeed contacted early, then it probably indicates
> incompetence of the altoin X.
>
> Finally, notice that this kind of loose early disclosure policy can be
> symmetric. For example, Zcash developers may choose to disclose
> vulnerabilities they discover which affect Bitcoin to Bitcoin developers
> *before* Zcash releases fixes, or before those fixes are widely adopted in
> Zcash. We actually have a policy of doing this, since it's obvious that if
> our mitigation process leaks and that's used to attack Bitcoin the
> potential economic damage is very large.
>
>
>
>> I haven't seen anything that indicates bitcoin devs will *ever* encourage
>> public disclosure of vulnerabilities (as opposed to tolerating other
>> people publishing them [6]). So I'm guessing current de facto policy is
>> more along the lines of:
>>
>>  * Where possible, Bitcoin devs will never disclose vulnerabilities
>>    publically while affected code may still be in use (including by
>>    altcoins).
>>
>> rather than something like:
>>
>>  * Bitcoin devs will disclose vulnerabilities publically after 99% of the
>>    bitcoin network has upgraded [7], and fixes have been released for
>>    at least 12 months.
>>
>>
> I advocate for something like the latter case. I'd like to see a timeout
> on disclosure. There's an endless tail of alt-coins that could be affected,
> and no guarantee all will vigilantly upgrade. Meanwhile, deciding which of
> them to disclose to confidentially versus which should just receive hints
> to apply new patches is tricky and political.
>
> Having a global timeout is a reasonable stop-gap. I consider the cost of
> never disclosing, publicly, a known vulnerbility to be very high, even if
> the fix is ubiquitously deployed, because it's a loss of security
> knowledge, a precious public good.
>
>
>>
>> Instinctively, I'd say documenting this policy (or whatever it actually
>> is) would be good, and having all vulnerabilities get publically released
>> eventually would also be good; that's certainly the more "open source"
>> approach. But arguing the other side:
>>
>>  - documenting security policy gives attackers a better handle on where
>>    to find weak points; this may be more harm than there is benefit to
>>    improving legitimate users' understanding of and confidence in the
>>    development process
>>
>>
> Publishing a policy *might* increase organizational vulnerability, but so
> might *not publishing* a policy. It seems fairly neutral to me on
> vulnerability impact, whereas the benefit is good for users and developers.
>
>
>
>>  - the main benefit of public vulnerability disclosure is a better
>>    working relationship with security researchers and perhaps better
>>    understanding of what sort of bugs happen in practice in general;
>>    but if most of your security research is effectively in house [6],
>>    maybe those benefits aren't as great as the harm done by revealing
>>    even old vulnerabilities to attackers
>>
>>
> Publishing after a reasonable timeout has many benefits. Many security
> researchers learn from vulnerability disclosures across many disciplines
> and industries. Future protocol designers of things potentially unrelated
> to blockchain altogether may also learn important lessons.
>
>
> If the first of those arguments holds, well, hopefully this message has
>> egregious errors that no one will correct, or it will quickly get lost
>> in this list's archives...
>>
>> Cheers,
>> aj
>>
>>
> regards,
> Nathan Wilcox
> Zcash
>
>
>> [0] http://bitcoincore.org/en/contact
>>     referenced from .github/ISSUE_TEMPLATE.md in git
>>
>> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017
>> -September/014986.html
>>
>> [2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017
>> -September/014990.html
>>
>> [3] https://www.reddit.com/r/btc/comments/6zf1qo/peter_todd_nice
>> ly_pulled_away_attention_from_jjs/dmxcw70/
>>
>> [4] https://www.reddit.com/r/btc/comments/6z827o/chris_jeffrey_j
>> j_discloses_bitcoin_attack_vector/dmxdg83/
>>
>> [5] https://www.reddit.com/r/btc/comments/6zb3lp/maxwell_admits_
>> core_sat_on_vulnerability/dmv4y7g/
>>
>> [6] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017
>> -September/014991.html
>>
>> [7] Per http://luke.dashjr.org/programs/bitcoin/files/charts/branche
>> s.html
>>     it seems like 1.7% of the network is running known-vulnerable versions
>>     0.8 and 0.9; but only 0.37% are running 0.10 or 0.11, so that might
>> argue
>>     revealing any vulnerabilities fixed since 0.12.0 would be fine...
>>     (bitnodes.21.co doesn't seem to break down anything earlier than
>> 0.12)
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170922/cdd9e559/attachment.html>

From sergio.d.lerner at gmail.com  Fri Sep 22 20:32:56 2017
From: sergio.d.lerner at gmail.com (Sergio Demian Lerner)
Date: Fri, 22 Sep 2017 17:32:56 -0300
Subject: [bitcoin-dev] cleanstack alt stack & softfork improvements
 (Was: Merkle branch verification & tail-call semantics for generalized
 MAST)
In-Reply-To: <CAA2B000-6C54-4AD7-B931-43C99D615A61@friedenbach.org>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<C623794E-F061-4C7A-B05D-378798ED2BF7@friedenbach.org>
	<201709190309.08669.luke@dashjr.org>
	<CAA2B000-6C54-4AD7-B931-43C99D615A61@friedenbach.org>
Message-ID: <CAKzdR-phAarTY16BOnC95BPN0qMNEE_XZ9H-XmFeeaBc2V1U5w@mail.gmail.com>

>
> There are other solutions to this problem that could have been taken
> instead, such as committing to the number of items or maximum size of
> the stack as part of the sighash data, but cleanstack was the approach
> taken.


The lack of signed maximum segwit stack size was one of the objections to
segwit I presented last year. This together with the unlimited segwit stack
size.

However, committing to the maximum stack size (in bytes) for an input is
tricky. The only place where this could be packed is in sequence_no, with a
soft-fork. E.g. when transaction version is 2 and and only when lock_time
is zero.

For transactions with locktime >0, we could soft-fork so transactions add a
last zero-satoshi output whose scriptPub contains OP_RETURN and followed by
N VarInts, containing the maximum stack size of each input.
Normally, for a 400 byte, 2-input transaction, this will add 11 bytes, or a
2.5% overhead.








> Arguably for a future script version upgrade one of these other
> approaches should be taken to allow for shorter tail-call scripts.
>
> Mark
>
> * Well, almost any. You could end the script with DEPTH EQUAL and that
>   is a compact way of ensuring the stack is clean (assuming the script
>   finished with just "true" on the stack). Nobody does this however
>   and burning two witness bytes of every redeem script going forward
>   as a protective measure seems like an unnecessary ask.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170922/cc607dfd/attachment-0001.html>

From mark at friedenbach.org  Fri Sep 22 21:11:03 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Fri, 22 Sep 2017 14:11:03 -0700
Subject: [bitcoin-dev] cleanstack alt stack & softfork improvements
 (Was: Merkle branch verification & tail-call semantics for generalized
 MAST)
In-Reply-To: <CAKzdR-phAarTY16BOnC95BPN0qMNEE_XZ9H-XmFeeaBc2V1U5w@mail.gmail.com>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<C623794E-F061-4C7A-B05D-378798ED2BF7@friedenbach.org>
	<201709190309.08669.luke@dashjr.org>
	<CAA2B000-6C54-4AD7-B931-43C99D615A61@friedenbach.org>
	<CAKzdR-phAarTY16BOnC95BPN0qMNEE_XZ9H-XmFeeaBc2V1U5w@mail.gmail.com>
Message-ID: <3385CE20-C1BA-40DD-8FC3-8F53F3350717@friedenbach.org>


> On Sep 22, 2017, at 1:32 PM, Sergio Demian Lerner <sergio.d.lerner at gmail.com> wrote:
> 
> 
> 
> There are other solutions to this problem that could have been taken
> instead, such as committing to the number of items or maximum size of
> the stack as part of the sighash data, but cleanstack was the approach
> taken. 
> 
> The lack of signed maximum segwit stack size was one of the objections to segwit I presented last year. This together with the unlimited segwit stack size.
> 
> However, committing to the maximum stack size (in bytes) for an input is tricky. The only place where this could be packed is in sequence_no, with a soft-fork. E.g. when transaction version is 2 and and only when lock_time is zero.
> 
> For transactions with locktime >0, we could soft-fork so transactions add a last zero-satoshi output whose scriptPub contains OP_RETURN and followed by N VarInts, containing the maximum stack size of each input. 
> Normally, for a 400 byte, 2-input transaction, this will add 11 bytes, or a 2.5% overhead.

There?s no need to put it in the transaction itself. You put it in the witness and it is either committed to as part of the witness (in which case it has to hold for all possible spend paths), or at spend time by including it in the data signed by CHECKSIG.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170922/9800edc4/attachment.html>

From sergio.d.lerner at gmail.com  Fri Sep 22 21:32:00 2017
From: sergio.d.lerner at gmail.com (Sergio Demian Lerner)
Date: Fri, 22 Sep 2017 18:32:00 -0300
Subject: [bitcoin-dev] cleanstack alt stack & softfork improvements
 (Was: Merkle branch verification & tail-call semantics for generalized
 MAST)
In-Reply-To: <3385CE20-C1BA-40DD-8FC3-8F53F3350717@friedenbach.org>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<C623794E-F061-4C7A-B05D-378798ED2BF7@friedenbach.org>
	<201709190309.08669.luke@dashjr.org>
	<CAA2B000-6C54-4AD7-B931-43C99D615A61@friedenbach.org>
	<CAKzdR-phAarTY16BOnC95BPN0qMNEE_XZ9H-XmFeeaBc2V1U5w@mail.gmail.com>
	<3385CE20-C1BA-40DD-8FC3-8F53F3350717@friedenbach.org>
Message-ID: <CAKzdR-pnvystx5H+P+OCXm73aVmWdyesCymerSgx=pCuXx+YGA@mail.gmail.com>

But generally before one signs a transaction one does not know the
signature size (which may be variable). One can only estimate the maximum
size.

On Fri, Sep 22, 2017 at 6:11 PM, Mark Friedenbach <mark at friedenbach.org>
wrote:

>
> On Sep 22, 2017, at 1:32 PM, Sergio Demian Lerner <
> sergio.d.lerner at gmail.com> wrote:
>
>
>>
>> There are other solutions to this problem that could have been taken
>> instead, such as committing to the number of items or maximum size of
>> the stack as part of the sighash data, but cleanstack was the approach
>> taken.
>
>
> The lack of signed maximum segwit stack size was one of the objections to
> segwit I presented last year. This together with the unlimited segwit stack
> size.
>
> However, committing to the maximum stack size (in bytes) for an input is
> tricky. The only place where this could be packed is in sequence_no, with a
> soft-fork. E.g. when transaction version is 2 and and only when lock_time
> is zero.
>
> For transactions with locktime >0, we could soft-fork so transactions add
> a last zero-satoshi output whose scriptPub contains OP_RETURN and followed
> by N VarInts, containing the maximum stack size of each input.
> Normally, for a 400 byte, 2-input transaction, this will add 11 bytes, or
> a 2.5% overhead.
>
>
> There?s no need to put it in the transaction itself. You put it in the
> witness and it is either committed to as part of the witness (in which case
> it has to hold for all possible spend paths), or at spend time by including
> it in the data signed by CHECKSIG.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170922/87c83dee/attachment.html>

From mark at friedenbach.org  Fri Sep 22 21:39:45 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Fri, 22 Sep 2017 14:39:45 -0700
Subject: [bitcoin-dev] cleanstack alt stack & softfork improvements
 (Was: Merkle branch verification & tail-call semantics for generalized
 MAST)
In-Reply-To: <CAKzdR-pnvystx5H+P+OCXm73aVmWdyesCymerSgx=pCuXx+YGA@mail.gmail.com>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<C623794E-F061-4C7A-B05D-378798ED2BF7@friedenbach.org>
	<201709190309.08669.luke@dashjr.org>
	<CAA2B000-6C54-4AD7-B931-43C99D615A61@friedenbach.org>
	<CAKzdR-phAarTY16BOnC95BPN0qMNEE_XZ9H-XmFeeaBc2V1U5w@mail.gmail.com>
	<3385CE20-C1BA-40DD-8FC3-8F53F3350717@friedenbach.org>
	<CAKzdR-pnvystx5H+P+OCXm73aVmWdyesCymerSgx=pCuXx+YGA@mail.gmail.com>
Message-ID: <9FD4AF03-28A5-4B8A-9C12-CBCB1BC2E22C@friedenbach.org>

You generally know the witness size to within a few bytes right before signing. Why would you not? You know the size of ECDSA signatures. You can be told the size of a hash preimage by the other party. It takes some contriving to come up with a scheme where one party has variable-length signatures of their chosing

> On Sep 22, 2017, at 2:32 PM, Sergio Demian Lerner <sergio.d.lerner at gmail.com> wrote:
> 
> But generally before one signs a transaction one does not know the signature size (which may be variable). One can only estimate the maximum size. 


From sergio.d.lerner at gmail.com  Fri Sep 22 21:54:39 2017
From: sergio.d.lerner at gmail.com (Sergio Demian Lerner)
Date: Fri, 22 Sep 2017 18:54:39 -0300
Subject: [bitcoin-dev] cleanstack alt stack & softfork improvements
 (Was: Merkle branch verification & tail-call semantics for generalized
 MAST)
In-Reply-To: <9FD4AF03-28A5-4B8A-9C12-CBCB1BC2E22C@friedenbach.org>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<C623794E-F061-4C7A-B05D-378798ED2BF7@friedenbach.org>
	<201709190309.08669.luke@dashjr.org>
	<CAA2B000-6C54-4AD7-B931-43C99D615A61@friedenbach.org>
	<CAKzdR-phAarTY16BOnC95BPN0qMNEE_XZ9H-XmFeeaBc2V1U5w@mail.gmail.com>
	<3385CE20-C1BA-40DD-8FC3-8F53F3350717@friedenbach.org>
	<CAKzdR-pnvystx5H+P+OCXm73aVmWdyesCymerSgx=pCuXx+YGA@mail.gmail.com>
	<9FD4AF03-28A5-4B8A-9C12-CBCB1BC2E22C@friedenbach.org>
Message-ID: <CAKzdR-r6u4J+_T5X516A=-tLWZ8zFFFsRokReiJndDE_S64OqQ@mail.gmail.com>

If the variable size increase is only a few bytes, then three possibilities
arise:

- one should allow signatures to be zero padded (to reach the maximum size)
and abandon strict DER encoding

- one should allow spare witness stack elements (to pad the size to match
the maximum size) and remove the cleanstack rule. But this is tricky
because empty stack elements must be counted as 1 byte.

- signers must loop the generation of signatures until the signature
generated is of its maximum size.




On Fri, Sep 22, 2017 at 6:39 PM, Mark Friedenbach <mark at friedenbach.org>
wrote:

> You generally know the witness size to within a few bytes right before
> signing. Why would you not? You know the size of ECDSA signatures. You can
> be told the size of a hash preimage by the other party. It takes some
> contriving to come up with a scheme where one party has variable-length
> signatures of their chosing
>
> > On Sep 22, 2017, at 2:32 PM, Sergio Demian Lerner <
> sergio.d.lerner at gmail.com> wrote:
> >
> > But generally before one signs a transaction one does not know the
> signature size (which may be variable). One can only estimate the maximum
> size.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170922/2f36b74f/attachment-0001.html>

From mark at friedenbach.org  Fri Sep 22 22:07:33 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Fri, 22 Sep 2017 15:07:33 -0700
Subject: [bitcoin-dev] cleanstack alt stack & softfork improvements
 (Was: Merkle branch verification & tail-call semantics for generalized
 MAST)
In-Reply-To: <CAKzdR-r6u4J+_T5X516A=-tLWZ8zFFFsRokReiJndDE_S64OqQ@mail.gmail.com>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<C623794E-F061-4C7A-B05D-378798ED2BF7@friedenbach.org>
	<201709190309.08669.luke@dashjr.org>
	<CAA2B000-6C54-4AD7-B931-43C99D615A61@friedenbach.org>
	<CAKzdR-phAarTY16BOnC95BPN0qMNEE_XZ9H-XmFeeaBc2V1U5w@mail.gmail.com>
	<3385CE20-C1BA-40DD-8FC3-8F53F3350717@friedenbach.org>
	<CAKzdR-pnvystx5H+P+OCXm73aVmWdyesCymerSgx=pCuXx+YGA@mail.gmail.com>
	<9FD4AF03-28A5-4B8A-9C12-CBCB1BC2E22C@friedenbach.org>
	<CAKzdR-r6u4J+_T5X516A=-tLWZ8zFFFsRokReiJndDE_S64OqQ@mail.gmail.com>
Message-ID: <971464E1-5AB8-44FD-BAE8-897DC4C5D970@friedenbach.org>

There is no harm in the value being a maximum off by a few bytes.

> On Sep 22, 2017, at 2:54 PM, Sergio Demian Lerner <sergio.d.lerner at gmail.com> wrote:
> 
> If the variable size increase is only a few bytes, then three possibilities arise:
> 
> - one should allow signatures to be zero padded (to reach the maximum size) and abandon strict DER encoding
> 
> - one should allow spare witness stack elements (to pad the size to match the maximum size) and remove the cleanstack rule. But this is tricky because empty stack elements must be counted as 1 byte.
> 
> - signers must loop the generation of signatures until the signature generated is of its maximum size.


From pieter.wuille at gmail.com  Fri Sep 22 22:09:07 2017
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Fri, 22 Sep 2017 15:09:07 -0700
Subject: [bitcoin-dev] cleanstack alt stack & softfork improvements
 (Was: Merkle branch verification & tail-call semantics for generalized
 MAST)
In-Reply-To: <CAKzdR-r6u4J+_T5X516A=-tLWZ8zFFFsRokReiJndDE_S64OqQ@mail.gmail.com>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<C623794E-F061-4C7A-B05D-378798ED2BF7@friedenbach.org>
	<201709190309.08669.luke@dashjr.org>
	<CAA2B000-6C54-4AD7-B931-43C99D615A61@friedenbach.org>
	<CAKzdR-phAarTY16BOnC95BPN0qMNEE_XZ9H-XmFeeaBc2V1U5w@mail.gmail.com>
	<3385CE20-C1BA-40DD-8FC3-8F53F3350717@friedenbach.org>
	<CAKzdR-pnvystx5H+P+OCXm73aVmWdyesCymerSgx=pCuXx+YGA@mail.gmail.com>
	<9FD4AF03-28A5-4B8A-9C12-CBCB1BC2E22C@friedenbach.org>
	<CAKzdR-r6u4J+_T5X516A=-tLWZ8zFFFsRokReiJndDE_S64OqQ@mail.gmail.com>
Message-ID: <CAPg+sBi+WnzpJkcG6XACdpqqz9ZA3rHX8+H9b5eExUdgXaeiWQ@mail.gmail.com>

On Fri, Sep 22, 2017 at 2:54 PM, Sergio Demian Lerner via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> If the variable size increase is only a few bytes, then three
> possibilities arise:
>
> - one should allow signatures to be zero padded (to reach the maximum
> size) and abandon strict DER encoding
>
> - one should allow spare witness stack elements (to pad the size to match
> the maximum size) and remove the cleanstack rule. But this is tricky
> because empty stack elements must be counted as 1 byte.
>
> - signers must loop the generation of signatures until the signature
> generated is of its maximum size.
>

Or (my preference);

- Get rid of DER encoding alltogether and switch to fixed size signatures.

Cheers,

-- 
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170922/5cb68030/attachment.html>

From ZmnSCPxj at protonmail.com  Sat Sep 23 01:49:11 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 22 Sep 2017 21:49:11 -0400
Subject: [bitcoin-dev] Sidechains: Mainstake
Message-ID: <rRLvSIAs4ZyW4YTai9d_ON_xV2HH6NlhRIsU2C9mzTKiGuXmtJjafTtmK9lJIgBYVNVRGcfKAWON_l2ZE9bKuqON11NXGoKKn1SOGXi8Dbs=@protonmail.com>

Good morning bitcoin-dev,

I have yet another sidechain proposal: https://zmnscpxj.github.io/sidechain/mainstake/index.html

I make the below outlandish claims in the above link:

1. While a 51% mainchain miner theft is still possible, it will take even longer than in drivechains (either months of broadcasting intent to steal before the theft, or locking funds that are likely to remain locked after a week-long theft).
2. A 26% anti-sidechain miner cannot completely block all sidechain withdrawals as they could in drivechains.
3. Outside of attacks and censorship, the economic majority controls sidechains, without going through miners as "representatives of the economic majority".
4. With sufficient cleverness (stupidity?), proof-of-stake can be made to work.

I hope for your consideration.  I suspect that I have not thought things out completely, and probably missed some significant flaw.

Regards,
ZmnSCPxj
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170922/ef4ebaac/attachment.html>

From psharp.x13 at gmail.com  Mon Sep 25 21:53:30 2017
From: psharp.x13 at gmail.com (Patrick Sharp)
Date: Mon, 25 Sep 2017 15:53:30 -0600
Subject: [bitcoin-dev] idea post: bitcoin side chain implementation
Message-ID: <CAES+R-q6v=Qc2zZgczNfKhrBtZ0kCt0Um90miAMGB0npp4zAKQ@mail.gmail.com>

Hello Devs,

I am Patrick Sharp. I just graduated with a BS is computer science. Forgive
my ignorance.

As per bip-0002 I have scoured each bip available on the wiki to see if
these ideas have already been formally proposed and now as per bip-0002
post these ideas here.

First and foremost I acknowledge that these ideas are not original nor new.

Side Chains:

Bip-R10 offers a mechanism to assign custody or transfer coins from one
chain to another. However I did not find a bip that proposed a formal
bitcoin side chain.

My proposal

   - They are officially supported, tracked and built by official bitcoin
   software meaning that they are not an external chain
   - each chain has an identifier in the block header i.e. main chain: 0,
   first chain: 1, second chain: 2...
   - the number of chains including the main chain that exists is always a
   power of 2, this power will also be included in the block header.
   - each address is assigned to a chain via chain = (address) mod (number
   of chains)
      - to be valid an addresse's next transaction will first send their
      coins to their chain if they are not already there
      - if the address they are sending to is outside their chain their
      transaction will be submitted to both chains and transaction fee will be
      split between chains
   - They come into being via a fork or split
      - every 2016 blocks (upon recalculation of difficulty) if some
      percentage (lets say 10%) of blocks on any chain are larger than some
      specified amount (lets say 750 KB) then all chains are called to
increment
      their power value and fork on their block.
         - miner of chain x creates genesis block for chain x+2^previous
         power
         - upon fork, the difficulty of the old chain and the new chain
         will be half the next difficulty
      - if every chain has gone 2016 block without surpassing some amount
      (lets say 250 KB) at least some percentage of the time (lets say 10%) all
      chains will be called to join, decrement their power and double their
      difficulty
         - given miner of chain x, if x not less than 2^new power, chain
         will be marked dead or sleeping
         - miners who mine blocks on the chain that was joined (the chain
         with the smaller identifier) may have to make a block for the sleeping
         chain if transactions include funds that fully or partially
originate from
         the sleeping chain
         - dead chain are revived on next split.
      - each block's reward outside of transaction fees will be the
      (current bounty / 2^fork power) except obviously for dead blocks who's
      reward is already included in their joined block
   - benefits
      - dynamically scales to any level of usage, no more issues about
      block size
      - miners have incentive to keep all difficulties close to parity
      - if miners are limited by hard drive space they don't have to mine
      every chain (though they should have trusted peers working on
other chains
      to verify transactions that originate off their chains, faulty block will
      still be unaccepted by the rest of the miners)
      - though work will still grow linearly with the number of chains due
      to having to hash each separate header, some of the overhead may remain
      constant and difficulty and reward will still be balanced.
      - transactions are pseudo equally distributed between chains.
      - rewards will be more distributed (doesn't' really matter, except
      that its beautiful)
   - cons
      - because most transactions will be double recorded the non-volatile
      memory foot print of bitcoin doubles (since miners do not need
all chains i
      believe this solution not only overcomes this cost but may decrease the
      foot print per miner in the long run overall)
      - transactions will hang in limbo until both chains have picked them
      up, a forever limboed transaction could result in lost coins, as
long as a
      transaction fee has been included this risk should be mitigated.

I believe this idea is applicable to the entire community. I would like
your thoughts and suggestions. I obviously think this is a freaking awesome
idea. I know it is quite ambitious but it is the next step in evolution
that bitcoin needs to take to be a viable competitor to visa.

I come to you to ask if this has any chance of acceptance.

-Patrick
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170925/515236fc/attachment-0001.html>

From psharp.x13 at gmail.com  Mon Sep 25 21:54:16 2017
From: psharp.x13 at gmail.com (Patrick Sharp)
Date: Mon, 25 Sep 2017 15:54:16 -0600
Subject: [bitcoin-dev] idea post: trimming and demurrage
Message-ID: <CAES+R-qpBwXdROKnXW0idierJYf7pSRe3Z=KSYvcGwB_S6nXrA@mail.gmail.com>

Hello Devs,

I am Patrick Sharp. I just graduated with a BS is computer science. Forgive
my ignorance.

As per bip-0002 I have scoured each bip available on the wiki to see if
these ideas have already been formally proposed and now as per bip-0002
post these ideas here.

First and foremost I acknowledge that these ideas are not original nor new.

Trimming and demurrage:

I am fully aware that demurrage is a prohibited change. I hereby contest.
For the record I am not a miner, I am just aware of the economics that
drive the costs of bitcoin.

Without the ability to maintain some sort of limit on the maximum length or
size of the block chain, block chain is not only unsustainable in the long
run but becomes more and more centralized as the block chain becomes more
and more unwieldy.

Trimming is not a foreign concept. Old block whose transactions are now
spent hold no real value. Meaningful trimming is expensive and inhibited by
unspent transactions. Old unspent transactions add unnecessary and unfair
burden.

   - Old transactions take up real world space that continues incur cost
   while these transactions they do not continue to contribute to any sort of
   payment for this cost.
   - One can assume that anybody with access to their bitcoins has the
   power to move these bitcoins from one address to another (or at least that
   the software that holds the keys to their coins can do it for them) and it
   is not unfair to require them to do so at least once every 5 to 10 years.
   - Given the incentive to move it or lose it and software that will do it
      for them, we can assume that any bitcoin not moved is most likey
therefore
      lost.
      - moving these coins will cost a small transaction fee which is fair
      as their transactions take up space, they need to contribute
      - most people who use their coins regularly will not even need to
      worry about this as their coins are moved to a change address anyway.
   - one downside is that paper wallets would then have an expiration date,
   however I do not think that a paper wallet that needs to be recycled every
   5 to 10 years is a terrible idea.

Therefore I propose that the block chain length be limited to either 2^18
blocks (slightly less than 5 years) or 2^19 blocks, or slightly less than
10 years. I propose that each time a block is mined the the oldest block(s)
(no more than two blocks) beyond this limit is trimmed from the chain and
that its unspent transactions are allowed to be included in the reward of
the mined block.

This keeps the block chain from tending towards infinity. This keeps the
costs of the miners balanced with the costs of the users.

Even though I believe this idea will have some friction, it is applicable
to the entire community. It will be hard for some users to give up small
benefits that they get at the great cost of miners, however miners run the
game and this fair proposal is in in their best interest in two different
ways. I would like your thoughts and suggestions. I obviously think this is
a freaking awesome idea. I know it is quite controversial but it is the
next step in evolution that bitcoin needs to take to ensure immortality.

I come to you to ask if this has any chance of acceptance.

-Patrick
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170925/0d5f1ac1/attachment.html>

From cryptaxe at gmail.com  Mon Sep 25 22:58:52 2017
From: cryptaxe at gmail.com (CryptAxe)
Date: Mon, 25 Sep 2017 15:58:52 -0700
Subject: [bitcoin-dev] idea post: bitcoin side chain implementation
In-Reply-To: <CAES+R-q6v=Qc2zZgczNfKhrBtZ0kCt0Um90miAMGB0npp4zAKQ@mail.gmail.com>
References: <CAES+R-q6v=Qc2zZgczNfKhrBtZ0kCt0Um90miAMGB0npp4zAKQ@mail.gmail.com>
Message-ID: <CAF5CFkheg5U0zPLSq9ow2aFZept8nGN94q894yRjiuvAY5s7Fw@mail.gmail.com>

Have you taken a look at Elements or Drivechains yet by chance?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170925/0ce30d83/attachment.html>

From ZmnSCPxj at protonmail.com  Mon Sep 25 23:34:32 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 25 Sep 2017 19:34:32 -0400
Subject: [bitcoin-dev] idea post: trimming and demurrage
In-Reply-To: <CAES+R-qpBwXdROKnXW0idierJYf7pSRe3Z=KSYvcGwB_S6nXrA@mail.gmail.com>
References: <CAES+R-qpBwXdROKnXW0idierJYf7pSRe3Z=KSYvcGwB_S6nXrA@mail.gmail.com>
Message-ID: <9Rdn-Mm90LWD4Tk_F0x04feUwKQp3nL8yTou9435kqjPCwjXWzNXsYTbWDA8YvO4p6_jBu1sFXEAa1ybvtcIrOqbv7qkghwENdHch6n_EEM=@protonmail.com>

Good morning Patrick,

Demurrage is simply impossible.

In Bitcoin we already have implemented OP_CHECKLOCKTIMEVERIFY.

This opcode requires that a certain block height or date has passed before the output can be spent.

It can be used to make an "in trust for" address, where you disallow spending of that address.  For example, you may have a child to whom you wish to dedicate some inheritance to, and ensure that the child will not spend it recklessly until they achieve some age (when hopefully they would be more mature), regardless of what happens to you.

If I made a P2SH address with OP_CHECKLOCKTIMEVERIFY that allows spending 18 years from birth of my child, and then suddenly Bitcoin Core announces demurrage, I would be very angry.

OP_CHECKLOCKTIMEVERIFY cannot be countermanded, and it would be impossible to refresh the UTXO's as required by demurrage, without requiring a hardfork that ignores OP_CHECKLOCKTIMEVERIFY.

It would be better to put such additional features as demurrage in a sidechain rather than on mainchain.

Regards,
ZmnSCPxj

-------- Original Message --------
Subject: [bitcoin-dev] idea post: trimming and demurrage
Local Time: September 25, 2017 9:54 PM
UTC Time: September 25, 2017 9:54 PM
From: bitcoin-dev at lists.linuxfoundation.org
To: bitcoin-dev at lists.linuxfoundation.org

Hello Devs,

I am Patrick Sharp. I just graduated with a BS is computer science. Forgive my ignorance.

As per bip-0002 I have scoured each bip available on the wiki to see if these ideas have already been formally proposed and now as per bip-0002 post these ideas here.

First and foremost I acknowledge that these ideas are not original nor new.

Trimming and demurrage:

I am fully aware that demurrage is a prohibited change. I hereby contest. For the record I am not a miner, I am just aware of the economics that drive the costs of bitcoin.

Without the ability to maintain some sort of limit on the maximum length or size of the block chain, block chain is not only unsustainable in the long run but becomes more and more centralized as the block chain becomes more and more unwieldy.

Trimming is not a foreign concept. Old block whose transactions are now spent hold no real value. Meaningful trimming is expensive and inhibited by unspent transactions. Old unspent transactions add unnecessary and unfair burden.
Old transactions take up real world space that continues incur cost while these transactions they do not continue to contribute to any sort of payment for this cost.
One can assume that anybody with access to their bitcoins has the power to move these bitcoins from one address to another (or at least that the software that holds the keys to their coins can do it for them) and it is not unfair to require them to do so at least once every 5 to 10 years.
Given the incentive to move it or lose it and software that will do it for them, we can assume that any bitcoin not moved is most likey therefore lost.
moving these coins will cost a small transaction fee which is fair as their transactions take up space, they need to contribute
most people who use their coins regularly will not even need to worry about this as their coins are moved to a change address anyway.
one downside is that paper wallets would then have an expiration date, however I do not think that a paper wallet that needs to be recycled every 5 to 10 years is a terrible idea.
Therefore I propose that the block chain length be limited to either 2^18 blocks (slightly less than 5 years) or 2^19 blocks, or slightly less than 10 years. I propose that each time a block is mined the the oldest block(s) (no more than two blocks) beyond this limit is trimmed from the chain and that its unspent transactions are allowed to be included in the reward of the mined block.

This keeps the block chain from tending towards infinity. This keeps the costs of the miners balanced with the costs of the users.

Even though I believe this idea will have some friction, it is applicable to the entire community. It will be hard for some users to give up small benefits that they get at the great cost of miners, however miners run the game and this fair proposal is in in their best interest in two different ways. I would like your thoughts and suggestions. I obviously think this is a freaking awesome idea. I know it is quite controversial but it is the next step in evolution that bitcoin needs to take to ensure immortality.

I come to you to ask if this has any chance of acceptance.

-Patrick
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170925/619478f6/attachment-0001.html>

From richard.hein at gmail.com  Mon Sep 25 23:30:23 2017
From: richard.hein at gmail.com (Richard Hein)
Date: Mon, 25 Sep 2017 19:30:23 -0400
Subject: [bitcoin-dev] idea post: trimming and demurrage
In-Reply-To: <CAES+R-qpBwXdROKnXW0idierJYf7pSRe3Z=KSYvcGwB_S6nXrA@mail.gmail.com>
References: <CAES+R-qpBwXdROKnXW0idierJYf7pSRe3Z=KSYvcGwB_S6nXrA@mail.gmail.com>
Message-ID: <AECFA9C4-DF1B-452A-8249-B7DAE0A67B19@gmail.com>

It kills Bitcoin as a store of value.  Disk space is not the problem; bandwidth is.  The blockchain won't go to infinity as you suggest, as it is bounded by certain constraints.  It's growth is a function of the transactions in a block, and the number of blocks is linear in growth.  

Sent from my iPhone

> On Sep 25, 2017, at 5:54 PM, Patrick Sharp via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Hello Devs,
> 
> I am Patrick Sharp. I just graduated with a BS is computer science. Forgive my ignorance.
> 
> As per bip-0002 I have scoured each bip available on the wiki to see if these ideas have already been formally proposed and now as per bip-0002 post these ideas here.
> 
> First and foremost I acknowledge that these ideas are not original nor new.
> 
> Trimming and demurrage:
> 
> I am fully aware that demurrage is a prohibited change. I hereby contest. For the record I am not a miner, I am just aware of the economics that drive the costs of bitcoin.
> 
> Without the ability to maintain some sort of limit on the maximum length or size of the block chain, block chain is not only unsustainable in the long run but becomes more and more centralized as the block chain becomes more and more unwieldy.
> 
> Trimming is not a foreign concept. Old block whose transactions are now spent hold no real value. Meaningful trimming is expensive and inhibited by unspent transactions. Old unspent transactions add unnecessary and unfair burden.
> Old transactions take up real world space that continues incur cost while these transactions they do not continue to contribute to any sort of payment for this cost.
> One can assume that anybody with access to their bitcoins has the power to move these bitcoins from one address to another (or at least that the software that holds the keys to their coins can do it for them) and it is not unfair to require them to do so at least once every 5 to 10 years.
> Given the incentive to move it or lose it and software that will do it for them, we can assume that any bitcoin not moved is most likey therefore lost.
> moving these coins will cost a small transaction fee which is fair as their transactions take up space, they need to contribute
> most people who use their coins regularly will not even need to worry about this as their coins are moved to a change address anyway.
> one downside is that paper wallets would then have an expiration date, however I do not think that a paper wallet that needs to be recycled every 5 to 10 years is a terrible idea.
> Therefore I propose that the block chain length be limited to either 2^18 blocks (slightly less than 5 years) or 2^19 blocks, or slightly less than 10 years. I propose that each time a block is mined the the oldest block(s) (no more than two blocks) beyond this limit is trimmed from the chain and that its unspent transactions are allowed to be included in the reward of the mined block.
> 
> This keeps the block chain from tending towards infinity. This keeps the costs of the miners balanced with the costs of the users.
> 
> Even though I believe this idea will have some friction, it is applicable to the entire community. It will be hard for some users to give up small benefits that they get at the great cost of miners, however miners run the game and this fair proposal is in in their best interest in two different ways. I would like your thoughts and suggestions. I obviously think this is a freaking awesome idea. I know it is quite controversial but it is the next step in evolution that bitcoin needs to take to ensure immortality.
> 
> I come to you to ask if this has any chance of acceptance.
> 
> -Patrick
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170925/c08a683e/attachment.html>

From psharp.x13 at gmail.com  Tue Sep 26 00:07:12 2017
From: psharp.x13 at gmail.com (Patrick Sharp)
Date: Mon, 25 Sep 2017 18:07:12 -0600
Subject: [bitcoin-dev] idea post: bitcoin side chain implementation
In-Reply-To: <CAF5CFkheg5U0zPLSq9ow2aFZept8nGN94q894yRjiuvAY5s7Fw@mail.gmail.com>
References: <CAES+R-q6v=Qc2zZgczNfKhrBtZ0kCt0Um90miAMGB0npp4zAKQ@mail.gmail.com>
	<CAF5CFkheg5U0zPLSq9ow2aFZept8nGN94q894yRjiuvAY5s7Fw@mail.gmail.com>
Message-ID: <CAES+R-pHkDHSPpTcyJyEv2rSWOvAkG+zUqs8hPwbHigejyFvDw@mail.gmail.com>

I shamefully was not aware. However familiarized myself with them.

Non official chains suffer from the fact that few if any miners are going
to mine them so they lack security on par with the main chain. And more
over most users aren't going to use them because its not magic.

That being said think they are and will always be a great place to develop
and prove out concepts.

If my ultimate goal is official side chains that include part of the reward
such security is at parity between all chains and that the official
software automatically enable users to distribute their burden, would my
course of action be to build an external proof-of-concept side chain of
side chains?
or do you doubt that official reward splitting chains will ever find their
way into bitcoin core?

On Mon, Sep 25, 2017 at 4:58 PM, CryptAxe <cryptaxe at gmail.com> wrote:

> Have you taken a look at Elements or Drivechains yet by chance?
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170925/89b2b5fa/attachment.html>

From ZmnSCPxj at protonmail.com  Tue Sep 26 00:01:10 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 25 Sep 2017 20:01:10 -0400
Subject: [bitcoin-dev] idea post: bitcoin side chain implementation
In-Reply-To: <CAES+R-q6v=Qc2zZgczNfKhrBtZ0kCt0Um90miAMGB0npp4zAKQ@mail.gmail.com>
References: <CAES+R-q6v=Qc2zZgczNfKhrBtZ0kCt0Um90miAMGB0npp4zAKQ@mail.gmail.com>
Message-ID: <YbD_Ikg2xmzEW1n20TKj8UoKLYn9scntkRHiyHuqXZbiJAqI37wxXZ4BgAciYQlcIrsMj4xorkT94_IvyZ9IVErMdTZLn3aY4gCNtgD9uss=@protonmail.com>

Good morning Patrick,

Your idea seems to focus more on scaling than on what sidechains actually were originally considered for.

Sidechains were originally designed to add and prototype new features to Bitcoin.  Increasing the effective block size is not what sidechains were expected to do.

For scaling, Lightning Network is a superior solution, as it keeps most transactions off-chain.

Features are the important thing that sidechains are supposed to add to Bitcoin.

1. Addresses are not how Bitcoin works under-the-hood.  Instead, P2PKH and P2SH addresses represent 2 kinds of standard output scripts.  It is possible in theory (with a lot of endless debate) to add new standard output scripts, some of which may not have an equivalent of an address.

2.  It is easy to game your system.  A miner needs only to send a bunch of transactions from himself to himself to trigger the splitting condition.  It would even be possible to hide this somewhat by generating new public/private key pairs.

3.  The problem with on-chain scaling is not that the code has this 1Mb limit.  The problem with on-chain scaling is delivering all of the block data to the rest of the network.  Crucially, in the case that block data delivery is slow, a larger mining pool with more resources and greater ability to handle larger blocks, will work better than smaller pools or solo miners due to orphan rate/stale rate.  Thus it is in the interest of large mining pools to push for large blocks and more data per second on-chain, in order to further consolidate their power and influence over Bitcoin.  As the censorship-resistance of Bitcoin is dependent on there being many small mining pools, larger blocks destroy censorship-resistance.

4.  Disk space is not a problem.  It never was the problem.  Satoshi even mistakenly thought it was a problem, but it never was and it never will be.  The problem is that the computations on Bitcoin's security assume that blocks are delivered in 0 time.  That is not true in reality, but the reason why 10 minutes was selected as the block rate is to make block delivery time as close to 0 (relative to the average block rate) as possible.  Increasing block size makes block delivery time further from the ideal 0 that is the basis of Bitcon's security.

5.  Mining is a random process and once splits occur, you can never assure that particular chains will synchronize the real-world time of 2016 blocks.  I mean, it would be come possible for one chain to finish in 1 week while another chain is never worked on.  The 2016-blocks schedule is even more likely to misalign in real time when further splits occur.

Regards,
ZmnSCPxj

-------- Original Message --------
Subject: [bitcoin-dev] idea post: bitcoin side chain implementation
Local Time: September 25, 2017 9:53 PM
UTC Time: September 25, 2017 9:53 PM
From: bitcoin-dev at lists.linuxfoundation.org
To: bitcoin-dev at lists.linuxfoundation.org

Hello Devs,

I am Patrick Sharp. I just graduated with a BS is computer science. Forgive my ignorance.

As per bip-0002 I have scoured each bip available on the wiki to see if these ideas have already been formally proposed and now as per bip-0002 post these ideas here.

First and foremost I acknowledge that these ideas are not original nor new.

Side Chains:

Bip-R10 offers a mechanism to assign custody or transfer coins from one chain to another. However I did not find a bip that proposed a formal bitcoin side chain.

My proposal
They are officially supported, tracked and built by official bitcoin software meaning that they are not an external chain
each chain has an identifier in the block header i.e. main chain: 0, first chain: 1, second chain: 2...
the number of chains including the main chain that exists is always a power of 2, this power will also be included in the block header.
each address is assigned to a chain via chain = (address) mod (number of chains)
to be valid an addresse's next transaction will first send their coins to their chain if they are not already there
if the address they are sending to is outside their chain their transaction will be submitted to both chains and transaction fee will be split between chains
They come into being via a fork or split
every 2016 blocks (upon recalculation of difficulty) if some percentage (lets say 10%) of blocks on any chain are larger than some specified amount (lets say 750 KB) then all chains are called to increment their power value and fork on their block.
miner of chain x creates genesis block for chain x+2^previous power
upon fork, the difficulty of the old chain and the new chain will be half the next difficulty
if every chain has gone 2016 block without surpassing some amount (lets say 250 KB) at least some percentage of the time (lets say 10%) all chains will be called to join, decrement their power and double their difficulty
given miner of chain x, if x not less than 2^new power, chain will be marked dead or sleeping
miners who mine blocks on the chain that was joined (the chain with the smaller identifier) may have to make a block for the sleeping chain if transactions include funds that fully or partially originate from the sleeping chain
dead chain are revived on next split.
each block's reward outside of transaction fees will be the (current bounty / 2^fork power) except obviously for dead blocks who's reward is already included in their joined block
benefits
dynamically scales to any level of usage, no more issues about block size
miners have incentive to keep all difficulties close to parity
if miners are limited by hard drive space they don't have to mine every chain (though they should have trusted peers working on other chains to verify transactions that originate off their chains, faulty block will still be unaccepted by the rest of the miners)
though work will still grow linearly with the number of chains due to having to hash each separate header, some of the overhead may remain constant and difficulty and reward will still be balanced.
transactions are pseudo equally distributed between chains.
rewards will be more distributed (doesn't' really matter, except that its beautiful)
cons
because most transactions will be double recorded the non-volatile memory foot print of bitcoin doubles (since miners do not need all chains i believe this solution not only overcomes this cost but may decrease the foot print per miner in the long run overall)
transactions will hang in limbo until both chains have picked them up, a forever limboed transaction could result in lost coins, as long as a transaction fee has been included this risk should be mitigated.
I believe this idea is applicable to the entire community. I would like your thoughts and suggestions. I obviously think this is a freaking awesome idea. I know it is quite ambitious but it is the next step in evolution that bitcoin needs to take to be a viable competitor to visa.

I come to you to ask if this has any chance of acceptance.

-Patrick
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170925/4e6eca75/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Tue Sep 26 00:35:39 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 25 Sep 2017 20:35:39 -0400
Subject: [bitcoin-dev] idea post: bitcoin side chain implementation
In-Reply-To: <CAES+R-pHkDHSPpTcyJyEv2rSWOvAkG+zUqs8hPwbHigejyFvDw@mail.gmail.com>
References: <CAES+R-q6v=Qc2zZgczNfKhrBtZ0kCt0Um90miAMGB0npp4zAKQ@mail.gmail.com>
	<CAF5CFkheg5U0zPLSq9ow2aFZept8nGN94q894yRjiuvAY5s7Fw@mail.gmail.com>
	<CAES+R-pHkDHSPpTcyJyEv2rSWOvAkG+zUqs8hPwbHigejyFvDw@mail.gmail.com>
Message-ID: <7lMVV5tc0S5aSzZV8305yOhRd8AWufZhxToS31hmq6SGpiMC2eLZsvHYcsyj_HzFo6ip5p6CtKXRiHxxRVM3IHsCnm8qXWJT_iheDM3HYZU=@protonmail.com>

Good morning Patrick,

>Non official chains suffer from the fact that few if any miners are going to mine them so they lack security on par with the main chain.

That is why most sidechain proposals use some kind of merge mining, where a commitment to another chain's block is published on the Bitcoin chain.  Drivechain has "blind" merge mining, my recent "mainstake" proposal publishses entire sidechain block headers on the mainchain.  These techniques provide security that is nearer to mainchain security.

>And more over most
>users aren't going to use them because its not magic.

No technology is magic, so I do not understand this sentence.

>If my ultimate goal is official side chains that include part of the reward such security is at parity between all chains and that the official software
>automatically enable users to distribute their burden, would my course of action be to build an external proof-of-concept side chain of side chains?
>or do you doubt that official reward splitting chains will ever find their way into bitcoin core?

I think it would be better to term your system as "sharding" rather than "sidechain".

If and when we are able to actually agree upon some kind of sidechain-enabling proposal that is acceptable to the majority of Bitcoin Core developers, then yes, you should make a sidechain that is capable of sharding.  Sharding a distributed ledger while ensuring correct operation is a hard problem; in particular it is almost impossible to protect against double-spending unless you can see all officially-added-to-the-chain transactions.

See: https://petertodd.org/2015/why-scaling-bitcoin-with-sharding-is-very-hard

Regards,
ZmnSCPxj
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170925/79852421/attachment-0001.html>

From psharp.x13 at gmail.com  Tue Sep 26 01:15:09 2017
From: psharp.x13 at gmail.com (Patrick Sharp)
Date: Mon, 25 Sep 2017 19:15:09 -0600
Subject: [bitcoin-dev] idea post: bitcoin side chain implementation
In-Reply-To: <7lMVV5tc0S5aSzZV8305yOhRd8AWufZhxToS31hmq6SGpiMC2eLZsvHYcsyj_HzFo6ip5p6CtKXRiHxxRVM3IHsCnm8qXWJT_iheDM3HYZU=@protonmail.com>
References: <CAES+R-q6v=Qc2zZgczNfKhrBtZ0kCt0Um90miAMGB0npp4zAKQ@mail.gmail.com>
	<CAF5CFkheg5U0zPLSq9ow2aFZept8nGN94q894yRjiuvAY5s7Fw@mail.gmail.com>
	<CAES+R-pHkDHSPpTcyJyEv2rSWOvAkG+zUqs8hPwbHigejyFvDw@mail.gmail.com>
	<7lMVV5tc0S5aSzZV8305yOhRd8AWufZhxToS31hmq6SGpiMC2eLZsvHYcsyj_HzFo6ip5p6CtKXRiHxxRVM3IHsCnm8qXWJT_iheDM3HYZU=@protonmail.com>
Message-ID: <CAES+R-of6zkZi0Wx191buWBvrTzmO8LjcfJ6dJ7-a9CtwQK+bg@mail.gmail.com>

By magic I meant that that it happens all by itself without any extra
configuring.

Thank you for your responses. I have been enlightened. As ZmnSCPxj has
pointed out lightning network and pruning accomplishes everything I set out
to accomplish. And sharding is exactly what I had in mind. I will keep this
in the back of my mind and perhaps even attempt will implement it if it
still seems worth doing later.

You guys are totally awesome!!!

I here by withdraw my proposal for the time being.

-patrick

On Mon, Sep 25, 2017 at 6:35 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Patrick,
>
>
> >Non official chains suffer from the fact that few if any miners are going
> to mine them so they lack security on par with the main chain.
>
> That is why most sidechain proposals use some kind of merge mining, where
> a commitment to another chain's block is published on the Bitcoin chain.
> Drivechain has "blind" merge mining, my recent "mainstake" proposal
> publishses entire sidechain block headers on the mainchain.  These
> techniques provide security that is nearer to mainchain security.
>
> >And more over most
> >users aren't going to use them because its not magic.
>
> No technology is magic, so I do not understand this sentence.
>
> >If my ultimate goal is official side chains that include part of the
> reward such security is at parity between all chains and that the official
> software
> >automatically enable users to distribute their burden, would my course of
> action be to build an external proof-of-concept side chain of side chains?
> >or do you doubt that official reward splitting chains will ever find
> their way into bitcoin core?
>
> I think it would be better to term your system as "sharding" rather than
> "sidechain".
>
> If and when we are able to actually agree upon some kind of
> sidechain-enabling proposal that is acceptable to the majority of Bitcoin
> Core developers, then yes, you should make a sidechain that is capable of
> sharding.  Sharding a distributed ledger while ensuring correct operation
> is a hard problem; in particular it is almost impossible to protect against
> double-spending unless you can see all officially-added-to-the-chain
> transactions.
>
> See: https://petertodd.org/2015/why-scaling-bitcoin-with-
> sharding-is-very-hard
>
> Regards,
> ZmnSCPxj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170925/82ac5fc6/attachment-0001.html>

From psharp.x13 at gmail.com  Tue Sep 26 01:33:25 2017
From: psharp.x13 at gmail.com (Patrick Sharp)
Date: Mon, 25 Sep 2017 19:33:25 -0600
Subject: [bitcoin-dev] idea post: trimming and demurrage
In-Reply-To: <9Rdn-Mm90LWD4Tk_F0x04feUwKQp3nL8yTou9435kqjPCwjXWzNXsYTbWDA8YvO4p6_jBu1sFXEAa1ybvtcIrOqbv7qkghwENdHch6n_EEM=@protonmail.com>
References: <CAES+R-qpBwXdROKnXW0idierJYf7pSRe3Z=KSYvcGwB_S6nXrA@mail.gmail.com>
	<9Rdn-Mm90LWD4Tk_F0x04feUwKQp3nL8yTou9435kqjPCwjXWzNXsYTbWDA8YvO4p6_jBu1sFXEAa1ybvtcIrOqbv7qkghwENdHch6n_EEM=@protonmail.com>
Message-ID: <CAES+R-rWiyn65+HYadu+OVBuG0zDeuw+0GN404rZ233CSEFVxA@mail.gmail.com>

Thank you for your responses. I have been enlightened. For the time being
the combination of the UTXO's and pruning will accomplish what I desire. I
suspect that there will come a time when the UTXO database becomes too
large, but I guess that is a problem for another day. If that day ever
comes 10 years was just an example, like you said there are reasons to
preserve value beyond that point, perhaps a human lifetime or two would be
a better choice.

Side question: wouldn't it be a good idea to store the hash of the current
or previous UTXO's in the block header so that pruned nodes can verify
their UTXO's are accurate without having to check the full chain? and/or
maybe include a snap shot of the UTXO's every x blocks?

You guys are totally awesome!!!

I here by withdraw my proposal for the time being.

On Mon, Sep 25, 2017 at 5:34 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Patrick,
>
> Demurrage is simply impossible.
>
> In Bitcoin we already have implemented OP_CHECKLOCKTIMEVERIFY.
>
> This opcode requires that a certain block height or date has passed before
> the output can be spent.
>
> It can be used to make an "in trust for" address, where you disallow
> spending of that address.  For example, you may have a child to whom you
> wish to dedicate some inheritance to, and ensure that the child will not
> spend it recklessly until they achieve some age (when hopefully they would
> be more mature), regardless of what happens to you.
>
> If I made a P2SH address with OP_CHECKLOCKTIMEVERIFY that allows spending
> 18 years from birth of my child, and then suddenly Bitcoin Core announces
> demurrage, I would be very angry.
>
> OP_CHECKLOCKTIMEVERIFY cannot be countermanded, and it would be impossible
> to refresh the UTXO's as required by demurrage, without requiring a
> hardfork that ignores OP_CHECKLOCKTIMEVERIFY.
>
> It would be better to put such additional features as demurrage in a
> sidechain rather than on mainchain.
>
>
> Regards,
> ZmnSCPxj
>
> -------- Original Message --------
> Subject: [bitcoin-dev] idea post: trimming and demurrage
> Local Time: September 25, 2017 9:54 PM
> UTC Time: September 25, 2017 9:54 PM
> From: bitcoin-dev at lists.linuxfoundation.org
> To: bitcoin-dev at lists.linuxfoundation.org
>
> Hello Devs,
>
> I am Patrick Sharp. I just graduated with a BS is computer science.
> Forgive my ignorance.
>
> As per bip-0002 I have scoured each bip available on the wiki to see if
> these ideas have already been formally proposed and now as per bip-0002
> post these ideas here.
>
> First and foremost I acknowledge that these ideas are not original nor new.
>
> Trimming and demurrage:
>
> I am fully aware that demurrage is a prohibited change. I hereby contest.
> For the record I am not a miner, I am just aware of the economics that
> drive the costs of bitcoin.
>
> Without the ability to maintain some sort of limit on the maximum length
> or size of the block chain, block chain is not only unsustainable in the
> long run but becomes more and more centralized as the block chain becomes
> more and more unwieldy.
>
> Trimming is not a foreign concept. Old block whose transactions are now
> spent hold no real value. Meaningful trimming is expensive and inhibited by
> unspent transactions. Old unspent transactions add unnecessary and unfair
> burden.
> Old transactions take up real world space that continues incur cost while
> these transactions they do not continue to contribute to any sort of
> payment for this cost.
> One can assume that anybody with access to their bitcoins has the power to
> move these bitcoins from one address to another (or at least that the
> software that holds the keys to their coins can do it for them) and it is
> not unfair to require them to do so at least once every 5 to 10 years.
> Given the incentive to move it or lose it and software that will do it for
> them, we can assume that any bitcoin not moved is most likey therefore lost.
> moving these coins will cost a small transaction fee which is fair as
> their transactions take up space, they need to contribute
> most people who use their coins regularly will not even need to worry
> about this as their coins are moved to a change address anyway.
> one downside is that paper wallets would then have an expiration date,
> however I do not think that a paper wallet that needs to be recycled every
> 5 to 10 years is a terrible idea.
> Therefore I propose that the block chain length be limited to either 2^18
> blocks (slightly less than 5 years) or 2^19 blocks, or slightly less than
> 10 years. I propose that each time a block is mined the the oldest block(s)
> (no more than two blocks) beyond this limit is trimmed from the chain and
> that its unspent transactions are allowed to be included in the reward of
> the mined block.
>
> This keeps the block chain from tending towards infinity. This keeps the
> costs of the miners balanced with the costs of the users.
>
> Even though I believe this idea will have some friction, it is applicable
> to the entire community. It will be hard for some users to give up small
> benefits that they get at the great cost of miners, however miners run the
> game and this fair proposal is in in their best interest in two different
> ways. I would like your thoughts and suggestions. I obviously think this is
> a freaking awesome idea. I know it is quite controversial but it is the
> next step in evolution that bitcoin needs to take to ensure immortality.
>
> I come to you to ask if this has any chance of acceptance.
>
> -Patrick
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170925/fb9f8f5c/attachment-0001.html>

From vitteaymeric at gmail.com  Mon Sep 25 22:43:02 2017
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Tue, 26 Sep 2017 00:43:02 +0200
Subject: [bitcoin-dev] idea post: trimming and demurrage
In-Reply-To: <CAES+R-rWiyn65+HYadu+OVBuG0zDeuw+0GN404rZ233CSEFVxA@mail.gmail.com>
References: <CAES+R-qpBwXdROKnXW0idierJYf7pSRe3Z=KSYvcGwB_S6nXrA@mail.gmail.com>
	<9Rdn-Mm90LWD4Tk_F0x04feUwKQp3nL8yTou9435kqjPCwjXWzNXsYTbWDA8YvO4p6_jBu1sFXEAa1ybvtcIrOqbv7qkghwENdHch6n_EEM=@protonmail.com>
	<CAES+R-rWiyn65+HYadu+OVBuG0zDeuw+0GN404rZ233CSEFVxA@mail.gmail.com>
Message-ID: <883ac262-1de8-ac16-f57d-90c683da9e7d@gmail.com>

Maybe I missed or did not receive some messages, where was your
centralization concern addressed in the discussion?


Le 26/09/2017 ? 03:33, Patrick Sharp via bitcoin-dev a ?crit?:
> Thank you for your responses. I have been enlightened. For the time
> being the combination of the UTXO's and?pruning will accomplish?what I
> desire. I suspect that there will come a time when the UTXO database
> becomes too large, but I guess that is a problem for another day. If
> that day ever comes 10 years was just an example, like you said there
> are reasons to preserve value beyond that point, perhaps a human
> lifetime or two would be a better choice.
>
> Side question: wouldn't it be a good idea to store the hash of the
> current or previous UTXO's in the block header so that pruned nodes
> can verify their UTXO's are accurate without having to check the full
> chain? and/or maybe include a snap shot of the UTXO's every x blocks?
>
> You guys are totally awesome!!!
>
> I here by withdraw my proposal for the time being.
>
> On Mon, Sep 25, 2017 at 5:34 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com
> <mailto:ZmnSCPxj at protonmail.com>> wrote:
>
>     Good morning Patrick,
>
>     Demurrage is simply impossible.
>
>     In Bitcoin we already have implemented OP_CHECKLOCKTIMEVERIFY.
>
>     This opcode requires that a certain block height or date has
>     passed before the output can be spent.
>
>     It can be used to make an "in trust for" address, where you
>     disallow spending of that address.? For example, you may have a
>     child to whom you wish to dedicate some inheritance to, and ensure
>     that the child will not spend it recklessly until they achieve
>     some age (when hopefully they would be more mature), regardless of
>     what happens to you.
>
>     If I made a P2SH address with OP_CHECKLOCKTIMEVERIFY that allows
>     spending 18 years from birth of my child, and then suddenly
>     Bitcoin Core announces demurrage, I would be very angry.
>
>     OP_CHECKLOCKTIMEVERIFY cannot be countermanded, and it would be
>     impossible to refresh the UTXO's as required by demurrage, without
>     requiring a hardfork that ignores OP_CHECKLOCKTIMEVERIFY.
>
>     It would be better to put such additional features as demurrage in
>     a sidechain rather than on mainchain.
>
>
>     Regards,
>     ZmnSCPxj
>
>     -------- Original Message --------
>     Subject: [bitcoin-dev] idea post: trimming and demurrage
>     Local Time: September 25, 2017 9:54 PM
>     UTC Time: September 25, 2017 9:54 PM
>     From: bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>     To: bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>
>     Hello Devs,
>
>     I am Patrick Sharp. I just graduated with a BS is computer
>     science. Forgive my ignorance.
>
>     As per bip-0002 I have scoured each bip available on the wiki to
>     see if these ideas have already been formally proposed and now as
>     per bip-0002 post these ideas here.
>
>     First and foremost I acknowledge that these ideas are not original
>     nor new.
>
>     Trimming and demurrage:
>
>     I am fully aware that demurrage is a prohibited change. I hereby
>     contest. For the record I am not a miner, I am just aware of the
>     economics that drive the costs of bitcoin.
>
>     Without the ability to maintain some sort of limit on the maximum
>     length or size of the block chain, block chain is not only
>     unsustainable in the long run but becomes more and more
>     centralized as the block chain becomes more and more unwieldy.
>
>     Trimming is not a foreign concept. Old block whose transactions
>     are now spent hold no real value. Meaningful trimming is expensive
>     and inhibited by unspent transactions. Old unspent transactions
>     add unnecessary and unfair burden.
>     Old transactions take up real world space that continues incur
>     cost while these transactions they do not continue to contribute
>     to any sort of payment for this cost.
>     One can assume that anybody with access to their bitcoins has the
>     power to move these bitcoins from one address to another (or at
>     least that the software that holds the keys to their coins can do
>     it for them) and it is not unfair to require them to do so at
>     least once every 5 to 10 years.
>     Given the incentive to move it or lose it and software that will
>     do it for them, we can assume that any bitcoin not moved is most
>     likey therefore lost.
>     moving these coins will cost a small transaction fee which is fair
>     as their transactions take up space, they need to contribute
>     most people who use their coins regularly will not even need to
>     worry about this as their coins are moved to a change address anyway.
>     one downside is that paper wallets would then have an expiration
>     date, however I do not think that a paper wallet that needs to be
>     recycled every 5 to 10 years is a terrible idea.
>     Therefore I propose that the block chain length be limited to
>     either 2^18 blocks (slightly less than 5 years) or 2^19 blocks, or
>     slightly less than 10 years. I propose that each time a block is
>     mined the the oldest block(s) (no more than two blocks) beyond
>     this limit is trimmed from the chain and that its unspent
>     transactions are allowed to be included in the reward of the mined
>     block.
>
>     This keeps the block chain from tending towards infinity. This
>     keeps the costs of the miners balanced with the costs of the users.
>
>     Even though?I believe this idea will have some friction, it is
>     applicable to the entire community. It will be hard for some users
>     to give up small benefits that they get at the great cost of
>     miners, however miners run the game and this fair proposal is in
>     in their best interest in two different ways. I would like your
>     thoughts and suggestions. I obviously think this is a freaking
>     awesome idea. I know it is quite controversial?but it is the next
>     step in evolution that bitcoin needs to take to ensure immortality.
>
>     I come to you to ask if this has any chance of acceptance.
>
>     -Patrick
>
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170926/9fbdd815/attachment.html>

From ZmnSCPxj at protonmail.com  Tue Sep 26 07:50:42 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 26 Sep 2017 03:50:42 -0400
Subject: [bitcoin-dev] idea post: trimming and demurrage
In-Reply-To: <CAES+R-rWiyn65+HYadu+OVBuG0zDeuw+0GN404rZ233CSEFVxA@mail.gmail.com>
References: <CAES+R-qpBwXdROKnXW0idierJYf7pSRe3Z=KSYvcGwB_S6nXrA@mail.gmail.com>
	<9Rdn-Mm90LWD4Tk_F0x04feUwKQp3nL8yTou9435kqjPCwjXWzNXsYTbWDA8YvO4p6_jBu1sFXEAa1ybvtcIrOqbv7qkghwENdHch6n_EEM=@protonmail.com>
	<CAES+R-rWiyn65+HYadu+OVBuG0zDeuw+0GN404rZ233CSEFVxA@mail.gmail.com>
Message-ID: <357s0oMtjEWukjKUHnT_Zb1_WiyH5lZBGirA_1cbNzVh51UtOBQwsbuladzdK776FBnqTbdHrJT-1EpjVXgRcCiF7O3-yAnI5J3_pAHMVFU=@protonmail.com>

Good morning,

This is called "UTXO Set Commitments".

Pieter Wuille I think had concrete proposals for the cryptographic primitive to use. Try searching "Rolling UTXO Set Commitments".

Regards,
ZmnSCPxj

Sent with [ProtonMail](https://protonmail.com) Secure Email.

> -------- Original Message --------
> Subject: Re: [bitcoin-dev] idea post: trimming and demurrage
> Local Time: September 26, 2017 9:33 AM
> UTC Time: September 26, 2017 1:33 AM
> From: psharp.x13 at gmail.com
> To: ZmnSCPxj <ZmnSCPxj at protonmail.com>
> bitcoin-dev at lists.linuxfoundation.org <bitcoin-dev at lists.linuxfoundation.org>
>
> Thank you for your responses. I have been enlightened. For the time being the combination of the UTXO's and pruning will accomplish what I desire. I suspect that there will come a time when the UTXO database becomes too large, but I guess that is a problem for another day. If that day ever comes 10 years was just an example, like you said there are reasons to preserve value beyond that point, perhaps a human lifetime or two would be a better choice.
>
> Side question: wouldn't it be a good idea to store the hash of the current or previous UTXO's in the block header so that pruned nodes can verify their UTXO's are accurate without having to check the full chain? and/or maybe include a snap shot of the UTXO's every x blocks?
>
> You guys are totally awesome!!!
>
> I here by withdraw my proposal for the time being.
>
> On Mon, Sep 25, 2017 at 5:34 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>
>> Good morning Patrick,
>>
>> Demurrage is simply impossible.
>>
>> In Bitcoin we already have implemented OP_CHECKLOCKTIMEVERIFY.
>>
>> This opcode requires that a certain block height or date has passed before the output can be spent.
>>
>> It can be used to make an "in trust for" address, where you disallow spending of that address.  For example, you may have a child to whom you wish to dedicate some inheritance to, and ensure that the child will not spend it recklessly until they achieve some age (when hopefully they would be more mature), regardless of what happens to you.
>>
>> If I made a P2SH address with OP_CHECKLOCKTIMEVERIFY that allows spending 18 years from birth of my child, and then suddenly Bitcoin Core announces demurrage, I would be very angry.
>>
>> OP_CHECKLOCKTIMEVERIFY cannot be countermanded, and it would be impossible to refresh the UTXO's as required by demurrage, without requiring a hardfork that ignores OP_CHECKLOCKTIMEVERIFY.
>>
>> It would be better to put such additional features as demurrage in a sidechain rather than on mainchain.
>>
>> Regards,
>> ZmnSCPxj
>>
>> -------- Original Message --------
>> Subject: [bitcoin-dev] idea post: trimming and demurrage
>> Local Time: September 25, 2017 9:54 PM
>> UTC Time: September 25, 2017 9:54 PM
>> From: bitcoin-dev at lists.linuxfoundation.org
>> To: bitcoin-dev at lists.linuxfoundation.org
>>
>> Hello Devs,
>>
>> I am Patrick Sharp. I just graduated with a BS is computer science. Forgive my ignorance.
>>
>> As per bip-0002 I have scoured each bip available on the wiki to see if these ideas have already been formally proposed and now as per bip-0002 post these ideas here.
>>
>> First and foremost I acknowledge that these ideas are not original nor new.
>>
>> Trimming and demurrage:
>>
>> I am fully aware that demurrage is a prohibited change. I hereby contest. For the record I am not a miner, I am just aware of the economics that drive the costs of bitcoin.
>>
>> Without the ability to maintain some sort of limit on the maximum length or size of the block chain, block chain is not only unsustainable in the long run but becomes more and more centralized as the block chain becomes more and more unwieldy.
>>
>> Trimming is not a foreign concept. Old block whose transactions are now spent hold no real value. Meaningful trimming is expensive and inhibited by unspent transactions. Old unspent transactions add unnecessary and unfair burden.
>> Old transactions take up real world space that continues incur cost while these transactions they do not continue to contribute to any sort of payment for this cost.
>> One can assume that anybody with access to their bitcoins has the power to move these bitcoins from one address to another (or at least that the software that holds the keys to their coins can do it for them) and it is not unfair to require them to do so at least once every 5 to 10 years.
>> Given the incentive to move it or lose it and software that will do it for them, we can assume that any bitcoin not moved is most likey therefore lost.
>> moving these coins will cost a small transaction fee which is fair as their transactions take up space, they need to contribute
>> most people who use their coins regularly will not even need to worry about this as their coins are moved to a change address anyway.
>> one downside is that paper wallets would then have an expiration date, however I do not think that a paper wallet that needs to be recycled every 5 to 10 years is a terrible idea.
>> Therefore I propose that the block chain length be limited to either 2^18 blocks (slightly less than 5 years) or 2^19 blocks, or slightly less than 10 years. I propose that each time a block is mined the the oldest block(s) (no more than two blocks) beyond this limit is trimmed from the chain and that its unspent transactions are allowed to be included in the reward of the mined block.
>>
>> This keeps the block chain from tending towards infinity. This keeps the costs of the miners balanced with the costs of the users.
>>
>> Even though I believe this idea will have some friction, it is applicable to the entire community. It will be hard for some users to give up small benefits that they get at the great cost of miners, however miners run the game and this fair proposal is in in their best interest in two different ways. I would like your thoughts and suggestions. I obviously think this is a freaking awesome idea. I know it is quite controversial but it is the next step in evolution that bitcoin needs to take to ensure immortality.
>>
>> I come to you to ask if this has any chance of acceptance.
>>
>> -Patrick
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170926/db2421ff/attachment-0001.html>

From Mark.Radcliffe at dlapiper.com  Mon Sep 25 21:53:40 2017
From: Mark.Radcliffe at dlapiper.com (Radcliffe, Mark)
Date: Mon, 25 Sep 2017 21:53:40 +0000
Subject: [bitcoin-dev] Bitcoin Assistance
Message-ID: <E682AA2FC88ADD4589420BFC6BE3A92141FC460F@SANDMBX01v.piper.root.local>

My apologies if this post has been answered, but I am new to the list. I am lawyer trying to understand the licensing of the Bitcoin core and I  will be presenting in a webinar with Black Duck Software on Blockchain on September 28  (in case you are not familiar with them, Black Duck Software assists companies in managing their open source software resources). They have scanned the Bitcoin Core code for the open source licenses used in the codebase.  I am enclosing a summary of the findings. I would be interested in communicating with the individuals who manage this codebase and can provide insight about the project manages contributions because the codebase includes projects with inconsistent licenses (for example, code licensed under the Apache Software License version  2 and GPLv2 cannot work together in some situations). Thanks in advance.

According to the scan, the code base includes code licensed under the following licenses:


Apache License 2.0

Boost Software License 1.0

BSD 2-clause "Simplified" License

BSD 3-clause "New" or "Revised" License

Creative Commons Attribution Share Alike 3.0

Expat License

GNU General Public License v2.0 or later

GNU General Public License v3.0 or later

GNU Lesser General Public License v2.1 or later

License for A fast alternative to the modulo reduction

License for atomic by Timm Kosse

MIT License

Public Domain

University of Illinois/NCSA Open Source License






Mark Radcliffe
Partner

T +1 650.833.2266
F +1 650.687.1222
M +1 650.521.5039
E mark.radcliffe at dlapiper.com <mailto:mark.radcliffe at dlapiper.com>

[DLA Piper Logo]

DLA Piper LLP (US)
2000 University Avenue
East Palo Alto, California 94303-2215
United States
www.dlapiper.com <http://www.dlapiper.com>

Please consider the environment before printing this email.

The information contained in this email may be confidential and/or legally privileged. It has been sent for the sole use of the intended recipient(s). If the reader of this message is not an intended recipient, you are hereby notified that any unauthorized review, use, disclosure, dissemination, distribution, or copying of this communication, or any of its contents, is strictly prohibited. If you have received this communication in error, please reply to the sender and destroy all copies of the message. To contact us directly, send to postmaster at dlapiper.com. Thank you.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170925/85b1cd96/attachment.html>

From alex.mutovkin at gmail.com  Tue Sep 26 07:10:43 2017
From: alex.mutovkin at gmail.com (=?UTF-8?B?0JDQu9C10LrRgdC10Lkg0JzRg9GC0L7QstC60LjQvQ==?=)
Date: Tue, 26 Sep 2017 10:10:43 +0300
Subject: [bitcoin-dev] idea post: trimming and demurrage
In-Reply-To: <CAES+R-rWiyn65+HYadu+OVBuG0zDeuw+0GN404rZ233CSEFVxA@mail.gmail.com>
References: <CAES+R-qpBwXdROKnXW0idierJYf7pSRe3Z=KSYvcGwB_S6nXrA@mail.gmail.com>
	<9Rdn-Mm90LWD4Tk_F0x04feUwKQp3nL8yTou9435kqjPCwjXWzNXsYTbWDA8YvO4p6_jBu1sFXEAa1ybvtcIrOqbv7qkghwENdHch6n_EEM=@protonmail.com>
	<CAES+R-rWiyn65+HYadu+OVBuG0zDeuw+0GN404rZ233CSEFVxA@mail.gmail.com>
Message-ID: <CAEadUTLeg69Cz-tkfcYk6B_Fn=J+vdL0sFB4hW8iD+k98Z=FJg@mail.gmail.com>

Lets call it blocktrain instead of blockchain. Because it is fixed amount
of blocks moving forward on the time axis. Oldest blocks are detached from
the tail of that blockTrain and goes to depot.

2017-09-26 4:33 GMT+03:00 Patrick Sharp via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org>:

> Thank you for your responses. I have been enlightened. For the time being
> the combination of the UTXO's and pruning will accomplish what I desire. I
> suspect that there will come a time when the UTXO database becomes too
> large, but I guess that is a problem for another day. If that day ever
> comes 10 years was just an example, like you said there are reasons to
> preserve value beyond that point, perhaps a human lifetime or two would be
> a better choice.
>
> Side question: wouldn't it be a good idea to store the hash of the current
> or previous UTXO's in the block header so that pruned nodes can verify
> their UTXO's are accurate without having to check the full chain? and/or
> maybe include a snap shot of the UTXO's every x blocks?
>
> You guys are totally awesome!!!
>
> I here by withdraw my proposal for the time being.
>
> On Mon, Sep 25, 2017 at 5:34 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>
>> Good morning Patrick,
>>
>> Demurrage is simply impossible.
>>
>> In Bitcoin we already have implemented OP_CHECKLOCKTIMEVERIFY.
>>
>> This opcode requires that a certain block height or date has passed
>> before the output can be spent.
>>
>> It can be used to make an "in trust for" address, where you disallow
>> spending of that address.  For example, you may have a child to whom you
>> wish to dedicate some inheritance to, and ensure that the child will not
>> spend it recklessly until they achieve some age (when hopefully they would
>> be more mature), regardless of what happens to you.
>>
>> If I made a P2SH address with OP_CHECKLOCKTIMEVERIFY that allows spending
>> 18 years from birth of my child, and then suddenly Bitcoin Core announces
>> demurrage, I would be very angry.
>>
>> OP_CHECKLOCKTIMEVERIFY cannot be countermanded, and it would be
>> impossible to refresh the UTXO's as required by demurrage, without
>> requiring a hardfork that ignores OP_CHECKLOCKTIMEVERIFY.
>>
>> It would be better to put such additional features as demurrage in a
>> sidechain rather than on mainchain.
>>
>>
>> Regards,
>> ZmnSCPxj
>>
>> -------- Original Message --------
>> Subject: [bitcoin-dev] idea post: trimming and demurrage
>> Local Time: September 25, 2017 9:54 PM
>> UTC Time: September 25, 2017 9:54 PM
>> From: bitcoin-dev at lists.linuxfoundation.org
>> To: bitcoin-dev at lists.linuxfoundation.org
>>
>> Hello Devs,
>>
>> I am Patrick Sharp. I just graduated with a BS is computer science.
>> Forgive my ignorance.
>>
>> As per bip-0002 I have scoured each bip available on the wiki to see if
>> these ideas have already been formally proposed and now as per bip-0002
>> post these ideas here.
>>
>> First and foremost I acknowledge that these ideas are not original nor
>> new.
>>
>> Trimming and demurrage:
>>
>> I am fully aware that demurrage is a prohibited change. I hereby contest.
>> For the record I am not a miner, I am just aware of the economics that
>> drive the costs of bitcoin.
>>
>> Without the ability to maintain some sort of limit on the maximum length
>> or size of the block chain, block chain is not only unsustainable in the
>> long run but becomes more and more centralized as the block chain becomes
>> more and more unwieldy.
>>
>> Trimming is not a foreign concept. Old block whose transactions are now
>> spent hold no real value. Meaningful trimming is expensive and inhibited by
>> unspent transactions. Old unspent transactions add unnecessary and unfair
>> burden.
>> Old transactions take up real world space that continues incur cost while
>> these transactions they do not continue to contribute to any sort of
>> payment for this cost.
>> One can assume that anybody with access to their bitcoins has the power
>> to move these bitcoins from one address to another (or at least that the
>> software that holds the keys to their coins can do it for them) and it is
>> not unfair to require them to do so at least once every 5 to 10 years.
>> Given the incentive to move it or lose it and software that will do it
>> for them, we can assume that any bitcoin not moved is most likey therefore
>> lost.
>> moving these coins will cost a small transaction fee which is fair as
>> their transactions take up space, they need to contribute
>> most people who use their coins regularly will not even need to worry
>> about this as their coins are moved to a change address anyway.
>> one downside is that paper wallets would then have an expiration date,
>> however I do not think that a paper wallet that needs to be recycled every
>> 5 to 10 years is a terrible idea.
>> Therefore I propose that the block chain length be limited to either 2^18
>> blocks (slightly less than 5 years) or 2^19 blocks, or slightly less than
>> 10 years. I propose that each time a block is mined the the oldest block(s)
>> (no more than two blocks) beyond this limit is trimmed from the chain and
>> that its unspent transactions are allowed to be included in the reward of
>> the mined block.
>>
>> This keeps the block chain from tending towards infinity. This keeps the
>> costs of the miners balanced with the costs of the users.
>>
>> Even though I believe this idea will have some friction, it is applicable
>> to the entire community. It will be hard for some users to give up small
>> benefits that they get at the great cost of miners, however miners run the
>> game and this fair proposal is in in their best interest in two different
>> ways. I would like your thoughts and suggestions. I obviously think this is
>> a freaking awesome idea. I know it is quite controversial but it is the
>> next step in evolution that bitcoin needs to take to ensure immortality.
>>
>> I come to you to ask if this has any chance of acceptance.
>>
>> -Patrick
>>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170926/dd090ecd/attachment-0001.html>

From omarshib at gmail.com  Tue Sep 26 13:12:48 2017
From: omarshib at gmail.com (Omar Shibli)
Date: Tue, 26 Sep 2017 16:12:48 +0300
Subject: [bitcoin-dev] Bitcoin Assistance
In-Reply-To: <E682AA2FC88ADD4589420BFC6BE3A92141FC460F@SANDMBX01v.piper.root.local>
References: <E682AA2FC88ADD4589420BFC6BE3A92141FC460F@SANDMBX01v.piper.root.local>
Message-ID: <CAE3EOfjD5aW05DTOF1yC3R3Jf4w4m+kajT8rs4faH-n+WZpuog@mail.gmail.com>

According to my understanding, Bitcoin protocol is a combination of several
components (node, miner, wallet..), you can use different licenses for
different components, as long as the components are well structured and
inter APIs are well defined and encapsulated, therefore, incompatible
licenses could be not an issue.
Please note that I'm not legal advisor and this is just my personal opinion.

On Tue, Sep 26, 2017 at 12:53 AM, Radcliffe, Mark via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> My apologies if this post has been answered, but I am new to the list. I
> am lawyer trying to understand the licensing of the Bitcoin core and I
>  will be presenting in a webinar with Black Duck Software on Blockchain on
> September 28  (in case you are not familiar with them, Black Duck Software
> assists companies in managing their open source software resources). They
> have scanned the Bitcoin Core code for the open source licenses used in the
> codebase.  I am enclosing a summary of the findings. I would be interested
> in communicating with the individuals who manage this codebase and can
> provide insight about the project manages contributions because the
> codebase includes projects with inconsistent licenses (for example, code
> licensed under the Apache Software License version  2 and GPLv2 cannot work
> together in some situations). Thanks in advance.
>
>
>
> According to the scan, the code base includes code licensed under the
> following licenses:
>
>
>
> Apache License 2.0
>
> Boost Software License 1.0
>
> BSD 2-clause "Simplified" License
>
> BSD 3-clause "New" or "Revised" License
>
> Creative Commons Attribution Share Alike 3.0
>
> Expat License
>
> GNU General Public License v2.0 or later
>
> GNU General Public License v3.0 or later
>
> GNU Lesser General Public License v2.1 or later
>
> License for A fast alternative to the modulo reduction
>
> License for atomic by Timm Kosse
>
> MIT License
>
> Public Domain
>
> University of Illinois/NCSA Open Source License
>
>
>
>
>
>
>
>
>
> *Mark Radcliffe*
> Partner
>
>
> *T* +1 650.833.2266 <(650)%20833-2266>
> *F* +1 650.687.1222 <(650)%20687-1222>
> *M* +1 650.521.5039 <(650)%20521-5039>
> *E* mark.radcliffe at dlapiper.com
>
>
>
> [image: DLA Piper Logo]
>
>
>
> DLA Piper LLP (US)
> 2000 University Avenue
> East Palo Alto, California 94303-2215
> United States
> www.dlapiper.com
>
>
> Please consider the environment before printing this email.
>
> The information contained in this email may be confidential and/or legally
> privileged. It has been sent for the sole use of the intended recipient(s).
> If the reader of this message is not an intended recipient, you are hereby
> notified that any unauthorized review, use, disclosure, dissemination,
> distribution, or copying of this communication, or any of its contents, is
> strictly prohibited. If you have received this communication in error,
> please reply to the sender and destroy all copies of the message. To
> contact us directly, send to postmaster at dlapiper.com. Thank you.
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170926/a58cc0c2/attachment.html>

From chris at suredbits.com  Tue Sep 26 17:51:50 2017
From: chris at suredbits.com (Chris Stewart)
Date: Tue, 26 Sep 2017 12:51:50 -0500
Subject: [bitcoin-dev] Sidechains: Mainstake
In-Reply-To: <rRLvSIAs4ZyW4YTai9d_ON_xV2HH6NlhRIsU2C9mzTKiGuXmtJjafTtmK9lJIgBYVNVRGcfKAWON_l2ZE9bKuqON11NXGoKKn1SOGXi8Dbs=@protonmail.com>
References: <rRLvSIAs4ZyW4YTai9d_ON_xV2HH6NlhRIsU2C9mzTKiGuXmtJjafTtmK9lJIgBYVNVRGcfKAWON_l2ZE9bKuqON11NXGoKKn1SOGXi8Dbs=@protonmail.com>
Message-ID: <CAGL6+mEXEzrWK0w58tXEzHWvMQLdUJVEcJ5wBiFO0ye0yrKaig@mail.gmail.com>

>For each sidechain ID, for each mainchain block, at most one sidechain
block header may be published. In addition, the sidechain block header
published on the mainchain blocks may only be published by the stake
lottery winner from the end of the previous block.

What happens if the stake winner disappears? It seems, in your scheme, that
this would cause progress to come to a screeching halt.

Our weak mitigation against a mainchain miner >50% attack is weakened
> further; now the mainchain miner with 51% hashpower need only block the
> creation of sidechain mainstake UTXOs except its own, and eventually the
> other mainstake UTXOs will time out and the miner can outright steal
> costlessly


Can we not nest mainstake outputs in p2wsh/p2sh scripts to mitigate this?
This means that they cannot block the creation of mainstake utxos -- but I
guess they would still be able to block the spends of this utxo.

Another thing that is problematic with using a p2sh output is 'relocking'
the stake. Unfortunately if the p2sh script hash's aren't identical I don't
think we can guarantee they didn't spend the stake to a non stake output.
If the script hash's *are* identical then the miner can censor the
transaction that re-locks the output.

Perhaps there is a hybrid that would work, however it depends on what you
mean by 'creation'. If it is just the *initial* creation of the utxo -- and
not subsequent OP_STAKEVERIFY change outputs -- I think this strategy might
work. You just won't be able to participate in the lottery while the utxo
is nested inside the p2sh output initially.

This also brings back the problem above -- what if a stake winner
disappears -- or a miners creates the illusion they disappeared via
censorship? I guess a miner would be losing out on transaction fees.

-Chris



On Fri, Sep 22, 2017 at 8:49 PM, ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Good morning bitcoin-dev,
>
> I have yet another sidechain proposal: https://zmnscpxj.github.io/
> sidechain/mainstake/index.html
>
> I make the below outlandish claims in the above link:
>
> 1. While a 51% mainchain miner theft is still possible, it will take even
> longer than in drivechains (either months of broadcasting intent to steal
> before the theft, or locking funds that are likely to remain locked after a
> week-long theft).
> 2. A 26% anti-sidechain miner cannot completely block all sidechain
> withdrawals as they could in drivechains.
> 3. Outside of attacks and censorship, the economic majority controls
> sidechains, without going through miners as "representatives of the
> economic majority".
> 4. With sufficient cleverness (stupidity?), proof-of-stake can be made to
> work.
>
> I hope for your consideration.  I suspect that I have not thought things
> out completely, and probably missed some significant flaw.
>
> Regards,
> ZmnSCPxj
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170926/ceeacc15/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Tue Sep 26 22:38:59 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 26 Sep 2017 18:38:59 -0400
Subject: [bitcoin-dev] Sidechains: Mainstake
In-Reply-To: <CAGL6+mEXEzrWK0w58tXEzHWvMQLdUJVEcJ5wBiFO0ye0yrKaig@mail.gmail.com>
References: <rRLvSIAs4ZyW4YTai9d_ON_xV2HH6NlhRIsU2C9mzTKiGuXmtJjafTtmK9lJIgBYVNVRGcfKAWON_l2ZE9bKuqON11NXGoKKn1SOGXi8Dbs=@protonmail.com>
	<CAGL6+mEXEzrWK0w58tXEzHWvMQLdUJVEcJ5wBiFO0ye0yrKaig@mail.gmail.com>
Message-ID: <XcdjnX4QElnhSZmxpbKIol_Purbp8BUaX4wpZhoHDCKh7PBgwGgba2zy9KUkjlbLQ7fXotLsoXnLz5cg-39C0T2sx65UPGnMWf0B__r1do0=@protonmail.com>

Good morning,

>>For each sidechain ID, for each mainchain block, at most one sidechain block header may be published. In addition, the sidechain block header
>published on the mainchain blocks may only be published by the stake lottery winner from the end of the previous block.
>
>What happens if the stake winner disappears? It seems, in your scheme, that this would cause progress to come to a screeching halt.

The stake winner is only valid for a specific mainchain block.  If the stake winner is unable to publish a sidechain header on that mainchain block, then the mainchain block contains no sidechain header.  On the next mainchain block, a new stake winner is selected based on the mainchain block header hash of the mainchain block containing no sidechain header, hopefully that will be a different mainstaker.  So the stake winner will only slow down the sidechain temporarily.

Basically, the time to the next mainchain block is the "timeout" that the stake winner has to publish its sidechain header.  If we assume that mainchain will operate continuously (because a massive lack of mainchain activity would imply the death of the mainchain anyway) then the sidechain only gets slowed down (no block) if the stake winner does not respond.  Presumably this will not happen if the sidechain has pending transactions, as the stake winner would "lose its winning ticket" if it was unable to respond in a timely manner and lose its opportunity to earn sidechain transaction fees.

If the stake winner has lost keys completely, then the stake has a lock time and after the lock time the stake will no longer be part of the stake lottery, so while it would slow down the sidechain until the lock time, after the lock time it will no longer have an effect.

A passive attack, where a mainstaker just stakes and resets the stake when its lock time arrives, but does not publish any sidechain headers, will slow down the sidechain, but the mainstaker could have been earning sidechain fees if it were participating honestly instead, so the passive mainstaker suffers opportunity cost.

>>Our weak mitigation against a mainchain miner >50% attack is weakened further; now the mainchain miner with 51% hashpower need only block the
>creation of sidechain mainstake UTXOs except its own, and eventually the other mainstake UTXOs will time out and the miner can outright steal
>costlessly
>
>Can we not nest mainstake outputs in p2wsh/p2sh scripts to mitigate this? This means that they cannot block the creation of mainstake utxos -- but I
>guess they would still be able to block the spends of this utxo.

The lottery needs to be executable by the mainchain fullnodes.  Thus the mainchain fullnodes need to be aware of which UTXOs are to be put in the lottery, not just the sidechain fullnodes.  This is why I use scriptPubKey, rather than P2SH redeemScript.  However, this does allow mainchain miners to be aware of which UTXOs are mainstakes also, and allows them to censor these transactions.

>Another thing that is problematic with using a p2sh output is 'relocking' the stake. Unfortunately if the p2sh script hash's aren't identical I don't think we
>can guarantee they didn't spend the stake to a non stake output. If the script hash's *are* identical then the miner can censor the transaction that
>re-locks the output.
>
>Perhaps there is a hybrid that would work, however it depends on what you mean by 'creation'. If it is just the *initial* creation of the utxo -- and not
>subsequent OP_STAKEVERIFY change outputs -- I think this strategy might work. You just won't be able to participate in the lottery while the utxo is
>nested inside the p2sh output initially.

Yes, it prevents the lottery from including the UTXO.  As it is not in the lottery, it cannot be a stake winner and cannot publish a sidechain block header until the lock time, when it can now publish openly that it is a stake UTXO using scriptPubKey.  This makes OP_STAKEVERIFY work almost as much as OP_CHECKLOCKTIMEVERIFY when inside a redeemScript.

>This also brings back the problem above -- what if a stake winner disappears -- or a miners creates the illusion they disappeared via censorship? I
>guess a miner would be losing out on transaction fees.

Yes, although the mainchain transaction fees from publishing sidechain block headers will only be marginally higher than the prevailing fee rate of the block.  For a particular block, the stake winner has a monopoly (it is the only one allowed to publish a sidechain header for that block) and does not need to bid with other mainstakers, and can bid the minimum necessary just to get into the mainchain block.

Regards,
ZmnSCPxj
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170926/6965d03b/attachment.html>

From pete at petertodd.org  Wed Sep 27 16:06:54 2017
From: pete at petertodd.org (Peter Todd)
Date: Wed, 27 Sep 2017 12:06:54 -0400
Subject: [bitcoin-dev] Address expiration times should be added to BIP-173
Message-ID: <20170927160654.GA12492@savin.petertodd.org>

Re-use of old addresses is a major problem, not only for privacy, but also
operationally: services like exchanges frequently have problems with users
sending funds to addresses whose private keys have been lost or stolen; there
are multiple examples of exchanges getting hacked, with users continuing to
lose funds well after the actual hack has occured due to continuing deposits.
This also makes it difficult operationally to rotate private keys. I personally
have even lost funds in the past due to people sending me BTC to addresses that
I gave them long ago for different reasons, rather than asking me for fresh
one.

To help combat this problem, I suggest that we add a UI-level expiration time
to the new BIP173 address format. Wallets would be expected to consider
addresses as invalid as a destination for funds after the expiration time is
reached.

Unfortunately, this proposal inevitably will raise a lot of UI and terminology
questions. Notably, the entire notion of addresses is flawed from a user point
of view: their experience with them should be more like "payment codes", with a
code being valid for payment for a short period of time; wallets should not be
displaying addresses as actually associated with specific funds. I suspect
we'll see users thinking that an expired address risks the funds themselves;
some thought needs to be put into terminology.

Being just an expiration time, seconds-level resolution is unnecessary, and
may give the wrong impression. I'd suggest either:

1) Hour resolution - 2^24 hours = 1914 years
2) Month resolution - 2^16 months = 5458 years

Both options have the advantage of working well at the UI level regardless of
timezone: the former is sufficiently short that UI's can simply display an
"exact" time (though note different leap second interpretations), while the
latter is long enough that rounding off to the nearest day in the local
timezone is fine.

Supporting hour-level (or just seconds) precision has the advantage of making
it easy for services like exchanges to use addresses with relatively short
validity periods, to reduce the risks of losses after a hack. Also, using at
least hour-level ensures we don't have any year 2038 problems.

Thoughts?

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/7f7c4bfb/attachment.sig>

From cryptaxe at gmail.com  Wed Sep 27 18:15:20 2017
From: cryptaxe at gmail.com (CryptAxe)
Date: Wed, 27 Sep 2017 11:15:20 -0700
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <20170927160654.GA12492@savin.petertodd.org>
References: <20170927160654.GA12492@savin.petertodd.org>
Message-ID: <f7ee0056-5fd3-e72a-9f9a-776c0f877ab1@gmail.com>

I think we need something like this. Hour resolution seems like the
correct choice to me.

Please someone steal whatever code you can from this PR when
implementing the UI for BIP173 expiration:

https://github.com/bitcoin/bitcoin/pull/9722

I have a rebased version as well if anyone wants it.


On 09/27/2017 09:06 AM, Peter Todd via bitcoin-dev wrote:
> Re-use of old addresses is a major problem, not only for privacy, but also
> operationally: services like exchanges frequently have problems with users
> sending funds to addresses whose private keys have been lost or stolen; there
> are multiple examples of exchanges getting hacked, with users continuing to
> lose funds well after the actual hack has occured due to continuing deposits.
> This also makes it difficult operationally to rotate private keys. I personally
> have even lost funds in the past due to people sending me BTC to addresses that
> I gave them long ago for different reasons, rather than asking me for fresh
> one.
>
> To help combat this problem, I suggest that we add a UI-level expiration time
> to the new BIP173 address format. Wallets would be expected to consider
> addresses as invalid as a destination for funds after the expiration time is
> reached.
>
> Unfortunately, this proposal inevitably will raise a lot of UI and terminology
> questions. Notably, the entire notion of addresses is flawed from a user point
> of view: their experience with them should be more like "payment codes", with a
> code being valid for payment for a short period of time; wallets should not be
> displaying addresses as actually associated with specific funds. I suspect
> we'll see users thinking that an expired address risks the funds themselves;
> some thought needs to be put into terminology.
>
> Being just an expiration time, seconds-level resolution is unnecessary, and
> may give the wrong impression. I'd suggest either:
>
> 1) Hour resolution - 2^24 hours = 1914 years
> 2) Month resolution - 2^16 months = 5458 years
>
> Both options have the advantage of working well at the UI level regardless of
> timezone: the former is sufficiently short that UI's can simply display an
> "exact" time (though note different leap second interpretations), while the
> latter is long enough that rounding off to the nearest day in the local
> timezone is fine.
>
> Supporting hour-level (or just seconds) precision has the advantage of making
> it easy for services like exchanges to use addresses with relatively short
> validity periods, to reduce the risks of losses after a hack. Also, using at
> least hour-level ensures we don't have any year 2038 problems.
>
> Thoughts?
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/e671823a/attachment-0001.html>

From luke at dashjr.org  Wed Sep 27 18:56:26 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Wed, 27 Sep 2017 18:56:26 +0000
Subject: [bitcoin-dev] Revising BIP 2 to expand editorial authority
Message-ID: <201709271856.27376.luke@dashjr.org>

Many pull requests to the BIPs repository are spelling corrections or similar, 
which are obvious to merge. Currently, the BIP process requires the Author of 
the affected BIPs to ACK any changes, which seems inefficient and unnecessary 
for these kind of editorial fixes.

What do people think about modifying BIP 2 to allow editors to merge these 
kinds of changes without involving the Authors? Strictly speaking, BIP 2 
shouldn't be changed now that it is Active, but for such a minor revision, I 
think an exception is reasonable.

I've prepared a draft PR for BIP 2 here:
    https://github.com/bitcoin/bips/pull/596

If you oppose this change, please say so within the next month.

Luke

From kanzure at gmail.com  Wed Sep 27 19:01:40 2017
From: kanzure at gmail.com (Bryan Bishop)
Date: Wed, 27 Sep 2017 14:01:40 -0500
Subject: [bitcoin-dev] Revising BIP 2 to expand editorial authority
In-Reply-To: <201709271856.27376.luke@dashjr.org>
References: <201709271856.27376.luke@dashjr.org>
Message-ID: <CABaSBaz=pMfTz2UF-WpyxrkGY9XZO+zTHR7-Oie79J1Ap10hpQ@mail.gmail.com>

On Wed, Sep 27, 2017 at 1:56 PM, Luke Dashjr via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> What do people think about modifying BIP 2 to allow editors to merge these
> kinds of changes without involving the Authors? Strictly speaking, BIP 2
> shouldn't be changed now that it is Active, but for such a minor revision,
> I
> think an exception is reasonable.
>

Even minor revisions can not change the meaning of text. Changing a single
word can often have a strange impact on the meaning of the text. There
should be some amount of care exercised here. Maybe it would be okay as
long as edits are mentioned in the changelog at the bottom of each
document, or mention that the primary authors have not reviewed suggested
changes, or something as much; otherwise the reader might not be aware to
check revision history to see what's going on.

- Bryan
http://heybryan.org/
1 512 203 0507
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/f7331b71/attachment.html>

From mark at friedenbach.org  Wed Sep 27 19:03:44 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Wed, 27 Sep 2017 12:03:44 -0700
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <20170927160654.GA12492@savin.petertodd.org>
References: <20170927160654.GA12492@savin.petertodd.org>
Message-ID: <31968FFC-11BC-4331-B602-70B1F74AEEFC@friedenbach.org>

While there is a lot that I would like to comment on, for the moment I will just mention that you should consider using the 17 bit relative time format used in CSV as an offset from the birthdate of the address, a field all addresses should also have.

This would also mean that addresses cannot last more than a year without user override, which might actually be a plus, but you could also extend the field by a few bits too if that was deemed not acceptable. An address should not be considered valid longer than anticipated lifetime of the underlying cryptosystem in any case, so every address should have an expiry.

> On Sep 27, 2017, at 9:06 AM, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Re-use of old addresses is a major problem, not only for privacy, but also
> operationally: services like exchanges frequently have problems with users
> sending funds to addresses whose private keys have been lost or stolen; there
> are multiple examples of exchanges getting hacked, with users continuing to
> lose funds well after the actual hack has occured due to continuing deposits.
> This also makes it difficult operationally to rotate private keys. I personally
> have even lost funds in the past due to people sending me BTC to addresses that
> I gave them long ago for different reasons, rather than asking me for fresh
> one.
> 
> To help combat this problem, I suggest that we add a UI-level expiration time
> to the new BIP173 address format. Wallets would be expected to consider
> addresses as invalid as a destination for funds after the expiration time is
> reached.
> 
> Unfortunately, this proposal inevitably will raise a lot of UI and terminology
> questions. Notably, the entire notion of addresses is flawed from a user point
> of view: their experience with them should be more like "payment codes", with a
> code being valid for payment for a short period of time; wallets should not be
> displaying addresses as actually associated with specific funds. I suspect
> we'll see users thinking that an expired address risks the funds themselves;
> some thought needs to be put into terminology.
> 
> Being just an expiration time, seconds-level resolution is unnecessary, and
> may give the wrong impression. I'd suggest either:
> 
> 1) Hour resolution - 2^24 hours = 1914 years
> 2) Month resolution - 2^16 months = 5458 years
> 
> Both options have the advantage of working well at the UI level regardless of
> timezone: the former is sufficiently short that UI's can simply display an
> "exact" time (though note different leap second interpretations), while the
> latter is long enough that rounding off to the nearest day in the local
> timezone is fine.
> 
> Supporting hour-level (or just seconds) precision has the advantage of making
> it easy for services like exchanges to use addresses with relatively short
> validity periods, to reduce the risks of losses after a hack. Also, using at
> least hour-level ensures we don't have any year 2038 problems.
> 
> Thoughts?
> 
> -- 
> https://petertodd.org 'peter'[:-1]@petertodd.org
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From cp368202 at ohiou.edu  Wed Sep 27 19:35:33 2017
From: cp368202 at ohiou.edu (Chris Priest)
Date: Wed, 27 Sep 2017 13:35:33 -0600
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <20170927160654.GA12492@savin.petertodd.org>
References: <20170927160654.GA12492@savin.petertodd.org>
Message-ID: <CAAcC9yvdw4Yphs-prpckaouzaU21D=kGRqK+gG9SbPr-=27z9w@mail.gmail.com>

A better solution is to just have the sending wallet check to see if the
address you are about to send to has been used before. If it's a fresh
address, it sends it through without any popup alert. If the address has
history going back a certain amount of time, then a popup comes up and
notifies the sender that they are sending to a non-fresh address that may
no longer be controlled by the receiver anymore.

Also, an even better idea is to set up an "address expiration service".
When you delete a wallet, you first send off an "expiration notice" which
is just a message (signed with the private key) saying "I am about to
delete this address, here is my new address". When someone tries to send to
that address, they first consult the address expiration service, and the
service will either tell them "this address is not expired, proceed", or
"this address has been expired, please send to this other address
instead...". Basically like a 301 redirect, but for addresses. I don't
think address expiration should be part of the protocol.

On Wed, Sep 27, 2017 at 10:06 AM, Peter Todd via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Re-use of old addresses is a major problem, not only for privacy, but also
> operationally: services like exchanges frequently have problems with users
> sending funds to addresses whose private keys have been lost or stolen;
> there
> are multiple examples of exchanges getting hacked, with users continuing to
> lose funds well after the actual hack has occured due to continuing
> deposits.
> This also makes it difficult operationally to rotate private keys. I
> personally
> have even lost funds in the past due to people sending me BTC to addresses
> that
> I gave them long ago for different reasons, rather than asking me for fresh
> one.
>
> To help combat this problem, I suggest that we add a UI-level expiration
> time
> to the new BIP173 address format. Wallets would be expected to consider
> addresses as invalid as a destination for funds after the expiration time
> is
> reached.
>
> Unfortunately, this proposal inevitably will raise a lot of UI and
> terminology
> questions. Notably, the entire notion of addresses is flawed from a user
> point
> of view: their experience with them should be more like "payment codes",
> with a
> code being valid for payment for a short period of time; wallets should
> not be
> displaying addresses as actually associated with specific funds. I suspect
> we'll see users thinking that an expired address risks the funds
> themselves;
> some thought needs to be put into terminology.
>
> Being just an expiration time, seconds-level resolution is unnecessary, and
> may give the wrong impression. I'd suggest either:
>
> 1) Hour resolution - 2^24 hours = 1914 years
> 2) Month resolution - 2^16 months = 5458 years
>
> Both options have the advantage of working well at the UI level regardless
> of
> timezone: the former is sufficiently short that UI's can simply display an
> "exact" time (though note different leap second interpretations), while the
> latter is long enough that rounding off to the nearest day in the local
> timezone is fine.
>
> Supporting hour-level (or just seconds) precision has the advantage of
> making
> it easy for services like exchanges to use addresses with relatively short
> validity periods, to reduce the risks of losses after a hack. Also, using
> at
> least hour-level ensures we don't have any year 2038 problems.
>
> Thoughts?
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>


-- 
Chris Priest
786-531-5938
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/e853137e/attachment.html>

From cryptaxe at gmail.com  Wed Sep 27 20:11:09 2017
From: cryptaxe at gmail.com (CryptAxe)
Date: Wed, 27 Sep 2017 13:11:09 -0700
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <CAAcC9yvdw4Yphs-prpckaouzaU21D=kGRqK+gG9SbPr-=27z9w@mail.gmail.com>
References: <20170927160654.GA12492@savin.petertodd.org>
	<CAAcC9yvdw4Yphs-prpckaouzaU21D=kGRqK+gG9SbPr-=27z9w@mail.gmail.com>
Message-ID: <0e625a3c-46fa-239f-e646-cf97ae226df0@gmail.com>

See https://github.com/bitcoin/bitcoin/pull/9722

What still needs to be done is that during the first start up after
updating with this popup, the wallet needs to scan for addresses that
have been used in the past. That way the popup isn't only shown for
addresses that are reused after updating.


On 09/27/2017 12:35 PM, Chris Priest via bitcoin-dev wrote:
> A better solution is to just have the sending wallet check to see if
> the address you are about to send to has been used before. If it's a
> fresh address, it sends it through without any popup alert. If the
> address has history going back a certain amount of time, then a popup
> comes up and notifies the sender that they are sending to a non-fresh
> address that may no longer be controlled by the receiver anymore.
>
> Also, an even better idea is to set up an "address expiration
> service". When you delete a wallet, you first send off an "expiration
> notice" which is just a message (signed with the private key) saying
> "I am about to delete this address, here is my new address". When
> someone tries to send to that address, they first consult the address
> expiration service, and the service will either tell them "this
> address is not expired, proceed", or "this address has been expired,
> please send to this other address instead...". Basically like a 301
> redirect, but for addresses. I don't think address expiration should
> be part of the protocol.
>
...
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/305de41f/attachment-0001.html>

From sjors at sprovoost.nl  Wed Sep 27 20:20:54 2017
From: sjors at sprovoost.nl (Sjors Provoost)
Date: Wed, 27 Sep 2017 23:20:54 +0300
Subject: [bitcoin-dev] Revising BIP 2 to expand editorial authority
In-Reply-To: <CABaSBaz=pMfTz2UF-WpyxrkGY9XZO+zTHR7-Oie79J1Ap10hpQ@mail.gmail.com>
References: <201709271856.27376.luke@dashjr.org>
	<CABaSBaz=pMfTz2UF-WpyxrkGY9XZO+zTHR7-Oie79J1Ap10hpQ@mail.gmail.com>
Message-ID: <965940AD-A698-4B5F-9909-105E8A32B398@sprovoost.nl>


Op 27 sep. 2017, om 22:01 heeft Bryan Bishop via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:
> 
> On Wed, Sep 27, 2017 at 1:56 PM, Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
> What do people think about modifying BIP 2 to allow editors to merge these
> kinds of changes without involving the Authors? Strictly speaking, BIP 2
> shouldn't be changed now that it is Active, but for such a minor revision, I
> think an exception is reasonable.
> 
> Even minor revisions can not change the meaning of text. Changing a single word can often have a strange impact on the meaning of the text. There should be some amount of care exercised here. Maybe it would be okay as long as edits are mentioned in the changelog at the bottom of each document, or mention that the primary authors have not reviewed suggested changes, or something as much; otherwise the reader might not be aware to check revision history to see what's going on.

Perhaps it's enough to @mention authors in the PR and give them a week to object before merging?

Sjors
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/2bfcb0e8/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/2bfcb0e8/attachment.sig>

From nick at pudar.com  Wed Sep 27 20:23:33 2017
From: nick at pudar.com (Nick Pudar)
Date: Wed, 27 Sep 2017 20:23:33 +0000
Subject: [bitcoin-dev] Address expiration times should be added
	to	BIP-173
In-Reply-To: <CAAcC9yvdw4Yphs-prpckaouzaU21D=kGRqK+gG9SbPr-=27z9w@mail.gmail.com>
References: <20170927160654.GA12492@savin.petertodd.org>,
	<CAAcC9yvdw4Yphs-prpckaouzaU21D=kGRqK+gG9SbPr-=27z9w@mail.gmail.com>
Message-ID: <CY4PR12MB139977628660D809B611D8ACC8780@CY4PR12MB1399.namprd12.prod.outlook.com>

As a long term silent reader of this list, I felt compelled to comment on this address expiration topic.  I don't believe that address expiration should be part of the protocol.  I think instead that the "sending" feature should by default offer guidance to request a fresh address from the recipient.  Also allow the receiver of funds to be able to generate an "invoice" that the sender acts on.


I also think that re-directs are fraught with privacy issues.  At the end of the day, the ultimate burden is on the sender (with much self interest from the receiver) that the correct address is being used.


________________________________
From: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Chris Priest via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
Sent: Wednesday, September 27, 2017 3:35 PM
To: Peter Todd; Bitcoin Protocol Discussion
Subject: Re: [bitcoin-dev] Address expiration times should be added to BIP-173

A better solution is to just have the sending wallet check to see if the address you are about to send to has been used before. If it's a fresh address, it sends it through without any popup alert. If the address has history going back a certain amount of time, then a popup comes up and notifies the sender that they are sending to a non-fresh address that may no longer be controlled by the receiver anymore.

Also, an even better idea is to set up an "address expiration service". When you delete a wallet, you first send off an "expiration notice" which is just a message (signed with the private key) saying "I am about to delete this address, here is my new address". When someone tries to send to that address, they first consult the address expiration service, and the service will either tell them "this address is not expired, proceed", or "this address has been expired, please send to this other address instead...". Basically like a 301 redirect, but for addresses. I don't think address expiration should be part of the protocol.

On Wed, Sep 27, 2017 at 10:06 AM, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
Re-use of old addresses is a major problem, not only for privacy, but also
operationally: services like exchanges frequently have problems with users
sending funds to addresses whose private keys have been lost or stolen; there
are multiple examples of exchanges getting hacked, with users continuing to
lose funds well after the actual hack has occured due to continuing deposits.
This also makes it difficult operationally to rotate private keys. I personally
have even lost funds in the past due to people sending me BTC to addresses that
I gave them long ago for different reasons, rather than asking me for fresh
one.

To help combat this problem, I suggest that we add a UI-level expiration time
to the new BIP173 address format. Wallets would be expected to consider
addresses as invalid as a destination for funds after the expiration time is
reached.

Unfortunately, this proposal inevitably will raise a lot of UI and terminology
questions. Notably, the entire notion of addresses is flawed from a user point
of view: their experience with them should be more like "payment codes", with a
code being valid for payment for a short period of time; wallets should not be
displaying addresses as actually associated with specific funds. I suspect
we'll see users thinking that an expired address risks the funds themselves;
some thought needs to be put into terminology.

Being just an expiration time, seconds-level resolution is unnecessary, and
may give the wrong impression. I'd suggest either:

1) Hour resolution - 2^24 hours = 1914 years
2) Month resolution - 2^16 months = 5458 years

Both options have the advantage of working well at the UI level regardless of
timezone: the former is sufficiently short that UI's can simply display an
"exact" time (though note different leap second interpretations), while the
latter is long enough that rounding off to the nearest day in the local
timezone is fine.

Supporting hour-level (or just seconds) precision has the advantage of making
it easy for services like exchanges to use addresses with relatively short
validity periods, to reduce the risks of losses after a hack. Also, using at
least hour-level ensures we don't have any year 2038 problems.

Thoughts?

--
https://petertodd.org 'peter'[:-1]@petertodd.org<http://petertodd.org>

_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev




--
Chris Priest
786-531-5938
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/317dbefa/attachment.html>

From pete at petertodd.org  Wed Sep 27 21:15:50 2017
From: pete at petertodd.org (Peter Todd)
Date: Wed, 27 Sep 2017 17:15:50 -0400
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <CAAcC9yvdw4Yphs-prpckaouzaU21D=kGRqK+gG9SbPr-=27z9w@mail.gmail.com>
References: <20170927160654.GA12492@savin.petertodd.org>
	<CAAcC9yvdw4Yphs-prpckaouzaU21D=kGRqK+gG9SbPr-=27z9w@mail.gmail.com>
Message-ID: <20170927211550.GA2034@savin.petertodd.org>

On Wed, Sep 27, 2017 at 01:35:33PM -0600, Chris Priest wrote:
> A better solution is to just have the sending wallet check to see if the
> address you are about to send to has been used before. If it's a fresh

My concern is not primarily people re-using addresses, but rather people using
stale addresses that the recipient would rather not be used anymore. This
situation often happens even if the stale address has never been used.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/33226c50/attachment-0001.sig>

From pete at petertodd.org  Wed Sep 27 21:20:18 2017
From: pete at petertodd.org (Peter Todd)
Date: Wed, 27 Sep 2017 17:20:18 -0400
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <31968FFC-11BC-4331-B602-70B1F74AEEFC@friedenbach.org>
References: <20170927160654.GA12492@savin.petertodd.org>
	<31968FFC-11BC-4331-B602-70B1F74AEEFC@friedenbach.org>
Message-ID: <20170927212018.GB2034@savin.petertodd.org>

On Wed, Sep 27, 2017 at 12:03:44PM -0700, Mark Friedenbach wrote:
> While there is a lot that I would like to comment on, for the moment I will just mention that you should consider using the 17 bit relative time format used in CSV as an offset from the birthdate of the address, a field all addresses should also have.

Why should addresses have a birthdate? I don't see why that information would
be relevant to the person sending funds, and it could pose a privacy risk.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/b77a85ef/attachment.sig>

From lists at coryfields.com  Wed Sep 27 21:20:26 2017
From: lists at coryfields.com (Cory Fields)
Date: Wed, 27 Sep 2017 17:20:26 -0400
Subject: [bitcoin-dev] Bitcoin Assistance
In-Reply-To: <CAE3EOfjD5aW05DTOF1yC3R3Jf4w4m+kajT8rs4faH-n+WZpuog@mail.gmail.com>
References: <E682AA2FC88ADD4589420BFC6BE3A92141FC460F@SANDMBX01v.piper.root.local>
	<CAE3EOfjD5aW05DTOF1yC3R3Jf4w4m+kajT8rs4faH-n+WZpuog@mail.gmail.com>
Message-ID: <CAApLimhdKtQnx4CPwRsiB0LiOiWAQxJds3MhumXRqSpfMnEMnQ@mail.gmail.com>

Hi Mark

Thank you very much for posting the findings. I took a look through our
repository and I think I can provide a bit of context.

I'll go through each one, annotating what I've found.

> Apache License 2.0

This is used by a few java files in the libsecp256k1 project. That library
(which lives here: https://github.com/bitcoin-core/secp256k1) is a
sub-module created and maintained by Bitcoin Core developers. The files in
question are bindings that allow other applications to use libsecp256k1
from Java. Bitcoin Core makes no use of them.

> Boost Software License 1.0

This comes from tinyformat.h. Bitcoin Core indeed uses it.

> BSD 2-clause "Simplified" License

I'm unable to find any 2-clause BSD licensed files.

> BSD 3-clause "New" or "Revised" License

This comes from leveldb, which is database software used by Bitcoin Core.
Because database software version inconsistencies can cause accidental
forks (this actually happened in 2013), we include these files in our
repository and use them rather than linking to arbitrary versions at
runtime.

There are a few non-upstream files we use in our leveldb tree to provide
windows support. Quoting from src/leveldb/util/env_win.cc:
  This file contains source that originates from:

http://code.google.com/p/leveldbwin/source/browse/trunk/win32_impl_src/env_win32.h

http://code.google.com/p/leveldbwin/source/browse/trunk/win32_impl_src/port_win32.cc
  Those files don't have any explicit license headers but the
  project (http://code.google.com/p/leveldbwin/) lists the 'New BSD License'

> Creative Commons Attribution Share Alike 3.0

I didn't manage to find any CC-licensed files. The match probably comes
from our gui svg icons, which contain an xml tag with a link to
creativecommons.org. This seems to be the default behavior of inkscape,
which was used to create those icons. Any icons that we have not created
ourselves are listed in contrib/debian/copyright (they're all expat/public
domain).

> Expat License

See MIT.

> GNU General Public License v2.0 or later

The debian folder, which holds the files used to create debian/ubuntu
packages is licensed gplv2+. These are packaging resources only,
unnecessary for use of the code.

Additionally, some gplv2 m4 macros are used to bootstrap the code that is
used to build the Bitcoin code. These contain the additional exception:

   As a special exception, the respective Autoconf Macro's copyright owner
   gives unlimited permission to copy, distribute and modify the configure
   scripts that are the output of Autoconf when processing the Macro. You
   need not follow the terms of the GNU General Public License when using
   or distributing such scripts, even though portions of the text of the
   Macro appear in them. The GNU General Public License (GPL) does govern
   all other use of the material that constitutes the Autoconf Macro.

> GNU General Public License v3.0 or later

The macdeploy script, useful for creating DMG files for macOS is gplv3. It
is not necessary for any other platform, and is only used during the build
process. Additionally, it is not the only way to create DMG files (apple's
native tools can be used as well).

Additionally, config.guess and config.sub are gplv3 scripts used to build
our buildsystem.

> GNU Lesser General Public License v2.1 or later

authproxy.py, A python script used in our test suite is licensed lgpl
v2.1+. It is only necessary for running optional tests during development.

> License for A fast alternative to the modulo reduction

This references a comment cuckoocache.h. No code from the site is used. The
link to the site was added after the code, as the site provides a helpful
explanation for the technique used.

> License for atomic by Timm Kosse

Another m4 file. As explained with the others above, this is a macro which
builds code which builds code. It is used in the build process only.

> MIT License

The primary and default license for all contributions.

> Public Domain

> University of Illinois/NCSA Open Source License

clang-format-diff.py, a python script optionally used by developers to
clean up code changes.

tl;dr: Best I can tell, all source files that comprise Bitcoin Core
binaries are licensed (excluding the public domain ones) as MIT, BSD, or
Boost.

It's also worth repeating Omar's point that many of the files in the
Bitcoin Core repository are used for optional programs/libraries. None of
the artwork, for example, is needed for the primary bitcoin daemon.

Hope that helps!

Regards,
Cory
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/af791133/attachment.html>

From pete at petertodd.org  Wed Sep 27 21:33:07 2017
From: pete at petertodd.org (Peter Todd)
Date: Wed, 27 Sep 2017 17:33:07 -0400
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <20170927160654.GA12492@savin.petertodd.org>
References: <20170927160654.GA12492@savin.petertodd.org>
Message-ID: <20170927213307.GA2270@savin.petertodd.org>

On Wed, Sep 27, 2017 at 12:06:54PM -0400, Peter Todd via bitcoin-dev wrote:
> Being just an expiration time, seconds-level resolution is unnecessary, and
> may give the wrong impression. I'd suggest either:
> 
> 1) Hour resolution - 2^24 hours = 1914 years
> 2) Month resolution - 2^16 months = 5458 years

Just remembered: it's notable how Coinbase has a 10 minute timeout on their
payment window, which is in effect a 10 minute expiry time for the address.
Presumably they'd make use of this feature if it existed.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/95cbee53/attachment.sig>

From tim.ruffing at mmci.uni-saarland.de  Wed Sep 27 21:54:09 2017
From: tim.ruffing at mmci.uni-saarland.de (Tim Ruffing)
Date: Wed, 27 Sep 2017 23:54:09 +0200
Subject: [bitcoin-dev] Bitcoin Assistance
In-Reply-To: <CAApLimhdKtQnx4CPwRsiB0LiOiWAQxJds3MhumXRqSpfMnEMnQ@mail.gmail.com>
References: <E682AA2FC88ADD4589420BFC6BE3A92141FC460F@SANDMBX01v.piper.root.local>
	<CAE3EOfjD5aW05DTOF1yC3R3Jf4w4m+kajT8rs4faH-n+WZpuog@mail.gmail.com>
	<CAApLimhdKtQnx4CPwRsiB0LiOiWAQxJds3MhumXRqSpfMnEMnQ@mail.gmail.com>
Message-ID: <1506549249.1600.7.camel@mmci.uni-saarland.de>

On Wed, 2017-09-27 at 17:20 -0400, Cory Fields via bitcoin-dev wrote:
> > Creative Commons Attribution Share Alike 3.0
> 
> I didn't manage to find any CC-licensed files. The match probably
> comes from our gui svg icons, which contain an xml tag with a link to
> creativecommons.org. This seems to be the default behavior of
> inkscape, which was used to create those icons. Any icons that we
> have not created ourselves are listed in contrib/debian/copyright
> (they're all expat/public domain).

This is somewhat weird. Back in 2014, most of icons were listed as
"CC BY-SA" (which is the correct license according to the original
source):
https://github.com/bitcoin/bitcoin/blob/31aac02446472ec5bfc4676ab190ec9d37056503/doc/assets-attribution.md

However the current docs list them as "Expat". A mistake?
https://github.com/bitcoin/bitcoin/blob/master/contrib/debian/copyright

Also, even the old version lists some icons "based on Stephan Hutchings
Typicons" as "License: MIT", which could be a violation of CC BY-SA if
I'm not mistaken.

Best,
Tim



From greg at xiph.org  Wed Sep 27 22:06:58 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Wed, 27 Sep 2017 22:06:58 +0000
Subject: [bitcoin-dev] Bitcoin Assistance
In-Reply-To: <CAApLimhdKtQnx4CPwRsiB0LiOiWAQxJds3MhumXRqSpfMnEMnQ@mail.gmail.com>
References: <E682AA2FC88ADD4589420BFC6BE3A92141FC460F@SANDMBX01v.piper.root.local>
	<CAE3EOfjD5aW05DTOF1yC3R3Jf4w4m+kajT8rs4faH-n+WZpuog@mail.gmail.com>
	<CAApLimhdKtQnx4CPwRsiB0LiOiWAQxJds3MhumXRqSpfMnEMnQ@mail.gmail.com>
Message-ID: <CAAS2fgQpmNHaUWHTG-NXeW4+W01yRp47EVB_HcK4Pn3GDoTHzg@mail.gmail.com>

On Wed, Sep 27, 2017 at 9:20 PM, Cory Fields via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>> License for A fast alternative to the modulo reduction
>
> This references a comment cuckoocache.h. No code from the site is used. The
> link to the site was added after the code, as the site provides a helpful
> explanation for the technique used.

As the author of that comment: the reference there is unrelated to the
code but just a found-on-the-internet explanation for an trivial, old,
and well known technique (which I've seen in code since at least the
80s) that manages to sometimes surprise people who aren't familiar
with fixed point signal processing.  I wrote and submitted the comment
after encountering people confused by our code in another project,
long after it was written.

From greg at xiph.org  Wed Sep 27 22:21:12 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Wed, 27 Sep 2017 22:21:12 +0000
Subject: [bitcoin-dev] Bitcoin Assistance
In-Reply-To: <1506549249.1600.7.camel@mmci.uni-saarland.de>
References: <E682AA2FC88ADD4589420BFC6BE3A92141FC460F@SANDMBX01v.piper.root.local>
	<CAE3EOfjD5aW05DTOF1yC3R3Jf4w4m+kajT8rs4faH-n+WZpuog@mail.gmail.com>
	<CAApLimhdKtQnx4CPwRsiB0LiOiWAQxJds3MhumXRqSpfMnEMnQ@mail.gmail.com>
	<1506549249.1600.7.camel@mmci.uni-saarland.de>
Message-ID: <CAAS2fgQA=gpNW3JZsBBPazRGH8AvoG4VnnqUwGs3t_Qvjoahcw@mail.gmail.com>

On Wed, Sep 27, 2017 at 9:54 PM, Tim Ruffing via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Also, even the old version lists some icons "based on Stephan Hutchings
> Typicons" as "License: MIT", which could be a violation of CC BY-SA if
> I'm not mistaken.

Relicensed by the copyright holder:

https://github.com/bitcoin/bitcoin/commit/dae0a89d4b66f08c83ccc8c20cf37521084b6257

(For future reference, git log -p <file> makes it easy to go find
where some string was last in a file, so you can look at the commit
that changed it.)

From tim.ruffing at mmci.uni-saarland.de  Wed Sep 27 22:41:24 2017
From: tim.ruffing at mmci.uni-saarland.de (Tim Ruffing)
Date: Thu, 28 Sep 2017 00:41:24 +0200
Subject: [bitcoin-dev] Bitcoin Assistance
In-Reply-To: <CAAS2fgQA=gpNW3JZsBBPazRGH8AvoG4VnnqUwGs3t_Qvjoahcw@mail.gmail.com>
References: <E682AA2FC88ADD4589420BFC6BE3A92141FC460F@SANDMBX01v.piper.root.local>
	<CAE3EOfjD5aW05DTOF1yC3R3Jf4w4m+kajT8rs4faH-n+WZpuog@mail.gmail.com>
	<CAApLimhdKtQnx4CPwRsiB0LiOiWAQxJds3MhumXRqSpfMnEMnQ@mail.gmail.com>
	<1506549249.1600.7.camel@mmci.uni-saarland.de>
	<CAAS2fgQA=gpNW3JZsBBPazRGH8AvoG4VnnqUwGs3t_Qvjoahcw@mail.gmail.com>
Message-ID: <1506552084.1600.14.camel@mmci.uni-saarland.de>

Oh nevermind. I had a look at the history but missed that commit and
assumed the change was introduced when adding the text to
contrib/debian/copyright

Tim

On Wed, 2017-09-27 at 22:21 +0000, Gregory Maxwell wrote:
> On Wed, Sep 27, 2017 at 9:54 PM, Tim Ruffing via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > Also, even the old version lists some icons "based on Stephan
> > Hutchings
> > Typicons" as "License: MIT", which could be a violation of CC BY-SA 
> > if
> > I'm not mistaken.
> 
> Relicensed by the copyright holder:
> 
> https://github.com/bitcoin/bitcoin/commit/dae0a89d4b66f08c83ccc8c20cf
> 37521084b6257
> 
> (For future reference, git log -p <file> makes it easy to go find
> where some string was last in a file, so you can look at the commit
> that changed it.)

From greg at xiph.org  Thu Sep 28 00:22:13 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Thu, 28 Sep 2017 00:22:13 +0000
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <CAAcC9yvdw4Yphs-prpckaouzaU21D=kGRqK+gG9SbPr-=27z9w@mail.gmail.com>
References: <20170927160654.GA12492@savin.petertodd.org>
	<CAAcC9yvdw4Yphs-prpckaouzaU21D=kGRqK+gG9SbPr-=27z9w@mail.gmail.com>
Message-ID: <CAAS2fgQqae4mdSt2eg=Q2wXquUW5qmXBxg_vuiCC4O05rh0_2g@mail.gmail.com>

On Wed, Sep 27, 2017 at 7:35 PM, Chris Priest via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> A better solution is to just have the sending wallet check to see if the
> address you are about to send to has been used before.

So every wallet needs all the addresses ever used and a fast index into them?
This seems pretty harmful for scalability.

> they first consult the address expiration service,

So you propose a best practice that requires contacting a service and
telling them what addresses you're planning on paying?  This seems
pretty harmful for privacy.

From greg at xiph.org  Thu Sep 28 00:58:30 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Thu, 28 Sep 2017 00:58:30 +0000
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <20170927160654.GA12492@savin.petertodd.org>
References: <20170927160654.GA12492@savin.petertodd.org>
Message-ID: <CAAS2fgRpMXdqKXeYSOtVBQQ9fmu=nQ9anEO6Wrc_5rms1Y2B2w@mail.gmail.com>

On Wed, Sep 27, 2017 at 4:06 PM, Peter Todd via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Re-use of old addresses is a major problem, not only for privacy, but also
> operationally: services like exchanges frequently have problems with users
> sending funds to addresses whose private keys have been lost or stolen; there

When Pieter and I were working on Bech32 we specifically designed for
error correcting codes that had good performance for longer lengths
than we technically needed specifically to incorporate things like
dates and explicit amounts.

(explicit amounts so that typos and bit flips in amounts displayed or
in memory couldn't result in sending the wrong amount)

But we also thought that also adding those features at the same time
would retard adoption-- both due to debating over the encodings and
because handling would result in different software requirements and
layering, so you couldn't just drop them in.

Doubly unfortunately, people have even deployed BIP173 already (prior
to it even having much peer review or being adopted by its own
authors), so I think a rethink now wouldn't be timely (I mean as a
replacement to BIP173 rather than an additional format). :(

But I do support the idea.

One thing to keep in mind is that address format linked fields are
most efficient if they're multiples of 5 bits.  Perhaps use 1 bit to
indicate an embedded amount and 19 bits of 1 day precision, resulting
in a 1435 year span.

Keep in mind that high precision of the expiration times is asking the
sender to have a higher precision of idea of the time, date only is
kinda nice.  I think shorter expiration times are unlikely to be
useful due to clock skew-- you can't assume a signer has any access to
the Bitcoin network at all.

From andreas at schildbach.de  Thu Sep 28 10:09:59 2017
From: andreas at schildbach.de (Andreas Schildbach)
Date: Thu, 28 Sep 2017 12:09:59 +0200
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <20170927160654.GA12492@savin.petertodd.org>
References: <20170927160654.GA12492@savin.petertodd.org>
Message-ID: <oqihpf$5gc$1@blaine.gmane.org>

This feels redundant to me; the payment protocol already has an
expiration time.


On 09/27/2017 06:06 PM, Peter Todd via bitcoin-dev wrote:
> Re-use of old addresses is a major problem, not only for privacy, but also
> operationally: services like exchanges frequently have problems with users
> sending funds to addresses whose private keys have been lost or stolen; there
> are multiple examples of exchanges getting hacked, with users continuing to
> lose funds well after the actual hack has occured due to continuing deposits.
> This also makes it difficult operationally to rotate private keys. I personally
> have even lost funds in the past due to people sending me BTC to addresses that
> I gave them long ago for different reasons, rather than asking me for fresh
> one.
> 
> To help combat this problem, I suggest that we add a UI-level expiration time
> to the new BIP173 address format. Wallets would be expected to consider
> addresses as invalid as a destination for funds after the expiration time is
> reached.
> 
> Unfortunately, this proposal inevitably will raise a lot of UI and terminology
> questions. Notably, the entire notion of addresses is flawed from a user point
> of view: their experience with them should be more like "payment codes", with a
> code being valid for payment for a short period of time; wallets should not be
> displaying addresses as actually associated with specific funds. I suspect
> we'll see users thinking that an expired address risks the funds themselves;
> some thought needs to be put into terminology.
> 
> Being just an expiration time, seconds-level resolution is unnecessary, and
> may give the wrong impression. I'd suggest either:
> 
> 1) Hour resolution - 2^24 hours = 1914 years
> 2) Month resolution - 2^16 months = 5458 years
> 
> Both options have the advantage of working well at the UI level regardless of
> timezone: the former is sufficiently short that UI's can simply display an
> "exact" time (though note different leap second interpretations), while the
> latter is long enough that rounding off to the nearest day in the local
> timezone is fine.
> 
> Supporting hour-level (or just seconds) precision has the advantage of making
> it easy for services like exchanges to use addresses with relatively short
> validity periods, to reduce the risks of losses after a hack. Also, using at
> least hour-level ensures we don't have any year 2038 problems.
> 
> Thoughts?
> 
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 



From decker.christian at gmail.com  Thu Sep 28 12:43:19 2017
From: decker.christian at gmail.com (Christian Decker)
Date: Thu, 28 Sep 2017 12:43:19 +0000
Subject: [bitcoin-dev] Revising BIP 2 to expand editorial authority
In-Reply-To: <CABaSBaz=pMfTz2UF-WpyxrkGY9XZO+zTHR7-Oie79J1Ap10hpQ@mail.gmail.com>
References: <201709271856.27376.luke@dashjr.org>
	<CABaSBaz=pMfTz2UF-WpyxrkGY9XZO+zTHR7-Oie79J1Ap10hpQ@mail.gmail.com>
Message-ID: <CALxbBHUPoOgEuXGryYVvuVnM+Rnv_97kCpxPW-BcGyXFLedcLA@mail.gmail.com>

Agreed, I think a sign-off mechanism might be desirable. Currently it must
be the original author(s) signing off, but we can probably widen that to be
any 2-3 community members. They'd basically be attesting that the meaning
did not change.

- cdecker

On Wed, Sep 27, 2017 at 9:02 PM Bryan Bishop via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Wed, Sep 27, 2017 at 1:56 PM, Luke Dashjr via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> What do people think about modifying BIP 2 to allow editors to merge these
>> kinds of changes without involving the Authors? Strictly speaking, BIP 2
>> shouldn't be changed now that it is Active, but for such a minor
>> revision, I
>> think an exception is reasonable.
>>
>
> Even minor revisions can not change the meaning of text. Changing a single
> word can often have a strange impact on the meaning of the text. There
> should be some amount of care exercised here. Maybe it would be okay as
> long as edits are mentioned in the changelog at the bottom of each
> document, or mention that the primary authors have not reviewed suggested
> changes, or something as much; otherwise the reader might not be aware to
> check revision history to see what's going on.
>
> - Bryan
> http://heybryan.org/
> 1 512 203 0507
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/1651c3ca/attachment-0001.html>

From cryptaxe at gmail.com  Wed Sep 27 20:19:48 2017
From: cryptaxe at gmail.com (CryptAxe)
Date: Wed, 27 Sep 2017 13:19:48 -0700
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <CY4PR12MB139977628660D809B611D8ACC8780@CY4PR12MB1399.namprd12.prod.outlook.com>
References: <20170927160654.GA12492@savin.petertodd.org>
	<CAAcC9yvdw4Yphs-prpckaouzaU21D=kGRqK+gG9SbPr-=27z9w@mail.gmail.com>
	<CY4PR12MB139977628660D809B611D8ACC8780@CY4PR12MB1399.namprd12.prod.outlook.com>
Message-ID: <12c4295c-9546-ba0a-5bd4-4e7e9282daf1@gmail.com>

I do agree with you to a degree, but address reuse is actually not even
supposed to work (it is a bug). Peter Todd is suggesting only to make
expiration a part of a new address format, and we could have a GUI
warning (but no protocol change) for the existing formats. What do you
think about that?


On 09/27/2017 01:23 PM, Nick Pudar via bitcoin-dev wrote:
>
> As a long term silent reader of this list, I felt compelled to comment
> on this address expiration topic.  I don't believe that address
> expiration should be part of the protocol.  I think instead that the
> "sending" feature should by default offer guidance to request a fresh
> address from the recipient.  Also allow the receiver of funds to be
> able to generate an "invoice" that the sender acts on.
>
>
> I also think that re-directs are fraught with privacy issues.  At the
> end of the day, the ultimate burden is on the sender (with much self
> interest from the receiver) that the correct address is being used.
>
>
>
> ------------------------------------------------------------------------
> *From:* bitcoin-dev-bounces at lists.linuxfoundation.org
> <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Chris
> Priest via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
> *Sent:* Wednesday, September 27, 2017 3:35 PM
> *To:* Peter Todd; Bitcoin Protocol Discussion
> *Subject:* Re: [bitcoin-dev] Address expiration times should be added
> to BIP-173
>  
> A better solution is to just have the sending wallet check to see if
> the address you are about to send to has been used before. If it's a
> fresh address, it sends it through without any popup alert. If the
> address has history going back a certain amount of time, then a popup
> comes up and notifies the sender that they are sending to a non-fresh
> address that may no longer be controlled by the receiver anymore.
>
> Also, an even better idea is to set up an "address expiration
> service". When you delete a wallet, you first send off an "expiration
> notice" which is just a message (signed with the private key) saying
> "I am about to delete this address, here is my new address". When
> someone tries to send to that address, they first consult the address
> expiration service, and the service will either tell them "this
> address is not expired, proceed", or "this address has been expired,
> please send to this other address instead...". Basically like a 301
> redirect, but for addresses. I don't think address expiration should
> be part of the protocol.
>
> On Wed, Sep 27, 2017 at 10:06 AM, Peter Todd via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org
> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>
>     Re-use of old addresses is a major problem, not only for privacy,
>     but also
>     operationally: services like exchanges frequently have problems
>     with users
>     sending funds to addresses whose private keys have been lost or
>     stolen; there
>     are multiple examples of exchanges getting hacked, with users
>     continuing to
>     lose funds well after the actual hack has occured due to
>     continuing deposits.
>     This also makes it difficult operationally to rotate private keys.
>     I personally
>     have even lost funds in the past due to people sending me BTC to
>     addresses that
>     I gave them long ago for different reasons, rather than asking me
>     for fresh
>     one.
>
>     To help combat this problem, I suggest that we add a UI-level
>     expiration time
>     to the new BIP173 address format. Wallets would be expected to
>     consider
>     addresses as invalid as a destination for funds after the
>     expiration time is
>     reached.
>
>     Unfortunately, this proposal inevitably will raise a lot of UI and
>     terminology
>     questions. Notably, the entire notion of addresses is flawed from
>     a user point
>     of view: their experience with them should be more like "payment
>     codes", with a
>     code being valid for payment for a short period of time; wallets
>     should not be
>     displaying addresses as actually associated with specific funds. I
>     suspect
>     we'll see users thinking that an expired address risks the funds
>     themselves;
>     some thought needs to be put into terminology.
>
>     Being just an expiration time, seconds-level resolution is
>     unnecessary, and
>     may give the wrong impression. I'd suggest either:
>
>     1) Hour resolution - 2^24 hours = 1914 years
>     2) Month resolution - 2^16 months = 5458 years
>
>     Both options have the advantage of working well at the UI level
>     regardless of
>     timezone: the former is sufficiently short that UI's can simply
>     display an
>     "exact" time (though note different leap second interpretations),
>     while the
>     latter is long enough that rounding off to the nearest day in the
>     local
>     timezone is fine.
>
>     Supporting hour-level (or just seconds) precision has the
>     advantage of making
>     it easy for services like exchanges to use addresses with
>     relatively short
>     validity periods, to reduce the risks of losses after a hack.
>     Also, using at
>     least hour-level ensures we don't have any year 2038 problems.
>
>     Thoughts?
>
>     --
>     https://petertodd.org 'peter'[:-1]@petertodd.org
>     <http://petertodd.org>
>
>     _______________________________________________
>     bitcoin-dev mailing list
>     bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>     <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
>
>
>
>
> -- 
> Chris Priest
> 786-531-5938
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/c2fbfa44/attachment-0001.html>

From mark at friedenbach.org  Wed Sep 27 21:09:16 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Wed, 27 Sep 2017 14:09:16 -0700
Subject: [bitcoin-dev] Address expiration times should be added
	to	BIP-173
In-Reply-To: <CY4PR12MB139977628660D809B611D8ACC8780@CY4PR12MB1399.namprd12.prod.outlook.com>
References: <20170927160654.GA12492@savin.petertodd.org>
	<CAAcC9yvdw4Yphs-prpckaouzaU21D=kGRqK+gG9SbPr-=27z9w@mail.gmail.com>
	<CY4PR12MB139977628660D809B611D8ACC8780@CY4PR12MB1399.namprd12.prod.outlook.com>
Message-ID: <F2378ADB-C2FB-4253-A7D7-3B52318FA251@friedenbach.org>

First, there?s been no discussion so far for address expiration to be part of ?the protocol? which usually means consensus rules or p2p. This is purely about wallets and wallet information exchange protocols.

There?s no way for the sender to know whether an address has been used without a complete copy of the block chain and more indexes than even Bitcoin Core maintains. It?s simply not an option now, let alone as the blockchain grows into the future.

> On Sep 27, 2017, at 1:23 PM, Nick Pudar via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> As a long term silent reader of this list, I felt compelled to comment on this address expiration topic.  I don't believe that address expiration should be part of the protocol.  I think instead that the "sending" feature should by default offer guidance to request a fresh address from the recipient.  Also allow the receiver of funds to be able to generate an "invoice" that the sender acts on.
> 
> I also think that re-directs are fraught with privacy issues.  At the end of the day, the ultimate burden is on the sender (with much self interest from the receiver) that the correct address is being used.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/f8b622f6/attachment-0001.html>

From sjors at sprovoost.nl  Thu Sep 28 12:43:05 2017
From: sjors at sprovoost.nl (Sjors Provoost)
Date: Thu, 28 Sep 2017 15:43:05 +0300
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <oqihpf$5gc$1@blaine.gmane.org>
References: <20170927160654.GA12492@savin.petertodd.org>
	<oqihpf$5gc$1@blaine.gmane.org>
Message-ID: <B5DE4E92-C5B3-4C01-A148-E3C46C897323@sprovoost.nl>

Peter Todd wrote:

> 
> Re-use of old addresses is a major problem, not only for privacy, but also
> operationally: services like exchanges frequently have problems with users
> sending funds to addresses whose private keys have been lost or stolen;

[...]
> 
> To help combat this problem, I suggest that we add a UI-level expiration time
> to the new BIP173 address format. Wallets would be expected to consider
> addresses as invalid as a destination for funds after the expiration time is
> reached.

[...]

Perhaps outside the scope of BIP173, but what about baking it into the protocol? That way a transaction that's sent too late, simply won't get confirmed. This removes the need for refund logic or asking a customer to pay just a few extra cents. You could also disallow a second payment.

Two downsides I can think of:
* privacy, as differences in expiration policy would be visible on chain
* miners might be able to game it in their interaction with brokers

> Being just an expiration time, seconds-level resolution is unnecessary, and
> may give the wrong impression. I'd suggest either:
> 
> 1) Hour resolution - 2^24 hours = 1914 years
> 2) Month resolution - 2^16 months = 5458 years

So that's 4.8 characters for hours, or 3.2 for years, plus checksum space? The shorter the better. Perhaps one or two bits can be used to specify an exponent; a large range seems more useful than high precision. For instance a merchant doesn't care if the customer pays within 10:00:00 minutes or 10:00:01 minutes and you wouldn't care if your address is valid 50 years or 50 years and 3 minutes. This point may be mute if minute level resolution is not practical.

> Both options have the advantage of working well at the UI level regardless of
> timezone: the former is sufficiently short that UI's can simply display an
> "exact" time (though note different leap second interpretations), while the
> latter is long enough that rounding off to the nearest day in the local
> timezone is fine.
> 
> Supporting hour-level (or just seconds) precision has the advantage of making
> it easy for services like exchanges to use addresses with relatively short
> validity periods, to reduce the risks of losses after a hack. Also, using at
> least hour-level ensures we don't have any year 2038 problems.

Greg Maxwell wrote:

> One thing to keep in mind is that address format linked fields are
> most efficient if they're multiples of 5 bits.  Perhaps use 1 bit to
> indicate an embedded amount and 19 bits of 1 day precision, resulting
> in a 1435 year span.

Is this because 5 bits are one bech32 character (2^5=32) or there is another reason? And does that include the space needed for the checksum?


Hopefully one day addresses can be abstracted away, because they really aren't what people intuitively think they are, but I don't see that happen on short notice. Until then they shouldn't exhibit "surprising" behavior.

Embedding amounts in an address could confuse people when they reuse it. Wallets would e.g. have to ignore the amount value if they previously sent money, but without changing the address string displayed in the UI.


> Keep in mind that high precision of the expiration times is asking the
> sender to have a higher precision of idea of the time, date only is
> kinda nice.  I think shorter expiration times are unlikely to be
> useful due to clock skew-- you can't assume a signer has any access to
> the Bitcoin network at all.

Many merchant services and exchanges use 10-15 minute expiration though. At the wallet level, all sender and recipient need to agree on is their relative time. Fallback behavior for a signer with no access to time could be to ignore the deadline.

Andreas Schildbach wrote:
> 
> This feels redundant to me; the payment protocol already has an
> expiration time.

The BIP-70 payment protocol has significant overhead and most importantly requires back and forth. Emailing a bitcoin address or printing it on an invoice is much easier, so I would expect people to keep doing that.

Sjors

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/48685946/attachment-0001.sig>

From jeanpaulkogelman at me.com  Wed Sep 27 21:00:35 2017
From: jeanpaulkogelman at me.com (Jean-Paul Kogelman)
Date: Wed, 27 Sep 2017 14:00:35 -0700
Subject: [bitcoin-dev] Revising BIP 2 to expand editorial authority
In-Reply-To: <965940AD-A698-4B5F-9909-105E8A32B398@sprovoost.nl>
References: <201709271856.27376.luke@dashjr.org>
	<CABaSBaz=pMfTz2UF-WpyxrkGY9XZO+zTHR7-Oie79J1Ap10hpQ@mail.gmail.com>
	<965940AD-A698-4B5F-9909-105E8A32B398@sprovoost.nl>
Message-ID: <04038964-659F-4105-B086-8C0AB9FF765C@me.com>

Perhaps having authors consent to certain types of changes when they submit their BIP?


> On Sep 27, 2017, at 1:20 PM, Sjors Provoost via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> 
>> Op 27 sep. 2017, om 22:01 heeft Bryan Bishop via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:
>> 
>>> On Wed, Sep 27, 2017 at 1:56 PM, Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>> What do people think about modifying BIP 2 to allow editors to merge these
>>> kinds of changes without involving the Authors? Strictly speaking, BIP 2
>>> shouldn't be changed now that it is Active, but for such a minor revision, I
>>> think an exception is reasonable.
>> 
>> Even minor revisions can not change the meaning of text. Changing a single word can often have a strange impact on the meaning of the text. There should be some amount of care exercised here. Maybe it would be okay as long as edits are mentioned in the changelog at the bottom of each document, or mention that the primary authors have not reviewed suggested changes, or something as much; otherwise the reader might not be aware to check revision history to see what's going on.
> 
> Perhaps it's enough to @mention authors in the PR and give them a week to object before merging?
> 
> Sjors
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170927/b5952838/attachment.html>

From andreas at schildbach.de  Thu Sep 28 14:13:48 2017
From: andreas at schildbach.de (Andreas Schildbach)
Date: Thu, 28 Sep 2017 16:13:48 +0200
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <B5DE4E92-C5B3-4C01-A148-E3C46C897323@sprovoost.nl>
References: <20170927160654.GA12492@savin.petertodd.org>
	<oqihpf$5gc$1@blaine.gmane.org>
	<B5DE4E92-C5B3-4C01-A148-E3C46C897323@sprovoost.nl>
Message-ID: <oqj02k$fj9$1@blaine.gmane.org>

On 09/28/2017 02:43 PM, Sjors Provoost via bitcoin-dev wrote:

>> This feels redundant to me; the payment protocol already has an
>> expiration time.
> 
> The BIP-70 payment protocol has significant overhead and most importantly requires back and forth. Emailing a bitcoin address or printing it on an invoice is much easier, so I would expect people to keep doing that.

The payment request message is just as one-way as an address is. It is
already being emailed and printed on an invoice, in fact it often acts
as the invoice.

Even more problematic, if you were to include an expiry date in a
BIP-173 address and put that into a payment request, wallets wouldn't be
allowed to parse that expiry date from the script without violating the
BIP70 spec.


From sjors at sprovoost.nl  Thu Sep 28 14:41:42 2017
From: sjors at sprovoost.nl (Sjors Provoost)
Date: Thu, 28 Sep 2017 17:41:42 +0300
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <oqj02k$fj9$1@blaine.gmane.org>
References: <20170927160654.GA12492@savin.petertodd.org>
	<oqihpf$5gc$1@blaine.gmane.org>
	<B5DE4E92-C5B3-4C01-A148-E3C46C897323@sprovoost.nl>
	<oqj02k$fj9$1@blaine.gmane.org>
Message-ID: <14496C9C-E291-4415-B07E-859853579D20@sprovoost.nl>

Op 28 sep. 2017, om 17:13 heeft Andreas Schildbach via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:
> 
> On 09/28/2017 02:43 PM, Sjors Provoost via bitcoin-dev wrote:
> 
>>> This feels redundant to me; the payment protocol already has an
>>> expiration time.
>> 
>> The BIP-70 payment protocol has significant overhead and most importantly requires back and forth. Emailing a bitcoin address or printing it on an invoice is much easier, so I would expect people to keep doing that.
> 
> The payment request message is just as one-way as an address is. It is
> already being emailed and printed on an invoice, in fact it often acts
> as the invoice.

True and the more complicated fields, like a digital signature, are optional. Are you suggesting BIP-70 payment requests should be rendered with bech32? How long would those be if it's just the address and expiration date?

> 
> Even more problematic, if you were to include an expiry date in a
> BIP-173 address and put that into a payment request, wallets wouldn't be
> allowed to parse that expiry date from the script without violating the
> BIP70 spec.

Do tools that generate BIP-70 payment requests generate addresses themselves or are those input manually by a user? In the former case, I assume it could avoid setting the optional expiration date?

Is it not allowed to scan the date even if it then sets the expires field to the same (redundant) value?

Sjors
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/9b3fb190/attachment.sig>

From andreas at schildbach.de  Thu Sep 28 15:06:56 2017
From: andreas at schildbach.de (Andreas Schildbach)
Date: Thu, 28 Sep 2017 17:06:56 +0200
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <14496C9C-E291-4415-B07E-859853579D20@sprovoost.nl>
References: <20170927160654.GA12492@savin.petertodd.org>
	<oqihpf$5gc$1@blaine.gmane.org>
	<B5DE4E92-C5B3-4C01-A148-E3C46C897323@sprovoost.nl>
	<oqj02k$fj9$1@blaine.gmane.org>
	<14496C9C-E291-4415-B07E-859853579D20@sprovoost.nl>
Message-ID: <oqj369$18u$1@blaine.gmane.org>

On 09/28/2017 04:41 PM, Sjors Provoost via bitcoin-dev wrote:

>> The payment request message is just as one-way as an address is. It is
>> already being emailed and printed on an invoice, in fact it often acts
>> as the invoice.
> 
> True and the more complicated fields, like a digital signature, are optional. Are you suggesting BIP-70 payment requests should be rendered with bech32? How long would those be if it's just the address and expiration date?

I've not yet progressed that far in segwit support, but I can't think of
a reason why not. You can request coins to any script using the payment
protocol.

Regarding size, I've had no problems putting (unsigned) payment request
messages into QR codes. I doubt paying to a native segwit address will
change much in size. Protobuf is very efficient.


>> Even more problematic, if you were to include an expiry date in a
>> BIP-173 address and put that into a payment request, wallets wouldn't be
>> allowed to parse that expiry date from the script without violating the
>> BIP70 spec.
> 
> Do tools that generate BIP-70 payment requests generate addresses themselves or are those input manually by a user? In the former case, I assume it could avoid setting the optional expiration date?

The BIP70 spec doesn't limit you on this, I guess either does exist.
Having two (or more!) optional expiration date adds unnecessary
complexity to the specs and implementations. E.g. what if the two do not
match up?

> Is it not allowed to scan the date even if it then sets the expires field to the same (redundant) value?

What do you mean by "scan the date"?


From sjors at sprovoost.nl  Thu Sep 28 15:45:47 2017
From: sjors at sprovoost.nl (Sjors Provoost)
Date: Thu, 28 Sep 2017 18:45:47 +0300
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <oqj369$18u$1@blaine.gmane.org>
References: <20170927160654.GA12492@savin.petertodd.org>
	<oqihpf$5gc$1@blaine.gmane.org>
	<B5DE4E92-C5B3-4C01-A148-E3C46C897323@sprovoost.nl>
	<oqj02k$fj9$1@blaine.gmane.org>
	<14496C9C-E291-4415-B07E-859853579D20@sprovoost.nl>
	<oqj369$18u$1@blaine.gmane.org>
Message-ID: <4745C5CF-AA3A-4614-99DA-DE3C985F3D69@sprovoost.nl>

Op 28 sep. 2017, om 18:06 heeft Andreas Schildbach via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:
> 
> On 09/28/2017 04:41 PM, Sjors Provoost via bitcoin-dev wrote:
> 
>>> The payment request message is just as one-way as an address is. It is
>>> already being emailed and printed on an invoice, in fact it often acts
>>> as the invoice.
>> 
>> True and the more complicated fields, like a digital signature, are optional. Are you suggesting BIP-70 payment requests should be rendered with bech32? How long would those be if it's just the address and expiration date?
> 
> I've not yet progressed that far in segwit support, but I can't think of
> a reason why not. You can request coins to any script using the payment
> protocol.
> 
> Regarding size, I've had no problems putting (unsigned) payment request
> messages into QR codes. I doubt paying to a native segwit address will
> change much in size. Protobuf is very efficient.

Bech32 is just a replacement for Base58. It's not strictly SegWit related. If I understand correctly the only reason it won't be used for legacy addresses is to prevent confusion:

https://www.youtube.com/watch?v=NqiN9VFE4CU
https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki

Regarding size I'm mostly curious how big it is on a screen or a physical paper, as text, not as a QR code. This would involve deserializing the protobuf and rendering the result in bech32.

I does sound like there's overlap between BIP-70 and BIP-173 that should be resolved.

Perhaps any payment request can be rendered as bech32 and any bech32 address can converted to a payment request. Maybe only for a limited set of fields (address, expiration, amount). This would be a matter of agreeing how the protobuf should be serialized and deserialized. In that case the protobuf would not contain the literal bech32 address as a string, but instead it would contain the underlying data (public key / script hash, network, etc).

Sjors
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/c1597496/attachment-0001.sig>

From luke at dashjr.org  Thu Sep 28 16:59:26 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Thu, 28 Sep 2017 16:59:26 +0000
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <oqj02k$fj9$1@blaine.gmane.org>
References: <20170927160654.GA12492@savin.petertodd.org>
	<B5DE4E92-C5B3-4C01-A148-E3C46C897323@sprovoost.nl>
	<oqj02k$fj9$1@blaine.gmane.org>
Message-ID: <201709281659.27343.luke@dashjr.org>

On Thursday 28 September 2017 2:13:48 PM Andreas Schildbach via bitcoin-dev 
wrote:
> On 09/28/2017 02:43 PM, Sjors Provoost via bitcoin-dev wrote:
> >> This feels redundant to me; the payment protocol already has an
> >> expiration time.
> > 
> > The BIP-70 payment protocol has significant overhead and most importantly
> > requires back and forth. Emailing a bitcoin address or printing it on an
> > invoice is much easier, so I would expect people to keep doing that.
> 
> The payment request message is just as one-way as an address is. It is
> already being emailed and printed on an invoice, in fact it often acts
> as the invoice.
> 
> Even more problematic, if you were to include an expiry date in a
> BIP-173 address and put that into a payment request, wallets wouldn't be
> allowed to parse that expiry date from the script without violating the
> BIP70 spec.

Payment requests don't use and don't overlap with addresses. Maybe you could 
have an argument for serialising BIP70 payment requests in Bech32 as the new 
address format itself, but it doesn't make sense to talk about putting a 
Bech32 address *into* a payment request...

Luke

From mark at friedenbach.org  Fri Sep 29 01:06:29 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Thu, 28 Sep 2017 18:06:29 -0700
Subject: [bitcoin-dev] Rebatable fees & incentive-safe fee markets
Message-ID: <359FFE85-86AF-4FBD-9491-3528382E5002@friedenbach.org>

This article by Ron Lavi, Or Sattath, and Aviv Zohar was forwarded to
me and is of interest to this group:

    "Redesigning Bitcoin's fee market"
    https://arxiv.org/abs/1709.08881

I'll briefly summarize before providing some commentary of my own,
including transformation of the proposed mechanism into a relatively
simple soft-fork.  The article points out that bitcoin's auction
model for transaction fees / inclusion in a block is broken in the
sense that it does not achieve maximum clearing price* and to prevent
strategic bidding behavior.

(* Maximum clearing price meaning highest fee the user is willing to
   pay for the amount of time they had to wait.  In other words, miner
   income.  While this is a common requirement of academic work on
   auction protocols, it's not obvious that it provides intrinsic
   benefit to bitcoin for miners to extract from users the maximum
   amount of fee the market is willing to support.  However strategic
   bidding behavior (e.g. RBF and CPFP) does have real network and
   usability costs, which a more "correct" auction model would reduce
   in some use cases.)

Bitcoin is a "pay your bid" auction, where the user makes strategic
calculations to determine what bid (=fee) is likely to get accepted
within the window of time in which they want confirmation.  This bid
can then be adjusted through some combination of RBF or CPFP.

The authors suggest moving to a "pay lowest winning bid" model where
all transactions pay only the smallest fee rate paid by any
transaction in the block, for which the winning strategy is to bid the
maximum amount you are willing to pay to get the transaction
confirmed:

> Users can then simply set their bids truthfully to exactly the
> amount they are willing to pay to transact, and do not need to
> utilize fee estimate mechanisms, do not resort to bid shading and do
> not need to adjust transaction fees (via replace-by-fee mechanisms)
> if the mempool grows.


Unlike other proposed fixes to the fee model, this is not trivially
broken by paying the miner out of band.  If you pay out of band fee
instead of regular fee, then your transaction cannot be included with
other regular fee paying transactions without the miner giving up all
regular fee income.  Any transaction paying less fee in-band than the
otherwise minimum fee rate needs to also provide ~1Mvbyte * fee rate
difference fee to make up for that lost income.  So out of band fee is
only realistically considered when it pays on top of a regular feerate
paying transaction that would have been included in the block anyway.
And what would be the point of that?


As an original contribution, I would like to note that something
strongly resembling this proposal could be soft-forked in very easily.
The shortest explanation is:

    For scriptPubKey outputs of the form "<max-42-byte-push>", where
    the pushed data evaluates as true, a consensus rule is added that
    the coinbase must pay any fee in excess of the minimum fee rate
    for the block to the push value, which is a scriptPubKey.

Beyond fixing the perceived problems of bitcoin's fee auction model
leading to costly strategic behavior (whether that is a problem is a
topic open to debate!), this would have the additional benefits of:

    1. Allowing pre-signed transactions, of payment channel close-out
       for example, to provide sufficient fee for confirmation without
       knowledge of future rates or overpaying or trusting a wallet to
       be online to provide CPFP fee updates.

    2. Allowing explicit fees in multi-party transaction creation
       protocols where final transaction sizes are not known prior to
       signing by one or more of the parties, while again not
       overpaying or trusting on CPFP, etc.

    3. Allowing applications with expensive network access to pay
       reasonable fees for quick confirmation, without overpaying or
       querying a trusted fee estimator.  Blockstream Satellite helps
       here, but rebateable fees provides an alternative option when
       full block feeds are not available for whatever reason.

Using a fee rebate would carry a marginal cost of 70-100 vbytes per
instance.  This makes it a rather expensive feature, and therefore in
my own estimation not something that is likely to be used by most
transactions today.  However the cost is less than CPFP, and so I
expect that it would be a heavily used feature in things like payment
channel refund and uncooperative close-out transactions.


Here is a more worked out proposal, suitable for critiquing:

1. A transaction is allowed to specify an _Implicit Fee_, as usual, as
   well as one or more explicit _Rebateable Fees_.  A rebateable fee
   is an ouput with a scriptPubKey that consists of a single, minimal,
   nonzero push of up to 42 bytes.  Note that this is an always-true
   script that requires no signature to spend.

2. The _Fee Rate_ of a transaction is a fractional number equal to the
   combined implicit and rebateable fee divided by the size/weight of
   the transaction.

   (A nontrivial complication of this, which I will punt on for the
    moment, is how to group transactions for fee rate calculation such
    that CPFP doesn't bring down the minimum fee rate of the block,
    but to do so with rules that are both simple, because this is
    consensus code; and fair, so as to prevent unintended use of a
    rebate fee by children or siblings.)

3. The smallest fee rate of any non-coinbase transaction (or
   transaction group) is the _Marginal Fee Rate_ for the block and is
   included in the witness for the block.

4. The verifier checks that each transaction or transaction grouping
   provides a fee greater than or equal to the threshold fee rate, and
   at least one is exactly equal to the marginal rate (which proves
   the marginal rate is the minimum for the block).

This establishes the marginal fee rate, which alternatively expressed
is epsilon less than the fee rate that would have been required to get
into the block, assuming there was sufficient space.

5. A per-block _Dust Threshold_ is calculated using the marginal fee
   rate and reasonable assumptions about transaction size.

6. For each transaction (or transaction group), the _Required Fee_ is
   calculated to be the marginal fee rate times the size/weight of the
   transaction.  Implicit fee is applied towards this required fee and
   added to the _Miner's Fee Tally_.  Any excess implicit fee
   remaining is added to the _Implicit Fee Tally_.

7. For each transaction (group), the rebateable fees contribute
   proportionally towards towards meeting the remaining marginal fee
   requirement, if the implicit fee failed to do so.  Of what's left,
   one of two things can happen based on how much is remaining:

     A. If greater than or equal to the dust threshold is remaining in
        a specific rebateable fee, a requirement is added that an
        output be provided in the coinbase paying the remaining fee to
        a scriptPubKey equal to the push value (see #1 above).

        (With due consideration for what happens if a script is reused
         in multiple explicit fees, of course.)

     B. Otherwise, add remaining dust to the implicit fee tally.

8. For the very last transaction in the block, the miner builds a
   transaction claiming ALL of these explicit fees, and with a single
   zero-valued null/data output, thereby forwarding the fees on to the
   coinbase, as far as old clients are concerned.  This is only
   concerns consensus in that this final transaction does not change
   any of the previously mentioned tallies.

   (Aside: the zero-valued output is merely required because all
    transactions must have at least one output. It does however make a
    great location to put commitments for extensions to the block
    header, as being on the right-most path of the Merkle tree can
    mean shorter proofs.)

9. The miner is allowed to claim subsidy + the miner's fee tally + the
   explicit fee tally for themselves in the coinbase.  The coinbase is
   also required to contain all rebated fees above the dust threshold.

In summary, all transactions have the same actual fee rate equal to
the minimum fee rate that went into the creation of the block, which
is basically the marginal fee rate for transaction inclusion.

A variant of this proposal is that instead of giving the implicit fee
tally to the miner (the excess non-rebateable fees beyond the required
minimum), it is carried forward from block to block in the final
transaction and the miner is allowed to claim some average of past
fees, thereby smoothing out fees or providing some other incentive.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 659 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/8d6e3b63/attachment.sig>

From pete at petertodd.org  Fri Sep 29 01:45:43 2017
From: pete at petertodd.org (Peter Todd)
Date: Thu, 28 Sep 2017 21:45:43 -0400
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <oqihpf$5gc$1@blaine.gmane.org>
References: <20170927160654.GA12492@savin.petertodd.org>
	<oqihpf$5gc$1@blaine.gmane.org>
Message-ID: <20170929014543.GB11956@savin.petertodd.org>

On Thu, Sep 28, 2017 at 12:09:59PM +0200, Andreas Schildbach via bitcoin-dev wrote:
> This feels redundant to me; the payment protocol already has an
> expiration time.

I'm well aware. As the payment protocol hasn't caught on - and doesn't fully
overlap all the usecases that addresses do anyway - I think we should consider
bringing this important feature to Bitcoin addresses too.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/ad500ed8/attachment.sig>

From pete at petertodd.org  Fri Sep 29 01:50:48 2017
From: pete at petertodd.org (Peter Todd)
Date: Thu, 28 Sep 2017 21:50:48 -0400
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <CAAS2fgRpMXdqKXeYSOtVBQQ9fmu=nQ9anEO6Wrc_5rms1Y2B2w@mail.gmail.com>
References: <20170927160654.GA12492@savin.petertodd.org>
	<CAAS2fgRpMXdqKXeYSOtVBQQ9fmu=nQ9anEO6Wrc_5rms1Y2B2w@mail.gmail.com>
Message-ID: <20170929015048.GC11956@savin.petertodd.org>

On Thu, Sep 28, 2017 at 12:58:30AM +0000, Gregory Maxwell wrote:
> On Wed, Sep 27, 2017 at 4:06 PM, Peter Todd via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > Re-use of old addresses is a major problem, not only for privacy, but also
> > operationally: services like exchanges frequently have problems with users
> > sending funds to addresses whose private keys have been lost or stolen; there
> 
> When Pieter and I were working on Bech32 we specifically designed for
> error correcting codes that had good performance for longer lengths
> than we technically needed specifically to incorporate things like
> dates and explicit amounts.
> 
> (explicit amounts so that typos and bit flips in amounts displayed or
> in memory couldn't result in sending the wrong amount)
> 
> But we also thought that also adding those features at the same time
> would retard adoption-- both due to debating over the encodings and
> because handling would result in different software requirements and
> layering, so you couldn't just drop them in.

Notably, even something as simple as adding a new type of confirmation window
that might be needed is a big chance to UI logic.

> Doubly unfortunately, people have even deployed BIP173 already (prior
> to it even having much peer review or being adopted by its own
> authors), so I think a rethink now wouldn't be timely (I mean as a
> replacement to BIP173 rather than an additional format). :(

Yeah, I just noticed Pieter Wuille's BIP173-including segwit pull-req - that's
a lot of code that would get touched by this proposal, so it's likely too late
in the process.

> But I do support the idea.
> 
> One thing to keep in mind is that address format linked fields are
> most efficient if they're multiples of 5 bits.  Perhaps use 1 bit to
> indicate an embedded amount and 19 bits of 1 day precision, resulting
> in a 1435 year span.

What do you mean by "an embedded amount"?

> Keep in mind that high precision of the expiration times is asking the
> sender to have a higher precision of idea of the time, date only is
> kinda nice.  I think shorter expiration times are unlikely to be
> useful due to clock skew-- you can't assume a signer has any access to
> the Bitcoin network at all.

I'm inclined to agree as well. Also, Bitcoin payments themselves are inherently
imprecise, because blocks aren't found on a regular interval - Coinbase's "10
minute" payment expiry window is odd from that point of view.

Having said that, you'd want a resolution more precise than what you'd expect
timeouts to be set at, to avoid UI "fencepost" oddity; if I want to set a 1 day
timeout, users shouldn't see either 1 or 2 days depending on exactly which way
it happened to be rounded that particular time..

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/04ab3f7f/attachment.sig>

From pete at petertodd.org  Fri Sep 29 01:52:00 2017
From: pete at petertodd.org (Peter Todd)
Date: Thu, 28 Sep 2017 21:52:00 -0400
Subject: [bitcoin-dev] Revising BIP 2 to expand editorial authority
In-Reply-To: <CABaSBaz=pMfTz2UF-WpyxrkGY9XZO+zTHR7-Oie79J1Ap10hpQ@mail.gmail.com>
References: <201709271856.27376.luke@dashjr.org>
	<CABaSBaz=pMfTz2UF-WpyxrkGY9XZO+zTHR7-Oie79J1Ap10hpQ@mail.gmail.com>
Message-ID: <20170929015200.GD11956@savin.petertodd.org>

On Wed, Sep 27, 2017 at 02:01:40PM -0500, Bryan Bishop via bitcoin-dev wrote:
> On Wed, Sep 27, 2017 at 1:56 PM, Luke Dashjr via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> > What do people think about modifying BIP 2 to allow editors to merge these
> > kinds of changes without involving the Authors? Strictly speaking, BIP 2
> > shouldn't be changed now that it is Active, but for such a minor revision,
> > I
> > think an exception is reasonable.
> >
> 
> Even minor revisions can not change the meaning of text. Changing a single
> word can often have a strange impact on the meaning of the text. There
> should be some amount of care exercised here. Maybe it would be okay as
> long as edits are mentioned in the changelog at the bottom of each
> document, or mention that the primary authors have not reviewed suggested
> changes, or something as much; otherwise the reader might not be aware to
> check revision history to see what's going on.

As part of this, we may want to say that the BIP editor should
cryptographically sign (and ideally timestamp) all their changes as a secondary
measure to make it clear who actually made the change.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/086e86a5/attachment-0001.sig>

From lf-lists at mattcorallo.com  Fri Sep 29 01:53:55 2017
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Fri, 29 Sep 2017 01:53:55 +0000
Subject: [bitcoin-dev] Rebatable fees & incentive-safe fee markets
In-Reply-To: <359FFE85-86AF-4FBD-9491-3528382E5002@friedenbach.org>
References: <359FFE85-86AF-4FBD-9491-3528382E5002@friedenbach.org>
Message-ID: <DC1B3730-756E-4A9B-BE6E-481B78E4104D@mattcorallo.com>

I'm somewhat curious what the authors envisioned the real-world implications of this model to be. While blindly asking users to enter what they're willing to pay always works in theory, I'd imagine in such a world the fee selection UX would be similar to what it is today - users are provided a list of options with feerates and expected confirmation times from which to select. Indeed, in a world where users pay a lower fee if they paid more than necessary fee estimation could be more willing to overshoot and the UX around RBF and CPFP could be simplified greatly, but I'm not actually convinced that it would result in higher overall mining revenue.

The UX issues with RBF and CPFP, not to mention the UX issues involved in optimizing for quick confirmation are, indeed, quite significant, but I believe them to be solveable with rather striaght-forward changes. Making the market more useable (for higher or lower overall miner revenue) may be a sufficient goal, however, to want to consider something like this.

On September 28, 2017 9:06:29 PM EDT, Mark Friedenbach via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>This article by Ron Lavi, Or Sattath, and Aviv Zohar was forwarded to
>me and is of interest to this group:
>
>    "Redesigning Bitcoin's fee market"
>    https://arxiv.org/abs/1709.08881
>
>I'll briefly summarize before providing some commentary of my own,
>including transformation of the proposed mechanism into a relatively
>simple soft-fork.  The article points out that bitcoin's auction
>model for transaction fees / inclusion in a block is broken in the
>sense that it does not achieve maximum clearing price* and to prevent
>strategic bidding behavior.
>
>(* Maximum clearing price meaning highest fee the user is willing to
>   pay for the amount of time they had to wait.  In other words, miner
>   income.  While this is a common requirement of academic work on
>   auction protocols, it's not obvious that it provides intrinsic
>   benefit to bitcoin for miners to extract from users the maximum
>   amount of fee the market is willing to support.  However strategic
>   bidding behavior (e.g. RBF and CPFP) does have real network and
>   usability costs, which a more "correct" auction model would reduce
>   in some use cases.)
>
>Bitcoin is a "pay your bid" auction, where the user makes strategic
>calculations to determine what bid (=fee) is likely to get accepted
>within the window of time in which they want confirmation.  This bid
>can then be adjusted through some combination of RBF or CPFP.
>
>The authors suggest moving to a "pay lowest winning bid" model where
>all transactions pay only the smallest fee rate paid by any
>transaction in the block, for which the winning strategy is to bid the
>maximum amount you are willing to pay to get the transaction
>confirmed:
>
>> Users can then simply set their bids truthfully to exactly the
>> amount they are willing to pay to transact, and do not need to
>> utilize fee estimate mechanisms, do not resort to bid shading and do
>> not need to adjust transaction fees (via replace-by-fee mechanisms)
>> if the mempool grows.
>
>
>Unlike other proposed fixes to the fee model, this is not trivially
>broken by paying the miner out of band.  If you pay out of band fee
>instead of regular fee, then your transaction cannot be included with
>other regular fee paying transactions without the miner giving up all
>regular fee income.  Any transaction paying less fee in-band than the
>otherwise minimum fee rate needs to also provide ~1Mvbyte * fee rate
>difference fee to make up for that lost income.  So out of band fee is
>only realistically considered when it pays on top of a regular feerate
>paying transaction that would have been included in the block anyway.
>And what would be the point of that?
>
>
>As an original contribution, I would like to note that something
>strongly resembling this proposal could be soft-forked in very easily.
>The shortest explanation is:
>
>    For scriptPubKey outputs of the form "<max-42-byte-push>", where
>    the pushed data evaluates as true, a consensus rule is added that
>    the coinbase must pay any fee in excess of the minimum fee rate
>    for the block to the push value, which is a scriptPubKey.
>
>Beyond fixing the perceived problems of bitcoin's fee auction model
>leading to costly strategic behavior (whether that is a problem is a
>topic open to debate!), this would have the additional benefits of:
>
>    1. Allowing pre-signed transactions, of payment channel close-out
>       for example, to provide sufficient fee for confirmation without
>       knowledge of future rates or overpaying or trusting a wallet to
>       be online to provide CPFP fee updates.
>
>    2. Allowing explicit fees in multi-party transaction creation
>       protocols where final transaction sizes are not known prior to
>       signing by one or more of the parties, while again not
>       overpaying or trusting on CPFP, etc.
>
>    3. Allowing applications with expensive network access to pay
>       reasonable fees for quick confirmation, without overpaying or
>       querying a trusted fee estimator.  Blockstream Satellite helps
>       here, but rebateable fees provides an alternative option when
>       full block feeds are not available for whatever reason.
>
>Using a fee rebate would carry a marginal cost of 70-100 vbytes per
>instance.  This makes it a rather expensive feature, and therefore in
>my own estimation not something that is likely to be used by most
>transactions today.  However the cost is less than CPFP, and so I
>expect that it would be a heavily used feature in things like payment
>channel refund and uncooperative close-out transactions.
>
>
>Here is a more worked out proposal, suitable for critiquing:
>
>1. A transaction is allowed to specify an _Implicit Fee_, as usual, as
>   well as one or more explicit _Rebateable Fees_.  A rebateable fee
>   is an ouput with a scriptPubKey that consists of a single, minimal,
>   nonzero push of up to 42 bytes.  Note that this is an always-true
>   script that requires no signature to spend.
>
>2. The _Fee Rate_ of a transaction is a fractional number equal to the
>   combined implicit and rebateable fee divided by the size/weight of
>   the transaction.
>
>   (A nontrivial complication of this, which I will punt on for the
>    moment, is how to group transactions for fee rate calculation such
>    that CPFP doesn't bring down the minimum fee rate of the block,
>    but to do so with rules that are both simple, because this is
>    consensus code; and fair, so as to prevent unintended use of a
>    rebate fee by children or siblings.)
>
>3. The smallest fee rate of any non-coinbase transaction (or
>   transaction group) is the _Marginal Fee Rate_ for the block and is
>   included in the witness for the block.
>
>4. The verifier checks that each transaction or transaction grouping
>   provides a fee greater than or equal to the threshold fee rate, and
>   at least one is exactly equal to the marginal rate (which proves
>   the marginal rate is the minimum for the block).
>
>This establishes the marginal fee rate, which alternatively expressed
>is epsilon less than the fee rate that would have been required to get
>into the block, assuming there was sufficient space.
>
>5. A per-block _Dust Threshold_ is calculated using the marginal fee
>   rate and reasonable assumptions about transaction size.
>
>6. For each transaction (or transaction group), the _Required Fee_ is
>   calculated to be the marginal fee rate times the size/weight of the
>   transaction.  Implicit fee is applied towards this required fee and
>   added to the _Miner's Fee Tally_.  Any excess implicit fee
>   remaining is added to the _Implicit Fee Tally_.
>
>7. For each transaction (group), the rebateable fees contribute
>   proportionally towards towards meeting the remaining marginal fee
>   requirement, if the implicit fee failed to do so.  Of what's left,
>   one of two things can happen based on how much is remaining:
>
>     A. If greater than or equal to the dust threshold is remaining in
>        a specific rebateable fee, a requirement is added that an
>        output be provided in the coinbase paying the remaining fee to
>        a scriptPubKey equal to the push value (see #1 above).
>
>        (With due consideration for what happens if a script is reused
>         in multiple explicit fees, of course.)
>
>     B. Otherwise, add remaining dust to the implicit fee tally.
>
>8. For the very last transaction in the block, the miner builds a
>   transaction claiming ALL of these explicit fees, and with a single
>   zero-valued null/data output, thereby forwarding the fees on to the
>   coinbase, as far as old clients are concerned.  This is only
>   concerns consensus in that this final transaction does not change
>   any of the previously mentioned tallies.
>
>   (Aside: the zero-valued output is merely required because all
>    transactions must have at least one output. It does however make a
>    great location to put commitments for extensions to the block
>    header, as being on the right-most path of the Merkle tree can
>    mean shorter proofs.)
>
>9. The miner is allowed to claim subsidy + the miner's fee tally + the
>   explicit fee tally for themselves in the coinbase.  The coinbase is
>   also required to contain all rebated fees above the dust threshold.
>
>In summary, all transactions have the same actual fee rate equal to
>the minimum fee rate that went into the creation of the block, which
>is basically the marginal fee rate for transaction inclusion.
>
>A variant of this proposal is that instead of giving the implicit fee
>tally to the miner (the excess non-rebateable fees beyond the required
>minimum), it is carried forward from block to block in the final
>transaction and the miner is allowed to claim some average of past
>fees, thereby smoothing out fees or providing some other incentive.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/8028683c/attachment.html>

From pete at petertodd.org  Fri Sep 29 02:02:27 2017
From: pete at petertodd.org (Peter Todd)
Date: Thu, 28 Sep 2017 22:02:27 -0400
Subject: [bitcoin-dev] Rebatable fees & incentive-safe fee markets
In-Reply-To: <359FFE85-86AF-4FBD-9491-3528382E5002@friedenbach.org>
References: <359FFE85-86AF-4FBD-9491-3528382E5002@friedenbach.org>
Message-ID: <20170929020227.GA12192@savin.petertodd.org>

On Thu, Sep 28, 2017 at 06:06:29PM -0700, Mark Friedenbach via bitcoin-dev wrote:
> Unlike other proposed fixes to the fee model, this is not trivially
> broken by paying the miner out of band.  If you pay out of band fee
> instead of regular fee, then your transaction cannot be included with
> other regular fee paying transactions without the miner giving up all
> regular fee income.  Any transaction paying less fee in-band than the
> otherwise minimum fee rate needs to also provide ~1Mvbyte * fee rate
> difference fee to make up for that lost income.  So out of band fee is
> only realistically considered when it pays on top of a regular feerate
> paying transaction that would have been included in the block anyway.
> And what would be the point of that?

This proposed fix is itself broken, because the miner can easily include *only*
transactions paying out-of-band, at which point the fee can be anything.
Equally, miners can provide fee *rebates*, forcing up prices for everyone else
while still allowing them to make deals.

Also, remember that you can pay fees via anyone-can-spend outputs, as miners
have full ability to control what transactions end up spending those outputs.

The fact these countermeasures are all likely to be implemented - all of which
harm the overall ecosystem by reducing visibility of fees and making it harder
to compete with centralized miners - makes me very dubious about that proposal.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/84259421/attachment.sig>

From greg at xiph.org  Fri Sep 29 02:06:54 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Fri, 29 Sep 2017 02:06:54 +0000
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <20170929015048.GC11956@savin.petertodd.org>
References: <20170927160654.GA12492@savin.petertodd.org>
	<CAAS2fgRpMXdqKXeYSOtVBQQ9fmu=nQ9anEO6Wrc_5rms1Y2B2w@mail.gmail.com>
	<20170929015048.GC11956@savin.petertodd.org>
Message-ID: <CAAS2fgSZnaUvxC1ErfyKADvEocF1pAk=9VU55hQWwNbNyAho4w@mail.gmail.com>

On Fri, Sep 29, 2017 at 1:50 AM, Peter Todd <pete at petertodd.org> wrote:
> What do you mean by "an embedded amount"?

I ask you to pay 1 Bitcoin to bc1blahblah.

...you make a typo, or a poorly placed cosmic ray switches it in your
ram to bc1blohblahbah.   No problem, it'll get rejected. (even if the
cosmic ray happens just before signing... if the software is robust
it'll reencode from the signed transaction and check against the
original input.

But if instead the typo converts it to 2 Bitcoins or the cosmic ray
converts it to 2.34217728... the payment will happily go through,
assuming your wallet had enough, and you're stuck asking me to refund
you the excess.

Sure, you can put amounts in URIs and whatnot, but they're not error
protected... so there will always be unprotected poritons where a
glitch can radically change the amount.

In many cases you know exactly what amount you're asking for when you
generate an address. There isn't any reason the amount couldn't be
covered by the addresses checksum in those cases.

There are a couple ways of doing that... e.g. adding it explicitly,
where the checksum includes it but not the address itself; so it
errors out if you get it wrong. But this is unfortunate because it
can't tell you the expected amount when its wrong.   Another way would
be to embed the amount in the address, and then the software can tell
you the amount the address was expecting and not let you proceed until
they match.

From pete at petertodd.org  Fri Sep 29 02:10:33 2017
From: pete at petertodd.org (Peter Todd)
Date: Thu, 28 Sep 2017 22:10:33 -0400
Subject: [bitcoin-dev] Rebatable fees & incentive-safe fee markets
In-Reply-To: <DC1B3730-756E-4A9B-BE6E-481B78E4104D@mattcorallo.com>
References: <359FFE85-86AF-4FBD-9491-3528382E5002@friedenbach.org>
	<DC1B3730-756E-4A9B-BE6E-481B78E4104D@mattcorallo.com>
Message-ID: <20170929021033.GA12303@savin.petertodd.org>

On Fri, Sep 29, 2017 at 01:53:55AM +0000, Matt Corallo via bitcoin-dev wrote:
> I'm somewhat curious what the authors envisioned the real-world implications of this model to be. While blindly asking users to enter what they're willing to pay always works in theory, I'd imagine in such a world the fee selection UX would be similar to what it is today - users are provided a list of options with feerates and expected confirmation times from which to select. Indeed, in a world where users pay a lower fee if they paid more than necessary fee estimation could be more willing to overshoot and the UX around RBF and CPFP could be simplified greatly, but I'm not actually convinced that it would result in higher overall mining revenue.

Note too that the fee users are willing to pay often changes over time.

My OpenTimestamps service is a perfect example: getting a timestamp confirmed
within 10 minutes of the previous one has little value to me, but if the
previous completed timestamp was 24 hours ago I'm willing to pay significantly
more money because the time delay is getting significant enough to affect the
trustworthyness of the entire service. So the fee selection mechanism is
nothing more than a RBF-using loop that bumps the fee every time a block gets
mined w/o confirming my latest transaction.

This kind of time sensitivity is probably true of a majority of Bitcoin
use-cases, with the caveat that often the slope will be negative eventually:
after a point in time completing the transaction has no value.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/054c801c/attachment.sig>

From pete at petertodd.org  Fri Sep 29 02:18:46 2017
From: pete at petertodd.org (Peter Todd)
Date: Thu, 28 Sep 2017 22:18:46 -0400
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <B5DE4E92-C5B3-4C01-A148-E3C46C897323@sprovoost.nl>
References: <20170927160654.GA12492@savin.petertodd.org>
	<oqihpf$5gc$1@blaine.gmane.org>
	<B5DE4E92-C5B3-4C01-A148-E3C46C897323@sprovoost.nl>
Message-ID: <20170929021846.GB12303@savin.petertodd.org>

On Thu, Sep 28, 2017 at 03:43:05PM +0300, Sjors Provoost via bitcoin-dev wrote:
> Peter Todd wrote:
> Perhaps outside the scope of BIP173, but what about baking it into the protocol? That way a transaction that's sent too late, simply won't get confirmed. This removes the need for refund logic or asking a customer to pay just a few extra cents. You could also disallow a second payment.
> 
> Two downsides I can think of:
> * privacy, as differences in expiration policy would be visible on chain
> * miners might be able to game it in their interaction with brokers

This has been discussed many times before; there are *severe* downsides to
making it possible for transactions to become invalid after the fact.

> > Being just an expiration time, seconds-level resolution is unnecessary, and
> > may give the wrong impression. I'd suggest either:
> > 
> > 1) Hour resolution - 2^24 hours = 1914 years
> > 2) Month resolution - 2^16 months = 5458 years
> 
> So that's 4.8 characters for hours, or 3.2 for years, plus checksum space? The shorter the better. Perhaps one or two bits can be used to specify an exponent; a large range seems more useful than high precision. For instance a merchant doesn't care if the customer pays within 10:00:00 minutes or 10:00:01 minutes and you wouldn't care if your address is valid 50 years or 50 years and 3 minutes. This point may be mute if minute level resolution is not practical.

Note that "large range" is a requirement driven by the fact that expiry times
will inevitably be specified absolutely, not relatively: when the range runs
out you need to upgrade the standard. Better to use another character and use a
range that won't run out any time soon.

This wouldn't create a need for more checksum space.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/04fb5921/attachment.sig>

From pete at petertodd.org  Fri Sep 29 02:55:38 2017
From: pete at petertodd.org (Peter Todd)
Date: Thu, 28 Sep 2017 22:55:38 -0400
Subject: [bitcoin-dev] Why the BIP-72 Payment Protocol URI Standard is
 Insecure Against MITM Attacks
In-Reply-To: <B5DE4E92-C5B3-4C01-A148-E3C46C897323@sprovoost.nl>
References: <20170927160654.GA12492@savin.petertodd.org>
	<oqihpf$5gc$1@blaine.gmane.org>
	<B5DE4E92-C5B3-4C01-A148-E3C46C897323@sprovoost.nl>
Message-ID: <20170929025538.GC12303@savin.petertodd.org>

On Thu, Sep 28, 2017 at 03:43:05PM +0300, Sjors Provoost via bitcoin-dev wrote:
> Andreas Schildbach wrote:
> > This feels redundant to me; the payment protocol already has an
> > expiration time.
> 
> The BIP-70 payment protocol has significant overhead and most importantly requires back and forth. Emailing a bitcoin address or printing it on an invoice is much easier, so I would expect people to keep doing that.

The BIP-70 payment protocol used via BIP-72 URI's is insecure, as payment qr
codes don't cryptographically commit to the identity of the merchant, which
means a MITM attacker can redirect the payment if they can obtain a SSL cert
that the wallet accepts.

For example, if I have a wallet on my phone and go to pay a
merchant, a BIP-72 URI will look like the following(1):

    bitcoin:mq7se9wy2egettFxPbmn99cK8v5AFq55Lx?amount=0.11&r=https://merchant.com/pay.php?h%3D2a8628fc2fbe

A wallet following the BIP-72 standard will "ignore the bitcoin
address/amount/label/message in the URI and instead fetch a PaymentRequest
message and then follow the payment protocol, as described in BIP 70."

So my phone will make a second connection - likely on a second network with a
totally different set of MITM attackers - to https://merchant.com

In short, while my browser may have gotten the correct URL with the correct
Bitcoin address, by using the payment protocol my wallet is discarding that
information and giving MITM attackers a second chance at redirecting my payment
to them. That wallet is also likely using an off-the-shelf SSL library, with
nothing other than an infrequently updated set of root certificates to use to
verify the certificate; your browser has access to a whole host of better
technologies, such as HSTS pinning, certificate transparency, and frequently
updated root certificate lists with proper revocation (see Symantec).

As an ad-hoc, unstandardized, extension Android Wallet for Bitcoin at least
supports a h= parameter with a hash commitment to what the payment request
should be, and will reject the MITM attacker if that hash doesn't match. But
that's not actually in the standard itself, and as far as I can tell has never
been made into a BIP.

As-is BIP-72 is very dangerous and should be depreciated, with a new BIP made
to replace it.

1) As an aside, it's absolutely hilarious that this URL taken straight from
   BIP-72 has the merchant using PHP, given its truly terrible track record for
   security.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/09e0db5f/attachment.sig>

From pete at petertodd.org  Fri Sep 29 03:02:25 2017
From: pete at petertodd.org (Peter Todd)
Date: Thu, 28 Sep 2017 23:02:25 -0400
Subject: [bitcoin-dev] Rebatable fees & incentive-safe fee markets
In-Reply-To: <FAD5BE01-52B5-49C6-B018-47BF234A5EF2@friedenbach.org>
References: <359FFE85-86AF-4FBD-9491-3528382E5002@friedenbach.org>
	<20170929020227.GA12192@savin.petertodd.org>
	<FAD5BE01-52B5-49C6-B018-47BF234A5EF2@friedenbach.org>
Message-ID: <20170929030225.GA12614@savin.petertodd.org>

On Thu, Sep 28, 2017 at 07:45:02PM -0700, Mark Friedenbach wrote:
> 
> 
> > On Sep 28, 2017, at 7:02 PM, Peter Todd <pete at petertodd.org> wrote:
> > 
> >> On Thu, Sep 28, 2017 at 06:06:29PM -0700, Mark Friedenbach via bitcoin-dev wrote:
> >> Unlike other proposed fixes to the fee model, this is not trivially
> >> broken by paying the miner out of band.  If you pay out of band fee
> >> instead of regular fee, then your transaction cannot be included with
> >> other regular fee paying transactions without the miner giving up all
> >> regular fee income.  Any transaction paying less fee in-band than the
> >> otherwise minimum fee rate needs to also provide ~1Mvbyte * fee rate
> >> difference fee to make up for that lost income.  So out of band fee is
> >> only realistically considered when it pays on top of a regular feerate
> >> paying transaction that would have been included in the block anyway.
> >> And what would be the point of that?
> > 
> > This proposed fix is itself broken, because the miner can easily include *only*
> > transactions paying out-of-band, at which point the fee can be anything.
> 
> And in doing so either reduce the claimable income from other transactions (miner won?t do that), or require paying more non-rebateable fee than is needed to get in the block (why would the user do that?)
> 
> This is specifically addressed in the text you quoted. 

I specifically outlined a scenario where that text isn't relevant: *all*
transaction in a block can be paying out of band.

> > Equally, miners can provide fee *rebates*, forcing up prices for everyone else
> > while still allowing them to make deals.
> 
> Discounted by the fact rebates would not be honored by other miners. The rebate would have to be higher than what they could get from straight fee collection, making it less profitable than doing nothing. 

You're making the incorrect assumption that all transactions have to be
broadcast publicly; they don't.

> > Also, remember that you can pay fees via anyone-can-spend outputs, as miners
> > have full ability to control what transactions end up spending those outputs.
> 
> You?d still have to pay the minimum fee rate of the other transactions or you?d bring down the miners income. Otherwise this is nearly the same cost as the rebate fee, since they both involve explicit outputs claimed by the miner, but the rebate goes back to you. So why would you not want to do that instead?
> 
> A different way of looking at this proposal is that it creates a penalty for out of band payments. 

It certainly does not. It simply adds another level of complexity and overhead
to the out-of-band payment situation, which is not desirable. If we can't
eliminate out of band payments entirely, we do not want to make the playing
field of them even more unbalanced than it already is.

This is a typical academic proposal that only considers first order effects
while ignoring second order effects.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/830d78cd/attachment.sig>

From nathan at z.cash  Fri Sep 29 02:09:13 2017
From: nathan at z.cash (Nathan Wilcox)
Date: Fri, 29 Sep 2017 11:09:13 +0900
Subject: [bitcoin-dev] Rebatable fees & incentive-safe fee markets
In-Reply-To: <DC1B3730-756E-4A9B-BE6E-481B78E4104D@mattcorallo.com>
References: <359FFE85-86AF-4FBD-9491-3528382E5002@friedenbach.org>
	<DC1B3730-756E-4A9B-BE6E-481B78E4104D@mattcorallo.com>
Message-ID: <CAK8perD6VNqbwcgw9bQA=+VdEnS8fWg0nE16PQbvPAvRCn81Bg@mail.gmail.com>

Happy to see Mark Friedenbach's strawman implementation. Two clarifying
verifications:

This implementation would allow old-style implicit fees which would have
the same behavior (Pay-Your-Bid). Correct?

In terms of space costs, rebateable fee txns (or CPFP chains, I'm less
clear on that complication) add one UTXO 'internally' and new consensus
rules require one UTXO in the coinbase for the rebate, correct?


As for the paper itself: it doesn't account for high-latency/low-fee usage,
correct? What if I want a transaction to complete anytime in the next N
days for as cheap as given some probability of success?

This has two parts: a. Is there a clear/clean game-theoretic-compatible UX
for users? b. would the implementation be simple enough? If either a is
'no' or b is 'complicated', then the trade-off might not be much better
than the status quo.

Maybe for a high enough latency, the answer to a is 'yes' and b. is
'simple' by this strawman: try a tiny fee, if that doesn't work, try a new
higher fee and repeat. Is that good enough?

regards.
Nathan


On Fri, Sep 29, 2017 at 10:53 AM, Matt Corallo via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I'm somewhat curious what the authors envisioned the real-world
> implications of this model to be. While blindly asking users to enter what
> they're willing to pay always works in theory, I'd imagine in such a world
> the fee selection UX would be similar to what it is today - users are
> provided a list of options with feerates and expected confirmation times
> from which to select. Indeed, in a world where users pay a lower fee if
> they paid more than necessary fee estimation could be more willing to
> overshoot and the UX around RBF and CPFP could be simplified greatly, but
> I'm not actually convinced that it would result in higher overall mining
> revenue.
>
> The UX issues with RBF and CPFP, not to mention the UX issues involved in
> optimizing for quick confirmation are, indeed, quite significant, but I
> believe them to be solveable with rather striaght-forward changes. Making
> the market more useable (for higher or lower overall miner revenue) may be
> a sufficient goal, however, to want to consider something like this.
>
>
> On September 28, 2017 9:06:29 PM EDT, Mark Friedenbach via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> This article by Ron Lavi, Or Sattath, and Aviv Zohar was forwarded to
>> me and is of interest to this group:
>>
>>     "Redesigning Bitcoin's fee market"
>>     https://arxiv.org/abs/1709.08881
>>
>> I'll briefly summarize before providing some commentary of my own,
>> including transformation of the proposed mechanism into a relatively
>> simple soft-fork.  The article points out that bitcoin's auction
>> model for transaction fees / inclusion in a block is broken in the
>> sense that it does not achieve maximum clearing price* and to prevent
>> strategic bidding behavior.
>>
>> (* Maximum clearing price meaning highest fee the user is willing to
>>    pay for the amount of time they had to wait.  In other words, miner
>>    income.  While this is a common requirement of academic work on
>>    auction protocols, it's not obvious that it provides intrinsic
>>    benefit to bitcoin for miners to extract from users the maximum
>>    amount of fee the market is willing to support.  However strategic
>>    bidding behavior (e.g. RBF and CPFP) does have real network and
>>    usability costs, which a more "correct" auction model would reduce
>>    in some use cases.)
>>
>> Bitcoin is a "pay your bid" auction, where the user makes strategic
>> calculations to determine what bid (=fee) is likely to get accepted
>> within the window of time in which they want confirmation.  This bid
>> can then be adjusted through some combination of RBF or CPFP.
>>
>> The authors suggest moving to a "pay lowest winning bid" model where
>> all transactions pay only the smallest fee rate paid by any
>> transaction in the block, for which the winning strategy is to bid the
>> maximum amount you are willing to pay to get the transaction
>> confirmed:
>>
>>  Users can then simply set their bids truthfully to exactly the
>>>  amount they are willing to pay to transact, and do not need to
>>>  utilize fee estimate mechanisms, do not resort to bid shading and do
>>>  not need to adjust transaction fees (via replace-by-fee mechanisms)
>>>  if the mempool grows.
>>>
>>
>>
>> Unlike other proposed fixes to the fee model, this is not trivially
>> broken by paying the miner out of band.  If you pay out of band fee
>> instead of regular fee, then your transaction cannot be included with
>> other regular fee paying transactions without the miner giving up all
>> regular fee income.  Any transaction paying less fee in-band than the
>> otherwise minimum fee rate needs to also provide ~1Mvbyte * fee rate
>> difference fee to make up for that lost income.  So out of band fee is
>> only realistically considered when it pays on top of a regular feerate
>> paying transaction that would have been included in the block anyway.
>> And what would be the point of that?
>>
>>
>> As an original contribution, I would like to note that something
>> strongly resembling this proposal could be soft-forked in very easily.
>> The shortest explanation is:
>>
>>     For scriptPubKey outputs of the form "<max-42-byte-push>", where
>>     the pushed data evaluates as true, a consensus rule is added that
>>     the coinbase must pay any fee in excess of the minimum fee rate
>>     for the block to the push value, which is a scriptPubKey.
>>
>> Beyond fixing the perceived problems of bitcoin's fee auction model
>> leading to costly strategic behavior (whether that is a problem is a
>> topic open to debate!), this would have the additional benefits of:
>>
>>     1. Allowing pre-signed transactions, of payment channel close-out
>>        for example, to provide sufficient fee for confirmation without
>>        knowledge of future rates or overpaying or trusting a wallet to
>>        be online to provide CPFP fee updates.
>>
>>     2. Allowing explicit fees in multi-party transaction creation
>>        protocols where final transaction sizes are not known prior to
>>        signing by one or more of the parties, while again not
>>        overpaying or trusting on CPFP, etc.
>>
>>     3. Allowing applications with expensive network access to pay
>>        reasonable fees for quick confirmation, without overpaying or
>>        querying a trusted fee estimator.  Blockstream Satellite helps
>>        here, but rebateable fees provides an alternative option when
>>        full block feeds are not available for whatever reason.
>>
>> Using a fee rebate would carry a marginal cost of 70-100 vbytes per
>> instance.  This makes it a rather expensive feature, and therefore in
>> my own estimation not something that is likely to be used by most
>> transactions today.  However the cost is less than CPFP, and so I
>> expect that it would be a heavily used feature in things like payment
>> channel refund and uncooperative close-out transactions.
>>
>>
>> Here is a more worked out proposal, suitable for critiquing:
>>
>> 1. A transaction is allowed to specify an _Implicit Fee_, as usual, as
>>    well as one or more explicit _Rebateable Fees_.  A rebateable fee
>>    is an ouput with a scriptPubKey that consists of a single, minimal,
>>    nonzero push of up to 42 bytes.  Note that this is an always-true
>>    script that requires no signature to spend.
>>
>> 2. The _Fee Rate_ of a transaction is a fractional number equal to the
>>    combined implicit and rebateable fee divided by the size/weight of
>>    the transaction.
>>
>>    (A nontrivial complication of this, which I will punt on for the
>>     moment, is how to group transactions for fee rate calculation such
>>     that CPFP doesn't bring down the minimum fee rate of the block,
>>     but to do so with rules that are both simple, because this is
>>     consensus code; and fair, so as to prevent unintended use of a
>>     rebate fee by children or siblings.)
>>
>> 3. The smallest fee rate of any non-coinbase transaction (or
>>    transaction group) is the _Marginal Fee Rate_ for the block and is
>>    included in the witness for the block.
>>
>> 4. The verifier checks that each transaction or transaction grouping
>>    provides a fee greater than or equal to the threshold fee rate, and
>>    at least one is exactly equal to the marginal rate (which proves
>>    the marginal rate is the minimum for the block).
>>
>> This establishes the marginal fee rate, which alternatively expressed
>> is epsilon less than the fee rate that would have been required to get
>> into the block, assuming there was sufficient space.
>>
>> 5. A per-block _Dust Threshold_ is calculated using the marginal fee
>>    rate and reasonable assumptions about transaction size.
>>
>> 6. For each transaction (or transaction group), the _Required Fee_ is
>>    calculated to be the marginal fee rate times the size/weight of the
>>    transaction.  Implicit fee is applied towards this required fee and
>>    added to the _Miner's Fee Tally_.  Any excess implicit fee
>>    remaining is added to the _Implicit Fee Tally_.
>>
>> 7. For each transaction (group), the rebateable fees contribute
>>    proportionally towards towards meeting the remaining marginal fee
>>    requirement, if the implicit fee failed to do so.  Of what's left,
>>    one of two things can happen based on how much is remaining:
>>
>>      A. If greater than or equal to the dust threshold is remaining in
>>         a specific rebateable fee, a requirement is added that an
>>         output be provided in the coinbase paying the remaining fee to
>>         a scriptPubKey equal to the push value (see #1 above).
>>
>>         (With due consideration for what happens if a script is reused
>>          in multiple explicit fees, of course.)
>>
>>      B. Otherwise, add remaining dust to the implicit fee tally.
>>
>> 8. For the very last transaction in the block, the miner builds a
>>    transaction claiming ALL of these explicit fees, and with a single
>>    zero-valued null/data output, thereby forwarding the fees on to the
>>    coinbase, as far as old clients are concerned.  This is only
>>    concerns consensus in that this final transaction does not change
>>    any of the previously mentioned tallies.
>>
>>    (Aside: the zero-valued output is merely required because all
>>     transactions must have at least one output. It does however make a
>>     great location to put commitments for extensions to the block
>>     header, as being on the right-most path of the Merkle tree can
>>     mean shorter proofs.)
>>
>> 9. The miner is allowed to claim subsidy + the miner's fee tally + the
>>    explicit fee tally for themselves in the coinbase.  The coinbase is
>>    also required to contain all rebated fees above the dust threshold.
>>
>> In summary, all transactions have the same actual fee rate equal to
>> the minimum fee rate that went into the creation of the block, which
>> is basically the marginal fee rate for transaction inclusion.
>>
>> A variant of this proposal is that instead of giving the implicit fee
>> tally to the miner (the excess non-rebateable fees beyond the required
>> minimum), it is carried forward from block to block in the final
>> transaction and the miner is allowed to claim some average of past
>> fees, thereby smoothing out fees or providing some other incentive.
>>
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/c4b50f5d/attachment-0001.html>

From nathan at z.cash  Fri Sep 29 02:17:05 2017
From: nathan at z.cash (Nathan Wilcox)
Date: Fri, 29 Sep 2017 11:17:05 +0900
Subject: [bitcoin-dev] Rebatable fees & incentive-safe fee markets
In-Reply-To: <20170929021033.GA12303@savin.petertodd.org>
References: <359FFE85-86AF-4FBD-9491-3528382E5002@friedenbach.org>
	<DC1B3730-756E-4A9B-BE6E-481B78E4104D@mattcorallo.com>
	<20170929021033.GA12303@savin.petertodd.org>
Message-ID: <CAK8perBDQDN0WvOn3bVxDHCVLjn=chg9=pVoBsVa6U67Qox8GQ@mail.gmail.com>

On Fri, Sep 29, 2017 at 11:10 AM, Peter Todd via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Fri, Sep 29, 2017 at 01:53:55AM +0000, Matt Corallo via bitcoin-dev
> wrote:
> > I'm somewhat curious what the authors envisioned the real-world
> implications of this model to be. While blindly asking users to enter what
> they're willing to pay always works in theory, I'd imagine in such a world
> the fee selection UX would be similar to what it is today - users are
> provided a list of options with feerates and expected confirmation times
> from which to select. Indeed, in a world where users pay a lower fee if
> they paid more than necessary fee estimation could be more willing to
> overshoot and the UX around RBF and CPFP could be simplified greatly, but
> I'm not actually convinced that it would result in higher overall mining
> revenue.
>
> Note too that the fee users are willing to pay often changes over time.
>
> My OpenTimestamps service is a perfect example: getting a timestamp
> confirmed
> within 10 minutes of the previous one has little value to me, but if the
> previous completed timestamp was 24 hours ago I'm willing to pay
> significantly
> more money because the time delay is getting significant enough to affect
> the
> trustworthyness of the entire service. So the fee selection mechanism is
> nothing more than a RBF-using loop that bumps the fee every time a block
> gets
> mined w/o confirming my latest transaction.
>
> This kind of time sensitivity is probably true of a majority of Bitcoin
> use-cases, with the caveat that often the slope will be negative
> eventually:
> after a point in time completing the transaction has no value.
>
>
Wouldn't this RBF loop behave pretty much the same in the Monopolistic
Price Mechanism? (I haven't grokked RSOP yet.)

In fact, so long as RBF works, isn't it possible to raise Pay-Your-Bid fees
and Monopolistic Price fees over time to express the time curve preference?



> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/a7352e52/attachment.html>

From mark at friedenbach.org  Fri Sep 29 02:45:02 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Thu, 28 Sep 2017 19:45:02 -0700
Subject: [bitcoin-dev] Rebatable fees & incentive-safe fee markets
In-Reply-To: <20170929020227.GA12192@savin.petertodd.org>
References: <359FFE85-86AF-4FBD-9491-3528382E5002@friedenbach.org>
	<20170929020227.GA12192@savin.petertodd.org>
Message-ID: <FAD5BE01-52B5-49C6-B018-47BF234A5EF2@friedenbach.org>



> On Sep 28, 2017, at 7:02 PM, Peter Todd <pete at petertodd.org> wrote:
> 
>> On Thu, Sep 28, 2017 at 06:06:29PM -0700, Mark Friedenbach via bitcoin-dev wrote:
>> Unlike other proposed fixes to the fee model, this is not trivially
>> broken by paying the miner out of band.  If you pay out of band fee
>> instead of regular fee, then your transaction cannot be included with
>> other regular fee paying transactions without the miner giving up all
>> regular fee income.  Any transaction paying less fee in-band than the
>> otherwise minimum fee rate needs to also provide ~1Mvbyte * fee rate
>> difference fee to make up for that lost income.  So out of band fee is
>> only realistically considered when it pays on top of a regular feerate
>> paying transaction that would have been included in the block anyway.
>> And what would be the point of that?
> 
> This proposed fix is itself broken, because the miner can easily include *only*
> transactions paying out-of-band, at which point the fee can be anything.

And in doing so either reduce the claimable income from other transactions (miner won?t do that), or require paying more non-rebateable fee than is needed to get in the block (why would the user do that?)

This is specifically addressed in the text you quoted. 

> Equally, miners can provide fee *rebates*, forcing up prices for everyone else
> while still allowing them to make deals.

Discounted by the fact rebates would not be honored by other miners. The rebate would have to be higher than what they could get from straight fee collection, making it less profitable than doing nothing. 

> Also, remember that you can pay fees via anyone-can-spend outputs, as miners
> have full ability to control what transactions end up spending those outputs.

You?d still have to pay the minimum fee rate of the other transactions or you?d bring down the miners income. Otherwise this is nearly the same cost as the rebate fee, since they both involve explicit outputs claimed by the miner, but the rebate goes back to you. So why would you not want to do that instead?

A different way of looking at this proposal is that it creates a penalty for out of band payments. 

From mark at friedenbach.org  Fri Sep 29 03:30:27 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Thu, 28 Sep 2017 20:30:27 -0700
Subject: [bitcoin-dev] Rebatable fees & incentive-safe fee markets
In-Reply-To: <CAK8perBDQDN0WvOn3bVxDHCVLjn=chg9=pVoBsVa6U67Qox8GQ@mail.gmail.com>
References: <359FFE85-86AF-4FBD-9491-3528382E5002@friedenbach.org>
	<DC1B3730-756E-4A9B-BE6E-481B78E4104D@mattcorallo.com>
	<20170929021033.GA12303@savin.petertodd.org>
	<CAK8perBDQDN0WvOn3bVxDHCVLjn=chg9=pVoBsVa6U67Qox8GQ@mail.gmail.com>
Message-ID: <53AEC8D5-EF33-434A-85C7-9CF824C1FDF2@friedenbach.org>

Only if your keys are online and the transaction is self-signed. It wouldn?t let you pre-sign a transaction for a third party to broadcast and have it clear at just the market rate in the future. Like a payment channel refund, for example.

> On Sep 28, 2017, at 7:17 PM, Nathan Wilcox via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> 
> 
>> On Fri, Sep 29, 2017 at 11:10 AM, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> On Fri, Sep 29, 2017 at 01:53:55AM +0000, Matt Corallo via bitcoin-dev wrote:
>> > I'm somewhat curious what the authors envisioned the real-world implications of this model to be. While blindly asking users to enter what they're willing to pay always works in theory, I'd imagine in such a world the fee selection UX would be similar to what it is today - users are provided a list of options with feerates and expected confirmation times from which to select. Indeed, in a world where users pay a lower fee if they paid more than necessary fee estimation could be more willing to overshoot and the UX around RBF and CPFP could be simplified greatly, but I'm not actually convinced that it would result in higher overall mining revenue.
>> 
>> Note too that the fee users are willing to pay often changes over time.
>> 
>> My OpenTimestamps service is a perfect example: getting a timestamp confirmed
>> within 10 minutes of the previous one has little value to me, but if the
>> previous completed timestamp was 24 hours ago I'm willing to pay significantly
>> more money because the time delay is getting significant enough to affect the
>> trustworthyness of the entire service. So the fee selection mechanism is
>> nothing more than a RBF-using loop that bumps the fee every time a block gets
>> mined w/o confirming my latest transaction.
>> 
>> This kind of time sensitivity is probably true of a majority of Bitcoin
>> use-cases, with the caveat that often the slope will be negative eventually:
>> after a point in time completing the transaction has no value.
>> 
> 
> Wouldn't this RBF loop behave pretty much the same in the Monopolistic Price Mechanism? (I haven't grokked RSOP yet.)
> 
> In fact, so long as RBF works, isn't it possible to raise Pay-Your-Bid fees and Monopolistic Price fees over time to express the time curve preference?
> 
>  
>> --
>> https://petertodd.org 'peter'[:-1]@petertodd.org
>> 
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170928/acc90653/attachment.html>

From aj at erisian.com.au  Fri Sep 29 04:45:56 2017
From: aj at erisian.com.au (Anthony Towns)
Date: Fri, 29 Sep 2017 14:45:56 +1000
Subject: [bitcoin-dev] Rebatable fees & incentive-safe fee markets
In-Reply-To: <359FFE85-86AF-4FBD-9491-3528382E5002@friedenbach.org>
References: <359FFE85-86AF-4FBD-9491-3528382E5002@friedenbach.org>
Message-ID: <20170929044556.GA3996@erisian.com.au>

On Thu, Sep 28, 2017 at 06:06:29PM -0700, Mark Friedenbach via bitcoin-dev wrote:
> Unlike other proposed fixes to the fee model, this is not trivially
> broken by paying the miner out of band.

I think CPFP allows this to break: a miner getting paid out of band
would just make the block look like:

    (1) 100kB of 5s/byte transactions
    (2) 850kB of 35s/byte transactions
    (3) 50kB of 95s/byte transactions, miner paying themselves

As long as every transaction in (1) has an output spent in (3), that seems
like it would be perfectly legitimate for CPFP. 

I think it would be cheaper overall than the fee refund transactions
as well. People making arrangements with miners directly would have to
pay for block space to cover:

   out:
     30-40B dest address
     30-40B change address
     10B    cpfp link
   in:
     36B    cpfp txid

then to actual spend their change:

   in:
     36B+70B txid+idx + witness for change

for a total of 142-162B plus 70B witness, as well as some sort of out of
band payment to the miner (paying fees directly to miners via a lightning
channel, comes to mind). 

If I understand your suggestion correctly, it would look like:

   coinbase:
     30-40B fee overflow payment back to transactor

   out:
     30-40B dest address
     30-40B change address
     30-40B fee-overflow output marker

and to spend their change:

   in:
     36B+70B txid+idx + witness for change
     36B+70B txid+idx + witness for fee overflow

for a total of 192-232B plus 140B witness; so that's 40%-50% more block
weight used. The fee overflow would probably be pretty small amounts,
as well, so kind of annoying to actually collect.

If you end up with two change addresses per tx generally, that also seems
like it might it annoyingly easy to link your transactions together
(unless fees end up getting coinjoined or run through satoshidice or
something). If you end up sending lots of fee overflows to a single
address, that links your txes too of course.


A miner might be willing to do that in order to charge a two-part tariff:
ie, a very high "subscription" fee that's paid once a year or similar,
along with very low per-tx fees. The only reason I can think of why
someone would buy a subscription is if the miner's effectively a monopoly
and submitting transactions via the p2p network isn't reliable enough;
the whole point of a two-part tariff is to be as expensive as each user
can bear, so it won't ever be any cheaper.


FWIW, I think reliability-based-price-discrimination might allow higher
mining revenue via having txes with differing fee rates in the same
block: eg if people are happy to pay 100s/byte for confirmation within
30 minutes, and likewise willing to pay 10s/byte for confirmation within
3 hours, and there aren't enough transactions of either type to hit the
block size limit, then a monopoly miner / mining cartel would do better
by accepting 100s/byte txes at any time, while accepting 10s/byte txes
in any given block, but only with about a 1-in-7 chance for any given tx.

Looking at estimatefee.com, there's currently apparently ~200kB of 82s/B
or more transactions, while to fill a 1MB block you'd have to go all the
way down to 2.1s/B -- so if you have to charge all txes at the marginal
fee rate, that's 200kB at 82s/B for 0.16 BTC rather than 1MB at 2.1s/B
for 0.021 BTC.


I think ideally, it would probably be better to let the block weight
limit adjust to deal with high-frequency components to changes in demand,
and have fee rates adjust more slowly to address the long-term trends
in changes to demand: if fee rates only adjust slowly, then they're
(by definition) easily predictable and you don't *have* to have much
concern about getting them wrong. (You'd still need to add the correct
fee at the time you want to publish a pre-signed transaction that was
very old, but CPFP isn't too bad at that).

Cheers,
aj


From andreas at schildbach.de  Fri Sep 29 08:44:11 2017
From: andreas at schildbach.de (Andreas Schildbach)
Date: Fri, 29 Sep 2017 10:44:11 +0200
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <20170929014543.GB11956@savin.petertodd.org>
References: <20170927160654.GA12492@savin.petertodd.org>
	<oqihpf$5gc$1@blaine.gmane.org>
	<20170929014543.GB11956@savin.petertodd.org>
Message-ID: <oql14j$4qq$1@blaine.gmane.org>

On 09/29/2017 03:45 AM, Peter Todd via bitcoin-dev wrote:
> On Thu, Sep 28, 2017 at 12:09:59PM +0200, Andreas Schildbach via bitcoin-dev wrote:
>> This feels redundant to me; the payment protocol already has an
>> expiration time.
> 
> I'm well aware. As the payment protocol hasn't caught on - and doesn't fully
> overlap all the usecases that addresses do anyway - I think we should consider
> bringing this important feature to Bitcoin addresses too.

Hasn't caught on? It is used for virtually all merchant transactions,
plus person to person transactions between Bitcoin Wallet users.



From pete at petertodd.org  Fri Sep 29 09:55:37 2017
From: pete at petertodd.org (Peter Todd)
Date: Fri, 29 Sep 2017 05:55:37 -0400
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <oql14j$4qq$1@blaine.gmane.org>
References: <20170927160654.GA12492@savin.petertodd.org>
	<oqihpf$5gc$1@blaine.gmane.org>
	<20170929014543.GB11956@savin.petertodd.org>
	<oql14j$4qq$1@blaine.gmane.org>
Message-ID: <20170929095537.GA15286@savin.petertodd.org>

On Fri, Sep 29, 2017 at 10:44:11AM +0200, Andreas Schildbach via bitcoin-dev wrote:
> On 09/29/2017 03:45 AM, Peter Todd via bitcoin-dev wrote:
> > On Thu, Sep 28, 2017 at 12:09:59PM +0200, Andreas Schildbach via bitcoin-dev wrote:
> >> This feels redundant to me; the payment protocol already has an
> >> expiration time.
> > 
> > I'm well aware. As the payment protocol hasn't caught on - and doesn't fully
> > overlap all the usecases that addresses do anyway - I think we should consider
> > bringing this important feature to Bitcoin addresses too.
> 
> Hasn't caught on? It is used for virtually all merchant transactions,
> plus person to person transactions between Bitcoin Wallet users.

"Virtually all"?

I regularly pay with Bitcoin, and I haven't seen the payment protocol used in
ages.

Can you name some users of it?

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/28b4c7ee/attachment.sig>

From daniele.pinna at gmail.com  Fri Sep 29 10:43:22 2017
From: daniele.pinna at gmail.com (Daniele Pinna)
Date: Fri, 29 Sep 2017 12:43:22 +0200
Subject: [bitcoin-dev] Rebatable fees & incentive-safe fee markets
In-Reply-To: <CAEgR2PEyWFO1RFohVEpcb-M7aM-8xjCFvDPeJPD4zF4yTCyZ0A@mail.gmail.com>
References: <CAEgR2PGCZ=F85yjAbZgC6NtzhpdgBL3n4M2jowN12wJ7x-Ai1A@mail.gmail.com>
	<CAEgR2PGrxDQE0k8WX4XXz9GN-RAL6JB51ST9Hdz=ba36gRCa6A@mail.gmail.com>
	<CAEgR2PFjt=ihzRBhNXbHTAJz1R+3vz8o-zRZkDA3iBo39x9cTQ@mail.gmail.com>
	<CAEgR2PFfSjJjkTYq+DAmTzmkHPxqhn6fUDoXTzrRebz+OoUgqw@mail.gmail.com>
	<CAEgR2PG5ZueHKDXbsPDEjQG7xAYBa_JAtPZo9n1V2=STC1srpA@mail.gmail.com>
	<CAEgR2PGPQ1e9SmoWOS3V+N9v+OWiM4g3nPN3d9urc+DfkWEJ7A@mail.gmail.com>
	<CAEgR2PEKkHH6+Sh8cQGF83-s1tpwQZgd0fiuNz_xyWu0mUPfCA@mail.gmail.com>
	<CAEgR2PEyWFO1RFohVEpcb-M7aM-8xjCFvDPeJPD4zF4yTCyZ0A@mail.gmail.com>
Message-ID: <CAEgR2PGrf+4pQRyNC_xKVEKXimKTWveGK9q6YJeZkG0_r=8tkg@mail.gmail.com>

Maybe I'm getting this wrong but wouldn't this scheme imply that a miner is
incentivized to limit the amount of transactions in a block to capture the
maximum fee of the ones included?

As an example, mined blocks currently carry ~0.8 btc in fees right now. If
I were to submit a transaction paying 1 btc in maximal money fees, then the
miner would be incentivized to include my transaction alone to avoid that
lower fee paying transactions reduce the amount of fees he can earn from my
transaction alone. This would mean that I could literally clog the network
by paying 1btc every ten minutes.

Am I missing something?

Daniele
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/5ecfcff9/attachment.html>

From sjors at sprovoost.nl  Fri Sep 29 07:18:06 2017
From: sjors at sprovoost.nl (Sjors Provoost)
Date: Fri, 29 Sep 2017 10:18:06 +0300
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <20170929021846.GB12303@savin.petertodd.org>
References: <20170927160654.GA12492@savin.petertodd.org>
	<oqihpf$5gc$1@blaine.gmane.org>
	<B5DE4E92-C5B3-4C01-A148-E3C46C897323@sprovoost.nl>
	<20170929021846.GB12303@savin.petertodd.org>
Message-ID: <3CCFB7B0-10FC-4860-86C0-29472B76B129@sprovoost.nl>

Op 29 sep. 2017, om 05:18 heeft Peter Todd <pete at petertodd.org> het volgende geschreven:
> 
> On Thu, Sep 28, 2017 at 03:43:05PM +0300, Sjors Provoost via bitcoin-dev wrote:
>> Peter Todd wrote:
>> Perhaps outside the scope of BIP173, but what about baking it into the protocol? That way a transaction that's sent too late, simply won't get confirmed. This removes the need for refund logic or asking a customer to pay just a few extra cents. You could also disallow a second payment.
>> 
>> Two downsides I can think of:
>> * privacy, as differences in expiration policy would be visible on chain
>> * miners might be able to game it in their interaction with brokers
> 
> This has been discussed many times before; there are *severe* downsides to
> making it possible for transactions to become invalid after the fact.

I've heard of that general principe, but I'm having trouble finding a good resource that describes it more precisely.

Is it a peer to peer or mempool issue? E.g a transaction might be accepted into the mempool and relayed at one point in time and suddenly become invalid before they're committed to a block? Or that a node receives a transaction, thinks it's invalid because the address already expired, but then receives an older block later which contains that transaction?

Once in a block, I don't see how it would become invalid later. But as a miner tries to find a block and updates the timestamp, they would have toss the transaction out at some point.

Another objection I can think of, is that the soft fork introducing this change would have to use a transaction type that's non-standard at the moment. This would make it difficult for a non-upgraded node to broadcast such a transaction. The recipient would have to know if the sender has upgraded before communicating an address, which sounds impractical at best.

>>> Being just an expiration time, seconds-level resolution is unnecessary, and
>>> may give the wrong impression. I'd suggest either:
>>> 
>>> 1) Hour resolution - 2^24 hours = 1914 years
>>> 2) Month resolution - 2^16 months = 5458 years
>> 
>> So that's 4.8 characters for hours, or 3.2 for years, plus checksum space? The shorter the better. Perhaps one or two bits can be used to specify an exponent; a large range seems more useful than high precision. For instance a merchant doesn't care if the customer pays within 10:00:00 minutes or 10:00:01 minutes and you wouldn't care if your address is valid 50 years or 50 years and 3 minutes. This point may be mute if minute level resolution is not practical.
> 
> Note that "large range" is a requirement driven by the fact that expiry times
> will inevitably be specified absolutely, not relatively: when the range runs
> out you need to upgrade the standard. Better to use another character and use a
> range that won't run out any time soon.
> 
> This wouldn't create a need for more checksum space.

You're right, relative time makes no sense. So it would take 5 characters to get roughly two minute resolution that lasts for 100 years.

Sjors

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/47107d36/attachment.sig>

From omarshib at gmail.com  Fri Sep 29 04:21:09 2017
From: omarshib at gmail.com (Omar Shibli)
Date: Fri, 29 Sep 2017 07:21:09 +0300
Subject: [bitcoin-dev] Why the BIP-72 Payment Protocol URI Standard is
 Insecure Against MITM Attacks
In-Reply-To: <20170929025538.GC12303@savin.petertodd.org>
References: <20170927160654.GA12492@savin.petertodd.org>
	<oqihpf$5gc$1@blaine.gmane.org>
	<B5DE4E92-C5B3-4C01-A148-E3C46C897323@sprovoost.nl>
	<20170929025538.GC12303@savin.petertodd.org>
Message-ID: <CAE3EOfi6wz=5oduOambZgBT51=OsYGUG2Ps_gJHis=fTCq80Dg@mail.gmail.com>

Thank you for sharing, this is indefinitely valuable.

I think that risk could be mitigated if instead of ignoring the bitcoin
address/amount/..., the wallet use this address for integrity checks.
Furthermore, I think this BIP could be improved by actually applying the
homomorphic property and deriving the bitcoin address from merchant pub key
and the hash itself. that would allow both the customer and merchant to be
able generate address independently.

On Fri, Sep 29, 2017 at 5:55 AM, Peter Todd via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Thu, Sep 28, 2017 at 03:43:05PM +0300, Sjors Provoost via bitcoin-dev
> wrote:
> > Andreas Schildbach wrote:
> > > This feels redundant to me; the payment protocol already has an
> > > expiration time.
> >
> > The BIP-70 payment protocol has significant overhead and most
> importantly requires back and forth. Emailing a bitcoin address or printing
> it on an invoice is much easier, so I would expect people to keep doing
> that.
>
> The BIP-70 payment protocol used via BIP-72 URI's is insecure, as payment
> qr
> codes don't cryptographically commit to the identity of the merchant, which
> means a MITM attacker can redirect the payment if they can obtain a SSL
> cert
> that the wallet accepts.
>
> For example, if I have a wallet on my phone and go to pay a
> merchant, a BIP-72 URI will look like the following(1):
>
>     bitcoin:mq7se9wy2egettFxPbmn99cK8v5AFq55Lx?amount=0.11&r=https://
> merchant.com/pay.php?h%3D2a8628fc2fbe
>
> A wallet following the BIP-72 standard will "ignore the bitcoin
> address/amount/label/message in the URI and instead fetch a PaymentRequest
> message and then follow the payment protocol, as described in BIP 70."
>
> So my phone will make a second connection - likely on a second network
> with a
> totally different set of MITM attackers - to https://merchant.com
>
> In short, while my browser may have gotten the correct URL with the correct
> Bitcoin address, by using the payment protocol my wallet is discarding that
> information and giving MITM attackers a second chance at redirecting my
> payment
> to them. That wallet is also likely using an off-the-shelf SSL library,
> with
> nothing other than an infrequently updated set of root certificates to use
> to
> verify the certificate; your browser has access to a whole host of better
> technologies, such as HSTS pinning, certificate transparency, and
> frequently
> updated root certificate lists with proper revocation (see Symantec).
>
> As an ad-hoc, unstandardized, extension Android Wallet for Bitcoin at least
> supports a h= parameter with a hash commitment to what the payment request
> should be, and will reject the MITM attacker if that hash doesn't match.
> But
> that's not actually in the standard itself, and as far as I can tell has
> never
> been made into a BIP.
>
> As-is BIP-72 is very dangerous and should be depreciated, with a new BIP
> made
> to replace it.
>
> 1) As an aside, it's absolutely hilarious that this URL taken straight from
>    BIP-72 has the merchant using PHP, given its truly terrible track
> record for
>    security.
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/4137a237/attachment-0001.html>

From andreas at schildbach.de  Fri Sep 29 12:45:32 2017
From: andreas at schildbach.de (Andreas Schildbach)
Date: Fri, 29 Sep 2017 14:45:32 +0200
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <20170929095537.GA15286@savin.petertodd.org>
References: <20170927160654.GA12492@savin.petertodd.org>
	<oqihpf$5gc$1@blaine.gmane.org>
	<20170929014543.GB11956@savin.petertodd.org>
	<oql14j$4qq$1@blaine.gmane.org>
	<20170929095537.GA15286@savin.petertodd.org>
Message-ID: <oqlf95$8kq$1@blaine.gmane.org>

On 09/29/2017 11:55 AM, Peter Todd via bitcoin-dev wrote:

>>> I'm well aware. As the payment protocol hasn't caught on - and doesn't fully
>>> overlap all the usecases that addresses do anyway - I think we should consider
>>> bringing this important feature to Bitcoin addresses too.
>>
>> Hasn't caught on? It is used for virtually all merchant transactions,
>> plus person to person transactions between Bitcoin Wallet users.
> 
> "Virtually all"?
> 
> I regularly pay with Bitcoin, and I haven't seen the payment protocol used in
> ages.

I regularly pay with Bitcoin, and I haven't seen the payment protocol
not being in use in ages.

> Can you name some users of it?

15+ Mio Coinbase users
~10 Mio BitPay users
8 Mio Bitcoin Wallet users
Plus Bitcoin Core, Electrum, etc (sorry no numbers)

Probably the only usecase for naked addresses is paper wallets, right?
I'm not sure if paper wallets can expire.


From morcos at gmail.com  Fri Sep 29 12:50:20 2017
From: morcos at gmail.com (Alex Morcos)
Date: Fri, 29 Sep 2017 12:50:20 +0000
Subject: [bitcoin-dev] Rebatable fees & incentive-safe fee markets
In-Reply-To: <CAEgR2PGrf+4pQRyNC_xKVEKXimKTWveGK9q6YJeZkG0_r=8tkg@mail.gmail.com>
References: <CAEgR2PGCZ=F85yjAbZgC6NtzhpdgBL3n4M2jowN12wJ7x-Ai1A@mail.gmail.com>
	<CAEgR2PGrxDQE0k8WX4XXz9GN-RAL6JB51ST9Hdz=ba36gRCa6A@mail.gmail.com>
	<CAEgR2PFjt=ihzRBhNXbHTAJz1R+3vz8o-zRZkDA3iBo39x9cTQ@mail.gmail.com>
	<CAEgR2PFfSjJjkTYq+DAmTzmkHPxqhn6fUDoXTzrRebz+OoUgqw@mail.gmail.com>
	<CAEgR2PG5ZueHKDXbsPDEjQG7xAYBa_JAtPZo9n1V2=STC1srpA@mail.gmail.com>
	<CAEgR2PGPQ1e9SmoWOS3V+N9v+OWiM4g3nPN3d9urc+DfkWEJ7A@mail.gmail.com>
	<CAEgR2PEKkHH6+Sh8cQGF83-s1tpwQZgd0fiuNz_xyWu0mUPfCA@mail.gmail.com>
	<CAEgR2PEyWFO1RFohVEpcb-M7aM-8xjCFvDPeJPD4zF4yTCyZ0A@mail.gmail.com>
	<CAEgR2PGrf+4pQRyNC_xKVEKXimKTWveGK9q6YJeZkG0_r=8tkg@mail.gmail.com>
Message-ID: <CAPWm=eUCQo+1+2SWjpWG1kcidcLcugwTvVbug6WNmZBRVm_ebg@mail.gmail.com>

I had the same concern, or a miner could fill the remainder of the block
with their own high fee paying transactions if blocks were required to be
full.

On Fri, Sep 29, 2017 at 7:55 AM Daniele Pinna via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Maybe I'm getting this wrong but wouldn't this scheme imply that a miner
> is incentivized to limit the amount of transactions in a block to capture
> the maximum fee of the ones included?
>
> As an example, mined blocks currently carry ~0.8 btc in fees right now. If
> I were to submit a transaction paying 1 btc in maximal money fees, then the
> miner would be incentivized to include my transaction alone to avoid that
> lower fee paying transactions reduce the amount of fees he can earn from my
> transaction alone. This would mean that I could literally clog the network
> by paying 1btc every ten minutes.
>
> Am I missing something?
>
> Daniele
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/7873796c/attachment.html>

From pete at petertodd.org  Fri Sep 29 13:52:03 2017
From: pete at petertodd.org (Peter Todd)
Date: Fri, 29 Sep 2017 09:52:03 -0400
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <oqlf95$8kq$1@blaine.gmane.org>
References: <20170927160654.GA12492@savin.petertodd.org>
	<oqihpf$5gc$1@blaine.gmane.org>
	<20170929014543.GB11956@savin.petertodd.org>
	<oql14j$4qq$1@blaine.gmane.org>
	<20170929095537.GA15286@savin.petertodd.org>
	<oqlf95$8kq$1@blaine.gmane.org>
Message-ID: <20170929135203.GA16240@savin.petertodd.org>

On Fri, Sep 29, 2017 at 02:45:32PM +0200, Andreas Schildbach via bitcoin-dev wrote:
> On 09/29/2017 11:55 AM, Peter Todd via bitcoin-dev wrote:
> 
> >>> I'm well aware. As the payment protocol hasn't caught on - and doesn't fully
> >>> overlap all the usecases that addresses do anyway - I think we should consider
> >>> bringing this important feature to Bitcoin addresses too.
> >>
> >> Hasn't caught on? It is used for virtually all merchant transactions,
> >> plus person to person transactions between Bitcoin Wallet users.
> > 
> > "Virtually all"?
> > 
> > I regularly pay with Bitcoin, and I haven't seen the payment protocol used in
> > ages.
> 
> I regularly pay with Bitcoin, and I haven't seen the payment protocol
> not being in use in ages.
> 
> > Can you name some users of it?
> 
> 15+ Mio Coinbase users

Lol, interesting mistake I made w/ Coinbase: my mobile wallets are all setup in
ways that don't support the payment protocol w/ Coinbase, probably because come
to think of it they were (still are?) rejecting payment protocol requests over
proxies and Tor. And on my desktop setups payment protocol URLs don't work for
various reasons, and I'd forgotten I'd manually disabled them ages ago.

Just checked and Bitfinex, BTCC, and Shapeshift all don't seem to use the
payment protocol.

Other than BitPay and Coinbase, do you have an example of a service supporting
the payment protocol?

> ~10 Mio BitPay users
> 8 Mio Bitcoin Wallet users
> Plus Bitcoin Core, Electrum, etc (sorry no numbers)
> 
> Probably the only usecase for naked addresses is paper wallets, right?
> I'm not sure if paper wallets can expire.

User-to-user payments pretty much always use naked addresses.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/85654673/attachment.sig>

From mark at friedenbach.org  Fri Sep 29 15:22:14 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Fri, 29 Sep 2017 08:22:14 -0700
Subject: [bitcoin-dev] Rebatable fees & incentive-safe fee markets
In-Reply-To: <CAEgR2PGrf+4pQRyNC_xKVEKXimKTWveGK9q6YJeZkG0_r=8tkg@mail.gmail.com>
References: <CAEgR2PGCZ=F85yjAbZgC6NtzhpdgBL3n4M2jowN12wJ7x-Ai1A@mail.gmail.com>
	<CAEgR2PGrxDQE0k8WX4XXz9GN-RAL6JB51ST9Hdz=ba36gRCa6A@mail.gmail.com>
	<CAEgR2PFjt=ihzRBhNXbHTAJz1R+3vz8o-zRZkDA3iBo39x9cTQ@mail.gmail.com>
	<CAEgR2PFfSjJjkTYq+DAmTzmkHPxqhn6fUDoXTzrRebz+OoUgqw@mail.gmail.com>
	<CAEgR2PG5ZueHKDXbsPDEjQG7xAYBa_JAtPZo9n1V2=STC1srpA@mail.gmail.com>
	<CAEgR2PGPQ1e9SmoWOS3V+N9v+OWiM4g3nPN3d9urc+DfkWEJ7A@mail.gmail.com>
	<CAEgR2PEKkHH6+Sh8cQGF83-s1tpwQZgd0fiuNz_xyWu0mUPfCA@mail.gmail.com>
	<CAEgR2PEyWFO1RFohVEpcb-M7aM-8xjCFvDPeJPD4zF4yTCyZ0A@mail.gmail.com>
	<CAEgR2PGrf+4pQRyNC_xKVEKXimKTWveGK9q6YJeZkG0_r=8tkg@mail.gmail.com>
Message-ID: <5F7A4F74-B108-4E30-A3F4-4125BBD0F819@friedenbach.org>

This is correct. Under assumptions of a continuous mempool model however this should be considered the outlier behavior, other than a little bit of empty space at the end, now and then. A maximum fee rate calculated as a filter over past block rates could constrain this outlier behavior from ever happening too.

> On Sep 29, 2017, at 3:43 AM, Daniele Pinna <daniele.pinna at gmail.com> wrote:
> 
> Maybe I'm getting this wrong but wouldn't this scheme imply that a miner is incentivized to limit the amount of transactions in a block to capture the maximum fee of the ones included?
> 
> As an example, mined blocks currently carry ~0.8 btc in fees right now. If I were to submit a transaction paying 1 btc in maximal money fees, then the miner would be incentivized to include my transaction alone to avoid that lower fee paying transactions reduce the amount of fees he can earn from my transaction alone. This would mean that I could literally clog the network by paying 1btc every ten minutes.
> 
> Am I missing something?
> 
> Daniele 

From tomas at tomasvdw.nl  Fri Sep 29 13:14:03 2017
From: tomas at tomasvdw.nl (Tomas)
Date: Fri, 29 Sep 2017 15:14:03 +0200
Subject: [bitcoin-dev] Why the BIP-72 Payment Protocol URI Standard is
 Insecure Against MITM Attacks
In-Reply-To: <20170929025538.GC12303@savin.petertodd.org>
References: <20170927160654.GA12492@savin.petertodd.org>
	<oqihpf$5gc$1@blaine.gmane.org>
	<B5DE4E92-C5B3-4C01-A148-E3C46C897323@sprovoost.nl>
	<20170929025538.GC12303@savin.petertodd.org>
Message-ID: <1506690843.2339068.1122431744.5A801943@webmail.messagingengine.com>


On Fri, Sep 29, 2017, at 04:55, Peter Todd via bitcoin-dev wrote:
> The BIP-70 payment protocol used via BIP-72 URI's is insecure, as payment
> qr
> codes don't cryptographically commit to the identity of the merchant,
> which
> means a MITM attacker can redirect the payment if they can obtain a SSL
> cert
> that the wallet accepts.

By that reasoning, we also shouldn't go to https://coinbase.com or
https://kraken.com to buy any bitcoins? As a MITM can redirect the site
_if_ they obtain the coinbase or kraken certificate.

Obviously, HTTPS is secured under the assumption that certificates are
secure.  

Using the payment protocol simply means paying to a secure endpoint (eg
https://tomasvdw.nl/pay) instead of an address.

>  That wallet is also likely using an off-the-shelf SSL library,
> with
> nothing other than an infrequently updated set of root certificates to
> use to
> verify the certificate; your browser has access to a whole host of better
> technologies, such as HSTS pinning, certificate transparency, and
> frequently
> updated root certificate lists with proper revocation (see Symantec).

So we should not use HTTPS for secure transfer because the
implementation may not be good enough? This incorrectly conflates
implementation with specification. There is nothing stopping a developer
from using a proper implementation.

> 
> As an ad-hoc, unstandardized, extension Android Wallet for Bitcoin at
> least
> supports a h= parameter with a hash commitment to what the payment
> request
> should be, and will reject the MITM attacker if that hash doesn't match.
> But
> that's not actually in the standard itself, and as far as I can tell has
> never
> been made into a BIP.

Currently it is widely used by merchants, but not yet for light clients
_receiving_ money. If it becomes more wide spread,   it offers a range
of advantages as  the bitcoin-address of the URI can and should be
deprecated (made impossible with "h="). A payment address just becomes a
secure endpoint.

This means no more address reuse is possible. Also, it drops the need
for mempool synchronization among non-miners, solely as a "notification"
mechanism. In addition it means light clients know exactly when a
transaction is coming in, so they can efficiently rely on client-side
filtering a small set of blocks, improving their privacy.

In my opinion, the payment protocol is key to scaling.

> As-is BIP-72 is very dangerous and should be depreciated, with a new BIP
> made
> to replace it.

Sorry, but maybe you  could explain better how secure communication over
HTTPS is "very dangerous"? I think some websites would like to know :)

Tomas van der Wansem
bitcrust

From greg at xiph.org  Fri Sep 29 17:25:18 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Fri, 29 Sep 2017 17:25:18 +0000
Subject: [bitcoin-dev] Address expiration times should be added to
	BIP-173
In-Reply-To: <oqlf95$8kq$1@blaine.gmane.org>
References: <20170927160654.GA12492@savin.petertodd.org>
	<oqihpf$5gc$1@blaine.gmane.org>
	<20170929014543.GB11956@savin.petertodd.org>
	<oql14j$4qq$1@blaine.gmane.org>
	<20170929095537.GA15286@savin.petertodd.org>
	<oqlf95$8kq$1@blaine.gmane.org>
Message-ID: <CAAS2fgR0Q3KGnH1r-rF9+r=WC_j2NKwrx6WUOFKqXSiytLhbfQ@mail.gmail.com>

On Fri, Sep 29, 2017 at 12:45 PM, Andreas Schildbach via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> 15+ Mio Coinbase users

Who's payment protocol SSL cert was expired for months without even
generating a post on reddit.  Not exactly convincing there.

The fact that someone supports it doesn't mean its being used.

From dan at osc.co.cr  Fri Sep 29 17:29:17 2017
From: dan at osc.co.cr (Dan Libby)
Date: Fri, 29 Sep 2017 10:29:17 -0700
Subject: [bitcoin-dev] Paper Wallet support in bitcoin-core
Message-ID: <e43c6e06-0bdc-360e-eb5c-a3726e4f0fc8@osc.co.cr>

Hi,

I'm writing to suggest and discuss the addition of paper wallet
functionality in bitcoin-core software, starting with a single new RPC
call: genExternalAddress [type].

-- rationale --

bitcoin-core is the most trusted and most secure bitcoin implementation.

Yet today (unless I've missed something) paper wallet generation
requires use of third party software, or even a website such as
bitaddress.org.  This requires placing trust in an additional body of
code from a less-trusted and less peer-reviewed source.  Ideally, one
would personally audit this code for one's self, but in practice that
rarely happens.

In the case of a website generator, the code must be audited again each
time it is downloaded.  I cannot in good faith recommend to anyone to
use such third party tools for wallet generation.

I *would* recommend for others to trust a paper wallet that uses
address(es) generated by bitcoin-core itself.

At least for me, this requirement to audit (or implicitly trust) a
secondary body of bitcoin code places an additional hurdle or
disincentive on the use of paper wallets, or indeed private keys
generated outside of bitcoin-core for any purpose.

Unfortunately, one cannot simply use getnewaddress, getaccountaddress,
or getrawchangeaddress for this purpose, because the associated private
keys are added to the bitcoin-core wallet and cannot be removed... or in
the case of hd-wallets are deterministically derived.

As such, I'm throwing out the following half-baked proposal as a
starting point for discussion:


-----

    genexternaladdress ( "type" )

    Returns a new Bitcoin address and private key for receiving
    payments. This key/address is intended for external usage such as
    paper wallets and will not be used by internal wallet nor written to
    disk.

    Arguments:
    1. "type"        (string, optional) one of: p2pkh, p2sh-p2wpkh
                                        default: p2sh-p2wpkh

    Result:
    {
        "privKey"    (string) The private key in wif format.
        "address"    (string) The address in p2pkh or p2sh-p2wpkh
                              format.
    }


    Examples:
    > bitcoin-cli genexternaladdress


----

This API is simple to implement and use.  It provides enough
functionality for any moderately skilled developer to create their own
paper wallet creation script using any scripting language, or even for
advanced users to perform using bitcoin-cli or debug console.

If consensus here is in favor of including such an API, I will be happy
to take a crack at implementing it and submitting a pull request.

If anyone has reasons why it is a BAD IDEA to include such an RPC call
in bitcoind, I'm curious to hear it.

Also, I welcome suggestions for a better name, or maybe there could be
some improvements to the param(s), such as calling p2sh-p2wpkh "segwit"
instead.


---- further work ----


Further steps could be taken in this direction, but are not necessary
for a useful first-step.  In particular:

1. an RPC call to generate an external HD wallet seed.
2. an RPC call to generate N key/address pairs from a given seed.
3. GUI functionality in bitcoin-qt to facilitate easy paper wallet
generation (and printing?) for end-users, complete with nice graphics,
qr codes, etc.











From vitteaymeric at gmail.com  Fri Sep 29 17:40:00 2017
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Fri, 29 Sep 2017 19:40:00 +0200
Subject: [bitcoin-dev] Why the BIP-72 Payment Protocol URI Standard is
 Insecure Against MITM Attacks
In-Reply-To: <1506690843.2339068.1122431744.5A801943@webmail.messagingengine.com>
References: <20170927160654.GA12492@savin.petertodd.org>
	<oqihpf$5gc$1@blaine.gmane.org>
	<B5DE4E92-C5B3-4C01-A148-E3C46C897323@sprovoost.nl>
	<20170929025538.GC12303@savin.petertodd.org>
	<1506690843.2339068.1122431744.5A801943@webmail.messagingengine.com>
Message-ID: <d0855fe8-03b2-4f71-9514-7c841396aaa8@gmail.com>

Everybody knows that https is broken and insecure, and everybody knows
that it's still better than nothing

Just reacting here because there is worse: you are quoting Kraken, did
not check for Coinbase but Kraken is proxying all of its https traffic
via Cloudflare, including the API traffic

This is crazy but that's how things are, that's what everybody is doing,
that's what we have

The https principles are obsolete, the concept of certificates tied to a
domain is a complete stupidity, because there are no concept of domains
in bitcoin for example (and webrtc, Tor, bittorrent, p2p systems, etc)
and should evolve to something like certificates tied to an entityID
managed by something like a blockchain system, and not a stupid domain or CA

Therefore specifying things for bitcoin ? la web is not a good idea,
browsers can do far better than standard/usual web, and the "like
everybody is doing" argument is not a valid one


Le 29/09/2017 ? 15:14, Tomas via bitcoin-dev a ?crit?:
> On Fri, Sep 29, 2017, at 04:55, Peter Todd via bitcoin-dev wrote:
>> The BIP-70 payment protocol used via BIP-72 URI's is insecure, as payment
>> qr
>> codes don't cryptographically commit to the identity of the merchant,
>> which
>> means a MITM attacker can redirect the payment if they can obtain a SSL
>> cert
>> that the wallet accepts.
> By that reasoning, we also shouldn't go to https://coinbase.com or
> https://kraken.com to buy any bitcoins? As a MITM can redirect the site
> _if_ they obtain the coinbase or kraken certificate.
>
> Obviously, HTTPS is secured under the assumption that certificates are
> secure.  
>
> Using the payment protocol simply means paying to a secure endpoint (eg
> https://tomasvdw.nl/pay) instead of an address.
>
>>  That wallet is also likely using an off-the-shelf SSL library,
>> with
>> nothing other than an infrequently updated set of root certificates to
>> use to
>> verify the certificate; your browser has access to a whole host of better
>> technologies, such as HSTS pinning, certificate transparency, and
>> frequently
>> updated root certificate lists with proper revocation (see Symantec).
> So we should not use HTTPS for secure transfer because the
> implementation may not be good enough? This incorrectly conflates
> implementation with specification. There is nothing stopping a developer
> from using a proper implementation.
>
>> As an ad-hoc, unstandardized, extension Android Wallet for Bitcoin at
>> least
>> supports a h= parameter with a hash commitment to what the payment
>> request
>> should be, and will reject the MITM attacker if that hash doesn't match.
>> But
>> that's not actually in the standard itself, and as far as I can tell has
>> never
>> been made into a BIP.
> Currently it is widely used by merchants, but not yet for light clients
> _receiving_ money. If it becomes more wide spread,   it offers a range
> of advantages as  the bitcoin-address of the URI can and should be
> deprecated (made impossible with "h="). A payment address just becomes a
> secure endpoint.
>
> This means no more address reuse is possible. Also, it drops the need
> for mempool synchronization among non-miners, solely as a "notification"
> mechanism. In addition it means light clients know exactly when a
> transaction is coming in, so they can efficiently rely on client-side
> filtering a small set of blocks, improving their privacy.
>
> In my opinion, the payment protocol is key to scaling.
>
>> As-is BIP-72 is very dangerous and should be depreciated, with a new BIP
>> made
>> to replace it.
> Sorry, but maybe you  could explain better how secure communication over
> HTTPS is "very dangerous"? I think some websites would like to know :)
>
> Tomas van der Wansem
> bitcrust
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms


From andrew.johnson83 at gmail.com  Fri Sep 29 18:07:26 2017
From: andrew.johnson83 at gmail.com (Andrew Johnson)
Date: Fri, 29 Sep 2017 13:07:26 -0500
Subject: [bitcoin-dev] Paper Wallet support in bitcoin-core
In-Reply-To: <e43c6e06-0bdc-360e-eb5c-a3726e4f0fc8@osc.co.cr>
References: <e43c6e06-0bdc-360e-eb5c-a3726e4f0fc8@osc.co.cr>
Message-ID: <CAAy62_Jfp00gsAjTWvr1E8aYx9z9aYM9y6AqqrgK8HizQm08xQ@mail.gmail.com>

One consideration of exposing this in QT is that it may encourage users to
generate paper wallets(which are generally used and recommended for cold
storage) from online machines, rendering them moreso lukewarm rather than
cold, since the keys weren't generated in an air-gapped environment.  When
using bitaddress.org locally(we *are *all only using it locally and not
directly from the online webpage, right? ;) ) you've at least made the
effort to seek out the repo, clone it locally, and use it on an offline
machine and not retain any data from that session.

If we include this as a function in the reference implementation, how many
people are going to be making paper wallets with the intention of cold
storage on a machine that's potentially compromised?  As
adoption(hopefully) continues to increase the number of less than tech
savvy people using bitcoin will increase.

I'd suggest that any UI in QT include some sort of a modal dialog that
informs the user that this is not a secure cold storage address unless it
was created on an offline machine and printed on a non-networked printer,
and the prompt must be accepted and dismissed before the wallet will
provide the requested keys.


On Fri, Sep 29, 2017 at 12:29 PM, Dan Libby via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi,
>
> I'm writing to suggest and discuss the addition of paper wallet
> functionality in bitcoin-core software, starting with a single new RPC
> call: genExternalAddress [type].
>
> -- rationale --
>
> bitcoin-core is the most trusted and most secure bitcoin implementation.
>
> Yet today (unless I've missed something) paper wallet generation
> requires use of third party software, or even a website such as
> bitaddress.org.  This requires placing trust in an additional body of
> code from a less-trusted and less peer-reviewed source.  Ideally, one
> would personally audit this code for one's self, but in practice that
> rarely happens.
>
> In the case of a website generator, the code must be audited again each
> time it is downloaded.  I cannot in good faith recommend to anyone to
> use such third party tools for wallet generation.
>
> I *would* recommend for others to trust a paper wallet that uses
> address(es) generated by bitcoin-core itself.
>
> At least for me, this requirement to audit (or implicitly trust) a
> secondary body of bitcoin code places an additional hurdle or
> disincentive on the use of paper wallets, or indeed private keys
> generated outside of bitcoin-core for any purpose.
>
> Unfortunately, one cannot simply use getnewaddress, getaccountaddress,
> or getrawchangeaddress for this purpose, because the associated private
> keys are added to the bitcoin-core wallet and cannot be removed... or in
> the case of hd-wallets are deterministically derived.
>
> As such, I'm throwing out the following half-baked proposal as a
> starting point for discussion:
>
>
> -----
>
>     genexternaladdress ( "type" )
>
>     Returns a new Bitcoin address and private key for receiving
>     payments. This key/address is intended for external usage such as
>     paper wallets and will not be used by internal wallet nor written to
>     disk.
>
>     Arguments:
>     1. "type"        (string, optional) one of: p2pkh, p2sh-p2wpkh
>                                         default: p2sh-p2wpkh
>
>     Result:
>     {
>         "privKey"    (string) The private key in wif format.
>         "address"    (string) The address in p2pkh or p2sh-p2wpkh
>                               format.
>     }
>
>
>     Examples:
>     > bitcoin-cli genexternaladdress
>
>
> ----
>
> This API is simple to implement and use.  It provides enough
> functionality for any moderately skilled developer to create their own
> paper wallet creation script using any scripting language, or even for
> advanced users to perform using bitcoin-cli or debug console.
>
> If consensus here is in favor of including such an API, I will be happy
> to take a crack at implementing it and submitting a pull request.
>
> If anyone has reasons why it is a BAD IDEA to include such an RPC call
> in bitcoind, I'm curious to hear it.
>
> Also, I welcome suggestions for a better name, or maybe there could be
> some improvements to the param(s), such as calling p2sh-p2wpkh "segwit"
> instead.
>
>
> ---- further work ----
>
>
> Further steps could be taken in this direction, but are not necessary
> for a useful first-step.  In particular:
>
> 1. an RPC call to generate an external HD wallet seed.
> 2. an RPC call to generate N key/address pairs from a given seed.
> 3. GUI functionality in bitcoin-qt to facilitate easy paper wallet
> generation (and printing?) for end-users, complete with nice graphics,
> qr codes, etc.
>
>
>
>
>
>
>
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>



-- 
Andrew Johnson
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/07c1fa76/attachment.html>

From dan at osc.co.cr  Fri Sep 29 19:34:57 2017
From: dan at osc.co.cr (Dan Libby)
Date: Fri, 29 Sep 2017 12:34:57 -0700
Subject: [bitcoin-dev] Paper Wallet support in bitcoin-core
In-Reply-To: <CAAy62_Jfp00gsAjTWvr1E8aYx9z9aYM9y6AqqrgK8HizQm08xQ@mail.gmail.com>
References: <e43c6e06-0bdc-360e-eb5c-a3726e4f0fc8@osc.co.cr>
	<CAAy62_Jfp00gsAjTWvr1E8aYx9z9aYM9y6AqqrgK8HizQm08xQ@mail.gmail.com>
Message-ID: <6cd2299b-d38e-7bbc-e95e-9ce5ff13fc9e@osc.co.cr>

On 09/29/2017 11:07 AM, Andrew Johnson wrote:
> One consideration of exposing this in QT is that it may encourage users
> to generate paper wallets(which are generally used and recommended for
> cold storage) from online machines, rendering them moreso lukewarm
> rather than cold, since the keys weren't generated in an air-gapped
> environment.? 

true that.  Though there's nothing stopping a diligent person from
installing bitcoin-core on a dedicated offline machine.  The blockchain
wouldn't need to be synced at all for key generation purposes.

> When using bitaddress.org <http://bitaddress.org>
> locally(we?/are /all only?using it locally and not directly from the
> online webpage, right? ;) )?you've at least made the effort to seek out
> the repo, clone it locally, and use it on an offline machine and not
> retain any data from that session.

yeah, so I noticed this issue about Paper Wallet generation not being
possible with bitcoin-core exactly because I was recommending to a
non-technical user to use paper wallets, but then I also had to point
out that really bitaddress code should be downloaded, audited, etc,
before use.  Things that are actually impossible for a non-technical user.

So I figured that instead I would make a simple script for them that
would use bitcoin-core to generate the addresses... and that's when it
dawned on me that it won't actually work with present day RPCs that are
all tied to internal wallet.

hence, this proposal.

> I'd suggest that any UI in QT include some sort of a modal dialog that
> informs the user that this is not a secure cold storage address unless
> it was created on an offline machine and printed on a non-networked
> printer, and the prompt must be accepted and dismissed before the wallet
> will provide the requested keys.

yes, agreed.

From dan at osc.co.cr  Fri Sep 29 20:13:59 2017
From: dan at osc.co.cr (Dan Libby)
Date: Fri, 29 Sep 2017 13:13:59 -0700
Subject: [bitcoin-dev] Paper Wallet support in bitcoin-core
In-Reply-To: <e43c6e06-0bdc-360e-eb5c-a3726e4f0fc8@osc.co.cr>
References: <e43c6e06-0bdc-360e-eb5c-a3726e4f0fc8@osc.co.cr>
Message-ID: <847d24d6-f1ee-e15c-9f85-a8bd45d57501@osc.co.cr>

One additional thought:

It should be useful to also define a multi-sig generation RPC.

This would facilitate multi-sig paper wallets stored in different
physical locations, amongst other use-cases.

Something like:

-----

    genexternalmultisigaddress ( "m", "n", "type" )

    Returns a new Bitcoin address and n number of private key(s).
    This address and associated keys is intended for external usage such
    as paper wallets and will not be used by internal wallet nor written
    to disk.

    Arguments:
    1. "m"           (integer, required) The number of required signers
                                         to send funds.
    2. "n"           (integer, required) The number of authorized
                                         signers
    3. "type"        (string, optional)  one of: p2sh-p2pkh, p2sh-p2wpkh
                                         default: p2sh-p2wpkh

    Result:
    {
        "address",   (string) The address in p2pkh or p2sh-p2wpkh
                              format.
        "privkeys": [
            (string) The private key in wif format.
        ]
    }


    Examples:
    > bitcoin-cli genexternalmultisigaddress 2 3

-----



On 09/29/2017 10:29 AM, Dan Libby via bitcoin-dev wrote:
> Hi,
> 
> I'm writing to suggest and discuss the addition of paper wallet
> functionality in bitcoin-core software, starting with a single new RPC
> call: genExternalAddress [type].
> 
> -- rationale --
> 
> bitcoin-core is the most trusted and most secure bitcoin implementation.
> 
> Yet today (unless I've missed something) paper wallet generation
> requires use of third party software, or even a website such as
> bitaddress.org.  This requires placing trust in an additional body of
> code from a less-trusted and less peer-reviewed source.  Ideally, one
> would personally audit this code for one's self, but in practice that
> rarely happens.
> 
> In the case of a website generator, the code must be audited again each
> time it is downloaded.  I cannot in good faith recommend to anyone to
> use such third party tools for wallet generation.
> 
> I *would* recommend for others to trust a paper wallet that uses
> address(es) generated by bitcoin-core itself.
> 
> At least for me, this requirement to audit (or implicitly trust) a
> secondary body of bitcoin code places an additional hurdle or
> disincentive on the use of paper wallets, or indeed private keys
> generated outside of bitcoin-core for any purpose.
> 
> Unfortunately, one cannot simply use getnewaddress, getaccountaddress,
> or getrawchangeaddress for this purpose, because the associated private
> keys are added to the bitcoin-core wallet and cannot be removed... or in
> the case of hd-wallets are deterministically derived.

From dan at osc.co.cr  Fri Sep 29 22:13:47 2017
From: dan at osc.co.cr (Dan Libby)
Date: Fri, 29 Sep 2017 15:13:47 -0700
Subject: [bitcoin-dev] Paper Wallet support in bitcoin-core
In-Reply-To: <201709292103.36630.luke@dashjr.org>
References: <e43c6e06-0bdc-360e-eb5c-a3726e4f0fc8@osc.co.cr>
	<201709292103.36630.luke@dashjr.org>
Message-ID: <dcfaa57d-3fcd-973e-2548-5f9f318c0682@osc.co.cr>

It seems to me that the same statement can be made for *any* key storage
mechanism depending on one's security/threat model, including
bitcoin-core's internal wallet storage.  There certainly are cases where
a paper (or metal) offline wallet makes a lot of sense, particularly for
long-term offline storage... something that electronic media pretty much
sucks at.

Though if you care to elaborate I'd be interested to learn of your
specific critiques, if you have any beyond the generic statements here:
https://en.bitcoin.it/wiki/Paper_wallet

Regardless, the APIs I've proposed have uses beyond paper wallets.  It
can also be used by third party wallets, or any number of reasons that
individuals or devs might have to generate keys.



On 09/29/2017 02:03 PM, Luke Dashjr wrote:
> Paper wallets are a safety hazard, insecure, and generally not advisable.
> 
> 
> On Friday 29 September 2017 5:29:17 PM Dan Libby via bitcoin-dev wrote:
>> Hi,
>>
>> I'm writing to suggest and discuss the addition of paper wallet
>> functionality in bitcoin-core software, starting with a single new RPC
>> call: genExternalAddress [type].
>>
>> -- rationale --
>>
>> bitcoin-core is the most trusted and most secure bitcoin implementation.
>>
>> Yet today (unless I've missed something) paper wallet generation
>> requires use of third party software, or even a website such as
>> bitaddress.org.  This requires placing trust in an additional body of
>> code from a less-trusted and less peer-reviewed source.  Ideally, one
>> would personally audit this code for one's self, but in practice that
>> rarely happens.
>>
>> In the case of a website generator, the code must be audited again each
>> time it is downloaded.  I cannot in good faith recommend to anyone to
>> use such third party tools for wallet generation.
>>
>> I *would* recommend for others to trust a paper wallet that uses
>> address(es) generated by bitcoin-core itself.
>>
>> At least for me, this requirement to audit (or implicitly trust) a
>> secondary body of bitcoin code places an additional hurdle or
>> disincentive on the use of paper wallets, or indeed private keys
>> generated outside of bitcoin-core for any purpose.
>>
>> Unfortunately, one cannot simply use getnewaddress, getaccountaddress,
>> or getrawchangeaddress for this purpose, because the associated private
>> keys are added to the bitcoin-core wallet and cannot be removed... or in
>> the case of hd-wallets are deterministically derived.
>>
>> As such, I'm throwing out the following half-baked proposal as a
>> starting point for discussion:
>>
>>
>> -----
>>
>>     genexternaladdress ( "type" )
>>
>>     Returns a new Bitcoin address and private key for receiving
>>     payments. This key/address is intended for external usage such as
>>     paper wallets and will not be used by internal wallet nor written to
>>     disk.
>>
>>     Arguments:
>>     1. "type"        (string, optional) one of: p2pkh, p2sh-p2wpkh
>>                                         default: p2sh-p2wpkh
>>
>>     Result:
>>     {
>>         "privKey"    (string) The private key in wif format.
>>         "address"    (string) The address in p2pkh or p2sh-p2wpkh
>>                               format.
>>     }
>>
>>     Examples:
>>     > bitcoin-cli genexternaladdress
>>
>> ----
>>
>> This API is simple to implement and use.  It provides enough
>> functionality for any moderately skilled developer to create their own
>> paper wallet creation script using any scripting language, or even for
>> advanced users to perform using bitcoin-cli or debug console.
>>
>> If consensus here is in favor of including such an API, I will be happy
>> to take a crack at implementing it and submitting a pull request.
>>
>> If anyone has reasons why it is a BAD IDEA to include such an RPC call
>> in bitcoind, I'm curious to hear it.
>>
>> Also, I welcome suggestions for a better name, or maybe there could be
>> some improvements to the param(s), such as calling p2sh-p2wpkh "segwit"
>> instead.
>>
>>
>> ---- further work ----
>>
>>
>> Further steps could be taken in this direction, but are not necessary
>> for a useful first-step.  In particular:
>>
>> 1. an RPC call to generate an external HD wallet seed.
>> 2. an RPC call to generate N key/address pairs from a given seed.
>> 3. GUI functionality in bitcoin-qt to facilitate easy paper wallet
>> generation (and printing?) for end-users, complete with nice graphics,
>> qr codes, etc.
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


-- 
Dan Libby

Open Source Consulting S.A.
Santa Ana, Costa Rica
http://osc.co.cr
phone: 011 506 2204 7018
Fax: 011 506 2223 7359

From sjors at sprovoost.nl  Fri Sep 29 20:21:48 2017
From: sjors at sprovoost.nl (Sjors Provoost)
Date: Fri, 29 Sep 2017 22:21:48 +0200
Subject: [bitcoin-dev] Paper Wallet support in bitcoin-core
In-Reply-To: <CAAy62_Jfp00gsAjTWvr1E8aYx9z9aYM9y6AqqrgK8HizQm08xQ@mail.gmail.com>
References: <e43c6e06-0bdc-360e-eb5c-a3726e4f0fc8@osc.co.cr>
	<CAAy62_Jfp00gsAjTWvr1E8aYx9z9aYM9y6AqqrgK8HizQm08xQ@mail.gmail.com>
Message-ID: <1FF598B0-52BD-4DE6-8DD3-7A31025CF313@sprovoost.nl>

A 12-24 word BIP39 mnemonic is easy to write down and has the benefit of not needing to trust a printer.

However without also supporting BIP43/44/49 this would probably cause confusion. Supporting these would be a larger project as well. Although widely used, the standards are still Proposed / Draft. There's  might be room for improvement [0].

Sjors

[0] https://github.com/satoshilabs/slips/issues/103

> Op 29 sep. 2017, om 20:07 heeft Andrew Johnson via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:
> 
> One consideration of exposing this in QT is that it may encourage users to generate paper wallets(which are generally used and recommended for cold storage) from online machines, rendering them moreso lukewarm rather than cold, since the keys weren't generated in an air-gapped environment.  When using bitaddress.org <http://bitaddress.org/> locally(we are all only using it locally and not directly from the online webpage, right? ;) ) you've at least made the effort to seek out the repo, clone it locally, and use it on an offline machine and not retain any data from that session.
> 
> If we include this as a function in the reference implementation, how many people are going to be making paper wallets with the intention of cold storage on a machine that's potentially compromised?  As adoption(hopefully) continues to increase the number of less than tech savvy people using bitcoin will increase.
> 
> I'd suggest that any UI in QT include some sort of a modal dialog that informs the user that this is not a secure cold storage address unless it was created on an offline machine and printed on a non-networked printer, and the prompt must be accepted and dismissed before the wallet will provide the requested keys.
> 
> 
> On Fri, Sep 29, 2017 at 12:29 PM, Dan Libby via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
> Hi,
> 
> I'm writing to suggest and discuss the addition of paper wallet
> functionality in bitcoin-core software, starting with a single new RPC
> call: genExternalAddress [type].
> 
> -- rationale --
> 
> bitcoin-core is the most trusted and most secure bitcoin implementation.
> 
> Yet today (unless I've missed something) paper wallet generation
> requires use of third party software, or even a website such as
> bitaddress.org <http://bitaddress.org/>.  This requires placing trust in an additional body of
> code from a less-trusted and less peer-reviewed source.  Ideally, one
> would personally audit this code for one's self, but in practice that
> rarely happens.
> 
> In the case of a website generator, the code must be audited again each
> time it is downloaded.  I cannot in good faith recommend to anyone to
> use such third party tools for wallet generation.
> 
> I *would* recommend for others to trust a paper wallet that uses
> address(es) generated by bitcoin-core itself.
> 
> At least for me, this requirement to audit (or implicitly trust) a
> secondary body of bitcoin code places an additional hurdle or
> disincentive on the use of paper wallets, or indeed private keys
> generated outside of bitcoin-core for any purpose.
> 
> Unfortunately, one cannot simply use getnewaddress, getaccountaddress,
> or getrawchangeaddress for this purpose, because the associated private
> keys are added to the bitcoin-core wallet and cannot be removed... or in
> the case of hd-wallets are deterministically derived.
> 
> As such, I'm throwing out the following half-baked proposal as a
> starting point for discussion:
> 
> 
> -----
> 
>     genexternaladdress ( "type" )
> 
>     Returns a new Bitcoin address and private key for receiving
>     payments. This key/address is intended for external usage such as
>     paper wallets and will not be used by internal wallet nor written to
>     disk.
> 
>     Arguments:
>     1. "type"        (string, optional) one of: p2pkh, p2sh-p2wpkh
>                                         default: p2sh-p2wpkh
> 
>     Result:
>     {
>         "privKey"    (string) The private key in wif format.
>         "address"    (string) The address in p2pkh or p2sh-p2wpkh
>                               format.
>     }
> 
> 
>     Examples:
>     > bitcoin-cli genexternaladdress
> 
> 
> ----
> 
> This API is simple to implement and use.  It provides enough
> functionality for any moderately skilled developer to create their own
> paper wallet creation script using any scripting language, or even for
> advanced users to perform using bitcoin-cli or debug console.
> 
> If consensus here is in favor of including such an API, I will be happy
> to take a crack at implementing it and submitting a pull request.
> 
> If anyone has reasons why it is a BAD IDEA to include such an RPC call
> in bitcoind, I'm curious to hear it.
> 
> Also, I welcome suggestions for a better name, or maybe there could be
> some improvements to the param(s), such as calling p2sh-p2wpkh "segwit"
> instead.
> 
> 
> ---- further work ----
> 
> 
> Further steps could be taken in this direction, but are not necessary
> for a useful first-step.  In particular:
> 
> 1. an RPC call to generate an external HD wallet seed.
> 2. an RPC call to generate N key/address pairs from a given seed.
> 3. GUI functionality in bitcoin-qt to facilitate easy paper wallet
> generation (and printing?) for end-users, complete with nice graphics,
> qr codes, etc.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/3a74a284/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/3a74a284/attachment-0001.sig>

From dan at osc.co.cr  Fri Sep 29 22:19:46 2017
From: dan at osc.co.cr (Dan Libby)
Date: Fri, 29 Sep 2017 15:19:46 -0700
Subject: [bitcoin-dev] Paper Wallet support in bitcoin-core
In-Reply-To: <dcfaa57d-3fcd-973e-2548-5f9f318c0682@osc.co.cr>
References: <e43c6e06-0bdc-360e-eb5c-a3726e4f0fc8@osc.co.cr>
	<201709292103.36630.luke@dashjr.org>
	<dcfaa57d-3fcd-973e-2548-5f9f318c0682@osc.co.cr>
Message-ID: <51935ee9-ef24-22cf-638e-cd5679df94ce@osc.co.cr>

Anyway, I'll count that as a NAK from Luke.  what do others here think?

I wish to guage if I were to submit a functional pull request for one or
both of these RPC calls, if would it be likely to be accepted.

If so I'm happy to contribute my time, otherwise...

On 09/29/2017 03:13 PM, Dan Libby wrote:
> It seems to me that the same statement can be made for *any* key storage
> mechanism depending on one's security/threat model, including
> bitcoin-core's internal wallet storage.  There certainly are cases where
> a paper (or metal) offline wallet makes a lot of sense, particularly for
> long-term offline storage... something that electronic media pretty much
> sucks at.
> 
> Though if you care to elaborate I'd be interested to learn of your
> specific critiques, if you have any beyond the generic statements here:
> https://en.bitcoin.it/wiki/Paper_wallet
> 
> Regardless, the APIs I've proposed have uses beyond paper wallets.  It
> can also be used by third party wallets, or any number of reasons that
> individuals or devs might have to generate keys.
> 
> 
> 
> On 09/29/2017 02:03 PM, Luke Dashjr wrote:
>> Paper wallets are a safety hazard, insecure, and generally not advisable.
>>
>>
>> On Friday 29 September 2017 5:29:17 PM Dan Libby via bitcoin-dev wrote:
>>> Hi,
>>>
>>> I'm writing to suggest and discuss the addition of paper wallet
>>> functionality in bitcoin-core software, starting with a single new RPC
>>> call: genExternalAddress [type].
>>>
>>> -- rationale --
>>>
>>> bitcoin-core is the most trusted and most secure bitcoin implementation.
>>>
>>> Yet today (unless I've missed something) paper wallet generation
>>> requires use of third party software, or even a website such as
>>> bitaddress.org.  This requires placing trust in an additional body of
>>> code from a less-trusted and less peer-reviewed source.  Ideally, one
>>> would personally audit this code for one's self, but in practice that
>>> rarely happens.
>>>
>>> In the case of a website generator, the code must be audited again each
>>> time it is downloaded.  I cannot in good faith recommend to anyone to
>>> use such third party tools for wallet generation.
>>>
>>> I *would* recommend for others to trust a paper wallet that uses
>>> address(es) generated by bitcoin-core itself.
>>>
>>> At least for me, this requirement to audit (or implicitly trust) a
>>> secondary body of bitcoin code places an additional hurdle or
>>> disincentive on the use of paper wallets, or indeed private keys
>>> generated outside of bitcoin-core for any purpose.
>>>
>>> Unfortunately, one cannot simply use getnewaddress, getaccountaddress,
>>> or getrawchangeaddress for this purpose, because the associated private
>>> keys are added to the bitcoin-core wallet and cannot be removed... or in
>>> the case of hd-wallets are deterministically derived.
>>>
>>> As such, I'm throwing out the following half-baked proposal as a
>>> starting point for discussion:
>>>
>>>
>>> -----
>>>
>>>     genexternaladdress ( "type" )
>>>
>>>     Returns a new Bitcoin address and private key for receiving
>>>     payments. This key/address is intended for external usage such as
>>>     paper wallets and will not be used by internal wallet nor written to
>>>     disk.
>>>
>>>     Arguments:
>>>     1. "type"        (string, optional) one of: p2pkh, p2sh-p2wpkh
>>>                                         default: p2sh-p2wpkh
>>>
>>>     Result:
>>>     {
>>>         "privKey"    (string) The private key in wif format.
>>>         "address"    (string) The address in p2pkh or p2sh-p2wpkh
>>>                               format.
>>>     }
>>>
>>>     Examples:
>>>     > bitcoin-cli genexternaladdress
>>>
>>> ----
>>>
>>> This API is simple to implement and use.  It provides enough
>>> functionality for any moderately skilled developer to create their own
>>> paper wallet creation script using any scripting language, or even for
>>> advanced users to perform using bitcoin-cli or debug console.
>>>
>>> If consensus here is in favor of including such an API, I will be happy
>>> to take a crack at implementing it and submitting a pull request.
>>>
>>> If anyone has reasons why it is a BAD IDEA to include such an RPC call
>>> in bitcoind, I'm curious to hear it.
>>>
>>> Also, I welcome suggestions for a better name, or maybe there could be
>>> some improvements to the param(s), such as calling p2sh-p2wpkh "segwit"
>>> instead.
>>>
>>>
>>> ---- further work ----
>>>
>>>
>>> Further steps could be taken in this direction, but are not necessary
>>> for a useful first-step.  In particular:
>>>
>>> 1. an RPC call to generate an external HD wallet seed.
>>> 2. an RPC call to generate N key/address pairs from a given seed.
>>> 3. GUI functionality in bitcoin-qt to facilitate easy paper wallet
>>> generation (and printing?) for end-users, complete with nice graphics,
>>> qr codes, etc.
>>>
>>>
>>>
>>>
>>>
>>>
>>>
>>>
>>>
>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> 


-- 
Dan Libby

Open Source Consulting S.A.
Santa Ana, Costa Rica
http://osc.co.cr
phone: 011 506 2204 7018
Fax: 011 506 2223 7359

From greg at xiph.org  Sat Sep 30 00:47:54 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Sat, 30 Sep 2017 00:47:54 +0000
Subject: [bitcoin-dev] Rebatable fees & incentive-safe fee markets
In-Reply-To: <CAEgR2PGrf+4pQRyNC_xKVEKXimKTWveGK9q6YJeZkG0_r=8tkg@mail.gmail.com>
References: <CAEgR2PGCZ=F85yjAbZgC6NtzhpdgBL3n4M2jowN12wJ7x-Ai1A@mail.gmail.com>
	<CAEgR2PGrxDQE0k8WX4XXz9GN-RAL6JB51ST9Hdz=ba36gRCa6A@mail.gmail.com>
	<CAEgR2PFjt=ihzRBhNXbHTAJz1R+3vz8o-zRZkDA3iBo39x9cTQ@mail.gmail.com>
	<CAEgR2PFfSjJjkTYq+DAmTzmkHPxqhn6fUDoXTzrRebz+OoUgqw@mail.gmail.com>
	<CAEgR2PG5ZueHKDXbsPDEjQG7xAYBa_JAtPZo9n1V2=STC1srpA@mail.gmail.com>
	<CAEgR2PGPQ1e9SmoWOS3V+N9v+OWiM4g3nPN3d9urc+DfkWEJ7A@mail.gmail.com>
	<CAEgR2PEKkHH6+Sh8cQGF83-s1tpwQZgd0fiuNz_xyWu0mUPfCA@mail.gmail.com>
	<CAEgR2PEyWFO1RFohVEpcb-M7aM-8xjCFvDPeJPD4zF4yTCyZ0A@mail.gmail.com>
	<CAEgR2PGrf+4pQRyNC_xKVEKXimKTWveGK9q6YJeZkG0_r=8tkg@mail.gmail.com>
Message-ID: <CAAS2fgRbC46Wii0KOU6B+5v+OBcSp5syN-oWkNByBdZbmwr3Wg@mail.gmail.com>

On Fri, Sep 29, 2017 at 10:43 AM, Daniele Pinna via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> As an example, mined blocks currently carry ~0.8 btc in fees right now. If I
> were to submit a transaction paying 1 btc in maximal money fees, then the
> miner would be incentivized to include my transaction alone to avoid that
> lower fee paying transactions reduce the amount of fees he can earn from my
> transaction alone. This would mean that I could literally clog the network
> by paying 1btc every ten minutes.

If I'm not mistaken that is is nothing new or interesting: You can
delay some transaction by paying more than it offered by every block
you delay it from. E.g. if the next full block would pay 0.8 BTC in
fees, you just need to make transactions paying more than that. But
you'll pay it for each delay and the people you push out only pay once
(when they are successful), so it gets awfully expensive fast.

(Arguably the monopoly price model is better because outbidding party
doesn't need to bloat the chain to do their thing; arguable its
somewhat worse because its harder to do by accident.)

My thought on this was the same as PT's initial: miners and users can
arrange OOB payments (and/or coinjoin rebates) and bypass this. I
don't see why it wouldn't be in their individual best interest to do
so, and if they do that would likely be a centralizing effect.

From jtimon at jtimon.cc  Sat Sep 30 03:53:00 2017
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Sat, 30 Sep 2017 05:53:00 +0200
Subject: [bitcoin-dev] Rebatable fees & incentive-safe fee markets
In-Reply-To: <5F7A4F74-B108-4E30-A3F4-4125BBD0F819@friedenbach.org>
References: <CAEgR2PGCZ=F85yjAbZgC6NtzhpdgBL3n4M2jowN12wJ7x-Ai1A@mail.gmail.com>
	<CAEgR2PGrxDQE0k8WX4XXz9GN-RAL6JB51ST9Hdz=ba36gRCa6A@mail.gmail.com>
	<CAEgR2PFjt=ihzRBhNXbHTAJz1R+3vz8o-zRZkDA3iBo39x9cTQ@mail.gmail.com>
	<CAEgR2PFfSjJjkTYq+DAmTzmkHPxqhn6fUDoXTzrRebz+OoUgqw@mail.gmail.com>
	<CAEgR2PG5ZueHKDXbsPDEjQG7xAYBa_JAtPZo9n1V2=STC1srpA@mail.gmail.com>
	<CAEgR2PGPQ1e9SmoWOS3V+N9v+OWiM4g3nPN3d9urc+DfkWEJ7A@mail.gmail.com>
	<CAEgR2PEKkHH6+Sh8cQGF83-s1tpwQZgd0fiuNz_xyWu0mUPfCA@mail.gmail.com>
	<CAEgR2PEyWFO1RFohVEpcb-M7aM-8xjCFvDPeJPD4zF4yTCyZ0A@mail.gmail.com>
	<CAEgR2PGrf+4pQRyNC_xKVEKXimKTWveGK9q6YJeZkG0_r=8tkg@mail.gmail.com>
	<5F7A4F74-B108-4E30-A3F4-4125BBD0F819@friedenbach.org>
Message-ID: <CABm2gDqXXvNCZ7EyKuwudB5J0YDX7hNnXHPZNxTO0_JsM+yNHg@mail.gmail.com>

I really don't see how this "outlier behaviour" can be prevented. I think
it would be the norm even with your proposed "fix". Perhaps I'm missing
something too.

On 29 Sep 2017 5:24 pm, "Mark Friedenbach via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> This is correct. Under assumptions of a continuous mempool model however
> this should be considered the outlier behavior, other than a little bit of
> empty space at the end, now and then. A maximum fee rate calculated as a
> filter over past block rates could constrain this outlier behavior from
> ever happening too.
>
> > On Sep 29, 2017, at 3:43 AM, Daniele Pinna <daniele.pinna at gmail.com>
> wrote:
> >
> > Maybe I'm getting this wrong but wouldn't this scheme imply that a miner
> is incentivized to limit the amount of transactions in a block to capture
> the maximum fee of the ones included?
> >
> > As an example, mined blocks currently carry ~0.8 btc in fees right now.
> If I were to submit a transaction paying 1 btc in maximal money fees, then
> the miner would be incentivized to include my transaction alone to avoid
> that lower fee paying transactions reduce the amount of fees he can earn
> from my transaction alone. This would mean that I could literally clog the
> network by paying 1btc every ten minutes.
> >
> > Am I missing something?
> >
> > Daniele
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170930/809576bf/attachment.html>

From jtimon at jtimon.cc  Sat Sep 30 03:55:58 2017
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Sat, 30 Sep 2017 05:55:58 +0200
Subject: [bitcoin-dev] Rebatable fees & incentive-safe fee markets
In-Reply-To: <CABm2gDqXXvNCZ7EyKuwudB5J0YDX7hNnXHPZNxTO0_JsM+yNHg@mail.gmail.com>
References: <CAEgR2PGCZ=F85yjAbZgC6NtzhpdgBL3n4M2jowN12wJ7x-Ai1A@mail.gmail.com>
	<CAEgR2PGrxDQE0k8WX4XXz9GN-RAL6JB51ST9Hdz=ba36gRCa6A@mail.gmail.com>
	<CAEgR2PFjt=ihzRBhNXbHTAJz1R+3vz8o-zRZkDA3iBo39x9cTQ@mail.gmail.com>
	<CAEgR2PFfSjJjkTYq+DAmTzmkHPxqhn6fUDoXTzrRebz+OoUgqw@mail.gmail.com>
	<CAEgR2PG5ZueHKDXbsPDEjQG7xAYBa_JAtPZo9n1V2=STC1srpA@mail.gmail.com>
	<CAEgR2PGPQ1e9SmoWOS3V+N9v+OWiM4g3nPN3d9urc+DfkWEJ7A@mail.gmail.com>
	<CAEgR2PEKkHH6+Sh8cQGF83-s1tpwQZgd0fiuNz_xyWu0mUPfCA@mail.gmail.com>
	<CAEgR2PEyWFO1RFohVEpcb-M7aM-8xjCFvDPeJPD4zF4yTCyZ0A@mail.gmail.com>
	<CAEgR2PGrf+4pQRyNC_xKVEKXimKTWveGK9q6YJeZkG0_r=8tkg@mail.gmail.com>
	<5F7A4F74-B108-4E30-A3F4-4125BBD0F819@friedenbach.org>
	<CABm2gDqXXvNCZ7EyKuwudB5J0YDX7hNnXHPZNxTO0_JsM+yNHg@mail.gmail.com>
Message-ID: <CABm2gDqmOXGZ_qxyNjFYg8qTRu4Tmo7V+zYZCt0j5RekUNVkWw@mail.gmail.com>

Gmaxwell I think what's new is that in this case, with a single tx you
would take out all txs with fee below 1 btc. With current rules, you would
only remove enoguh txs for that one to fit, not empty the whole block and
mine only a block with that single tx.

On 30 Sep 2017 5:53 am, "Jorge Tim?n" <jtimon at jtimon.cc> wrote:

> I really don't see how this "outlier behaviour" can be prevented. I think
> it would be the norm even with your proposed "fix". Perhaps I'm missing
> something too.
>
> On 29 Sep 2017 5:24 pm, "Mark Friedenbach via bitcoin-dev" <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> This is correct. Under assumptions of a continuous mempool model however
>> this should be considered the outlier behavior, other than a little bit of
>> empty space at the end, now and then. A maximum fee rate calculated as a
>> filter over past block rates could constrain this outlier behavior from
>> ever happening too.
>>
>> > On Sep 29, 2017, at 3:43 AM, Daniele Pinna <daniele.pinna at gmail.com>
>> wrote:
>> >
>> > Maybe I'm getting this wrong but wouldn't this scheme imply that a
>> miner is incentivized to limit the amount of transactions in a block to
>> capture the maximum fee of the ones included?
>> >
>> > As an example, mined blocks currently carry ~0.8 btc in fees right now.
>> If I were to submit a transaction paying 1 btc in maximal money fees, then
>> the miner would be incentivized to include my transaction alone to avoid
>> that lower fee paying transactions reduce the amount of fees he can earn
>> from my transaction alone. This would mean that I could literally clog the
>> network by paying 1btc every ten minutes.
>> >
>> > Am I missing something?
>> >
>> > Daniele
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170930/23101914/attachment-0001.html>

From dev at jonasschnelli.ch  Sat Sep 30 04:49:52 2017
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Fri, 29 Sep 2017 21:49:52 -0700
Subject: [bitcoin-dev] Paper Wallet support in bitcoin-core
In-Reply-To: <e43c6e06-0bdc-360e-eb5c-a3726e4f0fc8@osc.co.cr>
References: <e43c6e06-0bdc-360e-eb5c-a3726e4f0fc8@osc.co.cr>
Message-ID: <96328209-9249-44BC-957A-4EF8DE014E2D@jonasschnelli.ch>


> Hi,
> 
> I'm writing to suggest and discuss the addition of paper wallet
> functionality in bitcoin-core software, starting with a single new RPC
> call: genExternalAddress [type].
> 

AFAIK, client implementations such as your proposal are off-topic for this ML.
Better use bitcoin-core-dev (ML or IRC) or Github (bitcoin/bitcoin) for such proposals.


> On 09/29/2017 02:03 PM, Luke Dashjr wrote:
> Paper wallets are a safety hazard, insecure, and generally not advisable.
> 

I have to agree with Luke.
And I would also extend those concerns to BIP39 plaintext paper backups.

IMO, private keys should be generated and used (signing) on a trusted, minimal and offline hardware/os. They should never leave the device over the channel used for the signing I/O. Users should have no way to view or export the private keys (expect for the seed backup). Backups should be encrypted (whoever finds the paper backup should need a second factor to decrypt) and the restore process should be footgun-safe (especially the lost-passphrase deadlock).


/jonas
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170929/4a7078c9/attachment.sig>

From greg at xiph.org  Sat Sep 30 08:54:57 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Sat, 30 Sep 2017 08:54:57 +0000
Subject: [bitcoin-dev] Rebatable fees & incentive-safe fee markets
In-Reply-To: <CABm2gDqmOXGZ_qxyNjFYg8qTRu4Tmo7V+zYZCt0j5RekUNVkWw@mail.gmail.com>
References: <CAEgR2PGCZ=F85yjAbZgC6NtzhpdgBL3n4M2jowN12wJ7x-Ai1A@mail.gmail.com>
	<CAEgR2PGrxDQE0k8WX4XXz9GN-RAL6JB51ST9Hdz=ba36gRCa6A@mail.gmail.com>
	<CAEgR2PFjt=ihzRBhNXbHTAJz1R+3vz8o-zRZkDA3iBo39x9cTQ@mail.gmail.com>
	<CAEgR2PFfSjJjkTYq+DAmTzmkHPxqhn6fUDoXTzrRebz+OoUgqw@mail.gmail.com>
	<CAEgR2PG5ZueHKDXbsPDEjQG7xAYBa_JAtPZo9n1V2=STC1srpA@mail.gmail.com>
	<CAEgR2PGPQ1e9SmoWOS3V+N9v+OWiM4g3nPN3d9urc+DfkWEJ7A@mail.gmail.com>
	<CAEgR2PEKkHH6+Sh8cQGF83-s1tpwQZgd0fiuNz_xyWu0mUPfCA@mail.gmail.com>
	<CAEgR2PEyWFO1RFohVEpcb-M7aM-8xjCFvDPeJPD4zF4yTCyZ0A@mail.gmail.com>
	<CAEgR2PGrf+4pQRyNC_xKVEKXimKTWveGK9q6YJeZkG0_r=8tkg@mail.gmail.com>
	<5F7A4F74-B108-4E30-A3F4-4125BBD0F819@friedenbach.org>
	<CABm2gDqXXvNCZ7EyKuwudB5J0YDX7hNnXHPZNxTO0_JsM+yNHg@mail.gmail.com>
	<CABm2gDqmOXGZ_qxyNjFYg8qTRu4Tmo7V+zYZCt0j5RekUNVkWw@mail.gmail.com>
Message-ID: <CAAS2fgQR48pLBPh7=yntE8iXcQSeQU22nptze76DjAUJ9A1KSQ@mail.gmail.com>

On Sat, Sep 30, 2017 at 3:55 AM, Jorge Tim?n via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Gmaxwell I think what's new is that in this case, with a single tx you would
> take out all txs with fee below 1 btc. With current rules, you would only
> remove enoguh txs for that one to fit, not empty the whole block and mine
> only a block with that single tx.

I think this is not relevant: By paying the same amount you can delay
the same transactions today.

The difference is that your 'attack' wastes less capacity-- it can be
a simple 150 weight txn rather than a collection that add up to almost
4 million weight; but it costs exactly the same.  To the extent that
this difference matters at all, I think it's an improvement.

The only argument that I see for it not being one is that it's easier
to do accidentally.  But part of the purpose of this alternative
market is to achieve an equilibrium other than the ultrabloating one;
so yes, you're going to find outcomes where the blocks are not
maximally full.

I wonder how the economics would respond if there is a PI controller
on the maximum size, so that 'lost space' in single blocks with bogon
fee transactions could be recovered if doing so didn't change the
medium timescale total. I think the paper's analysis assumes there is
no limit, but that is impractical for technical reasons (e.g. making
it impossible to budget communications and storage capacity for
nodes...).

From aritter at gmail.com  Sat Sep 30 09:35:05 2017
From: aritter at gmail.com (Adam Ritter)
Date: Sat, 30 Sep 2017 11:35:05 +0200
Subject: [bitcoin-dev] Paper Wallet support in bitcoin-core
In-Reply-To: <96328209-9249-44BC-957A-4EF8DE014E2D@jonasschnelli.ch>
References: <e43c6e06-0bdc-360e-eb5c-a3726e4f0fc8@osc.co.cr>
	<96328209-9249-44BC-957A-4EF8DE014E2D@jonasschnelli.ch>
Message-ID: <CAKuKjyWN-K9xSuwebtTxEG7Em6jSLsKdE8VY2n72FBdpeycZxA@mail.gmail.com>

I'm happy to help with secure paper wallet support. Bitcoin core is already
used offline by the Glacier Protocol, though there's no official offline
support.

I extended the Glacier Protocol with an extra password derivation function.
I used Scrypt with 2GB RAM requirement, though maybe using Argon2id V1.3
would be better.

Also I'd prefer using BIP45 Multisig HD Wallets over a multisig address, as
in the current Glacier Protocol implementation the redeem key is public
because of the test withdrawal transaction.

On Sat, Sep 30, 2017 at 6:49 AM, Jonas Schnelli via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> > Hi,
> >
> > I'm writing to suggest and discuss the addition of paper wallet
> > functionality in bitcoin-core software, starting with a single new RPC
> > call: genExternalAddress [type].
> >
>
> AFAIK, client implementations such as your proposal are off-topic for this
> ML.
> Better use bitcoin-core-dev (ML or IRC) or Github (bitcoin/bitcoin) for
> such proposals.
>
>
> > On 09/29/2017 02:03 PM, Luke Dashjr wrote:
> > Paper wallets are a safety hazard, insecure, and generally not advisable.
> >
>
> I have to agree with Luke.
> And I would also extend those concerns to BIP39 plaintext paper backups.
>
> IMO, private keys should be generated and used (signing) on a trusted,
> minimal and offline hardware/os. They should never leave the device over
> the channel used for the signing I/O. Users should have no way to view or
> export the private keys (expect for the seed backup). Backups should be
> encrypted (whoever finds the paper backup should need a second factor to
> decrypt) and the restore process should be footgun-safe (especially the
> lost-passphrase deadlock).
>
>
> /jonas
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170930/8ad1e451/attachment.html>

From dan at osc.co.cr  Sat Sep 30 07:06:42 2017
From: dan at osc.co.cr (Dan Libby)
Date: Sat, 30 Sep 2017 00:06:42 -0700
Subject: [bitcoin-dev] Paper Wallet support in bitcoin-core
In-Reply-To: <96328209-9249-44BC-957A-4EF8DE014E2D@jonasschnelli.ch>
References: <e43c6e06-0bdc-360e-eb5c-a3726e4f0fc8@osc.co.cr>
	<96328209-9249-44BC-957A-4EF8DE014E2D@jonasschnelli.ch>
Message-ID: <05caf783-cba2-b37a-0f28-2d0020386279@osc.co.cr>

On 09/29/2017 09:49 PM, Jonas Schnelli wrote:

> AFAIK, client implementations such as your proposal are off-topic for this ML.
> Better use bitcoin-core-dev (ML or IRC) or Github (bitcoin/bitcoin) for such proposals.

ok, thanks.  I will take the proposal there.

> I have to agree with Luke.

thanks for your feedback.

> And I would also extend those concerns to BIP39 plaintext paper backups.
> 
> IMO, private keys should be generated and used (signing) on a trusted, minimal and offline hardware/os.

uhh.... do you apply this logic to the bitcoin-core wallet itself?
because clearly it generates keys and is intended to be used for signing
in online environments.  Lots of real-world use-cases depend on that today.

So if existing bitcoin-core wallet behavior is "ok" in any context then
how is it any worse for it to generate a key/address that will not be
stored in the internal wallet, and the user may do with it as they wish?
 That is all my proposed RPC call does and unlike the existing RPC calls
it never even stores the key or address to disk.  It is also useful when
run on an offline hardware device, such as a laptop connected to an
non-networked printer.

Further, you mention the word trust.  That's the crux of the matter.  As
a full node operator, I've already placed my trust in the bitcoin-core
developers and dev/release practices.  Why exactly should I trust the
software in this minimal offline hardware/os you mention if it is NOT
bitcoin core?  And even if open source software, does that not at least
double my workload/expense to audit theat software in addition to
bitcoin-core?

> Users should have no way to view or export the private keys (expect for 
> the seed backup).

I suppose that in your view then, dumpprivkey and dumpwallet RPCs should
be removed from bitcoin-core to fit this paradigm?

(Personally I actively avoid wallet software that takes this view and
treat users like children, preventing individuals direct access to the
keys for their own funds, which disempowers and sometimes results in a
form of lockin)

> Backups should be encrypted (whoever finds the paper backup should need a second factor to decrypt) and the restore process should be footgun-safe (especially the lost-passphrase deadlock).

This is more relevant to an application layer above the 2 RPC calls I
proposed. Encryption could be implemented (or not) by whichever software
calls the proposed RPC apis.  And further the APIs can be called for
use-cases beyond just paper wallets.




From sjors at sprovoost.nl  Sat Sep 30 07:36:46 2017
From: sjors at sprovoost.nl (Sjors Provoost)
Date: Sat, 30 Sep 2017 09:36:46 +0200
Subject: [bitcoin-dev] Paper Wallet support in bitcoin-core
In-Reply-To: <96328209-9249-44BC-957A-4EF8DE014E2D@jonasschnelli.ch>
References: <e43c6e06-0bdc-360e-eb5c-a3726e4f0fc8@osc.co.cr>
	<96328209-9249-44BC-957A-4EF8DE014E2D@jonasschnelli.ch>
Message-ID: <2B95B25F-F47C-4867-A1A6-144200F7B2D4@sprovoost.nl>



> Op 30 sep. 2017, om 06:49 heeft Jonas Schnelli via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:
> 
>> On 09/29/2017 02:03 PM, Luke Dashjr wrote:
>> Paper wallets are a safety hazard, insecure, and generally not advisable.
>> 
> 
> I have to agree with Luke.
> And I would also extend those concerns to BIP39 plaintext paper backups.
> 
> IMO, private keys should be generated and used (signing) on a trusted, minimal and offline hardware/os. They should never leave the device over the channel used for the signing I/O. Users should have no way to view or export the private keys (expect for the seed backup). Backups should be encrypted (whoever finds the paper backup should need a second factor to decrypt) and the restore process should be footgun-safe (especially the lost-passphrase deadlock).

I believe BIP39 does an excellent job at reducing the amount of bitcoin permanently lost. Stolen funds can at least in theory be retrieved at some future date. There's a trade-off between having a backup process that is secure and one that people actually use. I don't know the right answer, and tend to agree it's better left to individual wallets to decide.

Sjors
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170930/d70b17b5/attachment-0001.sig>

From vitteaymeric at gmail.com  Sat Sep 30 11:10:45 2017
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Sat, 30 Sep 2017 13:10:45 +0200
Subject: [bitcoin-dev] Paper Wallet support in bitcoin-core
In-Reply-To: <96328209-9249-44BC-957A-4EF8DE014E2D@jonasschnelli.ch>
References: <e43c6e06-0bdc-360e-eb5c-a3726e4f0fc8@osc.co.cr>
	<96328209-9249-44BC-957A-4EF8DE014E2D@jonasschnelli.ch>
Message-ID: <f83df1e7-9a90-64e4-e644-f10262408791@gmail.com>

I am not sure that this discussion is really off topic for this list,
this is a real issue, would everybody even here say that they feel very
comfortable with their keys? That if something happen to them there is
no pb for the family or trusted parties to retrieve the keys? That this
process is secured in case the trusted parties are finally untrusted? etc

I don't think so, if experts are not comfortable then how can we expect
non experts people to manage this? (except going to a wallet sw asking
them all the info, even online, crazy but they just don't know)

Comments below


Le 30/09/2017 ? 06:49, Jonas Schnelli via bitcoin-dev a ?crit?:

> And I would also extend those concerns to BIP39 plaintext paper backups.

Personnaly I don't see also the advantage of proposals such as BIP39 versus backing up a seed 

> IMO, private keys should be generated and used (signing) on a trusted, minimal and offline hardware/os.

This is the intent of https://github.com/Ayms/bitcoin-wallets and
https://github.com/Ayms/zcash-wallets

But even myself can get confused, where did I put the backup seed? But
remember you did not backup the seed but the first derivation step and
you mixed it secretely, so nobody can reconstitute it except you,
well... what did I do exactly? What version is my real wallet? What is
the encryption key? How did I do last time to add the key in qt? etc

>  They should never leave the device over the channel used for the signing I/O. Users should have no way to view or export the private keys (expect for the seed backup). Backups should be encrypted (whoever finds the paper backup should need a second factor to decrypt) and the restore process should be footgun-safe (especially the lost-passphrase deadlock).

Is there really nothing existing yet to address all of this?


-- 
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms


From andreas at schildbach.de  Sat Sep 30 15:33:01 2017
From: andreas at schildbach.de (Andreas Schildbach)
Date: Sat, 30 Sep 2017 17:33:01 +0200
Subject: [bitcoin-dev] Why the BIP-72 Payment Protocol URI Standard is
 Insecure Against MITM Attacks
In-Reply-To: <20170929025538.GC12303@savin.petertodd.org>
References: <20170927160654.GA12492@savin.petertodd.org>
	<oqihpf$5gc$1@blaine.gmane.org>
	<B5DE4E92-C5B3-4C01-A148-E3C46C897323@sprovoost.nl>
	<20170929025538.GC12303@savin.petertodd.org>
Message-ID: <oqodf6$30b$1@blaine.gmane.org>

Generally agreed. This is why I nack'ed BIP72 years ago when we
discussed about standardization.

However, there are many ways to use BIP70 without BIP72. BIP72 is just a
kludge to biggy-pack the payment protocol onto BIP21. And also, as you
note, BIP72 can be easily fixed using a hash parameter.


On 09/29/2017 04:55 AM, Peter Todd via bitcoin-dev wrote:
> On Thu, Sep 28, 2017 at 03:43:05PM +0300, Sjors Provoost via bitcoin-dev wrote:
>> Andreas Schildbach wrote:
>>> This feels redundant to me; the payment protocol already has an
>>> expiration time.
>>
>> The BIP-70 payment protocol has significant overhead and most importantly requires back and forth. Emailing a bitcoin address or printing it on an invoice is much easier, so I would expect people to keep doing that.
> 
> The BIP-70 payment protocol used via BIP-72 URI's is insecure, as payment qr
> codes don't cryptographically commit to the identity of the merchant, which
> means a MITM attacker can redirect the payment if they can obtain a SSL cert
> that the wallet accepts.
> 
> For example, if I have a wallet on my phone and go to pay a
> merchant, a BIP-72 URI will look like the following(1):
> 
>     bitcoin:mq7se9wy2egettFxPbmn99cK8v5AFq55Lx?amount=0.11&r=https://merchant.com/pay.php?h%3D2a8628fc2fbe
> 
> A wallet following the BIP-72 standard will "ignore the bitcoin
> address/amount/label/message in the URI and instead fetch a PaymentRequest
> message and then follow the payment protocol, as described in BIP 70."
> 
> So my phone will make a second connection - likely on a second network with a
> totally different set of MITM attackers - to https://merchant.com
> 
> In short, while my browser may have gotten the correct URL with the correct
> Bitcoin address, by using the payment protocol my wallet is discarding that
> information and giving MITM attackers a second chance at redirecting my payment
> to them. That wallet is also likely using an off-the-shelf SSL library, with
> nothing other than an infrequently updated set of root certificates to use to
> verify the certificate; your browser has access to a whole host of better
> technologies, such as HSTS pinning, certificate transparency, and frequently
> updated root certificate lists with proper revocation (see Symantec).
> 
> As an ad-hoc, unstandardized, extension Android Wallet for Bitcoin at least
> supports a h= parameter with a hash commitment to what the payment request
> should be, and will reject the MITM attacker if that hash doesn't match. But
> that's not actually in the standard itself, and as far as I can tell has never
> been made into a BIP.
> 
> As-is BIP-72 is very dangerous and should be depreciated, with a new BIP made
> to replace it.
> 
> 1) As an aside, it's absolutely hilarious that this URL taken straight from
>    BIP-72 has the merchant using PHP, given its truly terrible track record for
>    security.
> 
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 



From dev at jonasschnelli.ch  Sat Sep 30 21:14:44 2017
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Sat, 30 Sep 2017 14:14:44 -0700
Subject: [bitcoin-dev] Paper Wallet support in bitcoin-core
In-Reply-To: <05caf783-cba2-b37a-0f28-2d0020386279@osc.co.cr>
References: <e43c6e06-0bdc-360e-eb5c-a3726e4f0fc8@osc.co.cr>
	<96328209-9249-44BC-957A-4EF8DE014E2D@jonasschnelli.ch>
	<05caf783-cba2-b37a-0f28-2d0020386279@osc.co.cr>
Message-ID: <19DF6343-462D-4C99-A526-B3A5A10E8F37@jonasschnelli.ch>

> 
> uhh.... do you apply this logic to the bitcoin-core wallet itself?
> because clearly it generates keys and is intended to be used for signing
> in online environments.  Lots of real-world use-cases depend on that today.

The current Bitcoin Core wallet setup is not as ideal as it could be.
An good example is, that the wallet and the full node (the p2p logic on 8333) do share the same process (same memory space).
AFAIK a lot of users use Core in watch-only mode and do the signing offline (offline / through HWWs).
Although, Core has currently no direct support for offline signing (expect the rawtx API which are pretty expert-ish).

The Core development process goes into that direction but it takes time due to the strict and extremely important code quality insurance.

> 
> So if existing bitcoin-core wallet behavior is "ok" in any context then
> how is it any worse for it to generate a key/address that will not be
> stored in the internal wallet, and the user may do with it as they wish?
> That is all my proposed RPC call does and unlike the existing RPC calls
> it never even stores the key or address to disk.  It is also useful when
> run on an offline hardware device, such as a laptop connected to an
> non-networked printer.

IMO we should make it better not worse.
Paper wallets delude to do address reuse, the spending-procedure is unclear, and very likely insecure.
A quick photo-snapshot by an attack may result in a full compromised key.
Printer buffers, etc. are also something to worry here.

> Further, you mention the word trust.  That's the crux of the matter.  As
> a full node operator, I've already placed my trust in the bitcoin-core
> developers and dev/release practices.  Why exactly should I trust the
> software in this minimal offline hardware/os you mention if it is NOT
> bitcoin core?  And even if open source software, does that not at least
> double my workload/expense to audit theat software in addition to
> bitcoin-core?

I think Bitcoin Core does a great job there. But not sure about other security layers are outside of Core.
Especially your operating system.
The reason why we see a growing demand in hardware wallets is probably because people no longer trust in current available operating systems as well as current used desktop/laptop CPUs (like Intel wit it?s MME, etc.).

> 
>> Users should have no way to view or export the private keys (expect for
>> the seed backup).
> 
> I suppose that in your view then, dumpprivkey and dumpwallet RPCs should
> be removed from bitcoin-core to fit this paradigm?

Yes. That actually something we are considering (especially if we would allow BIP44 or other HD public key derivation forms).
Also, we heard of "support sessions? on IRC where attackers told victims they must enter ?dumpprivkey? in the Console and give them the output in order ?to fix the problem?.

> (Personally I actively avoid wallet software that takes this view and
> treat users like children, preventing individuals direct access to the
> keys for their own funds, which disempowers and sometimes results in a
> form of lockin)

I dislike that as well ? in general. But I guess most users like self-protection. Also, the user layer is attackable. If _you_ can access the private-keys, an attacker can do also. What most users want is a key-safe that only signs transactions which they could verify beforehand in a safe environment, and not a way to export private keys or something else that can touch the keys.


>> They should never leave the device over the channel used for the signing I/O. Users should have no way to view or export the private keys (expect for the seed backup). Backups should be encrypted (whoever finds the paper backup should need a second factor to decrypt) and the restore process should be footgun-safe (especially the lost-passphrase deadlock).
> 
> Is there really nothing existing yet to address all of this?

The answer is probably: No (for now). But working towards this should be the focus.


---
/jonas

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170930/c2a58417/attachment.sig>

From luke at dashjr.org  Sat Sep 30 23:23:32 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Sat, 30 Sep 2017 23:23:32 +0000
Subject: [bitcoin-dev] Merkle branch verification & tail-call semantics
	for generalized MAST
In-Reply-To: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
Message-ID: <201709302323.33004.luke@dashjr.org>

On Thursday 07 September 2017 12:38:55 AM Mark Friedenbach via bitcoin-dev 
wrote:
> Tail-call execution semantics
> BIP: https://gist.github.com/maaku/f7b2e710c53f601279549aa74eeb5368
> Code: https://github.com/maaku/bitcoin/tree/tail-call-semantics

Just noticed this doesn't count sigops toward the block sigop limit.
Is that really safe? How long would it take, to verify a malicious block with 
only inputs such that there is nearly 4 MB of sigops?

(I do already understand the difficulty in supporting the sigop limit.)

Luke

From vitteaymeric at gmail.com  Sat Sep 30 23:51:12 2017
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Sun, 1 Oct 2017 01:51:12 +0200
Subject: [bitcoin-dev] Paper Wallet support in bitcoin-core
In-Reply-To: <19DF6343-462D-4C99-A526-B3A5A10E8F37@jonasschnelli.ch>
References: <e43c6e06-0bdc-360e-eb5c-a3726e4f0fc8@osc.co.cr>
	<96328209-9249-44BC-957A-4EF8DE014E2D@jonasschnelli.ch>
	<05caf783-cba2-b37a-0f28-2d0020386279@osc.co.cr>
	<19DF6343-462D-4C99-A526-B3A5A10E8F37@jonasschnelli.ch>
Message-ID: <0f7f32a1-5d42-292a-bdbd-e57218ef3cbd@gmail.com>

By "all of this" I meant the other issues that I mentioned too "would
everybody even here say that they feel very comfortable with their keys?
That if something happen to them there is no pb for the family or
trusted parties to retrieve the keys? That this process is secured in
case the trusted parties are finally untrusted? etc", I am extending the
problematic while the very basic concerns are still unsolved

Then I don't agree with the fact that users should not have the control
of their keys, but if I try to summarize, your suggestions probably lead
to the fact that the "wallet" part should be outside of bitcoin-qt, in a
simple offline module (assuming that you can trust the simple sw + the
os + the hw +the cpu, but ok, the pb is the same with a hw wallet),
which I think is a good idea

That's why I made a module some time ago, supposed to be "bitcoin
transactions made simple", you do your transactions offline, check them,
and send them to the network via qt, the web or other, it's working but
is not online on github because unfinished, and unfinished because
nothing is simple and it's unlikely that normal people can use this for
now, unfortunately you need to be a bit online to make your transaction,
fetch the output you want to spend or get the info, then associate the
right key, calculate the fees, that's not simple, that's why it's
different from a standard wallet, but probably a good way

Small sw a bit like a credit card finally, and people know they must not
disclose their code(s) in case they are asked on IRC or elsewhere



Le 30/09/2017 ? 23:14, Jonas Schnelli via bitcoin-dev a ?crit?:
>> uhh.... do you apply this logic to the bitcoin-core wallet itself?
>> because clearly it generates keys and is intended to be used for signing
>> in online environments.  Lots of real-world use-cases depend on that today.
> The current Bitcoin Core wallet setup is not as ideal as it could be.
> An good example is, that the wallet and the full node (the p2p logic on 8333) do share the same process (same memory space).
> AFAIK a lot of users use Core in watch-only mode and do the signing offline (offline / through HWWs).
> Although, Core has currently no direct support for offline signing (expect the rawtx API which are pretty expert-ish).
>
> The Core development process goes into that direction but it takes time due to the strict and extremely important code quality insurance.
>
>> So if existing bitcoin-core wallet behavior is "ok" in any context then
>> how is it any worse for it to generate a key/address that will not be
>> stored in the internal wallet, and the user may do with it as they wish?
>> That is all my proposed RPC call does and unlike the existing RPC calls
>> it never even stores the key or address to disk.  It is also useful when
>> run on an offline hardware device, such as a laptop connected to an
>> non-networked printer.
> IMO we should make it better not worse.
> Paper wallets delude to do address reuse, the spending-procedure is unclear, and very likely insecure.
> A quick photo-snapshot by an attack may result in a full compromised key.
> Printer buffers, etc. are also something to worry here.
>
>> Further, you mention the word trust.  That's the crux of the matter.  As
>> a full node operator, I've already placed my trust in the bitcoin-core
>> developers and dev/release practices.  Why exactly should I trust the
>> software in this minimal offline hardware/os you mention if it is NOT
>> bitcoin core?  And even if open source software, does that not at least
>> double my workload/expense to audit theat software in addition to
>> bitcoin-core?
> I think Bitcoin Core does a great job there. But not sure about other security layers are outside of Core.
> Especially your operating system.
> The reason why we see a growing demand in hardware wallets is probably because people no longer trust in current available operating systems as well as current used desktop/laptop CPUs (like Intel wit it?s MME, etc.).
>
>>> Users should have no way to view or export the private keys (expect for
>>> the seed backup).
>> I suppose that in your view then, dumpprivkey and dumpwallet RPCs should
>> be removed from bitcoin-core to fit this paradigm?
> Yes. That actually something we are considering (especially if we would allow BIP44 or other HD public key derivation forms).
> Also, we heard of "support sessions? on IRC where attackers told victims they must enter ?dumpprivkey? in the Console and give them the output in order ?to fix the problem?.
>
>> (Personally I actively avoid wallet software that takes this view and
>> treat users like children, preventing individuals direct access to the
>> keys for their own funds, which disempowers and sometimes results in a
>> form of lockin)
> I dislike that as well ? in general. But I guess most users like self-protection. Also, the user layer is attackable. If _you_ can access the private-keys, an attacker can do also. What most users want is a key-safe that only signs transactions which they could verify beforehand in a safe environment, and not a way to export private keys or something else that can touch the keys.
>
>
>>> They should never leave the device over the channel used for the signing I/O. Users should have no way to view or export the private keys (expect for the seed backup). Backups should be encrypted (whoever finds the paper backup should need a second factor to decrypt) and the restore process should be footgun-safe (especially the lost-passphrase deadlock).
>> Is there really nothing existing yet to address all of this?
> The answer is probably: No (for now). But working towards this should be the focus.
>
>
> ---
> /jonas
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171001/47634345/attachment-0001.html>

From mark at friedenbach.org  Sat Sep 30 23:51:49 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Sat, 30 Sep 2017 16:51:49 -0700
Subject: [bitcoin-dev] Merkle branch verification & tail-call semantics
	for generalized MAST
In-Reply-To: <201709302323.33004.luke@dashjr.org>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<201709302323.33004.luke@dashjr.org>
Message-ID: <921EB5CF-B472-4BD6-9493-1A681586FB51@friedenbach.org>

10s of seconds if no further restrictions are placed. It would be trivial to include a new per input rule that reduces it to ~1s without cutting off any non-attack script (require sigops per input to be limited to witness/sig size). secp256k1 is now fast enough that we don?t need a separate sigop limit.

> On Sep 30, 2017, at 4:23 PM, Luke Dashjr <luke at dashjr.org> wrote:
> 
> On Thursday 07 September 2017 12:38:55 AM Mark Friedenbach via bitcoin-dev 
> wrote:
>> Tail-call execution semantics
>> BIP: https://gist.github.com/maaku/f7b2e710c53f601279549aa74eeb5368
>> Code: https://github.com/maaku/bitcoin/tree/tail-call-semantics
> 
> Just noticed this doesn't count sigops toward the block sigop limit.
> Is that really safe? How long would it take, to verify a malicious block with 
> only inputs such that there is nearly 4 MB of sigops?
> 
> (I do already understand the difficulty in supporting the sigop limit.)
> 
> Luke

