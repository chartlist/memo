From ZmnSCPxj at protonmail.com  Mon Jun  1 02:34:03 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 01 Jun 2020 02:34:03 +0000
Subject: [bitcoin-dev] Design for a CoinSwap implementation for
	massively improving Bitcoin privacy and fungibility
In-Reply-To: <CAPv7TjZn6+j10a_X_vCG3Qn1Fv19uidw50Cf38NNUvp8m+uh2w@mail.gmail.com>
References: <82d90d57-ad07-fc7d-4aca-2b227ac2068d@riseup.net>
 <CAPv7TjY9h8n-nK_CPiYCWYDcbXpT1gfRMQDgf9VUkcR532rxOw@mail.gmail.com>
 <VxL93WE7bDrK1riquTWTTEgJj9mDQ4W5CuhOgdnnDPeidw2ho6evVh4cLZLz0jEYMqejaD1tiLULVTXkNRbI5A7wSwV49qSwnXcTWCDJ96E=@protonmail.com>
 <CAPv7TjZn6+j10a_X_vCG3Qn1Fv19uidw50Cf38NNUvp8m+uh2w@mail.gmail.com>
Message-ID: <WKC6zH0X8ad2bK_JwklQegyJBKf5rTp1Ub_fPPPkS_EeIkIoc_wcRd9k3a_aq6sFIZ3-gOtG9ubWq3gTPG5fZW5aA1s_2C8-emEsr67Qxjk=@protonmail.com>

Good morning Ruben,


>
> That assumes there will be a second transaction. With SAS I believe we can avoid that, and make it look like this:
>
> ? ? ? ? ? ? ?+---+
> ? ? Alice ---| ? |--- Bob
> ? ? Alice ---| ? |
> ? ? ? Bob ---| ? |
> ? ? ? ? ? ? ?+---+

If Alice is paying to a non-SAS aware payee that just provides an onchain address (i.e. all current payees today), then the 2-of-2 output it gets from the swap (both of whose keys it learns at the end of the swap) is **not** the payee onchain address.
And it cannot just hand over both private keys, because the payee will still want unambiguous ownership of the entire UTXO.
So it needs a second transaction anyway.
(with Schnorr then Alice and payee Carol can act as a single entity/taker to Bob, a la Lightning Nodelets using Composable MuSig, but that is a pretty big increase in protocol complexity)

If Alice does not want to store the remote-generated privkey as well, and use only an HD key, then it also has to make the second transaction.
Alice might want to provide the same assurances as current wallets that memorizing a 12-word or so mnemonic is sufficient backup for all the funds (other than funds currently being swapped), and so would not want to leave any funds in a 2-of-2.

If Bob is operating as a maker, then it also cannot directly use the 2-of-2 output it gets from the swap, and has to make a new 2-of-2 output, for the *next* taker that arrives to request its services.

So there is always going to be a second transaction in a SwapMarket system, I think.


What SAS / private key turnover gets us is that there is not a *third* transaction to move from a 1-of-1 to the next address that makers and takers will be moving anyway, and that the protocol does not have to add communication provisions for special things like adding maker inputs or specifying all destination addresses for the second stage and so on, because those can be done unilaterally once the private key is turned over.


> >A thing I have been trying to work out is whether SAS can be done with more than one participant, like in S6
>
> S6 requires timelocks for each output in order to function, so I doubt it can be made to work with SAS.

Hmmm right right.

Naively it seems both chaining SAS/private key turnover to multiple makers, and a multi-maker S6 augmented with private key turnover, would result in the same number of transactions onchain, but I probably have to go draw some diagrams or something first.

But S6 has the mild advantage that all the funding transactions paying to 2-of-2s *can* appear on the same block, whereas chaining swaps will have a particular order of when the transactions appear onchain, which might be used to derive the order of swaps.
On the other hand, funds claiming in S6 is also ordered in time, so someone paying attention to the mempool could guess as well the order of swaps.


Regards,
ZmnSCPxj

From nadav at shesek.info  Mon Jun  1 08:10:50 2020
From: nadav at shesek.info (Nadav Ivgi)
Date: Mon, 1 Jun 2020 11:10:50 +0300
Subject: [bitcoin-dev] Announcing Bitcoin Wallet Tracker
In-Reply-To: <h-iXaWQ7GCW2m7hWhPPdBalMXR_yzNL6AbK-YV4o-gaHyTxIOu8SwfdVp2hsYL8XrbkV_pry20fKQPSfc2g0uk-r5IrMXX1Ci0A4R1fLr4A=@protonmail.com>
References: <CAGXD5f16OFOTb3fobOPNjrhFkmXk6w=V7cW1LijP+OumEh_3NQ@mail.gmail.com>
 <h-iXaWQ7GCW2m7hWhPPdBalMXR_yzNL6AbK-YV4o-gaHyTxIOu8SwfdVp2hsYL8XrbkV_pry20fKQPSfc2g0uk-r5IrMXX1Ci0A4R1fLr4A=@protonmail.com>
Message-ID: <CAGXD5f2wZ+x1Mc7kak0+Qp5DmBp1ZoED4bu1xw9J7LE6sJxhmw@mail.gmail.com>

Hi Antoine,

I designed both APIs, so they definitely do share some similarities.

It's difficult to compare their performance directly, since
esplora-electrs keeps a full index of everything, while bwt tracks
your wallet addresses only.

If you're only interested in your wallet addresses and don't have a
*really* huge number of them, bwt will definitely perform better, as
it can avoid a lot of unnecessary indexing work. If you do have a lot
of addresses, esplora-electrs will be better suited for the job, as
its designed to deal with high volumes of data and does not rely on
the bitcoind wallet functionality, which was not designed for this.

I'm not sure where the line for "really huge" crosses exactly though,
I have not put this to the test. Definitely if you're tracking
millions of addresses, probably also for hundreds of thousands,
possibly even less?

API design wise, the main differences between the two are:

- Esplora provides every bit of information one might want to know
about transactions/blocks, while bwt intentionally tries to reduce
this to the subset useful in the context of app development.

- bwt provides wallet-contextual information, like key origins next to
addresses and the net change inflicted on the wallet's balance by
transactions.

- Esplora doesn't provide real-time updates (yet), while bwt provides
them using two different mechanisms (SSE and Web Hooks).

Nadav



On Sun, May 31, 2020 at 5:56 PM darosior <darosior at protonmail.com> wrote:
>
> Hi,
>
> I gave a quick look to the http API, and it seems very similar to Esplora's. So I wonder : how does
> bwt compares to Esplora, performance-wise ?
>
> Thanks!
> Antoine
>
>
> ??????? Original Message ???????
> Le samedi, mai 30, 2020 4:16 PM, Nadav Ivgi via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> a ?crit :
>
> Hi all,
>
> I recently released bwt [0], an HD wallet indexer implemented in Rust, using
> a model similar to that of Electrum Personal Server.
>
> It uses the bitcoind wallet functionality to do the heavy lifting and builds
> additional indexes on top of that, which can be queried using the Electrum
> RPC protocol, as well as a more modern, developer-friendly HTTP REST API.
>
> The electrum server can also be used as an electrum plugin [1], which
> integrates the server straight into the electrum client. From the user's
> perspective, this allows connecting electrum directly to a full node.
>
> The HTTP API is my take on a modern design for a wallet tracking API aimed
> at app developers. Some use-cases include using it as a backend for wallets
> (similarly to Samuari's Dojo) or to track deposits to a watch-only xpub
> (similarly to BTCPay's NBXplorer).
>
> Compared to using the bitcoind RPC directly, bwt provides:
>
> - The ability to track an xpub and automatically have new addresses derived
>   and imported as needed, according to the gap limit.
>
> - Two additional indexes, one for looking up the transaction history of
>   addresses, and another one for looking up txo spends (a map of
>   funding_txid:vout => spending_txid:vin).
>
> - Real-time updates using Server-Sent Events [2] (a long-lived streaming HTTP
>   connection) or Web Hooks [3] (an HTTP request sent to a configured URL).
>   The updates being sent [4] directly provide information about the funded
>   and spent wallet txos, instead of the client figuring it out from the tx.
>
> - Some API conveniences and simplifications, like including key origin
>   information directly alongside inputs/outputs [5], the ability to specify
>   key origins in place of addresses (eg. GET /hd/15cb9edc/8/utxos), a compact
>   history format [6], and an easy way to catch-up with missed events [7].
>   Unless explicitly asked for, the API omits information about non-wallet
>   inputs/outputs and protocol-level details like scriptsig and witnesses,
>   which are typically not needed for higher-level app development.
>
> The indexer is designed in a way that minimizes RPC requests to bitcoind. By
> using labels to store key origin information, it is able to index incoming
> transactions using the information available from `listtransactions` alone
> (plus 3 extra rpc requests that don't grow with the number of transactions),
> but requires 1 additional rpc call per outgoing transaction (to learn which
> prevouts were spent). It can index 10k incoming txs in under a second, or a
> mixture of 5k/5k in under 5 seconds. The index is currently entirely in-
> memory and does not get persisted. The indexer logic can be seen in [8].
>
> One major item on the roadmap that I'm hoping to tackle soon is support for
> output script descriptors.
>
> If anyone is interested in contributing, the README has some useful developer
> resources [9] and a handy script for setting up a development environment.
>
> This is an early alpha release, recommended for use with testnet/regtest.
>
> All feedback welcome!
>
> Cheers,
> Nadav
>
> [0] https://github.com/shesek/bwt
> [1] https://github.com/shesek/bwt#electrum-plugin
> [2] https://github.com/shesek/bwt#server-sent-events
> [3] https://github.com/shesek/bwt#web-hooks
> [4] https://github.com/shesek/bwt#event-categories
> [5] https://github.com/shesek/bwt#wallet-transaction-format
> [6] https://github.com/shesek/bwt#get-txssinceblock-heightcompact
> [7] https://github.com/shesek/bwt#catching-up-with-missed-events--re-org-detection
> [8] https://github.com/shesek/bwt/blob/master/src/indexer.rs (sync_transactions and load_transactions_since)
> [9] https://github.com/shesek/bwt#developing
>
>

From rsomsen at gmail.com  Mon Jun  1 10:19:38 2020
From: rsomsen at gmail.com (Ruben Somsen)
Date: Mon, 1 Jun 2020 12:19:38 +0200
Subject: [bitcoin-dev] Design for a CoinSwap implementation for
 massively improving Bitcoin privacy and fungibility
In-Reply-To: <WKC6zH0X8ad2bK_JwklQegyJBKf5rTp1Ub_fPPPkS_EeIkIoc_wcRd9k3a_aq6sFIZ3-gOtG9ubWq3gTPG5fZW5aA1s_2C8-emEsr67Qxjk=@protonmail.com>
References: <82d90d57-ad07-fc7d-4aca-2b227ac2068d@riseup.net>
 <CAPv7TjY9h8n-nK_CPiYCWYDcbXpT1gfRMQDgf9VUkcR532rxOw@mail.gmail.com>
 <VxL93WE7bDrK1riquTWTTEgJj9mDQ4W5CuhOgdnnDPeidw2ho6evVh4cLZLz0jEYMqejaD1tiLULVTXkNRbI5A7wSwV49qSwnXcTWCDJ96E=@protonmail.com>
 <CAPv7TjZn6+j10a_X_vCG3Qn1Fv19uidw50Cf38NNUvp8m+uh2w@mail.gmail.com>
 <WKC6zH0X8ad2bK_JwklQegyJBKf5rTp1Ub_fPPPkS_EeIkIoc_wcRd9k3a_aq6sFIZ3-gOtG9ubWq3gTPG5fZW5aA1s_2C8-emEsr67Qxjk=@protonmail.com>
Message-ID: <CAPv7TjZf60VPKXL2s8bFXEF1kUGS-LMEpuURf4O4CPM3kFuyZQ@mail.gmail.com>

Hi ZmnSCPxj,

>If Alice is paying to a non-SAS aware payee

Yeah, I agree that this use case is not possible without a third
transaction (preferably from the timelocked side, in the case of SAS). My
point was merely that you can swap and simultaneously merge some of your
outputs into the post-swap non-timelocked output, though perhaps that is
not very useful.

Cheers,
Ruben



On Mon, Jun 1, 2020 at 4:34 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Ruben,
>
>
> >
> > That assumes there will be a second transaction. With SAS I believe we
> can avoid that, and make it look like this:
> >
> >              +---+
> >     Alice ---|   |--- Bob
> >     Alice ---|   |
> >       Bob ---|   |
> >              +---+
>
> If Alice is paying to a non-SAS aware payee that just provides an onchain
> address (i.e. all current payees today), then the 2-of-2 output it gets
> from the swap (both of whose keys it learns at the end of the swap) is
> **not** the payee onchain address.
> And it cannot just hand over both private keys, because the payee will
> still want unambiguous ownership of the entire UTXO.
> So it needs a second transaction anyway.
> (with Schnorr then Alice and payee Carol can act as a single entity/taker
> to Bob, a la Lightning Nodelets using Composable MuSig, but that is a
> pretty big increase in protocol complexity)
>
> If Alice does not want to store the remote-generated privkey as well, and
> use only an HD key, then it also has to make the second transaction.
> Alice might want to provide the same assurances as current wallets that
> memorizing a 12-word or so mnemonic is sufficient backup for all the funds
> (other than funds currently being swapped), and so would not want to leave
> any funds in a 2-of-2.
>
> If Bob is operating as a maker, then it also cannot directly use the
> 2-of-2 output it gets from the swap, and has to make a new 2-of-2 output,
> for the *next* taker that arrives to request its services.
>
> So there is always going to be a second transaction in a SwapMarket
> system, I think.
>
>
> What SAS / private key turnover gets us is that there is not a *third*
> transaction to move from a 1-of-1 to the next address that makers and
> takers will be moving anyway, and that the protocol does not have to add
> communication provisions for special things like adding maker inputs or
> specifying all destination addresses for the second stage and so on,
> because those can be done unilaterally once the private key is turned over.
>
>
> > >A thing I have been trying to work out is whether SAS can be done with
> more than one participant, like in S6
> >
> > S6 requires timelocks for each output in order to function, so I doubt
> it can be made to work with SAS.
>
> Hmmm right right.
>
> Naively it seems both chaining SAS/private key turnover to multiple
> makers, and a multi-maker S6 augmented with private key turnover, would
> result in the same number of transactions onchain, but I probably have to
> go draw some diagrams or something first.
>
> But S6 has the mild advantage that all the funding transactions paying to
> 2-of-2s *can* appear on the same block, whereas chaining swaps will have a
> particular order of when the transactions appear onchain, which might be
> used to derive the order of swaps.
> On the other hand, funds claiming in S6 is also ordered in time, so
> someone paying attention to the mempool could guess as well the order of
> swaps.
>
>
> Regards,
> ZmnSCPxj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200601/aee5c117/attachment.html>

From dp at simplexum.com  Mon Jun  1 11:38:54 2020
From: dp at simplexum.com (Dmitry Petukhov)
Date: Mon, 1 Jun 2020 16:38:54 +0500
Subject: [bitcoin-dev] TLA+ specification for Succint Atomic Swap
In-Reply-To: <20200513220222.24953c0a@simplexum.com>
References: <20200513220222.24953c0a@simplexum.com>
Message-ID: <20200601163854.17594845@simplexum.com>

I've finished specifying the full Succint Atomic Swap contract in TLA+.

I believe the specification [1] now covers all relevant behaviors of
the participants. It even has an option to enable 'non-rational'
behavior, so that it can be shown that the transactions that are there
to punish bad behavior can actually be used. If you examine the spec
and find that I failed to specify some relevant behavior, please tell.

The specification can be used to exhaustively check safety properties
of the model (such as no participant can take both coins, unless in
explicitly specified circumstances), and temporal properties (such as
contract always end up in an explicitly specified 'finished' state).

The specification can also be used to *show* (but not automatically
check at the moment) the hyperproperties of the model, such as what
transactions can ever be confirmed in at least one the execution path,
max/min/avg values for various stats, etc. The information on these
hyperproperties can be printed out during model checking, and can be
examined manually or with help of additional scripts (if one willing to
write some).

The model has some limitations, like only having one miner, and not
modelling fees and mempool priorities. More than one miner needed to
introduce reorgs in the model, but I believe that reorgs are relevant
only if we cannot say that "one block in the model means 6 bitcoin
blocks" (or whatever reorg safety limit is acceptable). I also believe
that the fees and mempool priorities are a lower-level concern, because
the task to confirm the transaction in time is the same for different
stages of the contract and for different transactions, and therefore
this can be modelled separately.

The goal of creating this specification was to evaluate the suitability
of TLA+ for modelling of the smart contracts in UTXO-based
blockchain systems. I believe that the presented spec shows that it is
indeed feasible to do such modelling and TLA+ is a suitable tool for
specifying and for checking such specifications (Although having ability
to automatically check hyperproperties using TLA+ expressions would be
nice).

I hope that this spec can be used as a basis for specs for other
contracts, and that using TLA+ can make designing safe contracts for
UTXO-based systems easier. I also hope that this will help to increase
interest in using formal methods in this area.

I tried to make the parts of the spec that deal with things like mining
and mempool to not depend on the concrete contract logic, in
expectation that this logic can be reused afterwards for the specs of
other contracts. I did not make specific effort to factor out this
generic logic into separate module though, because I think that more
various contract specifications need to be designed and analyzed to
understand what is really generic and what should lay with concrete
contract logic. When more knowledge is created regarding this, there
could be a module that contract specifications can use to avoid
explicitly specifying the generic blockchain-related logic.

Thanks to Ruben Somsen for designing this contract and
providing helpful description and diagram that made it possible to
create this formal specification.

[1] https://github.com/dgpv/SASwap_TLAplus_spec

From belcher at riseup.net  Tue Jun  2 22:24:19 2020
From: belcher at riseup.net (Chris Belcher)
Date: Tue, 2 Jun 2020 23:24:19 +0100
Subject: [bitcoin-dev] Design for a CoinSwap implementation for
 massively improving Bitcoin privacy and fungibility
In-Reply-To: <VxL93WE7bDrK1riquTWTTEgJj9mDQ4W5CuhOgdnnDPeidw2ho6evVh4cLZLz0jEYMqejaD1tiLULVTXkNRbI5A7wSwV49qSwnXcTWCDJ96E=@protonmail.com>
References: <82d90d57-ad07-fc7d-4aca-2b227ac2068d@riseup.net>
 <CAPv7TjY9h8n-nK_CPiYCWYDcbXpT1gfRMQDgf9VUkcR532rxOw@mail.gmail.com>
 <VxL93WE7bDrK1riquTWTTEgJj9mDQ4W5CuhOgdnnDPeidw2ho6evVh4cLZLz0jEYMqejaD1tiLULVTXkNRbI5A7wSwV49qSwnXcTWCDJ96E=@protonmail.com>
Message-ID: <cbf78f63-cf8c-c5d8-06ea-afc79aabc23c@riseup.net>

Hello ZmnSCPxj,

On 31/05/2020 03:30, ZmnSCPxj via bitcoin-dev wrote:
> Good morning Ruben and Chris,

> I am not in fact convinced that PayJoin-with-CoinSwap adds *that* much privacy.
> 
> These transactions:
> 
>              +---+  +---+
>     Alice ---|   |--|   |--- Bob
>     Alice ---|   |  |   |
>       Bob ---|   |  +---+
>              +---+
> 
> Are not really much different in coin ownership analysis from these:
> 
>              +---+    +---+
>     Alice ---|   |----|   |--- Bob
>     Alice ---|   | +--|   |
>              +---+ |  +---+
>       Bob ---------+

The main benefit of PayJoin-with-CoinSwap is it breaks the
common-input-ownership heuristic, which is a major widely used
heuristic. It would be a big win if that heuristic could be broken.

PayJoin-with-CoinSwap would be useful if Alice is trying to recover some
privacy which was previously degraded, for example if she is spending
from a reused address or from an address linked to her identity. If she
does a PayJoin with the reused address then some other economic entity
would have his activity linked with Alice's.

Just the fact that PayJoin-with-CoinSwap exists would improve privacy
for people who don't use it, for example if someone buys bitcoin from an
exchange that knows their identity and then co-spends it with other
coins they obtained another way. The fact that PayJoin exists means an
adversary cannot assume for sure that this user really owns that other
address which was co-spent. This doesn't apply for regular CoinSwap,
which only ever breaks the transaction graph heuristic, so in our
example the destination the coins are sent *to* would be uncertain, but
that the co-spent inputs are owned by the same person would be certain
in a world where PayJoin didn't exist.

> It also removes the need for Bob to reveal additional UTXOs to Alice during the swap protocol; yes PoDLE mitigates the privacy probing attack that Alice can mount on Bob, but it is helpful to remember this is "only" a mitigation.

Opening up the possibility of spying for free is a real downside for
PayJoin-with-CoinSwap. Using decoy UTXOs as described in my design
document, rather than PoDLE, seems like a better way of resisting these
attacks. This is because at the cost of a little bit more bandwidth and
CPU its possible to make the probability of an attacker successfully
guessing the maker's real UTXOs to be as low as you want.

> But S6 has the mild advantage that all the funding transactions paying to 2-of-2s *can* appear on the same block, whereas chaining swaps will have a particular order of when the transactions appear onchain, which might be used to derive the order of swaps.
On the other hand, funds claiming in S6 is also ordered in time, so
someone paying attention to the mempool could guess as well the order of
swaps.

I think this is wrong, and that it's possible for the funding
transactions of chained/routed swaps to all be in the same block as well.

In CoinSwap it's possible to get DOS'd without the other side spending
money if you broadcast your funding transaction first and the other side
simply disappears. You'd get your money back but you have to waste time
and spend miner fees. The other side didn't spend money to do this, not
even miner fees.

>From the point of view of us as a maker in the route, we know we won't
get DOS'd like this for free if we only broadcast our funding
transaction once we've seen the other side's funding transaction being
broadcast first. This should work as long as the two transactions have a
similar fee rate. There might be an attack involving hash power: If the
other side has a small amount of hash power and mines only their funding
transaction in a manner similar to a finney attack, then our funding
transaction should get mined very soon afterwards by another miner and
the protocol will continue as normal. If the other side has knowledge of
the preimage and uses it to do CPFP and take the money, then we can
learn that preimage and do our own CPFP to get our money back too.

So in a routed coinswap setup it should be possible for Alice the taker
to broadcast her funding transaction first, which will lead to all the
makers broadcasting their funding transactions as well once they see the
other side has broadcast first. Then it would be possible for all those
funding transactions to be confirmed in the same block.

I hope I haven't missed anything, because if this doesn't work and each
maker must wait for confirmations, then the UX of routed CoinSwap would
degrade: a CoinSwap route of 5 makers would require at least 5 blocks to
be mined.

Of course this setup can leak the ordering of the routes because the
funding transaction would appear in the mempool in that order, but this
could be beaten if some Alices choose to intentionally spread out the
funding transaction broadcasts among multiple blocks for privacy reasons.

An interesting tangent could be to see if it's possible to make private
key handover work with S6. A nice side-effect of private key handover is
that the transfer of possession of the coins happens off-chain, so then
paying attention to the mempool won't help an adversary much.


Regards,
Chris Belcher

From ZmnSCPxj at protonmail.com  Wed Jun  3 04:53:52 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 03 Jun 2020 04:53:52 +0000
Subject: [bitcoin-dev] Design for a CoinSwap implementation for
	massively improving Bitcoin privacy and fungibility
In-Reply-To: <cbf78f63-cf8c-c5d8-06ea-afc79aabc23c@riseup.net>
References: <82d90d57-ad07-fc7d-4aca-2b227ac2068d@riseup.net>
 <CAPv7TjY9h8n-nK_CPiYCWYDcbXpT1gfRMQDgf9VUkcR532rxOw@mail.gmail.com>
 <VxL93WE7bDrK1riquTWTTEgJj9mDQ4W5CuhOgdnnDPeidw2ho6evVh4cLZLz0jEYMqejaD1tiLULVTXkNRbI5A7wSwV49qSwnXcTWCDJ96E=@protonmail.com>
 <cbf78f63-cf8c-c5d8-06ea-afc79aabc23c@riseup.net>
Message-ID: <5LiZqpFxklAAbGFiiAE3ijRbIteODXKcHrXvGJ-qabgQj5hG8beFtHNbVZ-XUxETVwduJYz94UYuJGAPxBrbGeZpSClUtXYsPJBABfr03KM=@protonmail.com>

Good morning Chris,

> > Good morning Ruben and Chris,
>
> > I am not in fact convinced that PayJoin-with-CoinSwap adds that much privacy.
> > These transactions:
> >
> >              +---+  +---+
> >     Alice ---|   |--|   |--- Bob
> >     Alice ---|   |  |   |
> >       Bob ---|   |  +---+
> >              +---+
> >
> >
> > Are not really much different in coin ownership analysis from these:
> >
> >              +---+    +---+
> >     Alice ---|   |----|   |--- Bob
> >     Alice ---|   | +--|   |
> >              +---+ |  +---+
> >       Bob ---------+
> >
>
> The main benefit of PayJoin-with-CoinSwap is it breaks the
> common-input-ownership heuristic, which is a major widely used
> heuristic. It would be a big win if that heuristic could be broken.
>
> PayJoin-with-CoinSwap would be useful if Alice is trying to recover some
> privacy which was previously degraded, for example if she is spending
> from a reused address or from an address linked to her identity. If she
> does a PayJoin with the reused address then some other economic entity
> would have his activity linked with Alice's.
>
> Just the fact that PayJoin-with-CoinSwap exists would improve privacy
> for people who don't use it, for example if someone buys bitcoin from an
> exchange that knows their identity and then co-spends it with other
> coins they obtained another way. The fact that PayJoin exists means an
> adversary cannot assume for sure that this user really owns that other
> address which was co-spent. This doesn't apply for regular CoinSwap,
> which only ever breaks the transaction graph heuristic, so in our
> example the destination the coins are sent to would be uncertain, but
> that the co-spent inputs are owned by the same person would be certain
> in a world where PayJoin didn't exist.

Alice can do PayJoin with a payee Carol that supports normal PayJoin, for similar overall results.

Though I suppose there is a mild advantage still with supporting it on the funding tx of the first transaction, as you noted.

> > But S6 has the mild advantage that all the funding transactions paying to 2-of-2s can appear on the same block, whereas chaining swaps will have a particular order of when the transactions appear onchain, which might be used to derive the order of swaps.
>
> On the other hand, funds claiming in S6 is also ordered in time, so
> someone paying attention to the mempool could guess as well the order of
> swaps.
>
> I think this is wrong, and that it's possible for the funding
> transactions of chained/routed swaps to all be in the same block as well.
>
> In CoinSwap it's possible to get DOS'd without the other side spending
> money if you broadcast your funding transaction first and the other side
> simply disappears. You'd get your money back but you have to waste time
> and spend miner fees. The other side didn't spend money to do this, not
> even miner fees.
>
> From the point of view of us as a maker in the route, we know we won't
> get DOS'd like this for free if we only broadcast our funding
> transaction once we've seen the other side's funding transaction being
> broadcast first. This should work as long as the two transactions have a
> similar fee rate. There might be an attack involving hash power: If the
> other side has a small amount of hash power and mines only their funding
> transaction in a manner similar to a finney attack, then our funding
> transaction should get mined very soon afterwards by another miner and
> the protocol will continue as normal. If the other side has knowledge of
> the preimage and uses it to do CPFP and take the money, then we can
> learn that preimage and do our own CPFP to get our money back too.

How about RBF?

A taker Alice can broadcast the funding tx spending its own funds.
The funding tx spends funds controlled unilaterally by Alice.
Alice can sign a replacement transaction for those funds, spending them to an address with unilateral control, and making the funding tx output with all the obligations attached never get confirmed in the first place.

The chances may be small --- Bob can certainly monitor for Alice broadcasting a replacement and counter-broadcast its own replacement --- but the risk still exists.
TANSTAAGM (There Aint No Such Thing As A Global Mempool) also means Alice could arrange the replacement by other means, such as not using the RBF-enabled flag, broadcasting the self-paying replacement near miner nodes, and broadcasting the CoinSwap-expected funding tx near the Bob fullnode; Bob fullnode will then reject attempts to replace it, but miners will also reject the CoinSwap-expected funding tx and it will not confirm anyway.


With the pre-SAS 4-tx setup, this potentially allows Alice to steal the funds of Bob; after Alice gets its funding-tx-replacement confirmed together with the Bob honest-funding-tx, Alice can use the contract transaction and publish the preimage to take the Bob funds.
Since the Alice-side funding tx has been replaced, knowledge of the hash preimage will not help Bob any: the Alice funding tx has been replaced and Bob cannot use the preimage to claim it (it does not exist).


With SAS Alice cannot outright steal the Bob funds, but the Bob funds will now be locked in a 2-of-2 and Alice can take it hostage (either Bob gives up on the funds, i.e. donates its value to all HODLers, or Bob gives most of the value to Alice).


For the avoidance of theft, it is probably better for Bob to wait for Alice-side funding tx to confirm, probably deeply because reorgs suck.

This at least makes it costly to perform this attack; you have to lock more of your funds longer in order to induce a competitor to lock its funds.


Come to think of it, the same issue probably holds for S6 as well, the funding tx with the longest timelock has to confirm first before the next is even broadcast, bleah.


> An interesting tangent could be to see if it's possible to make private
> key handover work with S6. A nice side-effect of private key handover is
> that the transfer of possession of the coins happens off-chain, so then
> paying attention to the mempool won't help an adversary much.

It certainly seems quite possible; each participant in S6 has a fixed "previous" and "next" participant.

Of course, this requires a secure tunnel, and my understanding of your plan for SwapMarket is that the taker Alice serves as the broadcast medium between all makers and itself.
So, in an S6 sequence of Alice -> Bob1 -> Bob2 -> Alice, after Alice provides the preimage, Bob2 encrypts the private key being handed over in an asymmetric encryption that only Alice can open (e.g. using some known pubkey of Alice, there are many to choose from), Bob1 similarly encrypts its privkey for Bob2, and Alice encrypts the private key to Bob1, and Alice can then broadcast all those data to all participants, and only the correct participant will be able to decrypt it.

---

On another privacy-related note, S6 mildly leaks to each maker its position in the route, via the timelocks.
Each Bob has to know the timelocks it is offered and which it will offer to the next participant, and the timelocks will be larger the further away that Bob is from the Alice taker.
This is a mild privacy leak, one that seems unremovable to me.
(It also exists in Lightning Network as well: we suggest the use of "shadow routes" to artificially increase the distance of forwarding nodes, as a mitigation.)

Regards,
ZmnSCPxj


From dp at simplexum.com  Wed Jun  3 09:04:25 2020
From: dp at simplexum.com (Dmitry Petukhov)
Date: Wed, 3 Jun 2020 14:04:25 +0500
Subject: [bitcoin-dev] SAS: Succinct Atomic Swap
In-Reply-To: <OyxLj_9i4yfbKGK-W0GXc2V9bQA3RJBPGHmPUz3OtwG6ZMCpRwgXtuFl9E_aDi4M_VP3cNIVoqj3mIjTJ_2rRdGuWyoJcNNCKs2G6znGhck=@protonmail.com>
References: <CAPv7TjZGBbf6f1y49HLFD2eNiP5d4e+=dFGqiMFs6jaeYyH-NQ@mail.gmail.com>
 <vtu_ujJwxJDSC3w4QI5VlQ8WfkxaRg1Jk4nSNybgeYSWgGrN7sJiKa9dNzb0tDbRBdVhT4p60v-j6C2F8LmFxMLUTi_VtCznWRb56GVlvu8=@protonmail.com>
 <CAPv7TjYePyEt2YMg3J_KinK6Lv6SSLAF2nrOj79_oVt8qBXN0w@mail.gmail.com>
 <OyxLj_9i4yfbKGK-W0GXc2V9bQA3RJBPGHmPUz3OtwG6ZMCpRwgXtuFl9E_aDi4M_VP3cNIVoqj3mIjTJ_2rRdGuWyoJcNNCKs2G6znGhck=@protonmail.com>
Message-ID: <20200603140425.2a4e9d60@simplexum.com>

I made a version of the TLA+ spec according to the suggested variant,
as I understood it from your description. This version is in
the separate branch in the SASwap repo, 'variant_ZmnSCPxj' [1]

If I understood and specified your variant correctly, there is a
deadlock possible after step 9, if Bob fails to publish success tx in
time. After refund tx becomes spendable, Alice cannot publish it via
mempool, because Bob can learn her secret and has a chance invalidate
her refund tx by giving his success tx to friendly miner, while taking
back the locked LTC because both secrets are known. At the same time,
Bob cannot publish success tx via mempool, because then Alice can do
the same thing, invalidating his success tx with refund tx via friednly
miner.

There is a possibility that this deadlock can be resolved if one
participant indeed has possibility to confirm their tx directly,
bypassing the mempool, so the counterparty won't learn the secret until
transaction is in the block. But then this just raises the cost of the
attack because the counterparty will need to invalidate (orphan) the
whole block instead of just a transaction in the mempool, after
learning the other secret from the recent block.

[1] https://github.com/dgpv/SASwap_TLAplus_spec/tree/variant_ZmnSCPxj

? Tue, 12 May 2020 04:41:43 +0000
ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Good morning Ruben,
> 
> > Hi ZmnSCPxj,
> >
> > Thanks for your feedback :)
> >  
> > > CoinSwap for privacy is practically a "cross" chain atomic swap
> > > with the same chain and token for both sides of the swap  
> >
> > I agree, I didn't mean to imply that was new, only that this
> > protocol makes it more efficient.
> >  
> 
> Indeed; basically, any innovations in cross-chain swaps can be
> adapted to a CoinSwap (though not necessarily vice-versa, if a
> CoinSwap innovation requires certain specific blockchain features).
> 
> > > "Instead, Bob simply hands secretBob to Alice" is basically the
> > > same as private key turnover  
> >
> > Thanks for the link. I will add it to the links at the bottom of the
> > write-up, as I agree it's related. Do note there are a few key
> > differences:
> >
> > -   The swap is set up in an "asymmetric" way with only timelocks
> > on one side, so on the other side the swap never expires
> >  
> 
> An interesting setup.
> 
> So I was wondering why something like this would not work instead:
> 
> 0.  Alice has BTC, Bob has LTC, they agree on exchange rates and two
> future timelock L1 and L2 such that L1 < L2. 1.  Alice creates
> keypairs Alice[0] Alice[1] Alice[2], Bob creates Bob[0] Bob[1]
> Bob[2], and share the pubkeys. 2.  Alice creates, but does not sign,
> a funding tx on BTC whose output requires Alice[0] && Bob[0]. 3.  Bob
> creates a backout transaction spending the BTC funding txo, with an
> absolute timelock L1, whose output goes to Alice[2], then provides to
> Alice a signature for Bob[0] and requires an adaptor such that
> completing the signature with Alice[0] reveals Alice[1].
> 
>                          nLockTime L1
>     BTC funding txo ---> Alice[0] && Bob[0]    --->  Alice[2]
>                              reveals Alice[1]
> 
> 4.  Alice creates a timeout transaction spending the BTC funding txo,
> with an absolute timelock L2, whose output goes to Bob[2], then
> provides to Bob a signature for Alice[0] and requires an adaptor such
> that completing the signature with Bob[0] reveals Bob[1].
> 
>                          nLockTime L2
>     BTC funding txo ---> Alice[0] && Bob[0]    --->  Bob[2]
>                              reveals Bob[1]
> 
> 5.  Alice signs the BTC funding tx and broadcasts it.
> 6.  Alice and Bob wait for the BTC funding tx to be confirmed.
> 7.  Bob creates an LTC funding tx whose output requires Alice[1] &&
> Bob[1]. 8.  Alice and Bob wait for the LTC funding tx to be confirmed.
> 9.  Alice creates a success transaction spending the BTC funding txo,
> with no practical absolute timelock (current blockheight + 1), whose
> output goes to Bob[2], then provides to Bob a signature for Alice[0]
> and requires an adaptor such that completing the signature with
> Bob[0] reveals Bob[1].
> 
>                          nLockTime now
>     BTC funding txo ---> Alice[0] && Bob[0]    --->  Bob[2]
>                              reveals Bob[1]
> 
> 10.  Bob gives the secret key of Bob[1] to Alice.
> 11.  Alice gives the secret key of Alice[0] to Bob.
> 12.  Bob claims the BTC funding txo before L1.
> 
> Aborts and stalls:
> 
> * Aborts before step 5 are safe: no money is ever committed yet.
>   Stalls before step 5 can be promoted to aborts.
> * If aborted between step 5 and step 8, Alice reclaims her BTC via
> the backout transaction. Since Bob did not confirm any locked funds
> in LTC, revealing Alice[1] does not give Bob any extra funds it did
> not already have. If Bob stalls before step 8 Alice can abort at L1
> using the backout transaction.
> * If Alice stalls at step 9, Bob can force the completion using the
> timeout transaction at L2, revealing Bob[1] and claiming the BTC.
> * If Alice instead aborts at step 9 using the backout transaction at
> L1, Bob learns Alice[1] and can reclaim its LTC.
> * Steps 10 and 11 are optional and "only" give Alice and Bob extra
> flexibility in what they can do with the funds (such as sweeping
> multiple swaps, RBFing, performing another swap, etc.), i.e. private
> key turnover. Bob can always claim the BTC funding txo before L1 by
> signing and broadcasting the success transaction.
> 
> Would this not work?
> It requires that at least one chain involved supports witness
> segregation, in order to allow signing a dependent transaction before
> signing what it spends.
> 
> This has the advantage of using only absolute timelocks, which are
> better for privacy since ordinary wallets like Bitcoin Core and
> C-Lightning use absolute timelocks for ordinary spends onchain.
> 
> 
> >
> > Unfortunately this does not hold for the revoke transaction. It
> > would be a bit awkward if Alice had a high fee copy after the
> > protocol completes. She could send it to the blockchain and
> > essentially Bob would be paying for it. I'm not as concerned about
> > the other transactions, because those could all be bumped with CPFP
> > if needed, but having different feerates would be nice.
> >
> > And a general comment about privacy: it seems inevitable that some
> > information will be leaked if the protocol does not complete
> > cooperatively. As long as the cooperative case is not traceable,
> > that seems about as good as it can get. That's my view, at least.
> > I'd be curious to hear if you see that differently.  
> 
> 
> If the above counterproposal would work, it seems to me that all
> abort and stall scenarios "just" involve an absolute-timelock
> `SIGHASH_ALL` signed transaction, so it might not be so inevitable.
> 
> In addition, the above counterproposal has the transaction signatures
> be completed by whoever ends up getting the money, so will rationally
> use the version with the best feerate.
> 
> While leaking information in case of uncooperative abort is
> acceptable, it still seems to me that in this case, we can have a
> solution where an uncooperative abort has no information leak. My
> thesis is that, if relative locktimes are used as often as absolute
> locktimes for block-sniping-prevention and a decent Scriptless Script
> system, then all protocol aborts should be doable with no information
> leaks, at the cost of pre-signing a bunch of timelocked transactions.
> 
> ---
> 
> A sidenote as well, that if Alice typically uses an HD wallet, the
> UTXO on the LTC side would not be in that HD, and if Alice wants to
> cold-store the LTC, it should move the money as well into an HD
> pubkey.
> 
> Regards,
> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From laanwj at gmail.com  Wed Jun  3 10:48:54 2020
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Wed, 3 Jun 2020 12:48:54 +0200
Subject: [bitcoin-dev] Bitcoin Core 0.20.0 released
Message-ID: <20200603104854.fpyhmzjrl4ya2s6z@aurora.visucore.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

0.20.0 Release Notes
====================

Bitcoin Core version 0.20.0 is now available from:

  <https://bitcoincore.org/bin/bitcoin-core-0.20.0/>

Or through BitTorrent:

    magnet:?xt=urn:btih:1845a0c66b6a728e183b9bd8c5d8c1611dddaaa3&dn=bitcoin-core-0.20.0&tr=https%3A%2F%2Fopenbittorrent.com%2F&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337%2Fannounce&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969%2Fannounce&tr=udp%3A%2F%2Fexplodie.org%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.torrent.eu.org%3A451%2Fannounce&tr=udp%3A%2F%2Ftracker.bitcoin.sprovoost.nl%3A6969

This release includes new features, various bug fixes and performance
improvements, as well as updated translations.

Please report bugs using the issue tracker at GitHub:

  <https://github.com/bitcoin/bitcoin/issues>

To receive security and update notifications, please subscribe to:

  <https://bitcoincore.org/en/list/announcements/join/>

How to Upgrade
==============

If you are running an older version, shut it down. Wait until it has completely
shut down (which might take a few minutes in some cases), then run the
installer (on Windows) or just copy over `/Applications/Bitcoin-Qt` (on Mac)
or `bitcoind`/`bitcoin-qt` (on Linux).

Upgrading directly from a version of Bitcoin Core that has reached its EOL is
possible, but it might take some time if the data directory needs to be migrated. Old
wallet versions of Bitcoin Core are generally supported.

Compatibility
==============

Bitcoin Core is supported and extensively tested on operating systems
using the Linux kernel, macOS 10.12+, and Windows 7 and newer.  Bitcoin
Core should also work on most other Unix-like systems but is not as
frequently tested on them.  It is not recommended to use Bitcoin Core on
unsupported systems.

- From Bitcoin Core 0.20.0 onwards, macOS versions earlier than 10.12 are no
longer supported. Additionally, Bitcoin Core does not yet change appearance
when macOS "dark mode" is activated.

Known Bugs
==========

The process for generating the source code release ("tarball") has changed in an
effort to make it more complete, however, there are a few regressions in
this release:

- - The generated `configure` script is currently missing, and you will need to
  install autotools and run `./autogen.sh` before you can run
  `./configure`. This is the same as when checking out from git.

- - Instead of running `make` simply, you should instead run
  `BITCOIN_GENBUILD_NO_GIT=1 make`.

Notable changes
===============

P2P and network changes
- -----------------------

#### Removal of BIP61 reject network messages from Bitcoin Core

The `-enablebip61` command line option to enable BIP61 has been removed.
(#17004)

This feature has been disabled by default since Bitcoin Core version 0.18.0.
Nodes on the network can not generally be trusted to send valid messages
(including reject messages), so this should only ever be used when
connected to a trusted node.  Please use the alternatives recommended
below if you rely on this removed feature:

- - Testing or debugging of implementations of the Bitcoin P2P network protocol
  should be done by inspecting the log messages that are produced by a recent
  version of Bitcoin Core. Bitcoin Core logs debug messages
  (`-debug=<category>`) to a stream (`-printtoconsole`) or to a file
  (`-debuglogfile=<debug.log>`).

- - Testing the validity of a block can be achieved by specific RPCs:

  - `submitblock`

  - `getblocktemplate` with `'mode'` set to `'proposal'` for blocks with
    potentially invalid POW

- - Testing the validity of a transaction can be achieved by specific RPCs:

  - `sendrawtransaction`

  - `testmempoolaccept`

- - Wallets should not assume a transaction has propagated to the network
  just because there are no reject messages.  Instead, listen for the
  transaction to be announced by other peers on the network.  Wallets
  should not assume a lack of reject messages means a transaction pays
  an appropriate fee.  Instead, set fees using fee estimation and use
  replace-by-fee to increase a transaction's fee if it hasn't confirmed
  within the desired amount of time.

The removal of BIP61 reject message support also has the following minor RPC
and logging implications:

- - `testmempoolaccept` and `sendrawtransaction` no longer return the P2P reject
  code when a transaction is not accepted to the mempool. They still return the
  verbal reject reason.

- - Log messages that previously reported the reject code when a transaction was
  not accepted to the mempool now no longer report the reject code. The reason
  for rejection is still reported.

Updated RPCs
- ------------

- - The RPCs which accept descriptors now accept the new `sortedmulti(...)` descriptor
  type which supports multisig scripts where the public keys are sorted
  lexicographically in the resulting script.  (#17056)

- - The `walletprocesspsbt` and `walletcreatefundedpsbt` RPCs now include
  BIP32 derivation paths by default for public keys if we know them.
  This can be disabled by setting the `bip32derivs` parameter to
  `false`.  (#17264)

- - The `bumpfee` RPC's parameter `totalFee`, which was deprecated in
  0.19, has been removed.  (#18312)

- - The `bumpfee` RPC will return a PSBT when used with wallets that have
  private keys disabled.  (#16373)

- - The `getpeerinfo` RPC now includes a `mapped_as` field to indicate the
  mapped Autonomous System used for diversifying peer selection. See the
  `-asmap` configuration option described below in _New Settings_.  (#16702)

- - The `createmultisig` and `addmultisigaddress` RPCs now return an
  output script descriptor for the newly created address.  (#18032)

Build System
- ------------

- - OpenSSL is no longer used by Bitcoin Core.  (#17265)

- - BIP70 support has been fully removed from Bitcoin Core. The
  `--enable-bip70` option remains, but it will throw an error during configure.
  (#17165)

- - glibc 2.17 or greater is now required to run the release binaries. This
  retains compatibility with RHEL 7, CentOS 7, Debian 8 and Ubuntu 14.04 LTS. (#17538)

- - The source code archives that are provided with gitian builds no longer contain
  any autotools artifacts. Therefore, to build from such source, a user
  should run the `./autogen.sh` script from the root of the unpacked archive.
  This implies that `autotools` and other required packages are installed on the
  user's system. (#18331)

New settings
- ------------

- - New `rpcwhitelist` and `rpcwhitelistdefault` configuration parameters
  allow giving certain RPC users permissions to only some RPC calls.
  (#12763)

- - A new `-asmap` configuration option has been added to diversify the
  node's network connections by mapping IP addresses Autonomous System
  Numbers (ASNs) and then limiting the number of connections made to any
  single ASN.  See [issue #16599](https://github.com/bitcoin/bitcoin/issues/16599),
  [PR #16702](https://github.com/bitcoin/bitcoin/pull/16702), and the
  `bitcoind help` for more information.  This option is experimental and
  subject to removal or breaking changes in future releases, so the
  legacy /16 prefix mapping of IP addresses remains the default.  (#16702)

Updated settings
- ----------------

- - All custom settings configured when Bitcoin Core starts are now
  written to the `debug.log` file to assist troubleshooting.  (#16115)

- - Importing blocks upon startup via the `bootstrap.dat` file no longer
  occurs by default. The file must now be specified with
  `-loadblock=<file>`.  (#17044)

- - The `-debug=db` logging category has been renamed to
  `-debug=walletdb` to distinguish it from `coindb`.  The `-debug=db`
  option has been deprecated and will be removed in the next major
  release.  (#17410)

- - The `-walletnotify` configuration parameter will now replace any `%w`
  in its argument with the name of the wallet generating the
  notification.  This is not supported on Windows. (#13339)

Removed settings
- ----------------

- - The `-whitelistforcerelay` configuration parameter has been removed after
  it was discovered that it was rendered ineffective in version 0.13 and
  hasn't actually been supported for almost four years.  (#17985)

GUI changes
- -----------

- - The "Start Bitcoin Core on system login" option has been removed on macOS.
  (#17567)

- - In the Peers window, the details for a peer now displays a `Mapped AS`
  field to indicate the mapped Autonomous System used for diversifying
  peer selection. See the `-asmap` configuration option in _New
  Settings_, above.  (#18402)

- - A "known bug" [announced](https://bitcoincore.org/en/releases/0.18.0/#wallet-gui)
  in the release notes of version 0.18 has been fixed.  The issue
  affected anyone who simultaneously used multiple Bitcoin Core wallets
  and the GUI coin control feature. (#18894)

- - For watch-only wallets, creating a new transaction in the Send screen
  or fee bumping an existing transaction in the Transactions screen will
  automatically copy a Partially-Signed Bitcoin Transaction (PSBT) to
  the system clipboard.  This can then be pasted into an external
  program such as [HWI](https://github.com/bitcoin-core/HWI) for
  signing.  Future versions of Bitcoin Core should support a GUI option
  for finalizing and broadcasting PSBTs, but for now the debug console
  may be used with the `finalizepsbt` and `sendrawtransaction` RPCs.
  (#16944, #17492)

Wallet
- ------

- - The wallet now by default uses bech32 addresses when using RPC, and
  creates native segwit change outputs.  (#16884)

- - The way that output trust was computed has been fixed, which affects
  confirmed/unconfirmed balance status and coin selection.  (#16766)

- - The `gettransaction`, `listtransactions` and `listsinceblock` RPC
  responses now also include the height of the block that contains the
  wallet transaction, if any.  (#17437)

- - The `getaddressinfo` RPC has had its `label` field deprecated
  (re-enable for this release using the configuration parameter
  `-deprecatedrpc=label`).  The `labels` field is altered from returning
  JSON objects to returning a JSON array of label names (re-enable
  previous behavior for this release using the configuration parameter
  `-deprecatedrpc=labelspurpose`).  Backwards compatibility using the
  deprecated configuration parameters is expected to be dropped in the
  0.21 release.  (#17585, #17578)

Documentation changes
- ---------------------

- - Bitcoin Core's automatically-generated source code documentation is
  now available at https://doxygen.bitcoincore.org.  (#17596)

Low-level changes
=================

Utilities
- ---------

- - The `bitcoin-cli` utility used with the `-getinfo` parameter now
  returns a `headers` field with the number of downloaded block headers
  on the best headers chain (similar to the `blocks` field that is also
  returned) and a `verificationprogress` field that estimates how much
  of the best block chain has been synced by the local node.  The
  information returned no longer includes the `protocolversion`,
  `walletversion`, and `keypoololdest` fields.  (#17302, #17650)

- - The `bitcoin-cli` utility now accepts a `-stdinwalletpassphrase`
  parameter that can be used when calling the `walletpassphrase` and
  `walletpassphrasechange` RPCs to read the passphrase from standard
  input without echoing it to the terminal, improving security against
  anyone who can look at your screen.  The existing `-stdinrpcpass`
  parameter is also updated to not echo the passphrase. (#13716)

Command line
- ------------

- - Command line options prefixed with main/test/regtest network names like
  `-main.port=8333` `-test.server=1` previously were allowed but ignored. Now
  they trigger "Invalid parameter" errors on startup. (#17482)

New RPCs
- --------

- - The `dumptxoutset` RPC outputs a serialized snapshot of the current
  UTXO set.  A script is provided in the `contrib/devtools` directory
  for generating a snapshot of the UTXO set at a particular block
  height.  (#16899)

- - The `generatetodescriptor` RPC allows testers using regtest mode to
  generate blocks that pay an arbitrary output script descriptor.
  (#16943)

Updated RPCs
- ------------

- - The `verifychain` RPC default values are now static instead of
  depending on the command line options or configuration file
  (`-checklevel`, and `-checkblocks`). Users can pass in the RPC
  arguments explicitly when they don't want to rely on the default
  values. (#18541)

- - The `getblockchaininfo` RPC's `verificationprogress` field will no
  longer report values higher than 1.  Previously it would occasionally
  report the chain was more than 100% verified.  (#17328)

Tests
- -----

- - It is now an error to use an unqualified `walletdir=path` setting in
  the config file if running on testnet or regtest networks. The setting
  now needs to be qualified as `chain.walletdir=path` or placed in the
  appropriate `[chain]` section. (#17447)

- - `-fallbackfee` was 0 (disabled) by default for the main chain, but
  0.0002 by default for the test chains. Now it is 0 by default for all
  chains. Testnet and regtest users will have to add
  `fallbackfee=0.0002` to their configuration if they weren't setting it
  and they want it to keep working like before. (#16524)

Build system
- ------------

- - Support is provided for building with the Android Native Development
  Kit (NDK).  (#16110)

0.20.0 change log
=================

### Mining
- - #18742 miner: Avoid stack-use-after-return in validationinterface (MarcoFalke)

### Block and transaction handling
- - #15283 log: Fix UB with bench on genesis block (instagibbs)
- - #16507 feefilter: Compute the absolute fee rather than stored rate (instagibbs)
- - #16688 log: Add validation interface logging (jkczyz)
- - #16805 log: Add timing information to FlushStateToDisk() (jamesob)
- - #16902 O(1) `OP_IF/NOTIF/ELSE/ENDIF` script implementation (sipa)
- - #16945 introduce CChainState::GetCoinsCacheSizeState (jamesob)
- - #16974 Walk pindexBestHeader back to ChainActive().Tip() if it is invalid (TheBlueMatt)
- - #17004 Remove REJECT code from CValidationState (jnewbery)
- - #17080 Explain why `fCheckDuplicateInputs` can not be skipped and remove it (MarcoFalke)
- - #17328 GuessVerificationProgress: cap the ratio to 1 (darosior)
- - #17399 Templatize ValidationState instead of subclassing (jkczyz)
- - #17407 node: Add reference to mempool in NodeContext (MarcoFalke)
- - #17708 prevector: Avoid misaligned member accesses (ajtowns)
- - #17850,#17896,#17957,#18021,#18021,#18112 Serialization improvements (sipa)
- - #17925 Improve UpdateTransactionsFromBlock with Epochs (JeremyRubin)
- - #18002 Abstract out script execution out of `VerifyWitnessProgram()` (sipa)
- - #18388 Make VerifyWitnessProgram use a Span stack (sipa)
- - #18433 serialization: prevent int overflow for big Coin::nHeight (pierreN)
- - #18500 chainparams: Bump assumed valid hash (MarcoFalke)
- - #18551 Do not clear validationinterface entries being executed (sipa)

### P2P protocol and network code
- - #15437 Remove BIP61 reject messages (MarcoFalke)
- - #16702 Supply and use asmap to improve IP bucketing in addrman (naumenkogs)
- - #16851 Continue relaying transactions after they expire from mapRelay (ajtowns)
- - #17164 Avoid allocating memory for addrKnown where we don't need it (naumenkogs)
- - #17243 tools: add PoissonNextSend method that returns mockable time (amitiuttarwar)
- - #17251 SocketHandler logs peer id for close and disconnect (Sjors)
- - #17573 Seed RNG with precision timestamps on receipt of net messages (TheBlueMatt)
- - #17624 Fix an uninitialized read in ProcessMessage(?, "tx", ?) when receiving a transaction we already have (practicalswift)
- - #17754 Don't allow resolving of std::string with embedded NUL characters. Add tests (practicalswift)
- - #17758 Fix CNetAddr::IsRFC2544 comment + tests (tynes)
- - #17812 config, net, test: Asmap feature refinements and functional tests (jonatack)
- - #17951 Use rolling bloom filter of recent block txs for AlreadyHave() check (sdaftuar)
- - #17985 Remove forcerelay of rejected txs (MarcoFalke)
- - #18023 Fix some asmap issues (sipa)
- - #18054 Reference instead of copy in BlockConnected range loop (jonatack)
- - #18376 Fix use-after-free in tests (vasild)
- - #18454 Make addr relay mockable, add test (MarcoFalke)
- - #18458 Add missing `cs_vNodes` lock (MarcoFalke)
- - #18506 Hardcoded seeds update for 0.20 (laanwj)
- - #18808 Drop unknown types in getdata (jnewbery)
- - #18962 Only send a getheaders for one block in an INV (jnewbery)

### Wallet
- - #13339 Replace %w by wallet name in -walletnotify script (promag)
- - #15931 Remove GetDepthInMainChain dependency on locked chain interface (ariard)
- - #16373 bumpfee: Return PSBT when wallet has privkeys disabled (instagibbs)
- - #16524 Disable -fallbackfee by default (jtimon)
- - #16766 Make IsTrusted scan parents recursively (JeremyRubin)
- - #16884 Change default address type to bech32 (instagibbs)
- - #16911 Only check the hash of transactions loaded from disk (achow101)
- - #16923 Handle duplicate fileid exception (promag)
- - #17056 descriptors: Introduce sortedmulti descriptor (achow101)
- - #17070 Avoid showing GUI popups on RPC errors (MarcoFalke)
- - #17138 Remove wallet access to some node arguments (jnewbery)
- - #17237 LearnRelatedScripts only if KeepDestination (promag)
- - #17260 Split some CWallet functions into new LegacyScriptPubKeyMan (achow101)
- - #17261 Make ScriptPubKeyMan an actual interface and the wallet to have multiple (achow101)
- - #17290 Enable BnB coin selection for preset inputs and subtract fee from outputs (achow101)
- - #17373 Various fixes and cleanup to keypool handling in LegacyScriptPubKeyMan and CWallet (achow101)
- - #17410 Rename `db` log category to `walletdb` (like `coindb`) (laanwj)
- - #17444 Avoid showing GUI popups on RPC errors (take 2) (MarcoFalke)
- - #17447 Make -walletdir network only (promag)
- - #17537 Cleanup and move opportunistic and superfluous TopUp()s (achow101)
- - #17553 Remove out of date comments for CalculateMaximumSignedTxSize (instagibbs)
- - #17568 Fix when sufficient preset inputs and subtractFeeFromOutputs (achow101)
- - #17677 Activate watchonly wallet behavior for LegacySPKM only (instagibbs)
- - #17719 Document better -keypool as a look-ahead safety mechanism (ariard)
- - #17843 Reset reused transactions cache (fjahr)
- - #17889 Improve CWallet:MarkDestinationsDirty (promag)
- - #18034 Get the OutputType for a descriptor (achow101)
- - #18067 Improve LegacyScriptPubKeyMan::CanProvide script recognition (ryanofsky)
- - #18115 Pass in transactions and messages for signing instead of exporting the private keys (achow101)
- - #18192,#18546 Bugfix: Wallet: Safely deal with change in the address book (luke-jr)
- - #18204 descriptors: Improve descriptor cache and cache xpubs (achow101)
- - #18274 rpc/wallet: Initialize nFeeRequired to avoid using garbage value on failure (kallewoof)
- - #18312 Remove deprecated fee bumping by totalFee (jonatack)
- - #18338 Fix wallet unload race condition (promag)

### RPC and other APIs
- - #12763 Add RPC Whitelist Feature from #12248 (JeremyRubin)
- - #13716 cli: `-stdinwalletpassphrase` and non-echo stdin passwords (kallewoof)
- - #16689 Add missing fields to wallet rpc help output (ariard)
- - #16821 Fix bug where duplicate PSBT keys are accepted (erasmospunk)
- - #16899 UTXO snapshot creation (dumptxoutset)
- - #17156 psbt: Check that various indexes and amounts are within bounds (achow101)
- - #17264 Set default bip32derivs to true for psbt methods (Sjors)
- - #17283 improve getaddressinfo test coverage, help, code docs (jonatack)
- - #17302 cli: Add "headers" and "verificationprogress" to -getinfo (laanwj)
- - #17318 replace asserts in RPC code with `CHECK_NONFATAL` and add linter (adamjonas)
- - #17437 Expose block height of wallet transactions (promag)
- - #17519 Remove unused `COINBASE_FLAGS` (narula)
- - #17578 Simplify getaddressinfo labels, deprecate previous behavior (jonatack)
- - #17585 deprecate getaddressinfo label (jonatack)
- - #17746 Remove vector copy from listtransactions (promag)
- - #17809 Auto-format RPCResult (MarcoFalke)
- - #18032 Output a descriptor in createmultisig and addmultisigaddress (achow101)
- - #18122 Update validateaddress RPCExamples to bech32 (theStack)
- - #18208 Change RPCExamples to bech32 (yusufsahinhamza)
- - #18268 Remove redundant types from descriptions (docallag)
- - #18346 Document an RPCResult for all calls; Enforce at compile time (MarcoFalke)
- - #18396 Add missing HelpExampleRpc for getblockfilter (theStack)
- - #18398 Fix broken RPCExamples for waitforblock(height) (theStack)
- - #18444 Remove final comma for last entry of fixed-size arrays/objects in RPCResult (luke-jr)
- - #18459 Remove unused getbalances() code (jonatack)
- - #18484 Correctly compute redeemScript from witnessScript for signrawtransaction (achow101)
- - #18487 Fix rpcRunLater race in walletpassphrase (promag)
- - #18499 Make rpc documentation not depend on call-time rpc args (MarcoFalke)
- - #18532 Avoid initialization-order-fiasco on static CRPCCommand tables (MarcoFalke)
- - #18541 Make verifychain default values static, not depend on global args (MarcoFalke)
- - #18809 Do not advertise dumptxoutset as a way to flush the chainstate (MarcoFalke)
- - #18814 Relock wallet only if most recent callback (promag)

### GUI
- - #15023 Restore RPC Console to non-wallet tray icon menu (luke-jr)
- - #15084 Don't disable the sync overlay when wallet is disabled (benthecarman)
- - #15098 Show addresses for "SendToSelf" transactions (hebasto)
- - #15756 Add shortcuts for tab tools (promag)
- - #16944 create PSBT with watch-only wallet (Sjors)
- - #16964 Change sendcoins dialogue Yes to Send (instagibbs)
- - #17068 Always generate `bitcoinstrings.cpp` on `make translate` (D4nte)
- - #17096 Rename debug window (Zero-1729)
- - #17105 Make RPCConsole::TabTypes an enum class (promag)
- - #17125 Add toolTip and placeholderText to sign message fields (dannmat)
- - #17165 Remove BIP70 support (fanquake)
- - #17180 Improved tooltip for send amount field (JeremyCrookshank)
- - #17186 Add placeholder text to the sign message field (Danny-Scott)
- - #17195 Send amount placeholder value (JeremyCrookshank)
- - #17226 Fix payAmount tooltip in SendCoinsEntry (promag)
- - #17360 Cleaning up hide button tool tip (Danny-Scott)
- - #17446 Changed tooltip for 'Label' & 'Message' text fields to be more clear (dannmat)
- - #17453 Fix intro dialog labels when the prune button is toggled (hebasto)
- - #17474 Bugfix: GUI: Recognise `NETWORK_LIMITED` in formatServicesStr (luke-jr)
- - #17492 Bump fee returns PSBT on clipboard for watchonly-only wallets (instagibbs)
- - #17567 Remove macOS start on login code (fanquake)
- - #17587 Show watch-only balance in send screen (Sjors)
- - #17694 Disable 3rd-party tx-urls when wallet disabled (brakmic)
- - #17696 Force set nPruneSize in QSettings after the intro dialog (hebasto)
- - #17702 Move static placeholder texts to forms (laanwj)
- - #17826 Log Qt related info (hebasto)
- - #17886 Restore English translation option (achow101)
- - #17906 Set CConnman byte counters earlier to avoid uninitialized reads (ryanofsky)
- - #17935 Hide HD & encryption icons when no wallet loaded (brakmic)
- - #17998 Shortcut to close ModalOverlay (emilengler)
- - #18007 Bugfix: GUI: Hide the HD/encrypt icons earlier so they get re-shown if another wallet is open (luke-jr)
- - #18060 Drop PeerTableModel dependency to ClientModel (promag)
- - #18062 Fix unintialized WalletView::progressDialog (promag)
- - #18091 Pass clientmodel changes from walletframe to walletviews (jonasschnelli)
- - #18101 Fix deprecated QCharRef usage (hebasto)
- - #18121 Throttle GUI update pace when -reindex (hebasto)
- - #18123 Fix race in WalletModel::pollBalanceChanged (ryanofsky)
- - #18160 Avoid Wallet::GetBalance in WalletModel::pollBalanceChanged (promag)
- - #18360 Bump transifex slug and update English translations for 0.20 (laanwj)
- - #18402 Display mapped AS in peers info window (jonatack)
- - #18492 Translations update pre-branch (laanwj)
- - #18549 Fix Window -> Minimize menu item (hebasto)
- - #18578 Fix leak in CoinControlDialog::updateView (promag)
- - #18894 Fix manual coin control with multiple wallets loaded (promag)

### Build system
- - #16667 Remove mingw linker workaround from win gitian descriptor (fanquake)
- - #16669 Use new fork of osslsigncode for windows gitian signing (fanquake)
- - #16949 Only pass --disable-dependency-tracking to packages that understand it (fanquake)
- - #17008 Bump libevent to 2.1.11 in depends (stefanwouldgo)
- - #17029 gitian: Various improvements for windows descriptor (dongcarl)
- - #17033 Disable _FORTIFY_SOURCE when enable-debug (achow101)
- - #17057 Switch to upstream libdmg-hfsplus (fanquake)
- - #17066 Remove workaround for ancient libtool (hebasto)
- - #17074 Added double quotes (mztriz)
- - #17087 Add variable printing target to Makefiles (dongcarl)
- - #17118 depends macOS: point --sysroot to SDK (Sjors)
- - #17231 Fix boost mac cross build with clang 9+ (theuni)
- - #17265 Remove OpenSSL (fanquake)
- - #17284 Update retry to current version (RandyMcMillan)
- - #17308 nsis: Write to correct filename in first place (dongcarl)
- - #17324,#18099 Update univalue subtree (MarcoFalke)
- - #17398 Update leveldb to 1.22+ (laanwj)
- - #17409 Avoid hardcoded libfaketime dir in gitian (MarcoFalke)
- - #17466 Fix C{,XX} pickup (dongcarl)
- - #17483 Set gitian arch back to amd64 (MarcoFalke)
- - #17486 Make Travis catch unused variables (Sjors)
- - #17538 Bump minimum libc to 2.17 for release binaries (fanquake)
- - #17542 Create test utility library from src/test/util/ (brakmic)
- - #17545 Remove libanl.so.1 from ALLOWED_LIBRARIES (fanquake)
- - #17547 Fix configure report about qr (hebasto)
- - #17569 Allow export of environ symbols and work around rv64 toolchain issue (laanwj)
- - #17647 lcov: filter depends from coverage reports (nijynot)
- - #17658 Add ability to skip building qrencode (fanquake)
- - #17678 Support for S390X and POWER targets (MarcoFalke)
- - #17682 util: Update tinyformat to upstream (laanwj)
- - #17698 Don't configure `xcb_proto` (fanquake)
- - #17730 Remove Qt networking features (fanquake)
- - #17738 Remove linking librt for backwards compatibility (fanquake)
- - #17740 Remove configure checks for win libraries we don't link against (fanquake)
- - #17741 Included `test_bitcoin-qt` in msvc build (sipsorcery)
- - #17756 Remove `WINDOWS_BITS` from build system (fanquake)
- - #17769 Set `AC_PREREQ` to 2.69 (fanquake)
- - #17880 Add -Wdate-time to Werror flags (fanquake)
- - #17910 Remove double `LIBBITCOIN_SERVER` linking (fanquake)
- - #17928 Consistent use of package variable (Bushstar)
- - #17933 guix: Pin Guix using `guix time-machine` (dongcarl)
- - #17948 pass -fno-ident in Windows gitian descriptor (fanquake)
- - #18003 Remove --large-address-aware linker flag (fanquake)
- - #18004 Don't embed a build-id when building libdmg-hfsplus (fanquake)
- - #18051 Fix behavior when `ALLOW_HOST_PACKAGES` unset (hebasto)
- - #18059 Add missing attributes to Win installer (fanquake)
- - #18104 Skip i686 build by default in guix and gitian (MarcoFalke)
- - #18107 Add `cov_fuzz` target (MarcoFalke)
- - #18135 Add --enable-determinism configure flag (fanquake)
- - #18145 Add Wreturn-type to Werror flags, check on more Travis machines (Sjors)
- - #18264 Remove Boost Chrono (fanquake)
- - #18290 Set minimum Automake version to 1.13 (hebasto)
- - #18320 guix: Remove now-unnecessary gcc make flag (dongcarl)
- - #18331 Use git archive as source tarball (hebasto)
- - #18397 Fix libevent linking for `bench_bitcoin` binary (hebasto)
- - #18426 scripts: `Previous_release`: improve behaviour on failed download (theStack)
- - #18429 Remove double `LIBBITCOIN_SERVER` from bench-Makefile (brakmic)
- - #18528 Create `test_fuzz` library from src/test/fuzz/fuzz.cpp (brakmic)
- - #18558 Fix boost detection for arch armv7l (hebasto)
- - #18598 gitian: Add missing automake package to gitian-win-signer.yml (achow101)
- - #18676 Check libevent minimum version in configure script (hebasto)
- - #18945 Ensure source tarball has leading directory name (laanwj)

### Platform support
- - #16110 Add Android NDK support (icota)
- - #16392 macOS toolchain update (fanquake)
- - #16569 Increase init file stop timeout (setpill)
- - #17151 Remove OpenSSL PRNG seeding (Windows, Qt only) (fanquake)
- - #17365 Update README.md with working Android targets and API levels (icota)
- - #17521 Only use D-Bus with Qt on linux (fanquake)
- - #17550 Set minimum supported macOS to 10.12 (fanquake)
- - #17592 Appveyor install libevent[thread] vcpkg (sipsorcery)
- - #17660 Remove deprecated key from macOS Info.plist (fanquake)
- - #17663 Pass `-dead_strip_dylibs` to ld on macOS (fanquake)
- - #17676 Don't use OpenGL in Qt on macOS (fanquake)
- - #17686 Add `-bind_at_load` to macOS hardened LDFLAGS (fanquake)
- - #17787 scripts: Add macho pie check to security-check.py (fanquake)
- - #17800 random: don't special case clock usage on macOS (fanquake)
- - #17863 scripts: Add macho dylib checks to symbol-check.py (fanquake)
- - #17899 msvc: Ignore msvc linker warning and update to msvc build instructions (sipsorcery)
- - #17916 windows: Enable heap terminate-on-corruption (fanquake)
- - #18082 logging: Enable `thread_local` usage on macos (fanquake)
- - #18108 Fix `.gitignore` policy in `build_msvc` directory (hebasto)
- - #18295 scripts: Add macho lazy bindings check to security-check.py (fanquake)
- - #18358 util: Fix compilation with mingw-w64 7.0.0 (fanquake)
- - #18359 Fix sysctl() detection on macOS (fanquake)
- - #18364 random: remove getentropy() fallback for macOS < 10.12 (fanquake)
- - #18395 scripts: Add pe dylib checking to symbol-check.py (fanquake)
- - #18415 scripts: Add macho tests to test-security-check.py (fanquake)
- - #18425 releases: Update with new Windows code signing certificate (achow101)
- - #18702 Fix ASLR for bitcoin-cli on Windows (fanquake)

### Tests and QA
- - #12134 Build previous releases and run functional tests (Sjors)
- - #13693 Add coverage to estimaterawfee and estimatesmartfee (Empact)
- - #13728 lint: Run the ci lint stage on mac (Empact)
- - #15443 Add getdescriptorinfo functional test (promag)
- - #15888 Add `wallet_implicitsegwit` to test the ability to transform keys between address types (luke-jr)
- - #16540 Add `ASSERT_DEBUG_LOG` to unit test framework (MarcoFalke)
- - #16597 travis: Run full test suite on native macos (Sjors)
- - #16681 Use self.chain instead of 'regtest' in all current tests (jtimon)
- - #16786 add unit test for wallet watch-only methods involving PubKeys (theStack)
- - #16943 Add generatetodescriptor RPC (MarcoFalke)
- - #16973 Fix `combine_logs.py` for AppVeyor build (mzumsande)
- - #16975 Show debug log on unit test failure (MarcoFalke)
- - #16978 Seed test RNG context for each test case, print seed (MarcoFalke)
- - #17009, #17018, #17050, #17051, #17071, #17076, #17083, #17093, #17109, #17113, #17136, #17229, #17291, #17357, #17771, #17777, #17917, #17926, #17972, #17989, #17996, #18009, #18029, #18047, #18126, #18176, #18206, #18353, #18363, #18407, #18417, #18423, #18445, #18455, #18565 Add fuzzing harnesses (practicalswift)
- - #17011 ci: Use busybox utils for one build (MarcoFalke)
- - #17030 Fix Python Docstring to include all Args (jbampton)
- - #17041 ci: Run tests on arm (MarcoFalke)
- - #17069 Pass fuzzing inputs as constant references (practicalswift)
- - #17091 Add test for loadblock option and linearize scripts (fjahr)
- - #17108 fix "tx-size-small" errors after default address change (theStack)
- - #17121 Speed up `wallet_backup` by whitelisting peers (immediate tx relay) (theStack)
- - #17124 Speed up `wallet_address_types` by whitelisting peers (immediate tx relay) (theStack)
- - #17140 Fix bug in `blockfilter_index_tests` (jimpo)
- - #17199 use default address type (bech32) for `wallet_bumpfee` tests (theStack)
- - #17205 ci: Enable address sanitizer (asan) stack-use-after-return checking (practicalswift)
- - #17206 Add testcase to simulate bitcoin schema in leveldb (adamjonas)
- - #17209 Remove no longer needed UBSan suppressions (issues fixed). Add documentation (practicalswift)
- - #17220 Add unit testing for the CompressScript function (adamjonas)
- - #17225 Test serialisation as part of deserialisation fuzzing. Test round-trip equality where possible (practicalswift)
- - #17228 Add RegTestingSetup to `setup_common` (MarcoFalke)
- - #17233 travis: Run unit and functional tests on native arm (MarcoFalke)
- - #17235 Skip unnecessary fuzzer initialisation. Hold ECCVerifyHandle only when needed (practicalswift)
- - #17240 ci: Disable functional tests on mac host (MarcoFalke)
- - #17254 Fix `script_p2sh_tests` `OP_PUSHBACK2/4` missing (adamjonas)
- - #17267 bench: Fix negative values and zero for -evals flag (nijynot)
- - #17275 pubkey: Assert CPubKey's ECCVerifyHandle precondition (practicalswift)
- - #17288 Added TestWrapper class for interactive Python environments (jachiang)
- - #17292 Add new mempool benchmarks for a complex pool (JeremyRubin)
- - #17299 add reason checks for non-standard txs in `test_IsStandard` (theStack)
- - #17322 Fix input size assertion in `wallet_bumpfee.py` (instagibbs)
- - #17327 Add `rpc_fundrawtransaction` logging (jonatack)
- - #17330 Add `shrinkdebugfile=0` to regtest bitcoin.conf (sdaftuar)
- - #17340 Speed up fundrawtransaction test (jnewbery)
- - #17345 Do not instantiate CAddrDB for static call CAddrDB::Read() (hebasto)
- - #17362 Speed up `wallet_avoidreuse`, add logging (jonatack)
- - #17363 add "diamond" unit test to MempoolAncestryTests (theStack)
- - #17366 Reset global args between test suites (MarcoFalke)
- - #17367 ci: Run non-cross-compile builds natively (MarcoFalke)
- - #17378 TestShell: Fix typos & implement cleanups (jachiang)
- - #17384 Create new test library (MarcoFalke)
- - #17387 `wallet_importmulti`: use addresses of the same type as being imported (achow101)
- - #17388 Add missing newline in `util_ChainMerge` test (ryanofsky)
- - #17390 Add `util_ArgParsing` test (ryanofsky)
- - #17420 travis: Rework `cache_err_msg` (MarcoFalke)
- - #17423 ci: Make ci system read-only on the git work tree (MarcoFalke)
- - #17435 check custom ancestor limit in `mempool_packages.py` (theStack)
- - #17455 Update valgrind suppressions (practicalswift)
- - #17461 Check custom descendant limit in `mempool_packages.py` (theStack)
- - #17469 Remove fragile `assert_memory_usage_stable` (MarcoFalke)
- - #17470 ci: Use clang-8 for fuzzing to run on aarch64 ci systems (MarcoFalke)
- - #17480 Add unit test for non-standard txs with too large scriptSig (theStack)
- - #17497 Skip tests when utils haven't been compiled (fanquake)
- - #17502 Add unit test for non-standard bare multisig txs (theStack)
- - #17511 Add bounds checks before base58 decoding (sipa)
- - #17517 ci: Bump to clang-8 for asan build to avoid segfaults on ppc64le (MarcoFalke)
- - #17522 Wait until mempool is loaded in `wallet_abandonconflict` (MarcoFalke)
- - #17532 Add functional test for non-standard txs with too large scriptSig (theStack)
- - #17541 Add functional test for non-standard bare multisig txs (theStack)
- - #17555 Add unit test for non-standard txs with wrong nVersion (dspicher)
- - #17571 Add `libtest_util` library to msvc build configuration (sipsorcery)
- - #17591 ci: Add big endian platform - s390x (elichai)
- - #17593 Move more utility functions into test utility library (mzumsande)
- - #17633 Add option --valgrind to run the functional tests under Valgrind (practicalswift)
- - #17635 ci: Add centos 7 build (hebasto)
- - #17641 Add unit test for leveldb creation with unicode path (sipsorcery)
- - #17674 Add initialization order fiasco detection in Travis (practicalswift)
- - #17675 Enable tests which are incorrectly skipped when running `test_runner.py --usecli` (practicalswift)
- - #17685 Fix bug in the descriptor parsing fuzzing harness (`descriptor_parse`) (practicalswift)
- - #17705 re-enable CLI test support by using EncodeDecimal in json.dumps() (fanquake)
- - #17720 add unit test for non-standard "scriptsig-not-pushonly" txs (theStack)
- - #17767 ci: Fix qemu issues (MarcoFalke)
- - #17793 ci: Update github actions ci vcpkg cache on msbuild update (hebasto)
- - #17806 Change filemode of `rpc_whitelist.py` (emilengler)
- - #17849 ci: Fix brew python link (hebasto)
- - #17851 Add `std::to_string` to list of locale dependent functions (practicalswift)
- - #17893 Fix double-negative arg test (hebasto)
- - #17900 ci: Combine 32-bit build with centos 7 build (theStack)
- - #17921 Test `OP_CSV` empty stack fail in `feature_csv_activation.py` (theStack)
- - #17931 Fix `p2p_invalid_messages` failing in Python 3.8 because of warning (elichai)
- - #17947 add unit test for non-standard txs with too large tx size (theStack)
- - #17959 Check specific reject reasons in `feature_csv_activation.py` (theStack)
- - #17984 Add p2p test for forcerelay permission (MarcoFalke)
- - #18001 Updated appveyor job to checkout a specific vcpkg commit ID (sipsorcery)
- - #18008 fix fuzzing using libFuzzer on macOS (fanquake)
- - #18013 bench: Fix benchmarks filters (elichai)
- - #18018 reset fIsBareMultisigStd after bare-multisig tests (fanquake)
- - #18022 Fix appveyor `test_bitcoin` build of `*.raw` (MarcoFalke)
- - #18037 util: Allow scheduler to be mocked (amitiuttarwar)
- - #18056 ci: Check for submodules (emilengler)
- - #18069 Replace 'regtest' leftovers by self.chain (theStack)
- - #18081 Set a name for CI Docker containers (fanquake)
- - #18109 Avoid hitting some known minor tinyformat issues when fuzzing strprintf(?) (practicalswift)
- - #18155 Add harness which fuzzes EvalScript and VerifyScript using a fuzzed signature checker (practicalswift)
- - #18159 Add --valgrind option to `test/fuzz/test_runner.py` for running fuzzing test cases under valgrind (practicalswift)
- - #18166 ci: Run fuzz testing test cases (bitcoin-core/qa-assets) under valgrind to catch memory errors (practicalswift)
- - #18172 Transaction expiry from mempool (0xB10C)
- - #18181 Remove incorrect assumptions in `validation_flush_tests` (MarcoFalke)
- - #18183 Set `catch_system_errors=no` on boost unit tests (MarcoFalke)
- - #18195 Add `cost_of_change` parameter assertions to `bnb_search_test` (yancyribbens)
- - #18209 Reduce unneeded whitelist permissions in tests (MarcoFalke)
- - #18211 Disable mockforward scheduler unit test for now (MarcoFalke)
- - #18213 Fix race in `p2p_segwit` (MarcoFalke)
- - #18224 Make AnalyzePSBT next role calculation simple, correct (instagibbs)
- - #18228 Add missing syncwithvalidationinterfacequeue (MarcoFalke)
- - #18247 Wait for both veracks in `add_p2p_connection` (MarcoFalke)
- - #18249 Bump timeouts to accomodate really slow disks (MarcoFalke)
- - #18255 Add `bad-txns-*-toolarge` test cases to `invalid_txs` (MarcoFalke)
- - #18263 rpc: change setmocktime check to use IsMockableChain (gzhao408)
- - #18285 Check that `wait_until` returns if time point is in the past (MarcoFalke)
- - #18286 Add locale fuzzer to `FUZZERS_MISSING_CORPORA` (practicalswift)
- - #18292 fuzz: Add `assert(script == decompressed_script)` (MarcoFalke)
- - #18299 Update `FUZZERS_MISSING_CORPORA` to enable regression fuzzing for all harnesses in master (practicalswift)
- - #18300 fuzz: Add option to merge input dir to test runner (MarcoFalke)
- - #18305 Explain why test logging should be used (MarcoFalke)
- - #18306 Add logging to `wallet_listsinceblock.py` (jonatack)
- - #18311 Bumpfee test fix (instagibbs)
- - #18314 Add deserialization fuzzing of SnapshotMetadata (`utxo_snapshot`) (practicalswift)
- - #18319 fuzz: Add missing `ECC_Start` to `key_io` test (MarcoFalke)
- - #18334 Add basic test for BIP 37 (MarcoFalke)
- - #18350 Fix mining to an invalid target + ensure that a new block has the correct hash internally (TheQuantumPhysicist)
- - #18378 Bugfix & simplify bn2vch using `int.to_bytes` (sipa)
- - #18393 Don't assume presence of `__builtin_mul_overflow(?)` in `MultiplicationOverflow(?)` fuzzing harness (practicalswift)
- - #18406 add executable flag for `rpc_estimatefee.py` (theStack)
- - #18420 listsinceblock block height checks (jonatack)
- - #18430 ci: Only clone bitcoin-core/qa-assets when fuzzing (MarcoFalke)
- - #18438 ci: Use homebrew addon on native macos (hebasto)
- - #18447 Add coverage for script parse error in ParseScript (pierreN)
- - #18472 Remove unsafe `BOOST_TEST_MESSAGE` (MarcoFalke)
- - #18474 check that peer is connected when calling sync_* (MarcoFalke)
- - #18477 ci: Use focal for fuzzers (MarcoFalke)
- - #18481 add BIP37 'filterclear' test to p2p_filter.py (theStack)
- - #18496 Remove redundant `sync_with_ping` after `add_p2p_connection` (jonatack)
- - #18509 fuzz: Avoid running over all inputs after merging them (MarcoFalke)
- - #18510 fuzz: Add CScriptNum::getint coverage (MarcoFalke)
- - #18514 remove rapidcheck integration and tests (fanquake)
- - #18515 Add BIP37 remote crash bug [CVE-2013-5700] test to `p2p_filter.py` (theStack)
- - #18516 relax bumpfee `dust_to_fee` txsize an extra vbyte (jonatack)
- - #18518 fuzz: Extend descriptor fuzz test (MarcoFalke)
- - #18519 fuzz: Extend script fuzz test (MarcoFalke)
- - #18521 fuzz: Add `process_messages` harness (MarcoFalke)
- - #18529 Add fuzzer version of randomized prevector test (sipa)
- - #18534 skip backwards compat tests if not compiled with wallet (fanquake)
- - #18540 `wallet_bumpfee` assertion fixup (jonatack)
- - #18543 Use one node to avoid a race due to missing sync in `rpc_signrawtransaction` (MarcoFalke)
- - #18561 Properly raise FailedToStartError when rpc shutdown before warmup finished (MarcoFalke)
- - #18562 ci: Run unit tests sequential once (MarcoFalke)
- - #18563 Fix `unregister_all_during_call` cleanup (ryanofsky)
- - #18566 Set `-use_value_profile=1` when merging fuzz inputs (MarcoFalke)
- - #18757 Remove enumeration of expected deserialization exceptions in ProcessMessage(?) fuzzer (practicalswift)
- - #18878 Add test for conflicted wallet tx notifications (ryanofsky)
- - #18975 Remove const to work around compiler error on xenial (laanwj)

### Documentation
- - #16947 Doxygen-friendly script/descriptor.h comments (ch4ot1c)
- - #16983 Add detailed info about Bitcoin Core files (hebasto)
- - #16986 Doxygen-friendly CuckooCache comments (ch4ot1c)
- - #17022 move-only: Steps for "before major release branch-off" (MarcoFalke)
- - #17026 Update bips.md for default bech32 addresses in 0.20.0 (MarcoFalke)
- - #17081 Fix Makefile target in benchmarking.md (theStack)
- - #17102 Add missing indexes/blockfilter/basic to doc/files.md (MarcoFalke)
- - #17119 Fix broken bitcoin-cli examples (andrewtoth)
- - #17134 Add switch on enum example to developer notes (hebasto)
- - #17142 Update macdeploy README to include all files produced by `make deploy` (za-kk)
- - #17146 github: Add warning for bug reports (laanwj)
- - #17157 Added instructions for how to add an upsteam to forked repo (dannmat)
- - #17159 Add a note about backporting (carnhofdaki)
- - #17169 Correct function name in ReportHardwareRand() (fanquake)
- - #17177 Describe log files + consistent paths in test READMEs (fjahr)
- - #17239 Changed miniupnp links to https (sandakersmann)
- - #17281 Add developer note on `c_str()` (laanwj)
- - #17285 Bip70 removal follow-up (fjahr)
- - #17286 Fix help-debug -checkpoints (ariard)
- - #17309 update MSVC instructions to remove Qt OpenSSL linking (fanquake)
- - #17339 Add template for good first issues (michaelfolkson)
- - #17351 Fix some misspellings (RandyMcMillan)
- - #17353 Add ShellCheck to lint tests dependencies (hebasto)
- - #17370 Update doc/bips.md with recent changes in master (MarcoFalke)
- - #17393 Added regtest config for linearize script (gr0kchain)
- - #17411 Add some better examples for scripted diff (laanwj)
- - #17503 Remove bitness from bitcoin-qt help message and manpage (laanwj)
- - #17539 Update and improve Developer Notes (hebasto)
- - #17561 Changed MiniUPnPc link to https in dependencies.md (sandakersmann)
- - #17596 Change doxygen URL to doxygen.bitcoincore.org (laanwj)
- - #17598 Update release process with latest changes (MarcoFalke)
- - #17617 Unify unix epoch time descriptions (jonatack)
- - #17637 script: Add keyserver to verify-commits readme (emilengler)
- - #17648 Rename wallet-tool references to bitcoin-wallet (hel-o)
- - #17688 Add "ci" prefix to CONTRIBUTING.md (hebasto)
- - #17751 Use recommended shebang approach in documentation code block (hackerrdave)
- - #17752 Fix directory path for secp256k1 subtree in developer-notes (hackerrdave)
- - #17772 Mention PR Club in CONTRIBUTING.md (emilengler)
- - #17804 Misc RPC help fixes (MarcoFalke)
- - #17819 Developer notes guideline on RPCExamples addresses (jonatack)
- - #17825 Update dependencies.md (hebasto)
- - #17873 Add to Doxygen documentation guidelines (jonatack)
- - #17907 Fix improper Doxygen inline comments (Empact)
- - #17942 Improve fuzzing docs for macOS users (fjahr)
- - #17945 Fix doxygen errors (Empact)
- - #18025 Add missing supported rpcs to doc/descriptors.md (andrewtoth)
- - #18070 Add note about `brew doctor` (givanse)
- - #18125 Remove PPA note from release-process.md (fanquake)
- - #18170 Minor grammatical changes and flow improvements (travinkeith)
- - #18212 Add missing step in win deployment instructions (dangershony)
- - #18219 Add warning against wallet.dat re-use (corollari)
- - #18253 Correct spelling errors in comments (Empact)
- - #18278 interfaces: Describe and follow some code conventions (ryanofsky)
- - #18283 Explain rebase policy in CONTRIBUTING.md (MarcoFalke)
- - #18340 Mention MAKE=gmake workaround when building on a BSD (fanquake)
- - #18341 Replace remaining literal BTC with `CURRENCY_UNIT` (domob1812)
- - #18342 Add fuzzing quickstart guides for libFuzzer and afl-fuzz (practicalswift)
- - #18344 Fix nit in getblockchaininfo (stevenroose)
- - #18379 Comment fix merkle.cpp (4d55397500)
- - #18382 note the costs of fetching all pull requests (vasild)
- - #18391 Update init and reduce-traffic docs for -blocksonly (glowang)
- - #18464 Block-relay-only vs blocksonly (MarcoFalke)
- - #18486 Explain new test logging (MarcoFalke)
- - #18505 Update webchat URLs in README.md (SuriyaaKudoIsc)
- - #18513 Fix git add argument (HashUnlimited)
- - #18577 Correct scripted-diff example link (yahiheb)
- - #18589 Fix naming of macOS SDK and clarify version (achow101)

### Miscellaneous
- - #15600 lockedpool: When possible, use madvise to avoid including sensitive information in core dumps (luke-jr)
- - #15934 Merge settings one place instead of five places (ryanofsky)
- - #16115 On bitcoind startup, write config args to debug.log (LarryRuane)
- - #16117 util: Replace boost sleep with std sleep (MarcoFalke)
- - #16161 util: Fix compilation errors in support/lockedpool.cpp (jkczyz)
- - #16802 scripts: In linearize, search for next position of magic bytes rather than fail (takinbo)
- - #16889 Add some general std::vector utility functions (sipa)
- - #17049 contrib: Bump gitian descriptors for 0.20 (MarcoFalke)
- - #17052 scripts: Update `copyright_header` script to include additional files (GChuf)
- - #17059 util: Simplify path argument for cblocktreedb ctor (hebasto)
- - #17191 random: Remove call to `RAND_screen()` (Windows only) (fanquake)
- - #17192 util: Add `check_nonfatal` and use it in src/rpc (MarcoFalke)
- - #17218 Replace the LogPrint function with a macro (jkczyz)
- - #17266 util: Rename decodedumptime to parseiso8601datetime (elichai)
- - #17270 Feed environment data into RNG initializers (sipa)
- - #17282 contrib: Remove accounts from bash completion (fanquake)
- - #17293 Add assertion to randrange that input is not 0 (JeremyRubin)
- - #17325 log: Fix log message for -par=1 (hebasto)
- - #17329 linter: Strip trailing / in path for git-subtree-check (jnewbery)
- - #17336 scripts: Search for first block file for linearize-data with some block files pruned (Rjected)
- - #17361 scripts: Lint gitian descriptors with shellcheck (hebasto)
- - #17482 util: Disallow network-qualified command line options (ryanofsky)
- - #17507 random: mark RandAddPeriodic and SeedPeriodic as noexcept (fanquake)
- - #17527 Fix CPUID subleaf iteration (sipa)
- - #17604 util: Make schedulebatchpriority advisory only (fanquake)
- - #17650 util: Remove unwanted fields from bitcoin-cli -getinfo (malevolent)
- - #17671 script: Fixed wget call in gitian-build.py (willyko)
- - #17699 Make env data logging optional (sipa)
- - #17721 util: Don't allow base58 decoding of non-base58 strings. add base58 tests (practicalswift)
- - #17750 util: Change getwarnings parameter to bool (jnewbery)
- - #17753 util: Don't allow base32/64-decoding or parsemoney(?) on strings with embedded nul characters. add tests (practicalswift)
- - #17823 scripts: Read suspicious hosts from a file instead of hardcoding (sanjaykdragon)
- - #18162 util: Avoid potential uninitialized read in `formatiso8601datetime(int64_t)` by checking `gmtime_s`/`gmtime_r` return value (practicalswift)
- - #18167 Fix a violation of C++ standard rules where unions are used for type-punning (TheQuantumPhysicist)
- - #18225 util: Fail to parse empty string in parsemoney (MarcoFalke)
- - #18270 util: Fail to parse whitespace-only strings in parsemoney(?) (instead of parsing as zero) (practicalswift)
- - #18316 util: Helpexamplerpc formatting (jonatack)
- - #18357 Fix missing header in sync.h (promag)
- - #18412 script: Fix `script_err_sig_pushonly` error string (theStack)
- - #18416 util: Limit decimal range of numbers parsescript accepts (pierreN)
- - #18503 init: Replace `URL_WEBSITE` with `PACKAGE_URL` (MarcoFalke)
- - #18526 Remove PID file at the very end (hebasto)
- - #18553 Avoid non-trivial global constants in SHA-NI code (sipa)
- - #18665 Do not expose and consider `-logthreadnames` when it does not work (hebasto)

Credits
=======

Thanks to everyone who directly contributed to this release:

- - 0xb10c
- - 251
- - 4d55397500
- - Aaron Clauson
- - Adam Jonas
- - Albert
- - Amiti Uttarwar
- - Andrew Chow
- - Andrew Toth
- - Anthony Towns
- - Antoine Riard
- - Ava Barron
- - Ben Carman
- - Ben Woosley
- - Block Mechanic
- - Brian Solon
- - Bushstar
- - Carl Dong
- - Carnhof Daki
- - Cory Fields
- - Daki Carnhof
- - Dan Gershony
- - Daniel Kraft
- - dannmat
- - Danny-Scott
- - darosior
- - David O'Callaghan
- - Dominik Spicher
- - Elichai Turkel
- - Emil Engler
- - emu
- - Fabian Jahr
- - fanquake
- - Filip Gospodinov
- - Franck Royer
- - Gast?n I. Silva
- - gchuf
- - Gleb Naumenko
- - Gloria Zhao
- - glowang
- - Gr0kchain
- - Gregory Sanders
- - hackerrdave
- - Harris
- - hel0
- - Hennadii Stepanov
- - ianliu
- - Igor Cota
- - James Chiang
- - James O'Beirne
- - Jan Beich
- - Jan Sarenik
- - Jeffrey Czyz
- - Jeremy Rubin
- - JeremyCrookshank
- - Jim Posen
- - John Bampton
- - John L. Jegutanis
- - John Newbery
- - Jon Atack
- - Jon Layton
- - Jonas Schnelli
- - Jo?o Barbosa
- - Jorge Tim?n
- - Karl-Johan Alm
- - kodslav
- - Larry Ruane
- - Luke Dashjr
- - malevolent
- - MapleLaker
- - marcaiaf
- - MarcoFalke
- - Marius Kj?rstad
- - Mark Erhardt
- - Mark Tyneway
- - Martin Erlandsson
- - Martin Zumsande
- - Matt Corallo
- - Matt Ward
- - Michael Folkson
- - Michael Polzer
- - Micky Yun Chan
- - Neha Narula
- - nijynot
- - naumenkogs
- - NullFunctor
- - Peter Bushnell
- - pierrenn
- - Pieter Wuille
- - practicalswift
- - randymcmillan
- - Rjected
- - Russell Yanofsky
- - Samer Afach
- - Samuel Dobson
- - Sanjay K
- - Sebastian Falbesoner
- - setpill
- - Sjors Provoost
- - Stefan Richter
- - stefanwouldgo
- - Steven Roose
- - Suhas Daftuar
- - Suriyaa Sundararuban
- - TheCharlatan
- - Tim Akinbo
- - Travin Keith
- - tryphe
- - Vasil Dimov
- - Willy Ko
- - Wilson Ccasihue S
- - Wladimir J. van der Laan
- - Yahia Chiheb
- - Yancy Ribbens
- - Yusuf Sahin HAMZA
- - Zakk
- - Zero

As well as to everyone that helped with translations on
[Transifex](https://www.transifex.com/bitcoin/bitcoin/).
-----BEGIN PGP SIGNATURE-----

iQEzBAEBCgAdFiEEnerg3HBjJJ+wVHRoHkrtYphs0l0FAl7XfU4ACgkQHkrtYphs
0l2cDgf+LRNcSCBQ6drHVobWXZQqRy/l9p5pTJQm5hZBrvuwinCajv45fGQO8nHU
F/hPAxoRBr6yEAoihOg1iYJxRJc0oH6SZhrgFv+z01+SNQLAzXiHpf/2lGQN97jC
FLMNGqd/qAsWxQxB2TE5fewsEKQ07aMQvlESlqzIiAWT0YcjBqBlIaR42whdVg3i
xQT0RYEI606ASWndFa2pTj5jF+/1ll7vBSvel2XMWZb2Y8W/kEYqpaY5Z5VoIpjE
dRYPUKd8fDJH6cRN/KVwEFMAry/5aF08ZpsqghPAGUoRVuI71jPU/YYwIaBA921k
Ubc+7DrLD4ZgRJau9X+1TglkZTsOjg==
=6O7i
-----END PGP SIGNATURE-----

From ZmnSCPxj at protonmail.com  Wed Jun  3 14:36:46 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 03 Jun 2020 14:36:46 +0000
Subject: [bitcoin-dev] SAS: Succinct Atomic Swap
In-Reply-To: <20200603140425.2a4e9d60@simplexum.com>
References: <CAPv7TjZGBbf6f1y49HLFD2eNiP5d4e+=dFGqiMFs6jaeYyH-NQ@mail.gmail.com>
 <vtu_ujJwxJDSC3w4QI5VlQ8WfkxaRg1Jk4nSNybgeYSWgGrN7sJiKa9dNzb0tDbRBdVhT4p60v-j6C2F8LmFxMLUTi_VtCznWRb56GVlvu8=@protonmail.com>
 <CAPv7TjYePyEt2YMg3J_KinK6Lv6SSLAF2nrOj79_oVt8qBXN0w@mail.gmail.com>
 <OyxLj_9i4yfbKGK-W0GXc2V9bQA3RJBPGHmPUz3OtwG6ZMCpRwgXtuFl9E_aDi4M_VP3cNIVoqj3mIjTJ_2rRdGuWyoJcNNCKs2G6znGhck=@protonmail.com>
 <20200603140425.2a4e9d60@simplexum.com>
Message-ID: <UumGKofzr_d8aqpQE2fS6kkbJTRfkuOwpbdNBlaNLe8hB_pUZSI0kNOypT-HeSsQP3ZXoW4vyvknUyQ6Zi22rDLGcedvkv_Rj6pgVbNVKUM=@protonmail.com>

Good morning Dmitry,

> I made a version of the TLA+ spec according to the suggested variant,
> as I understood it from your description. This version is in
> the separate branch in the SASwap repo, 'variant_ZmnSCPxj' [1]
>
> If I understood and specified your variant correctly, there is a
> deadlock possible after step 9, if Bob fails to publish success tx in
> time. After refund tx becomes spendable, Alice cannot publish it via
> mempool, because Bob can learn her secret and has a chance invalidate
> her refund tx by giving his success tx to friendly miner, while taking
> back the locked LTC because both secrets are known. At the same time,
> Bob cannot publish success tx via mempool, because then Alice can do
> the same thing, invalidating his success tx with refund tx via friednly
> miner.

Indeed, this is precisely the issue Ruben pointed out.

Rationally, neither side will want this condition due to the deadlock and Bob will strive to avoid this, having a short real-world timeout after which Bob will force publication of the success tx if Alice does not respond in time.
There *is* a reason why it says "Bob claims the BTC funding txo before L1."

Of course, computers do crash occasionally, I am informed, so complete accidents may occur that way.
This can be mitigated by running multiple servers who are given copies of the success tx, and which will publish it regardless after a short sidereal time duration, unless countermanded by the main server (i,e, a dead man switch system).
With sufficient distribution the probability of this occurring can drop to negligible levels compared to other theoretical attacks.

Regards,
ZmnSCPxj


From ZmnSCPxj at protonmail.com  Wed Jun  3 14:50:01 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 03 Jun 2020 14:50:01 +0000
Subject: [bitcoin-dev] Design for a CoinSwap implementation for
	massively improving Bitcoin privacy and fungibility
In-Reply-To: <5LiZqpFxklAAbGFiiAE3ijRbIteODXKcHrXvGJ-qabgQj5hG8beFtHNbVZ-XUxETVwduJYz94UYuJGAPxBrbGeZpSClUtXYsPJBABfr03KM=@protonmail.com>
References: <82d90d57-ad07-fc7d-4aca-2b227ac2068d@riseup.net>
 <CAPv7TjY9h8n-nK_CPiYCWYDcbXpT1gfRMQDgf9VUkcR532rxOw@mail.gmail.com>
 <VxL93WE7bDrK1riquTWTTEgJj9mDQ4W5CuhOgdnnDPeidw2ho6evVh4cLZLz0jEYMqejaD1tiLULVTXkNRbI5A7wSwV49qSwnXcTWCDJ96E=@protonmail.com>
 <cbf78f63-cf8c-c5d8-06ea-afc79aabc23c@riseup.net>
 <5LiZqpFxklAAbGFiiAE3ijRbIteODXKcHrXvGJ-qabgQj5hG8beFtHNbVZ-XUxETVwduJYz94UYuJGAPxBrbGeZpSClUtXYsPJBABfr03KM=@protonmail.com>
Message-ID: <0U3wfLU9DpPZ7pwMOAr4xned-mOcHrpje4aLLiXZOt1qGuMhhyh36kAYJMEyv9bNjH2pMEzkkKK2rkAt9BD2pv_XknjdeqxEkEFsfSr4JAc=@protonmail.com>

Good morning Chris again,


> For the avoidance of theft, it is probably better for Bob to wait for Alice-side funding tx to confirm, probably deeply because reorgs suck.


Over in Lightning-land, we have a concept called "irrevocably committed".
This is a state where a newly-created contract can no longer be cancelled, by publishing an older state.
In Lightning, there is a short timeframe where a new state, and its directly previous state, are both still valid, until the previous state is revoked.
Only once the previous state (that does not contain the contract) has been revoked, and only the latest state is valid, can a forwarding node actually forward the payment.


This is roughly equivalent to the funding tx for the CoinSwap being confirmed.
Until a transaction is confirmed, the UTXOs it spends (i.e. the previous state) can still be validly spent by other alternate transactions.


Regards,
ZmnSCPxj

From naumenko.gs at gmail.com  Wed Jun  3 16:20:09 2020
From: naumenko.gs at gmail.com (Gleb Naumenko)
Date: Wed, 3 Jun 2020 19:20:09 +0300
Subject: [bitcoin-dev] Time-dilation Attacks on the Lightning Network
In-Reply-To: <2e8fba65-f7fa-4c37-a318-222547e25a06@Spark>
References: <2e8fba65-f7fa-4c37-a318-222547e25a06@Spark>
Message-ID: <9e4dfaa7-895a-48a1-8116-eaafc80da34f@Spark>

Hi! I and Antoine Riard explored time-dilation attacks on Lightning.

We have a blogpost, which is probably too long to include in the email in full.
You can read it here:?https://discrete-blog.github.io/time-dilation/
There?s also a paper we wrote:?https://arxiv.org/abs/2006.01418


We believe this work should be interesting for anyone curious/excited about LN or other second-layer protocols in Bitcoin. We are very interested in your opinions!

Now, let me share the intro from the post with you (which is really a summary of the work), since it?s about the right size for a mailing list post. Hopefully, it would motivate you to read further.

Protocols on top of the Bitcoin base layer are really cool. They offer tremendous opportunities in terms of scalability, confidentiality, and functionality, at a cost of new security assumptions.

We all know payment channels have to be monitored, otherwise, the funds can be stolen. That sounds too abstract though. We decided to study what an attacker actually has to do to steal funds from LN users.

More specifically, we explored how peer-to-peer layer attacks can help with breaking the assumption above. Per time-dilation attacks, an attacker controls the victim?s access to the Bitcoin network (hard, but not impossible) and delays block delivery to the victim. After that, the attacker exploits that the victim can?t access recent blocks in a timely manner. In some cases, it is enough to isolate the victim only for two hours.

Then the attacker makes a couple (totally legit) actions on the Lightning Network towards the victim?s channels, and at the same time commits a different state instead. Since the victim is behind in terms of the latest blockchain tip, they cannot detect this and react as required by the protocol.

We demonstrate three different ways the attacker can steal funds from the victim, and discuss the feasibility/cost of these attacks. We also explore the broad scope of countermeasures, which may significantly increase the attack cost.

In short, the takeaways from our work are:

1. Many Lightning users (those with Bitcoin light clients) are currently vulnerable to Eclipse attacks.
2. Those Lightning users which run Bitcoin Core full nodes are more robust to Eclipse attacks, but the attacks are still possible as recent research suggests.
3. Eclipse attacks enable stealing funds via time-dilation.
4. Time-dilation attacks can?t be mitigated with just observing slow block arrival, so there is no simple solution to (3).
5. Thus, time-dilation is a practical way to steal funds from eclipsed users. Neither it requires hashrate nor targets merchants only. Light client users are a good target because they are easy to attack. Full node users are a good target because they are often used by major hubs (or service providers), and stealing their aggregate liquidiy might justify the high attack cost.
6. Strong anti-Eclipse measures is the key solution. WatchTowers are cool too.


Best,

Gleb Naumenko and Antoine Riard
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200603/c9aff631/attachment.html>

From ZmnSCPxj at protonmail.com  Thu Jun  4 02:58:24 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 04 Jun 2020 02:58:24 +0000
Subject: [bitcoin-dev] Time-dilation Attacks on the Lightning Network
In-Reply-To: <9e4dfaa7-895a-48a1-8116-eaafc80da34f@Spark>
References: <2e8fba65-f7fa-4c37-a318-222547e25a06@Spark>
 <9e4dfaa7-895a-48a1-8116-eaafc80da34f@Spark>
Message-ID: <2phhD75B8ww3hFQ8Do039wAIlW8EVOjUeiedm-JtIek-TEnVocYSx-untchGrO3VoRLoPzinVAG95UN1yR3CadNWBJGSu19vJpFJ_yN-wZY=@protonmail.com>

Good morning Gleb and Antoine,

This is good research, thank you for your work.

> **Targeting Per-Hop Packet Delay** is based on routing via the victim, and the victim should have at least two channels with the attacker.

The existence of offchain-to-onchain swap services means that the attacker needs only build one channel to the victim for this attack to work.
Rather than route to themselves, the attacker routes to a convenient service providing such a swap service, and receives the stolen funds onchain, with no need even for an incoming channel from a different node.
(Of note as well, is that the onchain contract provided by such services is the same in spirit as those instantiated in channels of the Lightning Network, thus the same attack schema works on the onchain side.)

Indeed, the attack can be mounted on such a service directly.

Even without such a service, the incoming channel need not be directly connected to the victim.


> [Tor is tricky](https://arxiv.org/abs/1410.6079) too

Since the issue here is that eclipsing of Bitcoin nodes is risky, it strikes me that a mitigation would be to run your Bitcoin fullnode on clearnet while running your Lightning node over Tor.
Eclipsing the Lightning node (but not the Bitcoin fullnode it depends on) "only" loses you the ability to pay, receive, or route (and thereby earn forwarding fees), but as long as your blockchain view is clear, it should be fine.

Of course, the Lightning node could still be correlated with the Bitcoin node when transactions are broadcast with the attached Bitcoin node (as noted in the paper).
Instead the Lightning node should probably connect, over Tor, to some random Bitcoin fullnodes / Electrum servers and broadcast txes to them.

And this seems to tie with what you propose: that the LN node should use a different view-fullnode from the broadcast-fullnode.


> if a node doesn?t observe a block within the last 30 minutes, it attempts to make a new random connection to someone in the network.

A mitigation to this would be to run a background process which sleeps for 20 minutes, then does `bitcoin-cli addnode ${BITCOINNODE} onetry`.
It might want to `disconnectnode` any previous node it attempted to connect to.

However I note that the help for `addnode` contains the text "though such peers will not be synced from", which confuses me, since it also refers to the `-connect` command line option, and `-connect` means you only connect out to the specific nodes, so if those are not synced from.... huh?

And of course the interesting part is "how do we get a `${BITCOINNODE}` that we think is not part of the eclipsing attacker?"


> If a Lightning node is behind in its Bitcoin blockchain view, but Lightning payments between honest nodes are still flowing through it, this node will have a high routing failure rate. This would happen because honest nodes on the routing path would reject the forwarded HTLC for being too close to expired.

I am uncertain this would happen very often.
In the first place, the incoming HTLC would have "reasonable" timeouts, or else the incoming honest node would not have routed it at all, and the outgoing HTLC would be relative to this incoming one, so the outgoing honest node will still accept this.

The victim *could* instead check that the absolute timelocks seem very far in the future relative to its own view of the current blockheight.
(a forwarding node miht want to do that anyway to have an upper bound against griefing attacks)

What would definitely increase in failure rate would be payments arising from the victim node; the victim node believes the blockheight to be much lower than it actually is, and either the payee node, or some intermediate node along the route, will claim to have too little time to safely forward the funds.
This does not help for nodes which are primarily forwarding nodes.



Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Thu Jun  4 16:37:53 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 04 Jun 2020 16:37:53 +0000
Subject: [bitcoin-dev] Design for a CoinSwap implementation for
	massively improving Bitcoin privacy and fungibility
In-Reply-To: <0U3wfLU9DpPZ7pwMOAr4xned-mOcHrpje4aLLiXZOt1qGuMhhyh36kAYJMEyv9bNjH2pMEzkkKK2rkAt9BD2pv_XknjdeqxEkEFsfSr4JAc=@protonmail.com>
References: <82d90d57-ad07-fc7d-4aca-2b227ac2068d@riseup.net>
 <CAPv7TjY9h8n-nK_CPiYCWYDcbXpT1gfRMQDgf9VUkcR532rxOw@mail.gmail.com>
 <VxL93WE7bDrK1riquTWTTEgJj9mDQ4W5CuhOgdnnDPeidw2ho6evVh4cLZLz0jEYMqejaD1tiLULVTXkNRbI5A7wSwV49qSwnXcTWCDJ96E=@protonmail.com>
 <cbf78f63-cf8c-c5d8-06ea-afc79aabc23c@riseup.net>
 <5LiZqpFxklAAbGFiiAE3ijRbIteODXKcHrXvGJ-qabgQj5hG8beFtHNbVZ-XUxETVwduJYz94UYuJGAPxBrbGeZpSClUtXYsPJBABfr03KM=@protonmail.com>
 <0U3wfLU9DpPZ7pwMOAr4xned-mOcHrpje4aLLiXZOt1qGuMhhyh36kAYJMEyv9bNjH2pMEzkkKK2rkAt9BD2pv_XknjdeqxEkEFsfSr4JAc=@protonmail.com>
Message-ID: <mW43gzUcbr5HziCafjw_a-yZb3sdNl7SrsUTBpQFnZzVwRgpSVFUZzg4u6ORXzs9fc8KeWbdpGuCPnrA3iYjdmc1O_E84hyL-Qsr3cvqVGY=@protonmail.com>

Good morning yet again Chris,

> > For the avoidance of theft, it is probably better for Bob to wait for Alice-side funding tx to confirm, probably deeply because reorgs suck.

I realized that the *other* improvement I proposed in the [CoinSwapCS issue](https://github.com/AdamISZ/CoinSwapCS/issues/53) would help with this.
Specifically, `nLockTime`-protected Backouts.

Suppose we have an S6 route as so, with Alice as taker and Bob1 and Bob2 as makers:

    Alice -> Bob1 -> Bob2 -> Alice

We assume here that Bob1 and Bob2 directly talk to Alice and that if Bob1 wants to talk to Bob2 it is done via Alice, so in the below if we say "Bob1 sends to Bob2" we imply that this is done via Alice.

1.  Alice solicits fresh pubkeys from Bob1 and Bob2.
2.  Alice gives timeouts L1 and L2 to Bob1, and L2 and L3 to Bob2, such that L1 > L2 > L3, as well as negotiated amount, fees, etc.
3.  Alice creates (but does NOT sign) a funding tx paying to Alice && Bob1 and gives the txid to Bob1.
4.  Bob1 creates and signs a tx spending from the Alice funding tx and paying to Alice, with `nLockTime = L1`, and gives the signature to Alice.
5.  Bob1 creates (but does NOT sign) a funding tx paying to Bob1 && Bob2 and gives the txid to Bob2.
6.  Bob2 creates and signs a tx spending from the Bob1 funding tx and paying to Bob1, with `nLockTime = L2`, and gives the signature to Bob1.
7.  Bob2 creates (but does NOT sign) a funding tx paying to Bob2 && Alice and gives the txid to Alice.
8.  Alice creates and signs a tx spending from the Bob2 funding tx and paying to Bob2, with `nLockTime = L3`, and gives the signature to Bob2.
9.  Alice signals everyone to sign their respecting funding txes and broadcast them.

The rest of the CoinSwap protocol executes as normal once the funding txes are deeply confirmed.
The only thing that Bob1 (resp. Bob2) needs to wait for is that the signatures for the incoming HTLC / PTLC have been received before forwarding to the next hop.
This allows all funding txes to be confirmed in the same block, or even in some suitable random order (by having Alice send the signal out at different times/blocks to different makers).

The `nLockTime`d backout transactions are sufficient to allow everyone to recover their funds unilaterally in case one of the other funding txes do not confirm.

A similar technique can be done for SAS as well, but this removes the lack of encumbrance in the LTC-side output of SAS, which removes the advantage of having an otherwise unencumbered output.

In effect, the above creates Spilman unidirectional payment channels along the route, bringing the fiddly timing details offchain where it is less visible to observers.

--

However, note that this still allows a form of griefing attack.
Basically, Alice can induce Bob1 and Bob2 to lock their funds for some time, by completing the above ritual, but not signing and broadcasting its own funding tx.
Bob1 and Bob2 will have been induced to lock their funds for L2 and L3, respectively, while Alice only has to RBF away its own funding tx.

Alice might do this if it is actually another maker and it wants to take out its competitors Bob1 and Bob2, reducing their available liquidity for a time and cornering the SwapMarket.


This can be mitigated by replacing step 9 with:

9.  Alice gives its signed funding tx to Bob1.
10.  Bob1 gives its signed funding tx to Bob2.
11.  Bob2 gives its signed funding tx to Alice.
12.  Alice signals everyone to broadcast their funding txes.

Then Bob1 (resp. Bob2) can monitor the mempool/blockchain and check as well if its outgoing funding tx has been broadcast/confirmed, and if so broadcast the incoming funding tx.
Or better, if Bob1 (resp. Bob2) does not receive the Alice signal fast enough, it will broadcast its incoming funding tx anyway.

This is only a mitigation: Alice could have pre-prepared a replacement to the funding tx that it broadcasts near miners just before it signals Bob1 and Bob2 to broadcast all transactions.

For full protection against griefing attacks, Bob1 (resp. Bob2) have to wait for the incoming funding tx to be confirmed deeply before broadcasting its outgoing funding tx as well.

Regards,
ZmnSCPxj


From vitteaymeric at gmail.com  Fri Jun  5 10:10:20 2020
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Fri, 5 Jun 2020 12:10:20 +0200
Subject: [bitcoin-dev] Time-dilation Attacks on the Lightning Network
In-Reply-To: <2phhD75B8ww3hFQ8Do039wAIlW8EVOjUeiedm-JtIek-TEnVocYSx-untchGrO3VoRLoPzinVAG95UN1yR3CadNWBJGSu19vJpFJ_yN-wZY=@protonmail.com>
References: <2e8fba65-f7fa-4c37-a318-222547e25a06@Spark>
 <9e4dfaa7-895a-48a1-8116-eaafc80da34f@Spark>
 <2phhD75B8ww3hFQ8Do039wAIlW8EVOjUeiedm-JtIek-TEnVocYSx-untchGrO3VoRLoPzinVAG95UN1yR3CadNWBJGSu19vJpFJ_yN-wZY=@protonmail.com>
Message-ID: <ff416daf-a5cf-abe9-ad0f-77ec36d3ea56@gmail.com>


Le 04/06/2020 ? 04:58, ZmnSCPxj via bitcoin-dev a ?crit?:
>> [Tor is tricky](https://arxiv.org/abs/1410.6079) too
> Since the issue here is that eclipsing of Bitcoin nodes is risky, it strikes me that a mitigation would be to run your Bitcoin fullnode on clearnet while running your Lightning node over Tor.
> Eclipsing the Lightning node (but not the Bitcoin fullnode it depends on) "only" loses you the ability to pay, receive, or route (and thereby earn forwarding fees), but as long as your blockchain view is clear, it should be fine.
>
> Of course, the Lightning node could still be correlated with the Bitcoin node when transactions are broadcast with the attached Bitcoin node (as noted in the paper).
> Instead the Lightning node should probably connect, over Tor, to some random Bitcoin fullnodes / Electrum servers and broadcast txes to them.
>
> And this seems to tie with what you propose: that the LN node should use a different view-fullnode from the broadcast-fullnode.
>

The issue each time there are discussions/research linking to Tor is
that it is biased since the beginning because based on a wrong
postulate: using the Tor network

I will not elaborate on this again, it's an obvious very bad idea to use
the Tor network for bitcoin

It's not a bad idea to use the Tor protocol with no story of exit nodes
and hidden services, linking again to:
https://github.com/Ayms/node-Tor#phase-4-and-phase-5

And new link: http://www.peersm.com/Convergence-2020.pdf "A universal
and generic architecture to anonymize any application or protocol and
turn it into an independent decentralized p2p network inside browsers
and servers, with browsers acting as servers"

LN and bitcoin nodes would be relays and/or RDV points and/or clients
and serving parties, some Tor network nodes could be used in the middle
also (relays only) but in any case sybils/eclipse attacks become much
more difficult to perform (or unlikely depending on how the peer
discovery system is designed)

bitcoin | node-Tor |bitcoin and LN.pipe(node-Tor)

Then question for possible future tests: is there a simple way to pipe
the bitcoin protocol via stdin/stdout? (the socks interface could be
used but we already saw that it did raise issues)

-- 
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200605/c512ceb6/attachment.html>

From ZmnSCPxj at protonmail.com  Fri Jun  5 11:44:53 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 05 Jun 2020 11:44:53 +0000
Subject: [bitcoin-dev] Time-dilation Attacks on the Lightning Network
In-Reply-To: <ff416daf-a5cf-abe9-ad0f-77ec36d3ea56@gmail.com>
References: <2e8fba65-f7fa-4c37-a318-222547e25a06@Spark>
 <9e4dfaa7-895a-48a1-8116-eaafc80da34f@Spark>
 <2phhD75B8ww3hFQ8Do039wAIlW8EVOjUeiedm-JtIek-TEnVocYSx-untchGrO3VoRLoPzinVAG95UN1yR3CadNWBJGSu19vJpFJ_yN-wZY=@protonmail.com>
 <ff416daf-a5cf-abe9-ad0f-77ec36d3ea56@gmail.com>
Message-ID: <AHiqSOkmCAgH6Lo_yUd93T0cJ9PDzz9pVxctgZ_08j9BjkyQR5my57uaPrYmiRJEWpmlij69ILg5YW0XB0oOmEpoE9Ta5YTffsULRXBUa6k=@protonmail.com>

Good morning Aymeric,

> The issue each time there are discussions/research linking to Tor is that it is biased since the beginning because based on a wrong postulate: using the Tor network
>

Well, in the interest of using the wrong tool for a highly important job, let me present this thought:

* The Tor network is weakened due to its dependence on a limited set of exit nodes.
* "Direct", within-Tor rendezvous points are good, i.e. Tor hidden services.
* Thus, there is no issue with Tor-to-Tor or clearnet-to-clearnet connections, the issue is with Tor-to-clearnet connections.
* Of course, no miner is going to run over Tor because latency, so all the miners will be on clearnet.
* So make your own bridge between Tor and clearnet.
* Run two fullnodes on your computer (with sufficient ingenuity, you can probably share their block storages, or make one pruning).
* One fullnode is on the public network but runs in `blocksonly` so it does not propagate any transactions (which might be attached to your public IP).
* The other fullnode is on the Tor network and has an `-addnode` to the public-network node via `localhost`, which I assume is very hard for an eclipse attacker to get at.
* Use the Tor-fullnode to propagate your transactions.

Of course, the eclipse attacker can still attack all Tor exit nodes and block outgoing transaction traffic to perform eclipse attacks.
And if you decide to propagate transactions to the public-network node then you pretty much lose your privacy there.

Regards,
ZmnSCPxj

From vitteaymeric at gmail.com  Fri Jun  5 15:41:48 2020
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Fri, 5 Jun 2020 17:41:48 +0200
Subject: [bitcoin-dev] Time-dilation Attacks on the Lightning Network
In-Reply-To: <AHiqSOkmCAgH6Lo_yUd93T0cJ9PDzz9pVxctgZ_08j9BjkyQR5my57uaPrYmiRJEWpmlij69ILg5YW0XB0oOmEpoE9Ta5YTffsULRXBUa6k=@protonmail.com>
References: <2e8fba65-f7fa-4c37-a318-222547e25a06@Spark>
 <9e4dfaa7-895a-48a1-8116-eaafc80da34f@Spark>
 <2phhD75B8ww3hFQ8Do039wAIlW8EVOjUeiedm-JtIek-TEnVocYSx-untchGrO3VoRLoPzinVAG95UN1yR3CadNWBJGSu19vJpFJ_yN-wZY=@protonmail.com>
 <ff416daf-a5cf-abe9-ad0f-77ec36d3ea56@gmail.com>
 <AHiqSOkmCAgH6Lo_yUd93T0cJ9PDzz9pVxctgZ_08j9BjkyQR5my57uaPrYmiRJEWpmlij69ILg5YW0XB0oOmEpoE9Ta5YTffsULRXBUa6k=@protonmail.com>
Message-ID: <03508424-639f-2f3f-8b0e-5b1013f5269a@gmail.com>

Hi,

As far as I understand your answer is "let's try to use what exists",
this is not what I am proposing and not the Tor network, no "standard"
exit nodes, different hidden services, decentralized anonymizer network
unlike the Tor network, nodes are anonymizing themselves

Comments below, please let me know what is unclear in the description of
the project so I can modify it because all the time I get the impression
that it is mixed with the Tor network while it just has a very little to
do with it, and I don't get that the simple principle of communicating
between nodes using the Tor protocol without RDV points is never considered

Regards,

Le 05/06/2020 ? 13:44, ZmnSCPxj a ?crit?:
> Good morning Aymeric,
>
>> The issue each time there are discussions/research linking to Tor is that it is biased since the beginning because based on a wrong postulate: using the Tor network
>>
> Well, in the interest of using the wrong tool for a highly important job, let me present this thought:
Then for an important job people should use the right tool...
>
> * The Tor network is weakened due to its dependence on a limited set of exit nodes.
And centralized structure, limited set of nodes to make it short, for
some (or a lot) misbehaving, not designed for bitcoin, nothing prevents
bitcoin from operating its own anonymizer system, which I am proposing
> * "Direct", within-Tor rendezvous points are good, i.e. Tor hidden services.
Good to a certain extent... if you want to hide that you are operating a
bitcoin node you can use RDV points (ie hidden services) but if you
don't care you just connect anonymized circuits between bitcoin nodes,
this is more "direct" and does not exist in the Tor network, this
includes light clients that can act as relays also
> * Thus, there is no issue with Tor-to-Tor or clearnet-to-clearnet connections, the issue is with Tor-to-clearnet connections.
There are plenty of Tor-to-Tor issues, not theoretical but in the real
world, "Tor-to-clearnet" can be done outside of the Tor network, ie the
bitcoin network
> * Of course, no miner is going to run over Tor because latency, so all the miners will be on clearnet.
Probably, again I am not proposing a remake of the Tor network, I don't
see the use for a miner to hide (neither for a bitcoin node to use RDV
points), but they can be part of the global anonymized system, please
see below
> * So make your own bridge between Tor and clearnet.
> * Run two fullnodes on your computer (with sufficient ingenuity, you can probably share their block storages, or make one pruning).
> * One fullnode is on the public network but runs in `blocksonly` so it does not propagate any transactions (which might be attached to your public IP).
> * The other fullnode is on the Tor network and has an `-addnode` to the public-network node via `localhost`, which I assume is very hard for an eclipse attacker to get at.
> * Use the Tor-fullnode to propagate your transactions.
Yes but one full node should be able to do this alone, ie implement both
interfaces, like miners and everybody in fact (or Peersm bridges with
bittorrent if you look at the history of the project)
>
> Of course, the eclipse attacker can still attack all Tor exit nodes and block outgoing transaction traffic to perform eclipse attacks.
> And if you decide to propagate transactions to the public-network node then you pretty much lose your privacy there.

Please see the convergence link, it's not based on the assumption that
"the more you are the better you can hide and the lesser you can get
attacked", this does not work at all, it's based on the assumption that
even with a reduced set of peers it becomes very difficult to know who
is doing what and whom is talking to whom, the concept of
exiting/bridging to clearnet(s) is not clearly detailed in this version
but appears on the drawings



From belcher at riseup.net  Fri Jun  5 22:39:47 2020
From: belcher at riseup.net (Chris Belcher)
Date: Fri, 5 Jun 2020 23:39:47 +0100
Subject: [bitcoin-dev] Design for a CoinSwap implementation for
 massively improving Bitcoin privacy and fungibility
In-Reply-To: <5LiZqpFxklAAbGFiiAE3ijRbIteODXKcHrXvGJ-qabgQj5hG8beFtHNbVZ-XUxETVwduJYz94UYuJGAPxBrbGeZpSClUtXYsPJBABfr03KM=@protonmail.com>
References: <82d90d57-ad07-fc7d-4aca-2b227ac2068d@riseup.net>
 <CAPv7TjY9h8n-nK_CPiYCWYDcbXpT1gfRMQDgf9VUkcR532rxOw@mail.gmail.com>
 <VxL93WE7bDrK1riquTWTTEgJj9mDQ4W5CuhOgdnnDPeidw2ho6evVh4cLZLz0jEYMqejaD1tiLULVTXkNRbI5A7wSwV49qSwnXcTWCDJ96E=@protonmail.com>
 <cbf78f63-cf8c-c5d8-06ea-afc79aabc23c@riseup.net>
 <5LiZqpFxklAAbGFiiAE3ijRbIteODXKcHrXvGJ-qabgQj5hG8beFtHNbVZ-XUxETVwduJYz94UYuJGAPxBrbGeZpSClUtXYsPJBABfr03KM=@protonmail.com>
Message-ID: <e724b4c5-9efd-66c4-163b-492f17cafd7d@riseup.net>

Good day ZmnSCPxj,

>>> But S6 has the mild advantage that all the funding transactions paying to 2-of-2s can appear on the same block, whereas chaining swaps will have a particular order of when the transactions appear onchain, which might be used to derive the order of swaps.
>>
>> On the other hand, funds claiming in S6 is also ordered in time, so
>> someone paying attention to the mempool could guess as well the order of
>> swaps.
>>
>> I think this is wrong, and that it's possible for the funding
>> transactions of chained/routed swaps to all be in the same block as well.
>>
>> In CoinSwap it's possible to get DOS'd without the other side spending
>> money if you broadcast your funding transaction first and the other side
>> simply disappears. You'd get your money back but you have to waste time
>> and spend miner fees. The other side didn't spend money to do this, not
>> even miner fees.
>>
>> From the point of view of us as a maker in the route, we know we won't
>> get DOS'd like this for free if we only broadcast our funding
>> transaction once we've seen the other side's funding transaction being
>> broadcast first. This should work as long as the two transactions have a
>> similar fee rate. There might be an attack involving hash power: If the
>> other side has a small amount of hash power and mines only their funding
>> transaction in a manner similar to a finney attack, then our funding
>> transaction should get mined very soon afterwards by another miner and
>> the protocol will continue as normal. If the other side has knowledge of
>> the preimage and uses it to do CPFP and take the money, then we can
>> learn that preimage and do our own CPFP to get our money back too.
> 
> How about RBF?
> 
> A taker Alice can broadcast the funding tx spending its own funds.
> The funding tx spends funds controlled unilaterally by Alice.
> Alice can sign a replacement transaction for those funds, spending them to an address with unilateral control, and making the funding tx output with all the obligations attached never get confirmed in the first place.
> 
> The chances may be small --- Bob can certainly monitor for Alice broadcasting a replacement and counter-broadcast its own replacement --- but the risk still exists.
> TANSTAAGM (There Aint No Such Thing As A Global Mempool) also means Alice could arrange the replacement by other means, such as not using the RBF-enabled flag, broadcasting the self-paying replacement near miner nodes, and broadcasting the CoinSwap-expected funding tx near the Bob fullnode; Bob fullnode will then reject attempts to replace it, but miners will also reject the CoinSwap-expected funding tx and it will not confirm anyway.
> 
> 
> With the pre-SAS 4-tx setup, this potentially allows Alice to steal the funds of Bob; after Alice gets its funding-tx-replacement confirmed together with the Bob honest-funding-tx, Alice can use the contract transaction and publish the preimage to take the Bob funds.
> Since the Alice-side funding tx has been replaced, knowledge of the hash preimage will not help Bob any: the Alice funding tx has been replaced and Bob cannot use the preimage to claim it (it does not exist).
> 
> 
> With SAS Alice cannot outright steal the Bob funds, but the Bob funds will now be locked in a 2-of-2 and Alice can take it hostage (either Bob gives up on the funds, i.e. donates its value to all HODLers, or Bob gives most of the value to Alice).
> 
> 
> For the avoidance of theft, it is probably better for Bob to wait for Alice-side funding tx to confirm, probably deeply because reorgs suck.
> 
> This at least makes it costly to perform this attack; you have to lock more of your funds longer in order to induce a competitor to lock its funds.
> 
> 
> Come to think of it, the same issue probably holds for S6 as well, the funding tx with the longest timelock has to confirm first before the next is even broadcast, bleah.

Your RBF observation actually blows my idea out of the water. Not just
because of RBF but because of an attack by a miner.

Supposing that Alice starts with knowledge of the hash preimage, if she
uses RBF to make her funding transaction never confirm but allows Bob's
funding transaction to confirm, then Alice can use her preimage to take
the money from Bob's funding transaction. Bob will learn the value of
the preimage but it won't be much good to him because Alice's funding
transaction isn't valid anymore. Alice will get money from her funding
transaction and also money from Bob's funding transaction.

Because of this attack, it's pretty clear that a CoinSwap peer who
starts _without_ knowledge of the preimage must wait for the other
side's funding transaction to actually confirm, perhaps even with
multiple confirmations if they fear that the other side has access to
hashpower. For example, a miner could play the role of Alice and use
this attack to almost-risklessly steal Bob's coins using a finney attack.

That also seems to mean that a N-party routed CoinSwap requires at least
N blocks to be mined for all the funding transactions to be mined, which
is a slight setback for user experience. (Although even with today's
existing privacy tech, users must hang around waiting for coinjoins to
be signed, or waiting for multiple coinjoins to be confirmed.
Blockchains are inherently slow and we can't get around that.)


>>> For the avoidance of theft, it is probably better for Bob to wait for Alice-side funding tx to confirm, probably deeply because reorgs suck.
> 
> I realized that the *other* improvement I proposed in the [CoinSwapCS issue](https://github.com/AdamISZ/CoinSwapCS/issues/53) would help with this.
> Specifically, `nLockTime`-protected Backouts.
> 
> Suppose we have an S6 route as so, with Alice as taker and Bob1 and Bob2 as makers:
> 
>     Alice -> Bob1 -> Bob2 -> Alice
> 
> We assume here that Bob1 and Bob2 directly talk to Alice and that if Bob1 wants to talk to Bob2 it is done via Alice, so in the below if we say "Bob1 sends to Bob2" we imply that this is done via Alice.
> 
> 1.  Alice solicits fresh pubkeys from Bob1 and Bob2.
> 2.  Alice gives timeouts L1 and L2 to Bob1, and L2 and L3 to Bob2, such that L1 > L2 > L3, as well as negotiated amount, fees, etc.
> 3.  Alice creates (but does NOT sign) a funding tx paying to Alice && Bob1 and gives the txid to Bob1.
> 4.  Bob1 creates and signs a tx spending from the Alice funding tx and paying to Alice, with `nLockTime = L1`, and gives the signature to Alice.
> 5.  Bob1 creates (but does NOT sign) a funding tx paying to Bob1 && Bob2 and gives the txid to Bob2.
> 6.  Bob2 creates and signs a tx spending from the Bob1 funding tx and paying to Bob1, with `nLockTime = L2`, and gives the signature to Bob1.
> 7.  Bob2 creates (but does NOT sign) a funding tx paying to Bob2 && Alice and gives the txid to Alice.
> 8.  Alice creates and signs a tx spending from the Bob2 funding tx and paying to Bob2, with `nLockTime = L3`, and gives the signature to Bob2.
> 9.  Alice signals everyone to sign their respecting funding txes and broadcast them.
> 
> The rest of the CoinSwap protocol executes as normal once the funding txes are deeply confirmed.
> The only thing that Bob1 (resp. Bob2) needs to wait for is that the signatures for the incoming HTLC / PTLC have been received before forwarding to the next hop.
> This allows all funding txes to be confirmed in the same block, or even in some suitable random order (by having Alice send the signal out at different times/blocks to different makers).
> 
> The `nLockTime`d backout transactions are sufficient to allow everyone to recover their funds unilaterally in case one of the other funding txes do not confirm.
> 
> A similar technique can be done for SAS as well, but this removes the lack of encumbrance in the LTC-side output of SAS, which removes the advantage of having an otherwise unencumbered output.
> 
> In effect, the above creates Spilman unidirectional payment channels along the route, bringing the fiddly timing details offchain where it is less visible to observers.

I think I'm having trouble understanding this, does it work like this:

Say we're in the 2-party coinswap case (Alice and Bob)

We have Alice's funding transaction:
   Alice UTXO ---> 2of2 multisig (Alice+Bob)

And we have the regular contract transaction
   2of2 multisig (Alice+Bob) ---> Alice+timelock1 OR Bob+hashlock

And you propose a second pre-signed transaction?
   2of2 multisig (Alice+Bob) ---> Bob+timelock2

Where timelock2 > timelock1

If that's the protocol, then it's vulnerable to an attack. Once the
preimage is revealed we should be in a situation where Bob can
unilaterally get his coins back by broadcasting the regular contract
transaction and using the preimage to immediately get his coins. That
means Alice will be happy to hand over her private key, just to save
miner fees and improve privacy. But if the second pre-signed transaction
exists then Alice could do an attack where she broadcasts it and gets it
mined (perhaps more successfully if she has some hashpower). Once it's
mined then the regular contract transaction becomes invalid and Bob
can't get his money, in other words Bob doesn't have unilateral control
over those coins.


From ZmnSCPxj at protonmail.com  Sat Jun  6 01:40:18 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 06 Jun 2020 01:40:18 +0000
Subject: [bitcoin-dev] Design for a CoinSwap implementation for
	massively improving Bitcoin privacy and fungibility
In-Reply-To: <e724b4c5-9efd-66c4-163b-492f17cafd7d@riseup.net>
References: <82d90d57-ad07-fc7d-4aca-2b227ac2068d@riseup.net>
 <CAPv7TjY9h8n-nK_CPiYCWYDcbXpT1gfRMQDgf9VUkcR532rxOw@mail.gmail.com>
 <VxL93WE7bDrK1riquTWTTEgJj9mDQ4W5CuhOgdnnDPeidw2ho6evVh4cLZLz0jEYMqejaD1tiLULVTXkNRbI5A7wSwV49qSwnXcTWCDJ96E=@protonmail.com>
 <cbf78f63-cf8c-c5d8-06ea-afc79aabc23c@riseup.net>
 <5LiZqpFxklAAbGFiiAE3ijRbIteODXKcHrXvGJ-qabgQj5hG8beFtHNbVZ-XUxETVwduJYz94UYuJGAPxBrbGeZpSClUtXYsPJBABfr03KM=@protonmail.com>
 <e724b4c5-9efd-66c4-163b-492f17cafd7d@riseup.net>
Message-ID: <Sy14DpcFGdAYL95d7e6tfkOe87oY53tJReo9CYvPT5J3Gb85AqedMheq1NbfVKUXZtZrwZqwVV4wSztikgWBAgNfTh8J5h5gXC6HDMxvsNg=@protonmail.com>

Good morning Chris,

> I think I'm having trouble understanding this, does it work like this:
>
> Say we're in the 2-party coinswap case (Alice and Bob)
>
> We have Alice's funding transaction:
> Alice UTXO ---> 2of2 multisig (Alice+Bob)
>
> And we have the regular contract transaction
> 2of2 multisig (Alice+Bob) ---> Alice+timelock1 OR Bob+hashlock
>
> And you propose a second pre-signed transaction?
> 2of2 multisig (Alice+Bob) ---> Bob+timelock2

No, it is:

2of2 multisig (Alice+Bob) --(nLockTime=locktime1)-> Alice

The timelock is  imposed as a `nLockTime`, not as an `OP_CLTV` (so not in the output of the tx, but part of the tx), and the backout returns the funds to Alice, not sends it to Bob.
This transaction is created *before* the contract transaction.

The order is:

* Create (but not sign) Alice funding tx (Alice --> Alice+Bob).
* Create and sign Alice backout transaction (Alice+Bob -(nLockTime=locktime1)-> Alice).
* Create (but not sign) Bob funding tx (Bob --> Alice+Bob+sharedSecret).
* Create and sign Bob backout transaction (Alice+Bob+sharedSecret -(nLocktime=locktime2)-> Bob) where timelock2 < timelock1.
* Sign and broadcast funding txes.
  * At this point, even if Bob funding tx is confirmed but Alice funding tx is not, Bob can recover funds with the backout, but Alice cannot steal the funds (since there is no hashlock branch at this point).
* When Alice funding tx is confirmed, create and sign contract transaction (Alice+Bob --> Alice+timelock1 OR Bob+hashlock).
* When Bob funding tx is confirmed and Bob has received the Alice contract transaction, create and sign Bob contract transaction (Alice+Bob+sharedSecret --> Bob+timelock2 OR Alice+hashlock).
* Continue as normal.

In effect, the backout transaction creates a temporary Spilman unidirectional time-bound channel.
We just reuse the same timelock on the HTLC we expect to instantiate, as the time bound of the Spilman channel; the timelock exists anyway, we might as well reuse it for the Spilman.

Creation of the contract tx invalidates the backout tx (the backout tx is `nLockTime`d, the contract tx has no such encumbrance), but the backout allows Alice and Bob to fund their txes simultaneously without risk of race loss.
However, they do still have to wait for (deep) confirmation before signing contract transactions, and Bob has to wait for the incoming contract transaction as well before it signs its outgoing contract transaction.

The protocol is trivially extendable with more than one Bob.

The insight basically is that we can split CoinSwap into a "channel establishment" phase and "HTLC forwarding" phase followed by "HTLC resolution" and "private key handover".
HTLC forwarding and HTLC resolution are "done offchain" in the channels, and channel establishment can be done in any order, including reverse.

Indeed, the Spilman channel need not have the same timelock as the HTLC it will eventually host: it could have a shorter timelock, since the contract transaction has no `nLockTime` it can be instantiated (with loss of privacy due to the nonstandard script) before the Spilman timeout.

Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Sat Jun  6 03:59:30 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 06 Jun 2020 03:59:30 +0000
Subject: [bitcoin-dev] Design for a CoinSwap implementation for
	massively improving Bitcoin privacy and fungibility
In-Reply-To: <Sy14DpcFGdAYL95d7e6tfkOe87oY53tJReo9CYvPT5J3Gb85AqedMheq1NbfVKUXZtZrwZqwVV4wSztikgWBAgNfTh8J5h5gXC6HDMxvsNg=@protonmail.com>
References: <82d90d57-ad07-fc7d-4aca-2b227ac2068d@riseup.net>
 <CAPv7TjY9h8n-nK_CPiYCWYDcbXpT1gfRMQDgf9VUkcR532rxOw@mail.gmail.com>
 <VxL93WE7bDrK1riquTWTTEgJj9mDQ4W5CuhOgdnnDPeidw2ho6evVh4cLZLz0jEYMqejaD1tiLULVTXkNRbI5A7wSwV49qSwnXcTWCDJ96E=@protonmail.com>
 <cbf78f63-cf8c-c5d8-06ea-afc79aabc23c@riseup.net>
 <5LiZqpFxklAAbGFiiAE3ijRbIteODXKcHrXvGJ-qabgQj5hG8beFtHNbVZ-XUxETVwduJYz94UYuJGAPxBrbGeZpSClUtXYsPJBABfr03KM=@protonmail.com>
 <e724b4c5-9efd-66c4-163b-492f17cafd7d@riseup.net>
 <Sy14DpcFGdAYL95d7e6tfkOe87oY53tJReo9CYvPT5J3Gb85AqedMheq1NbfVKUXZtZrwZqwVV4wSztikgWBAgNfTh8J5h5gXC6HDMxvsNg=@protonmail.com>
Message-ID: <xNdzEDklg3DOAHpaOhPlacvkhr6Nfk6-oR6YAbqsMJiYc2QM837LAgwXpuIqyy6M6mZyk2zcZQqUWTlYky6MoAG_0ecupIygmSGDHuppa_4=@protonmail.com>

Good morning again Chris,

I am uncertain if you are aware, but some years ago somebody claimed that 2p-ECDSA could use Scriptless Script as well over on lightning-dev.

* https://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180426/fe978423/attachment-0001.pdf
* https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-April/001221.html

I cannot claim to follow the math enough to say it is actually secure, but the idea does exist.

If this is sufficiently secure, we can fold the Spilman backout into the scriptless script swap as well.

* Alice creates secret keypairs A[0] = a[0] * G, A[1] = a[1] * G
* Bob creates secret keypairs B[0] = b[0] * G, B[1] = b[1] * G
* Alice creates (but does not sign) funding from Alice -> A[0] && B[0]
* Bob provides partial signature for A[0] && B[0] -(nLockTime=locktime1)-> Alice to Alice and Alice completes this signature and stashes it.
* Bob creates (but does not sign) funding from Bob -> A[1] && B[1]
* Alice provides partial signature for A[1] && B[1] -(nLockTime=lockTime2)-> Bob to Bob and Bob completes this signature and stashes it.
* Alice and Bob sign and broadcast their funding transactions.
  * This can safely be done in any order; Bob will refuse to continue with the protocol until it sees Alice funding is confirmed, and will abort if locktime2 is too near.
* Alice waits for Bob funding tx to confirm.
* Alice provides a 2p-ECDSA adaptor signature for A[1] && B[1] --> Alice; the adaptor signature, when completed, reveals the secret a[0] to Bob.
* Bob waits for Alice funding tx to confirm.
* Bob provides the partial signature for the given adaptor signature for A[1] && B[1] --> Alice and  Alice completes this signature and stashes it.
* Alice gives a[0] outright to Bob.
* Bob gives b[1] outright to Alice.
* Alice spends the A[1] && B[1] output before locktime2.
* Bob spends the A[0] && B[0] output before locktime1.

I also pointed out the griefing problem in Lightning also applies to SwapMarket.
Bob can limit the griefing problem by requiring that locktime2 <= now + 12, and requiring that locktime1 >= now + 60.
This means that Alice has to lock its funds for 10 hours if it forces Bob to lock its funds for 2 hours, making it undesirable as an attack on competing makers.
This does prevent chaining (no maker is going to accept the outgoing), but if Alice wants chaining it can always use the private key handed over to immediately start a funding tx with another Bob.

(This is not a good solution for griefing in the Lightning Network since channels are intended to be reused there, whereas the Spilman channels in CoinSwap exist only to allow funding transactions to confirm in any order onchain, and are used only for the specific swap; in Lightning the forwarding node has an incentive to release the incoming HTLC immediately instead of imposing the incoming wait time since the funding can be reused for a different payment, but in CoinSwap it cannot be reused anyway, so it could just let the incoming timelock lapse instead of releasing that encumbrance as would be done in Lightning.)

Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Sat Jun  6 04:25:11 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 06 Jun 2020 04:25:11 +0000
Subject: [bitcoin-dev] Design for a CoinSwap implementation for
	massively improving Bitcoin privacy and fungibility
In-Reply-To: <xNdzEDklg3DOAHpaOhPlacvkhr6Nfk6-oR6YAbqsMJiYc2QM837LAgwXpuIqyy6M6mZyk2zcZQqUWTlYky6MoAG_0ecupIygmSGDHuppa_4=@protonmail.com>
References: <82d90d57-ad07-fc7d-4aca-2b227ac2068d@riseup.net>
 <CAPv7TjY9h8n-nK_CPiYCWYDcbXpT1gfRMQDgf9VUkcR532rxOw@mail.gmail.com>
 <VxL93WE7bDrK1riquTWTTEgJj9mDQ4W5CuhOgdnnDPeidw2ho6evVh4cLZLz0jEYMqejaD1tiLULVTXkNRbI5A7wSwV49qSwnXcTWCDJ96E=@protonmail.com>
 <cbf78f63-cf8c-c5d8-06ea-afc79aabc23c@riseup.net>
 <5LiZqpFxklAAbGFiiAE3ijRbIteODXKcHrXvGJ-qabgQj5hG8beFtHNbVZ-XUxETVwduJYz94UYuJGAPxBrbGeZpSClUtXYsPJBABfr03KM=@protonmail.com>
 <e724b4c5-9efd-66c4-163b-492f17cafd7d@riseup.net>
 <Sy14DpcFGdAYL95d7e6tfkOe87oY53tJReo9CYvPT5J3Gb85AqedMheq1NbfVKUXZtZrwZqwVV4wSztikgWBAgNfTh8J5h5gXC6HDMxvsNg=@protonmail.com>
 <xNdzEDklg3DOAHpaOhPlacvkhr6Nfk6-oR6YAbqsMJiYc2QM837LAgwXpuIqyy6M6mZyk2zcZQqUWTlYky6MoAG_0ecupIygmSGDHuppa_4=@protonmail.com>
Message-ID: <vhscPyFtc4oFhH00vCo8SZTJqUzET3Pv5F0O2rPOiEcCIVfA1Xa-Ea1cSCWzSiLxkEOcYGsSWdGl9yycfRvGZlM2KoPomsSQ0PH3--c9YBQ=@protonmail.com>

Good morning a third time Chris,

Now unrelated to the funding order, but one of the reasons why timeliness is desirable for CoinSwap is that if possible, we want to ensure that sends from a user wallet are not correlatable with receives into that wallet.
Thus, there is the strong suggestion that before sending to a payee, the user wallet should swap, then use the swapped funds to pay the payee, i.e. swap-on-pay.
JoinMarket does this in `sendpayment.py`, for example, and this is the recommended way to perform payments out of the JoinMarket wallet.

Let me propose an alternative: swap-on-receive+swap-on-change.

ZeroLink already suggests that wallets maintain two internal wallets: a pre-mix wallet and a post-mix wallet.
With swap-on-receive, when the user wants a receive address, the wallet gets it from the pre-mix wallet address.
Then, when wallet notices any unspent funds on any pre-mix wallet address, the wallet automatically swaps it into the post-mix wallet.
This is swap-on-receive.
Long-term HODLing goes into post-mix wallet addresses.

Then, when sending, the wallet selects from the post-mix wallet coins, and spends those coins directly into the payee address.
If there is no exact amount, it has to have change.
The change output does *not* go to the pre-mix or post-mix wallet address.
Instead, it goes to a 2-of-2 funding outpoint for a new swap immediately.

This lets the payee receive its funds quickly, as soon as the transaction confirms, without waiting for the CoinSwap to complete.
Of course, the user now has to be online to *fully* receive funds (the user cannot spend the funds until it is in the post-mix wallet).

Regards,
ZmnSCPxj

From mostafa.sedaghat at gmail.com  Fri Jun  5 12:05:20 2020
From: mostafa.sedaghat at gmail.com (Mostafa Sedaghat joo)
Date: Fri, 5 Jun 2020 20:05:20 +0800
Subject: [bitcoin-dev] Stamping transaction
Message-ID: <CAJr8eKuFv7R-1HRft-hLFTSdpWUL2uOtkDtisL2+iPaEvvH_hA@mail.gmail.com>

Hi

*stamping transactions* is as simple idea but has huge impact.
Simply, stamping transaction means putting previous block hash in the
header of the transaction. With this simple technique we can *decouple
*translation from
the block.
I have described my idea here:
https://b00f.github.io/blockchain/stamping_transactions


I know bitcoin developers tends to not change the core, but you can
consider it for next big change.


Regards,
Mostafa
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200605/ad4114d1/attachment.html>

From ZmnSCPxj at protonmail.com  Sun Jun  7 00:40:51 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sun, 07 Jun 2020 00:40:51 +0000
Subject: [bitcoin-dev] Stamping transaction
In-Reply-To: <CAJr8eKuFv7R-1HRft-hLFTSdpWUL2uOtkDtisL2+iPaEvvH_hA@mail.gmail.com>
References: <CAJr8eKuFv7R-1HRft-hLFTSdpWUL2uOtkDtisL2+iPaEvvH_hA@mail.gmail.com>
Message-ID: <c_8uFmqhKnoFYLB23sjYhJlKAXU5ZoCSQ2MsSgn_OePQoJKFOqIuzMjm7vhnCzevQkAwdJextCeNjA8D-f_p__-sUFSkOFMDI5_yS7k8ZM8=@protonmail.com>

Good morning Mostafa,

First off, the proposed mechanism can be made into a softfork by using an unspendable `scriptPubKey` with 0 output value.

For example, a stamp could by convention be any 0-value output whose `scriptPubKey` is `<blockhash> OP_0`, which should be unspendable.

Post-softfork nodes would reject blocks where some transaction is stamped and the stamped `<blockhash>` is not within the last N blocks.
Pre-softfork nodes would not see anything special about the unspendable `scriptPubKey` and would just accept it (but would not relay such transactions due to standardness).

Engineering-wise, block validation now needs to memorize the last N block hashes.

The mempool design currently assumes that a transaction that enters the mempool is always valid unless any UTXOs it spends have been removed.
This is important since miner block selection algorithms assume the mempool contains transactions that are currently valid.
Thus, there is the additional need to drop transactions from the mempool if they are stamped with a block that has dropped from the stamp TTL.

Another issue is incentives.
The stamp takes up blockchain space that is paid for by the creator of the transaction.
Further, the creator of the transaction gains no advantage from the stamped transaction; it is others who gain an advantage (the stamped transaction is more likely to be dropped from the mempool).
Discounting the stamp somehow will probably make this into a hardfork.
It might be sneaked into the witness somehow by adding it as a field somewhere in the new parts of Taproot (there is, a new block of data in Taproot that can be used for this), but note that the cost will still be non-zero (and users of this feature will still have a disadvantage in that their transactions are more likely to be dropped from the mempool).

Finally, it is expected to increase bandwidth use since a dropped stamped transaction will probably be rebroadcast with a new stamp, so effectively the transaction is retransmitted again with a different stamp.


Regards,
ZmnSCPxj

From mostafa.sedaghat at gmail.com  Sun Jun  7 07:27:48 2020
From: mostafa.sedaghat at gmail.com (Mostafa Sedaghat joo)
Date: Sun, 7 Jun 2020 15:27:48 +0800
Subject: [bitcoin-dev] Stamping transaction
In-Reply-To: <c_8uFmqhKnoFYLB23sjYhJlKAXU5ZoCSQ2MsSgn_OePQoJKFOqIuzMjm7vhnCzevQkAwdJextCeNjA8D-f_p__-sUFSkOFMDI5_yS7k8ZM8=@protonmail.com>
References: <CAJr8eKuFv7R-1HRft-hLFTSdpWUL2uOtkDtisL2+iPaEvvH_hA@mail.gmail.com>
 <c_8uFmqhKnoFYLB23sjYhJlKAXU5ZoCSQ2MsSgn_OePQoJKFOqIuzMjm7vhnCzevQkAwdJextCeNjA8D-f_p__-sUFSkOFMDI5_yS7k8ZM8=@protonmail.com>
Message-ID: <CAJr8eKtV=W8wLkZZP9tagnL8F3jxOv8t-J9oBCFV6MrRPDmGiw@mail.gmail.com>

Good day ZmnSCPxj

Thank you so much for your time to read my proposal.
About your comments, I do agree with some of them but maybe we need to
discuss more about them.
You might agree that any changes (especially a fundamental change like
stamping transactions) comes with advantages and probably some
disadvantages. I believe the advantages of stamping transactions are worth
having it.


*The main point of stamping transactions is decoupling transactions from
the block. *

*Blockchain size matters*
SegWit is a good witness that shows blockchain size matters. Nowadays, Data
storage is cheap and easy, but that doesn't mean it's a simple matter. If
you need to have a data-center to keep a copy of a blockchain, then you are
far from a decentralization system.

*A Solution*
Stamping transaction is a simple idea to keep the size of the blockchain as
small as possible. The question that I was looking to answer is how we can
decouple the transaction from the blocks.
Who cares about the transaction that happened 10 years ago. In the real
world you may go to your bank and ask them to give you transaction history.
But they probably have limits. They might say we just only keep the last 3
months in our system.

*Implementation*

> First off, the proposed mechanism can be made into a softfork by using an
unspendable `scriptPubKey` with 0 output value.
SoftFork is not possible here. Because the transaction will not be saved
inside the block (only tx hashes). Block format needs to be changed.
Therefore the block will be invalid.

> Engineering-wise, block validation now needs to memorize the last N block
hashes.
I don't think we need to memorize the last N block hashes.  We can have
something like:
```
Current_Height - Height_Of(tx.stamp) <= N
```
*Incentives*
I think Stamping transactions have nothing to do with the
incentivization mechanism.  Forgive me if I couldn't get your point.

*Mempool*
It's bad of me that I don't really know how mempool works in Bitcoin. My
assumption is that there are some junk transactions (transactions that are
valid but have very low or zero fees) inside the mempool. Stamping
transactions might help to get rid of them time to time.

Best Regards,
Mostafa


On Sun, Jun 7, 2020 at 8:40 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Mostafa,
>
> First off, the proposed mechanism can be made into a softfork by using an
> unspendable `scriptPubKey` with 0 output value.
>
> For example, a stamp could by convention be any 0-value output whose
> `scriptPubKey` is `<blockhash> OP_0`, which should be unspendable.
>
> Post-softfork nodes would reject blocks where some transaction is stamped
> and the stamped `<blockhash>` is not within the last N blocks.
> Pre-softfork nodes would not see anything special about the unspendable
> `scriptPubKey` and would just accept it (but would not relay such
> transactions due to standardness).
>
> Engineering-wise, block validation now needs to memorize the last N block
> hashes.
>
> The mempool design currently assumes that a transaction that enters the
> mempool is always valid unless any UTXOs it spends have been removed.
> This is important since miner block selection algorithms assume the
> mempool contains transactions that are currently valid.
> Thus, there is the additional need to drop transactions from the mempool
> if they are stamped with a block that has dropped from the stamp TTL.
>
> Another issue is incentives.
> The stamp takes up blockchain space that is paid for by the creator of the
> transaction.
> Further, the creator of the transaction gains no advantage from the
> stamped transaction; it is others who gain an advantage (the stamped
> transaction is more likely to be dropped from the mempool).
> Discounting the stamp somehow will probably make this into a hardfork.
> It might be sneaked into the witness somehow by adding it as a field
> somewhere in the new parts of Taproot (there is, a new block of data in
> Taproot that can be used for this), but note that the cost will still be
> non-zero (and users of this feature will still have a disadvantage in that
> their transactions are more likely to be dropped from the mempool).
>
> Finally, it is expected to increase bandwidth use since a dropped stamped
> transaction will probably be rebroadcast with a new stamp, so effectively
> the transaction is retransmitted again with a different stamp.
>
>
> Regards,
> ZmnSCPxj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200607/d226099f/attachment.html>

From ZmnSCPxj at protonmail.com  Sun Jun  7 15:01:42 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sun, 07 Jun 2020 15:01:42 +0000
Subject: [bitcoin-dev] Stamping transaction
In-Reply-To: <CAJr8eKtV=W8wLkZZP9tagnL8F3jxOv8t-J9oBCFV6MrRPDmGiw@mail.gmail.com>
References: <CAJr8eKuFv7R-1HRft-hLFTSdpWUL2uOtkDtisL2+iPaEvvH_hA@mail.gmail.com>
 <c_8uFmqhKnoFYLB23sjYhJlKAXU5ZoCSQ2MsSgn_OePQoJKFOqIuzMjm7vhnCzevQkAwdJextCeNjA8D-f_p__-sUFSkOFMDI5_yS7k8ZM8=@protonmail.com>
 <CAJr8eKtV=W8wLkZZP9tagnL8F3jxOv8t-J9oBCFV6MrRPDmGiw@mail.gmail.com>
Message-ID: <gNdtY-_W10fFe8vwyhQNUOCIWCtBj0G9LLUu5GQ7PYlRXejM1jwIX__TMYUhq6DDczOTQ3YYgVACOBSv6yIqx5nZ5vRbXkXPn-yjsOqi52w=@protonmail.com>

Good morning Mostafa,


> The main point of stamping transactions is decoupling transactions from the block.?
>
> Blockchain size matters
> SegWit is a good witness that shows blockchain size matters. Nowadays,?Data storage is cheap and easy, but that doesn't mean it's a simple matter. If you need to have a data-center to keep a copy of a blockchain, then you are far from a decentralization system.?
>
> A Solution
> Stamping?transaction is a simple idea to keep the size of the blockchain as small as possible. The question that I was looking to answer is how we can decouple the transaction from the blocks.
> Who cares about the transaction that happened?10 years ago. In the real world you may go to your bank and ask them to give you transaction?history. But they probably have limits. They might say we just only keep the last 3 months in our system.?

Stamping transaction is not how you would be able to keep **blockchain** size low.

The reason why very old history is retained is that, if a new node is brought up, you need to prove to that node that you are in fact the correct owner of the current coins.
Thus the entire history of Bitcoin is needed when starting a new node, and why archive nodes exist.

You might argue that banks do not do that, and that is because we want to do better than banks; we know that existing currency systems have not only the "official" minter, but also many "unofficial" minters (commonly called counterfeiters) which dilute the value of the currency.
It is this insistence on a full accounting of the provenance for every satoshi that separates Bitcoin from previous currency systems; bank fraud exists, and it hides in such sloppy techniques as deleting old transaction records.

Work has been done to have client-side validation (i.e. the owner of a coin keeps the entire history, and when paying, you hand over the entire history of your coin to the payee, instead of everyone validating every transaction).
Look up Peter Todd for some initial work on this.


> Implementation
>
> > First off, the proposed mechanism can be made into a softfork by using an unspendable `scriptPubKey` with 0 output value.
> SoftFork is not possible here. Because the transaction will not be saved inside the block (only tx hashes). Block format needs to be changed. Therefore the block will be invalid.

That greatly reduces the chances your proposal will get into Bitcoin; you would need to have very good advantages to counterbalance the tremendous risk that hardforks introduce in the continuity of the coin.

Bitcoin has never gone through a hardfork that has not instead created a new cryptocurrency, so any solution that requires a hardfork is going to be unlikely to be accepted by everyone.

> >?Engineering-wise, block validation now needs to memorize the last N block hashes.
> I don't think we need to memorize the last N block hashes.? We can have something like:
> ```
> Current_Height - Height_Of(tx.stamp) <= N?
> ```

...


`Height_Of()` would basically be a mapping from block hashes to block heights, with the number of elements equal to the height of the blockchain, and thus continuously growing.
Thus, validation is expected to become more expensive as the blockchain grows.

Since stamped transactions have a time-to-live anyway, instead you can use a *set* of the most recent N block hashes.
Then you simply check if the stamp is in the set.
This creates a data structure that is constant in size (at each block, you remove the block from N blocks ago), which is good for validation.

> Incentives
> I think Stamping transactions have nothing to do with the incentivization?mechanism.? Forgive me if I couldn't get your point.

A stamped tranasction has a stamp, an unstamped transaction has no stamp.
The stamped transaction is larger because of the stamp.
Larger transactions are more expensive because fees.

Thus, stamped transactions are more expensive than unstamped transactions.

Convince me why I would make *my* transaction stamped when I can just convince *everyone else* to stamp *their* transactions and use unstamped transactions myself.

If you propose that all transactions must be stamped in a new version of Bitcoin, then take note that users will prefer to run older versions and never upgrade to the new version that requires stamped transactions.
Why should users prefer a more expensive transaction format?
For the good of the network?
That is precisely an incentives problem: if it is so good for the network, then it should be good for an individual user, because the network is made up of individual users anyway; if individual users are not incentivized to use it, then that fact suggests it might not be as good for the network as you might think.

If you answer "the stamp can be discounted" then be aware that validating the stamp is still a cost on every node, and it is that cost that we want to be reflected in pricing every byte in the transaction.
For instance, UTXOs are retained, potentially indefinitely, and the UTXO lookup structure has to be very fast and is referred to at every transaction validation, so outputs (which create new UTXO entries) in SegWit are 4x more expensive than signatures, since signatures are only validated once when the transaction is queued to be put in the mempool.


> Mempool
> It's bad of me that I don't really know how mempool works in Bitcoin. My assumption is that there are some junk transactions (transactions that are valid but have very low or zero fees) inside the mempool. Stamping transactions might help to get rid of them time to time.?

Why would you think that stamping reduces mempool size?

If I wanted to I could just re-send the transaction with a fresh stamp.
Then the mempool usage would still be the same, and bandwidth use will increase (because the same transaction is now re-broadcast with a fresh stamp, and the added size of the stamps themselves).


Regards,
ZmnSCPxj


From joachimstr at protonmail.com  Sun Jun  7 16:51:10 2020
From: joachimstr at protonmail.com (=?UTF-8?Q?Joachim_Str=C3=B6mbergson?=)
Date: Sun, 07 Jun 2020 16:51:10 +0000
Subject: [bitcoin-dev] BIP OP_CHECKTEMPLATEVERIFY
In-Reply-To: <CAD5xwhjXidpeLLUr4TO30t7U3z_zUxTpU9GBpLxu3MWX3ZFeTA@mail.gmail.com>
References: <CAD5xwhjXidpeLLUr4TO30t7U3z_zUxTpU9GBpLxu3MWX3ZFeTA@mail.gmail.com>
Message-ID: <1cQUGt1pX0_lWPJm-tFDr9fQCvrPd5vqmCorgN89jy7gUF0m9wsouUosrFm1eal3jO9oB1BvMtORGE2htLdFjyDD5lno_QkXCFn971LQNZY=@protonmail.com>

Hello everyone,

regarding OP_CTV, I am considering the scaling use case, specifically an exchange (or similar) who wants to batch pay to OP_CTV to many users, and I wonder

1) How do you expect the exchange to communicate the proof of the payment to the user wallets such that they are able to construct the follow up transactions and accept the payment. This is UI question. Do you expect exchanges to provide a certain importable file/blob that the wallet will allow you to entry?

2) Who pays the fees and how for the transaction within the structure that OP_CTVed output is committed to? Say there is a tree structure and I want to get the coin out. Someone needs to send log(N) transactions to the chain in order for me to get access to the final UTXO I am interested in. Who can construct such transaction path and what do they need for it and who pays fees on that (which input)?

3) Depending on 2) above, is it not possible for a malicious entity who is among the many users being paid, but who has very small UTXO there relative to others, to construct this middle transaction and use a very small fee rate in order to DoS other participants. Is it even possible for this attacker to create the middle transaction with RBF disabled?

Thank you,
Joachim

Sent with [ProtonMail](https://protonmail.com) Secure Email.

??????? Original Message ???????
On Tuesday, November 26, 2019 1:50 AM, Jeremy via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Bitcoin Developers,
>
> Pleased to announce refinements to the BIP draft for OP_CHECKTEMPLATEVERIFY (replaces previous OP_SECURETHEBAG BIP). Primarily:
>
> 1) Changed the name to something more fitting and acceptable to the community
> 2) Changed the opcode specification to use the argument off of the stack with a primitive constexpr/literal tracker rather than script lookahead
> 3) Permits future soft-fork updates to loosen or remove "constexpr" restrictions
> 4) More detailed comparison to alternatives in the BIP, and why OP_CHECKTEMPLATEVERIFY should be favored even if a future technique may make it semi-redundant.
>
> Please see:
> BIP:https://github.com/JeremyRubin/bips/blob/ctv/bip-ctv.mediawiki
> Reference Implementation:https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify
>
> I believe this addresses all outstanding feedback on the design of this opcode, unless there are any new concerns with these changes.
>
> I'm also planning to host a review workshop in Q1 2020, most likely in San Francisco. Please fill out the form here https://forms.gle/pkevHNj2pXH9MGee9 if you're interested in participating (even if you can't physically attend).
>
> And as a "but wait, there's more":
>
> 1) RPC functions are under preliminary development, to aid in testing and evaluation of OP_CHECKTEMPLATEVERIFY. The new command `sendmanycompacted` shows one way to use OP_CHECKTEMPLATEVERIFY. See: https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify-rpcs. `sendmanycompacted` is still under early design. Standard practices for using OP_CHECKTEMPLATEVERIFY & wallet behaviors may be codified into a separate BIP. This work generalizes even if an alternative strategy is used to achieve the scalability techniques of OP_CHECKTEMPLATEVERIFY.
> 2) Also under development are improvements to the mempool which will, in conjunction with improvements like package relay, help make it safe to lift some of the mempool's restrictions on longchains specifically for OP_CHECKTEMPLATEVERIFY output trees. See: https://github.com/bitcoin/bitcoin/pull/17268This work offers an improvement irrespective of OP_CHECKTEMPLATEVERIFY's fate.
>
> Neither of these are blockers for proceeding with the BIP, as they are ergonomics and usability improvements needed once/if the BIP is activated.
>
> See prior mailing list discussions here:
>
> * https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016934.html
> * https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016997.html
>
> Thanks to the many developers who have provided feedback on iterations of this design.
>
> Best,
>
> Jeremy
> --
> [@JeremyRubin](https://twitter.com/JeremyRubin)https://twitter.com/JeremyRubin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200607/a3fd0b6a/attachment-0001.html>

From jlrubin at mit.edu  Sun Jun  7 22:45:16 2020
From: jlrubin at mit.edu (Jeremy)
Date: Sun, 7 Jun 2020 15:45:16 -0700
Subject: [bitcoin-dev] BIP OP_CHECKTEMPLATEVERIFY
In-Reply-To: <1cQUGt1pX0_lWPJm-tFDr9fQCvrPd5vqmCorgN89jy7gUF0m9wsouUosrFm1eal3jO9oB1BvMtORGE2htLdFjyDD5lno_QkXCFn971LQNZY=@protonmail.com>
References: <CAD5xwhjXidpeLLUr4TO30t7U3z_zUxTpU9GBpLxu3MWX3ZFeTA@mail.gmail.com>
 <1cQUGt1pX0_lWPJm-tFDr9fQCvrPd5vqmCorgN89jy7gUF0m9wsouUosrFm1eal3jO9oB1BvMtORGE2htLdFjyDD5lno_QkXCFn971LQNZY=@protonmail.com>
Message-ID: <CAD5xwhhZyAkQE3DpLku_xrOnixL344AqkWB=+a=fOBbekobY6g@mail.gmail.com>

Hi Joachim,

Fantastic questions!

I think it makes sense to think about it in terms of today, and then in
terms of a long-dated future where wallets have much richer native
understandings of these things. This helps preserve the purity of the
arguments I'm making with respect to what it would look like today v.s.
what it could look like with strong integration.

Today:
1) I would expect that exchanges do this as a CTV txn that is one initial
confirmation to a single output, and then that output expands to either all
the payments in the batch, or to a histogram of single-layer CTVs based on
priority/amount being spent. E.g, either A -> B -> {C,D,E,F,G...} or
A->B->{C -> {D,E,F}, G -> {H, I J}, K -> ....}. I would further expect that
the entire tree would include fees such that it will get into at least the
bottom of the mempool. See https://utxos.org/analysis/batching_sim/ for
more info. If txns land in the mempool, then users learn about it (even
with an un-updated wallet) just like the learn of normal unconfirmed
transactions. Even this simple two-step transaction can deliver massive
batching savings. OpTech has some coverage of this simple
commit-now-distribute-later scheme here
https://bitcoinops.org/en/newsletters/2019/05/29/#proposed-new-opcode-for-transaction-output-commitments
.

I'd also expect that exchanges in particular already store their outbound
transactions in resilient storage (for audit and compliance as well as
liability protection), so they would likely be able to make this data
available to their customers on inquiry if discarded.

I'm all for redundancy, so exchanges can also e.g. send an email with a
backup file if they want to. But that's not necessary for it to work today,
you can just watch the mempool like wallets already do.

A slightly patched wallet can treat CTV outs as more confirmed (e.g., like
an own-change address) than a normal unconfirmed out.

2) I would expect that exchanges pay a reasonable amount of fees for the
transaction so it can expect to at least get to the bottom range of the
mempool for children, and top of the mempool for the parent. Your question
seems to be more about after this phase.

First I would note that it is truly O(log(N)), but E[O(1)], because it
amortizes. That is, to claim out all of the outputs is a total overhead of
O(N), not O(N log N). Fees in this model are paid by CPFP. Because CPFP is
currently *Child* pays for parent and not *Children* pay for parent, we
don't (unfortunately) have rational txn selection for this case. Any wallet
can construct this spend path by rebroadcasting (if evicted) the parents
and spending the txn. The exchange can also 'bound' themselves to seeing a
transaction to completion by including some change address at the leaf node
layer (not much overhead depending on radix).

Thus the payer of fees is the person who needs to spend.

3) Not exactly, the middle txns are immutable. but it may be possible to
construct a low-fee longchain which can cause transaction pinning. If you
do a shallow tree as described in (1), the current lightning carve should
help to prevent this.

Future:
1) Most likely the desirable radix for a tree is something like 4 or 5
which minimizes the amount of work on an individual basis (you can compute
this by figuring out how deep the tree would be and the per-tx overheads, 4
or 5 pop out as being minimal overhead and the benefit is recursive).
Mempool broadcast still should work, but it's possible that for privacy
reasons it's preferred to not broadcast through mempool. It's also possible
that all payouts are into non-interactive lightning channels with N-of-N
taproot at each layer, so you receive a proof through your lightning wallet
and can immediately route payments, and when you want to close
opportunistically cooperate to reduce chain overhead. You can think of CTV
as an anchor for bootstrapping these layer two protocols with an on-chain
bisection algorithm to discover online participants to re-negotiate with. A
privacy and scalability win!

I further expect business wallets (like exchanges) to be able to credit
deposits from CTV trees without requiring full expansion. This is also a
privacy win, and can decrease latency of moving large value funds (e.g.,
exceeding inter exchange channel balances) and crediting funds for trading.

2) I think we'll eventually converge on a non-destructive way of adding
fees. RBF is destructive in that you're replacing a TX. CPFP is destructive
in that you have a spend a coin to drive progress. Without a new opcode you
can emulate this with CTV by at nodes in the tree having a consumable
output that serves as a CPFP hook/a RBF hook. You can see some discussion
here (animated, so use pres mode)
https://docs.google.com/presentation/d/1XDiZOz52XyJc4LDSbiD9_JAaJobyF5QDGtR3O9qD7yg/edit#slide=id.g7d267915e2_0_44.
This adds some extra chain weight, but is possible without further
extension. What I think we'll eventually land on is a way of doing a tx
that contributes fee to another tx chain as a passive observer to them.
While this breaks one abstraction around how dependencies between
transactions are processed, it also could help resolve some really
difficult challenges we face with application-DoS (pinning and other
attacks) in the mempool beyond CTV. I have a napkin design for how this
could work, but nothing quite ready to share yet.

3) Hopefully 2 solves pinning :)
--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>


On Sun, Jun 7, 2020 at 9:51 AM Joachim Str?mbergson <
joachimstr at protonmail.com> wrote:

> Hello everyone,
>
> regarding OP_CTV, I am considering the scaling use case, specifically an
> exchange (or similar) who wants to batch pay to OP_CTV to many users, and I
> wonder
>
> 1) How do you expect the exchange to communicate the proof of the payment
> to the user wallets such that they are able to construct the follow up
> transactions and accept the payment. This is UI question. Do you expect
> exchanges to provide a certain importable file/blob that the wallet will
> allow you to entry?
>
> 2) Who pays the fees and how for the transaction within the structure that
> OP_CTVed output is committed to? Say there is a tree structure and I want
> to get the coin out. Someone needs to send log(N) transactions to the chain
> in order for me to get access to the final UTXO I am interested in. Who can
> construct such transaction path and what do they need for it and who pays
> fees on that (which input)?
>
> 3) Depending on 2) above, is it not possible for a malicious entity who is
> among the many users being paid, but who has very small UTXO there relative
> to others, to construct this middle transaction and use a very small fee
> rate in order to DoS other participants. Is it even possible for this
> attacker to create the middle transaction with RBF disabled?
>
> Thank you,
> Joachim
>
>
>
> Sent with ProtonMail <https://protonmail.com> Secure Email.
>
> ??????? Original Message ???????
> On Tuesday, November 26, 2019 1:50 AM, Jeremy via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Bitcoin Developers,
>
> Pleased to announce refinements to the BIP draft for
> OP_CHECKTEMPLATEVERIFY (replaces previous OP_SECURETHEBAG BIP). Primarily:
>
> 1) Changed the name to something more fitting and acceptable to the
> community
> 2) Changed the opcode specification to use the argument off of the stack
> with a primitive constexpr/literal tracker rather than script lookahead
> 3) Permits future soft-fork updates to loosen or remove "constexpr"
> restrictions
> 4) More detailed comparison to alternatives in the BIP, and why
> OP_CHECKTEMPLATEVERIFY should be favored even if a future technique may
> make it semi-redundant.
>
> Please see:
> BIP: https://github.com/JeremyRubin/bips/blob/ctv/bip-ctv.mediawiki
> Reference Implementation:
> https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify
>
> I believe this addresses all outstanding feedback on the design of this
> opcode, unless there are any new concerns with these changes.
>
> I'm also planning to host a review workshop in Q1 2020, most likely in San
> Francisco. Please fill out the form here
> https://forms.gle/pkevHNj2pXH9MGee9 if you're interested in participating
> (even if you can't physically attend).
>
> And as a "but wait, there's more":
>
> 1) RPC functions are under preliminary development, to aid in testing and
> evaluation of OP_CHECKTEMPLATEVERIFY. The new command `sendmanycompacted`
> shows one way to use OP_CHECKTEMPLATEVERIFY. See:
> https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify-rpcs.
> `sendmanycompacted` is still under early design. Standard practices for
> using OP_CHECKTEMPLATEVERIFY & wallet behaviors may be codified into a
> separate BIP. This work generalizes even if an alternative strategy is used
> to achieve the scalability techniques of OP_CHECKTEMPLATEVERIFY.
> 2) Also under development are improvements to the mempool which will, in
> conjunction with improvements like package relay, help make it safe to lift
> some of the mempool's restrictions on longchains specifically for
> OP_CHECKTEMPLATEVERIFY output trees. See: https://github.com/bitcoin/bitcoin/pull/17268
> This work offers an improvement irrespective of OP_CHECKTEMPLATEVERIFY's
> fate.
>
>
> Neither of these are blockers for proceeding with the BIP, as they are
> ergonomics and usability improvements needed once/if the BIP is activated.
>
> See prior mailing list discussions here:
>
> *
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016934.html
> *
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016997.html
>
>
> Thanks to the many developers who have provided feedback on iterations of
> this design.
>
> Best,
>
> Jeremy
> --
> @JeremyRubin <https://twitter.com/JeremyRubin>
> <https://twitter.com/JeremyRubin>
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200607/6a0f0136/attachment-0001.html>

From antoine.riard at gmail.com  Sun Jun  7 22:31:54 2020
From: antoine.riard at gmail.com (Antoine Riard)
Date: Sun, 7 Jun 2020 18:31:54 -0400
Subject: [bitcoin-dev] Time-dilation Attacks on the Lightning Network
In-Reply-To: <2phhD75B8ww3hFQ8Do039wAIlW8EVOjUeiedm-JtIek-TEnVocYSx-untchGrO3VoRLoPzinVAG95UN1yR3CadNWBJGSu19vJpFJ_yN-wZY=@protonmail.com>
References: <2e8fba65-f7fa-4c37-a318-222547e25a06@Spark>
 <9e4dfaa7-895a-48a1-8116-eaafc80da34f@Spark>
 <2phhD75B8ww3hFQ8Do039wAIlW8EVOjUeiedm-JtIek-TEnVocYSx-untchGrO3VoRLoPzinVAG95UN1yR3CadNWBJGSu19vJpFJ_yN-wZY=@protonmail.com>
Message-ID: <CALZpt+FF0e1wSY5mBY-rVLQu4EGAjQefK9EQDCiExqMvKVc5UQ@mail.gmail.com>

Hi ZmnSCPxj,

> (Of note as well, is that the onchain contract provided by such services
is the same in spirit as those instantiated in channels of the Lightning
Network, thus the same attack schema works on the onchain side.)

If you onchain contract uses a timelock and has concurrent transactions
arbiter by this one , it's subject to time-dilation attack. So yes
submarine swaps, or any kind of atomic swap is concerned. We note this in
discussion.
But you're right for the attack cost, you don't need a channel to these
services, which is also concerning for their attack surface.

> Since the issue here is that eclipsing of Bitcoin nodes is risky, it
strikes me that a mitigation would be to run your Bitcoin fullnode on
clearnet while running your Lightning node over Tor

We clearly mention that risk of running a Bitcoin node over Tor, where do
we recommend running a LN node over Tor ?

>   And this seems to tie with what you propose: that the LN node should
use a different view-fullnode from the broadcast-fullnode.

Yes in Countermeasures - Link layer diversity, specially if it's easy for
an attacker to provoke a transaction broadcast by buying a channel to the
LN node.

> A mitigation to this would be to run a background process which sleeps
for 20 minutes, then does `bitcoin-cli addnode ${BITCOINNODE} onetry`.

Yeah instead of having every node operator running their own hacky scripts,
without them being bulletproofs on detection, I'm working on getting such
mitigations directly in Core, easily deployable for everyone.

> The victim *could* instead check that the absolute timelocks seem very
far in the future relative to its own view of the current blockheight.

I think you're right it's really dependent on CLTV_delta deployed on the
path and time-dilation offset. The alternative you're proposing is a good
one, but you shouldn't know where you're in the path and max CLTV is 2048
blocks IIRC.

Thanks for your reading and review,

Cheers,
Antoine

Le mer. 3 juin 2020 ? 22:58, ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> a ?crit :

> Good morning Gleb and Antoine,
>
> This is good research, thank you for your work.
>
> > **Targeting Per-Hop Packet Delay** is based on routing via the victim,
> and the victim should have at least two channels with the attacker.
>
> The existence of offchain-to-onchain swap services means that the attacker
> needs only build one channel to the victim for this attack to work.
> Rather than route to themselves, the attacker routes to a convenient
> service providing such a swap service, and receives the stolen funds
> onchain, with no need even for an incoming channel from a different node.
> (Of note as well, is that the onchain contract provided by such services
> is the same in spirit as those instantiated in channels of the Lightning
> Network, thus the same attack schema works on the onchain side.)
>
> Indeed, the attack can be mounted on such a service directly.
>
> Even without such a service, the incoming channel need not be directly
> connected to the victim.
>
>
> > [Tor is tricky](https://arxiv.org/abs/1410.6079) too
>
> Since the issue here is that eclipsing of Bitcoin nodes is risky, it
> strikes me that a mitigation would be to run your Bitcoin fullnode on
> clearnet while running your Lightning node over Tor.
> Eclipsing the Lightning node (but not the Bitcoin fullnode it depends on)
> "only" loses you the ability to pay, receive, or route (and thereby earn
> forwarding fees), but as long as your blockchain view is clear, it should
> be fine.
>
> Of course, the Lightning node could still be correlated with the Bitcoin
> node when transactions are broadcast with the attached Bitcoin node (as
> noted in the paper).
> Instead the Lightning node should probably connect, over Tor, to some
> random Bitcoin fullnodes / Electrum servers and broadcast txes to them.
>
> And this seems to tie with what you propose: that the LN node should use a
> different view-fullnode from the broadcast-fullnode.
>
>
> > if a node doesn?t observe a block within the last 30 minutes, it
> attempts to make a new random connection to someone in the network.
>
> A mitigation to this would be to run a background process which sleeps for
> 20 minutes, then does `bitcoin-cli addnode ${BITCOINNODE} onetry`.
> It might want to `disconnectnode` any previous node it attempted to
> connect to.
>
> However I note that the help for `addnode` contains the text "though such
> peers will not be synced from", which confuses me, since it also refers to
> the `-connect` command line option, and `-connect` means you only connect
> out to the specific nodes, so if those are not synced from.... huh?
>
> And of course the interesting part is "how do we get a `${BITCOINNODE}`
> that we think is not part of the eclipsing attacker?"
>
>
> > If a Lightning node is behind in its Bitcoin blockchain view, but
> Lightning payments between honest nodes are still flowing through it, this
> node will have a high routing failure rate. This would happen because
> honest nodes on the routing path would reject the forwarded HTLC for being
> too close to expired.
>
> I am uncertain this would happen very often.
> In the first place, the incoming HTLC would have "reasonable" timeouts, or
> else the incoming honest node would not have routed it at all, and the
> outgoing HTLC would be relative to this incoming one, so the outgoing
> honest node will still accept this.
>
> The victim *could* instead check that the absolute timelocks seem very far
> in the future relative to its own view of the current blockheight.
> (a forwarding node miht want to do that anyway to have an upper bound
> against griefing attacks)
>
> What would definitely increase in failure rate would be payments arising
> from the victim node; the victim node believes the blockheight to be much
> lower than it actually is, and either the payee node, or some intermediate
> node along the route, will claim to have too little time to safely forward
> the funds.
> This does not help for nodes which are primarily forwarding nodes.
>
>
>
> Regards,
> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200607/45de6e7a/attachment.html>

From ZmnSCPxj at protonmail.com  Mon Jun  8 04:56:56 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 08 Jun 2020 04:56:56 +0000
Subject: [bitcoin-dev] Time-dilation Attacks on the Lightning Network
In-Reply-To: <CALZpt+FF0e1wSY5mBY-rVLQu4EGAjQefK9EQDCiExqMvKVc5UQ@mail.gmail.com>
References: <2e8fba65-f7fa-4c37-a318-222547e25a06@Spark>
 <9e4dfaa7-895a-48a1-8116-eaafc80da34f@Spark>
 <2phhD75B8ww3hFQ8Do039wAIlW8EVOjUeiedm-JtIek-TEnVocYSx-untchGrO3VoRLoPzinVAG95UN1yR3CadNWBJGSu19vJpFJ_yN-wZY=@protonmail.com>
 <CALZpt+FF0e1wSY5mBY-rVLQu4EGAjQefK9EQDCiExqMvKVc5UQ@mail.gmail.com>
Message-ID: <0c12JSDyiAy6W118uPNSz2mGj53mOB1a88HBgN5icKHMyUCIW3iCjuscuwQxpniW6sxEwLi51UujOXSwBhsWD3KmQlFBADJ5vRU0Xr1YUz0=@protonmail.com>

Good morning Antoine,


> > Since the issue here is that eclipsing of Bitcoin nodes is risky, it strikes me that a mitigation would be to run your Bitcoin fullnode on clearnet while running your Lightning node over Tor
>
> We clearly mention that risk of running a Bitcoin node over Tor, where do we recommend running a LN node over Tor ?

Nowhere, *I* am the one recommending this.
Running both Bitcoin and Lightning nodes on clearnet automatically links them, making them easier to attack, whereas running Lightning on Tor does not.
Of course, they could still be linked by onchain transaction monitoring, but at least this increases the effort to attack, hopefully it becomes marginally less desirable to attack you.

On the other hand, you *could* run them on different public IP addresses, if you happen to have more than one; for those who do not even have a single public IP address there is no real choice if you want to let others to connect to you, Tor hidden service is the only Lightning-supported way to be accessible without a public IP.

(There are sections of the world where commodity "home" internet connections do not automatically get a public IP, and the privilege of getting one may be an additional cost; though of course if you have no real intent to help support either the Bitcoin or Lightning networks, you do not need a public IP anyway, and with IPv6 it becomes less and less likely that a randomly-chosen entity would be unlucky enough to not get a public IP.)

> > The victim *could* instead check that the absolute timelocks seem very far in the future relative to its own view of the current blockheight.
> I think you're right it's really dependent on CLTV_delta deployed on the path and time-dilation offset. The alternative you're proposing is a good one, but you shouldn't know where you're in the path and max CLTV is 2048 blocks IIRC.

Seeing an incoming payment that violates the max CLTV is a good indication you have been eclipsed.

On the other hand, if your Bitcoin node is eclipsed, then it seems likely your Lightning node is also eclipsed (if running over the same hardware) and you might not receive any indication over Lightning that you have been eclipsed anyway.

I suppose we need to identify just exactly *what* ways a node of either type can be eclipsed; it seems that mitigations that protect against one kind of eclipse will not work in general with other kinds of eclipse.

Regards,
ZmnSCPxj

From jlrubin at mit.edu  Mon Jun  8 06:43:39 2020
From: jlrubin at mit.edu (Jeremy)
Date: Sun, 7 Jun 2020 23:43:39 -0700
Subject: [bitcoin-dev] [was BIP OP_CHECKTEMPLATEVERIFY] Fee Bumping Operation
In-Reply-To: <20200608110545.078f8e81@simplexum.com>
References: <CAD5xwhjXidpeLLUr4TO30t7U3z_zUxTpU9GBpLxu3MWX3ZFeTA@mail.gmail.com>
 <1cQUGt1pX0_lWPJm-tFDr9fQCvrPd5vqmCorgN89jy7gUF0m9wsouUosrFm1eal3jO9oB1BvMtORGE2htLdFjyDD5lno_QkXCFn971LQNZY=@protonmail.com>
 <CAD5xwhhZyAkQE3DpLku_xrOnixL344AqkWB=+a=fOBbekobY6g@mail.gmail.com>
 <20200608110545.078f8e81@simplexum.com>
Message-ID: <CAD5xwhjhcSDX_e8RFHveOdEEwC6YTe8kPaUw_egKkrdE0fVe1w@mail.gmail.com>

Broke out to a separate thread.

At core, the reason why this method *might* work is that it's essentially
just CPFP but we can guarantee that the link we're examining is always
exactly one hop away, so we get rid of most of the CPFP graph traversal
issues.

Your description largely matches my thinking for how something like this
could work (pay for neighbor). The issue is that the extant CPFP logic is
somewhat brittle and doesn't work as expected (Child not Children, which is
problematic for multiple PFN's).

> PFN transaction would still be valid if some of 'ghost parents' are
already confirmed, so the miners could have more fees than strictly
necessary. But this is the same as with CPFP.

This is problematic and can't be done as it requires a new index of all
past txns for consensus.

My thinking is that a Fee Bump transaction can name a list of TXIDs (Or one
TXID which implies all ancestors of) that it wishes to be included in a
block with. It must be included in that block. A Fee Bump transaction may
have no unconfirmed ancestors nor any children. Potentially, it also may
not be RBF'd. You treat the Fee Bump Transactions as the lowest descendant
of whatever it targets and then set it's feerate/total fee based on the
package that would have to co-confirm for it to be worth mining. This makes
it sort like normal transactions for inclusion. You can require some
minimums for mempool inclusion at all.

If it's target is confirmed or replaced, it should drop from the mempool.

Transactions in the mempool may set a flag that opts out of CPFP for
descendants/blocks any descendants. Channel protocols should set this bit
to prevent pinning, and then use the Fee Bump to add fees to whatever txns
need to go through. If done right you can also layer a coinswap protocol
with the fee-bumping txns change so that you are getting a privacy benefit
at the same time.

BTW the annex *could* be used for this purpose, but it would also be
acceptable to have it be in some kind of anyone can spend output. Then it
would just be a anyone-can-spend tx with OP_CHECK_TXID_IN_BLOCK (or
OP_CHECK_UTXO_SPENT_IN_BLOCK), and a miner could claim all such outputs at
the end of the block. This is worse in terms of on-chain overheads, but
nice in that it's the minimal semantic change & introduces some general
purpose functionality.

But my thoughts are still pretty loose at the moment around it. I suspect
that to make fee bumping work nicely would require removing CPFP entirely,
but I don't know that to be the case concretely.

--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>


On Sun, Jun 7, 2020 at 11:02 PM Dmitry Petukhov <dp at simplexum.com> wrote:

> ? Sun, 7 Jun 2020 15:45:16 -0700
> Jeremy via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > What I think we'll eventually land on is a way of doing a tx
> > that contributes fee to another tx chain as a passive observer to
> > them. While this breaks one abstraction around how dependencies
> > between transactions are processed, it also could help resolve some
> > really difficult challenges we face with application-DoS (pinning and
> > other attacks) in the mempool beyond CTV. I have a napkin design for
> > how this could work, but nothing quite ready to share yet.
>
> I had an idea of 'Pay for neighbor' transaction where a transaction
> that is not directly a child of some other transaction can specify that
> it wants to pay the fee for that other transaction(s). It can become
> like 'ghost child' transaction for them, in what it cannot be mined
> unless its 'ghost parents' are confirmed, too. It will be like CPFP,
> but without direct dependency via inputs. Such 'PFN' transaction would
> not spend any coins beside what it specifies in its own inputs, of
> course.
>
> The idea required a hardfork at first, but Anthony Towns suggested
> a way to make it into a soft fork (past-taproot) by putting the txids of
> 'ghost parents' into taproot annex.
>
> PFN transaction would still be valid if some of 'ghost parents' are
> already confirmed, so the miners could have more fees than strictly
> necessary. But this is the same as with CPFP.
>
> Looking at the mempool code, it seems that only a way how parent/child
> transactions relationships are established will need to be adjusted to
> account for this 'ghost relationships', and once established, other
> logic will work as with CPFP. There could be complications regarding
> transaction package size. But I cannot claim that I understand that
> code enough to say something about this with certainty.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200607/520bf867/attachment-0001.html>

From dp at simplexum.com  Mon Jun  8 06:05:45 2020
From: dp at simplexum.com (Dmitry Petukhov)
Date: Mon, 8 Jun 2020 11:05:45 +0500
Subject: [bitcoin-dev] BIP OP_CHECKTEMPLATEVERIFY
In-Reply-To: <CAD5xwhhZyAkQE3DpLku_xrOnixL344AqkWB=+a=fOBbekobY6g@mail.gmail.com>
References: <CAD5xwhjXidpeLLUr4TO30t7U3z_zUxTpU9GBpLxu3MWX3ZFeTA@mail.gmail.com>
 <1cQUGt1pX0_lWPJm-tFDr9fQCvrPd5vqmCorgN89jy7gUF0m9wsouUosrFm1eal3jO9oB1BvMtORGE2htLdFjyDD5lno_QkXCFn971LQNZY=@protonmail.com>
 <CAD5xwhhZyAkQE3DpLku_xrOnixL344AqkWB=+a=fOBbekobY6g@mail.gmail.com>
Message-ID: <20200608110545.078f8e81@simplexum.com>

? Sun, 7 Jun 2020 15:45:16 -0700
Jeremy via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> What I think we'll eventually land on is a way of doing a tx
> that contributes fee to another tx chain as a passive observer to
> them. While this breaks one abstraction around how dependencies
> between transactions are processed, it also could help resolve some
> really difficult challenges we face with application-DoS (pinning and
> other attacks) in the mempool beyond CTV. I have a napkin design for
> how this could work, but nothing quite ready to share yet.

I had an idea of 'Pay for neighbor' transaction where a transaction
that is not directly a child of some other transaction can specify that
it wants to pay the fee for that other transaction(s). It can become
like 'ghost child' transaction for them, in what it cannot be mined
unless its 'ghost parents' are confirmed, too. It will be like CPFP,
but without direct dependency via inputs. Such 'PFN' transaction would
not spend any coins beside what it specifies in its own inputs, of
course.

The idea required a hardfork at first, but Anthony Towns suggested
a way to make it into a soft fork (past-taproot) by putting the txids of
'ghost parents' into taproot annex.

PFN transaction would still be valid if some of 'ghost parents' are
already confirmed, so the miners could have more fees than strictly
necessary. But this is the same as with CPFP.

Looking at the mempool code, it seems that only a way how parent/child
transactions relationships are established will need to be adjusted to
account for this 'ghost relationships', and once established, other
logic will work as with CPFP. There could be complications regarding
transaction package size. But I cannot claim that I understand that
code enough to say something about this with certainty.


From dp at simplexum.com  Mon Jun  8 07:15:11 2020
From: dp at simplexum.com (Dmitry Petukhov)
Date: Mon, 8 Jun 2020 12:15:11 +0500
Subject: [bitcoin-dev] [was BIP OP_CHECKTEMPLATEVERIFY] Fee Bumping
 Operation
In-Reply-To: <CAD5xwhjhcSDX_e8RFHveOdEEwC6YTe8kPaUw_egKkrdE0fVe1w@mail.gmail.com>
References: <CAD5xwhjXidpeLLUr4TO30t7U3z_zUxTpU9GBpLxu3MWX3ZFeTA@mail.gmail.com>
 <1cQUGt1pX0_lWPJm-tFDr9fQCvrPd5vqmCorgN89jy7gUF0m9wsouUosrFm1eal3jO9oB1BvMtORGE2htLdFjyDD5lno_QkXCFn971LQNZY=@protonmail.com>
 <CAD5xwhhZyAkQE3DpLku_xrOnixL344AqkWB=+a=fOBbekobY6g@mail.gmail.com>
 <20200608110545.078f8e81@simplexum.com>
 <CAD5xwhjhcSDX_e8RFHveOdEEwC6YTe8kPaUw_egKkrdE0fVe1w@mail.gmail.com>
Message-ID: <20200608121511.4dbadea8@simplexum.com>

? Sun, 7 Jun 2020 23:43:39 -0700
Jeremy via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> > PFN transaction would still be valid if some of 'ghost parents' are
> >  
> already confirmed, so the miners could have more fees than strictly
> necessary. But this is the same as with CPFP.
> 
> This is problematic and can't be done as it requires a new index of
> all past txns for consensus.

If the logic would match CPFP, then PFN would be valid if some of the
'ghost parents' are confirmed, but would be invalid if some of them are
spent. I believe in this case txindex won't be required.

> My thinking is that a Fee Bump transaction can name a list of TXIDs
> (Or one TXID which implies all ancestors of) that it wishes to be
> included in a block with. It must be included in that block. A Fee
> Bump transaction may have no unconfirmed ancestors nor any children.
> Potentially, it also may not be RBF'd. You treat the Fee Bump
> Transactions as the lowest descendant of whatever it targets and then
> set it's feerate/total fee based on the package that would have to
> co-confirm for it to be worth mining. This makes it sort like normal
> transactions for inclusion. You can require some minimums for mempool
> inclusion at all.
> 
> If it's target is confirmed or replaced, it should drop from the
> mempool.

Re "may not be RBF'd": What if the sender of PFN tx wants to increase
the fee it offers for the 'ghost parents'? RBF-ing PFN tx itself seems
like less wasteful way than RBF-ing some of the parents/'ghost parents'
just for this purpose. Sometimes I think the sender of PFN will not be
even able to replace any other transactions beside their own PFN tx
(like when they offer 'fee bumping' service for others)

From salvatore.ingala at gmail.com  Mon Jun  8 09:28:28 2020
From: salvatore.ingala at gmail.com (Salvatore Ingala)
Date: Mon, 8 Jun 2020 11:28:28 +0200
Subject: [bitcoin-dev] Hash-based accumulators with quick insertion
Message-ID: <CAMhCMoELX-=9N08KE499yjPNzH6xPqBB+gAKgQMTxbnsWQuV1w@mail.gmail.com>

Dear all,

I have been working on some constructions for cryptographic accumulators
that optimise for quick insertion.

As a brief background, an accumulator is a data structure that maintains
compact commitments to a potentially very large (and dynamic) set, while
keeping proofs of membership short. Unsurprisingly, they are getting more
popular, and one notable application in Bitcoin is to create light-weight
full nodes that do not need to store the UTXO set (Utreexo accumulator[1]).

In this work, I focus on additive accumulators that supports adding new
elements, but not removing them. My motivation is to support extending
Script with access to an arbitrarily large portion of the blockchain
history and state (e.g., past blocks, txids, or any more complex state
obtained from them - with all due care). The additional storage and
computation cost for nodes is small, and the cost (in additional bytesize)
for any transaction that wishes to access state committed in the
accumulator should be just slightly bigger than typical Merkle proofs.

I have focused on:
- An accumulator with insertion time O(1) and proof size O(log^2 n)
- A construction with insertion time O(log log n) and proof size O(log n
log log n)

All the performance metrics above are in "number of hashes".

You can find:
- draft writeup:
https://github.com/bigspider/accumulator/blob/master/docs/paper-draft.pdf
- sample python code (only for the first construction at this time):
https://github.com/bigspider/accumulator

While this is still an unfinished work, the ideas in the draft are
hopefully clear enough and easy to understand. I wanted to share it at this
stage as it can benefit from comments to improve the constructions, to
cover any related work or to find potential applications in Bitcoin (e.g.
Script, layer2, side chains, etc).

Best,
Salvatore Ingala

[1] - Thaddeus Dryja, Utreexo: A dynamic hash-based accumulator optimized
for the Bitcoin UTXO set - https://eprint.iacr.org/2019/611.pdf
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200608/562ce529/attachment.html>

From vitteaymeric at gmail.com  Mon Jun  8 16:43:27 2020
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Mon, 8 Jun 2020 18:43:27 +0200
Subject: [bitcoin-dev] Time-dilation Attacks on the Lightning Network
In-Reply-To: <0c12JSDyiAy6W118uPNSz2mGj53mOB1a88HBgN5icKHMyUCIW3iCjuscuwQxpniW6sxEwLi51UujOXSwBhsWD3KmQlFBADJ5vRU0Xr1YUz0=@protonmail.com>
References: <2e8fba65-f7fa-4c37-a318-222547e25a06@Spark>
 <9e4dfaa7-895a-48a1-8116-eaafc80da34f@Spark>
 <2phhD75B8ww3hFQ8Do039wAIlW8EVOjUeiedm-JtIek-TEnVocYSx-untchGrO3VoRLoPzinVAG95UN1yR3CadNWBJGSu19vJpFJ_yN-wZY=@protonmail.com>
 <CALZpt+FF0e1wSY5mBY-rVLQu4EGAjQefK9EQDCiExqMvKVc5UQ@mail.gmail.com>
 <0c12JSDyiAy6W118uPNSz2mGj53mOB1a88HBgN5icKHMyUCIW3iCjuscuwQxpniW6sxEwLi51UujOXSwBhsWD3KmQlFBADJ5vRU0Xr1YUz0=@protonmail.com>
Message-ID: <b54af24f-4141-2d6c-1f92-940beb39920b@gmail.com>


Le 08/06/2020 ? 06:56, ZmnSCPxj via bitcoin-dev a ?crit?:
> Running both Bitcoin and Lightning nodes on clearnet automatically links them, making them easier to attack, whereas running Lightning on Tor does not.
> Of course, they could still be linked by onchain transaction monitoring, but at least this increases the effort to attack, hopefully it becomes marginally less desirable to attack you.
Or makes it easier in fact, correcting what I said in my previous
answer, stating a "yes" for a mixed bitcoin and/or LN node in clearnet
and Tor, with or without different IPs, it's probably not difficult for
the Tor attacker to identify you (for example pinging the nodes with a
new received tx to see who has it in mempool)

Similar to "Deanonymizing the VPN peers"
https://github.com/Ayms/torrent-live, this is not public but the method
uses the clearnet/VPN "mixity" and unexpectedly the more you try to hide
the better you can get deanonymized

The conclusion is always the same: do not use the Tor network for
services it is not designed for

From german at diviproject.org  Mon Jun  8 22:01:09 2020
From: german at diviproject.org (German Luna)
Date: Mon, 8 Jun 2020 16:01:09 -0600
Subject: [bitcoin-dev] Hash-based accumulators with quick insertion
Message-ID: <CALmj_sU5pw5agXONUOcenBc0GJZP6_2Cc0OnSg-J86XEkq=eKQ@mail.gmail.com>

Interesting work! I should be fortunate to make time to read it.

I will point out, in case you'd not considered it, that you can support
addition and removal indirectly by formulating it as a difference of sets.
Similar to the collision-resistant replicated data types (CRDTs) concept.
Checking for membership would simply become CheckMembershipInAdditionSet &&
!CheckMembershipInRemovalSet, assuming an item could only be added/removed
once. You could also perhaps support multiple addition/removal by attaching
a count of how many times it's been added though that might break some of
the building blocks in the paper.

-- 
Germ?n
Mathematician
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200608/6e42c0a7/attachment.html>

From mostafa.sedaghat at gmail.com  Tue Jun  9 09:34:57 2020
From: mostafa.sedaghat at gmail.com (Mostafa Sedaghat joo)
Date: Tue, 9 Jun 2020 17:34:57 +0800
Subject: [bitcoin-dev] Stamping transaction
In-Reply-To: <gNdtY-_W10fFe8vwyhQNUOCIWCtBj0G9LLUu5GQ7PYlRXejM1jwIX__TMYUhq6DDczOTQ3YYgVACOBSv6yIqx5nZ5vRbXkXPn-yjsOqi52w=@protonmail.com>
References: <CAJr8eKuFv7R-1HRft-hLFTSdpWUL2uOtkDtisL2+iPaEvvH_hA@mail.gmail.com>
 <c_8uFmqhKnoFYLB23sjYhJlKAXU5ZoCSQ2MsSgn_OePQoJKFOqIuzMjm7vhnCzevQkAwdJextCeNjA8D-f_p__-sUFSkOFMDI5_yS7k8ZM8=@protonmail.com>
 <CAJr8eKtV=W8wLkZZP9tagnL8F3jxOv8t-J9oBCFV6MrRPDmGiw@mail.gmail.com>
 <gNdtY-_W10fFe8vwyhQNUOCIWCtBj0G9LLUu5GQ7PYlRXejM1jwIX__TMYUhq6DDczOTQ3YYgVACOBSv6yIqx5nZ5vRbXkXPn-yjsOqi52w=@protonmail.com>
Message-ID: <CAJr8eKuFM0QoNNaG9Tao7aVzCoXLTH+cATxaMnropjdEVFDqOw@mail.gmail.com>

Good day ZmnSCPxj

As I said before, I don't expect a hard fork for this change. I wanted to
share my thoughts with you guys. Anytime the bitcoin community decides to
make a hard-fork, you might consider this change as well.
I believe decoupling transactions from the block is beautiful.

 About transaction verification,
Transactions have their own way to survive. Owner of the coin can keep the
history of his transactions.
But there is no guarantee that ndes should keep all of them from the
genesis. It depends. Maybe some nodes want to keep  all the transactions,
some part of them and might nothing.
Also we can think about check pointing. When a new node connects to the
network, it doesn't need to validate all the blocks since genesis. It can
start validating from a checkpoint.

And also adding 32 bits to the header of translation (which won't be saved
inside the block) is not a big deal.


Adios,
Mostafa



On Sun, Jun 7, 2020 at 11:01 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Mostafa,
>
>
> > The main point of stamping transactions is decoupling transactions from
> the block.
> >
> > Blockchain size matters
> > SegWit is a good witness that shows blockchain size matters.
> Nowadays, Data storage is cheap and easy, but that doesn't mean it's a
> simple matter. If you need to have a data-center to keep a copy of a
> blockchain, then you are far from a decentralization system.
> >
> > A Solution
> > Stamping transaction is a simple idea to keep the size of the blockchain
> as small as possible. The question that I was looking to answer is how we
> can decouple the transaction from the blocks.
> > Who cares about the transaction that happened 10 years ago. In the real
> world you may go to your bank and ask them to give you transaction history.
> But they probably have limits. They might say we just only keep the last 3
> months in our system.
>
> Stamping transaction is not how you would be able to keep **blockchain**
> size low.
>
> The reason why very old history is retained is that, if a new node is
> brought up, you need to prove to that node that you are in fact the correct
> owner of the current coins.
> Thus the entire history of Bitcoin is needed when starting a new node, and
> why archive nodes exist.
>
> You might argue that banks do not do that, and that is because we want to
> do better than banks; we know that existing currency systems have not only
> the "official" minter, but also many "unofficial" minters (commonly called
> counterfeiters) which dilute the value of the currency.
> It is this insistence on a full accounting of the provenance for every
> satoshi that separates Bitcoin from previous currency systems; bank fraud
> exists, and it hides in such sloppy techniques as deleting old transaction
> records.
>
> Work has been done to have client-side validation (i.e. the owner of a
> coin keeps the entire history, and when paying, you hand over the entire
> history of your coin to the payee, instead of everyone validating every
> transaction).
> Look up Peter Todd for some initial work on this.
>
>
> > Implementation
> >
> > > First off, the proposed mechanism can be made into a softfork by using
> an unspendable `scriptPubKey` with 0 output value.
> > SoftFork is not possible here. Because the transaction will not be saved
> inside the block (only tx hashes). Block format needs to be changed.
> Therefore the block will be invalid.
>
> That greatly reduces the chances your proposal will get into Bitcoin; you
> would need to have very good advantages to counterbalance the tremendous
> risk that hardforks introduce in the continuity of the coin.
>
> Bitcoin has never gone through a hardfork that has not instead created a
> new cryptocurrency, so any solution that requires a hardfork is going to be
> unlikely to be accepted by everyone.
>
> > > Engineering-wise, block validation now needs to memorize the last N
> block hashes.
> > I don't think we need to memorize the last N block hashes.  We can have
> something like:
> > ```
> > Current_Height - Height_Of(tx.stamp) <= N
> > ```
>
> ...
>
>
> `Height_Of()` would basically be a mapping from block hashes to block
> heights, with the number of elements equal to the height of the blockchain,
> and thus continuously growing.
> Thus, validation is expected to become more expensive as the blockchain
> grows.
>
> Since stamped transactions have a time-to-live anyway, instead you can use
> a *set* of the most recent N block hashes.
> Then you simply check if the stamp is in the set.
> This creates a data structure that is constant in size (at each block, you
> remove the block from N blocks ago), which is good for validation.
>
> > Incentives
> > I think Stamping transactions have nothing to do with the
> incentivization mechanism.  Forgive me if I couldn't get your point.
>
> A stamped tranasction has a stamp, an unstamped transaction has no stamp.
> The stamped transaction is larger because of the stamp.
> Larger transactions are more expensive because fees.
>
> Thus, stamped transactions are more expensive than unstamped transactions.
>
> Convince me why I would make *my* transaction stamped when I can just
> convince *everyone else* to stamp *their* transactions and use unstamped
> transactions myself.
>
> If you propose that all transactions must be stamped in a new version of
> Bitcoin, then take note that users will prefer to run older versions and
> never upgrade to the new version that requires stamped transactions.
> Why should users prefer a more expensive transaction format?
> For the good of the network?
> That is precisely an incentives problem: if it is so good for the network,
> then it should be good for an individual user, because the network is made
> up of individual users anyway; if individual users are not incentivized to
> use it, then that fact suggests it might not be as good for the network as
> you might think.
>
> If you answer "the stamp can be discounted" then be aware that validating
> the stamp is still a cost on every node, and it is that cost that we want
> to be reflected in pricing every byte in the transaction.
> For instance, UTXOs are retained, potentially indefinitely, and the UTXO
> lookup structure has to be very fast and is referred to at every
> transaction validation, so outputs (which create new UTXO entries) in
> SegWit are 4x more expensive than signatures, since signatures are only
> validated once when the transaction is queued to be put in the mempool.
>
>
> > Mempool
> > It's bad of me that I don't really know how mempool works in Bitcoin. My
> assumption is that there are some junk transactions (transactions that are
> valid but have very low or zero fees) inside the mempool. Stamping
> transactions might help to get rid of them time to time.
>
> Why would you think that stamping reduces mempool size?
>
> If I wanted to I could just re-send the transaction with a fresh stamp.
> Then the mempool usage would still be the same, and bandwidth use will
> increase (because the same transaction is now re-broadcast with a fresh
> stamp, and the added size of the stamps themselves).
>
>
> Regards,
> ZmnSCPxj
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200609/2c5fbf6c/attachment-0001.html>

From criley at gmail.com  Tue Jun  9 14:16:27 2020
From: criley at gmail.com (Chris Riley)
Date: Tue, 9 Jun 2020 10:16:27 -0400
Subject: [bitcoin-dev] Stamping transaction
In-Reply-To: <CAJr8eKuFM0QoNNaG9Tao7aVzCoXLTH+cATxaMnropjdEVFDqOw@mail.gmail.com>
References: <CAJr8eKuFv7R-1HRft-hLFTSdpWUL2uOtkDtisL2+iPaEvvH_hA@mail.gmail.com>
 <c_8uFmqhKnoFYLB23sjYhJlKAXU5ZoCSQ2MsSgn_OePQoJKFOqIuzMjm7vhnCzevQkAwdJextCeNjA8D-f_p__-sUFSkOFMDI5_yS7k8ZM8=@protonmail.com>
 <CAJr8eKtV=W8wLkZZP9tagnL8F3jxOv8t-J9oBCFV6MrRPDmGiw@mail.gmail.com>
 <gNdtY-_W10fFe8vwyhQNUOCIWCtBj0G9LLUu5GQ7PYlRXejM1jwIX__TMYUhq6DDczOTQ3YYgVACOBSv6yIqx5nZ5vRbXkXPn-yjsOqi52w=@protonmail.com>
 <CAJr8eKuFM0QoNNaG9Tao7aVzCoXLTH+cATxaMnropjdEVFDqOw@mail.gmail.com>
Message-ID: <CAL5BAw3WytOEA_fiFDabwWXtCoLdNAy+nf3PV3e+sUde1nOGew@mail.gmail.com>

Hello,

Just a few comments.

>But there is no guarantee that ndes should keep all of them from the
genesis. It depends. Maybe some nodes want to keep  all the transactions,
some part of them and might nothing.
There is no guarantee that nodes keep them all from the genesis now, nodes
can turn on pruning if the operator doesn't desire to keep all the
transactions from the genesis block
(https://github.com/bitcoin/bitcoin/blob/v0.11.0/doc/release-notes.md#block-file-pruning).
Likewise, light clients may not keep any transaction history.

>Also we can think about check pointing. When a new node connects to the
network, it doesn't need to validate all the blocks since genesis. It can
start validating from a checkpoint.
>Transactions have their own way to survive. Owner of the coin can keep the
history of his transactions.
There have been some checkpoint discussions on here too, which have
discussed the pros and cons of them.
see, e.g.:
site:https://lists.linuxfoundation.org/pipermail/bitcoin-dev/ checkpointand:
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-May/016001.html
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-August/017209.html

Without introducing trusted people, how can you prove that the "owner" is
person A or B without verification from the genesis block?  For example, A
or B could claim to be the owner and provide an altered client with an
altered checkpoint to "prove" it.

>Anytime the bitcoin community decides to make a hard-fork, you might
consider this change as well
>From reading the initial bitcoin paper, many proposals etc since and having
been around the "bitcoin community" for 9 years, I think that this change
has a very, very small chance of ever happening because full transaction
verification is an important part of the blockchain bank.   Not to say this
isn't a useful, interesting, informative, and educational discussion, but
it seems unlikely to happen.  Likewise,  it could lead to something related
that would be likely to occur, so full discussions like this are useful.

Regards,  :-)
Chris

On Tue, Jun 9, 2020 at 7:20 AM Mostafa Sedaghat joo via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Good day ZmnSCPxj
>
> As I said before, I don't expect a hard fork for this change. I wanted to
> share my thoughts with you guys. Anytime the bitcoin community decides to
> make a hard-fork, you might consider this change as well.
> I believe decoupling transactions from the block is beautiful.
>
>  About transaction verification,
> Transactions have their own way to survive. Owner of the coin can keep the
> history of his transactions.
> But there is no guarantee that ndes should keep all of them from the
> genesis. It depends. Maybe some nodes want to keep  all the transactions,
> some part of them and might nothing.
> Also we can think about check pointing. When a new node connects to the
> network, it doesn't need to validate all the blocks since genesis. It can
> start validating from a checkpoint.
>
> And also adding 32 bits to the header of translation (which won't be saved
> inside the block) is not a big deal.
>
>
> Adios,
> Mostafa
>
>
>
> On Sun, Jun 7, 2020 at 11:01 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>
>> Good morning Mostafa,
>>
>>
>> > The main point of stamping transactions is decoupling transactions from
>> the block.
>> >
>> > Blockchain size matters
>> > SegWit is a good witness that shows blockchain size matters.
>> Nowadays, Data storage is cheap and easy, but that doesn't mean it's a
>> simple matter. If you need to have a data-center to keep a copy of a
>> blockchain, then you are far from a decentralization system.
>> >
>> > A Solution
>> > Stamping transaction is a simple idea to keep the size of the
>> blockchain as small as possible. The question that I was looking to answer
>> is how we can decouple the transaction from the blocks.
>> > Who cares about the transaction that happened 10 years ago. In the real
>> world you may go to your bank and ask them to give you transaction history.
>> But they probably have limits. They might say we just only keep the last 3
>> months in our system.
>>
>> Stamping transaction is not how you would be able to keep **blockchain**
>> size low.
>>
>> The reason why very old history is retained is that, if a new node is
>> brought up, you need to prove to that node that you are in fact the correct
>> owner of the current coins.
>> Thus the entire history of Bitcoin is needed when starting a new node,
>> and why archive nodes exist.
>>
>> You might argue that banks do not do that, and that is because we want to
>> do better than banks; we know that existing currency systems have not only
>> the "official" minter, but also many "unofficial" minters (commonly called
>> counterfeiters) which dilute the value of the currency.
>> It is this insistence on a full accounting of the provenance for every
>> satoshi that separates Bitcoin from previous currency systems; bank fraud
>> exists, and it hides in such sloppy techniques as deleting old transaction
>> records.
>>
>> Work has been done to have client-side validation (i.e. the owner of a
>> coin keeps the entire history, and when paying, you hand over the entire
>> history of your coin to the payee, instead of everyone validating every
>> transaction).
>> Look up Peter Todd for some initial work on this.
>>
>>
>> > Implementation
>> >
>> > > First off, the proposed mechanism can be made into a softfork by
>> using an unspendable `scriptPubKey` with 0 output value.
>> > SoftFork is not possible here. Because the transaction will not be
>> saved inside the block (only tx hashes). Block format needs to be changed.
>> Therefore the block will be invalid.
>>
>> That greatly reduces the chances your proposal will get into Bitcoin; you
>> would need to have very good advantages to counterbalance the tremendous
>> risk that hardforks introduce in the continuity of the coin.
>>
>> Bitcoin has never gone through a hardfork that has not instead created a
>> new cryptocurrency, so any solution that requires a hardfork is going to be
>> unlikely to be accepted by everyone.
>>
>> > > Engineering-wise, block validation now needs to memorize the last N
>> block hashes.
>> > I don't think we need to memorize the last N block hashes.  We can have
>> something like:
>> > ```
>> > Current_Height - Height_Of(tx.stamp) <= N
>> > ```
>>
>> ...
>>
>>
>> `Height_Of()` would basically be a mapping from block hashes to block
>> heights, with the number of elements equal to the height of the blockchain,
>> and thus continuously growing.
>> Thus, validation is expected to become more expensive as the blockchain
>> grows.
>>
>> Since stamped transactions have a time-to-live anyway, instead you can
>> use a *set* of the most recent N block hashes.
>> Then you simply check if the stamp is in the set.
>> This creates a data structure that is constant in size (at each block,
>> you remove the block from N blocks ago), which is good for validation.
>>
>> > Incentives
>> > I think Stamping transactions have nothing to do with the
>> incentivization mechanism.  Forgive me if I couldn't get your point.
>>
>> A stamped tranasction has a stamp, an unstamped transaction has no stamp.
>> The stamped transaction is larger because of the stamp.
>> Larger transactions are more expensive because fees.
>>
>> Thus, stamped transactions are more expensive than unstamped transactions.
>>
>> Convince me why I would make *my* transaction stamped when I can just
>> convince *everyone else* to stamp *their* transactions and use unstamped
>> transactions myself.
>>
>> If you propose that all transactions must be stamped in a new version of
>> Bitcoin, then take note that users will prefer to run older versions and
>> never upgrade to the new version that requires stamped transactions.
>> Why should users prefer a more expensive transaction format?
>> For the good of the network?
>> That is precisely an incentives problem: if it is so good for the
>> network, then it should be good for an individual user, because the network
>> is made up of individual users anyway; if individual users are not
>> incentivized to use it, then that fact suggests it might not be as good for
>> the network as you might think.
>>
>> If you answer "the stamp can be discounted" then be aware that validating
>> the stamp is still a cost on every node, and it is that cost that we want
>> to be reflected in pricing every byte in the transaction.
>> For instance, UTXOs are retained, potentially indefinitely, and the UTXO
>> lookup structure has to be very fast and is referred to at every
>> transaction validation, so outputs (which create new UTXO entries) in
>> SegWit are 4x more expensive than signatures, since signatures are only
>> validated once when the transaction is queued to be put in the mempool.
>>
>>
>> > Mempool
>> > It's bad of me that I don't really know how mempool works in Bitcoin.
>> My assumption is that there are some junk transactions (transactions that
>> are valid but have very low or zero fees) inside the mempool. Stamping
>> transactions might help to get rid of them time to time.
>>
>> Why would you think that stamping reduces mempool size?
>>
>> If I wanted to I could just re-send the transaction with a fresh stamp.
>> Then the mempool usage would still be the same, and bandwidth use will
>> increase (because the same transaction is now re-broadcast with a fresh
>> stamp, and the added size of the stamps themselves).
>>
>>
>> Regards,
>> ZmnSCPxj
>>
>> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200609/158605a4/attachment.html>

From lee.chiffre at secmail.pro  Wed Jun 10 00:43:40 2020
From: lee.chiffre at secmail.pro (Mr. Lee Chiffre)
Date: Tue, 9 Jun 2020 17:43:40 -0700
Subject: [bitcoin-dev] Design for a CoinSwap implementation for
 massively improving Bitcoin privacy and fungibility
In-Reply-To: <82d90d57-ad07-fc7d-4aca-2b227ac2068d@riseup.net>
References: <82d90d57-ad07-fc7d-4aca-2b227ac2068d@riseup.net>
Message-ID: <5b77933071fa02e900183d8d5e24d866.squirrel@giyzk7o6dcunb2ry.onion>


>
> === Combining multi-transaction with routing ===
>
> Routing and multi-transaction must be combined to get both benefits. If
> Alice owns multiple UTXOs (of value 6 BTC, 8 BTC and 1 BTC) then this is
> easy with this configuration:
>
>              Alice
>     (6 BTC) (8 BTC) (1 BTC)
>        |       |       |
>        |       |       |
>        v       v       v
>               Bob
>     (5 BTC) (5 BTC) (5 BTC)
>        |       |       |
>        |       |       |
>        v       v       v
>             Charlie
>     (9 BTC) (5 BTC) (1 BTC)
>        |       |       |
>        |       |       |
>        v       v       v
>             Dennis
>     (7 BTC) (4 BTC) (4 BTC)
>        |       |       |
>        |       |       |
>        v       v       v
>              Alice
>






Great work Chris and you have my respects for your contributions to
Bitcoin. A concern I have with bitcoin is scalability and privacy. Both
are important. The reasons people bash on Monero is also the same issue
Bitcoin has. The very large transaction size to achieve acceptable privacy
on a distributed financial network. Im not shilling Monero here. I am only
saying that bitcoin transactions with similar privacy properties are at
least equally as large as Monero transactions. Coinjoin on Monero can be
compared to ring signatures in Monero from the view of using decoys to
help conceal the source. From this proposal is this to say that
transactions will be at least 12 times larger in size to achieve the
property of privacy that bitcoin is currently missing?

Another thing to consider is that if coinswaps cannot be sent as a payment
then a coinswap needs to take place after every transaction to keep the
privacy and unlinkability from your other bitcoin transactions.

I always thought that CoinSwap would be and is a very much needed thing
that needs developed. The ability to swap coins with other people in a
trustless way and way that is not linkable to the public blockchain. But
how can this be scalable at all with the multiple branches and layers?
This is a good idea in theory but my concern would be the scalability
issues this creates.

Do you have any comments on this?
Thank you


-- 
lee.chiffre at secmail.pro
PGP 97F0C3AE985A191DA0556BCAA82529E2025BDE35


From lee.chiffre at secmail.pro  Wed Jun 10 00:46:41 2020
From: lee.chiffre at secmail.pro (Mr. Lee Chiffre)
Date: Tue, 9 Jun 2020 17:46:41 -0700
Subject: [bitcoin-dev] Design for a CoinSwap implementation for
 massively improving Bitcoin privacy and fungibility
In-Reply-To: <5b77933071fa02e900183d8d5e24d866.squirrel@giyzk7o6dcunb2ry.onion>
References: <82d90d57-ad07-fc7d-4aca-2b227ac2068d@riseup.net>
 <5b77933071fa02e900183d8d5e24d866.squirrel@giyzk7o6dcunb2ry.onion>
Message-ID: <b8ed24fe87f391c5abf291ddc43de868.squirrel@giyzk7o6dcunb2ry.onion>


> Coinjoin on Monero can be
> compared to ring signatures in Monero from the view of using decoys to
> help conceal the source. From this proposal is this to say that
> transactions will be at least 12 times larger in size to achieve the
> property of privacy that bitcoin is currently missing?
>


This was a typo. Coinjoin on BITCOIN, can be compared to ring signatures
in Monero form the view of using decoys to help conceal the source.


The same thing that makes monero transactions large and a scalability
concern is the same thing that bitcoin suffers from with using privacy
focused transactions.


From lee.chiffre at secmail.pro  Wed Jun 10 04:01:44 2020
From: lee.chiffre at secmail.pro (Mr. Lee Chiffre)
Date: Tue, 9 Jun 2020 21:01:44 -0700
Subject: [bitcoin-dev] Question about PayJoin effectiveness
Message-ID: <7c0dc46538f96032596163c4a9f03dc2.squirrel@giyzk7o6dcunb2ry.onion>

I am trying to learn about payjoin. I have a couple concerns on its
effectiveness. Are my concerns valid or am I missing something?

concern 1
If it is known to be a payjoin transaction anyone could determine the
sender the recipient and amount right?

Lets assume that everyone has a single utxo because payjoin becomes common
use and payjoin consolidates utxos through "snowballing". If Alice has a
UTXO of 0.05 btc and Bob has a UTXO of 1.15 btc. Bob can be assumed to
have more balance because he is a merchant and his customers payjoin him
payments alot.

If Alice and Bob do a payjoin with Alice paying 0.01 btc to Bob, it would
probably look like this right?

 0.05---> |____---->1.16
 1.15---> |    ---->0.04

It is very obvious here the amount sent and the sender.  Even if Alice did
combine another input it would still be very obvious. In this case Alice
has another utxo with 0.4 BTC

 0.40---> |
 0.05---> |____---->1.16
 1.15---> |    ---->0.44

This is still obvious that Alice paid Bob 0.01 BTC isn't it?



concern 2
If there is just one consolidated utxo after each payjoin, would it  be
easy to break the privacy of transaction chains?

Alice---payjoin--->Bob
Clark---payjoin--->Bob

or

Alice---payjoin--->Bob---payjoin--->Clark

For exmaple, lets say that Alice payjoins to Bob. Then later on Clark
payjoins with Bob. Based on the payjoin between Clark and Bob, Clark now
knows what UTXO was actually Bob's. And can then know which one was
actually Alices. By transacting a payjoin with someone, they could decloak
the payjoins before them right? If so, how far back the chain can they go?

The issue is not that someone knows the utxos of themselves and the entity
they payjoined with. The issue is that someone can figure out the payjoins
of others before them with the same entity.


I surely must be missing something here. What am I not understanding?

-- 
lee.chiffre at secmail.pro
PGP 97F0C3AE985A191DA0556BCAA82529E2025BDE35









From ZmnSCPxj at protonmail.com  Wed Jun 10 06:29:08 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 10 Jun 2020 06:29:08 +0000
Subject: [bitcoin-dev] Question about PayJoin effectiveness
In-Reply-To: <7c0dc46538f96032596163c4a9f03dc2.squirrel@giyzk7o6dcunb2ry.onion>
References: <7c0dc46538f96032596163c4a9f03dc2.squirrel@giyzk7o6dcunb2ry.onion>
Message-ID: <sjC0RVZr0Uyg5QKjgmAQfNibCUtaG-r_XEO8xDgPd7GIjLKSEybd47utANFWA53yySigMzqfiotpbCdFy-M5NcxJN1J6cCQO1r3sR1-eVks=@protonmail.com>


Good morning Mr. Lee,

> I am trying to learn about payjoin. I have a couple concerns on its
> effectiveness. Are my concerns valid or am I missing something?
>
> concern 1
> If it is known to be a payjoin transaction anyone could determine the
> sender the recipient and amount right?
>
> Lets assume that everyone has a single utxo because payjoin becomes common
> use and payjoin consolidates utxos through "snowballing". If Alice has a
> UTXO of 0.05 btc and Bob has a UTXO of 1.15 btc. Bob can be assumed to
> have more balance because he is a merchant and his customers payjoin him
> payments alot.
>
> If Alice and Bob do a payjoin with Alice paying 0.01 btc to Bob, it would
> probably look like this right?
>
> 0.05---> |____---->1.16
> 1.15---> | ---->0.04


There are multiple interpretations:

* The 0.05 owner is paying the 1.15 owner 0.01 BTC.
* The 1.15 owner is paying the 0.05 owner 1.11 BTC.
* The 0.05 + 1.15 owner is paying an independent user 1.16 BTC using a non-PayJoin transaction (because for example the payee currently has no coins, i.e. a new user).

It is this fact of multiple interpretations that is what PayJoin buys you in practice.

You could argue that paying 0.01 is more likely than paying 1.11 or 1.16, but that still does not give you 100% assurance --- the creators of the transaction are still getting the `100% - probability_of_paying_0.01` benefit, and reducing UTXO set size as well.

Your assertion that this is "very obvious" only exists because you already know that Alice is paying 0.01 to Bob, but that is in fact the very thing that is being obscured here.


>
> It is very obvious here the amount sent and the sender. Even if Alice did
> combine another input it would still be very obvious. In this case Alice
> has another utxo with 0.4 BTC
>
> 0.40---> |
> 0.05---> |____---->1.16
> 1.15---> | ---->0.44


This can be interpreted as well multiple ways:

* 0.05 + 1.15 is the same owner who wants to merge coins, and is paying the 0.40 owner 0.04 BTC.
* 0.40 + 1.15 is the same owner who wants to merge coins, and is paying the 0.05 owner 0.39 BTC.
* 0.40 + 0.05 is the same owner who wants to merge coins, and is paying the 1.15 owner 0.01 BTC.

You should probably be shuffling the inputs and outputs, or using BIP39 consistently, so that inputs and outputs do not correlate (i.e. do not necessarily group together all of Alice inputs).


>
> This is still obvious that Alice paid Bob 0.01 BTC isn't it?
>
> concern 2
> If there is just one consolidated utxo after each payjoin, would it be
> easy to break the privacy of transaction chains?
>
> Alice---payjoin--->Bob
> Clark---payjoin--->Bob
>
> or
>
> Alice---payjoin--->Bob---payjoin--->Clark
>
> For exmaple, lets say that Alice payjoins to Bob. Then later on Clark
> payjoins with Bob. Based on the payjoin between Clark and Bob, Clark now
> knows what UTXO was actually Bob's. And can then know which one was
> actually Alices. By transacting a payjoin with someone, they could decloak
> the payjoins before them right? If so, how far back the chain can they go?
>
> The issue is not that someone knows the utxos of themselves and the entity
> they payjoined with. The issue is that someone can figure out the payjoins
> of others before them with the same entity.

If Clark can hack Alice (even just read-only access to Alice logs), they can go by one more transaction.

If Clark cannot hack Alice, then that is the sole extent Clark knows: Clark know that Bob transacted with somebody for a resulting N BTC (which is relatively uninteresting, obviously somebody who uses BTC is going to be transacting with random BTC users in BTC), without being sure that Bob was the payer or the payee in that situation.

Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Wed Jun 10 06:47:28 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 10 Jun 2020 06:47:28 +0000
Subject: [bitcoin-dev] Question about PayJoin effectiveness
In-Reply-To: <sjC0RVZr0Uyg5QKjgmAQfNibCUtaG-r_XEO8xDgPd7GIjLKSEybd47utANFWA53yySigMzqfiotpbCdFy-M5NcxJN1J6cCQO1r3sR1-eVks=@protonmail.com>
References: <7c0dc46538f96032596163c4a9f03dc2.squirrel@giyzk7o6dcunb2ry.onion>
 <sjC0RVZr0Uyg5QKjgmAQfNibCUtaG-r_XEO8xDgPd7GIjLKSEybd47utANFWA53yySigMzqfiotpbCdFy-M5NcxJN1J6cCQO1r3sR1-eVks=@protonmail.com>
Message-ID: <Ke7oBPiiaYh_IZr8DdhdRAEsYnZS_mA8EQIKLEaggUUHZtsT8TAaVy6cWs2NamHBOpwCv6cVfI1vr2RxsCh5W1M3DWsfxGAUtPex86-39xw=@protonmail.com>

Good morning again Mr. Lee,

> > I am trying to learn about payjoin. I have a couple concerns on its
> > effectiveness. Are my concerns valid or am I missing something?
> > concern 1
> > If it is known to be a payjoin transaction anyone could determine the
> > sender the recipient and amount right?
> > Lets assume that everyone has a single utxo because payjoin becomes common
> > use and payjoin consolidates utxos through "snowballing". If Alice has a
> > UTXO of 0.05 btc and Bob has a UTXO of 1.15 btc. Bob can be assumed to
> > have more balance because he is a merchant and his customers payjoin him
> > payments alot.


It is also helpful to remember that Bob cannot exist in isolation, and therefore, Bob probably has:

* Employees.
* Suppliers.
* Shareholders.

For example, suppose Bob holds in reserve a 0.05 BTC UTXO in a holding wallet.

Then Bob takes the 1.16 UTXO it got from Alice and transfers 1.12 BTC to the holding wallet:

    Bob merchant wallet 1.16 --___-- 1.17 Bob holding wallet
    Bob holding wallet  0.05 --   -- 0.04 Bob merchant wallet

The above looks exactly like one of the "customer pays Bob" transactions, but is in fact different.

Then Bob uses the holding wallet to pay out to employees, suppliers, and shareholders, such as in a single large batched transaction, and then leaves behind another 0.05 BTC in the holding wallet (or some random small number of BTC) for the next time Bob has to pay to employees/suppliers/shareholders.

So the transaction below:

    1.16 --___-- 1.17
    0.05 --   -- 0.04

*could* be interpreted as the 0.05 owner paying to the 1.16 owner, but in fact that is just Bob preparing the incoming funds from the merchant front-end for processing to send to its own liabilities.

Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Wed Jun 10 07:09:04 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 10 Jun 2020 07:09:04 +0000
Subject: [bitcoin-dev] Design for a CoinSwap implementation for
	massively improving Bitcoin privacy and fungibility
In-Reply-To: <5b77933071fa02e900183d8d5e24d866.squirrel@giyzk7o6dcunb2ry.onion>
References: <82d90d57-ad07-fc7d-4aca-2b227ac2068d@riseup.net>
 <5b77933071fa02e900183d8d5e24d866.squirrel@giyzk7o6dcunb2ry.onion>
Message-ID: <V-w3Jx5ssSZ1Ch5GEiJJjI12U1qmnlyCsET6JjsDAkl2yC6iJ7DK52mshe0F7wOAjK8vrbSeqRijC3QFRyl1FuGe41xcmYfgC6s7e7H_AQg=@protonmail.com>

Good morning Mr. Lee,


> > === Combining multi-transaction with routing ===
> > Routing and multi-transaction must be combined to get both benefits. If
> > Alice owns multiple UTXOs (of value 6 BTC, 8 BTC and 1 BTC) then this is
> > easy with this configuration:
> >
> >              Alice
> >     (6 BTC) (8 BTC) (1 BTC)
> >        |       |       |
> >        |       |       |
> >        v       v       v
> >               Bob
> >     (5 BTC) (5 BTC) (5 BTC)
> >        |       |       |
> >        |       |       |
> >        v       v       v
> >             Charlie
> >     (9 BTC) (5 BTC) (1 BTC)
> >        |       |       |
> >        |       |       |
> >        v       v       v
> >             Dennis
> >     (7 BTC) (4 BTC) (4 BTC)
> >        |       |       |
> >        |       |       |
> >        v       v       v
> >              Alice
> >
>
> Great work Chris and you have my respects for your contributions to
> Bitcoin. A concern I have with bitcoin is scalability and privacy. Both
> are important. The reasons people bash on Monero is also the same issue
> Bitcoin has. The very large transaction size to achieve acceptable privacy
> on a distributed financial network. Im not shilling Monero here. I am only
> saying that bitcoin transactions with similar privacy properties are at
> least equally as large as Monero transactions. Coinjoin on Monero can be
> compared to ring signatures in Monero from the view of using decoys to
> help conceal the source. From this proposal is this to say that
> transactions will be at least 12 times larger in size to achieve the
> property of privacy that bitcoin is currently missing?

CoinSwap lets you buy privacy at whatever rate is manageable for you.
You can buy a simple non-routed non-multitransaction CoinSwap, for example, instead of larger sections like the above, depending on your privacy needs.
Even doing a non-routed non-multitransaction CoinSwap would help fungibility of those doing more complex setups, because the tiny CoinSwaps you make are made of "the same things" that the more complex CoinSwaps are made of.

>
> Another thing to consider is that if coinswaps cannot be sent as a payment
> then a coinswap needs to take place after every transaction to keep the
> privacy and unlinkability from your other bitcoin transactions.
>
> I always thought that CoinSwap would be and is a very much needed thing
> that needs developed. The ability to swap coins with other people in a
> trustless way and way that is not linkable to the public blockchain. But
> how can this be scalable at all with the multiple branches and layers?
> This is a good idea in theory but my concern would be the scalability
> issues this creates.
>
> Do you have any comments on this?
> Thank you

Overall, multiple mixing techniques cover a wide range of cost and privacy.

* PayJoins are cheap and almost free (you are coordinating with only one other participant who is strongly incentivized to cooperate with you, and making a single overall tx) but buys you only a small dollop of privacy (transaction can be misinterpreted by chain analysis, but probabilistic analysis can be "reasonably accurate" for a few transactions).
* Equal-valued CoinJoins are slightly more expensive than PayJoins but give a good amount of privacy (you are coordinating with multiple participants, and probably paying coordination/participation fees, but *which* output is yours will give probabilistic analysis a run for its money, although it is obvious that you *did* participate in a CoinJoin).
* CoinSwaps are a good bit more expensive than equal-valud CoinJoins but give a significant amount of privacy for their cost (you are coordinating with multiple participants and paying coordination/participation fees *and* you run the risk of getting your funds timelocked in case of network communications problems or active hacking attempts, but it is hard for chain analysis to even *realize* that a CoinSwap even occurred, i.e. it is steganographic).

Chris argues that CoinSwap gives better privacy:cost ratios than equal-valued CoinJoins, you can wait and see if he gives more supporting arguments regarding this, but overall the various mixing tech exists to give choice on how much privacy you buy.

Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Wed Jun 10 07:09:04 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 10 Jun 2020 07:09:04 +0000
Subject: [bitcoin-dev] Design for a CoinSwap implementation for
	massively improving Bitcoin privacy and fungibility
In-Reply-To: <5b77933071fa02e900183d8d5e24d866.squirrel@giyzk7o6dcunb2ry.onion>
References: <82d90d57-ad07-fc7d-4aca-2b227ac2068d@riseup.net>
 <5b77933071fa02e900183d8d5e24d866.squirrel@giyzk7o6dcunb2ry.onion>
Message-ID: <V-w3Jx5ssSZ1Ch5GEiJJjI12U1qmnlyCsET6JjsDAkl2yC6iJ7DK52mshe0F7wOAjK8vrbSeqRijC3QFRyl1FuGe41xcmYfgC6s7e7H_AQg=@protonmail.com>

Good morning Mr. Lee,


> > === Combining multi-transaction with routing ===
> > Routing and multi-transaction must be combined to get both benefits. If
> > Alice owns multiple UTXOs (of value 6 BTC, 8 BTC and 1 BTC) then this is
> > easy with this configuration:
> >
> >              Alice
> >     (6 BTC) (8 BTC) (1 BTC)
> >        |       |       |
> >        |       |       |
> >        v       v       v
> >               Bob
> >     (5 BTC) (5 BTC) (5 BTC)
> >        |       |       |
> >        |       |       |
> >        v       v       v
> >             Charlie
> >     (9 BTC) (5 BTC) (1 BTC)
> >        |       |       |
> >        |       |       |
> >        v       v       v
> >             Dennis
> >     (7 BTC) (4 BTC) (4 BTC)
> >        |       |       |
> >        |       |       |
> >        v       v       v
> >              Alice
> >
>
> Great work Chris and you have my respects for your contributions to
> Bitcoin. A concern I have with bitcoin is scalability and privacy. Both
> are important. The reasons people bash on Monero is also the same issue
> Bitcoin has. The very large transaction size to achieve acceptable privacy
> on a distributed financial network. Im not shilling Monero here. I am only
> saying that bitcoin transactions with similar privacy properties are at
> least equally as large as Monero transactions. Coinjoin on Monero can be
> compared to ring signatures in Monero from the view of using decoys to
> help conceal the source. From this proposal is this to say that
> transactions will be at least 12 times larger in size to achieve the
> property of privacy that bitcoin is currently missing?

CoinSwap lets you buy privacy at whatever rate is manageable for you.
You can buy a simple non-routed non-multitransaction CoinSwap, for example, instead of larger sections like the above, depending on your privacy needs.
Even doing a non-routed non-multitransaction CoinSwap would help fungibility of those doing more complex setups, because the tiny CoinSwaps you make are made of "the same things" that the more complex CoinSwaps are made of.

>
> Another thing to consider is that if coinswaps cannot be sent as a payment
> then a coinswap needs to take place after every transaction to keep the
> privacy and unlinkability from your other bitcoin transactions.
>
> I always thought that CoinSwap would be and is a very much needed thing
> that needs developed. The ability to swap coins with other people in a
> trustless way and way that is not linkable to the public blockchain. But
> how can this be scalable at all with the multiple branches and layers?
> This is a good idea in theory but my concern would be the scalability
> issues this creates.
>
> Do you have any comments on this?
> Thank you

Overall, multiple mixing techniques cover a wide range of cost and privacy.

* PayJoins are cheap and almost free (you are coordinating with only one other participant who is strongly incentivized to cooperate with you, and making a single overall tx) but buys you only a small dollop of privacy (transaction can be misinterpreted by chain analysis, but probabilistic analysis can be "reasonably accurate" for a few transactions).
* Equal-valued CoinJoins are slightly more expensive than PayJoins but give a good amount of privacy (you are coordinating with multiple participants, and probably paying coordination/participation fees, but *which* output is yours will give probabilistic analysis a run for its money, although it is obvious that you *did* participate in a CoinJoin).
* CoinSwaps are a good bit more expensive than equal-valud CoinJoins but give a significant amount of privacy for their cost (you are coordinating with multiple participants and paying coordination/participation fees *and* you run the risk of getting your funds timelocked in case of network communications problems or active hacking attempts, but it is hard for chain analysis to even *realize* that a CoinSwap even occurred, i.e. it is steganographic).

Chris argues that CoinSwap gives better privacy:cost ratios than equal-valued CoinJoins, you can wait and see if he gives more supporting arguments regarding this, but overall the various mixing tech exists to give choice on how much privacy you buy.

Regards,
ZmnSCPxj

From belcher at riseup.net  Wed Jun 10 10:15:36 2020
From: belcher at riseup.net (Chris Belcher)
Date: Wed, 10 Jun 2020 11:15:36 +0100
Subject: [bitcoin-dev] Design for a CoinSwap implementation for
 massively improving Bitcoin privacy and fungibility
In-Reply-To: <Sy14DpcFGdAYL95d7e6tfkOe87oY53tJReo9CYvPT5J3Gb85AqedMheq1NbfVKUXZtZrwZqwVV4wSztikgWBAgNfTh8J5h5gXC6HDMxvsNg=@protonmail.com>
References: <82d90d57-ad07-fc7d-4aca-2b227ac2068d@riseup.net>
 <CAPv7TjY9h8n-nK_CPiYCWYDcbXpT1gfRMQDgf9VUkcR532rxOw@mail.gmail.com>
 <VxL93WE7bDrK1riquTWTTEgJj9mDQ4W5CuhOgdnnDPeidw2ho6evVh4cLZLz0jEYMqejaD1tiLULVTXkNRbI5A7wSwV49qSwnXcTWCDJ96E=@protonmail.com>
 <cbf78f63-cf8c-c5d8-06ea-afc79aabc23c@riseup.net>
 <5LiZqpFxklAAbGFiiAE3ijRbIteODXKcHrXvGJ-qabgQj5hG8beFtHNbVZ-XUxETVwduJYz94UYuJGAPxBrbGeZpSClUtXYsPJBABfr03KM=@protonmail.com>
 <e724b4c5-9efd-66c4-163b-492f17cafd7d@riseup.net>
 <Sy14DpcFGdAYL95d7e6tfkOe87oY53tJReo9CYvPT5J3Gb85AqedMheq1NbfVKUXZtZrwZqwVV4wSztikgWBAgNfTh8J5h5gXC6HDMxvsNg=@protonmail.com>
Message-ID: <27f05cf1-08b2-a281-75b7-5c035317d030@riseup.net>

Good morning ZmnSCPxj,

On 06/06/2020 02:40, ZmnSCPxj wrote:
> Good morning Chris,
> 
>> I think I'm having trouble understanding this, does it work like this:
>>
>> Say we're in the 2-party coinswap case (Alice and Bob)
>>
>> We have Alice's funding transaction:
>> Alice UTXO ---> 2of2 multisig (Alice+Bob)
>>
>> And we have the regular contract transaction
>> 2of2 multisig (Alice+Bob) ---> Alice+timelock1 OR Bob+hashlock
>>
>> And you propose a second pre-signed transaction?
>> 2of2 multisig (Alice+Bob) ---> Bob+timelock2
> 
> No, it is:
> 
> 2of2 multisig (Alice+Bob) --(nLockTime=locktime1)-> Alice
> 
> The timelock is  imposed as a `nLockTime`, not as an `OP_CLTV` (so not in the output of the tx, but part of the tx), and the backout returns the funds to Alice, not sends it to Bob.
> This transaction is created *before* the contract transaction.
> 
> The order is:
> 
> * Create (but not sign) Alice funding tx (Alice --> Alice+Bob).
> * Create and sign Alice backout transaction (Alice+Bob -(nLockTime=locktime1)-> Alice).
> * Create (but not sign) Bob funding tx (Bob --> Alice+Bob+sharedSecret).
> * Create and sign Bob backout transaction (Alice+Bob+sharedSecret -(nLocktime=locktime2)-> Bob) where timelock2 < timelock1.
> * Sign and broadcast funding txes.
>   * At this point, even if Bob funding tx is confirmed but Alice funding tx is not, Bob can recover funds with the backout, but Alice cannot steal the funds (since there is no hashlock branch at this point).
> * When Alice funding tx is confirmed, create and sign contract transaction (Alice+Bob --> Alice+timelock1 OR Bob+hashlock).
> * When Bob funding tx is confirmed and Bob has received the Alice contract transaction, create and sign Bob contract transaction (Alice+Bob+sharedSecret --> Bob+timelock2 OR Alice+hashlock).
> * Continue as normal.
> 
> In effect, the backout transaction creates a temporary Spilman unidirectional time-bound channel.
> We just reuse the same timelock on the HTLC we expect to instantiate, as the time bound of the Spilman channel; the timelock exists anyway, we might as well reuse it for the Spilman.
> 
> Creation of the contract tx invalidates the backout tx (the backout tx is `nLockTime`d, the contract tx has no such encumbrance), but the backout allows Alice and Bob to fund their txes simultaneously without risk of race loss.
> However, they do still have to wait for (deep) confirmation before signing contract transactions, and Bob has to wait for the incoming contract transaction as well before it signs its outgoing contract transaction.
> 
> The protocol is trivially extendable with more than one Bob.
> 
> The insight basically is that we can split CoinSwap into a "channel establishment" phase and "HTLC forwarding" phase followed by "HTLC resolution" and "private key handover".
> HTLC forwarding and HTLC resolution are "done offchain" in the channels, and channel establishment can be done in any order, including reverse.
> 
> Indeed, the Spilman channel need not have the same timelock as the HTLC it will eventually host: it could have a shorter timelock, since the contract transaction has no `nLockTime` it can be instantiated (with loss of privacy due to the nonstandard script) before the Spilman timeout.
> 
> Regards,
> ZmnSCPxj
> 

Thanks for the explanation. I understand now, and I understand how this
makes it possible for all funding transactions in a coinswap route to be
confirmed in the same block.

However, I think this also breaks private key handover. Here's why:

Recall that in a Alice/Bob coinswap we have two funding transactions
(Alice --> multisig(Alice, Bob) and Bob --> multisig(Bob,Alice)), and
two contract transactions (multisig(Alice, Bob) -->
Alice+OP_CSV_timelock OR Bob+hashlock and multisig(Bob,Alice -->
Bob+OP_CSV_timelock OR Alice+hashlock). After the hashlock preimage
becomes known to all then Alice and Bob give their multisig privkey to
the other party.

Bob now has both privkeys in the multisig(Alice,Bob) so he can sign any
transaction he wants spending from it, but the contract transaction
still exists. So until Bob actually spends from the multisig he must
always be watching the blockchain, and if Alice broadcasts the contract
transaction then Bob must immediately spend from it using the hash
preimage branch. If Bob waits too long and the OP_CSV timelock value
passes then Alice can steal Bob's money by spending with that path. The
OP_CSV timelock only starts ticking when the contract transaction
actually confirms, and this is crucial for making privkey handover
practical because it means the coins in the multisig can stay unspent
indefinitely.

However, I think this does not apply to the scheme you described which
uses nLockTime, because after the privkeys are handed over Alice's
backout transaction (Alice+Bob -(nLockTime=locktime1)-> Alice) still
exists, and Alice could broadcast it. Once locktime1 passes then Alice
can steal Bob's coins by broadcasting even though Bob holds both
privkeys to that multisig. And using relative nLockTime doesn't help
either because its timelock will start ticking down from when the
funding transaction is confirmed, not when the contract transaction is
confirmed, and so the coins in the multisig cant remain unspent
indefinitely.

So fundamentally I think privkey handover gets broken here because it
requires relative timelocks. And those the relative timelocks need to
start ticking down only after a contract transaction is confirmed.


> I am uncertain if you are aware, but some years ago somebody claimed that 2p-ECDSA could use Scriptless Script as well over on lightning-dev.

I was aware. In such a scheme we'd still require the other building
blocks like fidelity bonds, multi-transaction and routing. So I was
thinking to code the project using the simplest hash-time-locked
contracts and once it all works we can add things like ECDSA-2P
scriptless scripts or schnorr signatures when they get added. Making the
Spilman channel scheme work with that is an interesting idea, thanks for
the thought.

> Let me propose an alternative: swap-on-receive+swap-on-change.

That's an interesting point, thanks for the thought. This scheme might
not be appropriate for every threat model and use case.
For example, if someone wants to use bitcoin just as a foreign currency
for its privacy and censorship-resistant properties. So for example if
they want to pay for a VPN anonymously, so they buy bitcoins and
immediately send all of them to the VPN merchant. The swap-on-receive
wouldn't be appropriate for them because they'll be doing a coinswap
straight away to the VPN merchant. So perhaps this plan could be an
optional mode of operation (which may or may not be the default). The
scheme obviously is useful when bitcoin is being used more as a
day-to-day money.


Regards
CB



From ZmnSCPxj at protonmail.com  Wed Jun 10 10:58:03 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 10 Jun 2020 10:58:03 +0000
Subject: [bitcoin-dev] Design for a CoinSwap implementation for
	massively improving Bitcoin privacy and fungibility
In-Reply-To: <27f05cf1-08b2-a281-75b7-5c035317d030@riseup.net>
References: <82d90d57-ad07-fc7d-4aca-2b227ac2068d@riseup.net>
 <CAPv7TjY9h8n-nK_CPiYCWYDcbXpT1gfRMQDgf9VUkcR532rxOw@mail.gmail.com>
 <VxL93WE7bDrK1riquTWTTEgJj9mDQ4W5CuhOgdnnDPeidw2ho6evVh4cLZLz0jEYMqejaD1tiLULVTXkNRbI5A7wSwV49qSwnXcTWCDJ96E=@protonmail.com>
 <cbf78f63-cf8c-c5d8-06ea-afc79aabc23c@riseup.net>
 <5LiZqpFxklAAbGFiiAE3ijRbIteODXKcHrXvGJ-qabgQj5hG8beFtHNbVZ-XUxETVwduJYz94UYuJGAPxBrbGeZpSClUtXYsPJBABfr03KM=@protonmail.com>
 <e724b4c5-9efd-66c4-163b-492f17cafd7d@riseup.net>
 <Sy14DpcFGdAYL95d7e6tfkOe87oY53tJReo9CYvPT5J3Gb85AqedMheq1NbfVKUXZtZrwZqwVV4wSztikgWBAgNfTh8J5h5gXC6HDMxvsNg=@protonmail.com>
 <27f05cf1-08b2-a281-75b7-5c035317d030@riseup.net>
Message-ID: <NWnynWUGBlIOhDRYr50kwUc1NK_h-I5tM5q1rjONrC5DTBPFlzYSr1DbmaE4jZOkFB1FtToeZfE2CegIDVJ_6NMezvzcQJ7U3DXFs4yFv0c=@protonmail.com>

Good morning Chris,

> > Let me propose an alternative: swap-on-receive+swap-on-change.
>
> That's an interesting point, thanks for the thought. This scheme might
> not be appropriate for every threat model and use case.
> For example, if someone wants to use bitcoin just as a foreign currency
> for its privacy and censorship-resistant properties. So for example if
> they want to pay for a VPN anonymously, so they buy bitcoins and
> immediately send all of them to the VPN merchant. The swap-on-receive
> wouldn't be appropriate for them because they'll be doing a coinswap
> straight away to the VPN merchant. So perhaps this plan could be an
> optional mode of operation (which may or may not be the default). The
> scheme obviously is useful when bitcoin is being used more as a
> day-to-day money.


No, I think you misunderstand my proposal.

If the user is doing swap-on-receive, the user already has an anonymous UTXO, they can just transfer it directly in full to the VPN without using a CoinSwap.

The number of CoinSwaps involved is the same: one.

So the difference is:

* swap-on-receive:
  * I get some coins from an exchange, giving them my contact information and bank information and all the places I have ever inhabited in my entire existence and an unfertilized egg sample and an archive of my diary and let them invasively scan my cognitive substrate.
  * I send the coins to my CoinSwap wallet.
  * The CoinSwap wallet automaticaly CoinSwaps the coins into a new UTXO.
    * One CoinSwap.
  * I tell the CoinSwap wallet to send it all to the VPN.
    * My CoinSwap wallet knows my coins are already cleaned, so it creates a plain 1-input 1-output transaction directly to the VPN address.

* swap-on-pay:
  * I get some coins from an exchange, giving them my contact information and bank information and all the places I have ever inhabited in my entire existence and an unfertilized egg sample and an archive of my diary and let them invasively scan my cognitive substrate.
  * I send the coins to my CoinSwap wallet.
  * I tell the CoinSwap wallet to send it all to the VPN.
    * My CoinSwap wallet automatically arranges a CoinSwap into the VPN address.
      * One CoinSwap.

So in both cases the same expected number of CoinSwaps is done, i.e. one.

Note that there are still details like how much onchain fees are and how much CoinSwap maker fees are and etc etc but they exist for both flows anyway.
So I would still be buying slightly more than my target amount, and if there is any change I could just designate it to be added to the mining fees or a donation to ZmnSCPxj, because ZmnSCPxj is so awesome.

What swap-on-receive+swap-on-change instead does is just amortize the timing of the CoinSwaps, so that you CoinSwap as soon as you receive, instead of as soon as you have to pay, so that sending payments is as fast as non-CoinSwap onchain wallets.


Regards,
ZmnSCPxj

From belcher at riseup.net  Wed Jun 10 11:15:03 2020
From: belcher at riseup.net (Chris Belcher)
Date: Wed, 10 Jun 2020 12:15:03 +0100
Subject: [bitcoin-dev] Design for a CoinSwap implementation for
 massively improving Bitcoin privacy and fungibility
In-Reply-To: <5b77933071fa02e900183d8d5e24d866.squirrel@giyzk7o6dcunb2ry.onion>
References: <82d90d57-ad07-fc7d-4aca-2b227ac2068d@riseup.net>
 <5b77933071fa02e900183d8d5e24d866.squirrel@giyzk7o6dcunb2ry.onion>
Message-ID: <aa5174d1-08d9-fc32-4c83-7d43c9f47531@riseup.net>

Hello Lee,

Thanks for the review.

On 10/06/2020 01:43, Mr. Lee Chiffre wrote:
> 
>>
>> === Combining multi-transaction with routing ===
>>
>> Routing and multi-transaction must be combined to get both benefits. If
>> Alice owns multiple UTXOs (of value 6 BTC, 8 BTC and 1 BTC) then this is
>> easy with this configuration:
>>
>>              Alice
>>     (6 BTC) (8 BTC) (1 BTC)
>>        |       |       |
>>        |       |       |
>>        v       v       v
>>               Bob
>>     (5 BTC) (5 BTC) (5 BTC)
>>        |       |       |
>>        |       |       |
>>        v       v       v
>>             Charlie
>>     (9 BTC) (5 BTC) (1 BTC)
>>        |       |       |
>>        |       |       |
>>        v       v       v
>>             Dennis
>>     (7 BTC) (4 BTC) (4 BTC)
>>        |       |       |
>>        |       |       |
>>        v       v       v
>>              Alice
>>
> 
> 
> 
> 
> 
> 
> Great work Chris and you have my respects for your contributions to
> Bitcoin. A concern I have with bitcoin is scalability and privacy. Both
> are important. The reasons people bash on Monero is also the same issue
> Bitcoin has. The very large transaction size to achieve acceptable privacy
> on a distributed financial network. Im not shilling Monero here. I am only
> saying that bitcoin transactions with similar privacy properties are at
> least equally as large as Monero transactions. Coinjoin on Monero can be
> compared to ring signatures in Monero from the view of using decoys to
> help conceal the source. From this proposal is this to say that
> transactions will be at least 12 times larger in size to achieve the
> property of privacy that bitcoin is currently missing?
> 
> Another thing to consider is that if coinswaps cannot be sent as a payment
> then a coinswap needs to take place after every transaction to keep the
> privacy and unlinkability from your other bitcoin transactions.
> 
> I always thought that CoinSwap would be and is a very much needed thing
> that needs developed. The ability to swap coins with other people in a
> trustless way and way that is not linkable to the public blockchain. But
> how can this be scalable at all with the multiple branches and layers?
> This is a good idea in theory but my concern would be the scalability
> issues this creates.
> 
> Do you have any comments on this?
> Thank you
> 

You are right to be concerned about scalability.

Here's a few of my thoughts on this:

An issue with Monero (or any cryptocurrency based on the ring signature
input signing scheme) isn't just that transactions are bigger in bytes.
Monero full nodes can't know when a TXO has been spent, so pruning is
impossible in Monero and the list of TXOs perpetually grows, this is
unlike in bitcoin where full nodes know if a UTXO has been spent and so
can delete it in pruning. The storage space needed for Bitcoin's UTXO
set sometimes actually gets smaller.

Note that Monero software actually has a feature called "pruning" so
sometimes the terminology gets confused when people say "wait, Monero
_does_ have pruning". But this pruning doesn't do the same thing as
Bitcoin's pruning, the disk space still grows as O(TXOcount) which is
much faster compared to Bitcoin's O(UTXOcount).

And when designing this CoinSwap system I've been careful to make sure
it doesn't break pruning (or other resources saving features, for
example CoinSwap can be made to work with the blocksonly feature of
Bitcoin Core). So bitcoin-with-CoinSwap's scalability isnt anywhere near
as bad as Monero's.

You're right to talk about decoys. Decoys are not a good way to obtain
privacy because they can be broken by repeated interactions.. I really
like this talk about why decoys are not a good solution to privacy in
many cases:

talk: https://www.youtube.com/watch?v=YgtF7psIKWg&feature=youtu.be&t=3701
transcript:
https://tokyo2018.scalingbitcoin.org/transcript/tokyo2018/how-much-privacy-is-enough

Equal-output CoinJoins also work with decoys. Like in JoinMarket you
could analyze those CoinJoins to say that the inputs and outputs of the
makers in a CoinJoin are actually just decoys. Fixed-denomination
CoinJoins like in Wasabi or Samourai also use much more block space
because of the reduced divisibility, for example Wasabi coinjoins can
only be done with about 0.1 BTC, so if you want to mix 1 BTC then you
have to do 10 such CoinJoins, costing 10 times the block space.

CoinSwap doesn't work by adding decoys, it improves privacy in the same
way as Lightning: by moving information off-chain.

You could perhaps analyze CoinSwap as using decoys if you say that the
decoys are almost every other bitcoin transaction happening on the
blockchain, and that can be almost as big as you want. One full block
has about 3000 outputs, so if you wait a day between the CoinSwap
funding and spending transactions then that's 144*3000 = 432000 decoys
(this calculation is simplified, but it's a good starting point). If
CoinJoin or Monero transactions had that many decoys they would be
hundreds of MB each.


Because CoinSwap transactions can look exactly the same as regular
transactions, they would improve the privacy of users even if they don't
use CoinSwap.

So on twitter sometimes I see people talking about "making every spend a
CoinJoin". The suggestion would be very costly in block space, and isn't
necessary for CoinSwap. I think perhaps 5% of transactions being
CoinSwaps or PayJoin-with-CoinSwap (as long as they were spread roughly
equally across the economy) would be enough to destroy the transaction
graph heuristic and common-input-ownership heuristic. Then anyone
analyzing the blockchain couldn't be sure when they see coins going from
address A to B that the ownership actually went from A to B, or that if
they see multiple inputs they don't know whether those inputs are
actually owned by the same entity.

Also, CoinSwaps could be used as payment. For example take this 1-hop
CoinSwap where Alice owns 10 BTC and wants to deposit 5 BTC into her
exchange account.

      (3 BTC) -->     (5 BTC) --> Exchange
Alice (1 BTC) --> Bob (4 BTC) --> Alice change1
      (6 BTC) -->     (1 BTC) --> Alice change2

So on the last hop Alice sends 5 BTC as payment to the exchange (to
deposit) and the remaining outputs go back to Alice as change. The
exchange can't see Alice's UTXOs that she just spent, and also can't see
Alice's change outputs.


Additionally, even in the example you use where 12 times as much block
space is used as normal, this is still cheaper than Equal-Output
Coinjoins. For example with JoinMarket a single CoinJoin is
approximately 12 times bigger than a regular bitcoin transaction, and to
get good privacy using JoinMarket's tumbler algorithm the user typically
creates 7-15 of those CoinJoins. And even then those CoinJoins are very
obvious and don't improve the privacy of people who don't use them,
meaning we have to advocate the expensive and impractical slogan "make
every spend a CoinJoin". And they also don't provide as much privacy as
CoinSwap would, because their anonymity set is smaller than CoinSwap's.


Finally, we know that blockchains don't scale, and so its widely
expected that most day-to-day bitcoin transactions will happen off-chain
on something like Lightning network, which also brings us privacy.
CoinSwap then is mostly useful for the situations where on-chain
transfers are still needed, and also because good on-chain privacy is
necessary for Lightning to really be private, because otherwise the
on-chain channel UTXOs can be tracked.





From belcher at riseup.net  Wed Jun 10 11:19:53 2020
From: belcher at riseup.net (Chris Belcher)
Date: Wed, 10 Jun 2020 12:19:53 +0100
Subject: [bitcoin-dev] Design for a CoinSwap implementation for
 massively improving Bitcoin privacy and fungibility
In-Reply-To: <NWnynWUGBlIOhDRYr50kwUc1NK_h-I5tM5q1rjONrC5DTBPFlzYSr1DbmaE4jZOkFB1FtToeZfE2CegIDVJ_6NMezvzcQJ7U3DXFs4yFv0c=@protonmail.com>
References: <82d90d57-ad07-fc7d-4aca-2b227ac2068d@riseup.net>
 <CAPv7TjY9h8n-nK_CPiYCWYDcbXpT1gfRMQDgf9VUkcR532rxOw@mail.gmail.com>
 <VxL93WE7bDrK1riquTWTTEgJj9mDQ4W5CuhOgdnnDPeidw2ho6evVh4cLZLz0jEYMqejaD1tiLULVTXkNRbI5A7wSwV49qSwnXcTWCDJ96E=@protonmail.com>
 <cbf78f63-cf8c-c5d8-06ea-afc79aabc23c@riseup.net>
 <5LiZqpFxklAAbGFiiAE3ijRbIteODXKcHrXvGJ-qabgQj5hG8beFtHNbVZ-XUxETVwduJYz94UYuJGAPxBrbGeZpSClUtXYsPJBABfr03KM=@protonmail.com>
 <e724b4c5-9efd-66c4-163b-492f17cafd7d@riseup.net>
 <Sy14DpcFGdAYL95d7e6tfkOe87oY53tJReo9CYvPT5J3Gb85AqedMheq1NbfVKUXZtZrwZqwVV4wSztikgWBAgNfTh8J5h5gXC6HDMxvsNg=@protonmail.com>
 <27f05cf1-08b2-a281-75b7-5c035317d030@riseup.net>
 <NWnynWUGBlIOhDRYr50kwUc1NK_h-I5tM5q1rjONrC5DTBPFlzYSr1DbmaE4jZOkFB1FtToeZfE2CegIDVJ_6NMezvzcQJ7U3DXFs4yFv0c=@protonmail.com>
Message-ID: <d80b7ab5-d5f8-2289-ddf3-ffa7bbc6e5da@riseup.net>

Hello ZmnSCPxj,

On 10/06/2020 11:58, ZmnSCPxj wrote:
> Good morning Chris,
> 
>>> Let me propose an alternative: swap-on-receive+swap-on-change.
>>
>> That's an interesting point, thanks for the thought. This scheme might
>> not be appropriate for every threat model and use case.
>> For example, if someone wants to use bitcoin just as a foreign currency
>> for its privacy and censorship-resistant properties. So for example if
>> they want to pay for a VPN anonymously, so they buy bitcoins and
>> immediately send all of them to the VPN merchant. The swap-on-receive
>> wouldn't be appropriate for them because they'll be doing a coinswap
>> straight away to the VPN merchant. So perhaps this plan could be an
>> optional mode of operation (which may or may not be the default). The
>> scheme obviously is useful when bitcoin is being used more as a
>> day-to-day money.
> 
> 
> No, I think you misunderstand my proposal.
> 
> If the user is doing swap-on-receive, the user already has an anonymous UTXO, they can just transfer it directly in full to the VPN without using a CoinSwap.
> 
> The number of CoinSwaps involved is the same: one.
> 
> So the difference is:
> 
> * swap-on-receive:
>   * I get some coins from an exchange, giving them my contact information and bank information and all the places I have ever inhabited in my entire existence and an unfertilized egg sample and an archive of my diary and let them invasively scan my cognitive substrate.
>   * I send the coins to my CoinSwap wallet.
>   * The CoinSwap wallet automaticaly CoinSwaps the coins into a new UTXO.
>     * One CoinSwap.
>   * I tell the CoinSwap wallet to send it all to the VPN.
>     * My CoinSwap wallet knows my coins are already cleaned, so it creates a plain 1-input 1-output transaction directly to the VPN address.
> 
> * swap-on-pay:
>   * I get some coins from an exchange, giving them my contact information and bank information and all the places I have ever inhabited in my entire existence and an unfertilized egg sample and an archive of my diary and let them invasively scan my cognitive substrate.
>   * I send the coins to my CoinSwap wallet.
>   * I tell the CoinSwap wallet to send it all to the VPN.
>     * My CoinSwap wallet automatically arranges a CoinSwap into the VPN address.
>       * One CoinSwap.
> 
> So in both cases the same expected number of CoinSwaps is done, i.e. one.
> 
> Note that there are still details like how much onchain fees are and how much CoinSwap maker fees are and etc etc but they exist for both flows anyway.
> So I would still be buying slightly more than my target amount, and if there is any change I could just designate it to be added to the mining fees or a donation to ZmnSCPxj, because ZmnSCPxj is so awesome.
> 
> What swap-on-receive+swap-on-change instead does is just amortize the timing of the CoinSwaps, so that you CoinSwap as soon as you receive, instead of as soon as you have to pay, so that sending payments is as fast as non-CoinSwap onchain wallets.
> 
> 
> Regards,
> ZmnSCPxj
> 

Right, I get it. Good explanation.

In your swap-on-receive example the exchange also can't tell how long
your coins remain unspent in your wallet, which they could in
swap-on-pay. This is very useful information for an exchange because it
tells them about what hodlers are doing, and they might trade against
them. (e.g. opening big short positions right after they see many long
term hodl'd coins being moved)


From adam.ficsor73 at gmail.com  Wed Jun 10 12:32:05 2020
From: adam.ficsor73 at gmail.com (nopara73)
Date: Wed, 10 Jun 2020 14:32:05 +0200
Subject: [bitcoin-dev] Tainting, CoinJoin, PayJoin, CoinSwap
Message-ID: <CAEPKjgfbQoXkB=cEp5Jc28ZihRSQe50M2x7k6=AjW+Vo5f=79g@mail.gmail.com>

The problem with CoinJoins is that desire for privacy is explicitly
signalled by them, so adversaries can consider them "suspicious." PayJoin
and CoinSwap solve this problem, because they are unnoticeable. I think
this logic doesn't stand for scrutiny.

>From here on let's use the terminology of a typical adversary: there are 3
kinds of coin histories: "clean", "dirty" and "suspicious".
The aftermath of you using a "dirty" coin is knocks on your door. You using
a "suspicious" coin is uncomfortable questions and you using a "clean" coin
is seamless transfer.

In scenario 1, you start out with a "clean" history. By using CoinJoins you
make your new coin's history "suspicious" so you have no incentive to
CoinJoin. By using CoinSwap/PayJoin your new coin can be either "clean" or
"dirty". What would a "clean" coin owner prefer more? Take the risk of
knocking on the door or answering uncomfortable questions?

In scenario 2, you start out with a "dirty" history. By using CoinJoins you
make your new coin's history "suspicious" so you have an incentive to
CoinJoin. By using CoinSwap/PayJoin your new coin can either be "clean" or
"dirty". What would a "dirty" coin owner prefer more? And here's an
insight: you may get knocks on your door for a dirty coin that you have
nothing to do with. And you can prove this fact to the adversary, but by
doing so, you'll also expose that you started out with a "dirty" coin to
begin with and now the adversary becomes interested in you for a different
reason.

You can also examine things assuming full adoption of PJ/CS vs full
adoption of CJ, but you'll see that full adoption of any of these solves
the tainting issue.

So my current conclusion is that PJ/CS does not only not solve the taint
problem, it just alters it and ultimately very similar problems arise for
the users. Maybe the goal of unobservable privacy is a fallacy in this
context as it is based on the assumption that desiring privacy is
suspicious, so you want to hide the fact that you desire privacy. And the
solution to the taint issue is either protocol change or social change
(decent adoption.)

PS.: Please try to keep the conversation to the Taint Issue as this email
of mine isn't supposed to be discussing general pros and cons of various
privacy techniques.

Any thoughts?

-- 
Best,
?d?m
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200610/ab707108/attachment.html>

From gsanders87 at gmail.com  Wed Jun 10 13:48:55 2020
From: gsanders87 at gmail.com (Greg Sanders)
Date: Wed, 10 Jun 2020 09:48:55 -0400
Subject: [bitcoin-dev] Tainting, CoinJoin, PayJoin, CoinSwap
In-Reply-To: <CAEPKjgfbQoXkB=cEp5Jc28ZihRSQe50M2x7k6=AjW+Vo5f=79g@mail.gmail.com>
References: <CAEPKjgfbQoXkB=cEp5Jc28ZihRSQe50M2x7k6=AjW+Vo5f=79g@mail.gmail.com>
Message-ID: <CAB3F3DtceGQmyJzEzXHuYVrGtNE3ASq1=Sq6Bps0hE+wn7Dy5w@mail.gmail.com>

A major point of defeating the common input heuristic and others is to make
"super-clusters". A small number of users that "don't care" about possibly
touching tainted coins can render many chain analysis techniques unworkable
in practice for enforcement. You don't need 100% coverage to defeat the
heuristic.

On Wed, Jun 10, 2020 at 9:40 AM nopara73 via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> The problem with CoinJoins is that desire for privacy is explicitly
> signalled by them, so adversaries can consider them "suspicious." PayJoin
> and CoinSwap solve this problem, because they are unnoticeable. I think
> this logic doesn't stand for scrutiny.
>
> From here on let's use the terminology of a typical adversary: there are 3
> kinds of coin histories: "clean", "dirty" and "suspicious".
> The aftermath of you using a "dirty" coin is knocks on your door. You
> using a "suspicious" coin is uncomfortable questions and you using a
> "clean" coin is seamless transfer.
>
> In scenario 1, you start out with a "clean" history. By using CoinJoins
> you make your new coin's history "suspicious" so you have no incentive to
> CoinJoin. By using CoinSwap/PayJoin your new coin can be either "clean" or
> "dirty". What would a "clean" coin owner prefer more? Take the risk of
> knocking on the door or answering uncomfortable questions?
>
> In scenario 2, you start out with a "dirty" history. By using CoinJoins
> you make your new coin's history "suspicious" so you have an incentive to
> CoinJoin. By using CoinSwap/PayJoin your new coin can either be "clean" or
> "dirty". What would a "dirty" coin owner prefer more? And here's an
> insight: you may get knocks on your door for a dirty coin that you have
> nothing to do with. And you can prove this fact to the adversary, but by
> doing so, you'll also expose that you started out with a "dirty" coin to
> begin with and now the adversary becomes interested in you for a different
> reason.
>
> You can also examine things assuming full adoption of PJ/CS vs full
> adoption of CJ, but you'll see that full adoption of any of these solves
> the tainting issue.
>
> So my current conclusion is that PJ/CS does not only not solve the taint
> problem, it just alters it and ultimately very similar problems arise for
> the users. Maybe the goal of unobservable privacy is a fallacy in this
> context as it is based on the assumption that desiring privacy is
> suspicious, so you want to hide the fact that you desire privacy. And the
> solution to the taint issue is either protocol change or social change
> (decent adoption.)
>
> PS.: Please try to keep the conversation to the Taint Issue as this email
> of mine isn't supposed to be discussing general pros and cons of various
> privacy techniques.
>
> Any thoughts?
>
> --
> Best,
> ?d?m
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200610/5f548ea7/attachment.html>

From belcher at riseup.net  Wed Jun 10 17:49:16 2020
From: belcher at riseup.net (Chris Belcher)
Date: Wed, 10 Jun 2020 18:49:16 +0100
Subject: [bitcoin-dev] Question about PayJoin effectiveness
In-Reply-To: <7c0dc46538f96032596163c4a9f03dc2.squirrel@giyzk7o6dcunb2ry.onion>
References: <7c0dc46538f96032596163c4a9f03dc2.squirrel@giyzk7o6dcunb2ry.onion>
Message-ID: <2b0d2414-49d8-8a11-0934-170601b09a74@riseup.net>

On 10/06/2020 05:01, Mr. Lee Chiffre via bitcoin-dev wrote:
> I am trying to learn about payjoin. I have a couple concerns on its
> effectiveness. Are my concerns valid or am I missing something?
> 
> concern 1
> If it is known to be a payjoin transaction anyone could determine the
> sender the recipient and amount right?
> 
> Lets assume that everyone has a single utxo because payjoin becomes common
> use and payjoin consolidates utxos through "snowballing". If Alice has a
> UTXO of 0.05 btc and Bob has a UTXO of 1.15 btc. Bob can be assumed to
> have more balance because he is a merchant and his customers payjoin him
> payments alot.
> 
> If Alice and Bob do a payjoin with Alice paying 0.01 btc to Bob, it would
> probably look like this right?
> 
>  0.05---> |____---->1.16
>  1.15---> |    ---->0.04
> 
> It is very obvious here the amount sent and the sender.  Even if Alice did
> combine another input it would still be very obvious. In this case Alice
> has another utxo with 0.4 BTC
> 
>  0.40---> |
>  0.05---> |____---->1.16
>  1.15---> |    ---->0.44
> 
> This is still obvious that Alice paid Bob 0.01 BTC isn't it?
> 
> 
> 
> concern 2
> If there is just one consolidated utxo after each payjoin, would it  be
> easy to break the privacy of transaction chains?
> 
> Alice---payjoin--->Bob
> Clark---payjoin--->Bob
> 
> or
> 
> Alice---payjoin--->Bob---payjoin--->Clark
> 
> For exmaple, lets say that Alice payjoins to Bob. Then later on Clark
> payjoins with Bob. Based on the payjoin between Clark and Bob, Clark now
> knows what UTXO was actually Bob's. And can then know which one was
> actually Alices. By transacting a payjoin with someone, they could decloak
> the payjoins before them right? If so, how far back the chain can they go?
> 
> The issue is not that someone knows the utxos of themselves and the entity
> they payjoined with. The issue is that someone can figure out the payjoins
> of others before them with the same entity.
> 
> 
> I surely must be missing something here. What am I not understanding?
> 

Adding to what other people have written, it's an important point that
PayJoin breaks the common-input-ownership heuristic. I.E. if PayJoins
become even moderately popular then it will no longer be a safe
assumption that all the inputs to a transaction are owned by the same
entity (taking away all the obvious breaks like equal-output-coinjoins).

This assumption is a huge reason why blockchain surveillance is so
effective. A good paper on that is here:
https://arxiv.org/abs/1605.06369 (The Unreasonable Effectiveness of
Address Clustering Harrigan, Martin & Fretter, Christoph. (2016))

The assumption is mentioned by Satoshi in the whitepaper where he
laments that the privacy loss is unavoidable. (One of the few outright
errors in the paper, perhaps the only error). The fact that we have
technology to break this assumption is a massive deal, and that's a big
value-add of PayJoin.


From belcher at riseup.net  Wed Jun 10 20:10:19 2020
From: belcher at riseup.net (Chris Belcher)
Date: Wed, 10 Jun 2020 21:10:19 +0100
Subject: [bitcoin-dev] Tainting, CoinJoin, PayJoin, CoinSwap
In-Reply-To: <CAEPKjgfbQoXkB=cEp5Jc28ZihRSQe50M2x7k6=AjW+Vo5f=79g@mail.gmail.com>
References: <CAEPKjgfbQoXkB=cEp5Jc28ZihRSQe50M2x7k6=AjW+Vo5f=79g@mail.gmail.com>
Message-ID: <e7ab27e5-e235-f6a2-5023-1cdda5c12d0b@riseup.net>

Hello nopara73,

On 10/06/2020 13:32, nopara73 via bitcoin-dev wrote:
> The problem with CoinJoins is that desire for privacy is explicitly
> signalled by them, so adversaries can consider them "suspicious." PayJoin
> and CoinSwap solve this problem, because they are unnoticeable. I think
> this logic doesn't stand for scrutiny.
> 
>>From here on let's use the terminology of a typical adversary: there are 3
> kinds of coin histories: "clean", "dirty" and "suspicious".
> The aftermath of you using a "dirty" coin is knocks on your door. You using
> a "suspicious" coin is uncomfortable questions and you using a "clean" coin
> is seamless transfer.
> 
> In scenario 1, you start out with a "clean" history. By using CoinJoins you
> make your new coin's history "suspicious" so you have no incentive to
> CoinJoin. By using CoinSwap/PayJoin your new coin can be either "clean" or
> "dirty". What would a "clean" coin owner prefer more? Take the risk of
> knocking on the door or answering uncomfortable questions?
> 
> In scenario 2, you start out with a "dirty" history. By using CoinJoins you
> make your new coin's history "suspicious" so you have an incentive to
> CoinJoin. By using CoinSwap/PayJoin your new coin can either be "clean" or
> "dirty". What would a "dirty" coin owner prefer more? And here's an
> insight: you may get knocks on your door for a dirty coin that you have
> nothing to do with. And you can prove this fact to the adversary, but by
> doing so, you'll also expose that you started out with a "dirty" coin to
> begin with and now the adversary becomes interested in you for a different
> reason.
> 
> You can also examine things assuming full adoption of PJ/CS vs full
> adoption of CJ, but you'll see that full adoption of any of these solves
> the tainting issue.
> 
> So my current conclusion is that PJ/CS does not only not solve the taint
> problem, it just alters it and ultimately very similar problems arise for
> the users. Maybe the goal of unobservable privacy is a fallacy in this
> context as it is based on the assumption that desiring privacy is
> suspicious, so you want to hide the fact that you desire privacy. And the
> solution to the taint issue is either protocol change or social change
> (decent adoption.)
> 
> PS.: Please try to keep the conversation to the Taint Issue as this email
> of mine isn't supposed to be discussing general pros and cons of various
> privacy techniques.
> 
> Any thoughts?
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

There are two concepts here: Taint analysis and the detectableness of
privacy protocols.

Taint analysis is quite an old technique, I remember seeing the
blockchain.info explorer having a tool for calculating a value for taint
back in 2013, long before any widely-used CoinJoin implementations were
created. I think taint was first created to attack the privacy technique
of simply sending coins to yourself multiple times. If those coins were
for example stolen from an exchange's hot wallet then the taint between
the exchange addresses and the later addresses would still be 100% even
if the thief sent the coins to himself multiple times.

A very important point is that it's difficult to reason about taint
analysis algorithms because they are often hypothetical, likely
closed-source, not available to the public for review and changing all
the time. OP talks about the three categories "clean", "dirty" and
"suspicious" which is one possibility. I've read about other taint
analysis algorithms which result in a numerical score out of 100.
Blockchain.info's algorithm calculated taint as a number expressing the
relation between any two addresses, so it wouldn't make sense to say "an
address" is tainted, instead you have to talk about a pair of addresses
being tainted with each other. So even though it's hard to reason about
the exact algorithm we can still talk about likely situations, and
imagine what an adversary could do in the worst case or best case.

One way to resist a likely taint analysis attack is to involve other
parts of the bitcoin economy in your transactions. For example our
exchange thief could deposit and then withdraw his stolen coins through
a Bitcoin Casino or other bitcoin service hot wallet. His coins might no
longer be 100% tainted from the exchange hack but perhaps have 5%
exchange hack, 5% bitcoin ATM, 5% mined coins, etc etc. The numbers are
made up and they depend on the exact algorithm but the main point is
that involving the rest of the bitcoin economy in your transaction is
one practical way to stop taint analysis being a useful attack against
on you.

Another important point is that taint isn't part of bitcoin's code
anywhere. It is an external reality that surveillance companies impose
on users. The only reason taint has any influence is because of
censorship, for example an exchange which uses the services of a
surveillance company has the power to freeze funds (i.e. censor a
transaction) if they believe the user's deposit transaction is tainted.

Therefore a way to resist the taint analysis attack is to actually use
bitcoin as money, I.E. earn bitcoin, spend it with merchants, who then
spend it with other merchants or pay their employees, where most
entities along those links actually dont use a taint analysis algorithm.
This is a general principle of bitcoin privacy by the way, if every
entry- and exit-point requires giving up personal information then
privacy is dead, regardless of whether we use
CoinJoin/PayJoin/CoinSwap/whatever in between.
This is a good place to again shill this list of peer-to-peer exchanges:
https://github.com/cointastical/P2P-Trading-Exchanges/

So that's taint.

Now for privacy protocols like CoinJoin. They also involve the rest of
the bitcoin economy, because many different users link their coins
together when using CoinJoin/PayJoin/CoinSwap/etc, so such protocols can
be a way to resist taint analysis too just like the Bitcoin Casino
mentioned earlier.

However, what I think OP is talking about is the case where taint
algorithms are reprogrammed to not just track exchange hack addresses,
but also track privacy protocol transactions. So for example if the
hypothetical taint algorithm comes across an Equal-Output CoinJoin it
will assign it a different taint score even if its not linked to an
exchange hack or anything like that.

Such a reprogramming wouldn't be possible in undetectable privacy
protocols like PayJoin and CoinSwap. They will have the economy-mixing
effect of reducing taint (just like the Bitcoin Casino example above),
but as OP writes that can just lead to the wrong person being under
suspicion. And so such protocols on their own cant resist taint analysis
forever, which is the point is OP making as well.

The only permanent solution to taint analysis as I've mentioned is to
use bitcoin as money, away from centralized choke points that can censor
transactions and demand personal information. It's worth pointing out
that using bitcoin as money wont help our exchange hacker much, this
hacker will never be able to buy mansions or sports cars with their
stolen bitcoin, because the authorities already require proof of the
origin of funds before, for example, buying a big mansion.

Nonetheless, unobservable privacy is also useful for other reasons than
resisting taint analysis:

* It improves the privacy of people who do not use it.
* It helps stops censorship of privacy protocols (I.E. miners could one
day refuse to mine equal-output CoinJoin transactions but still mine
regular transactions)
* It typically uses less block space, because information is removed
from the blockchain rather than adding to the blockchain.


Regards

Chris Belcher

From ZmnSCPxj at protonmail.com  Wed Jun 10 23:01:46 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 10 Jun 2020 23:01:46 +0000
Subject: [bitcoin-dev] Tainting, CoinJoin, PayJoin, CoinSwap
In-Reply-To: <e7ab27e5-e235-f6a2-5023-1cdda5c12d0b@riseup.net>
References: <CAEPKjgfbQoXkB=cEp5Jc28ZihRSQe50M2x7k6=AjW+Vo5f=79g@mail.gmail.com>
 <e7ab27e5-e235-f6a2-5023-1cdda5c12d0b@riseup.net>
Message-ID: <HOE_CSoWptTdBQtIqu4GTe0LlDZtnS1jEBUEf4H-wFlD7Il0-y8TikYWxGc2DPYYErJPMePIuwIO752TyNfIleKYPrkDzLQFh2l6FAKo6jU=@protonmail.com>

Good morning nopara73 and Chris,


> One way to resist a likely taint analysis attack is to involve other
> parts of the bitcoin economy in your transactions. For example our
> exchange thief could deposit and then withdraw his stolen coins through
> a Bitcoin Casino or other bitcoin service hot wallet. His coins might no
> longer be 100% tainted from the exchange hack but perhaps have 5%
> exchange hack, 5% bitcoin ATM, 5% mined coins, etc etc. The numbers are
> made up and they depend on the exact algorithm but the main point is
> that involving the rest of the bitcoin economy in your transaction is
> one practical way to stop taint analysis being a useful attack against
> on you.
>
> Another important point is that taint isn't part of bitcoin's code
> anywhere. It is an external reality that surveillance companies impose
> on users. The only reason taint has any influence is because of
> censorship, for example an exchange which uses the services of a
> surveillance company has the power to freeze funds (i.e. censor a
> transaction) if they believe the user's deposit transaction is tainted.

Adding on to this, we can consider the *economics* of taint.

Tainted coins are less valuable than untainted coins.

However, as pointed out as well, taint is not a consensus among all Bitcoin users.
There are no cryptographic underpinnings that would allow all nodes to agree on their individual taint analysis.

The people knocking on doors often have limited amounts of reach: there are real economic barriers to the knock-on-doors people being shipped to the other side of the Earth (fuel costs, ammunition costs, sociopolitical knock-on effects....).

Thus, suppose I am a miner with N coins.
As the coins have no history, they are "completely clean", as it were.

As a miner, I exist somewhere in the universe.
It is possible that I exist in some location on Earth (we cannot know; please ignore scurrilous slander that I am somehow existent outside of time and space).

Now suppose you have some tainted coins.
As noted, those coins are tainted only within some jurisdiction.
Outside that jurisdiction, however, they have no taint (taint is not a global consensus).

If I happen to live outside the jurisdiction where your coins are tainted, and I have some clean freshly-mined coins, I can offer this deal to you:

* Give me N+1 tainted coins for my N clean coins.

Now, again, the premise here is that there exists no global knock-on-doors people who can come to my datacenter and start asking questions to the sysads administering my computational substrate.

In that case, you might very well take the deal:

* You have not lost economic power, because the tainted coins, in your jurisdiction, are of lower value than N+1 anyway, and might even have value below that of N clean coins.
* I have gained economic power, because the tainted coins, in my jurisdiction, are not tainted and have the same cleanliness as my fresh mined coins.

This is a simple example of gains from trade, this time from jurisdictional arbitrage, thus such deals will exist.

--

But that is specious, as it assumes that there exists no global knock-on-doors people.
Obviously, there could exist one or more entities who are able to ship knocks-on-doors people all over the globe, taking advantage of economies of scale and reinvestment (more knock-on-doors people to knock on doors of people they can extract more economic power from to hire more knock-on-doors people) to achieve practically global coverage.

Against this, we must remember that ultimately censorship resistance of the coin is what can protect against such an attacker, which can impose its own non-consensual-but-pretty-damn-important view of taint practically globally.

Censorship resistance requires that owners of coins have control of the keys (your keys your coins) and that they can offer bribes to miners to get their transactions committed (mining fees).
Custodiality makes it easier for fewer knock-on-doors people to need to be shipped to stop certain activities.

Now, the Bitcoin Casino example is of course an example of not your keys not your coins i.e. custodiality.

For the purpose of mixing, the "Bitcoin Casino" here is simply aggregating multiple UTXOs and then sending them back out to many other new UTXOs.

This is in fact the same operation that CoinJoin does, it aggregates multiple UTXOs and creates many new UTXOs to different clients with shared taint.
The advantage is that CoinJoin is still your keys your coins, you still own the keys with which to sign the CoinJoin transaction, and thus improve censorship resistance of your mixing operation.

For CoinSwap as well, we can consider that a CoinSwap server could make multiple CoinSwaps with various clients.
This leads to the CoinSwap server owning many small UTXOs, which it at some point aggregates into a large UTXO that it then uses to service more clients (for example, it serves many small clients, then has to serve a single large client that wants a single large UTXO for its own purposes).
This aggregation again leads to spreading of taint.
CoinSwap, in this regard, is something like the cofunctor of CoinJoin.
Again, the advantage here is that CoinSwap is still your keys your coins, compared to the situation with Bitcoin Casino which is custodial.

(@Chris: I think it would be a good design for SwapMarket makers to avoid spending-together its owned coins when swapping, but if it *does* need to do so (i.e. its coins are all too split up and it becomes unable to serve a client without spending more than one coin in a tx), to spend-together *all* its UTXOs and try to serve as many takers as possible in a single tx, to simulate precisely the batching operations that custodial services use, thus appearing as some new custodial service, without actually *being* custodial.)

Thus, we should consider that CoinJoin and CoinSwap improve the censorship resistance, and thus improve our global resistance to a potential global attacker using taint analysis.

Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Wed Jun 10 23:34:53 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 10 Jun 2020 23:34:53 +0000
Subject: [bitcoin-dev] Time-dilation Attacks on the Lightning Network
In-Reply-To: <CALZpt+FF0e1wSY5mBY-rVLQu4EGAjQefK9EQDCiExqMvKVc5UQ@mail.gmail.com>
References: <2e8fba65-f7fa-4c37-a318-222547e25a06@Spark>
 <9e4dfaa7-895a-48a1-8116-eaafc80da34f@Spark>
 <2phhD75B8ww3hFQ8Do039wAIlW8EVOjUeiedm-JtIek-TEnVocYSx-untchGrO3VoRLoPzinVAG95UN1yR3CadNWBJGSu19vJpFJ_yN-wZY=@protonmail.com>
 <CALZpt+FF0e1wSY5mBY-rVLQu4EGAjQefK9EQDCiExqMvKVc5UQ@mail.gmail.com>
Message-ID: <SVoahCvNBv1S9IXAtG65zld__i5Q_Il9RAzkRLe2LX4JKt4fAxVFyttNp22IYsODv8uAzmWeQNjXORXwuiF9Xm4WeVDrWsaSh2o-KnCEFfw=@protonmail.com>

Good morning Antoine and Gleb,

One thing I have been idly thinking about would be to have a *separate* software daemon that performs de-eclipsing for your Bitcoin fullnode.

For example, you could run this deeclipser on the same hardware as your Bitcoin fullnode, and have the deeclipser bind to port 8334.
Then you set your Bitcoin fullnode with `addnode=localhost:8334` in your `bitcoind.conf`.

Your Bitcoin fullnode would then connect to the deeclipser using normal P2P protocol.

The deeclipser would periodically, every five minutes or so, check the latest headers known by your fullnode, via the P2P protocol connection your fullnode makes.
Then it would attempt to discover any blocks with greater blockheight.

The reason why we have a separate deeclipser process is so that the deeclipser can use a plugin system, and isolate the plugins from the main fullnode software.
For example, the deeclipser could query a number of plugins:

* One plugin could just try connecting to some random node, in the hopes of getting a new connection that is not eclipsed.
* Another plugin could try polling known blockchain explorers and using their APIs over HTTPS, possibly over Tor as well.
* Another plugin could try connecting to known Electrum servers.
* New plugins can be developed for new mitigations, such as sending headers over DNS or blocks over mesh or etc.

Then if any plugin discovers a block later than that known by your fullnode, the deeclipser can send an unsolicited `block` or `header` message to your fullnode to update it.

The advantage of using a plugin system is that it becomes easier to prototype, deploy, and maybe even test new de-eclipsing mitigations.

At the same time, by running a separate daemon from the fullnode, we provide some amount of process isolation in case some problem with the plugin system exists.
The deeclipser could be run by a completely different user, for example, and you might even run multiple deeclipser daemons in the same hardware, with different non-overlapping plugins, so that an exploit of one plugin will only bring down one deeclipser, with other deeclipser daemons remaining functional and still protecting your fullnode.

Finally, by using the P2P protocol, the fullnode you run could be a non-Bitcoin-Core fullnode, such as btcd or rust-bitcoin or whatever other fullnode implementations exist, assuming you actually want to use them for some reason.

What do you think?

Regards,
ZmnSCPxj


From lee.chiffre at secmail.pro  Thu Jun 11 02:01:41 2020
From: lee.chiffre at secmail.pro (Mr. Lee Chiffre)
Date: Wed, 10 Jun 2020 19:01:41 -0700
Subject: [bitcoin-dev] Tainting, CoinJoin, PayJoin, CoinSwap
In-Reply-To: <HOE_CSoWptTdBQtIqu4GTe0LlDZtnS1jEBUEf4H-wFlD7Il0-y8TikYWxGc2DPYYErJPMePIuwIO752TyNfIleKYPrkDzLQFh2l6FAKo6jU=@protonmail.com>
References: <CAEPKjgfbQoXkB=cEp5Jc28ZihRSQe50M2x7k6=AjW+Vo5f=79g@mail.gmail.com>
 <e7ab27e5-e235-f6a2-5023-1cdda5c12d0b@riseup.net>
 <HOE_CSoWptTdBQtIqu4GTe0LlDZtnS1jEBUEf4H-wFlD7Il0-y8TikYWxGc2DPYYErJPMePIuwIO752TyNfIleKYPrkDzLQFh2l6FAKo6jU=@protonmail.com>
Message-ID: <8ea7b021fcc73fc4db8881ce37726f26.squirrel@giyzk7o6dcunb2ry.onion>

Thought provoking. In my opinion bitcoin should be designed in a way to
where there is no distinction between "clean" bitcoins and "dirty"
bitcoins. If one bitcoin is considered dirty then all bitcoins should be
considered dirty. Fungibility is important. And bitcoin or its users
should not be concerned with pleasing governments. Bitcoin should be or
remain neutral. The term "clean" or "dirty" is defined by whatever
government is in power. Bitcoin is not to please government but to be
independent of government control and reliance on government or any other
centralized systems. To act as censorship resistant money to give people
freedom from tyranny. I'm just saying that if anyone can determine if a
bitcoin is clean or dirty then I think we are doing something wrong. What
is great with certain protocols like coinjoin coinswap and payjoin there
is that plausible deniability that hopefully would spread the entire
"taint" of bitcoin collectively either for real or just as a possibility 
to any blockchain analysis entities (with no real way to tell or interpret
with accuracy).

Bitcoin should be designed in a way where the only way to stop "dirty"
bitcoins is to reject all bitcoins.

If "dirty" bitcoins is actually a real thing then I guess I could have fun
by polluting random peoples bitcoin addresses with "dirty" coins right? No
way to prove if it is a self transfer or an unsolicited "donation".  I
just do not see how any bitcoin UTXO censorship could work because of
plausible deniability.

If any company actually used UTXO censorship then customers can just use
services that are respecting of freedom and do not use censorship.


From antoine.riard at gmail.com  Thu Jun 11 08:53:08 2020
From: antoine.riard at gmail.com (Antoine Riard)
Date: Thu, 11 Jun 2020 04:53:08 -0400
Subject: [bitcoin-dev] CoinPool,
	exploring generic payment pools for Fun and Privacy
Message-ID: <CALZpt+FqAWCAqCLF2HsajL84sOvst_X9_34bb_tvUxLFw=HTAA@mail.gmail.com>

Hi list,

We (Gleb Naumenko + I) think that a wide range of second-layer protocols
(LN, vaults, inheritance, etc) will be used by average Bitcoin users. We
are interested in finding and addressing the privacy issues coming from the
unique fingerprints these protocols bring.

More specifically, we are interested in answering the following questions:
1. How bad are privacy leaks from on-chain txn of second-layer protocols
and how much is leaked via protocol-specific metadatas (LN domain names,
watchtowers, ...) ?
2. How to establish a list of Bitcoin fingerprints and their severity to
inform protocol designers and clarify threat models ?
3. What kind of sophisticated heuristics spies may use in the future ?
4. How to mitigate privacy leaks ? Should each protocol adopt a common
toolbox (scriptless scripts, taproot, ...) in its own way or should we
design a confidential-layer to wrap around all of them ?
5. How to make the solution usable (cheaper, easier to integrate, safer)
for a daily basis ?

We suggest CoinPool: a generic payment pool [0] as a solution to those
problems. Although the design we propose is somewhat a scaling solution, we
won't focus on this aspect. This work is rather an exploration of *how a
pool construction could serve as a TLS for Bitcoin, enhancing both on-chain
and off-chain privacy*.

### Motivation: cross-protocols privacy

It has always been a challenge to make the on-chain UTXO graph more
private. We all know the issues with cleartext amounts, the linkability of
inputs/outputs, and other metadatas. Combining with p2p-level spying
(transaction-to-IP mapping) or some other patterns leading to real-world
identities enable serious spying.

Protocols on top of Bitcoin (LN, vaults[1], complicated spending conditions
based on Miniscript, DLC [2] are even more vulnerable to spying because:
- each of them brings new unique fingerprint/metadata [3]
- known spying techniques against second-layer are currently limited to
trivial heuristics, but we can't assume spies will always this
unsophisticated

There is already a wiki list [4] attempting to cover all issues like that,
although maintaining it would be challenging considering privacy is a
moving target.

Let's consider this example: Alice is a well-known LN merchant with a node
tied to a domain name. She always directs the output of channel closing to
her vault address. If she has another vault address on-chain with the same
unique unlocking script (like a CSV timelock with a specific delta) this
can be leveraged to cluster her transactions. And since one of her
addresses is tied to a domain name, all her funds can now be linked to a
real-world identity.

In theory, one may use CoinJoin-like solutions to mask cross-protocol
on-chain transfers. Unfortunately, robust designs like CoinSwap depend on
timelocking coins, extensive use of the on-chain space, and paying fees to
provide sufficient privacy, as we explain further. These properties imply
we can't expect users to be using strong CoinSwaps by default.

That's why instead of specialized high-latency, high-chain-use
CoinJoin-style protocols, we propose CoinPool: a low-latency, generic
off-chain protocol used to be wrapped around any other protocol. CoinPool
is based on shared UTXO ownership. It may reasonably improve on-chain
privacy while avoiding latency and locked liquidity issues. CoinPool may
also reduce the on-chain use (thus, help to scale Bitcoin) if participants
cooperate sufficiently.

We do believe that CoinSwap and other CoinJoins are of interest, but we
have to consider the trade-offs and choose the best tool for a job to make
privacy usable with regards to user resources. We will compare CoinPool to
CoinSwap in more detail later in this write-up.

### Extra-motivation: on-chain scalability

Even though it's not the main focus of this proposal, we also want to
mention that since CoinPool is a payment pool, it helps with on-chain
scalability. More specifically:
1. Shared UTXO ownership allows to represent many outputs as one, reducing
the UTXO set in size.
2. The CoinPool design enables off-chain transfers within the pool, helping
to save the block space by committing fewer transactions on-chain.
3. CoinPool provides decent support for batching activities from different
users, also helping to have fewer individual transactions on-chain.

Since the CoinPool provides scalability benefits, users will be even
incentivized to join CoinPools due to the conservative chain resources
usage and such enjoy privacy as a side-effect.

### CoinPool design

A CoinPool must satisfy the following *non-interactive any-order
withdrawal* property: at any point in time and any possible sequence of
previous CoinPool events, a participant should be able to move their funds
from the CoinPool to any address the participant wants without cooperation
with other CoinPool members.

The state of a CoinPool is represented by one on-chain UTXO (a funding
multisig of all pool participants) and a set of transactions stored by the
participants along with signatures allowing to spend that UTXO. This UTXO
is a Taproot output, where the leaves in the Merkle tree represent pool
participants.

#### Transactions

A CoinPool UTXO can be spent by two types: Pool_Tx and Split_Tx.

A Pool_Tx enables cooperatives updates of the pool, e.g a participant
exiting the pool or off-chain internal transfers. This transaction is used
to spend the key branch of the Taproot tree of the CoinPool UTXO.
Signatures for a Pool_Tx should be exchanged "on-demand", the moment
parties decide to update the CoinPool state collaboratively, In practice,
this would happen upon a request of a pool participant.

A Split_Tx enables a unilateral exit from the CoinPool, in case it's not
possible to use a cooperative Pool_Tx path. This transaction spends the
UTXO via the Merkle branch into two outputs:
- a _withdraw_ output paying to the pool participant who initiated a
transaction
- a _recursive_ output paying to the new instance of a CoinPool, which
contains all the same participants except the one who just withdrew

The design of the unilateral Split_Tx depends on what can be achieved with
Bitcoin Script. The main challenge is to enforce the second output of the
Split_tx s that the participant who exists can't take all the funds
unilaterally. We will talk more about the updates to Bitcoin Script which
would allow more advanced pools later (Scaling section).

For now, we will *focus on the Script capabilities of today*, per which
spending a Split_Tx requires signatures from all pool participants. Since
Split_Tx is a unilateral exit, parties are required to exchange signatures
for *any possible state of the pool* in advance, to handle the *any-order
withdraw* requirement. The exchange should happen when a pool is created.

#### Operations

There are three types of operations against a CoinPool: create, update,
withdraw.

Per *creation*, participants agree on a pool policy and commit inputs to a
funding transaction by sending a corresponding signature, created in a
secure "atomic" way (so that their funds can't be taken if other pool
participants are unresponsive). Participants also exchange their signatures
which would allow any participant to exit at any given time via a Split_Tx.

Per *update*, participants agree on a new coin distribution within the pool
tree. They can aggregate and split leaves of the tree, or rotate a target
output of a given leaf. E.g, a participant may choose to redirect coins to
a new pool right from the old pool and ask all the parties to agree on this
update. The previous state should then be revoked either via sequence
number (Eltoo) or adding the latest state as a child transaction from any
previous Pool_tx.

Per *withdraw*, a participant may submit either a Pool_Tx (after asking all
the parties for their signatures) or a Split_Tx (unilaterally). After that,
a new UTXO of the CoinPool would consist of all the remaining participants.

As an optimization, updates and withdrawals may aggregate changes to
multiple leaves within one transaction. A CoinPool may also optionality
allow new participants to *join* a pool on-the-fly, although trade-offs
should be considered.

#### Transaction Tree illustrated

We illustrate a CoinPool transaction tree with 3 leaves below. We use an
obvious optimization: if there are only 2 leaves left, the last transaction
doesn't have to commit to a new tree [5].


                                      Funding_Tx

                                  |

                                              |

                                     [Taproot_T]


          |

        ___________________ | ______________________________________

|
                                                  |

      |

                                  |


|
                                    |

[leaf_A]
                                           |

    ^

                                    |


|
                                       |

Split_TxA

___________________ |________________________
                                                                        /
             \
                                                                 |

|

/
\
|
|

/
\
[leaf_B]
  [leaf_C]
                                              [withdraw_A]
[Taproot T']
^
^

^
|
|

|
Split_TxB
Split_TxC


Pool_Tx                                                    /
\
/            \

/              \
/
\
/                \

/                  \                               [withdraw_B]
[Taproot T'']
[withdraw_C]             [Taproot'']

/
\
^
^

[withdraw_B]
[withdraw_C]                                                     |

      |

Pool_Tx
Pool_tx

/
\
/            \

/
\
/                \

           [withdraw_A]
[withdraw_C]
[withdraw_A]            [withdraw_B]


### Scaling the Pool and the Any-Order problem

A conservative CoinPool indeed does not scale well: it requires generating
pruned Merkle Tree encumbering the _recursive_ output for any combination
of withdrawals at pool creation. For a tree of Alice, Bob and Carol, they'd
have to build (A,B,C), (A,C,B), (B,A,C), (B,C,A), (C,A,B), (C,B,A) trees.
Since the complexity is quasi-factorial, the conservative CoinPool design
is impractical for more than 10 leaves.

Instead of operating over every possible alternative statically (via
pre-signing *every* combination), the protocol may rely on the script
interpreter to do it dynamically, only enforcing an effective path among
alternatives.

A new primitive to enable this behavior can be implemented as an
accumulator, i.e a space-efficient cryptographic set representation
supporting testing for inclusion and element deletion.

Implementation of this delete-only accumulator can be done by introducing
or combining already-proposed primitives like a new sighash flag, using a
Taproot tree as an accumulator, a committed bitset with templated
operations, etc, ... The exact design is left for future research.

This primitive would enable re-committing the updated tree on the
_recursive_ output, that way preserving balances of other participants,
independently of order of withdrawals.

Such _recursive_ output needs to be spendable by remaining Split_txn. These
transactions are pre-signed and their inputs commit to the parent txid. To
alleviate this issue, Split_tx should be signed through SIGHASH_NOINPUT,
therefore enabling _recursive_ output. The spending Tapscript must be
present among the set of Taproot tree leaves.

### Intra-pool communication and pool policies

The CoinPool design assumes participants have to communicate regularly to
exchange transaction templates and signatures. It happens almost every time
a state of the pools is modified: pool creation, pool update, and
cooperative withdrawal. Selecting a communication channel (a mixnet,
centralized servers, publication boards, ...) should be done considering
the threat model, the cost, the expected latency.

Every instance of a CoinPool may be public (available for new participants
to join at any time), private (available to join via some out-of-band
communication), or something in the middle (based on anti-Sybil measures we
will discuss later).

### Protocol rebinding

Since the conservative CoinPool design every unilateral exit via Split_Tx
should be signed by all the parties in advance, every participant joining
the pool should define in advance which address the coins will be directed
to in a unilateral case.

However, participants may want to use their CoinPool funds to move their
pool funds to a new scriptPubkey (for example, to open a new LN channel).
To avoid using an intermediate single-address on-chain transaction for
these cases, participants should be able to rotate the Split_Tx output.

To avoid asking other participants of the CoinPool to sign a new update, a
multisig signature covering the Split_Tx and enforcing covenant semantic
may be signed with SIGHASH_SINGLE. That way, at any-time Alice can finalize
her Split_Tx by adding a new output and signing her with SIGHASH_ALL.

Since unilateral withdrawal from CoinPool is time-locked, integration
time-sensitive off-chain protocols (e.g, LN or DLC) must be done with extra
care.

Lastly, the limitations of the current mempool design should be taken into
account while using CoinPools, so that issues like mempool  pinning [6] are
not critical.

### Security/Privacy model

Similarly to CoinJoins, CoinPool provides privacy by breaking payment
sender/receiver linkability for an on-chain observer.
Common-input-ownership, address reuse, change address heuristics can't be
leveraged. A spy is forced to commit/lock funds to the pool, and
potentially overcome ant-Sybil measures. Internal CoinPool transfers also
remain private for an external observer.

The exact on-chain privacy efficiency of a given CoinPool depends on two
factors: intra-pool activities and exit activities. If the parties are
cooperative, intra-pool transfers never leave a footprint on-chain. Exit
activities always hit the chain, but if output rebinding is available, the
funds can be sent right to the target receiver outside the pool (e.g, cold
storage or even another pool), making on-chain analysis much more difficult
than what happens with regular transactions today.

Since it's possible for an attacker to join a pool, we have to consider
extra Sybil-resistance (beyond just depositing coins). Extra
Sybil-resistance may include a lock on withdrawal. This lock should not
limit intra-pool updates, so that honest users are not limited.
Additionally, the solutions suggested for CoinJoins may be used (fidelity
bonds, PoDle, etc).

### User Requirements

CoinPool introduces two requirements on users: one for security, one for
pool performance.

It requires persistent storage from the user. Since a unilateral withdrawal
assumes transmitting signatures received from other participants
beforehand, these signatures, corresponding Taproot output and Merkle
branches should not be lost or corrupted, otherwise a participant won't be
able to exit the pool without cooperation.

It also requires hot access to the signing keys, i.e being online to sign
updates which introduces a higher security risk.

These requirements are similar to the requirements for LN and vault
constructions, so we believe that the burden on a CoinPool participant is
reasonable as long as we consider second-layer protocols practical.

### Comparing to CoinSwap

A CoinSwap was recently proposed as a next step for on-chain bitcoin
privacy [6]. We will compare CoinPool to  CoinSwap in terms of high-level
properties, because there are no deployed CoinSwaps yet.

CoinSwap enables privacy-enhanced (in terms of on-chain footprint)
transactions, executed as a non-custodial atomic "trade" between two
parties willing to send someone else (not each other) coins at the same
time.

A CoinSwap between two parties cost at least two on-chain transactions.
However, since this minimal design leaks privacy due to the amount
correlation, more advanced CoinSwap constructions should be used, and they
would be even more costly.

The privacy-efficiency of CoinSwaps is thus defined by fees and time-value
parameters. For these reasons, the lower security requirements are likely
to be most-widely picked-up by thrift users. Participation in a CoinPool,
however, costs of a funding transaction fee (shared across all
participants), and a cost of the withdrawal (either unilateral or
cooperative). Off-chain updates within a pool are free.

With regards to linkability, CoinSwap breaks the UTXO ownership graph,
CoinPool has similar properties the moment the coins are withdrawn, but the
off-chain events inside the pool are likely to obfuscate it even further.
Every participant can make direct payments during pool lifetime, breaking
mapping between committed inputs and withdrawn outputs.

CoinPool output will be part of the broader taproot user set, therefore any
single-owned output may be confused as a pool one, hindering further
on-chain analysis even for non-CoinPool users.

With regards to linkability, CoinSwap completely breaks the link between
inputs and outputs, while CoinPool just largely obfuscates the link
(similarly to CoinJoins). CoinPool is capable of breaking the link for
those payments happening off-chain (e.g, simple transfers within the pool).

With regards to requirements, beyond requiring online keys, practical
CoinPools require new base layers primitives, namely Taproot,
SIGHASH_NOINPUT and delete-only accumulators. CoinSwap is deployable today,
although the client software should be built.

With regards to malicious participants, CoinPool provides some privacy (in
terms of on-chain analysis) if at least one other participant is honest,
which is the same assumption as CoinSwap. More specifying spying cost
analysis can be made when comparing particular configurations of a CoinSwap
and a CoinPools. We invite the community to develop a better model of
privacy adversaries, their resources and leverages to refine
privacy-enhancing protocols comparisons.

Although we claim that different properties of CoinSwaps and CoinPools make
them better for different goals, they can benefit from each other: e.g,
both of them may rely on Sybil-resistance mechanisms or federated message
boards for cooperation.

### Conclusion

We propose CoinPool: a payment pool construction to improve privacy against
on-chain data analysis. More specifically, it helps to hide the unique
footprint associated with the use of second-layer protocols.

We attempted to design CoinPools to make them usable for daily activities,
as opposed to specialized CoinJoin-style solutions. They usually don't
require paying fees and don't use the on-chain space *per-activity*. If
they are widely used, they can also help with on-chain scalability,
although we don't cover this aspect in detail.

CoinPool is a UTXO representing a Taproot tree, in which the leaves
represent the spending conditions for coins in the pool. We designed
CoinPool around the *non-interactive any-order withdrawal* requirement.

In the long-term, CoinPool appears as a good candidate for a scalable,
used-by-default privacy-enhancing technology. We emphasize there are
several challenges deploying CoinPools, the biggest one being scalability.
Making them practical requires introducing new on-chain primitives.

Thanks to the wider privacy-community and on which of their work this
depends heavily.

Thanks to the reviewers.

Cheers,

Gleb + Antoine


[0] AFAIK, payment pools have been suggested by Greg Maxwell, although I
couldn't find any written evidence. The only description I know have been
made to me by Dave Harding during a BitDevs meetup. Yes I'm old enough to
have known when meatspace Bitcoin meetup was a thing.
<https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017793.html>

[1]
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017793.html

[2] https://github.com/discreetlogcontracts/dlcspecs/

[3] On protocol usage leak at the on-chain level see
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017633.html,
for an illustration see
https://b10c.me/mempool-observations/1-locktime-stairs/

[4] https://en.bitcoin.it/Privacy

[5] . A gist backup if it doesn't survive formatting :
https://gist.github.com/ariard/ab1e4c3a85e4816be21ee0e0f925e86b A common
notation to describe transactions tree and their scripts and ease reviewers
to verify their correctness would be great. Otherwise it's hard to gauge
the correctness of this kind of new protocol.

[6] https://bitcoinops.org/en/newsletters/2020/04/29/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200611/43cc1fe6/attachment-0001.html>

From antoine.riard at gmail.com  Thu Jun 11 09:21:48 2020
From: antoine.riard at gmail.com (Antoine Riard)
Date: Thu, 11 Jun 2020 05:21:48 -0400
Subject: [bitcoin-dev] Time-dilation Attacks on the Lightning Network
In-Reply-To: <SVoahCvNBv1S9IXAtG65zld__i5Q_Il9RAzkRLe2LX4JKt4fAxVFyttNp22IYsODv8uAzmWeQNjXORXwuiF9Xm4WeVDrWsaSh2o-KnCEFfw=@protonmail.com>
References: <2e8fba65-f7fa-4c37-a318-222547e25a06@Spark>
 <9e4dfaa7-895a-48a1-8116-eaafc80da34f@Spark>
 <2phhD75B8ww3hFQ8Do039wAIlW8EVOjUeiedm-JtIek-TEnVocYSx-untchGrO3VoRLoPzinVAG95UN1yR3CadNWBJGSu19vJpFJ_yN-wZY=@protonmail.com>
 <CALZpt+FF0e1wSY5mBY-rVLQu4EGAjQefK9EQDCiExqMvKVc5UQ@mail.gmail.com>
 <SVoahCvNBv1S9IXAtG65zld__i5Q_Il9RAzkRLe2LX4JKt4fAxVFyttNp22IYsODv8uAzmWeQNjXORXwuiF9Xm4WeVDrWsaSh2o-KnCEFfw=@protonmail.com>
Message-ID: <CALZpt+FPr2ymQ7x_w8pj0RX2eLoSRykUJH22HM1Z0pZy4cj-mQ@mail.gmail.com>

Hi ZmnSCPxj

Well your deeclipser is already WIP ;)

See my AltNet+Watchdog proposals in Core:
https://github.com/bitcoin/bitcoin/pull/18987/https://github.com/bitcoin/bitcoin/pull/18988

It's almost covering what you mention, a driver framework to plug
alternative transports protocols : radio, DNS, even LN Noise, Tor's
Snowflake... Proposal is a PoC with a multi-threaded process but yes I want
production-design to be a multi-process for the reasons you mentioned.
Drivers should be developed out-of-tree but with an interface to plug them
smoothly (tm).

Proposal is more generic than pure LN, like some privacy-concerned users
may want to broadcast by default their transactions over radio. But for LN
support it should a) detect network/block issuance anomalies b) dynamically
react by closing channels or c) fetch headers/blocks through redundant
communication channels and d) provide emergency transactions broadcast if
your time-sensitive transactions are censored.

It's long-term work so be patient but getting opt-in support in Core would
make it far easier for any LN routing/vaulting node to deploy it. In the
meanwhile you can have multiple nodes on different infrastructures to serve
as a backend for your LN node.

Bonus: if LN nodes are incentivized to deploy such strong anti-eclipsing
measures to mitigate time-dilation it would benefit base layer p2p security
network-wise. In case of network partition, your node with link layer
redundancy will keep it in-sync its connected peers on the same side of the
partition, even if they don't deploy anything.

I'm sure you have improvements to suggest !

Best,
Antoine


Le mer. 10 juin 2020 ? 19:35, ZmnSCPxj <ZmnSCPxj at protonmail.com> a ?crit :

> Good morning Antoine and Gleb,
>
> One thing I have been idly thinking about would be to have a *separate*
> software daemon that performs de-eclipsing for your Bitcoin fullnode.
>
> For example, you could run this deeclipser on the same hardware as your
> Bitcoin fullnode, and have the deeclipser bind to port 8334.
> Then you set your Bitcoin fullnode with `addnode=localhost:8334` in your
> `bitcoind.conf`.
>
> Your Bitcoin fullnode would then connect to the deeclipser using normal
> P2P protocol.
>
> The deeclipser would periodically, every five minutes or so, check the
> latest headers known by your fullnode, via the P2P protocol connection your
> fullnode makes.
> Then it would attempt to discover any blocks with greater blockheight.
>
> The reason why we have a separate deeclipser process is so that the
> deeclipser can use a plugin system, and isolate the plugins from the main
> fullnode software.
> For example, the deeclipser could query a number of plugins:
>
> * One plugin could just try connecting to some random node, in the hopes
> of getting a new connection that is not eclipsed.
> * Another plugin could try polling known blockchain explorers and using
> their APIs over HTTPS, possibly over Tor as well.
> * Another plugin could try connecting to known Electrum servers.
> * New plugins can be developed for new mitigations, such as sending
> headers over DNS or blocks over mesh or etc.
>
> Then if any plugin discovers a block later than that known by your
> fullnode, the deeclipser can send an unsolicited `block` or `header`
> message to your fullnode to update it.
>
> The advantage of using a plugin system is that it becomes easier to
> prototype, deploy, and maybe even test new de-eclipsing mitigations.
>
> At the same time, by running a separate daemon from the fullnode, we
> provide some amount of process isolation in case some problem with the
> plugin system exists.
> The deeclipser could be run by a completely different user, for example,
> and you might even run multiple deeclipser daemons in the same hardware,
> with different non-overlapping plugins, so that an exploit of one plugin
> will only bring down one deeclipser, with other deeclipser daemons
> remaining functional and still protecting your fullnode.
>
> Finally, by using the P2P protocol, the fullnode you run could be a
> non-Bitcoin-Core fullnode, such as btcd or rust-bitcoin or whatever other
> fullnode implementations exist, assuming you actually want to use them for
> some reason.
>
> What do you think?
>
> Regards,
> ZmnSCPxj
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200611/99324582/attachment.html>

From adam.ficsor73 at gmail.com  Thu Jun 11 11:20:56 2020
From: adam.ficsor73 at gmail.com (nopara73)
Date: Thu, 11 Jun 2020 13:20:56 +0200
Subject: [bitcoin-dev] Tainting, CoinJoin, PayJoin, CoinSwap
In-Reply-To: <8ea7b021fcc73fc4db8881ce37726f26.squirrel@giyzk7o6dcunb2ry.onion>
References: <CAEPKjgfbQoXkB=cEp5Jc28ZihRSQe50M2x7k6=AjW+Vo5f=79g@mail.gmail.com>
 <e7ab27e5-e235-f6a2-5023-1cdda5c12d0b@riseup.net>
 <HOE_CSoWptTdBQtIqu4GTe0LlDZtnS1jEBUEf4H-wFlD7Il0-y8TikYWxGc2DPYYErJPMePIuwIO752TyNfIleKYPrkDzLQFh2l6FAKo6jU=@protonmail.com>
 <8ea7b021fcc73fc4db8881ce37726f26.squirrel@giyzk7o6dcunb2ry.onion>
Message-ID: <CAEPKjgf8nhxn031ra4vqfJW7WV8RKdxhDtixMQnxcPD0NaSreg@mail.gmail.com>

Thank you all for your replies, I think everyone agrees here how it "should
be" and indeed I risked my post and my used terminology to further
legitimize the thinking of adversaries.
I'd have one clarification to my original post. It may not be clear why I
put PJ/CS to the same box. One way of thinking of CoinSwap is to swap coin
histories and PayJoin is to share coin histories. For the purposes of this
attack the consequences are roughly the same so that's why I think it's ok
to put them under the same umbrella in this discussion, but I wouldn't die
for it :)

And indeed I perhaps wrongly called this the "Taint Issue", maybe it should
be called "Coin Discrimination Issue" or something like that, not sure if
we have a term for this, but I'm sure we should have a term for this as
unlike some other, so far theoretical attacks on Bitcoin's fungibility, it
is currently being applied in practice.


On Thu, Jun 11, 2020 at 7:24 AM Mr. Lee Chiffre via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Thought provoking. In my opinion bitcoin should be designed in a way to
> where there is no distinction between "clean" bitcoins and "dirty"
> bitcoins. If one bitcoin is considered dirty then all bitcoins should be
> considered dirty. Fungibility is important. And bitcoin or its users
> should not be concerned with pleasing governments. Bitcoin should be or
> remain neutral. The term "clean" or "dirty" is defined by whatever
> government is in power. Bitcoin is not to please government but to be
> independent of government control and reliance on government or any other
> centralized systems. To act as censorship resistant money to give people
> freedom from tyranny. I'm just saying that if anyone can determine if a
> bitcoin is clean or dirty then I think we are doing something wrong. What
> is great with certain protocols like coinjoin coinswap and payjoin there
> is that plausible deniability that hopefully would spread the entire
> "taint" of bitcoin collectively either for real or just as a possibility
> to any blockchain analysis entities (with no real way to tell or interpret
> with accuracy).
>
> Bitcoin should be designed in a way where the only way to stop "dirty"
> bitcoins is to reject all bitcoins.
>
> If "dirty" bitcoins is actually a real thing then I guess I could have fun
> by polluting random peoples bitcoin addresses with "dirty" coins right? No
> way to prove if it is a self transfer or an unsolicited "donation".  I
> just do not see how any bitcoin UTXO censorship could work because of
> plausible deniability.
>
> If any company actually used UTXO censorship then customers can just use
> services that are respecting of freedom and do not use censorship.
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>


-- 
Best,
?d?m
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200611/5a9e314c/attachment.html>

From ZmnSCPxj at protonmail.com  Thu Jun 11 11:51:03 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 11 Jun 2020 11:51:03 +0000
Subject: [bitcoin-dev] Hiding CoinSwap Makers Among Custodial Services
Message-ID: <fQt0iIzsA5QprW64lX4SR1R78Aj6e-WqIgSMvk75mdiagQmAchIUqCpXzDjD4jPBhorg0i-oGlrYz7ot2xWMgJiha-eGFzl3PxbtZ-mbjSc=@protonmail.com>

Good morning Chris, and bitcoin-dev (but mostly Chris),


I made a random comment regarding taint on bitcoin-dev recently: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-June/017961.html

> For CoinSwap as well, we can consider that a CoinSwap server could make multiple CoinSwaps with various clients.
> This leads to the CoinSwap server owning many small UTXOs, which it at some point aggregates into a large UTXO that it then uses to service more clients (for example, it serves many small clients, then has to serve a single large client that wants a single large UTXO for its own purposes).
> This aggregation again leads to spreading of taint.

I want to propose some particular behaviors a SwapMarket maker can engage in, to improve the privacy of its customers.

Let us suppose that individual swaps use some variant of Succinct Atomic Swap.
Takers take on the role of Alice in the SAS description, makers take on the role of Bob.
We may be able to tweak the SAS protocol or some of its parameters for our purposes.

Now, what we will do is to have the maker operate in rounds.

Suppose two takers, T1 and T2, contact the sole maker M in its first ever round.
T1 and T2 have some coins they want to swap.
They arrange things all the way to confirmation of the Alice-side funding tx, and pause just before Bob creates its own funding tx for their individual swaps.
The chain now shows these txes/UTXOs:

     42 of T1 --->  42 of T1 & M
     50 of T2 --->  50 of T2 & M
    100 of T1 ---> 100 of T1 & M

    200 of M  -

Now the entire point of operating in rounds is precisely so that M can service multiple clients at the same time with a single transaction, i.e. batching.
So now M provides its B-side tx and complete the SAS protocols with each of the takers.
SAS gives unilateral control of the outputs directly to the takers, so we elide the fact that they are really 2-of-2s below:

     42 of T1 --->  42 of T1 & M
     50 of T2 --->  50 of T2 & M
    100 of T1 ---> 100 of T1 & M

    200 of M  +-->  11 of M
              +--> 140 of T1
              +-->  49 of T2

(M extracted 1 unit from each incoming coin as fee; they also live in a fictional universe where miners mine transactions out of the goodness of their hearts.)
Now in fact the previous transactions are, after the SAS, solely owned by M the maker.
Now suppose on the next round, we have 3 new takers, T3, T4, and T5, who offer some coins to M to CoinSwap, leading to more blockchain data:

     42 of T1 --->  42 of T1 & M
     50 of T2 --->  50 of T2 & M
    100 of T1 ---> 100 of T1 & M

    200 of M  -+->  11 of M
               +-> 140 of T1
               +->  49 of T2

     22 of T3 --->  22 of T3 & M
     90 of T3 --->  90 of T3 & M
     11 of T4 --->  11 of T4 & M
     50 of T4 --->  50 of T4 & M
     20 of T5 --->  20 of T5 & M

In order to service all the new takers of this round, M takes the coins that it got from T1 and T2, and uses them to fund a new combined CoinSwap tx:

     42 of T1 --->  42 of T1 & M -+--+-> 110 of T3
     50 of T2 --->  50 of T2 & M -+  +->  59 of T4
    100 of T1 ---> 100 of T1 & M -+  +->  14 of T5
                                     +->   9 of M
    200 of M  -+->  11 of M
               +-> 140 of T1
               +->  49 of T2

     22 of T3 --->  22 of T3 & M
     90 of T3 --->  90 of T3 & M
     11 of T4 --->  11 of T4 & M
     50 of T4 --->  50 of T4 & M
     15 of T5 --->  15 of T5 & M

That transaction, we can observe, looks very much like a batched transaction that a custodial service might produce.

Now imagine more rounds, and I think you can begin to imagine that the magic of transaction batching, ported into SwapMarket, would help mitigate the blockchain size issues that CoinSwap has.

Makers are expected to adopt this technique as this reduces the overall cost of transactions they produce, thus they are incentivized to use this technique to increase their profitability.

At the same time, it spreads taint around and increases the effort that chain analysis must go through to identify what really happened.

Regards,
ZmnSCPxj

From jlrubin at mit.edu  Thu Jun 11 17:21:08 2020
From: jlrubin at mit.edu (Jeremy)
Date: Thu, 11 Jun 2020 10:21:08 -0700
Subject: [bitcoin-dev] CoinPool,
 exploring generic payment pools for Fun and Privacy
In-Reply-To: <CALZpt+FqAWCAqCLF2HsajL84sOvst_X9_34bb_tvUxLFw=HTAA@mail.gmail.com>
References: <CALZpt+FqAWCAqCLF2HsajL84sOvst_X9_34bb_tvUxLFw=HTAA@mail.gmail.com>
Message-ID: <CAD5xwhjkstCcF49s8r8ZqVH77VmWXaZSm=_sx=FKZuCj6Ci_UA@mail.gmail.com>

Stellar work Antoine and Gleb! Really excited to see designs come out on
payment pools.

I've also been designing some payment pools (I have some not ready code I
can share with you guys off list), and I wanted to share what I learned
here in case it's useful.

In my design of payment pools, I don't think the following requirement: "A
CoinPool must satisfy the following *non-interactive any-order withdrawal*
property: at any point in time and any possible sequence of previous
CoinPool events, a participant should be able to move their funds from the
CoinPool to any address the participant wants without cooperation with
other CoinPool members." is desirable in O(1) space. I think it's much
better to set the requirement to O(log(n)), and this isn't just because of
wanting to use CTV, although it does help.

Let me describe a quick CTV based payment pool:

Build a payment pool for N users as N/2 channels between participants
created in a payment tree with a radix of R, where every node has a
multisig path for being used as a multi-party channel and the CTV branch
has a preset timeout. E.g., with radix 2:

                                      Channel(a,b,c,d,e,f,g,h)
                                     /                                   \
               Channel(a,b,c,d)
Channel(e,f,g,h)
                    /
\                                                    /                 \
Channel(a,b)    Channel(c,d)                          Channel(e,f)
Channel(g,h)


All of these channels can be constructed and set up non-interatively using
CTV, and updated interactively. By default payments can happen with minimal
coordination of parties by standard lightning channel updates at the leaf
nodes, and channels can be rebalanced at higher layers with more
participation.


Now let's compare the first-person exit non cooperative scenario across
pools:

CTV-Pool:
Wait time: Log(N). At each branch, you must wait for a timeout, and you
have to go through log N to make sure there are no updated states. You can
trade off wait time/fees by picking different radixes.
TXN Size: Log(N) 1000 people with radix 4 --> 5 wait periods. 5*4 txn size.
Radix 20 --> 2 wait periods. 2*20 txn size.

Accumulator-Pool:
Wait Time: O(1)
TXN Size: Depending on accumulator: O(1), O(log N), O(N) bits. Let's be
favorable to Accumulators and assumer O(1), but keep in mind constant may
be somewhat large/operations might be expensive in validation for updates.


This *seems* like a clear win for Accumulators. But not so fast. Let's look
at the case where *everyone* exits non cooperatively from a payment pool.
What is the total work and time?

CTV Pool:
Wait time: Log(N)
Txn Size: O(N) (no worse than 2x factor overhead with radix 2, higher
radixes dramatically less overhead)

Accumulator Pool:
Wait time: O(N)
Txn Size: O(N) (bear in mind *maybe* O(N^2) or O(N log N) if we use an
sub-optimal accumulator, or validation work may be expensive depending on
the new primitive)


So in this context, CTV Pool has a clear benefit. The last recipient can
always clear in Log(N) time whereas in the accumulator pool, the last
recipient has to wait much much longer. There's no asymptotic difference in
Tx Size, but I suspect that CTV is at least as good or cheaper since it's
just one tx hash and doesn't depend on implementation.

Another property that is nice about the CTV pool style is the bisecting
property. Every time you have to do an uncooperative withdrawal, you split
the group into R groups. If your group is not cooperating because one
person is permanently offline, then Accumulator pools *guarantee* you need
to go through a full on-chain redemption. Not so with a CTV-style pool, as
if you have a single failure among [1,2,3,4,5,6,7,8,9,10] channels (let's
say channel 8 fails), then with a radix 4 setup your next steps are:
[1,2,3,4,5,6,7,8,9,10]
[1,2,3,4,5,6,7,X,9,10]
[1,2,3,4] [5,6,7,X] [9,10]
[1,2,3,4] 5 6 7 X [9,10]

So you only need to do Log(N) chain work to exit the bad actor, but then it
amortizes! A future failure (let's say of 5) only causes 5 to have to close
their channel, and does not affect anyone else.

With an accumulator based pool, if you re-pool after one failure, a second
failure causes another O(N) work. So then total work in that case is
O(N^2). You can improve the design by making the evict in any order option
such that you can *kick out* a member in any order, that helps solve some
of this nastiness (rather than them opting to leave). But I'm unclear how
to make this safe w.r.t. updated states. You could also allow, perhaps, any
number of operators to simultaneously leave in a tx. Also not sure how to
do that.



Availability:
With CTV Pools, you can make a payment if just your immediate conterparty
is online in your channel. Opportunistically, if people above you are
online, you can make channel updates higher up in the tree which have
better timeout properties. You can also create new channels, binding
yourself to different parties if there is a planned exit.

With Accumulator pools, you need all parties online to make payments.


Cooperation Case:
CTV Pools and Accumulator pools, in a cooperative case, both just act like
a N of N multisig.

Privacy:
Because Accumulator pools always require N signers, it's possible to build
a better privacy model where N parties are essentially managing a chaumian
ecash like server for updates, giving good privacy of who initiated
payments. You *could* do this with CTV pools as well, but I expect users to
prefer making updates at the 2 party channel layer for low latency, and to
get privacy benefits out of the routability of the channels and ability to
connect to the broader lightning network.


Technical Complexity:
Both protocols require new features in Bitcoin. CTV is relatively simple, I
would posit that accumulators + sighashnoinput are relatively not simple.

The actual protocol design for CTV pools is pretty simple and can be
compatible with LN, I already have a rudimentary implementation of the
required transactions (but not servers).


Interactivity:

In both designs, the payment pool can be created non-interactively. This is
*super* important as it means third parties (e.g., an exchange) can
withdraw users funds *into* a payment pool.


Thanks for reading!

Jeremy



--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200611/fcf38fb7/attachment.html>

From nothingmuch at woobling.org  Thu Jun 11 20:40:07 2020
From: nothingmuch at woobling.org (Yuval Kogman)
Date: Thu, 11 Jun 2020 20:40:07 +0000
Subject: [bitcoin-dev] WabiSabi: a building block for coordinated CoinJoins
Message-ID: <CAAQdECAojQBLxOEdef1NHkVN6DGTcsFAZ5bB0eOHFTPGu6d+pQ@mail.gmail.com>

Hi,

As part of research into how CoinJoins in general and Wasabi in
particular can be improved, we'd like to share a new building block
we're calling WabiSabi, which utilizes keyed verification anonymous
credentials instead of blind signatures to verify the honest
participation of users in centrally coordinated CoinJoin protocols.

Blind signatures have been used to facilitate centrally coordinated
CoinJoins, but require standard denominations, each associated with a
key, because blind signatures can only convey a single bit of
information from the signer to the verifier (both roles are the
coordinator in this setting). Anonymous credentials carry attributes,
and in our case these are homomorphic value commitments as in
Confidential Transactions.

Note that this is an early draft with a deliberately narrow scope, and
only introduces this abstract building block. At this stage we'd like
to solicit feedback and criticism about our scheme and inputs with
regards to its potential applications before proceeding. We do not not
(yet) address the structure of the CoinJoin transactions, fee
structures, or other implementation details, but discussion of these
aspects is welcome.

The repository is https://github.com/zkSNACKs/WabiSabi, and the latest
version is available here:
https://github.com/zkSNACKs/WabiSabi/releases/latest/download/WabiSabi.pdf

From ZmnSCPxj at protonmail.com  Fri Jun 12 05:43:29 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 12 Jun 2020 05:43:29 +0000
Subject: [bitcoin-dev] WabiSabi Inside Batched CoinSwap
Message-ID: <D2DWwPP0JpNM3V2tbq_dUMZl4W24rsE6Evn265S6KEwe-_vyc9KNy8gHegbFzoM2xr72d_9VwsXHe3TSYmXpXM7ytkN5zIqZnskXL-Ew_xQ=@protonmail.com>

Introduction
============

THIS ENTIRE PROTOCOL IS NOVEL CRYPTO AND HAS NO PROOF THAT IT IS SECURE AND PRIVATE AND WHY WOULD YOU TRUST SOME RANDOM PSEUDONYM ON THE INTERNET SRSLY.

While [WabiSabi](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-June/017969.html) is planned for some kind of CoinJoin operation, a limitation is that the use of CoinJoin creates a transaction where the inputs are known to be linked to the outputs, as the generated transaction directly consumes the inputs.

It would be better if the server in the WabiSabi created outputs from independent outputs it owns, acquired from previous clients.
Then the outputs would, onchain, be linked to previous clients of the server instead of the current clients.
This is precisely the issue that CoinSwap, and the new swap scheme [Succinct Atomic Swaps](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-May/017846.html), can be used to solve.
By using [Batched CoinSwap](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-June/017967.html), makers can act as WabiSabi servers, and batched takers can act as WabiSabi clients.

Of course, WabiSabi has the advantage that payments between the clients are obscured from the server.
But a naive CoinSwap requires that outputs from the maker be linkable, at least by the maker, to inputs given to the maker, which is precisely the information that WabiSabi seeks to hide from the server.

However, by instead using [Signature Selling](https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-July/002077.html) in combination with standard Scriptless Script adaptor signatures, it is possible to arrange for a CoinSwap to occur without the make being able to link outputs to inputs.

Signature Selling
=================

The final output of the Schnorr signing process is a pair (R, s) for a pubkey A = a * G and ephemeral nonce R = r * G, where:

    s = r + h(P | R | m) * a

Now, instead of the pair (R, s), the signer can provide (R, s * G).
The receiver of (R, s * G) can validate that s * G is correct using the same validation as for Schnorr signatures.

    s * G = R + h(P | R | m) * A

The receiver of (R, s * G) can then offer a standard Scriptless Script adaptor signature, which when completed, lets them learn s.
The receiver may incentivize this by having the completed signature authorize a transaction to the sender of the original (R, s * G), so that the completed signature atomically gives the receiver the correct signature.

This can be used as a basis for atomic CoinSwap, and which we will use in this proposal.

Note that even in a MuSig case, it is possible for a participant to sell its share of the final signature, after the R exchange phase in MuSig.

WabiSabi
========

WabiSabi replaces blind signatures with credentials.
The primary advantage of credentials is that credentials can include a homomorphic value.
We use this homomorphic value to represent a blinded amount.

WabiSabi has a single server that issues credentials, and multiple clients that the server serves.
Clients can exchange value by swapping credentials, then claiming credentials they received from the server and exchanging them for fresh credentials.
Clients hold multiple credentials at a time, and the server consumes (and destroys) a set of credentials and outputs another set of fresh credentials, ensuring that the output value is the same as the input value (minus any fees the server wants to charge for the operation).

>From a high enough vantage point, the WabiSabi process is:

1.  Server issues 0-valued credentials to all clients.
2.  Clients put in money into the server by providing onchain inputs to the server plus their existing credentials, getting credentials with their input credential value plus the onchain input value.
3.  Clients swap credentials with each other to perform payments between themselves, then claim the credentials by asking the server to reissue them.
    * Receiving clients move their amounts among all the credentials they own (via server consume-reissue credential operations) so as to make one of their multiple credentials into a 0-value credential.
    * Sending clients move their amounts among all the credentials they own so that one of their multiple credentials has the sent value.
    * The receiving client exchanges its 0-value credential for the sent-value credential from the sending client, by cooperatively making a consume-reissue operation with the server.
4.  Clients then claim the value in their credentials by providing pubkeys to pay to, and amount, to the server, plus existing credentials, getting back credentials whose total value is minus the onchain output value.
5.  The server generates the final output set.
6.  The clients check that the final output set is indeed what they expected (their claimed outputs exist) and ratify the overall transaction.
    * In the CoinJoin case, the overall transaction is ratified by generating a single transaction that consumes the inputs and generates the output set, then the clients provide signatures to this transaction as ratification.

WabiSabi Inside Batched CoinSwap
================================

A Batched CoinSwap simply means having multiple takers be serviced in a single transaction by a single maker.

Suppose Alice, Bob, and Carol are takers, and Macky is the maker.

Now suppose that Alice is secretly the princess of a magical kingdom and that Bob saved her life and her entire kingdom, involving a lot of gunfire, explosions, evil wizards, pre-asskicking one-liners, and a bomb that is defused by Bob with just 1 second left on its timer.
Alice now owes a life debt to Bob and agrees to give all her bitcoins to Bob.
However, because the existence of magic is a secret, they do not want Carol, Macky, or the entire Bitcoin world to know about this Alice-to-Bob transaction.

Macky operates as a WabiSabi server, and Alice, Bob, and Carol operate as WabiSabi clients.
Rather than generate a single CoinJoin transaction, they generate a CoinSwap operation.

First, they all agree on future blockheights L1 and L2, where L1 < L2.

Then Alice, Bob, and Carol get the starting 0-value WabiSabi credentials from Macky.
They then register inputs in the WabiSabi protocol, and also additionally perform this sub-ritual in order to "lock in" the input registration:

* Alice (resp. Bob or Carol) creates (but does *not* sign) a funding transaction from Alice coins to MuSig(Alice, Macky).
* Alice and Macky create a backout transaction, with `nLockTime` at L2, and complete the plain MuSig signing ritual.
* Alice broadcasts the original funding transaction.

Macky need not wait for the funding tx to confirm; at a later stage, if it is not confirmed, Macky can cancel the entire ritual and all value transfers within it.

Then, before transitioning to the WabiSabi output registration stage, Macky performs the following ritual with Alice, Bob, and Carol.

* Macky creates (but does *not* sign) a funding transaction from Macky to MuSig(Alice, Bob, Carol, Macky).
  * The value must be greater than or equal to the total input values; but note that Alice, Bob, and Carol need not check this, as it is automatically implied by the later output ratification phase.
* Alice, Bob, Carol, and Macky create a backout transaction, with `nLockTime` at L1 (L1 < L2), and complete the composable MuSig signing ritual.
* Macky broadcasts the original funding transaction.

Again nobody needs to wait for the Macky funding transaction to come onchain at this point.

Alice can then send Bob all her money by use of WabiSabi inter-client value transfers.
Bob should not consider this value transfer as "real" until the entire WabiSabi-in-Batched-CoinSwap ritual is complete, by the way: so for example if Bob is required to marry princess Alice contingent on getting all of the coins of Alice, Bob should avoid the altar until the entire WabiSabi-in-Batched-CoinSwap ritual completes.

Then, output registration can begin.
In output registration, Bob and Carol take on new identities, as Bobby and Carolina, respectively.
Alice, having no funds inside the WabiSabi to reclaim, has no need of the new identity.
"Bobby" claims an output, to be sent to "Bobby", as does "Carolina".

At this point, Macky checks the Alice, Bob, and Carol funding transactions were confirmed deeply.
If not, Macky aborts the CoinSwap and waits until it can reclaim its funds.

Then, Macky enters the output ratification phase.
Macky publishes all the outputs registered, which should include the outputs to "Bobby", "Carolina", and a change output to Macky.
This is done by presenting a transaction spending the Macky funding transaction output with MuSig(Alice, Bob, Carol, Macky) and outputting to "Bobby", "Carolina", and Macky change.

At this point, Alice, Bob, and Carol check that the Macky funding transaction was confirmed deeply.
If not, Alice, Bob, and Carol aborts the CoinSwap and waits until they can reclaim the funds.

Then, Alice, having no outputs, approves the payout transaction.
Bob checks that the "Bobby" output exists and is the correct value.
Carol checks the "Carolina" output exists and is the correct value.
They also check that the payout transaction would actually be valid (outputs + fees = input, current `nLockTime`, etc.).

If one of the takers thinks the server misbehaved, they can just refuse to ratify the output.

Alice, Bob, and Carol can now cooperatively ratify the outputs produced by Macky.
This is done in a long ritual.

* First, Alice, Bob, Carol, and Macky complete the MuSig signing for the payout transaction all the way to R exchange.
* Then Alice, Bob, and Carol compute and broadcast their MuSig signature shares s[A], s[B], and s[C] to each other and to Macky.
* Macky then computes its share s[M], but rather than broadcast it to the takers, broadcasts s[M] * G.

At this point, the participants now turn their attention to the inputs to the mix.

* Now, Alice (resp. Bob or Carol) knows s[A], s[B], s[C], and s[M] * G for the payout transaction.
* Alice and Macky create a claim transaction spending from Alice funding output to Macky.
* Alice and Macky complete the MuSig signing ritual for the Macky claim transaction up to R exchange.
* Macky gives its share of the Macky claim transaction signature to Alice.
* Alice provides an adaptor signature for the Macky claim transaction, whose completion would let Alice learn s[M] for the payout transaction.

After Macky gets partial adaptor signatures from Alice, Bob, and Carol, it can then broadcast s[M] to Alice, Bob, and Carol, completing the payout transaction, and also complete all the claim transaction it needs.
If any of Alice, Bob, or Carol do not provide the partial adaptor signatures for any of the incoming inputs, Macky never broadcasts s[M] and the CoinSwap and all WabiSabi internal value transfers revert.

Private Key Handover
--------------------

It would be possible to hand over private keys for the Alice, Bob, and Carol funding transaction to Macky, and use a kickoff transaction followed by a `nSequence`-timelocked transactions for backing out.
This reduces the onchain space needed when Macky has another new set of clients it wants to serve.

Comparison to WabiSabi Inside CoinJoin
======================================

The above CoinSwap ritual requires more transactions onchain, and thus more expense.

However, it does buy better privacy.

* Carol never learns the inputs of Alice and Bob, and only knows that there are up to 2 other participants in the mix.
  * Carol only ever signs its own funding transaction output, and the payout transaction; the payout transaction does not reveal the inputs that other participants put into the mix.
  * For all Carol knows, the two other participants in the mix were sockpuppets of Macky, or were really just one participant using a sockpuppet.
* Bob never learns the input of Alice.
  * Bob knows how much Alice gave to Bob and that Alice gave her all to Bob, so in a CoinJoin could have scanned for CoinJoin inputs that sum up to how much Alice gave to Bob.
  * With CoinSwap, Bob has to scan recent blocks, which hopefully have much larger input sets and require more effort (and hopefully more false positives).

This is because knowledge of the *other* inputs to the mix is never revealed in a batched CoinSwap, whereas they would be revealed in a CoinJoin.
All that participants learn is the inputs from *previous* takers that the maker served in the past.

From ZmnSCPxj at protonmail.com  Fri Jun 12 08:39:35 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 12 Jun 2020 08:39:35 +0000
Subject: [bitcoin-dev] CoinPool,
	exploring generic payment pools for Fun and Privacy
In-Reply-To: <CALZpt+FqAWCAqCLF2HsajL84sOvst_X9_34bb_tvUxLFw=HTAA@mail.gmail.com>
References: <CALZpt+FqAWCAqCLF2HsajL84sOvst_X9_34bb_tvUxLFw=HTAA@mail.gmail.com>
Message-ID: <7cWQJzkWNEZCI2fYYrJCFxrmGfDGFAtsOyGpXRmB-g4Qhm2jzhyxLtuOIpJAr2CMJjAjri12lmR-h96ev3NWqaTgDtc_NN0yhyVxuIlBuzU=@protonmail.com>

Good morning Antoine and Gleb,

I have not studied the proposal in close detail yet, but anyway, my main takeaway roughly is:

* The core of CoinPool is some kind of multiparticipant (N > 2) offchain update mechanism (Decker-Wattenhofer or Decker-Russell-Osuntokun).
  * The output at each state of the update mechanism is some kind of splitting construction (which I have not studied in detail).
  * At each update of the state, all participants must sign off on the new state.

It seems to me that it would be possible to use a [WabiSabi protocol](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-June/017969.html) during negotiation of a new state.

Now, WabiSabi is a client-server protocol.
As all participants in the CoinPool are needed in order to ratify each new state anyway, they can simply elect one of their number by drawing lots, to act as server for a particular state update.

Then the participants can operate as WabiSabi clients.
Each participant registers the outputs they currently own in the current state, getting credentials that sum up to the correct value.
Then, during the WabiSabi run, they can exchange credentials among the participants in order to perform value transfers inside the WabiSabi construction.
Then, at output registration, they register new outputs to put in the next state of the CoinPool.

In order to hide transfers from the elected WabiSabi server, participants can maintain two coins in every state, and move coins randomly across the two coins they own at each state update, in order to hide "real" transfers from the elected server.

Then, after output registration, the participants ratify the new state by signing off on the new state and revoking the previous state, using the update mechanism.

Of course, we should note that one desired feature for CoinPool in the original proposal is that a participant can exit, and the CoinPool would still remain valid, but only for the remaining participants.

This is arguably a mild privacy leak: every other participant now knows how much that particular participant took out from the CoinPool.
Indeed, from what I can understand, in order to properly set up the splitting transactions in the first place, at each state every participant needs to know how much each other participant actually owns in the CoinPool at that point in time.

To hide how much each participant owns in the CoinPool from other participants, we would have to make unilateral closes expose all the current outputs, without trying to identify *which* participant exited the CoinPool, and thus preventing anyone else from figuring out exactly how much each *other* participant actually owns in the CoinPool on exit.
That way, output addresses can be to fresh pseudonyms of the participant, removing all linkages of participant to amount they own, and each participant can maintain multiple outputs per state for their own purposes and to mildly obscure exactly how much they own in total.

If we drop that feature (of being able to exit a participant without closing the *entire* CoinPool), of course, we need to mildly disincentivize a participant closing unilaterally for trivial reasons.
We can do this by using `SIGHASH_ANYPREVOUT` to force whoever performs a unilateral close of the CoinPool to pay the onchain fees involved, so that it would have to be a good reason indeed to perform a unilateral close.


Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Fri Jun 12 14:53:59 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 12 Jun 2020 14:53:59 +0000
Subject: [bitcoin-dev] WabiSabi Inside Batched CoinSwap
In-Reply-To: <D2DWwPP0JpNM3V2tbq_dUMZl4W24rsE6Evn265S6KEwe-_vyc9KNy8gHegbFzoM2xr72d_9VwsXHe3TSYmXpXM7ytkN5zIqZnskXL-Ew_xQ=@protonmail.com>
References: <D2DWwPP0JpNM3V2tbq_dUMZl4W24rsE6Evn265S6KEwe-_vyc9KNy8gHegbFzoM2xr72d_9VwsXHe3TSYmXpXM7ytkN5zIqZnskXL-Ew_xQ=@protonmail.com>
Message-ID: <bJ0u2EZrWaddQ1HusB727hSVEOKe37vqekZvgNuAsDs6LgaTfcL2LYejFLaZqMy8y1yuugpgWQB-o9wwd8SY81PE0nikiEHgTuK4V4GY16s=@protonmail.com>

Good morning list,

> -   Alice (resp. Bob or Carol) creates (but does not sign) a funding transaction from Alice coins to MuSig(Alice, Macky).
> -   Alice and Macky create a backout transaction, with `nLockTime` at L2, and complete the plain MuSig signing ritual.
> -   Alice broadcasts the original funding transaction.

Sorry, the taker funding transactions should have the nearer locktime L1, and the maker funding transctions should be the one with the later locktime L2.
This forces Macky to claim the incoming funds earlier, and claiming any of them unlocks the outgoing payout transaction.


Regards,
ZmnSCPxj

From tom at commerceblock.com  Fri Jun 12 18:11:52 2020
From: tom at commerceblock.com (Tom Trevethan)
Date: Fri, 12 Jun 2020 19:11:52 +0100
Subject: [bitcoin-dev] Blind Statechains
Message-ID: <CAJvkSsewzYTAsm0tneu6-9MT0a-CcYvJBcSmhzCUkmAJ95=T3A@mail.gmail.com>

Hello,

A statechain implementation and service co-signs 'backup' (off-chain)
transactions to transfer ownership of a UTXO from one owner to the next. A
suggested here
https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39
, this service (the statechain entity or SE) can be engineered to be
'blind' to the transactions it is signing (i.e. it does not and cannot know
the details of the transactions it is signing) which can give significant
privacy benefits. It would enable more private off-chain coin-swaps, and
make collusion more difficult.

The only downside of a blind SE is that it can no longer enforce the rules
governing the sequence of backup transactions it co-signs as owners can ask
the SE to cosign any transaction. So each new owner of a UTXO must receive,
store and verify the full sequence of previous owner backup transactions to
make sure that no previous owner has asked the SE to sign a transaction
that could be used to steal the UTXO. This may end up making wallets more
bloated and clunky, given that ownership of a UTXO could change hands
thousands of times off-chain.

In the case of a multisig, and Schnorr signatures, existing blind Schnorr
protocols could be used to implement a blind SE, however we are opting to
use two-party ECDSA (because there is no Schnorr yet, and in any case ECDSA
will give a much bigger anonymity set). There is no current 2P ECDSA
protocol that enables one of the two signers to be completely blinded, but
it seems that this would require only minor modifications to an existing 2P
ECDSA scheme (outlined here
https://github.com/commerceblock/mercury/blob/master/doc/blind_2p_ecdsa.md
based on Lindell 2017 https://eprint.iacr.org/2017/552 ).

Any comments on any of this gratefully received.

Tom
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200612/3dbd6277/attachment.html>

From rsomsen at gmail.com  Fri Jun 12 20:35:37 2020
From: rsomsen at gmail.com (Ruben Somsen)
Date: Fri, 12 Jun 2020 22:35:37 +0200
Subject: [bitcoin-dev] Blind Statechains
In-Reply-To: <CAJvkSsewzYTAsm0tneu6-9MT0a-CcYvJBcSmhzCUkmAJ95=T3A@mail.gmail.com>
References: <CAJvkSsewzYTAsm0tneu6-9MT0a-CcYvJBcSmhzCUkmAJ95=T3A@mail.gmail.com>
Message-ID: <CAPv7TjZ_MBCmWZ5CnUk0G0MhHL65cpGyt_dMDONDTzJBHpVUQg@mail.gmail.com>

Hi Tom,

Blind signatures are certainly a nice feature, great to see that you're
considering it.

>So each new owner of a UTXO must receive, store and verify the full
sequence of previous owner backup transactions to make sure that no
previous owner has asked the SE to sign a transaction that could be used to
steal the UTXO. This may end up making wallets more bloated and clunky,
given that ownership of a UTXO could change hands thousands of times
off-chain.

Users would have to validate the history of the chain regardless, even if
it wasn't blind, to verify whether the statechain entity hasn't been
cheating, so the main difference would be in unblinding the data.

One of my original ideas was to use the transitory key to derive the
secrets that blind the signatures (basically like an HD wallet). The
statechain entity would then store and serve blind signatures, and any new
owner would download and unblind/verify them using the transitory key (no
extensive peer-to-peer transfer needed). It's possible to make the
off-chain transactions themselves deterministic, so they can just be
generated by the client without any additional data transfer. The only
potentially unique thing in a transaction is the refund address, but this
can be the same key as the ownership key on the statechain, tweaked with
the transitory key via Diffie-Hellman (to ensure it's not linkable if it
goes on-chain).

The general downside of this method is that all transactions are exposed to
anyone who learns the transitory key -- not just for the current
transactions (which can always be leaked no matter what you do), but also
all future transactions in that particular statechain. However, I should
note there doesn't actually seem to be much to learn, because the history
of each statechain is actually quite uninformative. The money just goes
from one pseudonymous owner to the next.

Of course you now have scheme that changes the transitory key with each
step, so I instead suggest you introduce a secondary "blinding key" to
achieve what I described.

I'm not sure whether this can also apply to 2P-ECDSA, but with Schnorr the
statechain entity wouldn't even learn the address for the funding
transaction, so it wouldn't be able to tell which UTXO it controls by
watching the blockchain. Ideally, this functionality would be preserved to
ensure the statechain entity can't be aware of the funds it's holding.

Another thing to note is that you won't know when a statechain has been
pegged out, so pruning will be impossible. You may wish to consider some
kind of liveness rule where one statechain transaction needs to be made per
year. If they miss the deadline, they're just forced on-chain, which is not
terrible, in any case.

Hope this helps!

Cheers,
Ruben



On Fri, Jun 12, 2020 at 9:23 PM Tom Trevethan via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hello,
>
> A statechain implementation and service co-signs 'backup' (off-chain)
> transactions to transfer ownership of a UTXO from one owner to the next. A
> suggested here
> https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39
> , this service (the statechain entity or SE) can be engineered to be
> 'blind' to the transactions it is signing (i.e. it does not and cannot know
> the details of the transactions it is signing) which can give significant
> privacy benefits. It would enable more private off-chain coin-swaps, and
> make collusion more difficult.
>
> The only downside of a blind SE is that it can no longer enforce the rules
> governing the sequence of backup transactions it co-signs as owners can ask
> the SE to cosign any transaction. So each new owner of a UTXO must receive,
> store and verify the full sequence of previous owner backup transactions to
> make sure that no previous owner has asked the SE to sign a transaction
> that could be used to steal the UTXO. This may end up making wallets more
> bloated and clunky, given that ownership of a UTXO could change hands
> thousands of times off-chain.
>
> In the case of a multisig, and Schnorr signatures, existing blind Schnorr
> protocols could be used to implement a blind SE, however we are opting to
> use two-party ECDSA (because there is no Schnorr yet, and in any case ECDSA
> will give a much bigger anonymity set). There is no current 2P ECDSA
> protocol that enables one of the two signers to be completely blinded, but
> it seems that this would require only minor modifications to an existing 2P
> ECDSA scheme (outlined here
> https://github.com/commerceblock/mercury/blob/master/doc/blind_2p_ecdsa.md
> based on Lindell 2017 https://eprint.iacr.org/2017/552 ).
>
> Any comments on any of this gratefully received.
>
> Tom
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200612/c04c1c19/attachment.html>

From antoine.riard at gmail.com  Fri Jun 12 23:45:35 2020
From: antoine.riard at gmail.com (Antoine Riard)
Date: Fri, 12 Jun 2020 19:45:35 -0400
Subject: [bitcoin-dev] CoinPool,
 exploring generic payment pools for Fun and Privacy
In-Reply-To: <CAD5xwhjkstCcF49s8r8ZqVH77VmWXaZSm=_sx=FKZuCj6Ci_UA@mail.gmail.com>
References: <CALZpt+FqAWCAqCLF2HsajL84sOvst_X9_34bb_tvUxLFw=HTAA@mail.gmail.com>
 <CAD5xwhjkstCcF49s8r8ZqVH77VmWXaZSm=_sx=FKZuCj6Ci_UA@mail.gmail.com>
Message-ID: <CALZpt+Ec+K4oGXVexLikGKbGgcZ=AF+Spskx5SK-Om-HzuAAmg@mail.gmail.com>

Hi Jeremy,

For the records, I didn't know between Greg and you was at the origin of
payment pools. Thanks for your pioneer work here, obviously this draws
inspiration from OP_CTV use cases and Channel Factories works, even if we
picked up different assumptions and tried to address another set of issues.

With regards to scalability, I hit it on my own while inquiring
covenanted-Bitcoin contracts for international trade. I mentioned the
any-order issue on such multi-party complex contracts in a talk last summer
(https://github.com/ariard/talk-slides/blob/master/advanced-contracts.pdf).

> All of these channels can be constructed and set up non-interatively using
> CTV, and updated interactively. By default payments can happen with
minimal
> coordination of parties by standard lightning channel updates at the leaf
> nodes, and channels can be rebalanced at higher layers with more
> participation.

Side review note on OP_CTV: I think it would be great to define
non-interactivity better, namely at least between 3 phases: establishment,
operation, closing.

Even OP_CTV protocols assume interactivity at establishment, at least 1) to
learn payees pubkeys endpoint (and internal leaves pubkeys if you want
update at operation) 2) validate transaction tree correctness between
participants.

At operation, it depends if participants want to dynamically rebalance
value across channels or not. If you desire dynamically rebalancing, assume
internal leaves scriptpubkeys are (multisig-all OR OP_CTV'ed merkle_tree).
Using OP_CTV is a saving in message rounds for every constant expression
across tree updates.

At closing, depends again if participants have committed update keys or
not. If dynamic update, you can prune the whole tree and just commit final
balances onchain, either with a O(N) fan-out transaction (N outputs) or a
O(log(N)) congestion tree (N transactions).

So I would say the originality of a hashchain covenant like OP_CTV is to
provide onchain *immutability* (unforgeability?) of the offchain
transaction tree and thus provides instant finality to payees. You can get
the same semantic with off-chain covenant, pre-signed set of transactions,
assuming more communications rounds and performance hit.

That said, IMO, immutability comes with a security trade-off, namely if any
payout key committed in your OP_CTV tree gets compromised your funds are at
stake. And you can't update the tree anymore at the root to rotate keys. I
think this should be weighted by anyone designing covenant protocols,
especially vaults.

> I don't think the following requirement: "A
> CoinPool must satisfy the following *non-interactive any-order withdrawal*
> property: at any point in time and any possible sequence of previous
> CoinPool events, a participant should be able to move their funds from the
> CoinPool to any address the participant wants without cooperation with
> other CoinPool members." is desirable in O(1) space.

With current design (Pool_tx+Split_tx) it's O(2) space. Pool_tx is similar
to a commitment tx and thus enables off-chain novation of pool distribution.

> Let's be favorable to Accumulators and assume O(1), but keep in mind
constant may
> be somewhat large/operations might be expensive in validation for updates.

Using a Merkle Tree as an accumulator should be constant-size in space, but
likely it has to be O(log(N) in computation (N set elements). This overhead
in computation should be accounted for in accumulator sigops to avoid
network validation resources free-riding, but I think it's a better
trade-off minimizing chain footprint.

> So in this context, CTV Pool has a clear benefit. The last recipient can
> always clear in Log(N) time whereas in the accumulator pool, the last
> recipient has to wait much much longer. There's no asymptotic difference
in
> Tx Size, but I suspect that CTV is at least as good or cheaper since it's
> just one tx hash and doesn't depend on implementation.

Yes I agree CTV pool performs better in the worst-case scenario. In my
opinon what we should really look on is the probability of withdrawal
scenarios. I see 2 failure cases:
* a pool participant being offline, thus halting the pool
* a pool participant with external protocol requirement to fulfill, like a
HTLC to timeout onchain

With regards to 1) we assume that watchtower infra are likely to become
ubiquitous in the future (if you want a secure LN experience), so user
uptime should be near to 100%. Of course,  it's a new architecture which
comes with trade-offs, but interesting to explore.

With regards to 2) as of today channel-failure-rate (like unilateral close)
it's still quite important (30% IIRC) so it plays in favor of OP_CTV pool
but in the future I expect single-digit
therefore making CoinPool far more competitive. Do we envision protocol
more time-sensitive than LN in the future (atomic swaps...) ? Hard to gauge.

Do you see other ways to refine model, like integrating out-of-pool
liquidity needs rate ?

Note, I think for OP_CTV tree, increasing radix increases cooperation
requirement and failure, so there should be optimum somewhere.

> If your group is not cooperating because one
> person is permanently offline, then Accumulator pools *guarantee* you need
> to go through a full on-chain redemption.

That's right, that's a current shortcoming of this strawman design, I think
you can avoided by adding some timelocks, "if Alice doesn't anwser after X
days, initiate a kick-out", thus avoiding full onchain unrolling.

> But I'm unclear how
> to make this safe w.r.t. updated states. You could also allow, perhaps,
any
> number of operators to simultaneously leave in a tx. Also not sure how to
> do that.

I'm still thinking on this too, especially in LN-context, ideally you do
want the same thing to kick-out a HTLC of your HTLC-tree while preserving
the rest of them. Technically it works, if you assume CSV delay on the
commitment/pool_tx and locktime on the HTLC, which is Eltoo tradeoff.

> With Accumulator pools, you need all parties online to make payments.

I think that our shortcoming here, but technically with protocol rebinding
on any withdrawal output of Split_tx, you can have M-of-N channels between
pool participants. Also we should aim to support any kind of protocol at
the leaves.

> Because Accumulator pools always require N signers, it's possible to build
> a better privacy model where N parties are essentially managing a chaumian
> ecash like server for updates, giving good privacy of who initiated
> payments.

Yes that what I've in mind is something with blind signatures or any
obfuscation of pool tree construction as privacy optimization. Still you
will leak value weight of leaves to an in-pool observer.

> Both protocols require new features in Bitcoin. CTV is relatively simple,
I
> would posit that accumulators + sighashnoinput are relatively not simple.

I agree design, review, deployment costs are an order of magnitude higher.
That said they are more powerful primitives which would cover use cases
beyond pools. A concern with OP_CTV is if we want semantic extensions we
may realize they don't rank that well compared to more generic "base"
primitives.

> In both designs, the payment pool can be created non-interactively. This
is
> *super* important as it means third parties (e.g., an exchange) can
> withdraw users funds *into* a payment pool.

See my point above, I think we need a better definition of
non-interactivity.

Thanks for the high-quality review of CoinPool !

Antoine

Le jeu. 11 juin 2020 ? 13:21, Jeremy <jlrubin at mit.edu> a ?crit :

> Stellar work Antoine and Gleb! Really excited to see designs come out on
> payment pools.
>
> I've also been designing some payment pools (I have some not ready code I
> can share with you guys off list), and I wanted to share what I learned
> here in case it's useful.
>
> In my design of payment pools, I don't think the following requirement: "A
> CoinPool must satisfy the following *non-interactive any-order withdrawal*
> property: at any point in time and any possible sequence of previous
> CoinPool events, a participant should be able to move their funds from the
> CoinPool to any address the participant wants without cooperation with
> other CoinPool members." is desirable in O(1) space. I think it's much
> better to set the requirement to O(log(n)), and this isn't just because of
> wanting to use CTV, although it does help.
>
> Let me describe a quick CTV based payment pool:
>
> Build a payment pool for N users as N/2 channels between participants
> created in a payment tree with a radix of R, where every node has a
> multisig path for being used as a multi-party channel and the CTV branch
> has a preset timeout. E.g., with radix 2:
>
>                                       Channel(a,b,c,d,e,f,g,h)
>                                      /                                   \
>                Channel(a,b,c,d)
> Channel(e,f,g,h)
>                     /
> \                                                    /                 \
> Channel(a,b)    Channel(c,d)                          Channel(e,f)
> Channel(g,h)
>
>
> All of these channels can be constructed and set up non-interatively using
> CTV, and updated interactively. By default payments can happen with minimal
> coordination of parties by standard lightning channel updates at the leaf
> nodes, and channels can be rebalanced at higher layers with more
> participation.
>
>
> Now let's compare the first-person exit non cooperative scenario across
> pools:
>
> CTV-Pool:
> Wait time: Log(N). At each branch, you must wait for a timeout, and you
> have to go through log N to make sure there are no updated states. You can
> trade off wait time/fees by picking different radixes.
> TXN Size: Log(N) 1000 people with radix 4 --> 5 wait periods. 5*4 txn
> size. Radix 20 --> 2 wait periods. 2*20 txn size.
>
> Accumulator-Pool:
> Wait Time: O(1)
> TXN Size: Depending on accumulator: O(1), O(log N), O(N) bits. Let's be
> favorable to Accumulators and assumer O(1), but keep in mind constant may
> be somewhat large/operations might be expensive in validation for updates.
>
>
> This *seems* like a clear win for Accumulators. But not so fast. Let's
> look at the case where *everyone* exits non cooperatively from a payment
> pool. What is the total work and time?
>
> CTV Pool:
> Wait time: Log(N)
> Txn Size: O(N) (no worse than 2x factor overhead with radix 2, higher
> radixes dramatically less overhead)
>
> Accumulator Pool:
> Wait time: O(N)
> Txn Size: O(N) (bear in mind *maybe* O(N^2) or O(N log N) if we use an
> sub-optimal accumulator, or validation work may be expensive depending on
> the new primitive)
>
>
> So in this context, CTV Pool has a clear benefit. The last recipient can
> always clear in Log(N) time whereas in the accumulator pool, the last
> recipient has to wait much much longer. There's no asymptotic difference in
> Tx Size, but I suspect that CTV is at least as good or cheaper since it's
> just one tx hash and doesn't depend on implementation.
>
> Another property that is nice about the CTV pool style is the bisecting
> property. Every time you have to do an uncooperative withdrawal, you split
> the group into R groups. If your group is not cooperating because one
> person is permanently offline, then Accumulator pools *guarantee* you need
> to go through a full on-chain redemption. Not so with a CTV-style pool, as
> if you have a single failure among [1,2,3,4,5,6,7,8,9,10] channels (let's
> say channel 8 fails), then with a radix 4 setup your next steps are:
> [1,2,3,4,5,6,7,8,9,10]
> [1,2,3,4,5,6,7,X,9,10]
> [1,2,3,4] [5,6,7,X] [9,10]
> [1,2,3,4] 5 6 7 X [9,10]
>
> So you only need to do Log(N) chain work to exit the bad actor, but then
> it amortizes! A future failure (let's say of 5) only causes 5 to have to
> close their channel, and does not affect anyone else.
>
> With an accumulator based pool, if you re-pool after one failure, a second
> failure causes another O(N) work. So then total work in that case is
> O(N^2). You can improve the design by making the evict in any order option
> such that you can *kick out* a member in any order, that helps solve some
> of this nastiness (rather than them opting to leave). But I'm unclear how
> to make this safe w.r.t. updated states. You could also allow, perhaps, any
> number of operators to simultaneously leave in a tx. Also not sure how to
> do that.
>
>
>
> Availability:
> With CTV Pools, you can make a payment if just your immediate conterparty
> is online in your channel. Opportunistically, if people above you are
> online, you can make channel updates higher up in the tree which have
> better timeout properties. You can also create new channels, binding
> yourself to different parties if there is a planned exit.
>
> With Accumulator pools, you need all parties online to make payments.
>
>
> Cooperation Case:
> CTV Pools and Accumulator pools, in a cooperative case, both just act like
> a N of N multisig.
>
> Privacy:
> Because Accumulator pools always require N signers, it's possible to build
> a better privacy model where N parties are essentially managing a chaumian
> ecash like server for updates, giving good privacy of who initiated
> payments. You *could* do this with CTV pools as well, but I expect users to
> prefer making updates at the 2 party channel layer for low latency, and to
> get privacy benefits out of the routability of the channels and ability to
> connect to the broader lightning network.
>
>
> Technical Complexity:
> Both protocols require new features in Bitcoin. CTV is relatively simple,
> I would posit that accumulators + sighashnoinput are relatively not simple.
>
> The actual protocol design for CTV pools is pretty simple and can be
> compatible with LN, I already have a rudimentary implementation of the
> required transactions (but not servers).
>
>
> Interactivity:
>
> In both designs, the payment pool can be created non-interactively. This
> is *super* important as it means third parties (e.g., an exchange) can
> withdraw users funds *into* a payment pool.
>
>
> Thanks for reading!
>
> Jeremy
>
>
>
> --
> @JeremyRubin <https://twitter.com/JeremyRubin>
> <https://twitter.com/JeremyRubin>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200612/2afbf136/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Sat Jun 13 00:45:12 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 13 Jun 2020 00:45:12 +0000
Subject: [bitcoin-dev] CoinPool,
	exploring generic payment pools for Fun and Privacy
In-Reply-To: <CALZpt+EsACbq1QM9MFkC63_gDXW0vHfeTjXc7C9r4+2-1WKAJw@mail.gmail.com>
References: <CALZpt+FqAWCAqCLF2HsajL84sOvst_X9_34bb_tvUxLFw=HTAA@mail.gmail.com>
 <7cWQJzkWNEZCI2fYYrJCFxrmGfDGFAtsOyGpXRmB-g4Qhm2jzhyxLtuOIpJAr2CMJjAjri12lmR-h96ev3NWqaTgDtc_NN0yhyVxuIlBuzU=@protonmail.com>
 <CALZpt+EsACbq1QM9MFkC63_gDXW0vHfeTjXc7C9r4+2-1WKAJw@mail.gmail.com>
Message-ID: <m-yAKsQ52s-bYOrtEXVwETAcJ8sSbJt0k9WDN1ueidJ01IaEHRJtq9Odffmz_2utLxPfmI418x58aFc3vKBpOD2FKqgeCUAn1mvI1OSyGRY=@protonmail.com>

Good morning Antoine,


> Yes, that's part of future research, defining better *in-pool* observer. Sadly, right now, even if you use mask construction inside, it's quite easy to trace leaves by value weight. Of course, you can enforce equal-value leaves, as for a regular onchain CoinJoin. I think it comes with a higher onchain cost in case of pool breakage.


Perhaps not necessarily.

An advantage of WabiSabi is I can pretend to be two or more participants.

For example, I can pretend to be "Alice" and "Bob", and pretend that "Alice" owes a life debt to "Bob".

At initial state setup, I put a 1.0 BTC coin as "Alice" and a 0.5 BTC coin as "Bob".

Now, at each state update I need to sign as "Alice" and "Bob".
However, after the first initial state, I can use a new persona "Bobby" to *own* my coins, even though I still have to sign as "Alice" and "Bob" in every state update.

What the other pool participants see is that the 1.0 BTC "Alice" coin and the 0.5 BTC "Bob" coin are merged into the 1.5 BTC "Bobby" coin.
What they cannot be sure of is:

* "Alice" paid to "Bob", who is now pretending to be "Bobby".
* "Bob" paid to "Alice", who is now pretending to be "Bobby".
* "Alice" and "Bob" are the same person, and is also pretending to be "Bobby".

All the other participants know is that whoever owns the coin *now* is still part of the pool, but cannot be sure which participant *really* owns which coin, and whether participants are sockpuppets (which is why it should use n-of-n at each state update, incidentally).

In effect, it "imports" the possibility of PayJoin inside the CoinPool construction.



Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Sat Jun 13 01:20:16 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 13 Jun 2020 01:20:16 +0000
Subject: [bitcoin-dev] CoinPool,
	exploring generic payment pools for Fun and Privacy
In-Reply-To: <m-yAKsQ52s-bYOrtEXVwETAcJ8sSbJt0k9WDN1ueidJ01IaEHRJtq9Odffmz_2utLxPfmI418x58aFc3vKBpOD2FKqgeCUAn1mvI1OSyGRY=@protonmail.com>
References: <CALZpt+FqAWCAqCLF2HsajL84sOvst_X9_34bb_tvUxLFw=HTAA@mail.gmail.com>
 <7cWQJzkWNEZCI2fYYrJCFxrmGfDGFAtsOyGpXRmB-g4Qhm2jzhyxLtuOIpJAr2CMJjAjri12lmR-h96ev3NWqaTgDtc_NN0yhyVxuIlBuzU=@protonmail.com>
 <CALZpt+EsACbq1QM9MFkC63_gDXW0vHfeTjXc7C9r4+2-1WKAJw@mail.gmail.com>
 <m-yAKsQ52s-bYOrtEXVwETAcJ8sSbJt0k9WDN1ueidJ01IaEHRJtq9Odffmz_2utLxPfmI418x58aFc3vKBpOD2FKqgeCUAn1mvI1OSyGRY=@protonmail.com>
Message-ID: <7BPgx65Eh5HE5wLIqeG9G-bdsxxkDJJIzcyOJvS6_FIxXfA10sbFe5dfwQDNiEOExZ9Y72lHq88lKzcBRIFnYGFY5I2vwk6Dg7BcCMjmS2Y=@protonmail.com>

Good morning Antoine,

By dropping the requirement that a participant can seamlessly leave the CoinPool, it allows participants to split up their coins among new aliases and to use a different identity for later claiming coins.
With WabiSabi, none of the other participants can get a mapping between current-state aliases and the actual participants.

Now, in order to authorize moving coins from an output on the current state to a new output on the next state, obviously the pool needs to get a signature from its current owner.
Ideally, we would not want to have to implement SCRIPT inside the CoinPool software.

And with Taproot, a pubkey can hide one or more SCRIPTs.
If we use pubkeys as the identities of owners of coins, then it allows an alias to encode a SCRIPT.

With the combination of both features, we can instantiate HTLCs (or, with `SIGHASH_ANYPREVOUT`, PTLCs) inside a CoinPool "alias" pubkey identity, allowing for interoperation with LN.

Now suppose I have 1.0 BTC in a CoinPool.
I want to make an HTLC with you (hashlocked to you, timelocked to me), for 0.5 BTC.

I encode the HTLC SCRIPT, and put it into a Taproot whose internal pubkey is a MuSig of fresh identities of mine and yours.

Then, inside the CoinPool, I split my 1.0BTC to a 0.5BTC coin to a fresh identity of mine, and 0.5BTC to our HTLC Taproot.

If you can acquire the hash, you give it to me, and I am supposed to hand you a partial signature share to the HTLC Taproot that you can later complete and present to the CoinPool in the next update round in order to get the HTLC value.
If I do not hand you the signature share even after you hand the hash, you just drop the entire CoinPool onchain, instantiating the HTLC Taproot output onchain, and using the SCRIPT branch to claim using the hash you know.

If the timelock expires, I ask you to hand over your partial signature to the HTLC Taproot that I can later complete and present to the CoinPool in the next update round to recover the HTLC value.
If you do not hand over the signature share, I drop the CoinPool onchain, which instantiates the HTLC Taproot output onchain, and use the SCRIPT branch to claim using the timelock branch.

You can also ask to abort the HTLC "early", before the timelock expires, by handing over your partial signature to the HTLC Taproot, which I can later complete and present to the CoinPool in the next update round.
This is equivalent to `update_fail_htlc` in the current LN BOLT spec.

This allows operation of any SCRIPT, incidentally, without requiring that CoinPool software include a SCRIPT interpreter, only signature validation.
Any time an output absolutely needs a SCRIPT, we just drop the CoinPool onchain and let onchain handle the SCRIPT interpretation.

Regards,
ZmnSCPxj


From antoine.riard at gmail.com  Sat Jun 13 00:28:27 2020
From: antoine.riard at gmail.com (Antoine Riard)
Date: Fri, 12 Jun 2020 20:28:27 -0400
Subject: [bitcoin-dev] CoinPool,
 exploring generic payment pools for Fun and Privacy
In-Reply-To: <7cWQJzkWNEZCI2fYYrJCFxrmGfDGFAtsOyGpXRmB-g4Qhm2jzhyxLtuOIpJAr2CMJjAjri12lmR-h96ev3NWqaTgDtc_NN0yhyVxuIlBuzU=@protonmail.com>
References: <CALZpt+FqAWCAqCLF2HsajL84sOvst_X9_34bb_tvUxLFw=HTAA@mail.gmail.com>
 <7cWQJzkWNEZCI2fYYrJCFxrmGfDGFAtsOyGpXRmB-g4Qhm2jzhyxLtuOIpJAr2CMJjAjri12lmR-h96ev3NWqaTgDtc_NN0yhyVxuIlBuzU=@protonmail.com>
Message-ID: <CALZpt+EsACbq1QM9MFkC63_gDXW0vHfeTjXc7C9r4+2-1WKAJw@mail.gmail.com>

Hi ZmnSCPxj,

> I have not studied the proposal in close detail yet, but anyway, my main
takeaway roughly is:
>
> * The core of CoinPool is some kind of multiparticipant (N > 2) offchain
update mechanism (Decker-Wattenhofer or Decker-Russell-Osuntokun).
>   * The output at each state of the update mechanism is some kind of
splitting construction (which I have not studied in detail).
>   * At each update of the state, all participants must sign off on the
new state.

Overall, that's a really accurate description. I would add you can embed a
funding outpoint of any offchain protocol on the splitting construction,
modulo some timelocks shenanigans.

> In order to hide transfers from the elected WabiSabi server, participants
can maintain two coins in every state, and move coins randomly across the
two coins they own at each state update, in order to hide "real" transfers
from the elected server.

Yes I'm quite sure you can reuse WabiSabi as a communication channel
between participants, assuming you support tapscript and merkle branch
transports, and server build a tree. Generally, we tried to keep design as
flexible as we can to reuse privacy tools.

> Indeed, from what I can understand, in order to properly set up the
splitting transactions in the first place, at each state every participant
needs to know how much each other participant actually owns in the CoinPool
at that point in time.

Yes, that's part of future research, defining better *in-pool* observer.
Sadly, right now, even if you use mask construction inside, it's quite easy
to trace leaves by value weight. Of course, you can enforce equal-value
leaves, as for a regular onchain CoinJoin. I think it comes with a higher
onchain cost in case of pool breakage.

> That way, output addresses can be to fresh pseudonyms of the participant,
removing all linkages of participant to amount they own, and each
participant can maintain multiple outputs per state for their own purposes
and to mildly obscure exactly how much they own in total.

That's right that an in-pool observer may learn a link between an exit and
an onchain withdraw. There is a future optimization, if you can swap your
withdraw with an already onchain output, therefore breaking heuristics.

> We can do this by using `SIGHASH_ANYPREVOUT` to force whoever performs a
unilateral close of the CoinPool to pay the onchain fees involved, so that
it would have to be a good reason indeed to perform a unilateral close.

Absolutely, for the fee structure, as the withdraw output is at the
discretion of user, I was thinking some CPFP. There is maybe a better
solution, haven't spend that much on the exact adequate, incentives-align
mechanism beyond a "withdraw-must-pay-its-fees".

Thanks for the high-quality review, as usual ;)

Antoine

Le ven. 12 juin 2020 ? 04:39, ZmnSCPxj <ZmnSCPxj at protonmail.com> a ?crit :

> Good morning Antoine and Gleb,
>
> I have not studied the proposal in close detail yet, but anyway, my main
> takeaway roughly is:
>
> * The core of CoinPool is some kind of multiparticipant (N > 2) offchain
> update mechanism (Decker-Wattenhofer or Decker-Russell-Osuntokun).
>   * The output at each state of the update mechanism is some kind of
> splitting construction (which I have not studied in detail).
>   * At each update of the state, all participants must sign off on the new
> state.
>
> It seems to me that it would be possible to use a [WabiSabi protocol](
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-June/017969.html)
> during negotiation of a new state.
>
> Now, WabiSabi is a client-server protocol.
> As all participants in the CoinPool are needed in order to ratify each new
> state anyway, they can simply elect one of their number by drawing lots, to
> act as server for a particular state update.
>
> Then the participants can operate as WabiSabi clients.
> Each participant registers the outputs they currently own in the current
> state, getting credentials that sum up to the correct value.
> Then, during the WabiSabi run, they can exchange credentials among the
> participants in order to perform value transfers inside the WabiSabi
> construction.
> Then, at output registration, they register new outputs to put in the next
> state of the CoinPool.
>
> In order to hide transfers from the elected WabiSabi server, participants
> can maintain two coins in every state, and move coins randomly across the
> two coins they own at each state update, in order to hide "real" transfers
> from the elected server.
>
> Then, after output registration, the participants ratify the new state by
> signing off on the new state and revoking the previous state, using the
> update mechanism.
>
> Of course, we should note that one desired feature for CoinPool in the
> original proposal is that a participant can exit, and the CoinPool would
> still remain valid, but only for the remaining participants.
>
> This is arguably a mild privacy leak: every other participant now knows
> how much that particular participant took out from the CoinPool.
> Indeed, from what I can understand, in order to properly set up the
> splitting transactions in the first place, at each state every participant
> needs to know how much each other participant actually owns in the CoinPool
> at that point in time.
>
> To hide how much each participant owns in the CoinPool from other
> participants, we would have to make unilateral closes expose all the
> current outputs, without trying to identify *which* participant exited the
> CoinPool, and thus preventing anyone else from figuring out exactly how
> much each *other* participant actually owns in the CoinPool on exit.
> That way, output addresses can be to fresh pseudonyms of the participant,
> removing all linkages of participant to amount they own, and each
> participant can maintain multiple outputs per state for their own purposes
> and to mildly obscure exactly how much they own in total.
>
> If we drop that feature (of being able to exit a participant without
> closing the *entire* CoinPool), of course, we need to mildly disincentivize
> a participant closing unilaterally for trivial reasons.
> We can do this by using `SIGHASH_ANYPREVOUT` to force whoever performs a
> unilateral close of the CoinPool to pay the onchain fees involved, so that
> it would have to be a good reason indeed to perform a unilateral close.
>
>
> Regards,
> ZmnSCPxj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200612/1cdc8d6b/attachment.html>

From belcher at riseup.net  Sat Jun 13 13:38:35 2020
From: belcher at riseup.net (Chris Belcher)
Date: Sat, 13 Jun 2020 14:38:35 +0100
Subject: [bitcoin-dev] Hiding CoinSwap Makers Among Custodial Services
In-Reply-To: <fQt0iIzsA5QprW64lX4SR1R78Aj6e-WqIgSMvk75mdiagQmAchIUqCpXzDjD4jPBhorg0i-oGlrYz7ot2xWMgJiha-eGFzl3PxbtZ-mbjSc=@protonmail.com>
References: <fQt0iIzsA5QprW64lX4SR1R78Aj6e-WqIgSMvk75mdiagQmAchIUqCpXzDjD4jPBhorg0i-oGlrYz7ot2xWMgJiha-eGFzl3PxbtZ-mbjSc=@protonmail.com>
Message-ID: <9a2e9ba4-1dda-e5bb-2587-bfe589d24c70@riseup.net>

Hello ZmnSCPxj,

On 11/06/2020 12:51, ZmnSCPxj wrote:
> Good morning Chris, and bitcoin-dev (but mostly Chris),
> 
> 
> I made a random comment regarding taint on bitcoin-dev recently: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-June/017961.html
> 
>> For CoinSwap as well, we can consider that a CoinSwap server could make multiple CoinSwaps with various clients.
>> This leads to the CoinSwap server owning many small UTXOs, which it at some point aggregates into a large UTXO that it then uses to service more clients (for example, it serves many small clients, then has to serve a single large client that wants a single large UTXO for its own purposes).
>> This aggregation again leads to spreading of taint.
> 
> I want to propose some particular behaviors a SwapMarket maker can engage in, to improve the privacy of its customers.
> 
> Let us suppose that individual swaps use some variant of Succinct Atomic Swap.
> Takers take on the role of Alice in the SAS description, makers take on the role of Bob.
> We may be able to tweak the SAS protocol or some of its parameters for our purposes.
> 
> Now, what we will do is to have the maker operate in rounds.
> 
> Suppose two takers, T1 and T2, contact the sole maker M in its first ever round.
> T1 and T2 have some coins they want to swap.
> They arrange things all the way to confirmation of the Alice-side funding tx, and pause just before Bob creates its own funding tx for their individual swaps.
> The chain now shows these txes/UTXOs:
> 
>      42 of T1 --->  42 of T1 & M
>      50 of T2 --->  50 of T2 & M
>     100 of T1 ---> 100 of T1 & M
> 
>     200 of M  -
> 
> Now the entire point of operating in rounds is precisely so that M can service multiple clients at the same time with a single transaction, i.e. batching.
> So now M provides its B-side tx and complete the SAS protocols with each of the takers.
> SAS gives unilateral control of the outputs directly to the takers, so we elide the fact that they are really 2-of-2s below:
> 
>      42 of T1 --->  42 of T1 & M
>      50 of T2 --->  50 of T2 & M
>     100 of T1 ---> 100 of T1 & M
> 
>     200 of M  +-->  11 of M
>               +--> 140 of T1
>               +-->  49 of T2
> 
> (M extracted 1 unit from each incoming coin as fee; they also live in a fictional universe where miners mine transactions out of the goodness of their hearts.)
> Now in fact the previous transactions are, after the SAS, solely owned by M the maker.
> Now suppose on the next round, we have 3 new takers, T3, T4, and T5, who offer some coins to M to CoinSwap, leading to more blockchain data:
> 
>      42 of T1 --->  42 of T1 & M
>      50 of T2 --->  50 of T2 & M
>     100 of T1 ---> 100 of T1 & M
> 
>     200 of M  -+->  11 of M
>                +-> 140 of T1
>                +->  49 of T2
> 
>      22 of T3 --->  22 of T3 & M
>      90 of T3 --->  90 of T3 & M
>      11 of T4 --->  11 of T4 & M
>      50 of T4 --->  50 of T4 & M
>      20 of T5 --->  20 of T5 & M
> 
> In order to service all the new takers of this round, M takes the coins that it got from T1 and T2, and uses them to fund a new combined CoinSwap tx:
> 
>      42 of T1 --->  42 of T1 & M -+--+-> 110 of T3
>      50 of T2 --->  50 of T2 & M -+  +->  59 of T4
>     100 of T1 ---> 100 of T1 & M -+  +->  14 of T5
>                                      +->   9 of M
>     200 of M  -+->  11 of M
>                +-> 140 of T1
>                +->  49 of T2
> 
>      22 of T3 --->  22 of T3 & M
>      90 of T3 --->  90 of T3 & M
>      11 of T4 --->  11 of T4 & M
>      50 of T4 --->  50 of T4 & M
>      15 of T5 --->  15 of T5 & M
> 
> That transaction, we can observe, looks very much like a batched transaction that a custodial service might produce.
> 
> Now imagine more rounds, and I think you can begin to imagine that the magic of transaction batching, ported into SwapMarket, would help mitigate the blockchain size issues that CoinSwap has.
> 
> Makers are expected to adopt this technique as this reduces the overall cost of transactions they produce, thus they are incentivized to use this technique to increase their profitability.
> 
> At the same time, it spreads taint around and increases the effort that chain analysis must go through to identify what really happened.
> 
> Regards,
> ZmnSCPxj
> 

Would it be fair to summarize the idea in this way:

CoinSwappers can slow down the CoinSwap process which will give an
opportunity for makers to use batching.


From ZmnSCPxj at protonmail.com  Sat Jun 13 14:06:05 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 13 Jun 2020 14:06:05 +0000
Subject: [bitcoin-dev] Hiding CoinSwap Makers Among Custodial Services
In-Reply-To: <9a2e9ba4-1dda-e5bb-2587-bfe589d24c70@riseup.net>
References: <fQt0iIzsA5QprW64lX4SR1R78Aj6e-WqIgSMvk75mdiagQmAchIUqCpXzDjD4jPBhorg0i-oGlrYz7ot2xWMgJiha-eGFzl3PxbtZ-mbjSc=@protonmail.com>
 <9a2e9ba4-1dda-e5bb-2587-bfe589d24c70@riseup.net>
Message-ID: <_I7GJG-KA7UpwUenI2qekxB8Ocut7i3oCAdBilv7VeycuUuflLEmJRakMCI9qCJkg3vfNW_0TZGRQOSO8EOL_mhq4Rvyb7q8LtML1-sxTdI=@protonmail.com>

Good morning Chris,

>
> Would it be fair to summarize the idea in this way:
>
> CoinSwappers can slow down the CoinSwap process which will give an
> opportunity for makers to use batching.

I think so.

Regards,
ZmnSCPxj

From belcher at riseup.net  Sat Jun 13 23:25:00 2020
From: belcher at riseup.net (Chris Belcher)
Date: Sun, 14 Jun 2020 00:25:00 +0100
Subject: [bitcoin-dev] Hiding CoinSwap Makers Among Custodial Services
In-Reply-To: <_I7GJG-KA7UpwUenI2qekxB8Ocut7i3oCAdBilv7VeycuUuflLEmJRakMCI9qCJkg3vfNW_0TZGRQOSO8EOL_mhq4Rvyb7q8LtML1-sxTdI=@protonmail.com>
References: <fQt0iIzsA5QprW64lX4SR1R78Aj6e-WqIgSMvk75mdiagQmAchIUqCpXzDjD4jPBhorg0i-oGlrYz7ot2xWMgJiha-eGFzl3PxbtZ-mbjSc=@protonmail.com>
 <9a2e9ba4-1dda-e5bb-2587-bfe589d24c70@riseup.net>
 <_I7GJG-KA7UpwUenI2qekxB8Ocut7i3oCAdBilv7VeycuUuflLEmJRakMCI9qCJkg3vfNW_0TZGRQOSO8EOL_mhq4Rvyb7q8LtML1-sxTdI=@protonmail.com>
Message-ID: <c55d8195-fe1b-0b60-fee9-d3c69fec239c@riseup.net>

On 13/06/2020 15:06, ZmnSCPxj wrote:
> Good morning Chris,
> 
>>
>> Would it be fair to summarize the idea in this way:
>>
>> CoinSwappers can slow down the CoinSwap process which will give an
>> opportunity for makers to use batching.
> 
> I think so.
> 
> Regards,
> ZmnSCPxj
> 

It's definitely a good idea. As well as improving privacy by pretending
to be a service provider which uses batching, it may also be practical
just because CoinSwap takers will want to slow down the process for
greater privacy so that an adversary would have to search more of the
blockchain to attempt to deanonymize them. Also, by being prepared to
wait longer the takers will also save miner fees.

From tom at commerceblock.com  Sun Jun 14 22:24:47 2020
From: tom at commerceblock.com (Tom Trevethan)
Date: Sun, 14 Jun 2020 23:24:47 +0100
Subject: [bitcoin-dev] Blind Statechains
In-Reply-To: <CAPv7TjZ_MBCmWZ5CnUk0G0MhHL65cpGyt_dMDONDTzJBHpVUQg@mail.gmail.com>
References: <CAJvkSsewzYTAsm0tneu6-9MT0a-CcYvJBcSmhzCUkmAJ95=T3A@mail.gmail.com>
 <CAPv7TjZ_MBCmWZ5CnUk0G0MhHL65cpGyt_dMDONDTzJBHpVUQg@mail.gmail.com>
Message-ID: <CAJvkSsdpf1QJkFETeLQXfTM8AutgthiwG2m=THJnHS+d5JcH+Q@mail.gmail.com>

Hi Ruben,

Thanks for the comments.

> Users would have to validate the history of the chain regardless, even if
it wasn't blind, to verify whether the statechain entity hasn't been
cheating, so the main difference would be in unblinding the data.

My understanding was that users would need to verify the uniqueness of the
ownership of the previous owner, and verify that the ownership had been
signed over (which acts as proof of ownership in case the SE steals) but
that backup transaction rules would be enforced by the SE (the SE must be
trusted to not collude with a previous owner to sign a 'theft' transaction
before the UTXO is sold on). Even if a new owner verifying that all of the
previous backup transactions are correct does not prove that the SE has not
signed anything else we don't know about.

In the case of a blinded SE, we were thinking the way it could work is that
the SE would still need to be trusted to state how many times it had
co-signed. So a new owner would ask the SE how many times it has signed
something (e.g. 27) and then the new owner would need to check that there
are exactly 27 back up transactions and verify that each one was following
the rules. Then when it came to transfer, they would send the 27 + their
own backup to the new owner, who would then ask the SE again how many it
had signed.

Yes, the SE can store all of these transactions, encrypted with the current
owners key, to make the UX easier.

> I'm not sure whether this can also apply to 2P-ECDSA, but with Schnorr
the statechain entity wouldn't even learn the address for the funding
transaction, so it wouldn't be able to tell which UTXO it controls by
watching the blockchain. Ideally, this functionality would be preserved to
ensure the statechain entity can't be aware of the funds it's holding.

Yes, that is the aim. Like you mentioned, this may help a lot with legal
status of the SE, but also prevent the SE from being able to link swaps
(while still performing them atomically).

> Another thing to note is that you won't know when a statechain has been
pegged out, so pruning will be impossible. You may wish to consider some
kind of liveness rule where one statechain transaction needs to be made per
year. If they miss the deadline, they're just forced on-chain, which is not
terrible, in any case.

Interesting point. I guess it is not in the interest of the owner to tell
the SE that they have pegged-out a UTXO (as the SE might be able to
correlate with on-chain txs). Maybe the user wallet can send the SE
a message that the UTXO is pegged out some random interval after it has
happened.

Cheers,

Tom

On Fri, Jun 12, 2020 at 9:35 PM Ruben Somsen <rsomsen at gmail.com> wrote:

> Hi Tom,
>
> Blind signatures are certainly a nice feature, great to see that you're
> considering it.
>
> >So each new owner of a UTXO must receive, store and verify the full
> sequence of previous owner backup transactions to make sure that no
> previous owner has asked the SE to sign a transaction that could be used to
> steal the UTXO. This may end up making wallets more bloated and clunky,
> given that ownership of a UTXO could change hands thousands of times
> off-chain.
>
> Users would have to validate the history of the chain regardless, even if
> it wasn't blind, to verify whether the statechain entity hasn't been
> cheating, so the main difference would be in unblinding the data.
>
> One of my original ideas was to use the transitory key to derive the
> secrets that blind the signatures (basically like an HD wallet). The
> statechain entity would then store and serve blind signatures, and any new
> owner would download and unblind/verify them using the transitory key (no
> extensive peer-to-peer transfer needed). It's possible to make the
> off-chain transactions themselves deterministic, so they can just be
> generated by the client without any additional data transfer. The only
> potentially unique thing in a transaction is the refund address, but this
> can be the same key as the ownership key on the statechain, tweaked with
> the transitory key via Diffie-Hellman (to ensure it's not linkable if it
> goes on-chain).
>
> The general downside of this method is that all transactions are exposed
> to anyone who learns the transitory key -- not just for the current
> transactions (which can always be leaked no matter what you do), but also
> all future transactions in that particular statechain. However, I should
> note there doesn't actually seem to be much to learn, because the history
> of each statechain is actually quite uninformative. The money just goes
> from one pseudonymous owner to the next.
>
> Of course you now have scheme that changes the transitory key with each
> step, so I instead suggest you introduce a secondary "blinding key" to
> achieve what I described.
>
> I'm not sure whether this can also apply to 2P-ECDSA, but with Schnorr the
> statechain entity wouldn't even learn the address for the funding
> transaction, so it wouldn't be able to tell which UTXO it controls by
> watching the blockchain. Ideally, this functionality would be preserved to
> ensure the statechain entity can't be aware of the funds it's holding.
>
> Another thing to note is that you won't know when a statechain has been
> pegged out, so pruning will be impossible. You may wish to consider some
> kind of liveness rule where one statechain transaction needs to be made per
> year. If they miss the deadline, they're just forced on-chain, which is not
> terrible, in any case.
>
> Hope this helps!
>
> Cheers,
> Ruben
>
>
>
> On Fri, Jun 12, 2020 at 9:23 PM Tom Trevethan via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Hello,
>>
>> A statechain implementation and service co-signs 'backup' (off-chain)
>> transactions to transfer ownership of a UTXO from one owner to the next. A
>> suggested here
>> https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39
>> , this service (the statechain entity or SE) can be engineered to be
>> 'blind' to the transactions it is signing (i.e. it does not and cannot know
>> the details of the transactions it is signing) which can give significant
>> privacy benefits. It would enable more private off-chain coin-swaps, and
>> make collusion more difficult.
>>
>> The only downside of a blind SE is that it can no longer enforce the
>> rules governing the sequence of backup transactions it co-signs as owners
>> can ask the SE to cosign any transaction. So each new owner of a UTXO must
>> receive, store and verify the full sequence of previous owner backup
>> transactions to make sure that no previous owner has asked the SE to sign a
>> transaction that could be used to steal the UTXO. This may end up making
>> wallets more bloated and clunky, given that ownership of a UTXO could
>> change hands thousands of times off-chain.
>>
>> In the case of a multisig, and Schnorr signatures, existing blind Schnorr
>> protocols could be used to implement a blind SE, however we are opting to
>> use two-party ECDSA (because there is no Schnorr yet, and in any case ECDSA
>> will give a much bigger anonymity set). There is no current 2P ECDSA
>> protocol that enables one of the two signers to be completely blinded, but
>> it seems that this would require only minor modifications to an existing 2P
>> ECDSA scheme (outlined here
>> https://github.com/commerceblock/mercury/blob/master/doc/blind_2p_ecdsa.md
>> based on Lindell 2017 https://eprint.iacr.org/2017/552 ).
>>
>> Any comments on any of this gratefully received.
>>
>> Tom
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200614/b23d055a/attachment.html>

From ZmnSCPxj at protonmail.com  Tue Jun 16 05:23:01 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 16 Jun 2020 05:23:01 +0000
Subject: [bitcoin-dev] CoinPool,
	exploring generic payment pools for Fun and Privacy
In-Reply-To: <7BPgx65Eh5HE5wLIqeG9G-bdsxxkDJJIzcyOJvS6_FIxXfA10sbFe5dfwQDNiEOExZ9Y72lHq88lKzcBRIFnYGFY5I2vwk6Dg7BcCMjmS2Y=@protonmail.com>
References: <CALZpt+FqAWCAqCLF2HsajL84sOvst_X9_34bb_tvUxLFw=HTAA@mail.gmail.com>
 <7cWQJzkWNEZCI2fYYrJCFxrmGfDGFAtsOyGpXRmB-g4Qhm2jzhyxLtuOIpJAr2CMJjAjri12lmR-h96ev3NWqaTgDtc_NN0yhyVxuIlBuzU=@protonmail.com>
 <CALZpt+EsACbq1QM9MFkC63_gDXW0vHfeTjXc7C9r4+2-1WKAJw@mail.gmail.com>
 <m-yAKsQ52s-bYOrtEXVwETAcJ8sSbJt0k9WDN1ueidJ01IaEHRJtq9Odffmz_2utLxPfmI418x58aFc3vKBpOD2FKqgeCUAn1mvI1OSyGRY=@protonmail.com>
 <7BPgx65Eh5HE5wLIqeG9G-bdsxxkDJJIzcyOJvS6_FIxXfA10sbFe5dfwQDNiEOExZ9Y72lHq88lKzcBRIFnYGFY5I2vwk6Dg7BcCMjmS2Y=@protonmail.com>
Message-ID: <_VqB84inr1oM8O9n4r1BZ_t7BPRFaJQ3ifZqnsLwFKNlQAKtPdwUFK825Wja0PTyllzLERlmiWWMLSiamYR83d7MXH3ERCON-u-IkH5R5XA=@protonmail.com>

Good morning Antoine, Gleb, and list,

In some ways, CoinPool is really part of a swarm of ideas:

* CoinPool
* Multiparticipant (N > 2) channels
* Channel factories
* Nodelets

What CoinPool and multiparticipant channels buy us is better flexibility with forwarding.
For example, if we compare a multiparty channel to a channel factory, suppose there exists three entities A, B, and C in the multiparty construction.

In a channel factory, each entity has to decide how much of its liquidity to tie up in a channel with a specific other peer in the multiparty construction.
This limits the practical payment forwarding when integrated into the Lightning Network.

In a CoinPool, any of the entities can forward to any of the other entities, without tying their liquidity to a channel specifically with those entities.

However, in a CoinPool, once any of the entities goes offline, the entire CoinPool can no longer update.
This is in contrast with channel factories, where, if entity C goes offline, the channel between A and B remains useable for forwarding.
In other words, channel factories degrade gracefully.

Further, we already have a decent solution for liquidity redistribution: JIT Routing by Rene Pickhardt.
Thus the liquidity issue with channel factories are somewhat mitigated (and if all participants are online, they also have the option of redistributing channel funds *inside* the factory as well, not just JIT routing), while gaining graceful degradation of the factory.


Another is that pathfinding algorithms work best if graph edges are edges and not in fact some kind of twisted multi-edge that connects more than two nodes together.

On the other hand, the participants of a CoinPool could create a "virtual node" that is a MuSig of their individual keys, and report that as the "real" node on LN gossip (each of them pretending to have a large channel with that virtual node), so that the rest of the network only sees edges that link two nodes (and existing pathfinding algos still work seamlessly, never realizing that this node is actually a virtual node that represents a CoinPool).
This is basically them creating a sort of Nodelet node, which other nodes cannot make channels to, and which uses channels with the Nodelet node as proxies for the CoinPool as a whole.


Regards,
ZmnSCPxj

From luke at dashjr.org  Wed Jun 17 02:18:56 2020
From: luke at dashjr.org (Luke Dashjr)
Date: Wed, 17 Jun 2020 02:18:56 +0000
Subject: [bitcoin-dev] Bitcoin Knots 0.20.0.knots20200614 released
Message-ID: <202006170219.01660.luke@dashjr.org>

Bitcoin Knots version 0.20.0.knots20200614 is now available from:

  https://bitcoinknots.org/files/0.20.x/0.20.0.knots20200614/

This release includes new features, various bug fixes and performance
improvements, as well as updated translations.

Please report bugs using the issue tracker at GitHub:

  https://github.com/bitcoinknots/bitcoin/issues

To receive security and update notifications, please subscribe to:

  https://bitcoinknots.org/list/announcements/join/

For the full release notes and change log, see:

https://github.com/bitcoinknots/bitcoin/blob/v0.20.0.knots20200614/doc/release-notes.md
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 1528 bytes
Desc: This is a digitally signed message part.
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200617/26758bcd/attachment.sig>

From bastien at acinq.fr  Fri Jun 19 07:44:11 2020
From: bastien at acinq.fr (Bastien TEINTURIER)
Date: Fri, 19 Jun 2020 09:44:11 +0200
Subject: [bitcoin-dev] [Lightning-dev] RBF Pinning with Counterparties
 and Competing Interest
In-Reply-To: <4c4f3a06-0078-ef6a-7b06-7484f0f9edf1@mattcorallo.com>
References: <PtYNeePySy_thDHm8FwIIGEk32EjJpSmiwPctyEg0hOrLZEHjO1IBghm4MWY88g51K-XF2pf_JDnW0UdTL6QSbACEj21h9U1s5ITc_N3I6Q=@protonmail.com>
 <67334082-5ABA-45C7-9C09-FF19B119C80D@mattcorallo.com>
 <62P_3wvv8z7AVCdKPfh-bs30-LliHkx9GI9Og3wqIK6hadIG0d6MJJm077zac1erpPUy31FqgZjkAjEl9AQtrOCg4XA5cxozBb7-OIbbgvE=@protonmail.com>
 <4c4f3a06-0078-ef6a-7b06-7484f0f9edf1@mattcorallo.com>
Message-ID: <CACdvm3Of_9zhNmzCxeK-z8oz6wU=8RuDjr0R9+yrGeFjLYz9pg@mail.gmail.com>

Good morning list,

Sorry for being (very) late to the party on that subject, but better late
than never.

A lot of ideas have been thrown at the problem and are scattered across
emails, IRC discussions,
and github issues. I've spent some time putting it all together in one
gist, hoping that it will
help stir the discussion forward as well as give newcomers all the
background they need to ramp up
on this issue and join the discussion, bringing new ideas to the table.

The gist is here, and I'd appreciate your feedback if I have wrongly
interpreted some of the ideas:
https://gist.github.com/t-bast/22320336e0816ca5578fdca4ad824d12

Readers of this list can probably directly skip to the "Future work"
section. I believe my
"alternative proposal" should loosely reflect Matt's proposal from the very
first mail of this
thread; note that I included anchors and new txs only in some places, as I
think they aren't
necessary everywhere.

My current state-of-mind (subject to change as I discover more potential
attacks) is that:

* The proposal to add more anchors and pre-signed txs adds non-negligible
complexity and hurts
small HTLCs, so it would be better if we didn't need it
* The blind CPFP carve-out trick is a one shot, so you'll likely need to
pay a lot of fees for it
to work which still makes you lose money in case an attacker targets you
(but the money goes to
miners, not to the attacker - unless he is the miner). It's potentially
hard to estimate what fee
you should put into that blind CPFP carve-out because you have no idea what
the current fee of the
pinned success transaction package is, so it's unsure if that solution will
really work in practice
* If we take a step back, the only attack we need to protect against is an
attacker pinning a
preimage transaction while preventing us from learning that preimage for at
least `N` blocks
(see the gist for the complete explanation). Please correct me if that
claim is incorrect as it
will invalidate my conclusion! Thus if we have:
* a high enough `cltv_expiry_delta`
* [off-chain preimage broadcast](
https://github.com/lightningnetwork/lightning-rfc/issues/783)
(or David's proposal to do it by sending txs that can be redeemed via only
the preimage)
* LN hubs (or any party commercially investing in running a lightning node)
participating in
various mining pools to help discover preimages
* decent mitigations for eclipse attacks
* then the official anchor outputs proposal should be safe enough and is
much simpler?

Thank you for reading, I hope the work I put into this gist will be useful
for some of you.

Bastien

Le ven. 24 avr. 2020 ? 00:47, Matt Corallo via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> a ?crit :

>
>
> On 4/23/20 8:46 AM, ZmnSCPxj wrote:
> >>> -   Miners, being economically rational, accept this proposal and
> include this in a block.
> >>>
> >>> The proposal by Matt is then:
> >>>
> >>> -   The hashlock branch should instead be:
> >>> -   B and C must agree, and show the preimage of some hash H (hashlock
> branch).
> >>> -   Then B and C agree that B provides a signature spending the
> hashlock branch, to a transaction with the outputs:
> >>> -   Normal payment to C.
> >>> -   Hook output to B, which B can use to CPFP this transaction.
> >>> -   Hook output to C, which C can use to CPFP this transaction.
> >>> -   B can still (somehow) not maintain a mempool, by:
> >>> -   B broadcasts its timelock transaction.
> >>> -   B tries to CPFP the above hashlock transaction.
> >>> -   If CPFP succeeds, it means the above hashlock transaction exists
> and B queries the peer for this transaction, extracting the preimage and
> claiming the A->B HTLC.
> >>
> >> Note that no query is required. The problem has been solved and the
> preimage-containing transaction should now confirm just fine.
> >
> > Ah, right, so it gets confirmed and the `blocksonly` B sees it in a
> block.
> >
> > Even if C hooks a tree of low-fee transactions on its hook output or
> normal payment, miners will still be willing to confirm this and the B hook
> CPFP transaction without, right?
>
> Correct, once it makes it into the mempool we can CPFP it and all the
> regular sub-package CPFP calculation will pick it
> and its descendants up. Of course this relies on it not spending any other
> unconfirmed inputs.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200619/70e88f70/attachment.html>

From jonasdnick at gmail.com  Fri Jun 19 15:33:09 2020
From: jonasdnick at gmail.com (Jonas Nick)
Date: Fri, 19 Jun 2020 15:33:09 +0000
Subject: [bitcoin-dev] Design for a CoinSwap implementation for
 massively improving Bitcoin privacy and fungibility
In-Reply-To: <82d90d57-ad07-fc7d-4aca-2b227ac2068d@riseup.net>
References: <82d90d57-ad07-fc7d-4aca-2b227ac2068d@riseup.net>
Message-ID: <5cdc9a4a-6382-6b1f-fb34-58fa3f5eece0@gmail.com>

> [...] we can use 2-party ECDSA to create 2-of-2 multisignature addresses that
> look the same as regular single-signature addresses[2]. Even the old-style
> p2pkh addresses starting with 1 can be CoinSwap addresses.

Probably worth considering that p2pkh, p2wpkh and p2sh are vulnerable to the
(well-known) birthday attack with 2^80 operations on average if they encode a
multisig policy [0]. This is a large number but not the security margin we are
used to.

It is possible to reduce the feasibility of the attack by requiring 2^80
interactions instead of purely offline operations. This works by adding a
commitment round for all public keys involved in the policy. Now in order to
test whether a public key results in a collision, the attacker must first engage
in a commitment protocol with that public key. The "Fast Secure Two-Party ECDSA
Signing" protocol by Lindell [1] already has such a commitment round (for
reasons unrelated to Bitcoin). For example, the Gotham City two-party ECDSA
wallet [2] has this security model because it builds on the Lindell scheme and
uses p2sh-p2wpkh.

[0] https://bitcoin.stackexchange.com/questions/54841/birthday-attack-on-p2sh
[1] https://eprint.iacr.org/2017/552.pdf
[2] https://github.com/KZen-networks/gotham-city


On 5/25/20 1:21 PM, Chris Belcher via bitcoin-dev wrote:
> === Abstract ===
> 
> Imagine a future where a user Alice has bitcoins and wants to send them
> with maximal privacy, so she creates a special kind of transaction. For
> anyone looking at the blockchain her transaction appears completely
> normal with her coins seemingly going from address A to address B. But
> in reality her coins end up in address Z which is entirely unconnected
> to either A or B.
> 
> Now imagine another user, Carol, who isn't too bothered by privacy and
> sends her bitcoin using a regular wallet which exists today. But because
> Carol's transaction looks exactly the same as Alice's, anybody analyzing
> the blockchain must now deal with the possibility that Carol's
> transaction actually sent her coins to a totally unconnected address. So
> Carol's privacy is improved even though she didn't change her behaviour,
> and perhaps had never even heard of this software.
> 
> In a world where advertisers, social media and other companies want to
> collect all of Alice's and Carol's data, such privacy improvement would
> be incredibly valuable. And also the doubt added to every transaction
> would greatly boost the fungibility of bitcoin and so make it a better
> form of money.
> 
> This undetectable privacy can be developed today by implementing
> CoinSwap, although by itself that isn't enough. There must be many
> building blocks which together make a good system. The software could be
> standalone as a kind of bitcoin mixing app, but it could also be a
> library that existing wallets can implement allowing their users to send
> Bitcoin transactions with much greater privacy.
> 
> == CoinSwap ==
> 
> Like CoinJoin, CoinSwap was invented in 2013 by Greg Maxwell[1]. Unlike
> CoinJoin it is relatively complicated to implement and so far has not
> been deployed. But the idea holds great promise, and fixes many of the
> problems of some kinds of CoinJoins. CoinSwap is the next step for
> on-chain bitcoin privacy.
> 
> CoinSwap is a way of trading one coin for another coin in a
> non-custodial way. It is closely related to the idea of an atomic swap.
> Alice and Bob can trade coins with each other by first sending to a
> CoinSwap address and having those coins then sent to Bob:
> 
>     Alice's Address 1 ----> CoinSwap Address 1 ----> Bob's Address 1
> 
> An entirely separate set of transactions gives Bob's coins to Alice in
> return:
> 
>     Bob's Address 2 ----> CoinSwap Address 2 ----> Alice's Address 2
> 
> Where the symbol ----> is a bitcoin transaction.
> 
> Privacy is improved because an observer of the blockchain cannot link
> Alice's Address 1 to Alice's Address 2, as there is no transaction
> between them. Alice's Address 2 could either be an address in Alice's
> wallet, or the address of someone else she wants to transfer money to.
> CoinSwap therefore breaks the transaction graph heuristic, which is the
> assumption that if a transaction A -> B is seen then the ownership of
> funds actually went from A to B.
> 
> CoinSwap doesnt break any of bitcoin's assumptions or features like an
> auditable supply or pruning. It can be built on today's bitcoin without
> any new soft forks.
> 
> CoinSwap can't improve privacy much on its own, so it requires other
> building block to create a truly private system.
> 
> === ECDSA-2P ===
> 
> The original CoinSwap idea uses 2-of-2 multisig. We can get a slightly
> bigger anonymity set by using 2-of-3 multisigs with a fake third public
> key. For a much greater anonymity set we can use 2-party ECDSA to create
> 2-of-2 multisignature addresses that look the same as regular
> single-signature addresses[2]. Even the old-style p2pkh addresses
> starting with 1 can be CoinSwap addresses.
> 
> Because the transactions blend in with the rest of bitcoin, an
> application based on CoinSwap would provide much more privacy than the
> existing equal-output coinjoin apps (JoinMarket, Wasabi Wallet and
> Samourai Wallet's Whirlpool). CoinSwaps would also be cheaper for the
> same amount of privacy, as CoinJoin users usually create multiple
> CoinJoins to get effective privacy, for example JoinMarket's tumbler
> script does between 7-12 coinjoins (which are bigger than regular
> transactions too) when run with default parameters.
> 
> Schnorr signatures with Musig provide a much easier way to create
> invisible 2-of-2 multisig, but it is not as suitable for CoinSwap. This
> is because the anonymity set for ECDSA would be much greater. All
> addresses today are ECDSA, and none are schnorr. We'd have to wait for
> schnorr to be added to bitcoin and then wait for users to adopt it. We
> see with segwit that even after nearly 3 years that segwit adoption is
> only about 60%, and segwit actually has a sizeable financial incentive
> for adoption via lower fees. Schnorr when used for single-sig doesn't
> have such an incentive, as Schnorr single-sig costs the same size as
> today's p2wpkh, so we can expect adoption to be even slower. (Of course
> there is an incentive for multisig transactions, but most transactions
> are single-sig). As schnorr adoption increases this CoinSwap system
> could start to use it, but for a long time I suspect it will mostly be
> using ECDSA for a greater anonymity set.
> 
> === Liquidity market ===
> 
> We can create a liquidity market for CoinSwap very similar to how
> JoinMarket works for CoinJoins. In our example above Alice would be a
> market taker and Bob would be a market maker. The taker Alice pays a fee
> to the maker Bob in return for choosing the amount of a CoinSwap and
> when it happens. This allows an excellent user experience because Alice
> can create CoinSwaps for any size she wants, at any time she wants.
> Right now in JoinMarket there is liquidity to create CoinJoins of sizes
> up to about 200 BTC, and we can expect a similar kind of thing with
> CoinSwap.
> 
> 
> === Multi-transaction CoinSwaps to avoid amount correlation ===
> 
> This CoinSwap is vulnerable to amount correlation:
> 
>     AliceA (15 BTC) ----> CoinSwap AddressA ----> BobA (15 BTC)
>     BobB (15 BTC) ----> CoinSwap AddressB ----> AliceB (15 BTC)
> 
> Where AliceA, AliceB are addresses belonging to Alice. BobA, BobB are
> addresses belonging to Bob. If an adversary starts tracking at address
> AliceA they could unmix this CoinSwap easily by searching the entire
> blockchain for other transactions with amounts close to 15 BTC, which
> would lead them to address AliceB. We can beat this amount correlation
> attack by creating multi-transaction CoinSwaps. For example:
> 
>     AliceA (15 BTC) ----> CoinSwap AddressA ----> BobA (15 BTC)
> 
>     BobB (7 BTC) ----> CoinSwap AddressB ----> AliceB (7 BTC)
>     BobC (5 BTC) ----> CoinSwap AddressC ----> AliceC (5 BTC)
>     BobD (3 BTC) ----> CoinSwap AddressD ----> AliceD (3 BTC)
> 
> Now in the multi-transaction CoinSwap, the market taker Alice has given
> 10 BTC and got back three transactions which add up to the same amount,
> but nowhere on the blockchain is there an output where Alice received
> exactly 15 BTC.
> 
> === Routing CoinSwaps to avoid a single points of trust ===
> 
> In the original CoinSwap idea there are only two parties Alice and Bob,
> so when they CoinSwap Bob will know exactly where the Alice's coins
> went. This means Bob is a single point of failure in Alice's privacy,
> and Alice must trust him not to spy on her.
> 
> To spread out and decentralize the trust, we can create CoinSwaps where
> Alice's payment is routed through many Bobs.
> 
>     AliceA ====> Bob ====> Charlie ====> Dennis ====> AliceB
> 
> Where the symbol ====> means one CoinSwap. In this situation Alice will
> be a market taker in the liquidity market, and all the other entities
> (Bob, Charlie, Dennis) will be market makers. Only Alice will know the
> entire route, and the makers will only know the previous and next
> bitcoin addresses along the route.
> 
> This could be made to work by Alice handling almost everything about the
> CoinSwap on the other maker's behalf. The makers wouldn't have TCP
> connections between each other, but only to Alice, and she would relay
> CoinSwap-relevant information between them. The other makers are not
> aware whether their incoming coins came from Alice herself or the
> previous maker in Alice's route.
> 
> 
> === Combining multi-transaction with routing ===
> 
> Routing and multi-transaction must be combined to get both benefits. If
> Alice owns multiple UTXOs (of value 6 BTC, 8 BTC and 1 BTC) then this is
> easy with this configuration:
> 
>              Alice
>     (6 BTC) (8 BTC) (1 BTC)
>        |       |       |
>        |       |       |
>        v       v       v
>               Bob
>     (5 BTC) (5 BTC) (5 BTC)
>        |       |       |
>        |       |       |
>        v       v       v
>             Charlie
>     (9 BTC) (5 BTC) (1 BTC)
>        |       |       |
>        |       |       |
>        v       v       v
>             Dennis
>     (7 BTC) (4 BTC) (4 BTC)
>        |       |       |
>        |       |       |
>        v       v       v
>              Alice
> 
> Where the downward arrow symbol is a single CoinSwap hash-time-locked
> contract. Each hop uses multiple transactions so no maker (Bob, Charlie,
> Dennis) is able to use amount correlation to find addresses not directly
> related to them, but at each hop the total value adds up to the same
> amount 15 BTC. And all 3 makers must collude in order to track the
> source and destination of the bitcoins.
> 
> If Alice starts with only a single UTXO then the above configuration is
> still vulnerable to amount correlation. One of the later makers (e.g.
> Dennis) knows that the total coinswap amount is 15 BTC, and could search
> the blockchain to find Alice's single UTXO. In such a situation Alice
> must use a branching configuration:
> 
>                           Alice
>                          (15 BTC)
>                             |
>                             |
>                             v
>                            Bob
>                           /   \
>                          /     \
>              <-----------       ----------->
>              |                             |
>   (2 BTC) (2 BTC) (2 BTC)        (3 BTC) (3 BTC) (3 BTC)
>              |                             |
>              |                             |
>              v                             v
>           Charlie                       Dennis
>   (1 BTC) (2 BTC) (3 BTC)       (5 BTC) (3 BTC) (1 BTC)
>      |       |       |             |       |       |
>      |       |       |             |       |       |
>      v       v       v             v       v       v
>           Edward                          Fred
>   (4 BTC) (1 BTC) (1 BTC)       (4 BTC) (2 BTC) (1 BTC)
>      |       |       |             |       |       |
>      |       |       |             |       |       |
>      v       v       v             v       v       v
>            Alice                         Alice
> 
> In this diagram, Alice sends 15 BTC to Bob via CoinSwap who sends 6 BTC
> on to Charlie and the remaining 9 BTC to Dennis. Charlie and Dennis do a
> CoinSwap with Edward and Fred who forward the coins to Alice. None of
> the makers except Bob know the full 15 BTC amount and so can't search
> the blockchain backwards for Alice's initial UTXO. Because of multiple
> transactions Bob cannot look forward to search for the amounts he sent 6
> BTC and 9 BTC. A minimum of 3 makers in this example need to collude to
> know the source and destination of the coins.
> 
> Another configuration is branch merging, which Alice would find useful
> if she has two or more UTXOs for which there must not be evidence that
> they're owned by the same entity, and so they must not be spent together
> in the same transaction.
> 
>            Alice                         Alice
>           (9 BTC)                       (6 BTC)
>              |                             |
>              |                             |
>              v                             v
>             Bob                         Charlie
>   (4 BTC) (3 BTC) (2 BTC)       (1 BTC) (2 BTC) (3 BTC)
>      |       |       |             |       |       |
>      |       |       |             |       |       |
>       \       \       \           /       /       /
>        \       \       \         /       /       /
>         \       \       \       /       /       /
>          >------->-------\     /-------<-------<
>                           \   /
>                           Alice
>                          (15 BTC)
> 
> In this diagram Alice sends the two UTXOs (9 BTC and 6 BTC) to two
> different makers, who forward it onto Alice. Because the two UTXOs have
> been transferred to different makers they will likely never be co-spent.
> 
> These complex multi-transaction routed coinswaps are only for the
> highest threat models where the makers themselves are adversaries. In
> practice most users would probably choose to use just one or two hops.
> 
> 
> === Breaking change output and wallet fingerprinting heuristics ===
> 
> Equal-output CoinJoins easily leak change addresses (unless they are
> sweeps with no change). CoinSwap doesn't have this flaw which allows us
> to break some of the weaker change output heuristics[3].
> 
> For example address reuse. If an output address has been reused it is
> very likely to be a payment output, not a change output. In a CoinSwap
> application we can break this heuristic by having makers randomly with
> some probability send their change to an address they've used before.
> That will make the heuristics think that the real change address is
> actually the payment address, and the real payment is actually the
> change, and could result in an analyzer of the blockchain grouping the
> payment address inside the maker's own wallet cluster.
> 
> Another great heuristic to break is the script type heuristic. If the
> maker's input are all in p2sh-p2wpkh addresses, and their payment
> address is also of type p2sh-p2wpkh, then the maker could with some
> probability set the change address to a different type such as p2wpkh.
> This could trick a chain analyzer in a similar way.
> 
> === Fidelity bonds ===
> 
> Anybody can enter the CoinSwap market as a maker, so there is a danger
> of sybil attacks. This is when an adversary deploys huge numbers of
> maker bots. If the taker Alice chooses maker bots which are all
> controlled by the same person then that person can deanonymize Alice's
> transaction by tracking the coins along the route.
> 
> A solution to this is fidelity bonds. This is a mechanism where bitcoin
> value is deliberately sacrificed to make a cryptographic identity
> expensive to obtain. The sacrifice is done in a way that can be proven
> to a third party. One way to create a fidelity bond is to lock up
> bitcoins in a time-locked address. We can code the taker bots to behave
> in a way that creates market pressure for maker bot operators to publish
> fidelity bonds. These fidelity bonds can be created anonymously by
> anyone who owns bitcoin.
> 
> Fidelity bonds are a genuine sacrifice which can't be faked, they can be
> compared to proof-of-work which backs bitcoin mining. Then for a sybil
> attacker to be successful they would have to lock up a huge value in
> bitcoin for a long time. I've previously analyzed fidelity bonds for
> JoinMarket[4], and using realistic numbers I calculate that such a
> system would require about 55000 BTC (around 500 million USD at today's
> price) to be locked up for 6 months in time-locked addresses. This is a
> huge amount and provides strong sybil resistance.
> 
> ==== Who goes first ====
> 
> Fidelity bonds also solve the "who goes first" problem in CoinSwap.
> 
> This problem happens because either Alice or Bob must broadcast their
> funding transaction first, but if the other side halts the protocol then
> they can cause Alice or Bob's to waste time and miner fees as they're
> forced to use the contract transactions to get their money back. This is
> a DOS attack. If a malicious CoinSwapper could keep halting the protocol
> they could stop an honest user from doing a CoinSwap indefinitely.
> Fidelity bonds solve this by having the fidelity bond holder go second.
> If the fidelity bond holder halts the protocol then their fidelity bond
> can be avoid by the user in all later CoinSwaps. And the malicious
> CoinSwapper could pack the orderbook with their sybils without
> sacrificing a lot of value for fidelity bonds.
> 
> As a concrete example, Alice is a taker and Bob is a maker. Bob
> publishes a fidelity bond. Alice "goes first" by sending her coins into
> a 2-of-2 multisig between her and Bob. When Bob sees the transaction is
> confirmed he broadcasts his own transactions into another 2-of-2
> multisig. If Bob is actually malicious and halts the protocol then he
> will cost Alice some time and money, but Alice will refuse to ever
> CoinSwap with Bob's fidelity bond again.
> 
> If DOS becomes a big problem even with fidelity bonds, then its possible
> to have Alice request a "DOS proof" from Bob before broadcasting, which
> is a set of data containing transactions, merkle proofs and signatures
> which are a contract where Bob promises to broadcast his own transaction
> if Alice does so first. If Alice gets DOSed then she can share this DOS
> proof publicly. The proof will have enough information to convince
> anyone else that the DOS really happened, and it means that nobody else
> will ever CoinSwap with Bob's fidelity bond either (or at least assign
> some kind of ban score to lower the probability). I doubt it will come
> to this so I haven't expanded the idea much, but theres a longer writeup
> in the reference[5].
> 
> === Private key handover ===
> 
> The original proposal for CoinSwap involved four transactions. Two to
> pay into the multisig addresses and two to pay out. We can do better
> than this with private key handover[6]. This is an observation that once
> the CoinSwap preimage is revealed, Alice and Bob don't have to sign each
> other's multisig spend, instead they could hand over their private key
> to the other party. The other party will know both keys of the 2-of-2
> multisig and therefore have unilateral control of the coins. Although
> they would still need to watch the chain and respond in case a
> hash-time-locked contract transaction is broadcasted.
> 
> As well as saving block space, it also improves privacy because the
> coins could stay unspent for a long time, potentially indefinitely.
> While in the original coinswap proposal an analyst of the chain would
> always see a funding transaction followed closely in time by a
> settlement transaction, and this could be used as a fingerprint.
> 
> We can go even further than private key handover using a scheme called
> SAS: Succinct Atomic Swap[7]. This scheme uses adapter signatures[8] to
> create a similar outcome to CoinSwap-with-private-key-handover, but only
> one party in the CoinSwap must watch and respond to blockchain events
> until they spend the coin. The other party just gets unilateral control
> of their coins without needing to watch and respond.
> 
> 
> === PayJoin with CoinSwap ===
> 
> CoinSwap can be combined with CoinJoin. In original CoinSwap, Alice
> might pay into a CoinSwap address with a regular transaction spending
> multiple of her own inputs:
> 
>     AliceInputA (1 BTC) ----> CoinSwap Address (3 BTC)
>     AliceInputB (2 BTC)
> 
> This leaks information that all of those inputs are owned by the same
> person. We can make this example transaction a CoinJoin by involving
> Bob's inputs too. CoinJoin requires interaction but because Alice and
> Bob are already interacting to follow the CoinSwap protocol, so it's not
> too hard to have them interact a bit more to do a CoinJoin too. The
> CoinJoin transaction which funds the CoinSwap address would look like this:
> 
>     AliceInputA (1 BTC) ----> CoinSwap Address (7 BTC)
>     AliceInputB (2 BTC)
>     BobInputA   (4 BTC)
> 
> Alice's and Bob's inputs are both spent in a same transaction, which
> breaks the common-input-ownership heuristic. This form of CoinJoin is
> most similar to the PayJoin protocol or CoinJoinXT protocol. As with the
> rest of this design, this protocol does not have any special patterns
> and so is indistinguishable from any regular bitcoin transaction.
> 
> To make this work Bob the maker needs to provide two unrelated UTXOs,
> one that is CoinSwapped and the other CoinJoined.
> 
> ==== Using decoy UTXOs to protecting from leaks ====
> 
> If Bob the maker was just handing out inputs for CoinJoins to any Alice
> who asked, then malicious Alice's could constantly poll Bob to learn his
> UTXO and then halt the protocol. Malicious Alice could learn all of
> Bob's UTXOs and easily unmix future CoinSwaps by watching their future
> spends.
> 
> To defend against this attack we have Bob maintain a list of "decoy
> UTXOs", which are UTXOs that Bob found by scanning recent blocks. Then
> when creating the CoinJoin, Bob doesn't just send his own input but
> sends perhaps 50 or 100 other inputs which don't belong to him. For the
> protocol to continue Alice must partially-sign many CoinJoin
> transactions; one for each of those inputs, and send them back to Bob.
> Then Bob can sign the transaction which contains his genuine input and
> broadcast it. If Alice is actually a malicious spy she won't learn Bob's
> input for sure but will only know 100 other inputs, the majority of
> which have nothing to do with Bob. By the time malicious Alice learns
> Bob's true UTXO its already too late because its been spent and Alice is
> locked into the CoinSwap protocol, requiring time, miner fees and
> CoinSwap fees to get out.
> 
> This method of decoy UTXOs has already been written about in the
> original PayJoin designs from 2018[9][10].
> 
> === Creating a communication network using federated message boards ===
> 
> Right now JoinMarket uses public IRC networks for communication. This is
> subpar for a number of reasons, and we can do better.
> 
> I propose that there be a small number of volunteer-operated HTTP
> servers run on Tor hidden services. Their URLs are included in the
> CoinSwap software by default. They can be called message board servers.
> Makers are also servers run on hidden services, and to advertise
> themselves they connect to these message board servers to post the
> makers own .onion address. To protect from spam, makers must provide a
> fidelity bond before being allowed to write to the HTTP server.
> 
> Takers connect to all these HTTP message boards and download the list of
> all known maker .onion addresses. They connect to each maker's onion to
> obtain parameters like offered coinswap fee and maximum coinswap size.
> This is equivalent to downloading the orderbook on JoinMarket. Once
> takers have chosen which makers they'll do a CoinSwap with, they
> communicate with those maker again directly through their .onion address
> to transmit the data needed to create CoinSwaps.
> 
> These HTTP message board servers can be run quite cheaply, which is
> required as they'd be volunteer run. They shouldn't require much
> bandwidth or disk space, as they are well-protected from spam with the
> fidelity bond requirement. The system can also tolerate temporary
> downtimes so the servers don't need to be too reliable either. It's easy
> to imagine the volunteers running them on a raspberry pi in their own
> home. These message board servers are similar in some ways to the DNS
> seeds used by Bitcoin Core to find its first peers on bitcoin's p2p
> network. If the volunteers ever lose interest or disappear, then the
> community of users could find new volunteer operators and add those URLs
> to the default list.
> 
> In order to censor a maker, _all_ the message board servers would have
> to co-operate to censor him. If censorship is happening on a large scale
> (for example if the message board servers only display sybil makers run
> by themselves) then takers could also notice a drop in the total value
> of all fidelity bonds.
> 
> 
> == How are CoinSwap and Lightning Network different? ==
> 
> CoinSwap and Lightning Network have many similarities, so it's natural
> to ask why are they different, and why do we need a CoinSwap system at
> all if we already have Lightning?
> 
> === CoinSwap can be adopted unilaterally and is on-chain ===
> 
> Today we see some centralized exchange not supporting so-called
> ``privacy altcoins'' because of regulatory compliance concerns. We also
> see some exchanges frowning upon or blocking CoinJoin transaction they
> detect[11]. (There is some debate over whether the exchanges really
> blocked transactions because they were CoinJoin, but the principle
> remains that equal-output CoinJoins are inherently visible as such).
> It's possible that those exchanges will never adopt Lightning because of
> its privacy features.
> 
> Such a refusal would simply not be possible with CoinSwap, because it is
> fundamentally an on-chain technology. CoinSwap users pay to bitcoin
> addresses, not Lightning invoices. Anybody who accepts bitcoin today
> will accept CoinSwap. And because CoinSwap transactions can be made
> indistinguishable from regular transactions, it would be very difficult
> to even determine whether they got paid via a CoinSwap or not. So
> CoinSwap is not a replacement for Lightning, instead it is a replacement
> for on-chain privacy technology such as equal-output CoinJoins which are
> implemented today in JoinMarket, Wasabi Wallet and Samourai Wallet.
> Ideally this design, if implemented, would be possible to include into
> the many already-existing bitcoin wallets, and so the CoinSwaps would be
> accessible to everyone.
> 
> This feature of CoinSwap will in turn help Lightning Network, because
> those censoring exchanges won't be able to stop transactions with
> undetectable privacy no matter what they do. When they realize this
> they'll likely just implement Lightning Network anyway regardless of the
> privacy.
> 
> Bitcoin needs on-chain privacy as well, otherwise the bad privacy can
> leak into layer-2 solutions.
> 
> === Different ways of solving liquidity ===
> 
> Lightning Network cannot support large payment amounts. Liquidity in
> payment channels on the Lightning network is a scarce resource. Nodes
> which relay lightning payments always take care that a payment does not
> exhaust their liquidity. Users of Lightning today must often be aware of
> inbound liquidity, outbound liquidity and channel rebalancing. There
> even exist services today which sell Lightning liquidity.
> 
> This CoinSwap design solves its liquidity problem in a completely
> different way. Because of the liquidity market similar to JoinMarket,
> all the required liquidity is always available. There are never any
> concerns about exhausting channel capacity or a route not being found,
> because such liquidity is simply purchased from the liquidity market
> right before it is used.
> 
> It is still early days for Lightning, and liquidity has been a known
> issue since the start. Many people are confident that the liquidity
> issue will be improved. Yet it seems hard to imagine that Lightning
> Network will ever reliably route payments of 200 BTC to any node in the
> network (and it doesn't have to to be successful), yet on JoinMarket
> today as I write these words there are offers to create CoinJoins with
> amounts up to around 200 BTC. We can expect similar large amounts to be
> sendable in CoinSwap. The liquidity market as a solution is known to
> work and has been working for years.
> 
> === Sybil resistance ===
> 
> CoinSwap can support fidelity bonds and so can be made much more
> resistant to sybil attacks. We saw in the earlier section that realistic
> numbers from JoinMarket imply a sybil attacker would have to lock up
> hundreds of millions of USD worth of bitcoin to successfully deanonymize
> users.
> 
> It's difficult to compare this to the cost of a sybil attack in
> Lightning network as such attacks are hard to analyze. For example, the
> attacker needs to convince users to route payments through the
> attacker's own nodes, and maybe they could do this, but putting numbers
> on it is hard. Even so it is very likely that the true cost is much less
> than 500 million USD locked up for months because Lightning nodes can be
> set up for not more than the cost of hardware and payment channel
> capacity, while CoinSwap makers would require expensive fidelity bond
> sacrifices.
> 
> As this CoinSwap design would cost much more sybil attack, its privacy
> would be much greater in this respect.
> 
> 
> == How are CoinSwap, PayJoin and PaySwap different? ==
> 
> PayJoin can also be indistinguishable from regular bitcoin transaction,
> so why don't we all just that and not go further?
> 
> The answer is the threat models. PayJoin works by having the customer
> and merchant together co-operate to increase both their privacy. It
> works if the adversary of both of them is a passive observer of the
> blockchain.
> 
> PayJoin doesnt help a customer at all if the user's adversary is the
> merchant. This situation happens all the time today, for example
> exchanges spying on their customers. CoinSwap can help in this
> situation, as it doesn't assume or require that the second party is your
> friend. The same argument applies to PaySwap.
> 
> Obviously PayJoin and PaySwap are still very useful, but they operate
> under different threat models.
> 
> 
> == Conclusion ==
> 
> CoinSwap is a promising privacy protocol because it breaks the
> transaction graph heuristic, but it cant work on its own. In order to
> create a truly private system of sending transactions which would
> improve bitcoin's fungibility, CoinSwap must be combined with a couple
> of other building blocks:
> 
> * ECDSA-2P
> * Liquidity market
> * Routed CoinSwaps
> * Multi-transaction CoinSwaps
> * Breaking change output heuristics
> * Fidelity bonds
> * PayJoin with CoinSwap
> * Federated message boards protected from spam with fidelity bonds
> 
> CoinSwap transactions could be made to look just like any other regular
> bitcoin transaction, with no distinguishing fingerprint. This would make
> them invisible.
> 
> I intend to create this CoinSwap software. It will be almost completely
> decentralized and available for all to use for free. The design is
> published here for review. If you want to help support development I
> accept donations at https://bitcoinprivacy.me/coinswap-donations
> 
> 
> == References ==
> 
> - [1] "CoinSwap: Transaction graph disjoint trustless trading"
> https://bitcointalk.org/index.php?topic=321228.0
> 
> - [2]
> http://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/scriptless-ecdsa/
> 
> - [3] https://en.bitcoin.it/wiki/Privacy#Change_address_detection
> 
> - [4] "Design for improving JoinMarket's resistance to sybil attacks
> using fidelity bonds"
> https://gist.github.com/chris-belcher/18ea0e6acdb885a2bfbdee43dcd6b5af/
> 
> - [5] https://github.com/AdamISZ/CoinSwapCS/issues/50
> 
> - [6] https://github.com/AdamISZ/CoinSwapCS/issues/53
> 
> - [7]
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-May/017846.html
> 
> - [8]
> https://github.com/ElementsProject/scriptless-scripts/blob/master/md/atomic-swap.md
> 
> - [9]
> https://blockstream.com/2018/08/08/en-improving-privacy-using-pay-to-endpoint/
> 
> - [10] https://medium.com/@nopara73/pay-to-endpoint-56eb05d3cac6
> 
> - [11]
> https://cointelegraph.com/news/binance-returns-frozen-btc-after-user-promises-not-to-use-coinjoin
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From dave at dtrt.org  Fri Jun 19 19:58:46 2020
From: dave at dtrt.org (David A. Harding)
Date: Fri, 19 Jun 2020 15:58:46 -0400
Subject: [bitcoin-dev] [Lightning-dev] RBF Pinning with Counterparties
 and Competing Interest
In-Reply-To: <CACdvm3Of_9zhNmzCxeK-z8oz6wU=8RuDjr0R9+yrGeFjLYz9pg@mail.gmail.com>
References: <PtYNeePySy_thDHm8FwIIGEk32EjJpSmiwPctyEg0hOrLZEHjO1IBghm4MWY88g51K-XF2pf_JDnW0UdTL6QSbACEj21h9U1s5ITc_N3I6Q=@protonmail.com>
 <67334082-5ABA-45C7-9C09-FF19B119C80D@mattcorallo.com>
 <62P_3wvv8z7AVCdKPfh-bs30-LliHkx9GI9Og3wqIK6hadIG0d6MJJm077zac1erpPUy31FqgZjkAjEl9AQtrOCg4XA5cxozBb7-OIbbgvE=@protonmail.com>
 <4c4f3a06-0078-ef6a-7b06-7484f0f9edf1@mattcorallo.com>
 <CACdvm3Of_9zhNmzCxeK-z8oz6wU=8RuDjr0R9+yrGeFjLYz9pg@mail.gmail.com>
Message-ID: <20200619195846.fclw4ilngvbbf2kk@ganymede>

On Fri, Jun 19, 2020 at 09:44:11AM +0200, Bastien TEINTURIER via Lightning-dev wrote:
> The gist is here, and I'd appreciate your feedback if I have wrongly
> interpreted some of the ideas:
> https://gist.github.com/t-bast/22320336e0816ca5578fdca4ad824d12

Quoted text below is from the gist:

> The trick to protect against a malicious participant that broadcasts a
> low-fee HTLC-success or Remote-HTLC-success transaction is that we can
> always blindly do a CPFP carve-out on them; we know their txid

I think you're assuming here that the attacker broadcast a particular
state.  However, in a channel which potentially had thousands of state
changes, you'd have to broadcast a blind child for each previous state
(or at least each previous state that pays the attacker more than the
latest state).  That's potentially thousands of transactions times
potentially dozens of peers---not impossible, but it seems messy.

I think there's a way to accomplish the same goal for less bandwidth and
zero fees.  The only way your Bitcoin peer will relay your blind child
is if it already has the parent transaction.  If it has the parent, you
can just request it using P2P getdata(type='tx', id=$txid).[1]  You can
batch multiple txid requests together (up to 50,000 IIRC) to minimize
overhead, making the average cost per txid a tiny bit over 36 bytes.
If you receive one of the transactions you request, you can extract the
preimage at no cost to yourself (except bandwidth).  If you don't
receive a transaction, then sending a blind child is hopeless
anyway---your peers won't relay it.

Overall, it's hard for me to guess how effective your proposal would be
at defeating the attack.  I think the strongman argument for the attack
would be that the attacker will be able to perform a targeted relay of
their outdated state to just miners---everyone else on the network
will receive the counterparty's honest final-state close.  Unless the
counterparty happens to have a connection to a miner's node, the
counterparty will neither be able to CPFP fee bump nor use getdata to
retrieve the preimage.

It seems to me it's practical for a motivated attacker to research which
IP addresses belong to miners so that they can target them, whereas
honest users won't practically be able to do that research (and, even if
they could, it would create a centralizing barrier to new miners
entering the market if users focused on maintaining connections to
previously-known miners).

-Dave

[1] You'd have to be careful to not attempt the getdata too soon after
    you think the attacker broadcast their old state, but I think that
    only means waiting a single block, which you have to do anyway to
    see if the honest final-commitment transaction confirmed.  See
    https://github.com/bitcoin/bitcoin/pull/18861

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200619/09974bd2/attachment.sig>

From dave at dtrt.org  Fri Jun 19 20:52:20 2020
From: dave at dtrt.org (David A. Harding)
Date: Fri, 19 Jun 2020 16:52:20 -0400
Subject: [bitcoin-dev] [Lightning-dev] RBF Pinning with Counterparties
 and Competing Interest
In-Reply-To: <20200619195846.fclw4ilngvbbf2kk@ganymede>
References: <PtYNeePySy_thDHm8FwIIGEk32EjJpSmiwPctyEg0hOrLZEHjO1IBghm4MWY88g51K-XF2pf_JDnW0UdTL6QSbACEj21h9U1s5ITc_N3I6Q=@protonmail.com>
 <67334082-5ABA-45C7-9C09-FF19B119C80D@mattcorallo.com>
 <62P_3wvv8z7AVCdKPfh-bs30-LliHkx9GI9Og3wqIK6hadIG0d6MJJm077zac1erpPUy31FqgZjkAjEl9AQtrOCg4XA5cxozBb7-OIbbgvE=@protonmail.com>
 <4c4f3a06-0078-ef6a-7b06-7484f0f9edf1@mattcorallo.com>
 <CACdvm3Of_9zhNmzCxeK-z8oz6wU=8RuDjr0R9+yrGeFjLYz9pg@mail.gmail.com>
 <20200619195846.fclw4ilngvbbf2kk@ganymede>
Message-ID: <20200619205220.fshbr7pbijaerbf2@ganymede>

On Fri, Jun 19, 2020 at 03:58:46PM -0400, David A. Harding via bitcoin-dev wrote:
> I think you're assuming here that the attacker broadcast a particular
> state.  

Whoops, I managed to confuse myself despite looking at Bastien's
excellent explainer.  The attacker would be broadcasting the latest
state, so the honest counterparty would only need to send one blind
child.  However, the blind child will only be relayed by a Bitcoin peer
if the peer also has the parent transaction (the latest state) and, if
it has the parent transaction, you should be able to just getdata('tx',
$txid) that transaction from the peer without CPFPing anything.  That
will give you the preimage and so you can immediately resolve the HTLC
with the upstream channel.

Revising my conclusion from the previous post:

I think the strongman argument for the attack would be that the attacker
will be able to perform a targeted relay of the low-feerate
preimage-containing transaction to just miners---everyone else on the
network will receive the honest user's higher-feerate expired-timelock
transaction.  Unless the honest user happens to have a connection to a
miner's node, the user will neither be able to CPFP fee bump nor use
getdata to retrieve the preimage.

Sorry for the confusion.

-Dave
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200619/917b77aa/attachment.sig>

From bastien at acinq.fr  Sat Jun 20 08:54:03 2020
From: bastien at acinq.fr (Bastien TEINTURIER)
Date: Sat, 20 Jun 2020 10:54:03 +0200
Subject: [bitcoin-dev] [Lightning-dev] RBF Pinning with Counterparties
 and Competing Interest
In-Reply-To: <20200619205220.fshbr7pbijaerbf2@ganymede>
References: <PtYNeePySy_thDHm8FwIIGEk32EjJpSmiwPctyEg0hOrLZEHjO1IBghm4MWY88g51K-XF2pf_JDnW0UdTL6QSbACEj21h9U1s5ITc_N3I6Q=@protonmail.com>
 <67334082-5ABA-45C7-9C09-FF19B119C80D@mattcorallo.com>
 <62P_3wvv8z7AVCdKPfh-bs30-LliHkx9GI9Og3wqIK6hadIG0d6MJJm077zac1erpPUy31FqgZjkAjEl9AQtrOCg4XA5cxozBb7-OIbbgvE=@protonmail.com>
 <4c4f3a06-0078-ef6a-7b06-7484f0f9edf1@mattcorallo.com>
 <CACdvm3Of_9zhNmzCxeK-z8oz6wU=8RuDjr0R9+yrGeFjLYz9pg@mail.gmail.com>
 <20200619195846.fclw4ilngvbbf2kk@ganymede>
 <20200619205220.fshbr7pbijaerbf2@ganymede>
Message-ID: <CACdvm3O+A5M17rqejzAMUzE+fxLdzqnDY2m5+rnc5C=nzyPp9g@mail.gmail.com>

Hello Dave and list,

Thanks for your quick answers!

The attacker would be broadcasting the latest
> state, so the honest counterparty would only need to send one blind
> child.
>

Exactly, if the attacker submits an outdated transaction he would be
shooting himself in the foot,
as we could claim the revocation paths when seeing the transaction in a
block and get all the
channel funds (since the attacker's outputs will be CSV-locked).

The only way your Bitcoin peer will relay your blind child
> is if it already has the parent transaction.
>

That's an excellent point that I missed in the blind CPFP carve-out trick!
I think this makes the
blind CPFP carve-out quite hard in practice (even using getdata - thanks
for detailing that option)...

In the worst case scenario where most miners' mempools contain the
attacker's tx and the rest of
the network's mempools contains the honest participant's tx, I think there
isn't much we can do.
We're simply missing information, so it looks like the only good solution
is to avoid being in that
situation by having a foot in miners' mempools. Do you think it's
unreasonable to expect at least
some LN nodes to also invest in running nodes in mining pools, ensuring
that they learn about
attackers' txs and can potentially share discovered preimages with the
network off-chain (by
gossiping preimages found in the mempool over LN)? I think that these
recent attacks show that
we need (at least some) off-chain nodes to be somewhat heavily invested in
on-chain operations
(layers can't be fully decoupled with the current security assumptions -
maybe Eltoo will help
change that in the future?).

Thank you for your time!
Bastien



Le ven. 19 juin 2020 ? 22:53, David A. Harding <dave at dtrt.org> a ?crit :

> On Fri, Jun 19, 2020 at 03:58:46PM -0400, David A. Harding via bitcoin-dev
> wrote:
> > I think you're assuming here that the attacker broadcast a particular
> > state.
>
> Whoops, I managed to confuse myself despite looking at Bastien's
> excellent explainer.  The attacker would be broadcasting the latest
> state, so the honest counterparty would only need to send one blind
> child.  However, the blind child will only be relayed by a Bitcoin peer
> if the peer also has the parent transaction (the latest state) and, if
> it has the parent transaction, you should be able to just getdata('tx',
> $txid) that transaction from the peer without CPFPing anything.  That
> will give you the preimage and so you can immediately resolve the HTLC
> with the upstream channel.
>
> Revising my conclusion from the previous post:
>
> I think the strongman argument for the attack would be that the attacker
> will be able to perform a targeted relay of the low-feerate
> preimage-containing transaction to just miners---everyone else on the
> network will receive the honest user's higher-feerate expired-timelock
> transaction.  Unless the honest user happens to have a connection to a
> miner's node, the user will neither be able to CPFP fee bump nor use
> getdata to retrieve the preimage.
>
> Sorry for the confusion.
>
> -Dave
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200620/6caf18ec/attachment.html>

From dave at dtrt.org  Sat Jun 20 10:36:47 2020
From: dave at dtrt.org (David A. Harding)
Date: Sat, 20 Jun 2020 06:36:47 -0400
Subject: [bitcoin-dev] [Lightning-dev] RBF Pinning with Counterparties
 and Competing Interest
In-Reply-To: <CACdvm3O+A5M17rqejzAMUzE+fxLdzqnDY2m5+rnc5C=nzyPp9g@mail.gmail.com>
References: <PtYNeePySy_thDHm8FwIIGEk32EjJpSmiwPctyEg0hOrLZEHjO1IBghm4MWY88g51K-XF2pf_JDnW0UdTL6QSbACEj21h9U1s5ITc_N3I6Q=@protonmail.com>
 <67334082-5ABA-45C7-9C09-FF19B119C80D@mattcorallo.com>
 <62P_3wvv8z7AVCdKPfh-bs30-LliHkx9GI9Og3wqIK6hadIG0d6MJJm077zac1erpPUy31FqgZjkAjEl9AQtrOCg4XA5cxozBb7-OIbbgvE=@protonmail.com>
 <4c4f3a06-0078-ef6a-7b06-7484f0f9edf1@mattcorallo.com>
 <CACdvm3Of_9zhNmzCxeK-z8oz6wU=8RuDjr0R9+yrGeFjLYz9pg@mail.gmail.com>
 <20200619195846.fclw4ilngvbbf2kk@ganymede>
 <20200619205220.fshbr7pbijaerbf2@ganymede>
 <CACdvm3O+A5M17rqejzAMUzE+fxLdzqnDY2m5+rnc5C=nzyPp9g@mail.gmail.com>
Message-ID: <20200620103647.g62srlcxbjqpaqj6@ganymede>

On Sat, Jun 20, 2020 at 10:54:03AM +0200, Bastien TEINTURIER wrote:
> We're simply missing information, so it looks like the only good
> solution is to avoid being in that situation by having a foot in
> miners' mempools.

The problem I have with that approach is that the incentive is to
connect to the highest hashrate pools and ignore the long tail of
smaller pools and solo miners.  If miners realize people are doing this,
they may begin to charge for information about their mempool and the
largest miners will likely be able to charge more money per hashrate
than smaller miners, creating a centralization force by increasing
existing economies of scale.

Worse, information about a node's mempool is partly trusted.  A node can
easily prove what transactions it has, but it can't prove that it
doesn't have a certain transaction.  This implies incumbent pools with a
long record of trustworthy behavior may be able to charge more per
hashrate than a newer pools, creating a reputation-based centralizing
force that pushes individual miners towards well-established pools.

This is one reason I suggested using independent pay-to-preimage
transactions[1].  Anyone who knows the preimage can mine the
transaction, so it doesn't provide reputational advantage or direct
economies of scale---pay-to-preimage is incentive equivalent to paying
normal onchain transaction fees.  There is an indirect economy of
scale---attackers are most likely to send the low-feerate
preimage-containing transaction to just the largest pools, so small
miners are unlikely to learn the preimage and thus unlikely to be able
to claim the payment.  However, if the defense is effective, the attack
should rarely happen and so this should not have a significant effect on
mining profitability---unlike monitoring miner mempools which would have
to be done continuously and forever.

ZmnSCPxj noted that pay-to-preimage doesn't work with PTLCs.[2]  I was
hoping one of Bitcoin's several inventive cryptographers would come
along and describe how someone with an adaptor signature could use that
information to create a pubkey that could be put into a transaction with
a second output that OP_RETURN included the serialized adaptor
signature.  The pubkey would be designed to be spendable by anyone with
the final signature in a way that revealed the hidden value to the
pubkey's creator, allowing them to resolve the PTLC.  But if that's
fundamentally not possible, I think we could advocate for making
pay-to-revealed-adaptor-signature possible using something like
OP_CHECKSIGFROMSTACK.[3]

[1] https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002664.html
[2] https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002667.html
[3] https://bitcoinops.org/en/topics/op_checksigfromstack/

> Do you think it's unreasonable to expect at least some LN nodes to
> also invest in running nodes in mining pools, ensuring that they learn
> about attackers' txs and can potentially share discovered preimages
> with the network off-chain (by gossiping preimages found in the
> mempool over LN)?

Ignoring my concerns about mining centralization and from the
perspective of just the Lightning Network, that doesn't sound
unreasonable to me.  But from the perspective of a single LN node, it
might make more sense to get the information and *not* share it,
increasing your security and allowing you to charge lower routing fees
compared to your competitors.  This effect would only be enhanced if
miners charged for their mempool contents (indeed, to maximize their
revenue, miners might require that their mempool subscribers don't share
the information---which they could trivially enforce by occasionally
sending subscribers a preimage specific to the subscriber and seeing if
it propagated to the public network).

> I think that these recent attacks show that we need (at least some)
> off-chain nodes to be somewhat heavily invested in on-chain operations
> (layers can't be fully decoupled with the current security assumptions
> - maybe Eltoo will help change that in the future?).

I don't see how eltoo helps.  Eltoo helps ensure you reach the final
channel state, but this problem involves an abuse of that final state.

-Dave
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200620/6085153a/attachment-0001.sig>

From ZmnSCPxj at protonmail.com  Sat Jun 20 16:01:16 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 20 Jun 2020 16:01:16 +0000
Subject: [bitcoin-dev] [Lightning-dev] RBF Pinning with Counterparties
	and Competing Interest
In-Reply-To: <20200620103647.g62srlcxbjqpaqj6@ganymede>
References: <PtYNeePySy_thDHm8FwIIGEk32EjJpSmiwPctyEg0hOrLZEHjO1IBghm4MWY88g51K-XF2pf_JDnW0UdTL6QSbACEj21h9U1s5ITc_N3I6Q=@protonmail.com>
 <67334082-5ABA-45C7-9C09-FF19B119C80D@mattcorallo.com>
 <62P_3wvv8z7AVCdKPfh-bs30-LliHkx9GI9Og3wqIK6hadIG0d6MJJm077zac1erpPUy31FqgZjkAjEl9AQtrOCg4XA5cxozBb7-OIbbgvE=@protonmail.com>
 <4c4f3a06-0078-ef6a-7b06-7484f0f9edf1@mattcorallo.com>
 <CACdvm3Of_9zhNmzCxeK-z8oz6wU=8RuDjr0R9+yrGeFjLYz9pg@mail.gmail.com>
 <20200619195846.fclw4ilngvbbf2kk@ganymede>
 <20200619205220.fshbr7pbijaerbf2@ganymede>
 <CACdvm3O+A5M17rqejzAMUzE+fxLdzqnDY2m5+rnc5C=nzyPp9g@mail.gmail.com>
 <20200620103647.g62srlcxbjqpaqj6@ganymede>
Message-ID: <wRX9uiX_fFrjZvlmgx3Sj64VA3DdXakJZJq2_7DHJWIS7QBlphgpaBDdm4SjdY4aij5pESsumww8iJw8QZe5mO8bPgpYFyp6eImF2xbaXR4=@protonmail.com>

Good morning Dave,

> ZmnSCPxj noted that pay-to-preimage doesn't work with PTLCs.[2] I was
> hoping one of Bitcoin's several inventive cryptographers would come
> along and describe how someone with an adaptor signature could use that
> information to create a pubkey that could be put into a transaction with
> a second output that OP_RETURN included the serialized adaptor
> signature. The pubkey would be designed to be spendable by anyone with
> the final signature in a way that revealed the hidden value to the
> pubkey's creator, allowing them to resolve the PTLC. But if that's
> fundamentally not possible, I think we could advocate for making
> pay-to-revealed-adaptor-signature possible using something like
> OP_CHECKSIGFROMSTACK.[3]


Not a cryptographer, I just play one on the Internet, but maybe the pay-for-signature construction could work...?

Assuming a PTLC has a pointlocked branch, which involves signing with MuSig(A, B).
A offers to B the amount if B reveals the secret `t` behind `T = t * G`; A knows `T` but not `t`.
This is done by B handing over `R[B]` and `s'[B]`:

    R = R[A] + R[B] + T
    s'[B] = r[B] + h(MuSig(A, B) | R | m) * b

Then A provides its partial signature to B.

    s[A] = r[A] + h(MuSig(A, B) | R | m) * a

B has to complete the signature by:

    s = s[A] + s'[B] + t

Since A knows both `s[A]` and `s'[B]`, once it knows `s`, it can compute `t`.


Now, we can massage the equation for `s`:

    s = r[A] + h(MuSig(A, B) | R | m) * a + r[B] + h(MuSig(A, B) | R | m) * b + t
    ; multiply both sides by G
    s * G = r[A] * G + h(MuSig(A, B) | R | m) * a * G + r[B] * G + h(MuSig(A, B) | R | m) * b * G + t * G
    ; replace with public points
    s * G = R[A] + h(MuSig(A, B) | R | m) * A + R[B] + h(MuSig(A, B) | R | m) * B + T

Note that A can compute `s * G` above, because it generated `R[A]`, was given `R[B]` and `T`, and knows who `A` and `B` are.

So what A needs to do is to offer a fund that can only be claimed by leaking knowledge of `s` behind `s * G`.
A can do this by creating a new keypair `A[p4s] = a[p4s] * G` and putting a fund into it.

Then A generates an `R[A][p4s] = r[A][p4s] * G`, and computes:

    R[p4s] = R[A][p4s] + s * G
    s'[A][p4s] = r[A][p4s] + h(A | R[p4s] | m) * a[p4s]

The signed message could be a signature to `SIGHASH_NONE`, finally an actual use for that flag.

A reveals publicly (in an `OP_RETURN` as you suggest):

* `R[A][p4s]`
* `s * G`
* `s'[A][p4s]`
* `A[p4s]` - Already the Schnorr output pubkey.

In order to complete the above signature, a third party C has to learn `s` from B.

The third party has to scan every onchain 1-of-1 signature for an `s` that matches `s * G`, so there is greater processing (point multiplies are more expensive than hashes, also there are more 1-of-1s).
But once learned, the third party can complete the signature and claim the funds.
And A then learns `s`, from which it can derive `t`.

The third party learns about which channel (i.e. the UTXO that was spent to create the PTLC in the first place), but never learns `t` or `T`, which is a small but nice privacy bonus.


Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Sun Jun 21 02:10:32 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sun, 21 Jun 2020 02:10:32 +0000
Subject: [bitcoin-dev] [Lightning-dev] RBF Pinning with Counterparties
	and Competing Interest
In-Reply-To: <wRX9uiX_fFrjZvlmgx3Sj64VA3DdXakJZJq2_7DHJWIS7QBlphgpaBDdm4SjdY4aij5pESsumww8iJw8QZe5mO8bPgpYFyp6eImF2xbaXR4=@protonmail.com>
References: <PtYNeePySy_thDHm8FwIIGEk32EjJpSmiwPctyEg0hOrLZEHjO1IBghm4MWY88g51K-XF2pf_JDnW0UdTL6QSbACEj21h9U1s5ITc_N3I6Q=@protonmail.com>
 <67334082-5ABA-45C7-9C09-FF19B119C80D@mattcorallo.com>
 <62P_3wvv8z7AVCdKPfh-bs30-LliHkx9GI9Og3wqIK6hadIG0d6MJJm077zac1erpPUy31FqgZjkAjEl9AQtrOCg4XA5cxozBb7-OIbbgvE=@protonmail.com>
 <4c4f3a06-0078-ef6a-7b06-7484f0f9edf1@mattcorallo.com>
 <CACdvm3Of_9zhNmzCxeK-z8oz6wU=8RuDjr0R9+yrGeFjLYz9pg@mail.gmail.com>
 <20200619195846.fclw4ilngvbbf2kk@ganymede>
 <20200619205220.fshbr7pbijaerbf2@ganymede>
 <CACdvm3O+A5M17rqejzAMUzE+fxLdzqnDY2m5+rnc5C=nzyPp9g@mail.gmail.com>
 <20200620103647.g62srlcxbjqpaqj6@ganymede>
 <wRX9uiX_fFrjZvlmgx3Sj64VA3DdXakJZJq2_7DHJWIS7QBlphgpaBDdm4SjdY4aij5pESsumww8iJw8QZe5mO8bPgpYFyp6eImF2xbaXR4=@protonmail.com>
Message-ID: <v959z56ko0Nzdl9BGs-zRWIxIy9o960OfvH6bRszIC9_JI-zdtQuSb7fPD4L_VnngBp_nLMMfl_Nfd6ZLtSeZZRKhZoFO5Xxryvo6GT0zT4=@protonmail.com>

Good morning again,

> Good morning Dave,
>
> > ZmnSCPxj noted that pay-to-preimage doesn't work with PTLCs.[2] I was
> > hoping one of Bitcoin's several inventive cryptographers would come
> > along and describe how someone with an adaptor signature could use that
> > information to create a pubkey that could be put into a transaction with
> > a second output that OP_RETURN included the serialized adaptor
> > signature. The pubkey would be designed to be spendable by anyone with
> > the final signature in a way that revealed the hidden value to the
> > pubkey's creator, allowing them to resolve the PTLC. But if that's
> > fundamentally not possible, I think we could advocate for making
> > pay-to-revealed-adaptor-signature possible using something like
> > OP_CHECKSIGFROMSTACK.[3]
>
> <snip>
>
> The signed message could be a signature to `SIGHASH_NONE`, finally an actual use for that flag.

If you are going to embed it in an `OP_RETURN` in the same transaction, you also need `SIGHASH_ANYPREVOUT`, otherwise you cannot embed the adaptor signature for spending from that transaction in the transaction being spent, it also implies `A[p4s] = a[p4s] * G` is a one-time-use keypair.

Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Mon Jun 22 08:15:37 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 22 Jun 2020 08:15:37 +0000
Subject: [bitcoin-dev] [Lightning-dev] RBF Pinning with Counterparties
	and Competing Interest
In-Reply-To: <CACdvm3NTY1UYWJg=SJm+TAZSi5RophxhRvze9gKi9PyEHx0PgA@mail.gmail.com>
References: <PtYNeePySy_thDHm8FwIIGEk32EjJpSmiwPctyEg0hOrLZEHjO1IBghm4MWY88g51K-XF2pf_JDnW0UdTL6QSbACEj21h9U1s5ITc_N3I6Q=@protonmail.com>
 <67334082-5ABA-45C7-9C09-FF19B119C80D@mattcorallo.com>
 <62P_3wvv8z7AVCdKPfh-bs30-LliHkx9GI9Og3wqIK6hadIG0d6MJJm077zac1erpPUy31FqgZjkAjEl9AQtrOCg4XA5cxozBb7-OIbbgvE=@protonmail.com>
 <4c4f3a06-0078-ef6a-7b06-7484f0f9edf1@mattcorallo.com>
 <CACdvm3Of_9zhNmzCxeK-z8oz6wU=8RuDjr0R9+yrGeFjLYz9pg@mail.gmail.com>
 <20200619195846.fclw4ilngvbbf2kk@ganymede>
 <20200619205220.fshbr7pbijaerbf2@ganymede>
 <CACdvm3O+A5M17rqejzAMUzE+fxLdzqnDY2m5+rnc5C=nzyPp9g@mail.gmail.com>
 <20200620103647.g62srlcxbjqpaqj6@ganymede>
 <CACdvm3NTY1UYWJg=SJm+TAZSi5RophxhRvze9gKi9PyEHx0PgA@mail.gmail.com>
Message-ID: <F7ZA7-s3UnfMlhYdA1esEhJIhgNIBSKCfHWG64UAcMvQM-ZS6Do7xMg8OfYhbkHIFNodbLIe51TQG7Ps3jFXFoS80EJ6oEh8n2009vbnl04=@protonmail.com>

Good morning Bastien,

> Thanks for the detailed write-up on how it affects incentives and centralization,
> these are good points. I need to spend more time thinking about them.
>
> > This is one reason I suggested using independent pay-to-preimage
> > transactions[1]
>
> While this works as a technical solution, I think it has some incentives issues too.
> In this attack, I believe the miners that hide the preimage tx in their mempool have
> to be accomplice with the attacker, otherwise they would share that tx with some of
> their peers, and some non-miner nodes would get that preimage tx and be able to
> gossip them off-chain (and even relay them to other mempools).

I believe this is technically possible with current mempool rules, without miners cooperating with the attacker.

Basically, the attacker releases two transactions with near-equal fees, so that neither can RBF the other.
It releases the preimage tx near miners, and the timelock tx near non-miners.

Nodes at the boundaries between those that receive the preimage tx and the timelock tx will receive both.
However, they will receive one or the other first.
Which one they receive first will be what they keep, and they will reject the other (and *not* propagate the other), because the difference in fees is not enough to get past the RBF rules (which requires not just a feerate increase, but also an increase in absolute fee, of at least the minimum relay feerate times transaction size).

Because they reject the other tx, they do not propagate the other tx, so the boundary between the two txes is inviolate, neither can get past that boundary, this occurs even if everyone is running 100% unmodified Bitcoin Core code.

I am not a mempool expert and my understanding may be incorrect.

Regards,
ZmnSCPxj

From bastien at acinq.fr  Mon Jun 22 07:35:20 2020
From: bastien at acinq.fr (Bastien TEINTURIER)
Date: Mon, 22 Jun 2020 09:35:20 +0200
Subject: [bitcoin-dev] [Lightning-dev] RBF Pinning with Counterparties
 and Competing Interest
In-Reply-To: <20200620103647.g62srlcxbjqpaqj6@ganymede>
References: <PtYNeePySy_thDHm8FwIIGEk32EjJpSmiwPctyEg0hOrLZEHjO1IBghm4MWY88g51K-XF2pf_JDnW0UdTL6QSbACEj21h9U1s5ITc_N3I6Q=@protonmail.com>
 <67334082-5ABA-45C7-9C09-FF19B119C80D@mattcorallo.com>
 <62P_3wvv8z7AVCdKPfh-bs30-LliHkx9GI9Og3wqIK6hadIG0d6MJJm077zac1erpPUy31FqgZjkAjEl9AQtrOCg4XA5cxozBb7-OIbbgvE=@protonmail.com>
 <4c4f3a06-0078-ef6a-7b06-7484f0f9edf1@mattcorallo.com>
 <CACdvm3Of_9zhNmzCxeK-z8oz6wU=8RuDjr0R9+yrGeFjLYz9pg@mail.gmail.com>
 <20200619195846.fclw4ilngvbbf2kk@ganymede>
 <20200619205220.fshbr7pbijaerbf2@ganymede>
 <CACdvm3O+A5M17rqejzAMUzE+fxLdzqnDY2m5+rnc5C=nzyPp9g@mail.gmail.com>
 <20200620103647.g62srlcxbjqpaqj6@ganymede>
Message-ID: <CACdvm3NTY1UYWJg=SJm+TAZSi5RophxhRvze9gKi9PyEHx0PgA@mail.gmail.com>

Thanks for the detailed write-up on how it affects incentives and
centralization,
these are good points. I need to spend more time thinking about them.

This is one reason I suggested using independent pay-to-preimage
> transactions[1]
>

While this works as a technical solution, I think it has some incentives
issues too.
In this attack, I believe the miners that hide the preimage tx in their
mempool have
to be accomplice with the attacker, otherwise they would share that tx with
some of
their peers, and some non-miner nodes would get that preimage tx and be
able to
gossip them off-chain (and even relay them to other mempools).

If they are actively helping the attacker, they wouldn't spend the
pay-to-preimage tx,
unless they gain more from it than the share the attacker gives them. This
becomes
a simple bidding war, and the honest user will always be the losing party
here (the
attacker has nothing to lose). For this reason I'm afraid it wouldn't work
out in practice
as well as we'd hope...what do you think? And even if the honest user wins
the bidding
war, the attack still steals money from that user; it just goes into the
miner's pocket.

But from the perspective of a single LN node, it
> might make more sense to get the information and *not* share it
>

I think it depends. If this attack becomes doable in practice and we see it
happening,
LN routing nodes and service providers have a very high incentive to thwart
these attacks,
because otherwise they'd lose their business as people would leave the
lightning network.

As long as enough nodes think that way (with "enough" being a very hard to
define quantity),
this should mitigate the attack. The only risk would be a big "exit scam"
scenario, but the
coordination cost between all these nodes makes that scenario unlikely
(IMHO).

Thanks,
Bastien

Le sam. 20 juin 2020 ? 12:37, David A. Harding <dave at dtrt.org> a ?crit :

> On Sat, Jun 20, 2020 at 10:54:03AM +0200, Bastien TEINTURIER wrote:
> > We're simply missing information, so it looks like the only good
> > solution is to avoid being in that situation by having a foot in
> > miners' mempools.
>
> The problem I have with that approach is that the incentive is to
> connect to the highest hashrate pools and ignore the long tail of
> smaller pools and solo miners.  If miners realize people are doing this,
> they may begin to charge for information about their mempool and the
> largest miners will likely be able to charge more money per hashrate
> than smaller miners, creating a centralization force by increasing
> existing economies of scale.
>
> Worse, information about a node's mempool is partly trusted.  A node can
> easily prove what transactions it has, but it can't prove that it
> doesn't have a certain transaction.  This implies incumbent pools with a
> long record of trustworthy behavior may be able to charge more per
> hashrate than a newer pools, creating a reputation-based centralizing
> force that pushes individual miners towards well-established pools.
>
> This is one reason I suggested using independent pay-to-preimage
> transactions[1].  Anyone who knows the preimage can mine the
> transaction, so it doesn't provide reputational advantage or direct
> economies of scale---pay-to-preimage is incentive equivalent to paying
> normal onchain transaction fees.  There is an indirect economy of
> scale---attackers are most likely to send the low-feerate
> preimage-containing transaction to just the largest pools, so small
> miners are unlikely to learn the preimage and thus unlikely to be able
> to claim the payment.  However, if the defense is effective, the attack
> should rarely happen and so this should not have a significant effect on
> mining profitability---unlike monitoring miner mempools which would have
> to be done continuously and forever.
>
> ZmnSCPxj noted that pay-to-preimage doesn't work with PTLCs.[2]  I was
> hoping one of Bitcoin's several inventive cryptographers would come
> along and describe how someone with an adaptor signature could use that
> information to create a pubkey that could be put into a transaction with
> a second output that OP_RETURN included the serialized adaptor
> signature.  The pubkey would be designed to be spendable by anyone with
> the final signature in a way that revealed the hidden value to the
> pubkey's creator, allowing them to resolve the PTLC.  But if that's
> fundamentally not possible, I think we could advocate for making
> pay-to-revealed-adaptor-signature possible using something like
> OP_CHECKSIGFROMSTACK.[3]
>
> [1]
> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002664.html
> [2]
> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002667.html
> [3] https://bitcoinops.org/en/topics/op_checksigfromstack/
>
> > Do you think it's unreasonable to expect at least some LN nodes to
> > also invest in running nodes in mining pools, ensuring that they learn
> > about attackers' txs and can potentially share discovered preimages
> > with the network off-chain (by gossiping preimages found in the
> > mempool over LN)?
>
> Ignoring my concerns about mining centralization and from the
> perspective of just the Lightning Network, that doesn't sound
> unreasonable to me.  But from the perspective of a single LN node, it
> might make more sense to get the information and *not* share it,
> increasing your security and allowing you to charge lower routing fees
> compared to your competitors.  This effect would only be enhanced if
> miners charged for their mempool contents (indeed, to maximize their
> revenue, miners might require that their mempool subscribers don't share
> the information---which they could trivially enforce by occasionally
> sending subscribers a preimage specific to the subscriber and seeing if
> it propagated to the public network).
>
> > I think that these recent attacks show that we need (at least some)
> > off-chain nodes to be somewhat heavily invested in on-chain operations
> > (layers can't be fully decoupled with the current security assumptions
> > - maybe Eltoo will help change that in the future?).
>
> I don't see how eltoo helps.  Eltoo helps ensure you reach the final
> channel state, but this problem involves an abuse of that final state.
>
> -Dave
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200622/09e39b02/attachment-0001.html>

From bastien at acinq.fr  Mon Jun 22 08:25:09 2020
From: bastien at acinq.fr (Bastien TEINTURIER)
Date: Mon, 22 Jun 2020 10:25:09 +0200
Subject: [bitcoin-dev] [Lightning-dev] RBF Pinning with Counterparties
 and Competing Interest
In-Reply-To: <F7ZA7-s3UnfMlhYdA1esEhJIhgNIBSKCfHWG64UAcMvQM-ZS6Do7xMg8OfYhbkHIFNodbLIe51TQG7Ps3jFXFoS80EJ6oEh8n2009vbnl04=@protonmail.com>
References: <PtYNeePySy_thDHm8FwIIGEk32EjJpSmiwPctyEg0hOrLZEHjO1IBghm4MWY88g51K-XF2pf_JDnW0UdTL6QSbACEj21h9U1s5ITc_N3I6Q=@protonmail.com>
 <67334082-5ABA-45C7-9C09-FF19B119C80D@mattcorallo.com>
 <62P_3wvv8z7AVCdKPfh-bs30-LliHkx9GI9Og3wqIK6hadIG0d6MJJm077zac1erpPUy31FqgZjkAjEl9AQtrOCg4XA5cxozBb7-OIbbgvE=@protonmail.com>
 <4c4f3a06-0078-ef6a-7b06-7484f0f9edf1@mattcorallo.com>
 <CACdvm3Of_9zhNmzCxeK-z8oz6wU=8RuDjr0R9+yrGeFjLYz9pg@mail.gmail.com>
 <20200619195846.fclw4ilngvbbf2kk@ganymede>
 <20200619205220.fshbr7pbijaerbf2@ganymede>
 <CACdvm3O+A5M17rqejzAMUzE+fxLdzqnDY2m5+rnc5C=nzyPp9g@mail.gmail.com>
 <20200620103647.g62srlcxbjqpaqj6@ganymede>
 <CACdvm3NTY1UYWJg=SJm+TAZSi5RophxhRvze9gKi9PyEHx0PgA@mail.gmail.com>
 <F7ZA7-s3UnfMlhYdA1esEhJIhgNIBSKCfHWG64UAcMvQM-ZS6Do7xMg8OfYhbkHIFNodbLIe51TQG7Ps3jFXFoS80EJ6oEh8n2009vbnl04=@protonmail.com>
Message-ID: <CACdvm3O3UmZcYYGaY2x23MYY=3saPFkgQtaDELd=kY93SRLLaA@mail.gmail.com>

Hey ZmnSCPxj,

I agree that in theory this looks possible, but doing it in practice with
accurate control
of what parts of the network get what tx feels impractical to me (but maybe
I'm wrong!).

It feels to me that an attacker who would be able to do this would break
*any* off-chain
construction that relies on absolute timeouts, so I'm hoping this is
insanely hard to
achieve without cooperation from a miners subset. Let me know if I'm too
optimistic on
this!

Cheers,
Bastien

Le lun. 22 juin 2020 ? 10:15, ZmnSCPxj <ZmnSCPxj at protonmail.com> a ?crit :

> Good morning Bastien,
>
> > Thanks for the detailed write-up on how it affects incentives and
> centralization,
> > these are good points. I need to spend more time thinking about them.
> >
> > > This is one reason I suggested using independent pay-to-preimage
> > > transactions[1]
> >
> > While this works as a technical solution, I think it has some incentives
> issues too.
> > In this attack, I believe the miners that hide the preimage tx in their
> mempool have
> > to be accomplice with the attacker, otherwise they would share that tx
> with some of
> > their peers, and some non-miner nodes would get that preimage tx and be
> able to
> > gossip them off-chain (and even relay them to other mempools).
>
> I believe this is technically possible with current mempool rules, without
> miners cooperating with the attacker.
>
> Basically, the attacker releases two transactions with near-equal fees, so
> that neither can RBF the other.
> It releases the preimage tx near miners, and the timelock tx near
> non-miners.
>
> Nodes at the boundaries between those that receive the preimage tx and the
> timelock tx will receive both.
> However, they will receive one or the other first.
> Which one they receive first will be what they keep, and they will reject
> the other (and *not* propagate the other), because the difference in fees
> is not enough to get past the RBF rules (which requires not just a feerate
> increase, but also an increase in absolute fee, of at least the minimum
> relay feerate times transaction size).
>
> Because they reject the other tx, they do not propagate the other tx, so
> the boundary between the two txes is inviolate, neither can get past that
> boundary, this occurs even if everyone is running 100% unmodified Bitcoin
> Core code.
>
> I am not a mempool expert and my understanding may be incorrect.
>
> Regards,
> ZmnSCPxj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200622/67840048/attachment-0001.html>

From jacob.swambo at kcl.ac.uk  Mon Jun 22 15:07:41 2020
From: jacob.swambo at kcl.ac.uk (Swambo, Jacob)
Date: Mon, 22 Jun 2020 15:07:41 +0000
Subject: [bitcoin-dev] Distributed Delegated Pre-Signed Transactions (DDPST)
Message-ID: <AM6PR03MB542597B9DFD8060860BE35F1CC970@AM6PR03MB5425.eurprd03.prod.outlook.com>

I am building a solution for distributed, delegated pre-signed transactions (DDPST). This post introduces what DDPST are and why I think they are relevant for multiple applications. If you are working on application that can benefit from such a construction and want me to use your application in the proof of concept code, please reach out. All feedback is welcome on the concept in general.

Pre-signed transactions (PSTs) are utilized in numerous off-chain protocols including Lightning Network, non-custodial trading, Statechains, and custody protocols. PSTs are useful because they enable restricted access to funds and their custody can be *delegated* with limited risk. Compare this with the arbitrary control over funds that comes with access to the private keys. It is conceivable then that a broad class of applications would benefit from a mechanism to securely delegate PSTs. A mechanism to *distribute* custody of PSTs across multiple entities can act as a practical countermeasure for numerous attacks (e.g. denial-of-service, bribery, blackmail, etc.). Moreover, systems of accountability among the custodians, with proofs of correct and incorrect behaviour, form a foundation for engineering incentive structures that align with the objectives of the application at hand. Finally, distributed custody of PSTs could enable new trust models for the privacy of delegated PSTs using multi-party computation.

# Examples

Consider first the example of vault-custody protocols [1], where there is a requirement for a distributed network monitoring and response system to detect breeches and trigger a recovery process. It is critical to protect against denial-of-service (DoS) attacks that seek to compromise a monitoring node in order to force the custody operation into a recovery process. In this attack the adversary broadcasts the recovery transaction and reduces the accessibility of the wallet owner's funds. A method for distributing custody of the recovery transaction offers defence-in-depth, and a method for delegating custody enables outsourcing the monitor and response service (see Watchtower implementations currently under development [2,3]). A further improvement for the protection of PSTs, that comes from distributing custody, is that *proactive* security models can be instanciated such that successful attacks must occur in a limited time-frame [4].

Consider next the example of justice transactions in the current Lightning Network model. Here, it is critical that justice transactions are broadcast in a timely manner in response to detecting that either party is attempting to close the channel with a prior state. Attacks rely on disrupting the broadcast of the justice transaction through, for example, bribing the watchtower to wait. The watchtower can broadcast late and claim that it was an honest failure due to network issues. The victim has no recourse to punish the watchtower nor the malicious channel participant. If instead the justice transaction was distributed among a set of independent watchtowers, and an accountability system was in-place for their actions, a more robust incentive structure could be engineered. Moreover, distributing custody of the justice transaction can provide a new privacy mechanism for both operational security of a business but also to mitigate targeted attacks such as bribery.

Best regards,
Jacob

# References

[1] Jacob Swambo, Spencer Hommel, Bob McElrath, and Bryan Bishop. Custody Protocols Using Bitcoin Vaults. 2020. https://arxiv.org/abs/2005.11776

[2] The eye of satoshi - lightning watchtower. https://github.com/talaia-labs/python-teos

[3] Private altruist watchtowers. https://github.com/lightningnetwork/lnd/blob/master/docs/watchtower.md

[4] Ran Canetti, Rosario Gennaro, and Amir Herzberg. Proactive security: Long-term protection against break-ins. CryptoBytes, 3:1?8, 1997.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200622/68d835de/attachment.html>

From stanga at gmail.com  Tue Jun 23 06:41:56 2020
From: stanga at gmail.com (Stanga)
Date: Tue, 23 Jun 2020 09:41:56 +0300
Subject: [bitcoin-dev] MAD-HTLC
In-Reply-To: <CABT1wW=X35HRVGuP-BHUhDrkBEw27+-iDkNnHWjRU-1mRkn0JQ@mail.gmail.com>
References: <CABT1wW=X35HRVGuP-BHUhDrkBEw27+-iDkNnHWjRU-1mRkn0JQ@mail.gmail.com>
Message-ID: <CABT1wW=KWtoo6zHs8=yUQ7vAYcFSdAzdpDJ9yfw6sJrLd6dN5A@mail.gmail.com>

Hi all,

We'd like to bring to your attention our recent result concerning HTLC.
Here are the technical report and a short post outlining the main points:

* https://arxiv.org/abs/2006.12031
* https://ittayeyal.github.io/2020-06-22-mad-htlc

Essentially, we find that HTLC security relies on miners being altruistic,
or at least myopic. This might be enough for some time, but it took us 150
lines of code to make bitcoind non-myopic.

On the positive side, we discovered an alternative to HTLC that we call
MAD-HTLC, which is provably secure -- everyone's best interest is to behave
as desired.

We've notified relevant teams in advance.

We'll appreciate any comments.

Best,
Itay, Ittay, and Matan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200623/22f976f1/attachment.html>

From ZmnSCPxj at protonmail.com  Tue Jun 23 09:48:27 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 23 Jun 2020 09:48:27 +0000
Subject: [bitcoin-dev] MAD-HTLC
In-Reply-To: <CABT1wW=KWtoo6zHs8=yUQ7vAYcFSdAzdpDJ9yfw6sJrLd6dN5A@mail.gmail.com>
References: <CABT1wW=X35HRVGuP-BHUhDrkBEw27+-iDkNnHWjRU-1mRkn0JQ@mail.gmail.com>
 <CABT1wW=KWtoo6zHs8=yUQ7vAYcFSdAzdpDJ9yfw6sJrLd6dN5A@mail.gmail.com>
Message-ID: <ahTHfoyyTpBrMiKdJWMn9Qa8CMCEd1-y8OXPSjsDmttTOVC3zGuDoSHkm_oOe5mBYgIAY7jOPocQhLW29n544xFsqVyq51NFApvaFYYSvFY=@protonmail.com>

Good morning Itay, Ittay, and Matan,

I believe an unstated assumption in Bitcoin is that miners are short-sighted.

The reasoning for this assumption is:

* Deployment of new mining hardware controlled by others may occur at any time you do not control.
  * Thus, any transactions you leave on the table are potentially taken by somebody else and not by you.
  * Sudden changes in hashpower distribution may reduce your expected future earnings, so any future theoretical earnings should be discounted (*in addition to* expected return-on-investment on getting money you can invest *now*).

It also strikes me that, in a world with RBF and CPFP, the same endpoint (i.e. miners earn the entire fund of the HTLC) is achieved by existing HTLCs, without the additional branch and script opcodes needed by MAD-HTLC.
For example, if an HTLC is confirmed but the hashlock-claiming transaction is not being confirmed (because miners are holding it up because Bob is offering a much higher fee in the future for the timelock-claiming transaction), then Alice can, regardless of the reason why it is not being confirmed, bump up the fee with RBF or CPFP.

If the fee bump offered by Alice is sufficiently large, then miners will start re-preferring the Alice hashlock transaction.
To counter this, Bob has to bid up its version higher.

As the timeout approaches, Alice can bump up its fee until it is just 1 satoshi short of the total fund.
It is rational for Alice to do so since at timeout, it can expect to lose the entire fund.
In order for Bob to win, it has to beat that fee, at which point it equals or exceeds the total fund, and miners get the total fund (or more).

Knowing this end-point, rational Bob will not even begin this game.

I think this research considers these two endpoints to be distinct:

* Bob misbehaves and the entire fund is punished by miners, leaving miners with the fund and Alice and Bob without money (MAD-HTLC).
* Bob misbehaves, Alice counters, and the ensuing fee war leads to fees approaching the fund value, leaving miners with the fund and Alice and Bob without money (standard HTLC).

But in practice I think both endpoints are essentially equivalent.

--

What MAD-HTLC can do would be to make different claims:

* Inputs:
  * Bob 1 BTC - HTLC amount
  * Bob 1 BTC - Bob fidelity bond

* Cases:
  * Alice reveals hashlock at any time:
    * 1 BTC goes to Alice
    * 1 BTC goes to Bob (fidelity bond refund)
  * Bob reveals bob-hashlock after time L:
    * 2 BTC goes to Bob (HTLC refund + fidelity bond refund)
  * Bob cheated, anybody reveals both hashlock and bob-hashlock:
    * 2 BTC goes to miner

This is an actual improvement over HTLC: Bob misbehavior leads to loss of the fidelity bond.
The above cases can be assured by requiring both Alice and Bob to sign in the alice-hashlock branch, so that the splitting of the fund is enforced, and SegWit signing so that the dependent transaction is signed before the HTLC-funding transaction is.
It can also be implemented with `OP_CHECKTEMPLATEVERIFY`.

Regards,
ZmnSCPxj

From stanga at gmail.com  Tue Jun 23 12:47:56 2020
From: stanga at gmail.com (Stanga)
Date: Tue, 23 Jun 2020 15:47:56 +0300
Subject: [bitcoin-dev] MAD-HTLC
In-Reply-To: <ahTHfoyyTpBrMiKdJWMn9Qa8CMCEd1-y8OXPSjsDmttTOVC3zGuDoSHkm_oOe5mBYgIAY7jOPocQhLW29n544xFsqVyq51NFApvaFYYSvFY=@protonmail.com>
References: <CABT1wW=X35HRVGuP-BHUhDrkBEw27+-iDkNnHWjRU-1mRkn0JQ@mail.gmail.com>
 <CABT1wW=KWtoo6zHs8=yUQ7vAYcFSdAzdpDJ9yfw6sJrLd6dN5A@mail.gmail.com>
 <ahTHfoyyTpBrMiKdJWMn9Qa8CMCEd1-y8OXPSjsDmttTOVC3zGuDoSHkm_oOe5mBYgIAY7jOPocQhLW29n544xFsqVyq51NFApvaFYYSvFY=@protonmail.com>
Message-ID: <CABT1wWknczx62uCpJPWku-KeYuaFvJHrvOS74YzqfoVe5x=edg@mail.gmail.com>

Hi ZmnSCPxj,

Thank you for taking the time to respond, these are very good points.
Responses inline.

On Tue, Jun 23, 2020 at 12:48 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Itay, Ittay, and Matan,
>
> I believe an unstated assumption in Bitcoin is that miners are
> short-sighted.
>
> The reasoning for this assumption is:
>
> * Deployment of new mining hardware controlled by others may occur at any
> time you do not control.
>   * Thus, any transactions you leave on the table are potentially taken by
> somebody else and not by you.
>   * Sudden changes in hashpower distribution may reduce your expected
> future earnings, so any future theoretical earnings should be discounted
> (*in addition to* expected return-on-investment on getting money you can
> invest *now*).
>

Our analysis assumes constant difficulty, i.e., no significant changes of
the miners set. Indeed, hash-rate changes typically occur at a much larger
granularity than your average HTLC timeout. For instance, we noticed plenty
of lightning nodes use timeouts of a day. So, we do not consider
optimization at infinity, just a day ahead, and within this time frame all
the factors you mentioned are not expected to dramatically change.

That being said, it would be interesting to analyze the effect of miners
joining during the HTLC duration. Intuitively, this shouldn?t affect the
results, as those new miners have the same incentive to wait for the
higher-paying tx.


>
> It also strikes me that, in a world with RBF and CPFP, the same endpoint
> (i.e. miners earn the entire fund of the HTLC) is achieved by existing
> HTLCs, without the additional branch and script opcodes needed by MAD-HTLC.
> For example, if an HTLC is confirmed but the hashlock-claiming transaction
> is not being confirmed (because miners are holding it up because Bob is
> offering a much higher fee in the future for the timelock-claiming
> transaction), then Alice can, regardless of the reason why it is not being
> confirmed, bump up the fee with RBF or CPFP.
>
> If the fee bump offered by Alice is sufficiently large, then miners will
> start re-preferring the Alice hashlock transaction.
> To counter this, Bob has to bid up its version higher.
>
> As the timeout approaches, Alice can bump up its fee until it is just 1
> satoshi short of the total fund.
> It is rational for Alice to do so since at timeout, it can expect to lose
> the entire fund.
> In order for Bob to win, it has to beat that fee, at which point it equals
> or exceeds the total fund, and miners get the total fund (or more).
>
> Knowing this end-point, rational Bob will not even begin this game.
>
> I think this research considers these two endpoints to be distinct:
>
> * Bob misbehaves and the entire fund is punished by miners, leaving miners
> with the fund and Alice and Bob without money (MAD-HTLC).
> * Bob misbehaves, Alice counters, and the ensuing fee war leads to fees
> approaching the fund value, leaving miners with the fund and Alice and Bob
> without money (standard HTLC).
>
> But in practice I think both endpoints are essentially equivalent.
>

These are not the same scenario, since in HTLC there is a race between
Alice and Bob. Alice might not wish to pay the full HTLC amount once she
sees Bob is trying to cheat. She could wait until close to the timeout so
as to reduce the time Bob can respond. Of course Bob would do the same. So
this is an actual race, and Bob takes no risk since his payment is all from
the HTLC amount. Mutual destruction is only assured under certain
assumptions in HTLC. MAD-HTLC achieves security without relying on such
assumptions.


>
> --
>
> What MAD-HTLC can do would be to make different claims:
>
> * Inputs:
>   * Bob 1 BTC - HTLC amount
>   * Bob 1 BTC - Bob fidelity bond
>
> * Cases:
>   * Alice reveals hashlock at any time:
>     * 1 BTC goes to Alice
>     * 1 BTC goes to Bob (fidelity bond refund)
>   * Bob reveals bob-hashlock after time L:
>     * 2 BTC goes to Bob (HTLC refund + fidelity bond refund)
>   * Bob cheated, anybody reveals both hashlock and bob-hashlock:
>     * 2 BTC goes to miner
>
> This is an actual improvement over HTLC: Bob misbehavior leads to loss of
> the fidelity bond.
> The above cases can be assured by requiring both Alice and Bob to sign in
> the alice-hashlock branch, so that the splitting of the fund is enforced,
> and SegWit signing so that the dependent transaction is signed before the
> HTLC-funding transaction is.
> It can also be implemented with `OP_CHECKTEMPLATEVERIFY`.


The cases you present are exactly how MAD-HTLC works. It comprises two
contracts (UTXOs):
* Deposit (holding the intended HTLC tokens), with three redeem paths:
    - Alice (signature), with preimage "A", no timeout
    - Bob (signature), with preimage "B", timeout T
    - Any entity (miner), with both preimages "A" and "B", no timeout
* Collateral (the fidelity bond, doesn't have to be of the same amount)
    - Bob (signature), no preimage, timeout T
    - Any entity (miner), with both preimages "A" and "B", timeout T

Only Bob initially knows preimage "B", and is required to reveal it if he
wishes to get the Deposit tokens.

Consider first the case where Alice publishes preimage "A": Bob can safely
publish preimage "B" and get both the Deposit and Collateral tokens after
the timeout.
Now, consider the case where Alice does not publish preimage "A": If Bob
publishes preimage "B" he gets nothing (and so does Alice - this is the
mutual assured destruction), and if he doesn't, he gets the Collateral
tokens.

Best,
Ittay
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200623/351a3679/attachment.html>

From stanga at gmail.com  Tue Jun 23 13:18:35 2020
From: stanga at gmail.com (Stanga)
Date: Tue, 23 Jun 2020 16:18:35 +0300
Subject: [bitcoin-dev] MAD-HTLC
In-Reply-To: <CABT1wWknczx62uCpJPWku-KeYuaFvJHrvOS74YzqfoVe5x=edg@mail.gmail.com>
References: <CABT1wW=X35HRVGuP-BHUhDrkBEw27+-iDkNnHWjRU-1mRkn0JQ@mail.gmail.com>
 <CABT1wW=KWtoo6zHs8=yUQ7vAYcFSdAzdpDJ9yfw6sJrLd6dN5A@mail.gmail.com>
 <ahTHfoyyTpBrMiKdJWMn9Qa8CMCEd1-y8OXPSjsDmttTOVC3zGuDoSHkm_oOe5mBYgIAY7jOPocQhLW29n544xFsqVyq51NFApvaFYYSvFY=@protonmail.com>
 <CABT1wWknczx62uCpJPWku-KeYuaFvJHrvOS74YzqfoVe5x=edg@mail.gmail.com>
Message-ID: <CABT1wWmm=rx1MkFeNhGeEgdu7XpBXYeq_PWaZFfBOA7MRSKezw@mail.gmail.com>

Of course the order at the end should have been switched:

Consider first the case where Alice *does not* publish preimage "A": Bob
can safely publish preimage "B" and get both the Deposit and Collateral
tokens after the timeout.
Now, consider the case where Alice *publishes* preimage "A": If Bob
publishes preimage "B" he gets nothing (and so does Alice - this is the
mutual assured destruction), and if he doesn't, he gets the Collateral
tokens.


On Tue, Jun 23, 2020 at 3:47 PM Stanga <stanga at gmail.com> wrote:

> Hi ZmnSCPxj,
>
> Thank you for taking the time to respond, these are very good points.
> Responses inline.
>
> On Tue, Jun 23, 2020 at 12:48 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>
>> Good morning Itay, Ittay, and Matan,
>>
>> I believe an unstated assumption in Bitcoin is that miners are
>> short-sighted.
>>
>> The reasoning for this assumption is:
>>
>> * Deployment of new mining hardware controlled by others may occur at any
>> time you do not control.
>>   * Thus, any transactions you leave on the table are potentially taken
>> by somebody else and not by you.
>>   * Sudden changes in hashpower distribution may reduce your expected
>> future earnings, so any future theoretical earnings should be discounted
>> (*in addition to* expected return-on-investment on getting money you can
>> invest *now*).
>>
>
> Our analysis assumes constant difficulty, i.e., no significant changes of
> the miners set. Indeed, hash-rate changes typically occur at a much larger
> granularity than your average HTLC timeout. For instance, we noticed plenty
> of lightning nodes use timeouts of a day. So, we do not consider
> optimization at infinity, just a day ahead, and within this time frame all
> the factors you mentioned are not expected to dramatically change.
>
> That being said, it would be interesting to analyze the effect of miners
> joining during the HTLC duration. Intuitively, this shouldn?t affect the
> results, as those new miners have the same incentive to wait for the
> higher-paying tx.
>
>
>>
>> It also strikes me that, in a world with RBF and CPFP, the same endpoint
>> (i.e. miners earn the entire fund of the HTLC) is achieved by existing
>> HTLCs, without the additional branch and script opcodes needed by MAD-HTLC.
>> For example, if an HTLC is confirmed but the hashlock-claiming
>> transaction is not being confirmed (because miners are holding it up
>> because Bob is offering a much higher fee in the future for the
>> timelock-claiming transaction), then Alice can, regardless of the reason
>> why it is not being confirmed, bump up the fee with RBF or CPFP.
>>
>> If the fee bump offered by Alice is sufficiently large, then miners will
>> start re-preferring the Alice hashlock transaction.
>> To counter this, Bob has to bid up its version higher.
>>
>> As the timeout approaches, Alice can bump up its fee until it is just 1
>> satoshi short of the total fund.
>> It is rational for Alice to do so since at timeout, it can expect to lose
>> the entire fund.
>> In order for Bob to win, it has to beat that fee, at which point it
>> equals or exceeds the total fund, and miners get the total fund (or more).
>>
>> Knowing this end-point, rational Bob will not even begin this game.
>>
>> I think this research considers these two endpoints to be distinct:
>>
>> * Bob misbehaves and the entire fund is punished by miners, leaving
>> miners with the fund and Alice and Bob without money (MAD-HTLC).
>> * Bob misbehaves, Alice counters, and the ensuing fee war leads to fees
>> approaching the fund value, leaving miners with the fund and Alice and Bob
>> without money (standard HTLC).
>>
>> But in practice I think both endpoints are essentially equivalent.
>>
>
> These are not the same scenario, since in HTLC there is a race between
> Alice and Bob. Alice might not wish to pay the full HTLC amount once she
> sees Bob is trying to cheat. She could wait until close to the timeout so
> as to reduce the time Bob can respond. Of course Bob would do the same. So
> this is an actual race, and Bob takes no risk since his payment is all from
> the HTLC amount. Mutual destruction is only assured under certain
> assumptions in HTLC. MAD-HTLC achieves security without relying on such
> assumptions.
>
>
>>
>> --
>>
>> What MAD-HTLC can do would be to make different claims:
>>
>> * Inputs:
>>   * Bob 1 BTC - HTLC amount
>>   * Bob 1 BTC - Bob fidelity bond
>>
>> * Cases:
>>   * Alice reveals hashlock at any time:
>>     * 1 BTC goes to Alice
>>     * 1 BTC goes to Bob (fidelity bond refund)
>>   * Bob reveals bob-hashlock after time L:
>>     * 2 BTC goes to Bob (HTLC refund + fidelity bond refund)
>>   * Bob cheated, anybody reveals both hashlock and bob-hashlock:
>>     * 2 BTC goes to miner
>>
>> This is an actual improvement over HTLC: Bob misbehavior leads to loss of
>> the fidelity bond.
>> The above cases can be assured by requiring both Alice and Bob to sign in
>> the alice-hashlock branch, so that the splitting of the fund is enforced,
>> and SegWit signing so that the dependent transaction is signed before the
>> HTLC-funding transaction is.
>> It can also be implemented with `OP_CHECKTEMPLATEVERIFY`.
>
>
> The cases you present are exactly how MAD-HTLC works. It comprises two
> contracts (UTXOs):
> * Deposit (holding the intended HTLC tokens), with three redeem paths:
>     - Alice (signature), with preimage "A", no timeout
>     - Bob (signature), with preimage "B", timeout T
>     - Any entity (miner), with both preimages "A" and "B", no timeout
> * Collateral (the fidelity bond, doesn't have to be of the same amount)
>     - Bob (signature), no preimage, timeout T
>     - Any entity (miner), with both preimages "A" and "B", timeout T
>
> Only Bob initially knows preimage "B", and is required to reveal it if he
> wishes to get the Deposit tokens.
>
> Consider first the case where Alice publishes preimage "A": Bob can safely
> publish preimage "B" and get both the Deposit and Collateral tokens after
> the timeout.
> Now, consider the case where Alice does not publish preimage "A": If Bob
> publishes preimage "B" he gets nothing (and so does Alice - this is the
> mutual assured destruction), and if he doesn't, he gets the Collateral
> tokens.
>
> Best,
> Ittay
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200623/0f0934c7/attachment-0001.html>

From lf-lists at mattcorallo.com  Wed Jun 24 08:32:52 2020
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Wed, 24 Jun 2020 01:32:52 -0700
Subject: [bitcoin-dev] [Lightning-dev] RBF Pinning with Counterparties
	and Competing Interest
In-Reply-To: <CACdvm3O3UmZcYYGaY2x23MYY=3saPFkgQtaDELd=kY93SRLLaA@mail.gmail.com>
References: <CACdvm3O3UmZcYYGaY2x23MYY=3saPFkgQtaDELd=kY93SRLLaA@mail.gmail.com>
Message-ID: <034FCF40-B7D3-46F8-8746-98083CB0461E@mattcorallo.com>

Given transaction relay delays and a network topology that is rather transparent if you look closely enough, I think this is very real and very practical (double-digit % success rate, at least, with some trial and error probably 50+). That said, we all also probably know most of the people who know enough to go from zero to doing this practically next week. As for motivated folks who have lots of time to read code and dig, this seems like something worth fixing in the medium term.

Your observation is what?s largely led me to conclude there isn?t a lot we can do here without a lot of creativity and fundamental rethinking of our approach. One thing I keep harping on is maybe saving the blind-CPFP approach with a) eltoo, and b) some kind of magic transaction relay metadata that allows you to specify ?this spends at least one output on any transaction that spends output X? so that nodes can always apply it properly. But maybe that?s a pipedream of complexity. I know Antoine has other thoughts.

Matt

> On Jun 22, 2020, at 04:04, Bastien TEINTURIER via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> ?
> Hey ZmnSCPxj,
> 
> I agree that in theory this looks possible, but doing it in practice with accurate control
> of what parts of the network get what tx feels impractical to me (but maybe I'm wrong!).
> 
> It feels to me that an attacker who would be able to do this would break *any* off-chain
> construction that relies on absolute timeouts, so I'm hoping this is insanely hard to
> achieve without cooperation from a miners subset. Let me know if I'm too optimistic on
> this!
> 
> Cheers,
> Bastien
> 
>> Le lun. 22 juin 2020 ? 10:15, ZmnSCPxj <ZmnSCPxj at protonmail.com> a ?crit :
>> Good morning Bastien,
>> 
>> > Thanks for the detailed write-up on how it affects incentives and centralization,
>> > these are good points. I need to spend more time thinking about them.
>> >
>> > > This is one reason I suggested using independent pay-to-preimage
>> > > transactions[1]
>> >
>> > While this works as a technical solution, I think it has some incentives issues too.
>> > In this attack, I believe the miners that hide the preimage tx in their mempool have
>> > to be accomplice with the attacker, otherwise they would share that tx with some of
>> > their peers, and some non-miner nodes would get that preimage tx and be able to
>> > gossip them off-chain (and even relay them to other mempools).
>> 
>> I believe this is technically possible with current mempool rules, without miners cooperating with the attacker.
>> 
>> Basically, the attacker releases two transactions with near-equal fees, so that neither can RBF the other.
>> It releases the preimage tx near miners, and the timelock tx near non-miners.
>> 
>> Nodes at the boundaries between those that receive the preimage tx and the timelock tx will receive both.
>> However, they will receive one or the other first.
>> Which one they receive first will be what they keep, and they will reject the other (and *not* propagate the other), because the difference in fees is not enough to get past the RBF rules (which requires not just a feerate increase, but also an increase in absolute fee, of at least the minimum relay feerate times transaction size).
>> 
>> Because they reject the other tx, they do not propagate the other tx, so the boundary between the two txes is inviolate, neither can get past that boundary, this occurs even if everyone is running 100% unmodified Bitcoin Core code.
>> 
>> I am not a mempool expert and my understanding may be incorrect.
>> 
>> Regards,
>> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200624/7a0b11e4/attachment.html>

From ZmnSCPxj at protonmail.com  Thu Jun 25 01:38:17 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 25 Jun 2020 01:38:17 +0000
Subject: [bitcoin-dev] MAD-HTLC
In-Reply-To: <CABT1wWmm=rx1MkFeNhGeEgdu7XpBXYeq_PWaZFfBOA7MRSKezw@mail.gmail.com>
References: <CABT1wW=X35HRVGuP-BHUhDrkBEw27+-iDkNnHWjRU-1mRkn0JQ@mail.gmail.com>
 <CABT1wW=KWtoo6zHs8=yUQ7vAYcFSdAzdpDJ9yfw6sJrLd6dN5A@mail.gmail.com>
 <ahTHfoyyTpBrMiKdJWMn9Qa8CMCEd1-y8OXPSjsDmttTOVC3zGuDoSHkm_oOe5mBYgIAY7jOPocQhLW29n544xFsqVyq51NFApvaFYYSvFY=@protonmail.com>
 <CABT1wWknczx62uCpJPWku-KeYuaFvJHrvOS74YzqfoVe5x=edg@mail.gmail.com>
 <CABT1wWmm=rx1MkFeNhGeEgdu7XpBXYeq_PWaZFfBOA7MRSKezw@mail.gmail.com>
Message-ID: <xFJlIP6z6qhjxDAP8xUBnqPF-Wulexjr9izry8mIWCQzQdNrULtX_TwWGfuHo7VNfTdXZNmy05QHxMF3iJbjZm_-jFO_WRJjSQR0N_Dreic=@protonmail.com>

Good morning Stanga et al,


> > Hi ZmnSCPxj,?
> >
> > Thank you for taking the time to respond, these are very good points. Responses inline.
> >
> > On Tue, Jun 23, 2020 at 12:48 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
> >
> > > Good morning Itay, Ittay, and Matan,
> > >
> > > I believe an unstated assumption in Bitcoin is that miners are short-sighted.
> > >
> > > The reasoning for this assumption is:
> > >
> > > * Deployment of new mining hardware controlled by others may occur at any time you do not control.
> > > ? * Thus, any transactions you leave on the table are potentially taken by somebody else and not by you.
> > > ? * Sudden changes in hashpower distribution may reduce your expected future earnings, so any future theoretical earnings should be discounted (*in addition to* expected return-on-investment on getting money you can invest *now*).
> >
> > Our analysis assumes constant difficulty, i.e., no significant changes of the miners set. Indeed, hash-rate changes typically occur at a much larger granularity than your average HTLC timeout. For instance, we noticed plenty of lightning nodes use timeouts of a day. So, we do not consider optimization at infinity, just a day ahead, and within this time frame all the factors you mentioned are not expected to dramatically change.?
> >
> > That being said, it would be interesting to analyze the effect of miners joining during the HTLC duration. Intuitively, this shouldn?t affect the results, as those new miners have the same incentive to wait for the higher-paying tx.

We already know that hashrate tends to trend upwards, and that we do not expect hashrate to fall except for occasional transients.

The expectation is not that new miners have different incentives.
Instead, the expectation is that current miners discount future possible gains because in the future, they expect to have less hashrate share than right now.

The only trustless way for Bob to bribe miners into deferring Alice tx is to attach the bribe to the future confirmation of the Bob tx, thus Bob is offering future-coins, not present-coins like Alice can offer, and the fact that miners expect an overall uptrend in total hashrate (leading to an overall downtrend in their hashrate share) means that miners discount the Bob offered future-coins.
The discounting is proportional to the time delay involved, as a larger delay implies greater reduction in hashrate share.

This discounting is, again, *in addition to* natural discounting a.k.a. "I will gladly pay you Thursday for a hamburger today", the hamburger seller will want some pretty stiff assurances plus a bigger payment on Thursday for giving you a hamburger today, due to expected returns on investment.


> > ?
> >
> > > It also strikes me that, in a world with RBF and CPFP, the same endpoint (i.e. miners earn the entire fund of the HTLC) is achieved by existing HTLCs, without the additional branch and script opcodes needed by MAD-HTLC.
> > > For example, if an HTLC is confirmed but the hashlock-claiming transaction is not being confirmed (because miners are holding it up because Bob is offering a much higher fee in the future for the timelock-claiming transaction), then Alice can, regardless of the reason why it is not being confirmed, bump up the fee with RBF or CPFP.
> > >
> > > If the fee bump offered by Alice is sufficiently large, then miners will start re-preferring the Alice hashlock transaction.
> > > To counter this, Bob has to bid up its version higher.
> > >
> > > As the timeout approaches, Alice can bump up its fee until it is just 1 satoshi short of the total fund.
> > > It is rational for Alice to do so since at timeout, it can expect to lose the entire fund.
> > > In order for Bob to win, it has to beat that fee, at which point it equals or exceeds the total fund, and miners get the total fund (or more).
> > >
> > > Knowing this end-point, rational Bob will not even begin this game.
> > >
> > > I think this research considers these two endpoints to be distinct:
> > >
> > > * Bob misbehaves and the entire fund is punished by miners, leaving miners with the fund and Alice and Bob without money (MAD-HTLC).
> > > * Bob misbehaves, Alice counters, and the ensuing fee war leads to fees approaching the fund value, leaving miners with the fund and Alice and Bob without money (standard HTLC).
> > >
> > > But in practice I think both endpoints are essentially equivalent.
> >
> > These are not the same scenario, since in HTLC there is a race between Alice and Bob. Alice might not wish to pay the full HTLC amount once she sees Bob is trying to cheat. She could wait until close to the timeout so as to reduce the time Bob can respond. Of course Bob would do the same. So this is an actual race, and Bob takes no risk since his payment is all from the HTLC amount. Mutual destruction is only assured under certain assumptions in HTLC. MAD-HTLC achieves security without relying on such assumptions.?

Alice already knows that a rational Bob (who it might never interact with again in the future) will take the funds at the locktime L.
Thus, Alice can offer, at time L - 1, the entire fund, minus 1 satoshi, to miners.
Alice getting 1 satoshi versus 0 satoshi is a no-brainer for Alice.
Bob can only  beat this offer by offering the entire fund, at which point Bob earns nothing and it performed an attack for no benefit.

I and some number of Lightning devs consider this to be sufficient disincentive to Bob not attacking in the first place.


> > ?
> >
> > > --
> > >
> > > What MAD-HTLC can do would be to make different claims:
> > >
> > > * Inputs:
> > > ? * Bob 1 BTC - HTLC amount
> > > ? * Bob 1 BTC - Bob fidelity bond
> > >
> > > * Cases:
> > > ? * Alice reveals hashlock at any time:
> > > ? ? * 1 BTC goes to Alice
> > > ? ? * 1 BTC goes to Bob (fidelity bond refund)
> > > ? * Bob reveals bob-hashlock after time L:
> > > ? ? * 2 BTC goes to Bob (HTLC refund + fidelity bond refund)
> > > ? * Bob cheated, anybody reveals both hashlock and bob-hashlock:
> > > ? ? * 2 BTC goes to miner
> > >
> > > This is an actual improvement over HTLC: Bob misbehavior leads to loss of the fidelity bond.
> > > The above cases can be assured by requiring both Alice and Bob to sign in the alice-hashlock branch, so that the splitting of the fund is enforced, and SegWit signing so that the dependent transaction is signed before the HTLC-funding transaction is.
> > > It can also be implemented with `OP_CHECKTEMPLATEVERIFY`.
> >
> > The cases you present are exactly how MAD-HTLC works. It comprises two contracts (UTXOs):
> > * Deposit (holding the intended HTLC tokens), with three redeem paths:
> > ? ? - Alice (signature), with preimage "A", no timeout
> > ? ? - Bob (signature), with preimage "B", timeout T
> > ? ? - Any entity (miner), with both preimages "A" and "B", no timeout
> > * Collateral (the fidelity bond, doesn't have to be of the same amount)
> > ? ? - Bob (signature), no preimage, timeout T
> > ? ? - Any entity (miner), with both preimages "A" and "B", timeout T
> >
> > Only Bob initially knows preimage "B", and is required to reveal it if he wishes to get the Deposit tokens.
> >
> > Consider first the case where Alice publishes preimage "A": Bob can safely publish preimage "B" and get both the Deposit and Collateral tokens after the timeout.
> > Now, consider the case where Alice does not publish preimage "A": If Bob publishes preimage "B" he gets nothing (and so does Alice - this is the mutual assured destruction), and if he doesn't, he gets the Collateral tokens.

Thank you for the clarification.

Regards,
ZmnSCPxj


From ZmnSCPxj at protonmail.com  Thu Jun 25 04:04:09 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 25 Jun 2020 04:04:09 +0000
Subject: [bitcoin-dev] MAD-HTLC
In-Reply-To: <CAGXD5f0PXDMbVMiUNnqK-HGwB1yDEmBQgtLbQU4xcad3pDaGmw@mail.gmail.com>
References: <CABT1wW=X35HRVGuP-BHUhDrkBEw27+-iDkNnHWjRU-1mRkn0JQ@mail.gmail.com>
 <CABT1wW=KWtoo6zHs8=yUQ7vAYcFSdAzdpDJ9yfw6sJrLd6dN5A@mail.gmail.com>
 <ahTHfoyyTpBrMiKdJWMn9Qa8CMCEd1-y8OXPSjsDmttTOVC3zGuDoSHkm_oOe5mBYgIAY7jOPocQhLW29n544xFsqVyq51NFApvaFYYSvFY=@protonmail.com>
 <CABT1wWknczx62uCpJPWku-KeYuaFvJHrvOS74YzqfoVe5x=edg@mail.gmail.com>
 <CABT1wWmm=rx1MkFeNhGeEgdu7XpBXYeq_PWaZFfBOA7MRSKezw@mail.gmail.com>
 <xFJlIP6z6qhjxDAP8xUBnqPF-Wulexjr9izry8mIWCQzQdNrULtX_TwWGfuHo7VNfTdXZNmy05QHxMF3iJbjZm_-jFO_WRJjSQR0N_Dreic=@protonmail.com>
 <CAGXD5f0PXDMbVMiUNnqK-HGwB1yDEmBQgtLbQU4xcad3pDaGmw@mail.gmail.com>
Message-ID: <XcV-a5p3nVenGEXgv4CO2X6lh4UXi18PM4-iKnfY3_SSoi5xCeCp84wsS1yHdHMVvDftNX5TrOnhUfvei371OQQHIVAJmcF-UQ_EAAZONyE=@protonmail.com>

Good morning Nadav,

> > I and some number of Lightning devs consider this to be sufficient disincentive to Bob not attacking in the first place.
>
> An additional disincentive could be introduced in the form of bribery proofs for failed attempts.
>
> If we assume that "honest" users of the LN protocol won't reveal their timelocked transactions before reaching the timelock expiry (they shouldn't anyway because standard full node implementations won't relay them), we can prove that Bob attempted bribery and failed to an outside observer by showing Bob's signed timelocked transaction, spending an output that was in reality spent by a different transaction prior to the locktime expiry, which should not be possible if Bob had waited.


Unfortunately this could be subject to an inversion of this attack.

Alice can wait for the timelock to expire, then bribe miners to prevent confirmation of the Bob timelocked transaction, getting the Alice hashlocked transaction confirmed.

Now of course you do mention "prior to the locktime expiry" but there is now risk at around locktime.

Particularly, "natural" orphaned blocks and short-term chainsplits can exist.
Bob might see that the locktime has arrived and broadcast the signed timelocked transaction, then Alice sees the locktime has not yet arrived (due to short-term chainsplits/propagation delays) and broadcast the signed hashlocked transaction, then in the end the Alice side of the short-term chainsplit is what solidifies into reality due to random chance on which miner wins which block.
Then Bob can now be accused of bribery, even though it acted innocently; it broadcasted the timelock branch due to a natural chainsplit but Alice hashlocked branch got confirmed.

Additional complications can be added on top to help mitigate this edge case but more complex == worse in general.
For example it could "prior to locktime expiry" can ignore a few blocks before the actual timelock, but this might allow Bob to mount the attack by initiating its bribery behavior earlier by those few blocks.

Finally, serious attackers would just use new pseudonyms, the important thing is to make pseudonyms valuable and costly to lose, so it is considered sufficient that LN nodes need to have some commitment to the LN in the form of actual channels (which are valuable, potentially money-earning constructs, and costly to set up).

Other HTLC-using systems, such as the "SwapMarket" being proposed by Chris Belcher, could use similar disincentivizing; I know Chris is planning a fidelity bond system for SwapMarket makers, for example, which would mimic the properties of LN channels (costly to set up, money-earning).

Regards,
ZmnSCPxj

From nadav at shesek.info  Thu Jun 25 03:26:41 2020
From: nadav at shesek.info (Nadav Ivgi)
Date: Thu, 25 Jun 2020 06:26:41 +0300
Subject: [bitcoin-dev] MAD-HTLC
In-Reply-To: <xFJlIP6z6qhjxDAP8xUBnqPF-Wulexjr9izry8mIWCQzQdNrULtX_TwWGfuHo7VNfTdXZNmy05QHxMF3iJbjZm_-jFO_WRJjSQR0N_Dreic=@protonmail.com>
References: <CABT1wW=X35HRVGuP-BHUhDrkBEw27+-iDkNnHWjRU-1mRkn0JQ@mail.gmail.com>
 <CABT1wW=KWtoo6zHs8=yUQ7vAYcFSdAzdpDJ9yfw6sJrLd6dN5A@mail.gmail.com>
 <ahTHfoyyTpBrMiKdJWMn9Qa8CMCEd1-y8OXPSjsDmttTOVC3zGuDoSHkm_oOe5mBYgIAY7jOPocQhLW29n544xFsqVyq51NFApvaFYYSvFY=@protonmail.com>
 <CABT1wWknczx62uCpJPWku-KeYuaFvJHrvOS74YzqfoVe5x=edg@mail.gmail.com>
 <CABT1wWmm=rx1MkFeNhGeEgdu7XpBXYeq_PWaZFfBOA7MRSKezw@mail.gmail.com>
 <xFJlIP6z6qhjxDAP8xUBnqPF-Wulexjr9izry8mIWCQzQdNrULtX_TwWGfuHo7VNfTdXZNmy05QHxMF3iJbjZm_-jFO_WRJjSQR0N_Dreic=@protonmail.com>
Message-ID: <CAGXD5f0PXDMbVMiUNnqK-HGwB1yDEmBQgtLbQU4xcad3pDaGmw@mail.gmail.com>

> I and some number of Lightning devs consider this to be sufficient
disincentive to Bob not attacking in the first place.

An additional disincentive could be introduced in the form of bribery
proofs for failed attempts.

If we assume that "honest" users of the LN protocol won't reveal their
timelocked transactions before reaching the timelock expiry (they shouldn't
anyway because standard full node implementations won't relay them), we can
prove that Bob attempted bribery and failed to an outside observer by
showing Bob's signed timelocked transaction, spending an output that was in
reality spent by a different transaction prior to the locktime expiry,
which should not be possible if Bob had waited.

These proofs would be gossiped, and lightning network participants could
choose not to peer with Bob when they see them. This might require some
sort of a scoring/reputation scheme that makes it harder for Bob to attack
with new throw-away identities to be effective. (i.e. limiting your
exposure to peers to some BTC amount based on their historical public
channels records, using fidelity bonds, etc.)

Bob could still send these bribery transactions privately to selected
miners, but not making them public would greatly reduce the participating
miners' confidence that there is enough participating hashpower for the
attack to be profitable.

Nadav

On Thu, Jun 25, 2020 at 4:38 AM ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Good morning Stanga et al,
>
>
> > > Hi ZmnSCPxj,
> > >
> > > Thank you for taking the time to respond, these are very good points.
> Responses inline.
> > >
> > > On Tue, Jun 23, 2020 at 12:48 PM ZmnSCPxj <ZmnSCPxj at protonmail.com>
> wrote:
> > >
> > > > Good morning Itay, Ittay, and Matan,
> > > >
> > > > I believe an unstated assumption in Bitcoin is that miners are
> short-sighted.
> > > >
> > > > The reasoning for this assumption is:
> > > >
> > > > * Deployment of new mining hardware controlled by others may occur
> at any time you do not control.
> > > >   * Thus, any transactions you leave on the table are potentially
> taken by somebody else and not by you.
> > > >   * Sudden changes in hashpower distribution may reduce your
> expected future earnings, so any future theoretical earnings should be
> discounted (*in addition to* expected return-on-investment on getting money
> you can invest *now*).
> > >
> > > Our analysis assumes constant difficulty, i.e., no significant changes
> of the miners set. Indeed, hash-rate changes typically occur at a much
> larger granularity than your average HTLC timeout. For instance, we noticed
> plenty of lightning nodes use timeouts of a day. So, we do not consider
> optimization at infinity, just a day ahead, and within this time frame all
> the factors you mentioned are not expected to dramatically change.
> > >
> > > That being said, it would be interesting to analyze the effect of
> miners joining during the HTLC duration. Intuitively, this shouldn?t affect
> the results, as those new miners have the same incentive to wait for the
> higher-paying tx.
>
> We already know that hashrate tends to trend upwards, and that we do not
> expect hashrate to fall except for occasional transients.
>
> The expectation is not that new miners have different incentives.
> Instead, the expectation is that current miners discount future possible
> gains because in the future, they expect to have less hashrate share than
> right now.
>
> The only trustless way for Bob to bribe miners into deferring Alice tx is
> to attach the bribe to the future confirmation of the Bob tx, thus Bob is
> offering future-coins, not present-coins like Alice can offer, and the fact
> that miners expect an overall uptrend in total hashrate (leading to an
> overall downtrend in their hashrate share) means that miners discount the
> Bob offered future-coins.
> The discounting is proportional to the time delay involved, as a larger
> delay implies greater reduction in hashrate share.
>
> This discounting is, again, *in addition to* natural discounting a.k.a. "I
> will gladly pay you Thursday for a hamburger today", the hamburger seller
> will want some pretty stiff assurances plus a bigger payment on Thursday
> for giving you a hamburger today, due to expected returns on investment.
>
>
> > >
> > >
> > > > It also strikes me that, in a world with RBF and CPFP, the same
> endpoint (i.e. miners earn the entire fund of the HTLC) is achieved by
> existing HTLCs, without the additional branch and script opcodes needed by
> MAD-HTLC.
> > > > For example, if an HTLC is confirmed but the hashlock-claiming
> transaction is not being confirmed (because miners are holding it up
> because Bob is offering a much higher fee in the future for the
> timelock-claiming transaction), then Alice can, regardless of the reason
> why it is not being confirmed, bump up the fee with RBF or CPFP.
> > > >
> > > > If the fee bump offered by Alice is sufficiently large, then miners
> will start re-preferring the Alice hashlock transaction.
> > > > To counter this, Bob has to bid up its version higher.
> > > >
> > > > As the timeout approaches, Alice can bump up its fee until it is
> just 1 satoshi short of the total fund.
> > > > It is rational for Alice to do so since at timeout, it can expect to
> lose the entire fund.
> > > > In order for Bob to win, it has to beat that fee, at which point it
> equals or exceeds the total fund, and miners get the total fund (or more).
> > > >
> > > > Knowing this end-point, rational Bob will not even begin this game.
> > > >
> > > > I think this research considers these two endpoints to be distinct:
> > > >
> > > > * Bob misbehaves and the entire fund is punished by miners, leaving
> miners with the fund and Alice and Bob without money (MAD-HTLC).
> > > > * Bob misbehaves, Alice counters, and the ensuing fee war leads to
> fees approaching the fund value, leaving miners with the fund and Alice and
> Bob without money (standard HTLC).
> > > >
> > > > But in practice I think both endpoints are essentially equivalent.
> > >
> > > These are not the same scenario, since in HTLC there is a race between
> Alice and Bob. Alice might not wish to pay the full HTLC amount once she
> sees Bob is trying to cheat. She could wait until close to the timeout so
> as to reduce the time Bob can respond. Of course Bob would do the same. So
> this is an actual race, and Bob takes no risk since his payment is all from
> the HTLC amount. Mutual destruction is only assured under certain
> assumptions in HTLC. MAD-HTLC achieves security without relying on such
> assumptions.
>
> Alice already knows that a rational Bob (who it might never interact with
> again in the future) will take the funds at the locktime L.
> Thus, Alice can offer, at time L - 1, the entire fund, minus 1 satoshi, to
> miners.
> Alice getting 1 satoshi versus 0 satoshi is a no-brainer for Alice.
> Bob can only  beat this offer by offering the entire fund, at which point
> Bob earns nothing and it performed an attack for no benefit.
>
> I and some number of Lightning devs consider this to be sufficient
> disincentive to Bob not attacking in the first place.
>
>
> > >
> > >
> > > > --
> > > >
> > > > What MAD-HTLC can do would be to make different claims:
> > > >
> > > > * Inputs:
> > > >   * Bob 1 BTC - HTLC amount
> > > >   * Bob 1 BTC - Bob fidelity bond
> > > >
> > > > * Cases:
> > > >   * Alice reveals hashlock at any time:
> > > >     * 1 BTC goes to Alice
> > > >     * 1 BTC goes to Bob (fidelity bond refund)
> > > >   * Bob reveals bob-hashlock after time L:
> > > >     * 2 BTC goes to Bob (HTLC refund + fidelity bond refund)
> > > >   * Bob cheated, anybody reveals both hashlock and bob-hashlock:
> > > >     * 2 BTC goes to miner
> > > >
> > > > This is an actual improvement over HTLC: Bob misbehavior leads to
> loss of the fidelity bond.
> > > > The above cases can be assured by requiring both Alice and Bob to
> sign in the alice-hashlock branch, so that the splitting of the fund is
> enforced, and SegWit signing so that the dependent transaction is signed
> before the HTLC-funding transaction is.
> > > > It can also be implemented with `OP_CHECKTEMPLATEVERIFY`.
> > >
> > > The cases you present are exactly how MAD-HTLC works. It comprises two
> contracts (UTXOs):
> > > * Deposit (holding the intended HTLC tokens), with three redeem paths:
> > >     - Alice (signature), with preimage "A", no timeout
> > >     - Bob (signature), with preimage "B", timeout T
> > >     - Any entity (miner), with both preimages "A" and "B", no timeout
> > > * Collateral (the fidelity bond, doesn't have to be of the same amount)
> > >     - Bob (signature), no preimage, timeout T
> > >     - Any entity (miner), with both preimages "A" and "B", timeout T
> > >
> > > Only Bob initially knows preimage "B", and is required to reveal it if
> he wishes to get the Deposit tokens.
> > >
> > > Consider first the case where Alice publishes preimage "A": Bob can
> safely publish preimage "B" and get both the Deposit and Collateral tokens
> after the timeout.
> > > Now, consider the case where Alice does not publish preimage "A": If
> Bob publishes preimage "B" he gets nothing (and so does Alice - this is the
> mutual assured destruction), and if he doesn't, he gets the Collateral
> tokens.
>
> Thank you for the clarification.
>
> Regards,
> ZmnSCPxj
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200625/86ee66c8/attachment-0001.html>

From nadav at shesek.info  Thu Jun 25 04:35:51 2020
From: nadav at shesek.info (Nadav Ivgi)
Date: Thu, 25 Jun 2020 07:35:51 +0300
Subject: [bitcoin-dev] MAD-HTLC
In-Reply-To: <XcV-a5p3nVenGEXgv4CO2X6lh4UXi18PM4-iKnfY3_SSoi5xCeCp84wsS1yHdHMVvDftNX5TrOnhUfvei371OQQHIVAJmcF-UQ_EAAZONyE=@protonmail.com>
References: <CABT1wW=X35HRVGuP-BHUhDrkBEw27+-iDkNnHWjRU-1mRkn0JQ@mail.gmail.com>
 <CABT1wW=KWtoo6zHs8=yUQ7vAYcFSdAzdpDJ9yfw6sJrLd6dN5A@mail.gmail.com>
 <ahTHfoyyTpBrMiKdJWMn9Qa8CMCEd1-y8OXPSjsDmttTOVC3zGuDoSHkm_oOe5mBYgIAY7jOPocQhLW29n544xFsqVyq51NFApvaFYYSvFY=@protonmail.com>
 <CABT1wWknczx62uCpJPWku-KeYuaFvJHrvOS74YzqfoVe5x=edg@mail.gmail.com>
 <CABT1wWmm=rx1MkFeNhGeEgdu7XpBXYeq_PWaZFfBOA7MRSKezw@mail.gmail.com>
 <xFJlIP6z6qhjxDAP8xUBnqPF-Wulexjr9izry8mIWCQzQdNrULtX_TwWGfuHo7VNfTdXZNmy05QHxMF3iJbjZm_-jFO_WRJjSQR0N_Dreic=@protonmail.com>
 <CAGXD5f0PXDMbVMiUNnqK-HGwB1yDEmBQgtLbQU4xcad3pDaGmw@mail.gmail.com>
 <XcV-a5p3nVenGEXgv4CO2X6lh4UXi18PM4-iKnfY3_SSoi5xCeCp84wsS1yHdHMVvDftNX5TrOnhUfvei371OQQHIVAJmcF-UQ_EAAZONyE=@protonmail.com>
Message-ID: <CAGXD5f25Y180WoVhh+PnNP6pF_fHE1DbRqDJp_vaLz58+-5=8g@mail.gmail.com>

Hi ZmnSCPxj,

You are of course correct. I had considered the effect of reorgs, but the
email seemed to be getting too lengthy to mention that too.

You would need a few spare blocks in which Bob won't be accused of bribery
as a safety margin, which does reduce the time frame in which Alice can get
her transaction confirmed in order to have a valid bribery fraud. This
seems workable if the time frame was long enough (over a few hours should
be sufficient, assuming we consider reorgs of over 3-4 blocks to be
unlikely), but could indeed be problematic if the time frame is already
short to begin with.

Nadav

On Thu, Jun 25, 2020 at 7:04 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Nadav,
>
> > > I and some number of Lightning devs consider this to be sufficient
> disincentive to Bob not attacking in the first place.
> >
> > An additional disincentive could be introduced in the form of bribery
> proofs for failed attempts.
> >
> > If we assume that "honest" users of the LN protocol won't reveal their
> timelocked transactions before reaching the timelock expiry (they shouldn't
> anyway because standard full node implementations won't relay them), we can
> prove that Bob attempted bribery and failed to an outside observer by
> showing Bob's signed timelocked transaction, spending an output that was in
> reality spent by a different transaction prior to the locktime expiry,
> which should not be possible if Bob had waited.
>
>
> Unfortunately this could be subject to an inversion of this attack.
>
> Alice can wait for the timelock to expire, then bribe miners to prevent
> confirmation of the Bob timelocked transaction, getting the Alice
> hashlocked transaction confirmed.
>
> Now of course you do mention "prior to the locktime expiry" but there is
> now risk at around locktime.
>
> Particularly, "natural" orphaned blocks and short-term chainsplits can
> exist.
> Bob might see that the locktime has arrived and broadcast the signed
> timelocked transaction, then Alice sees the locktime has not yet arrived
> (due to short-term chainsplits/propagation delays) and broadcast the signed
> hashlocked transaction, then in the end the Alice side of the short-term
> chainsplit is what solidifies into reality due to random chance on which
> miner wins which block.
> Then Bob can now be accused of bribery, even though it acted innocently;
> it broadcasted the timelock branch due to a natural chainsplit but Alice
> hashlocked branch got confirmed.
>
> Additional complications can be added on top to help mitigate this edge
> case but more complex == worse in general.
> For example it could "prior to locktime expiry" can ignore a few blocks
> before the actual timelock, but this might allow Bob to mount the attack by
> initiating its bribery behavior earlier by those few blocks.
>
> Finally, serious attackers would just use new pseudonyms, the important
> thing is to make pseudonyms valuable and costly to lose, so it is
> considered sufficient that LN nodes need to have some commitment to the LN
> in the form of actual channels (which are valuable, potentially
> money-earning constructs, and costly to set up).
>
> Other HTLC-using systems, such as the "SwapMarket" being proposed by Chris
> Belcher, could use similar disincentivizing; I know Chris is planning a
> fidelity bond system for SwapMarket makers, for example, which would mimic
> the properties of LN channels (costly to set up, money-earning).
>
> Regards,
> ZmnSCPxj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200625/b7933c5a/attachment-0001.html>

From bastien at acinq.fr  Thu Jun 25 13:12:56 2020
From: bastien at acinq.fr (Bastien TEINTURIER)
Date: Thu, 25 Jun 2020 15:12:56 +0200
Subject: [bitcoin-dev] MAD-HTLC
In-Reply-To: <CAGXD5f25Y180WoVhh+PnNP6pF_fHE1DbRqDJp_vaLz58+-5=8g@mail.gmail.com>
References: <CABT1wW=X35HRVGuP-BHUhDrkBEw27+-iDkNnHWjRU-1mRkn0JQ@mail.gmail.com>
 <CABT1wW=KWtoo6zHs8=yUQ7vAYcFSdAzdpDJ9yfw6sJrLd6dN5A@mail.gmail.com>
 <ahTHfoyyTpBrMiKdJWMn9Qa8CMCEd1-y8OXPSjsDmttTOVC3zGuDoSHkm_oOe5mBYgIAY7jOPocQhLW29n544xFsqVyq51NFApvaFYYSvFY=@protonmail.com>
 <CABT1wWknczx62uCpJPWku-KeYuaFvJHrvOS74YzqfoVe5x=edg@mail.gmail.com>
 <CABT1wWmm=rx1MkFeNhGeEgdu7XpBXYeq_PWaZFfBOA7MRSKezw@mail.gmail.com>
 <xFJlIP6z6qhjxDAP8xUBnqPF-Wulexjr9izry8mIWCQzQdNrULtX_TwWGfuHo7VNfTdXZNmy05QHxMF3iJbjZm_-jFO_WRJjSQR0N_Dreic=@protonmail.com>
 <CAGXD5f0PXDMbVMiUNnqK-HGwB1yDEmBQgtLbQU4xcad3pDaGmw@mail.gmail.com>
 <XcV-a5p3nVenGEXgv4CO2X6lh4UXi18PM4-iKnfY3_SSoi5xCeCp84wsS1yHdHMVvDftNX5TrOnhUfvei371OQQHIVAJmcF-UQ_EAAZONyE=@protonmail.com>
 <CAGXD5f25Y180WoVhh+PnNP6pF_fHE1DbRqDJp_vaLz58+-5=8g@mail.gmail.com>
Message-ID: <CACdvm3OJOJ9TXxR5x=j6+aC4s71geXXRF9XOj0Bi=Pw+p2i6PQ@mail.gmail.com>

Good morning list,

This is an interesting and simple idea, thanks for sharing this paper!

However I think there are a couple of important issues (but it could be me
misunderstanding):

* the assumption that the mempool is a shared resource is flawed: it's
entirely possible
  to have very different mempools in different areas of the network, for a
potentially long
  period of time (see the RBF pinning thread [1]), and an attacker can
leverage this fact
* a corollary is that Bob may not know that Alice has published her
transaction, and will
  end up publishing his timeout tx, unknowingly giving the two preimages to
the miners
* a corollary of that is a very unhealthy incentive to miners, when they
receive an HTLC
  success tx, to always wait for the timeout before confirming the
transaction, in hope that
  they'll receive the second preimage and will be able to claim the funds
for themselves
  (whereas currently they don't gain anything by waiting before confirming
these txs)

To be fair the paper states that it doesn't address issues of malicious
miners or an attacker
colluding with a miner, but I think that even honest miners now have an
unhealthy incentive
regarding htlc success confirmation.

Let me know if I misunderstood something, or if you have ideas on how to
explore that
threat model in the future.

Cheers,
Bastien

[1]
https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html



Le jeu. 25 juin 2020 ? 14:45, Nadav Ivgi via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> a ?crit :

> Hi ZmnSCPxj,
>
> You are of course correct. I had considered the effect of reorgs, but the
> email seemed to be getting too lengthy to mention that too.
>
> You would need a few spare blocks in which Bob won't be accused of bribery
> as a safety margin, which does reduce the time frame in which Alice can get
> her transaction confirmed in order to have a valid bribery fraud. This
> seems workable if the time frame was long enough (over a few hours should
> be sufficient, assuming we consider reorgs of over 3-4 blocks to be
> unlikely), but could indeed be problematic if the time frame is already
> short to begin with.
>
> Nadav
>
> On Thu, Jun 25, 2020 at 7:04 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>
>> Good morning Nadav,
>>
>> > > I and some number of Lightning devs consider this to be sufficient
>> disincentive to Bob not attacking in the first place.
>> >
>> > An additional disincentive could be introduced in the form of bribery
>> proofs for failed attempts.
>> >
>> > If we assume that "honest" users of the LN protocol won't reveal their
>> timelocked transactions before reaching the timelock expiry (they shouldn't
>> anyway because standard full node implementations won't relay them), we can
>> prove that Bob attempted bribery and failed to an outside observer by
>> showing Bob's signed timelocked transaction, spending an output that was in
>> reality spent by a different transaction prior to the locktime expiry,
>> which should not be possible if Bob had waited.
>>
>>
>> Unfortunately this could be subject to an inversion of this attack.
>>
>> Alice can wait for the timelock to expire, then bribe miners to prevent
>> confirmation of the Bob timelocked transaction, getting the Alice
>> hashlocked transaction confirmed.
>>
>> Now of course you do mention "prior to the locktime expiry" but there is
>> now risk at around locktime.
>>
>> Particularly, "natural" orphaned blocks and short-term chainsplits can
>> exist.
>> Bob might see that the locktime has arrived and broadcast the signed
>> timelocked transaction, then Alice sees the locktime has not yet arrived
>> (due to short-term chainsplits/propagation delays) and broadcast the signed
>> hashlocked transaction, then in the end the Alice side of the short-term
>> chainsplit is what solidifies into reality due to random chance on which
>> miner wins which block.
>> Then Bob can now be accused of bribery, even though it acted innocently;
>> it broadcasted the timelock branch due to a natural chainsplit but Alice
>> hashlocked branch got confirmed.
>>
>> Additional complications can be added on top to help mitigate this edge
>> case but more complex == worse in general.
>> For example it could "prior to locktime expiry" can ignore a few blocks
>> before the actual timelock, but this might allow Bob to mount the attack by
>> initiating its bribery behavior earlier by those few blocks.
>>
>> Finally, serious attackers would just use new pseudonyms, the important
>> thing is to make pseudonyms valuable and costly to lose, so it is
>> considered sufficient that LN nodes need to have some commitment to the LN
>> in the form of actual channels (which are valuable, potentially
>> money-earning constructs, and costly to set up).
>>
>> Other HTLC-using systems, such as the "SwapMarket" being proposed by
>> Chris Belcher, could use similar disincentivizing; I know Chris is planning
>> a fidelity bond system for SwapMarket makers, for example, which would
>> mimic the properties of LN channels (costly to set up, money-earning).
>>
>> Regards,
>> ZmnSCPxj
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200625/845a11e0/attachment.html>

From quantumas3 at gmail.com  Thu Jun 25 21:43:20 2020
From: quantumas3 at gmail.com (Cloud Strife)
Date: Thu, 25 Jun 2020 17:43:20 -0400
Subject: [bitcoin-dev] Bitcoin 2-way-pegged childchains via Proof of Burn
Message-ID: <CAHeORgLcir=hZSoiDAE2hfttW71tiMNor0updmgRc2z-W-v=ow@mail.gmail.com>

Hi everyone,

I am hoping to get a critique on a proposal of how to
construct childchains "on-top" of Bitcoin without requiring any changes to
Bitcoin itself nor requiring any user or miner to be aware of them.

The childchain is Bitcoin-aware and simulates the properties of Proof of
Work by requiring continuous burning of Bitcoin in return for the fees on
the childchain.

The childchain tip is selected by highest total accumulated Bitcoin burnt
(with goal to simulate total accumulated work) for that full chained set of
childchain block commits.

The only asset on the childchain is a 2-way-peg coin that's secured in
value without oracles or collateral by requiring that each valid child
chain block must not only burn Bitcoin, but must always use a small % of
the burnt amount to deterministically reimburse withdrawals from the
childchain.

Childchain -> mainchain :: user burns the child-BTC and is added to
withdrawal queue filled as part of validity requirements by childchain
"miners" until filled 1:1 on mainchain or more. Note that occasionally
overpaying a widthdrawal does not break 1:1 peg as there's no fixed size
1:1 pool of coins necessary.

mainchain -> childchain :: user burns BTC (independent of mining
childchain) and is issued equivalent 1:1 child-BTC on the childchain

While childchains are less secure than the mainchain, both the childchain
security and the 2-way-peg accuracy might be an acceptable option for lower
value tx on scale determined by the burning rate.

Childchains would replace the need for any additional Proof of Work chains
for new blockchains to introduce any complexity (e.g. mimblewimble
childchain).

They would effectively use Proof of Work done on Bitcoin as proxy for
unforgeable costliness and benefit from Bitcoin's censorship resistance and
data availability. Large numbers of low value tx that might be priced out
of using the main chain could possibly in bulk provide enough childchain
fees combined through childchain miners to afford much higher mainchain
fees like "batching for fees".

It also has the "benefits" claimed by proof of stake like no energy
consumption without relying on internal permissions or tokens, trusted
distributions, or centralizing mechanisms like staking by simulating proof
of work. It should allow both growing the Bitcoin ecosystem and replace the
need to create alternative cryptocurrencies just to make a new blockchain.

More detailed write up available here:
https://bitcointalk.org/index.php?topic=5214173.0

I am hoping for a review if there's an overlooked issue or maybe interest
to create a proof of concept.

Thank you
-CS
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200625/9017f5d1/attachment.html>

From ZmnSCPxj at protonmail.com  Fri Jun 26 00:57:13 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 26 Jun 2020 00:57:13 +0000
Subject: [bitcoin-dev] Bitcoin 2-way-pegged childchains via Proof of Burn
In-Reply-To: <CAHeORgLcir=hZSoiDAE2hfttW71tiMNor0updmgRc2z-W-v=ow@mail.gmail.com>
References: <CAHeORgLcir=hZSoiDAE2hfttW71tiMNor0updmgRc2z-W-v=ow@mail.gmail.com>
Message-ID: <okQj-0Wqe15uKxpyE__yGosi6QkxODpX2AVkebxFNXN3NXHOSA-Q10N_CMj8hSI1UGLObVDdM-wvmIAb2pklg4jX_vVPlpsr6EMMry5d7MM=@protonmail.com>

Good morning CS,

The difficulty is not so much the proof-of-whatever, but rather, the peg itself.
My understanding of your pegout from sidechain to mainchain is that this pegout is very low-bandwidth, i.e. only a tiny amount can be pegged out at each mainchain block.
This suggests to me that the sidecoin can still drop lower than maincoin during times when overall side-to-main flows are higher than main-to-side flows.
(atomic swaps cannot *maintain* a peg, they can only follow a peg if it exists; if the peg is weak, atomic swaps cannot strengthen it.
this is because atomic swaps allow a non-1:1 exchange rate, as in cross-currency atomic swaps.)


In any case, from my reading of your text, I seem, the goal is scaling ("acceptable option for lower value tx").
I studied sidechains some years ago, and, came to the conclusion that sidechains are not good for scaling.
We already know that blockchains do not scale well (excessive bandwidth use, permanent records needed to support newcomers); thus, the scaling solution for cryptocurrency cannot be via **more** blockchains.
Hence, Lightning Network.

In Lightning Network, every channel is a consensus system between two participants, hence every channel is a 2-of-2 (i.e. requires consensus of both participants to advance).
We use atomic swaps to transfer between channels and the blockchain.
The channel construction requires reference to an ultimate arbiter of any dispute/non-consensus between the channel participants; this is provided by the blockchain layer off which the channel is based.

Thus blockchain for arbitration, channels for scaling.


Regards,
ZmnSCPxj


> Hi everyone,
>
> I am hoping to get a critique on a proposal of how to construct?childchains?"on-top" of Bitcoin without requiring any changes to Bitcoin itself nor requiring any user or miner to be aware of them.
>
> The childchain is Bitcoin-aware and simulates the properties of Proof of Work by requiring continuous burning of Bitcoin in return for the fees on the childchain.
>
> The childchain?tip is selected by highest total accumulated Bitcoin burnt (with goal to simulate total accumulated work) for that full chained set of childchain block commits.
>
> The only asset on the childchain?is a 2-way-peg coin that's secured in value without oracles or collateral by requiring that each valid child chain block must not only burn Bitcoin, but must always use a small % of the burnt amount to deterministically reimburse?withdrawals from the childchain.
>
> Childchain -> mainchain :: user burns the child-BTC and is added to withdrawal queue filled as part of validity requirements by childchain "miners" until filled 1:1 on mainchain or more. Note that occasionally overpaying a widthdrawal does not break 1:1 peg as there's no fixed size 1:1 pool of coins necessary.
>
> mainchain -> childchain :: user burns BTC (independent of mining childchain) and is issued equivalent 1:1 child-BTC on the childchain
>
> While childchains?are less secure than the mainchain, both the childchain security and the 2-way-peg accuracy might be an acceptable option for lower value tx on scale determined by the burning rate.?
>
> Childchains would replace the need for any additional Proof of Work chains for new blockchains to introduce any complexity (e.g. mimblewimble childchain).
>
> They would effectively use Proof of Work done on Bitcoin as proxy for unforgeable costliness and benefit from Bitcoin's censorship resistance and data availability. Large numbers of low value tx that might be priced out of using the main chain could possibly in bulk provide enough childchain fees combined through childchain miners to afford much higher mainchain fees like "batching for fees".
>
> It also has the "benefits" claimed by proof of stake like no energy consumption without relying on internal permissions or tokens, trusted distributions, or centralizing mechanisms like staking by simulating proof of work. It should allow both growing the Bitcoin ecosystem and replace the need to create alternative cryptocurrencies just to make a new blockchain.
>
> More detailed write up available here:?https://bitcointalk.org/index.php?topic=5214173.0??
>
> I am hoping for a review if there's an overlooked issue or maybe interest to create a proof of concept.
>
> Thank you
> -CS



From dave at dtrt.org  Sun Jun 28 12:15:17 2020
From: dave at dtrt.org (David A. Harding)
Date: Sun, 28 Jun 2020 08:15:17 -0400
Subject: [bitcoin-dev] MAD-HTLC
In-Reply-To: <CABT1wW=KWtoo6zHs8=yUQ7vAYcFSdAzdpDJ9yfw6sJrLd6dN5A@mail.gmail.com>
References: <CABT1wW=X35HRVGuP-BHUhDrkBEw27+-iDkNnHWjRU-1mRkn0JQ@mail.gmail.com>
 <CABT1wW=KWtoo6zHs8=yUQ7vAYcFSdAzdpDJ9yfw6sJrLd6dN5A@mail.gmail.com>
Message-ID: <20200628121517.f3l2mjcy7x4566v3@ganymede>

On Tue, Jun 23, 2020 at 09:41:56AM +0300, Stanga via bitcoin-dev wrote:
> Hi all,
> 
> We'd like to bring to your attention our recent result concerning HTLC.
> Here are the technical report and a short post outlining the main points:
> 
> * https://arxiv.org/abs/2006.12031
> * https://ittayeyal.github.io/2020-06-22-mad-htlc

Thank you for your interesting research!  Further quotes are from your
paper:

>      Myopic Miners: This bribery attack relies on all miners
> being rational, hence considering their utility at game conclu-
> sion instead of myopically optimizing for the next block. If
> a portion of the miners are myopic and any of them gets to
> create a block during the first T ? 1 rounds, that miner would
> include Alice?s transaction and Bob?s bribery attempt would
> have failed.
>    In such scenarios the attack succeeds only with a certain
> probability ? only if a myopic miner does not create a block
> in the first T ? 1 rounds. The success probability therefore
> decreases exponentially in T . Hence, to incentivize miners
> to support the attack, Bob has to increase his offered bribe
> exponentially in T .

This is a good abstract description, but I think it might be useful for
readers of this list who are wondering about the impact of this attack
to put it in concrete terms.  I'm bad at statistics, but I think the
probability of bribery failing (even if Bob offers a bribe with an
appropriately high feerate) is 1-exp(-b*h) where `b` is the number of
blocks until timeout and `h` is a percentage of the hashrate controlled
by so-called myopic miners.  Given that, here's a table of attack
failure probabilities:

                     "Myopic" hashrate
     B          1%      10%     33%     50%
     l       +---------------------------------
     o  6    |  5.82%   45.12%  86.19%  95.02%
     c  36   |  30.23%  97.27%  100.00% 100.00%
     k  144  |  76.31%  100.00% 100.00% 100.00%
     s  288  |  94.39%  100.00% 100.00% 100.00%

So, if I understand correctly, even a small amount of "myopic" hashrate
and long timeouts---or modest amounts of hashrate and short
timeouts---makes this attack unlikely to succeed (and, even in the cases
where it does succeed, Bob will have to offer a very large bribe to
compensate "rational" miners for their high chance of losing out on
gaining any transaction fees).

Additionally, I think there's the problem of measuring the distribution
of "myopic" hashrate versus "rational" hashrate.  "Rational" miners need
to do this in order to ensure they only accept Bob's timelocked bribe if
it pays a sufficiently high fee.  However, different miners who try to
track what bribes were relayed versus what transactions got mined may
come to different conclusions about the relative hashrate of "myopic"
miners, leading some of them to require higher bribes, which may lead
those those who estimated a lower relative hash rate to assume the rate
of "myopic" mining in increasing, producing a feedback loop that makes
other miners think the rate of "myopic" miners is increasing.  (And that
assumes none of the miners is deliberately juking the stats to mislead
its competitors into leaving money on the table.)

By comparison, "myopic" miners don't need to know anything special about
the past.  They can just take the UTXO set, block height, difficulty
target, and last header hash and mine whatever available transactions
will give them the greatest next-block revenue.

In conclusion, I think: 

1. Given that all known Bitcoin miners today are "myopic", there's no
   short-term issue (to be clear, you didn't claim there was).

2. A very large percentage of the hashrate would have to implement
   "rational" mining for the attack to become particularly effective.
   Hopefully, we'd learn about this as it was happening and could adapt
   before it became an issue.

3. So-called rational mining is probably a lot harder to implement
   effectively than just 150 loc in Python; it probably requires a lot
   more careful incentive analysis than just looking at HTLCs.[1]

4. Although I can't offer a proof, my intuition says that "myopic"
   mining is probably very close to optimal in the current subsidy-fee
   regime.  Optimizing transaction selection only for the next block has
   already proven to be quite challenging to both software and protocol
   developers[2] so I can't imagine how much work it would take to build
   something that effectively optimizes for an unbounded future.  In
   short, I think so-called myopic mining might actually be the most
   rational mining we're capable of.

Nevertheless, I think your results are interesting and that MAD-HTLC is
a useful tool that might be particularly desirable in contracts that
involve especially high value or especially short timeouts (perhaps
asset swaps or payment channels used by traders?).  Thank you again for
posting!

-Dave

[1] For example, your paper says "[...] the bribing cost required to
    attack HTLC is independent in T, meaning that simply increasing the
    timeout does contribute to HTLC?s security."  This implies that
    Alice, after she sees Bob's attempted bribe, could offer a counter
    bribe that spends all output value to fees (the scorched earth
    policy ZmnSCPxj describes) with a timelock set to the maximum
    single-transaction value (block 500 million, due to be mined in
    about 10 millennia, give or take a few centuries) and miners would
    hold on to it until then, never mining Bob's lower-feerate bribe.
    That's ridiculous, but it's understandable in your paper because
    you're mainly analyzing time periods so short that you don't need to
    worry much about the time-value-of-money discount (also mentioned by
    ZmnSCPxj); however, your paper also says that your Python
    implementation uses the same formulas in your paper to determine
    whether or not a bribe will profitable, which would obviously be
    wrong for a 10,000-year timelock.

[2] See the never ending discussions on this list and Lightning-Dev
    about ancestor mining package size/depth limits and BIP125 opt-in
    RBF rule #3.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200628/84e0a79b/attachment.sig>

From dave at dtrt.org  Sun Jun 28 16:41:32 2020
From: dave at dtrt.org (David A. Harding)
Date: Sun, 28 Jun 2020 12:41:32 -0400
Subject: [bitcoin-dev] MAD-HTLC
In-Reply-To: <CABT1wWknczx62uCpJPWku-KeYuaFvJHrvOS74YzqfoVe5x=edg@mail.gmail.com>
References: <CABT1wW=X35HRVGuP-BHUhDrkBEw27+-iDkNnHWjRU-1mRkn0JQ@mail.gmail.com>
 <CABT1wW=KWtoo6zHs8=yUQ7vAYcFSdAzdpDJ9yfw6sJrLd6dN5A@mail.gmail.com>
 <ahTHfoyyTpBrMiKdJWMn9Qa8CMCEd1-y8OXPSjsDmttTOVC3zGuDoSHkm_oOe5mBYgIAY7jOPocQhLW29n544xFsqVyq51NFApvaFYYSvFY=@protonmail.com>
 <CABT1wWknczx62uCpJPWku-KeYuaFvJHrvOS74YzqfoVe5x=edg@mail.gmail.com>
Message-ID: <20200628164132.mmpimgcrxpai2gnb@ganymede>

On Tue, Jun 23, 2020 at 03:47:56PM +0300, Stanga via bitcoin-dev wrote:
> On Tue, Jun 23, 2020 at 12:48 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
> > * Inputs:
> >   * Bob 1 BTC - HTLC amount
> >   * Bob 1 BTC - Bob fidelity bond
> >
> > * Cases:
> >   * Alice reveals hashlock at any time:
> >     * 1 BTC goes to Alice
> >     * 1 BTC goes to Bob (fidelity bond refund)
> >   * Bob reveals bob-hashlock after time L:
> >     * 2 BTC goes to Bob (HTLC refund + fidelity bond refund)
> >   * Bob cheated, anybody reveals both hashlock and bob-hashlock:
> >     * 2 BTC goes to miner
> >
> > [...]
> 
> The cases you present are exactly how MAD-HTLC works. It comprises two
> contracts (UTXOs):
> * Deposit (holding the intended HTLC tokens), with three redeem paths:
>     - Alice (signature), with preimage "A", no timeout
>     - Bob (signature), with preimage "B", timeout T
>     - Any entity (miner), with both preimages "A" and "B", no timeout
> * Collateral (the fidelity bond, doesn't have to be of the same amount)
>     - Bob (signature), no preimage, timeout T
>     - Any entity (miner), with both preimages "A" and "B", timeout T

I'm not these are safe if your counterparty is a miner.  Imagine Bob
offers Alice a MAD-HTLC.  Alice knows the payment preimage ("preimage
A").  Bob knows the bond preimage ("preimage B") and he's the one making
the payment and offering the bond.

After receiving the HTLC, Alice takes no action on it, so the timelock
expires.  Bob publicly broadcasts the refund transaction with the bond
preimage.  Unbeknownst to Bob, Alice is actually a miner and she uses her
pre-existing knowledge of the payment preimage plus her received
knowledge of the bond preimage to privately attempt mining a transaction
that pays her both the payment ("deposit") and the bond ("collateral").

Assuming Alice is a non-majority miner, she isn't guaranteed to
succeed---her chance of success depends on her percentage of the network
hashrate and how much fee Bob paid to incentivize other miners to
confirm his refund transaction quickly.  However, as long as Alice has a
non-trivial amount of hashrate, she will succeed some percentage of the
time in executing this type of attack.  Any of her theft attempts that
fail will leave no public trace, perhaps lulling users into a false
sense of security.

-Dave
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200628/eab02c90/attachment.sig>

From antoine.riard at gmail.com  Mon Jun 29 00:13:03 2020
From: antoine.riard at gmail.com (Antoine Riard)
Date: Sun, 28 Jun 2020 20:13:03 -0400
Subject: [bitcoin-dev] Pinning : The Good, The Bad, The Ugly
Message-ID: <CALZpt+Ea=GyzEAfJBZzdFvus4_U=x73eA+=J=sN2LONq9_V5dw@mail.gmail.com>

(tl;dr Ideally network mempools should be an efficient marketplace leading
to discovery of best-feerate blockspace demand by miners. It's not due to
current anti-DoS rules assumptions and it's quite harmful for shared-utxo
protocols like LN)

Hello all,

Lightning security model relies on the unilateral capability for a channel
participant to confirm transactions, like timing out an outgoing HTLC,
claiming an incoming HTLC or punishing a revoked commitment transaction and
thus enforcing onchain a balance negotiated offchain. This security model
is actually turning back the double-spend problem to a private matter,
making the duty of each channel participant to timely enforce its balance
against the competing interest of its counterparties. Or laid out
otherwise, contrary to a miner violating a consensus rules, base layer
peers don't care about your LN node failing to broadcast a justice
transaction before the corresponding timelock expiration (CSV delay).

Ensuring effective propagation and timely confirmation of LN transactions
is so a critical-safety operation.  Its efficiency should be always
evaluated with regards to base layer network topology, tx-relay propagation
rules, mempools behaviors, consistent policy applied by majority of nodes
and ongoing blockspace demand. All these components are direct parameters
of LN security. Due to the network being public, a malicious channel
counterparty do have an incentive to tweak them to steal from you.

The pinning attacks which have been discussed since a few months are a
direct illustration of this model. Before digging into each pinning
scenario, few properties of the base layer components should be evocated
[0].

Network mempools aren't guaranteed to be convergent, the local order of
events determines the next events accepted. I.e Alice may observe tx X, tx
Y, tx Z and Bob may observe tx Z, tx X, tx Y. If tx Z disable-RBF and tx X
try to replace Z, Alice accepts X and Bob rejects it. This divergence may
persevere until a new block.

Tx-relay topology can be observed by spying nodes [1]. An attacker can
exploit this fact to partition network mempools in different subset and
hamper propagation across them of same-spending output concurrent
transactions. If subset X observes Alice commitment transaction and subset
Y observes Bob commitment transaction, Alice's HTLC-timeout spending her
commitment won't propagate beyond the X-Y set boundaries. An attacker can
always win the propagation race through massive connections or bypassing
tx-relay privacy timers.

Miners mempools are likely identifiable, you could announce a series of
conflicting transactions to different subsets of the network and observe
"tainted" block composition to assign to each subset a miner mempool. I'm
not aware of any research on this, but it sounds plausible to identify all
power-miner mempool, i.e the ones likely to mine a block during the block
delay of the timelock you're looking to exploit. If you can't bid a
transaction in such miner mempools your channel state will stale and your
funds may be in danger.

### Scenario 1) HTLC-Preimage Pinning

As Matt previously explained in his original mail on RBF-pinning, a
malicious counterparty has an interest to pin a low-feerate HTLC-preimage
transaction in some network mempools and thus preventing a honest
HTLC-timeout to confirm. For details, refer to Optech newsletter [2].

This scenario doesn't bear any risk to the attacker, is easy to execute and
has double-digit rate of success. You don't assume network topologies
manipulation, mempools partitions or LN-node-to-full-node mapping [3] That
said this should be solved by implementing and deploying anchor outputs,
which effectively allows a party to unilaterally bump feerate of its
HTLC-timeout transactions.

### The Anchor Output Proposal

Anchor Output proposal is a current spec object implemented by the LN dev
community, it introduces the ability to _unilaterally_ and _dynamically_
bump feerate of any commitment transaction. It also opened the way to bump
local 2nd-stage transactions.

Beyond solving scenario 1), it makes LN node safe with regards to
unexpected mempool congestion. If your commitment transaction is stucking
in network mempools you can bump its feerate by attaching a CPFP on the new
`to_local` anchor. If the remote commitment gets stuck in network mempools,
you're able to bump it by attaching a CPFP on the `to_remote` anchor. This
should keep your safe against an unresponsive or lazy counterparty in case
of onchain funds to claim.

IMO, it comes with a trade-off as it introduces a mapping oracle, i.e a
linking vector between a LN node and its full-node. In this case, a spying
node may establish a dummy, low-value channel with a probed LN node, break
it by broadcasting thousands of different versions of the (revoked)
commitment and observes which one broadcast a CPFP first on the p2p layer.
Obviously, you can mitigate it by not chasing after low-value HTLC, but
that is a small risk of money loss. As of today,  this oracle can be seen
as acceptable as we have other ones and we may get rid of it in the future.

### Scenario 2a) Revoked Commitment Transaction Pinning

Digging further, we found that there are more concerning scenarios of
pinning, at the commitment-tx level. At a period of low-feerate, a
malicious party incessantly updates a channel until to obtain ~10k revoked
commitment transactions.

At a period of mempool-congestion, by having setup a fine-grained
`dust_limit_satoshis` and at same-time circulary routing HTLCs, our
malicious party can inflate absolute fee of its own commitment bounded
while breaking channel in the middle of an update sequence, ensuring it has
a higher-fee than the commitment of the honest counterparty. As channel
opener, the attacker has the amplitude of malleating the victim's
commitment such to keep it equal or under revoked feerate.

Then our malicious party broadcast to each base layer public peer one of
the revoked commitment transactions, that way partitioning the network
mempools in 10k subset. Even assuming anchor output a honest LN node won't
be able to confirm the remote commitment through a CPFP, this one failing
to cross subset boundaries, the parent txid being different at each.

Broadcasting the honest commitment transaction will fail, its feerate being
known and malleable it won't RBF already-in-mempool remote commitment
transactions. This prevents an honest party to timely timeout an outgoing
HTLC or an incoming HTLC.

This scenario does bear a low-risk to the attacker, is easy to execute and
has a likely double-digit rate of success once you tune feerate
malleability. You assume mempools partitions but not any network topologies
discovery. We underscore there is no current p2p/mempool mechanism to learn
about conflicting transactions, even learning about near-topology conflicts
don't guarantee you that a propagation path is uniform to make your CPFP
successful.

### Scenario 2b) Previous-Latest Commitment Transaction Pinning

A variant of commitment-tx pinning is to rely only on valid commitment
transactions. Channel update sequence not being atomic, you can legally own
2 valid commitment transactions. An attacker can successfully map a
LN-node's full-node and such, announce one of them and the other one to the
rest of the network. A honest peer will fail to leverage the `to_remote`
anchor output as its CPFP won't propagate again over network mempools
partitions.

This scenario doesn't bear a risk to the attacker, is medium to execute and
has a likely double-digit rate of success. You assume mempools partitions
and inter-layer mapping. How hard is it to map a LN-node to a full-node ?
Actually you can use the fact that a LN-node's full-node is monitoring the
mempool for a preimage of interest and observe the announcement of such
preimage on the offchain layer. As post-anchor HTLC-Success transactions
are malleable you can once again create mass-conflicts to isolate the
full-node and improve the probe with high certainty.

### Where Package Relay helps

Solving scenario 2a) and 2b) in the most efficient way is likely to require
package relay support on the Core side. Package relay would extend the
notion of a mempool package (topologically ordered bundles of transactions)
to introduce a new class of p2p traffic. So far its implementation has been
delayed due to refactoring mempool internals, ensuring a DoS-robust design
and a p2p PR pipeline already congested.

Once deployed, a LN node would be able to join a commitment transaction and
a CPFP together and make them evaluated atomically by network mempools such
to evict any malicious remote commitment assuming a higher feerate.

### Scenario 3) Network-Topology-Aware Pinning for Propagation Obstruction

Let's assume the following base layer tx-relay topology:

                Alice ---> Bob ---> Caroll

Alice wants to send her package relay to Caroll the miner to get her
commitment transaction confirmed. A malicious counterparty could throw
remote commitment W in Bob mempool and remote commitment X in Caroll
mempool. Transaction W would be attached to a high-fee CPFP Y. Transaction
X would be attached to a low-fee CPFP Z such that X pins in Caroll mempool.
CPFP Y and CPFP Z would be crafted such as both incorporating a conflicting
parent to prevent Bob and Caroll mempool convergence. It looks like the
following:

Bob's mempool:
tx W ---> tx Y
parent 1 ---> tx Y

Caroll's mempool:
tx X ---> tx Z
parent 2 ---> tx Z

Bob's mempool would announce and send package "tx W + tx Y + parent 1" to
Caroll's one and due to parent 1 and parent 2 spending the same output
package would be rejected. High-fee package W will prevent Alice to
successfully broadcast her package to Caroll. This fee can be higher than
the maximum one that Alice would pay to confirm her transaction, as due to
conflicts, it won't be _effectively_ paid by the malicious counterparty.

This scenario does bear a risk to the attacker only if miner mempools
haven't been well-mapped and high-fee package leak into them, is hard to
execute but has a likely double-digit rate of success. It assumes mempool
partitions, network topology knowledge and inter-layer mapping.

### Current Mempool Design Flaws in the lights of Contracting Applications
with Competing Interests

Scenario 3) does illustrate a current flaw of mempool with regards to
contracting applications with competing interests. A counterparty can
leverage network propagation rules to prevent miners' mempools to discover
the best feerate package and thus not having to pay the real fee price to
successfully obstrucate broadcast of honest package relay spending the same
output.

These network propagation rules, namely RBF opt-in, have been designed to
protect network mempools against any DoS but don't protect a single-party
against its shared-utxo co-owners. Amending these rules to enable
mempool-convergence based on feerate will enable a honest bid market for
contracting applications and ensure network-wise higher feerate. Getting
this right will require significant study as you may allow total mempool
fees to decrease when the transactions are near the bottom of the mempool.
At first sight, it sounds incentives-compatible, as miner a) gets the
highest fee bid b) an attacker does have to compete on feerate to attempt
stealing.

Assuming a basic package relay to evict low-feerate malicious commitment,
an alternative proposal could be to introduce outbound tx-relay peers
rotation to sweep and reach ~80% of the network in less than HTLC
timelocks.  Your LN node's full node will _probabilistically_ connect to a
miner mempool and announce to it the best feerate package. Making the
tx-relay topology more dynamic would make it harder for an attacker to make
package obstruction effective. IMHO, it sounds easier on the
engineering-side, but likely worse for privacy due to the aggressive
broadcast pattern.

Another alternative could be to have more ad hoc privacy-preserving
redundant tx-broadcast.

A fourth proposal, Matt's one, is to design some blind-CPFP package relay
with a pointer to original funding outpoint to rebind on-the-flight but it
does assume noinput.

### Conclusion

To the best of my knowledge, assuming mempools congestion levels we have
seen in the past months, currently deployed LN peers aren't secure against
scenario 2a) and 2b) to any motivated attackers with a decent knowledge of
both layers. Further, ensuring scenario 3) security requires heavy,
long-term work at the base layer.

IMO, we should a) go forward with anchor proposal implementation, it comes
with trade-off but enables mempool-congestion safety, b) work on package
relay to solve commitment-level pinning, c) study best base layer mechanism
to ensure best feerate package discovery by any miner's mempools and d) in
the meanwhile increase delta and deadline timelocks.

Thoughts ?

Thanks to Matt and t-bast for conversations.

Cheers,

Antoine

[0] For newcomers, see also t-bast's great piece on LN's transactions :
https://github.com/t-bast/lightning-docs/blob/master/lightning-txs.md

[1] And current state of opinions is obfuscating tx-relay topology is a
hard problem
https://github.com/bitcoin/bitcoin/pull/15759#issuecomment-480398802

[2]
https://bitcoinops.org/en/newsletters/2020/04/29/#new-attack-against-ln-payment-atomicity

[3] Obviously all these scenarios do have a setup cost scoping channel
opening onchain fees and
rebalancing but it's order(s) of magnitude lower if you can steal from
meaningful channels.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200628/42630142/attachment-0001.html>

From nadahalli at gmail.com  Mon Jun 29 11:57:52 2020
From: nadahalli at gmail.com (Tejaswi Nadahalli)
Date: Mon, 29 Jun 2020 13:57:52 +0200
Subject: [bitcoin-dev] MAD-HTLC
In-Reply-To: <20200628121517.f3l2mjcy7x4566v3@ganymede>
References: <CABT1wW=X35HRVGuP-BHUhDrkBEw27+-iDkNnHWjRU-1mRkn0JQ@mail.gmail.com>
 <CABT1wW=KWtoo6zHs8=yUQ7vAYcFSdAzdpDJ9yfw6sJrLd6dN5A@mail.gmail.com>
 <20200628121517.f3l2mjcy7x4566v3@ganymede>
Message-ID: <CAAifmAS6jX5f4XThSw_ygFpCU7JVdmQSgVjOj+if3p4qeO8sNg@mail.gmail.com>

On Sun, Jun 28, 2020 at 2:16 PM David A. Harding via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> So, if I understand correctly, even a small amount of "myopic" hashrate
> and long timeouts---or modest amounts of hashrate and short
> timeouts---makes this attack unlikely to succeed (and, even in the cases
> where it does succeed, Bob will have to offer a very large bribe to
> compensate "rational" miners for their high chance of losing out on
> gaining any transaction fees).
>

We were separately working on a similar problem, and wrote a paper as well:
https://eprint.iacr.org/2020/774 *

We look at the Alice's-Fees/Bob's-Bribe ratio. We also look at "strong" and
"weak" miners in this context. If a miner is weak, their hash-rate is lower
than this fees/bribe ratio. If they are strong, their hash rate is more
than this fees/bribe ratio. In this setting, it turns out that if there are
only strong miners, Bob will win. If there is at least one weak miner,
Alice has to win, given a reasonable timeout value. We found it awesome
that lightning has a parameter called "channel-reserve_satoshis", which
directly helps in countering this bribe by giving Alice some leeway in fees.

* Ph.D students want to write papers, unfortunately.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200629/0825c166/attachment.html>

From ZmnSCPxj at protonmail.com  Mon Jun 29 18:05:10 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 29 Jun 2020 18:05:10 +0000
Subject: [bitcoin-dev] MAD-HTLC
In-Reply-To: <20200628121517.f3l2mjcy7x4566v3@ganymede>
References: <CABT1wW=X35HRVGuP-BHUhDrkBEw27+-iDkNnHWjRU-1mRkn0JQ@mail.gmail.com>
 <CABT1wW=KWtoo6zHs8=yUQ7vAYcFSdAzdpDJ9yfw6sJrLd6dN5A@mail.gmail.com>
 <20200628121517.f3l2mjcy7x4566v3@ganymede>
Message-ID: <WYQRrIi65yvBWc9qsqCxHWadrMFtYPh2wI-IzVS15FBTFmpIXqHwj5yrj3Igpr-9sKygWsH4DkI_maWcULKKQb51Xp_xZBvKuPF_HmCvqb4=@protonmail.com>

Good morning Dave, et al.,


> >      Myopic Miners: This bribery attack relies on all miners
> >
> >
> > being rational, hence considering their utility at game conclu-
> > sion instead of myopically optimizing for the next block. If
> > a portion of the miners are myopic and any of them gets to
> > create a block during the first T ? 1 rounds, that miner would
> > include Alice?s transaction and Bob?s bribery attempt would
> > have failed.
> > In such scenarios the attack succeeds only with a certain
> > probability ? only if a myopic miner does not create a block
> > in the first T ? 1 rounds. The success probability therefore
> > decreases exponentially in T . Hence, to incentivize miners
> > to support the attack, Bob has to increase his offered bribe
> > exponentially in T .
>
> This is a good abstract description, but I think it might be useful for
> readers of this list who are wondering about the impact of this attack
> to put it in concrete terms. I'm bad at statistics, but I think the
> probability of bribery failing (even if Bob offers a bribe with an
> appropriately high feerate) is 1-exp(-b*h) where `b` is the number of
> blocks until timeout and `h` is a percentage of the hashrate controlled
> by so-called myopic miners. Given that, here's a table of attack
> failure probabilities:
>
> "Myopic" hashrate
> B 1% 10% 33% 50%
> l +---------------------------------
> o 6 | 5.82% 45.12% 86.19% 95.02%
> c 36 | 30.23% 97.27% 100.00% 100.00%
> k 144 | 76.31% 100.00% 100.00% 100.00%
> s 288 | 94.39% 100.00% 100.00% 100.00%
>
> So, if I understand correctly, even a small amount of "myopic" hashrate
> and long timeouts---or modest amounts of hashrate and short
> timeouts---makes this attack unlikely to succeed (and, even in the cases
> where it does succeed, Bob will have to offer a very large bribe to
> compensate "rational" miners for their high chance of losing out on
> gaining any transaction fees).
>
> Additionally, I think there's the problem of measuring the distribution
> of "myopic" hashrate versus "rational" hashrate. "Rational" miners need
> to do this in order to ensure they only accept Bob's timelocked bribe if
> it pays a sufficiently high fee. However, different miners who try to
> track what bribes were relayed versus what transactions got mined may
> come to different conclusions about the relative hashrate of "myopic"
> miners, leading some of them to require higher bribes, which may lead
> those those who estimated a lower relative hash rate to assume the rate
> of "myopic" mining in increasing, producing a feedback loop that makes
> other miners think the rate of "myopic" miners is increasing. (And that
> assumes none of the miners is deliberately juking the stats to mislead
> its competitors into leaving money on the table.)

A thought occurs to me, that we should not be so hasty to call non-myopic strategy "rational".
Let us consider instead "myopic" and "non-myopic" strategies in a population of miners.

I contend that in a mixed population of "myopic" and "non-myopic" miners, the myopic strategy is dominant in the game-theoretic sense, i.e. it might earn less if all miners were myopic, but if most miners were non-myopic and a small sub-population were myopic and there was no easy way for non-myopic miners to punish myopic miners, then the myopic miners will end up earning more (at the expense of the non-myopic miners) and dominate over non-myopic miners.
Such dominant result should prevent non-myopic miners from arising in the first place.

The dominance results from the fact that by accepting the Alice transaction, myopic miners are effectively deducting the fees earned by non-myopic miners by preventing the Bob transaction from being confirmable.
On the other hand, even if the non-myopic miners successfully defer the Alice transaction, the myopic miner still has a chance equal to its hashrate of getting the Bob transaction and its attached fee.
Thus, myopic miners impose costs on their non-myopic competitors that non-myopic miners cannot impose their myopic competitors.
If even one myopic miner successfully gets the Alice transaction confirmed, all the non-myopic miners lose out on the Bob bribe fee.

So I think the myopic strategy will be dominant and non-myopic miners will not arise in the first place.


Regards,
ZmnSCPxj

From stanga at gmail.com  Tue Jun 30 06:28:58 2020
From: stanga at gmail.com (Stanga)
Date: Tue, 30 Jun 2020 09:28:58 +0300
Subject: [bitcoin-dev] MAD-HTLC
In-Reply-To: <WYQRrIi65yvBWc9qsqCxHWadrMFtYPh2wI-IzVS15FBTFmpIXqHwj5yrj3Igpr-9sKygWsH4DkI_maWcULKKQb51Xp_xZBvKuPF_HmCvqb4=@protonmail.com>
References: <CABT1wW=X35HRVGuP-BHUhDrkBEw27+-iDkNnHWjRU-1mRkn0JQ@mail.gmail.com>
 <CABT1wW=KWtoo6zHs8=yUQ7vAYcFSdAzdpDJ9yfw6sJrLd6dN5A@mail.gmail.com>
 <20200628121517.f3l2mjcy7x4566v3@ganymede>
 <WYQRrIi65yvBWc9qsqCxHWadrMFtYPh2wI-IzVS15FBTFmpIXqHwj5yrj3Igpr-9sKygWsH4DkI_maWcULKKQb51Xp_xZBvKuPF_HmCvqb4=@protonmail.com>
Message-ID: <CABT1wWnR8bwUbJRPRuuGkh4-Tf6VpPRVbU4dSBtB1_y6QM9R4A@mail.gmail.com>

Hi ZmnSCPxj,

That's a good point. Basically there are two extremes, if everyone is
non-myoptic (rational), they should wait even for a small fee (our mad-htlc
result), and if everyone else is myopic (rational), a non-myopic miner
should only wait for a fairly large fee, depending on miner sizes and the
timeout -- this is analyzed in an earlier paper by Winzer, Herd and Faust
[1]. In a mixed situation the calculation becomes slightly more involved,
but qualitatively it's closer to the Wizner et al. result, namely the bribe
should grow exponentially with the timeout, which is bad for the attacker.
But mad-htlc avoids myopic assumptions, allowing you to keep your contracts
safe either way.

Best,
Ittay

[1] F. Winzer, B. Herd and S. Faust, "Temporary Censorship Attacks in the
Presence of Rational Miners
<https://ieeexplore.ieee.org/abstract/document/8802377>," *2019 IEEE
European Symposium on Security and Privacy Workshops (EuroS&PW)*,
Stockholm, Sweden, 2019, pp. 357-366, doi: 10.1109/EuroSPW.2019.00046.

On Mon, Jun 29, 2020 at 9:05 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Dave, et al.,
>
>
> > >      Myopic Miners: This bribery attack relies on all miners
> > >
> > >
> > > being rational, hence considering their utility at game conclu-
> > > sion instead of myopically optimizing for the next block. If
> > > a portion of the miners are myopic and any of them gets to
> > > create a block during the first T ? 1 rounds, that miner would
> > > include Alice?s transaction and Bob?s bribery attempt would
> > > have failed.
> > > In such scenarios the attack succeeds only with a certain
> > > probability ? only if a myopic miner does not create a block
> > > in the first T ? 1 rounds. The success probability therefore
> > > decreases exponentially in T . Hence, to incentivize miners
> > > to support the attack, Bob has to increase his offered bribe
> > > exponentially in T .
> >
> > This is a good abstract description, but I think it might be useful for
> > readers of this list who are wondering about the impact of this attack
> > to put it in concrete terms. I'm bad at statistics, but I think the
> > probability of bribery failing (even if Bob offers a bribe with an
> > appropriately high feerate) is 1-exp(-b*h) where `b` is the number of
> > blocks until timeout and `h` is a percentage of the hashrate controlled
> > by so-called myopic miners. Given that, here's a table of attack
> > failure probabilities:
> >
> > "Myopic" hashrate
> > B 1% 10% 33% 50%
> > l +---------------------------------
> > o 6 | 5.82% 45.12% 86.19% 95.02%
> > c 36 | 30.23% 97.27% 100.00% 100.00%
> > k 144 | 76.31% 100.00% 100.00% 100.00%
> > s 288 | 94.39% 100.00% 100.00% 100.00%
> >
> > So, if I understand correctly, even a small amount of "myopic" hashrate
> > and long timeouts---or modest amounts of hashrate and short
> > timeouts---makes this attack unlikely to succeed (and, even in the cases
> > where it does succeed, Bob will have to offer a very large bribe to
> > compensate "rational" miners for their high chance of losing out on
> > gaining any transaction fees).
> >
> > Additionally, I think there's the problem of measuring the distribution
> > of "myopic" hashrate versus "rational" hashrate. "Rational" miners need
> > to do this in order to ensure they only accept Bob's timelocked bribe if
> > it pays a sufficiently high fee. However, different miners who try to
> > track what bribes were relayed versus what transactions got mined may
> > come to different conclusions about the relative hashrate of "myopic"
> > miners, leading some of them to require higher bribes, which may lead
> > those those who estimated a lower relative hash rate to assume the rate
> > of "myopic" mining in increasing, producing a feedback loop that makes
> > other miners think the rate of "myopic" miners is increasing. (And that
> > assumes none of the miners is deliberately juking the stats to mislead
> > its competitors into leaving money on the table.)
>
> A thought occurs to me, that we should not be so hasty to call non-myopic
> strategy "rational".
> Let us consider instead "myopic" and "non-myopic" strategies in a
> population of miners.
>
> I contend that in a mixed population of "myopic" and "non-myopic" miners,
> the myopic strategy is dominant in the game-theoretic sense, i.e. it might
> earn less if all miners were myopic, but if most miners were non-myopic and
> a small sub-population were myopic and there was no easy way for non-myopic
> miners to punish myopic miners, then the myopic miners will end up earning
> more (at the expense of the non-myopic miners) and dominate over non-myopic
> miners.
> Such dominant result should prevent non-myopic miners from arising in the
> first place.
>
> The dominance results from the fact that by accepting the Alice
> transaction, myopic miners are effectively deducting the fees earned by
> non-myopic miners by preventing the Bob transaction from being confirmable.
> On the other hand, even if the non-myopic miners successfully defer the
> Alice transaction, the myopic miner still has a chance equal to its
> hashrate of getting the Bob transaction and its attached fee.
> Thus, myopic miners impose costs on their non-myopic competitors that
> non-myopic miners cannot impose their myopic competitors.
> If even one myopic miner successfully gets the Alice transaction
> confirmed, all the non-myopic miners lose out on the Bob bribe fee.
>
> So I think the myopic strategy will be dominant and non-myopic miners will
> not arise in the first place.
>
>
> Regards,
> ZmnSCPxj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200630/809808b9/attachment-0001.html>

From nadahalli at gmail.com  Tue Jun 30 06:45:09 2020
From: nadahalli at gmail.com (Tejaswi Nadahalli)
Date: Tue, 30 Jun 2020 08:45:09 +0200
Subject: [bitcoin-dev] MAD-HTLC
In-Reply-To: <WYQRrIi65yvBWc9qsqCxHWadrMFtYPh2wI-IzVS15FBTFmpIXqHwj5yrj3Igpr-9sKygWsH4DkI_maWcULKKQb51Xp_xZBvKuPF_HmCvqb4=@protonmail.com>
References: <CABT1wW=X35HRVGuP-BHUhDrkBEw27+-iDkNnHWjRU-1mRkn0JQ@mail.gmail.com>
 <CABT1wW=KWtoo6zHs8=yUQ7vAYcFSdAzdpDJ9yfw6sJrLd6dN5A@mail.gmail.com>
 <20200628121517.f3l2mjcy7x4566v3@ganymede>
 <WYQRrIi65yvBWc9qsqCxHWadrMFtYPh2wI-IzVS15FBTFmpIXqHwj5yrj3Igpr-9sKygWsH4DkI_maWcULKKQb51Xp_xZBvKuPF_HmCvqb4=@protonmail.com>
Message-ID: <CAAifmATmQSUUsEbouVYTNNMu-BT8vQiGvh3jwLNK4CUB11s7mg@mail.gmail.com>

Hello ZmnSCPxj (as there would be no better way to start an email to you
:-),

I posted a reply to Dave in the other sub-thread of this main thread. We
have a paper about something similar to what you have said - where we look
at "weak" and "strong" miners, and how even if there are a few weak miners,
they have a dominating strategy, etc.

On Mon, Jun 29, 2020 at 8:05 PM ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Good morning Dave, et al.,
>
>
> > >      Myopic Miners: This bribery attack relies on all miners
> > >
> > >
> > > being rational, hence considering their utility at game conclu-
> > > sion instead of myopically optimizing for the next block. If
> > > a portion of the miners are myopic and any of them gets to
> > > create a block during the first T ? 1 rounds, that miner would
> > > include Alice?s transaction and Bob?s bribery attempt would
> > > have failed.
> > > In such scenarios the attack succeeds only with a certain
> > > probability ? only if a myopic miner does not create a block
> > > in the first T ? 1 rounds. The success probability therefore
> > > decreases exponentially in T . Hence, to incentivize miners
> > > to support the attack, Bob has to increase his offered bribe
> > > exponentially in T .
> >
> > This is a good abstract description, but I think it might be useful for
> > readers of this list who are wondering about the impact of this attack
> > to put it in concrete terms. I'm bad at statistics, but I think the
> > probability of bribery failing (even if Bob offers a bribe with an
> > appropriately high feerate) is 1-exp(-b*h) where `b` is the number of
> > blocks until timeout and `h` is a percentage of the hashrate controlled
> > by so-called myopic miners. Given that, here's a table of attack
> > failure probabilities:
> >
> > "Myopic" hashrate
> > B 1% 10% 33% 50%
> > l +---------------------------------
> > o 6 | 5.82% 45.12% 86.19% 95.02%
> > c 36 | 30.23% 97.27% 100.00% 100.00%
> > k 144 | 76.31% 100.00% 100.00% 100.00%
> > s 288 | 94.39% 100.00% 100.00% 100.00%
> >
> > So, if I understand correctly, even a small amount of "myopic" hashrate
> > and long timeouts---or modest amounts of hashrate and short
> > timeouts---makes this attack unlikely to succeed (and, even in the cases
> > where it does succeed, Bob will have to offer a very large bribe to
> > compensate "rational" miners for their high chance of losing out on
> > gaining any transaction fees).
> >
> > Additionally, I think there's the problem of measuring the distribution
> > of "myopic" hashrate versus "rational" hashrate. "Rational" miners need
> > to do this in order to ensure they only accept Bob's timelocked bribe if
> > it pays a sufficiently high fee. However, different miners who try to
> > track what bribes were relayed versus what transactions got mined may
> > come to different conclusions about the relative hashrate of "myopic"
> > miners, leading some of them to require higher bribes, which may lead
> > those those who estimated a lower relative hash rate to assume the rate
> > of "myopic" mining in increasing, producing a feedback loop that makes
> > other miners think the rate of "myopic" miners is increasing. (And that
> > assumes none of the miners is deliberately juking the stats to mislead
> > its competitors into leaving money on the table.)
>
> A thought occurs to me, that we should not be so hasty to call non-myopic
> strategy "rational".
> Let us consider instead "myopic" and "non-myopic" strategies in a
> population of miners.
>
> I contend that in a mixed population of "myopic" and "non-myopic" miners,
> the myopic strategy is dominant in the game-theoretic sense, i.e. it might
> earn less if all miners were myopic, but if most miners were non-myopic and
> a small sub-population were myopic and there was no easy way for non-myopic
> miners to punish myopic miners, then the myopic miners will end up earning
> more (at the expense of the non-myopic miners) and dominate over non-myopic
> miners.
> Such dominant result should prevent non-myopic miners from arising in the
> first place.
>
> The dominance results from the fact that by accepting the Alice
> transaction, myopic miners are effectively deducting the fees earned by
> non-myopic miners by preventing the Bob transaction from being confirmable.
> On the other hand, even if the non-myopic miners successfully defer the
> Alice transaction, the myopic miner still has a chance equal to its
> hashrate of getting the Bob transaction and its attached fee.
> Thus, myopic miners impose costs on their non-myopic competitors that
> non-myopic miners cannot impose their myopic competitors.
> If even one myopic miner successfully gets the Alice transaction
> confirmed, all the non-myopic miners lose out on the Bob bribe fee.
>
> So I think the myopic strategy will be dominant and non-myopic miners will
> not arise in the first place.
>
>
> Regards,
> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200630/ecf01349/attachment.html>

From hildawithin at 163.com  Tue Jun 30 19:01:30 2020
From: hildawithin at 163.com (Hilda)
Date: Wed, 1 Jul 2020 03:01:30 +0800 (CST)
Subject: [bitcoin-dev] Is Bitcoin mempool synchronized?
Message-ID: <24cf6c3f.207.173069b0747.Coremail.hildawithin@163.com>

Hi there,


I have been assuming Bitcoin system to be well synchronized, including mempools. But after being challenged, I started to think that I actually cannot verify this without knocking the door of every miner in every single second (just a time slice reasonable to me; stop torturing me by asking why). Can anyone share any thoughts with me?


Thank you,
Hilda
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200701/fc716bba/attachment.html>

