From luke at dashjr.org  Sun Oct  1 01:13:29 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Sun, 1 Oct 2017 01:13:29 +0000
Subject: [bitcoin-dev] Version 1 witness programs (first draft)
Message-ID: <201710010113.30518.luke@dashjr.org>

I've put together a first draft for what I hope to be a good next step for 
Segwit and Bitcoin scripting:
    https://github.com/luke-jr/bips/blob/witnessv1/bip-witnessv1.mediawiki

This introduces 5 key changes:

1. Minor versions for witnesses, inside the witness itself. Essentially the 
witness [major] version 1 simply indicates the witness commitment is SHA256d, 
and nothing more.

The remaining two are witness version 1.0 (major 1, minor 0):

2. As previously discussed, undefined opcodes immediately cause the script to 
exit with success, making future opcode softforks a lot more flexible.

3. If the final stack element is not exactly true or false, it is interpreted 
as a tail-call Script and executed. (Credit to Mark Friedenbach)

4. A new shorter fixed-length signature format, eliminating the need to guess 
the signature size in advance. All signatures are 65 bytes, unless a condition 
script is included (see #5).

5. The ability for signatures to commit to additional conditions, expressed in 
the form of a serialized Script in the signature itself. This would be useful 
in combination with OP_CHECKBLOCKATHEIGHT (BIP 115), hopefully ending the 
whole replay protection argument by introducing it early to Bitcoin before any 
further splits.

This last part is a big ugly right now: the signature must commit to the 
script interpreter flags and internal "sigversion", which basically serve the 
same purpose. The reason for this, is that otherwise someone could move the 
signature to a different context in an attempt to exploit differences in the 
various Script interpretation modes. I don't consider the BIP deployable 
without this getting resolved, but I'm not sure what the best approach would 
be. Maybe it should be replaced with a witness [major] version and witness 
stack?

There is also draft code implementing [the consensus side of] this:
    https://github.com/bitcoin/bitcoin/compare/master...luke-jr:witnessv1

Thoughts? Anything I've overlooked / left missing that would be 
uncontroversial and desirable? (Is any of this unexpectedly controversial for 
some reason?)

Luke

From mark at friedenbach.org  Sun Oct  1 02:23:47 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Sat, 30 Sep 2017 19:23:47 -0700
Subject: [bitcoin-dev] Version 1 witness programs (first draft)
In-Reply-To: <201710010113.30518.luke@dashjr.org>
References: <201710010113.30518.luke@dashjr.org>
Message-ID: <5A220A8D-3A85-49D0-8DB2-6BDEC362EAEB@friedenbach.org>

The CLEANSTACK rule should be eliminated, and instead the number of items on the stack should be incorporated into the signature hash. That way any script with a CHECKSIG is protected from witness extension malleability, and those rare ones that do not use signature operations can have a ?DEPTH 1 EQUALVERIFY? at the end. This allows for much simpler tail-call evaluation as you don?t need to pass arguments on the alt-stack.

> On Sep 30, 2017, at 6:13 PM, Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> I've put together a first draft for what I hope to be a good next step for 
> Segwit and Bitcoin scripting:
>    https://github.com/luke-jr/bips/blob/witnessv1/bip-witnessv1.mediawiki
> 
> This introduces 5 key changes:
> 
> 1. Minor versions for witnesses, inside the witness itself. Essentially the 
> witness [major] version 1 simply indicates the witness commitment is SHA256d, 
> and nothing more.
> 
> The remaining two are witness version 1.0 (major 1, minor 0):
> 
> 2. As previously discussed, undefined opcodes immediately cause the script to 
> exit with success, making future opcode softforks a lot more flexible.
> 
> 3. If the final stack element is not exactly true or false, it is interpreted 
> as a tail-call Script and executed. (Credit to Mark Friedenbach)
> 
> 4. A new shorter fixed-length signature format, eliminating the need to guess 
> the signature size in advance. All signatures are 65 bytes, unless a condition 
> script is included (see #5).
> 
> 5. The ability for signatures to commit to additional conditions, expressed in 
> the form of a serialized Script in the signature itself. This would be useful 
> in combination with OP_CHECKBLOCKATHEIGHT (BIP 115), hopefully ending the 
> whole replay protection argument by introducing it early to Bitcoin before any 
> further splits.
> 
> This last part is a big ugly right now: the signature must commit to the 
> script interpreter flags and internal "sigversion", which basically serve the 
> same purpose. The reason for this, is that otherwise someone could move the 
> signature to a different context in an attempt to exploit differences in the 
> various Script interpretation modes. I don't consider the BIP deployable 
> without this getting resolved, but I'm not sure what the best approach would 
> be. Maybe it should be replaced with a witness [major] version and witness 
> stack?
> 
> There is also draft code implementing [the consensus side of] this:
>    https://github.com/bitcoin/bitcoin/compare/master...luke-jr:witnessv1
> 
> Thoughts? Anything I've overlooked / left missing that would be 
> uncontroversial and desirable? (Is any of this unexpectedly controversial for 
> some reason?)
> 
> Luke
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From luke at dashjr.org  Sun Oct  1 02:47:41 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Sun, 1 Oct 2017 02:47:41 +0000
Subject: [bitcoin-dev] Version 1 witness programs (first draft)
In-Reply-To: <5A220A8D-3A85-49D0-8DB2-6BDEC362EAEB@friedenbach.org>
References: <201710010113.30518.luke@dashjr.org>
	<5A220A8D-3A85-49D0-8DB2-6BDEC362EAEB@friedenbach.org>
Message-ID: <201710010247.42180.luke@dashjr.org>

Should it perhaps commit to the length of the serialised witness data instead 
or additionally? Now that signatures are no longer variable-length, that'd be 
possible...

As far as tail-call needs are concerned, CLEANSTACK wouldn't have been checked 
until AFTER the tail-call in the first draft. But I suppose eliminating it for 
other possible future purposes is still useful.

Luke


On Sunday 01 October 2017 2:23:47 AM Mark Friedenbach wrote:
> The CLEANSTACK rule should be eliminated, and instead the number of items
> on the stack should be incorporated into the signature hash. That way any
> script with a CHECKSIG is protected from witness extension malleability,
> and those rare ones that do not use signature operations can have a ?DEPTH
> 1 EQUALVERIFY? at the end. This allows for much simpler tail-call
> evaluation as you don?t need to pass arguments on the alt-stack.
> 
> > On Sep 30, 2017, at 6:13 PM, Luke Dashjr via bitcoin-dev
> > <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > 
> > I've put together a first draft for what I hope to be a good next step
> > for
> > 
> > Segwit and Bitcoin scripting:
> >    https://github.com/luke-jr/bips/blob/witnessv1/bip-witnessv1.mediawiki
> > 
> > This introduces 5 key changes:
> > 
> > 1. Minor versions for witnesses, inside the witness itself. Essentially
> > the witness [major] version 1 simply indicates the witness commitment is
> > SHA256d, and nothing more.
> > 
> > The remaining two are witness version 1.0 (major 1, minor 0):
> > 
> > 2. As previously discussed, undefined opcodes immediately cause the
> > script to exit with success, making future opcode softforks a lot more
> > flexible.
> > 
> > 3. If the final stack element is not exactly true or false, it is
> > interpreted as a tail-call Script and executed. (Credit to Mark
> > Friedenbach)
> > 
> > 4. A new shorter fixed-length signature format, eliminating the need to
> > guess the signature size in advance. All signatures are 65 bytes, unless
> > a condition script is included (see #5).
> > 
> > 5. The ability for signatures to commit to additional conditions,
> > expressed in the form of a serialized Script in the signature itself.
> > This would be useful in combination with OP_CHECKBLOCKATHEIGHT (BIP
> > 115), hopefully ending the whole replay protection argument by
> > introducing it early to Bitcoin before any further splits.
> > 
> > This last part is a big ugly right now: the signature must commit to the
> > script interpreter flags and internal "sigversion", which basically serve
> > the same purpose. The reason for this, is that otherwise someone could
> > move the signature to a different context in an attempt to exploit
> > differences in the various Script interpretation modes. I don't consider
> > the BIP deployable without this getting resolved, but I'm not sure what
> > the best approach would be. Maybe it should be replaced with a witness
> > [major] version and witness stack?
> > 
> > There is also draft code implementing [the consensus side of] this:
> >    https://github.com/bitcoin/bitcoin/compare/master...luke-jr:witnessv1
> > 
> > Thoughts? Anything I've overlooked / left missing that would be
> > uncontroversial and desirable? (Is any of this unexpectedly controversial
> > for some reason?)
> > 
> > Luke
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From mark at friedenbach.org  Sun Oct  1 05:04:32 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Sat, 30 Sep 2017 22:04:32 -0700
Subject: [bitcoin-dev] Version 1 witness programs (first draft)
In-Reply-To: <201710010247.42180.luke@dashjr.org>
References: <201710010113.30518.luke@dashjr.org>
	<5A220A8D-3A85-49D0-8DB2-6BDEC362EAEB@friedenbach.org>
	<201710010247.42180.luke@dashjr.org>
Message-ID: <D811BF0D-8286-4A40-A443-09147E4EADDD@friedenbach.org>

Clean stack should be eliminated for other possible future uses, the most obvious of which is recursive tail-call for general computation capability. I?m not arguing for that at this time, just arguing that we shouldn?t prematurely cut off an easy implementation of such should we want to. Clean stack must still exist as policy for future soft-fork safety, but being a consensus requirement was only to avoid witness malleability, which committing to the size of the witness also accomplishes.

Committing to the number of witness elements is fully sufficient, and using the number of elements avoids problems of not knowing the actual size in bytes at the time of signing, e.g. because the witness contains a merkle proof generated by another party from an unbalanced tree, and unbalanced trees are expected to be common (so that elements can be placed higher in the tree in accordance with their higher expected probability of usage). Other future extensions might also have variable-length proofs.

> On Sep 30, 2017, at 7:47 PM, Luke Dashjr <luke at dashjr.org> wrote:
> 
> Should it perhaps commit to the length of the serialised witness data instead 
> or additionally? Now that signatures are no longer variable-length, that'd be 
> possible...
> 
> As far as tail-call needs are concerned, CLEANSTACK wouldn't have been checked 
> until AFTER the tail-call in the first draft. But I suppose eliminating it for 
> other possible future purposes is still useful.
> 
> Luke


From mail at felixweis.com  Sun Oct  1 11:22:30 2017
From: mail at felixweis.com (Felix Weis)
Date: Sun, 01 Oct 2017 11:22:30 +0000
Subject: [bitcoin-dev] Version 1 witness programs (first draft)
In-Reply-To: <D811BF0D-8286-4A40-A443-09147E4EADDD@friedenbach.org>
References: <201710010113.30518.luke@dashjr.org>
	<5A220A8D-3A85-49D0-8DB2-6BDEC362EAEB@friedenbach.org>
	<201710010247.42180.luke@dashjr.org>
	<D811BF0D-8286-4A40-A443-09147E4EADDD@friedenbach.org>
Message-ID: <CAMnWzuULmHsiC8CSHZRHS7nJAgHBVMCUfSR-0Si31YSQFeGfbQ@mail.gmail.com>

Just a simple suggestion since the signature format is changed. Can this be
designed so that possible future hard forks can simply change 1 constant in
the code and turn on cross chain replay protection?

On Sun, Oct 1, 2017 at 1:05 PM Mark Friedenbach via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Clean stack should be eliminated for other possible future uses, the most
> obvious of which is recursive tail-call for general computation capability.
> I?m not arguing for that at this time, just arguing that we shouldn?t
> prematurely cut off an easy implementation of such should we want to. Clean
> stack must still exist as policy for future soft-fork safety, but being a
> consensus requirement was only to avoid witness malleability, which
> committing to the size of the witness also accomplishes.
>
> Committing to the number of witness elements is fully sufficient, and
> using the number of elements avoids problems of not knowing the actual size
> in bytes at the time of signing, e.g. because the witness contains a merkle
> proof generated by another party from an unbalanced tree, and unbalanced
> trees are expected to be common (so that elements can be placed higher in
> the tree in accordance with their higher expected probability of usage).
> Other future extensions might also have variable-length proofs.
>
> > On Sep 30, 2017, at 7:47 PM, Luke Dashjr <luke at dashjr.org> wrote:
> >
> > Should it perhaps commit to the length of the serialised witness data
> instead
> > or additionally? Now that signatures are no longer variable-length,
> that'd be
> > possible...
> >
> > As far as tail-call needs are concerned, CLEANSTACK wouldn't have been
> checked
> > until AFTER the tail-call in the first draft. But I suppose eliminating
> it for
> > other possible future purposes is still useful.
> >
> > Luke
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171001/4e1497ee/attachment-0001.html>

From luke at dashjr.org  Sun Oct  1 17:36:05 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Sun, 1 Oct 2017 17:36:05 +0000
Subject: [bitcoin-dev] Version 1 witness programs (first draft)
In-Reply-To: <CAMnWzuULmHsiC8CSHZRHS7nJAgHBVMCUfSR-0Si31YSQFeGfbQ@mail.gmail.com>
References: <201710010113.30518.luke@dashjr.org>
	<D811BF0D-8286-4A40-A443-09147E4EADDD@friedenbach.org>
	<CAMnWzuULmHsiC8CSHZRHS7nJAgHBVMCUfSR-0Si31YSQFeGfbQ@mail.gmail.com>
Message-ID: <201710011736.06471.luke@dashjr.org>

BIP 115 provides fork-independent opt-in replay protection, which can be used 
in combination with the new signature condition scripts in this proposal.

Perhaps the code can have a flag for new altcoins to easily make it mandatory 
(and we can use it on testnet?).

Luke


On Sunday 01 October 2017 11:22:30 AM Felix Weis wrote:
> Just a simple suggestion since the signature format is changed. Can this be
> designed so that possible future hard forks can simply change 1 constant in
> the code and turn on cross chain replay protection?
> 
> On Sun, Oct 1, 2017 at 1:05 PM Mark Friedenbach via bitcoin-dev <
> 
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> > Clean stack should be eliminated for other possible future uses, the most
> > obvious of which is recursive tail-call for general computation
> > capability. I?m not arguing for that at this time, just arguing that we
> > shouldn?t prematurely cut off an easy implementation of such should we
> > want to. Clean stack must still exist as policy for future soft-fork
> > safety, but being a consensus requirement was only to avoid witness
> > malleability, which committing to the size of the witness also
> > accomplishes.
> > 
> > Committing to the number of witness elements is fully sufficient, and
> > using the number of elements avoids problems of not knowing the actual
> > size in bytes at the time of signing, e.g. because the witness contains
> > a merkle proof generated by another party from an unbalanced tree, and
> > unbalanced trees are expected to be common (so that elements can be
> > placed higher in the tree in accordance with their higher expected
> > probability of usage). Other future extensions might also have
> > variable-length proofs.
> > 
> > > On Sep 30, 2017, at 7:47 PM, Luke Dashjr <luke at dashjr.org> wrote:
> > > 
> > > Should it perhaps commit to the length of the serialised witness data
> > 
> > instead
> > 
> > > or additionally? Now that signatures are no longer variable-length,
> > 
> > that'd be
> > 
> > > possible...
> > > 
> > > As far as tail-call needs are concerned, CLEANSTACK wouldn't have been
> > 
> > checked
> > 
> > > until AFTER the tail-call in the first draft. But I suppose eliminating
> > 
> > it for
> > 
> > > other possible future purposes is still useful.
> > > 
> > > Luke
> > 
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From mark at friedenbach.org  Sun Oct  1 18:34:07 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Sun, 1 Oct 2017 11:34:07 -0700
Subject: [bitcoin-dev] Version 1 witness programs (first draft)
In-Reply-To: <201710010113.30518.luke@dashjr.org>
References: <201710010113.30518.luke@dashjr.org>
Message-ID: <089161B1-9AD6-45A2-BE0A-215FECC19510@friedenbach.org>

I would also suggest that the 520 byte push limitation be removed for v1 scripts as well. MERKLEBRANCHVERIFY in particular could benefit from larger proof sizes. To do so safely would require reworking script internals to use indirect pointers and reference counting for items on stack, but this is worth doing generally, and introducing a per-input hashing limit equal to a small multiple of the witness size (or retaining the opcount limit).

> On Sep 30, 2017, at 6:13 PM, Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> I've put together a first draft for what I hope to be a good next step for 
> Segwit and Bitcoin scripting:
>    https://github.com/luke-jr/bips/blob/witnessv1/bip-witnessv1.mediawiki
> 
> This introduces 5 key changes:
> 
> 1. Minor versions for witnesses, inside the witness itself. Essentially the 
> witness [major] version 1 simply indicates the witness commitment is SHA256d, 
> and nothing more.
> 
> The remaining two are witness version 1.0 (major 1, minor 0):
> 
> 2. As previously discussed, undefined opcodes immediately cause the script to 
> exit with success, making future opcode softforks a lot more flexible.
> 
> 3. If the final stack element is not exactly true or false, it is interpreted 
> as a tail-call Script and executed. (Credit to Mark Friedenbach)
> 
> 4. A new shorter fixed-length signature format, eliminating the need to guess 
> the signature size in advance. All signatures are 65 bytes, unless a condition 
> script is included (see #5).
> 
> 5. The ability for signatures to commit to additional conditions, expressed in 
> the form of a serialized Script in the signature itself. This would be useful 
> in combination with OP_CHECKBLOCKATHEIGHT (BIP 115), hopefully ending the 
> whole replay protection argument by introducing it early to Bitcoin before any 
> further splits.
> 
> This last part is a big ugly right now: the signature must commit to the 
> script interpreter flags and internal "sigversion", which basically serve the 
> same purpose. The reason for this, is that otherwise someone could move the 
> signature to a different context in an attempt to exploit differences in the 
> various Script interpretation modes. I don't consider the BIP deployable 
> without this getting resolved, but I'm not sure what the best approach would 
> be. Maybe it should be replaced with a witness [major] version and witness 
> stack?
> 
> There is also draft code implementing [the consensus side of] this:
>    https://github.com/bitcoin/bitcoin/compare/master...luke-jr:witnessv1
> 
> Thoughts? Anything I've overlooked / left missing that would be 
> uncontroversial and desirable? (Is any of this unexpectedly controversial for 
> some reason?)
> 
> Luke
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From roconnor at blockstream.io  Sun Oct  1 19:05:38 2017
From: roconnor at blockstream.io (Russell O'Connor)
Date: Sun, 1 Oct 2017 15:05:38 -0400
Subject: [bitcoin-dev] Version 1 witness programs (first draft)
In-Reply-To: <D811BF0D-8286-4A40-A443-09147E4EADDD@friedenbach.org>
References: <201710010113.30518.luke@dashjr.org>
	<5A220A8D-3A85-49D0-8DB2-6BDEC362EAEB@friedenbach.org>
	<201710010247.42180.luke@dashjr.org>
	<D811BF0D-8286-4A40-A443-09147E4EADDD@friedenbach.org>
Message-ID: <CAMZUoK=1fZUeKkA6V2pFwqj-Fd-YnZD4sffP9yc0Y7vv8-XvhQ@mail.gmail.com>

Given the proposed fixed signature size, It seems better to me that we
create a SIGHASH_WITNESS_WEIGHT flag as opposed to SIGHASH_WITNESS_DEPTH.

Mark, you seem to be arguing that in general we still want weight
malleability even with witness depth fixed, but I don't understand in what
scenario we would want that.

It strikes me that is most scenarios all parties signing an input would do
so after an execution path through the script has been agreed upon by all
parties, in which case the witness weight can be fixed.
In rare cases where the smart contract requires that some parties sign in
advance of the decision about the execution path (for example, I'm thinking
about delegation here, but I want to keep my remarks general), we wouldn't
want to fix the witness depth either.

A SIGHASH_WITNESS_WEIGHT would prevent all possible malleability that would
modify the transaction's fee/weight priority (at least for that one input),
and greatly reduce the overall attack surface of witness malleability
issues.

On Sun, Oct 1, 2017 at 1:04 AM, Mark Friedenbach via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Clean stack should be eliminated for other possible future uses, the most
> obvious of which is recursive tail-call for general computation capability.
> I?m not arguing for that at this time, just arguing that we shouldn?t
> prematurely cut off an easy implementation of such should we want to. Clean
> stack must still exist as policy for future soft-fork safety, but being a
> consensus requirement was only to avoid witness malleability, which
> committing to the size of the witness also accomplishes.
>
> Committing to the number of witness elements is fully sufficient, and
> using the number of elements avoids problems of not knowing the actual size
> in bytes at the time of signing, e.g. because the witness contains a merkle
> proof generated by another party from an unbalanced tree, and unbalanced
> trees are expected to be common (so that elements can be placed higher in
> the tree in accordance with their higher expected probability of usage).
> Other future extensions might also have variable-length proofs.
>
> > On Sep 30, 2017, at 7:47 PM, Luke Dashjr <luke at dashjr.org> wrote:
> >
> > Should it perhaps commit to the length of the serialised witness data
> instead
> > or additionally? Now that signatures are no longer variable-length,
> that'd be
> > possible...
> >
> > As far as tail-call needs are concerned, CLEANSTACK wouldn't have been
> checked
> > until AFTER the tail-call in the first draft. But I suppose eliminating
> it for
> > other possible future purposes is still useful.
> >
> > Luke
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171001/61186661/attachment.html>

From mark at friedenbach.org  Sun Oct  1 19:27:21 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Sun, 1 Oct 2017 12:27:21 -0700
Subject: [bitcoin-dev] Version 1 witness programs (first draft)
In-Reply-To: <CAMZUoK=1fZUeKkA6V2pFwqj-Fd-YnZD4sffP9yc0Y7vv8-XvhQ@mail.gmail.com>
References: <201710010113.30518.luke@dashjr.org>
	<5A220A8D-3A85-49D0-8DB2-6BDEC362EAEB@friedenbach.org>
	<201710010247.42180.luke@dashjr.org>
	<D811BF0D-8286-4A40-A443-09147E4EADDD@friedenbach.org>
	<CAMZUoK=1fZUeKkA6V2pFwqj-Fd-YnZD4sffP9yc0Y7vv8-XvhQ@mail.gmail.com>
Message-ID: <460EDF1F-2BFD-4DBE-A921-73469C2EA9B9@friedenbach.org>

> On Oct 1, 2017, at 12:05 PM, Russell O'Connor <roconnor at blockstream.io> wrote:
> 
> Given the proposed fixed signature size, It seems better to me that we create a SIGHASH_WITNESS_WEIGHT flag as opposed to SIGHASH_WITNESS_DEPTH.

For what benefit? If your script actually uses all the items on the stack, and if your script is not written in such a way as to allow malleability (which cannot be prevented in general), then they?re equivalent. Using weight instead of depth only needlessly restricts other parties to select a witness size up-front.

And to be clear, signing witness weight doesn?t mean the witness is not malleable. The signer could sign again with a different ECDSA nonce. Or if the signer is signing from a 2-of-3 wallet, a common scenario I hope, there are 3 possible key combinations that could be used. If using MBV, a 3-element tree is inherently unbalanced and the common use case can have a smaller proof size.

Witnesses are not 3rd party malleable and we will maintain that property going forward with future opcodes.

> Mark, you seem to be arguing that in general we still want weight malleability even with witness depth fixed, but I don't understand in what scenario we would want that.

Any time all parties are not online at the same time in an interactive signing protocol, or for which individual parties have to reconfigure their signing choices due to failures. We should not restrict our script signature system to such a degree that it becomes difficult to create realistic signing setups for people using best practices (multi-key, 2FA, etc.) to sign. If I am a participant in a signing protocol, it would be layer violating to treat me as anything other than a black box, such that internal errors and timeouts in my signing setup don?t propagate upwards to the multi-party protocol.

For example, I should be able to try to 2FA sign, and if that fails go fetch my backup key and sign with that. But because it?s my infrequently used backup key, it might be placed deeper in the key tree and therefore signatures using it are larger. All the other signers need care is that slot #3 in the witness is where my Merkle proof goes. They shouldn?t have to restart and resign because my proof was a little larger than anticipated ? and maybe they can?t resign because double-spend protections!


From roconnor at blockstream.io  Sun Oct  1 19:41:46 2017
From: roconnor at blockstream.io (Russell O'Connor)
Date: Sun, 1 Oct 2017 15:41:46 -0400
Subject: [bitcoin-dev] Version 1 witness programs (first draft)
In-Reply-To: <460EDF1F-2BFD-4DBE-A921-73469C2EA9B9@friedenbach.org>
References: <201710010113.30518.luke@dashjr.org>
	<5A220A8D-3A85-49D0-8DB2-6BDEC362EAEB@friedenbach.org>
	<201710010247.42180.luke@dashjr.org>
	<D811BF0D-8286-4A40-A443-09147E4EADDD@friedenbach.org>
	<CAMZUoK=1fZUeKkA6V2pFwqj-Fd-YnZD4sffP9yc0Y7vv8-XvhQ@mail.gmail.com>
	<460EDF1F-2BFD-4DBE-A921-73469C2EA9B9@friedenbach.org>
Message-ID: <CAMZUoK=heF1FALyGbi7cpzLiQuhLnsq-5Z2-sTgq5b28sjjeUw@mail.gmail.com>

On Sun, Oct 1, 2017 at 3:27 PM, Mark Friedenbach <mark at friedenbach.org>
wrote:

> > On Oct 1, 2017, at 12:05 PM, Russell O'Connor <roconnor at blockstream.io>
> wrote:
> >
> > Given the proposed fixed signature size, It seems better to me that we
> create a SIGHASH_WITNESS_WEIGHT flag as opposed to SIGHASH_WITNESS_DEPTH.
>
> For what benefit? If your script actually uses all the items on the stack,
> and if your script is not written in such a way as to allow malleability
> (which cannot be prevented in general), then they?re equivalent. Using
> weight instead of depth only needlessly restricts other parties to select a
> witness size up-front.
>

Creating a Bitcoin script that does not allow malleability is difficult and
requires wasting a lot of bytes to do so, typically when handling issues
around non-0-or-1 witness values being used with OP_IF, and dealing with
non-standard-zero values, etc.  Adding a witness weight flag cuts through
the worst of all this, and makes script design enormously simpler and makes
scripts smaller and cheaper.


> And to be clear, signing witness weight doesn?t mean the witness is not
> malleable. The signer could sign again with a different ECDSA nonce. Or if
> the signer is signing from a 2-of-3 wallet, a common scenario I hope, there
> are 3 possible key combinations that could be used. If using MBV, a
> 3-element tree is inherently unbalanced and the common use case can have a
> smaller proof size.
>
> Witnesses are not 3rd party malleable and we will maintain that property
> going forward with future opcodes.
>
> > Mark, you seem to be arguing that in general we still want weight
> malleability even with witness depth fixed, but I don't understand in what
> scenario we would want that.
>
> Any time all parties are not online at the same time in an interactive
> signing protocol, or for which individual parties have to reconfigure their
> signing choices due to failures. We should not restrict our script
> signature system to such a degree that it becomes difficult to create
> realistic signing setups for people using best practices (multi-key, 2FA,
> etc.) to sign. If I am a participant in a signing protocol, it would be
> layer violating to treat me as anything other than a black box, such that
> internal errors and timeouts in my signing setup don?t propagate upwards to
> the multi-party protocol.
>
> For example, I should be able to try to 2FA sign, and if that fails go
> fetch my backup key and sign with that. But because it?s my infrequently
> used backup key, it might be placed deeper in the key tree and therefore
> signatures using it are larger. All the other signers need care is that
> slot #3 in the witness is where my Merkle proof goes. They shouldn?t have
> to restart and resign because my proof was a little larger than anticipated
> ? and maybe they can?t resign because double-spend protections!
>

I'll argue that I don't want my counter-party going off and using a very
deeply nested key in order to subvert the fee rate we've agreed upon after
I've signed my part of the input.  If we are doing multi-party signing of
inputs we need to communicate anyways to construct the transaction.  I see
no problem with requiring my counter-party to choose their keys before I
sign so that I know up front what our fee rate is going to be.  If they
lose their keys and need a backup, they should have to come back to me to
resign in order that we can negotiate a new fee rate for the transaction
and who is going to be covering how much of the fee and on which inputs.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171001/a587d6ba/attachment.html>

From mark at friedenbach.org  Sun Oct  1 20:39:11 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Sun, 1 Oct 2017 13:39:11 -0700
Subject: [bitcoin-dev] Version 1 witness programs (first draft)
In-Reply-To: <CAMZUoK=heF1FALyGbi7cpzLiQuhLnsq-5Z2-sTgq5b28sjjeUw@mail.gmail.com>
References: <201710010113.30518.luke@dashjr.org>
	<5A220A8D-3A85-49D0-8DB2-6BDEC362EAEB@friedenbach.org>
	<201710010247.42180.luke@dashjr.org>
	<D811BF0D-8286-4A40-A443-09147E4EADDD@friedenbach.org>
	<CAMZUoK=1fZUeKkA6V2pFwqj-Fd-YnZD4sffP9yc0Y7vv8-XvhQ@mail.gmail.com>
	<460EDF1F-2BFD-4DBE-A921-73469C2EA9B9@friedenbach.org>
	<CAMZUoK=heF1FALyGbi7cpzLiQuhLnsq-5Z2-sTgq5b28sjjeUw@mail.gmail.com>
Message-ID: <BC800737-7B93-41BD-BA87-F25B25F95426@friedenbach.org>


> On Oct 1, 2017, at 12:41 PM, Russell O'Connor <roconnor at blockstream.io> wrote:
> 
> Creating a Bitcoin script that does not allow malleability is difficult and requires wasting a lot of bytes to do so, typically when handling issues around non-0-or-1 witness values being used with OP_IF, and dealing with non-standard-zero values, etc.

Script validation flags of the correct place to do this. We already have policy validation flags that check for these things. They were not made consensus rules with Segwit v0 mainly due to concern over scope creep in an already large overhaul, of my memory is correct. Script versions and quadratic hashing fixes where the minimum necessary to allow segwit to activate safely while still enabling future upgrades that would otherwise have been hard forks. We knew that we would be later changing the EC signature scheme to be something that supported signature aggregation, and that would be more appropriate time to discuss such changes. As we are considering to do now (although witness versions means we don?t need to omnibus the script upgrade here either, so a v1 before signature aggregation is ready is fine IMHO).

In any case if there is any general witness malleability due to opcode semantics that it?s not fixed by one of our existing policy flags, that is a bug and I would encourage you to report it.
> I'll argue that I don't want my counter-party going off and using a very deeply nested key in order to subvert the fee rate we've agreed upon after I've signed my part of the input.  If we are doing multi-party signing of inputs we need to communicate anyways to construct the transaction.  I see no problem with requiring my counter-party to choose their keys before I sign so that I know up front what our fee rate is going to be.  If they lose their keys and need a backup, they should have to come back to me to resign in order that we can negotiate a new fee rate for the transaction and who is going to be covering how much of the fee and on which inputs.

Arguing that every single user should be forced to restart an interactive signing session. That?s a very strong statement based on something that I would say is a preference that depends on circumstances.

What about an optional commitment to witness size in bytes? The value zero meaning ?I don?t care.? I would argue that it should be a maximum however, and therefor serialized as part of the witness. The serialization of this would be very compact (1 plus the difference between actual and maximum, with zero meaning not used.)

From luke at dashjr.org  Sun Oct  1 20:43:18 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Sun, 1 Oct 2017 20:43:18 +0000
Subject: [bitcoin-dev] Version 1 witness programs (first draft)
In-Reply-To: <BC800737-7B93-41BD-BA87-F25B25F95426@friedenbach.org>
References: <201710010113.30518.luke@dashjr.org>
	<CAMZUoK=heF1FALyGbi7cpzLiQuhLnsq-5Z2-sTgq5b28sjjeUw@mail.gmail.com>
	<BC800737-7B93-41BD-BA87-F25B25F95426@friedenbach.org>
Message-ID: <201710012043.18742.luke@dashjr.org>

On Sunday 01 October 2017 8:39:11 PM Mark Friedenbach wrote:
> What about an optional commitment to witness size in bytes? The value zero
> meaning ?I don?t care.? I would argue that it should be a maximum however,
> and therefor serialized as part of the witness. The serialization of this
> would be very compact (1 plus the difference between actual and maximum,
> with zero meaning not used.)

Could just do SIGHASH_WITNESS_SIZE in addition to SIGHASH_WITNESS_DEPTH...

From jl2012 at xbt.hk  Sun Oct  1 21:32:56 2017
From: jl2012 at xbt.hk (Johnson Lau)
Date: Mon, 2 Oct 2017 05:32:56 +0800
Subject: [bitcoin-dev] Version 1 witness programs (first draft)
In-Reply-To: <201710010113.30518.luke@dashjr.org>
References: <201710010113.30518.luke@dashjr.org>
Message-ID: <30B31B43-B603-4793-BDFB-B7E25FD96D1B@xbt.hk>

So there are 3 proposals with similar goal but different designs. I try to summarise some questions below:

1. How do we allow further upgrade within v1 witness? Here are some options:
a. Minor version in witness. (Johnson / Luke) I prefer this way, but we may end up with many minor versions.
b. OP_RETURNTRUE (Luke). I proposed this in an earlier version of BIP114 but now I think it doesn?t interact well with signature aggregation, and I worry that it would have some other unexpected effects.
c. Generalised NOP method: user has to provide the returned value, so even VERIFY-type code could do anything

2. Do we want to allow signature-time commitment of extra scripts?
I think all proposals allow this, just with different way
a. Tail-call semantics with CHECKSIGFROMSTACK (Mark). I think this is too rigid as it works only with specially designed scriptPubKey
b. scriptWitCode: extra scripts are put in some fixed location in witness (Johnson). This makes sure static analysability.
c. Extra-data as script in OP_CHECKSIG (Luke)

3. Do we want to allow static analysis of sigop?
BIP114 and the related proposals are specifically designed to allow static analysis of sigop. I think this was one of the main reason of OP_EVAL not being accepted. This was also the main reason of Ethereum failing to do a DAO hacker softfork, leading to the ETH/ETC split. I?m not sure if we really want to give up this property. Once we do it, we have to support it forever.

??
Johnson

From mark at friedenbach.org  Mon Oct  2 00:35:38 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Sun, 1 Oct 2017 17:35:38 -0700
Subject: [bitcoin-dev] Version 1 witness programs (first draft)
In-Reply-To: <30B31B43-B603-4793-BDFB-B7E25FD96D1B@xbt.hk>
References: <201710010113.30518.luke@dashjr.org>
	<30B31B43-B603-4793-BDFB-B7E25FD96D1B@xbt.hk>
Message-ID: <50CA8523-3D1A-409E-9B7D-51EA5FC4B898@friedenbach.org>


> On Oct 1, 2017, at 2:32 PM, Johnson Lau <jl2012 at xbt.hk> wrote:
> 
> So there are 3 proposals with similar goal but different designs. I try to summarise some questions below:
> 
> 1. How do we allow further upgrade within v1 witness? Here are some options:
> a. Minor version in witness. (Johnson / Luke) I prefer this way, but we may end up with many minor versions.

I'm not sure I agree with the "minor version" nomenclature, or that we would necessarily end up with any consensus-visible fields beyond 2.  There are two separate soft-fork version fields that were, I think it is fair to say now, inappropriately merged in the "script version? feature of segregated witness as described in BIP141.

First there is the witness type, which combined with the length of the commitment that follows specifies how data from the witness stack is used to calculate/verify the witness commitment in the scriptPubKey of the output being spent.  For v0 with a 20-byte hash, it says that those 20 bytes are the HASH160 of the top element of the stack.  For v0 with a 32-byte hash, it says that those 32 bytes are the HASH256 of the top element of the stack.

Second there is the script version, which is not present as a separate field for witness type v0.  Implicitly though, the script version for v0,20-byte is that the witness consists of two elements, and these are interpreted as a pubkey and a signature.  For v0,32-byte the script version is that the witness consists of 1 or more elements; with max 520 byte size constraints for all but the top element, which has a higher limit of 10,000 bytes; and the top-most element is interpreted as a script and executed with the modified CHECKSIG behavior defined by BIP141 and the CLEANSTACK rule enforced.

These are separate roles, one not being derivative of the other.  In an ideal world the witness type (of which there are only 16 remaining without obsoleting BIP141) is used only to specify a new function for transforming the witness stack into a commitment for verification purposes.  Merklized script would be one example: v2,32-byte could be defined to require a witness stack of at least two elements, the top most of which is a Merkle inclusion proof of the second item in a tree whose root is given in the 32-byte payload of the output.  Maybe v3 would prove inclusion by means of some sort of RSA accumulator or something.

Such a specification says nothing about the features of the subscript drawn from the Merkle tree, or even whether it is bitcoin script at all vs something else (Simplicity, DEX, RISC-V, Joy, whatever).  All that is necessary is that a convention be adopted about where to find the script version from whatever data is left on the stack after doing the witness type check (hashing the script, calculating a Merkle root, checking inclusion in an RSA accumulator, whatever).  A simple rule is that it is serialized and prefixed to the beginning of the string that was checked against the commitment in the output.

So v0,32-byte says that the top item is hashed and that hash must match the 32-byte value in the output.  This new v1,32-byte witness type being talked about in this thread would have exactly the same hashing rules, but will execute the resulting string based on its prefix, the script version, which is first removed before execution.

Sure first script version used could be a cleaned up script with a bunch of the weirdness removed (CHECKMULTISIG, I'm looking at you!); CLTV, CSV, and MBV drop arguments; disabled opcodes and unassigned NOPs become "return true"; etc.  Maybe v2 adds new opcodes.  But we can imagine script version that do something totally different, like introduce a new script based on a strongly-typed Merklized lambda calculus, or a RISC-V executable format, or whatever.

This has pragmatic implications with the separation of witness type and script version: we could then define a "MAST" output that proves the script used is drawn from a set represented by the Merkle tree.  However different scripts in that tree can use different versions.  It would be useful if the most common script is the key aggregated everyone-signs outcome, which looks like a regular bitcoin payment, and then contingency cases can be handled by means of a complicated script written in some newly added general computation language or a whole emulated RISC-V virtual machine.

> b. OP_RETURNTRUE (Luke). I proposed this in an earlier version of BIP114 but now I think it doesn?t interact well with signature aggregation, and I worry that it would have some other unexpected effects.
> c. Generalised NOP method: user has to provide the returned value, so even VERIFY-type code could do anything

I see no reason to do either. Gate new behavior based on script execution flags, which are set based on the script version.  Script versions not understood are treated as "return true" to begin with.  The interpreter isn't even going to try to decode the script according to the old rules, let alone try to execute it, so there's no reason for the old soft-fork compatability tricks.

The new soft-fork trick is that you increment the script version number.  That is all.

> 2. Do we want to allow signature-time commitment of extra scripts?
> I think all proposals allow this, just with different way
> a. Tail-call semantics with CHECKSIGFROMSTACK (Mark). I think this is too rigid as it works only with specially designed scriptPubKey

This is not signature-time commitment of extra script. Not without CHECKSIGFROMSTACK or something like it.

> b. scriptWitCode: extra scripts are put in some fixed location in witness (Johnson). This makes sure static analysability.
> c. Extra-data as script in OP_CHECKSIG (Luke)

Propose these as their own script updates.  Script versioning makes such new features cheap.  There's no reason to create some sort of complex omnibus overhaul that does everything.

> 3. Do we want to allow static analysis of sigop?
> BIP114 and the related proposals are specifically designed to allow static analysis of sigop. I think this was one of the main reason of OP_EVAL not being accepted. This was also the main reason of Ethereum failing to do a DAO hacker softfork, leading to the ETH/ETC split. I?m not sure if we really want to give up this property. Once we do it, we have to support it forever.

Again, this is off-topic for this thread.  I don't think a v1 witness type upgrade should do any of these things.  The v1 witness type should add a proper script version in the witness, and remove or simplify limits or unnecessary verification rules that are no longer necessary and/or hindering progress.  That?s it.

For example, I don't think a v1 witness version should be coupled with my tail-call semantics or the introduction of MERKLEBRANCHVERIFY (but if MBV was released already we could have it drop its arguments, which would be nice).  However it should drop the CLEANSTACK rule in favor of something else (like signatures committing to the witness depth and/or weight) since the tail-call BIP demonstrates it to be an impediment to extensibility and alternatives are not.  And it should drop the 520 byte push limitation, as the MBV BIP demonstrates use cases that have serialized proofs larger than that, like a k-of-N threshold with N=16.

From luke at dashjr.org  Mon Oct  2 00:45:22 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Mon, 2 Oct 2017 00:45:22 +0000
Subject: [bitcoin-dev] Version 1 witness programs (first draft)
In-Reply-To: <30B31B43-B603-4793-BDFB-B7E25FD96D1B@xbt.hk>
References: <201710010113.30518.luke@dashjr.org>
	<30B31B43-B603-4793-BDFB-B7E25FD96D1B@xbt.hk>
Message-ID: <201710020045.30259.luke@dashjr.org>

On Sunday 01 October 2017 9:32:56 PM Johnson Lau wrote:
> 1. How do we allow further upgrade within v1 witness? Here are some
> options: a. Minor version in witness. (Johnson / Luke) I prefer this way,
> but we may end up with many minor versions. b. OP_RETURNTRUE (Luke). I
> proposed this in an earlier version of BIP114 but now I think it doesn?t
> interact well with signature aggregation, and I worry that it would have
> some other unexpected effects. c. Generalised NOP method: user has to
> provide the returned value, so even VERIFY-type code could do anything

I like (A) and (B). Use B when practical, and (A) when more fundamental 
changes are needed. SigAgg is a concern, but there are ways to adapt it.

(C) is harmless, but I think unnecessary with (A) and/or (B).

> 2. Do we want to allow signature-time commitment of extra scripts?
> I think all proposals allow this, just with different way
> a. Tail-call semantics with CHECKSIGFROMSTACK (Mark). I think this is too
> rigid as it works only with specially designed scriptPubKey b.
> scriptWitCode: extra scripts are put in some fixed location in witness
> (Johnson). This makes sure static analysability. c. Extra-data as script
> in OP_CHECKSIG (Luke)

Note that my BIP draft supports both (A) and (C).

> 3. Do we want to allow static analysis of sigop?
> BIP114 and the related proposals are specifically designed to allow static
> analysis of sigop. I think this was one of the main reason of OP_EVAL not
> being accepted. This was also the main reason of Ethereum failing to do a
> DAO hacker softfork, leading to the ETH/ETC split. I?m not sure if we
> really want to give up this property. Once we do it, we have to support it
> forever.

It seems inevitable at this point. Maybe we could add a separate "executable-
witness" array (in the same manner as the current witness was softforked in), 
and require tail-call and condition scripts to merely reference these by hash, 
but I'm not sure it's worth the effort?

Thinking further, we could avoid adding a separate executable-witness 
commitment by either:
A) Define that all the witness elements in v1 are type-tagged (put the minor
   witness version on them all, and redefine minor 0 as a stack item?); or
B) Use an empty element as a delimiter between stack and executable items.

To avoid witness malleability, the executable items can be required to be 
sorted in some manner.

The downside of these approaches is that we now need an addition 20 or 32 
bytes per script reference... which IMO may possibly be worse than losing 
static analysis. I wonder if there's a way to avoid that overhead?

Luke

From luke at dashjr.org  Mon Oct  2 02:56:27 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Mon, 2 Oct 2017 02:56:27 +0000
Subject: [bitcoin-dev] Version 1 witness programs (first draft)
In-Reply-To: <50CA8523-3D1A-409E-9B7D-51EA5FC4B898@friedenbach.org>
References: <201710010113.30518.luke@dashjr.org>
	<30B31B43-B603-4793-BDFB-B7E25FD96D1B@xbt.hk>
	<50CA8523-3D1A-409E-9B7D-51EA5FC4B898@friedenbach.org>
Message-ID: <201710020256.27964.luke@dashjr.org>

On Monday 02 October 2017 12:35:38 AM Mark Friedenbach wrote:
> > b. OP_RETURNTRUE (Luke). I proposed this in an earlier version of BIP114
> > but now I think it doesn?t interact well with signature aggregation, and
> > I worry that it would have some other unexpected effects. c. Generalised
> > NOP method: user has to provide the returned value, so even VERIFY-type
> > code could do anything
> 
> I see no reason to do either. Gate new behavior based on script execution
> flags, which are set based on the script version.  Script versions not
> understood are treated as "return true" to begin with.  The interpreter
> isn't even going to try to decode the script according to the old rules,
> let alone try to execute it, so there's no reason for the old soft-fork
> compatability tricks.
> 
> The new soft-fork trick is that you increment the script version number. 
> That is all.

This breaks parallel softfork deployments.

> > b. scriptWitCode: extra scripts are put in some fixed location in witness
> > (Johnson). This makes sure static analysability. c. Extra-data as script
> > in OP_CHECKSIG (Luke)
> 
> Propose these as their own script updates.  Script versioning makes such
> new features cheap.  There's no reason to create some sort of complex
> omnibus overhaul that does everything.

Only if there's common code to implement both versions, which doesn't work if 
the changes from A to B to C are drastic. To avoid such drastic changes, the 
overall design/layout needs to at least be planned to cover the desired use 
cases in advance.

Luke

From sjors at sprovoost.nl  Mon Oct  2 09:09:00 2017
From: sjors at sprovoost.nl (Sjors Provoost)
Date: Mon, 2 Oct 2017 10:09:00 +0100
Subject: [bitcoin-dev] Version 1 witness programs (first draft)
In-Reply-To: <201710020256.27964.luke@dashjr.org>
References: <201710010113.30518.luke@dashjr.org>
	<30B31B43-B603-4793-BDFB-B7E25FD96D1B@xbt.hk>
	<50CA8523-3D1A-409E-9B7D-51EA5FC4B898@friedenbach.org>
	<201710020256.27964.luke@dashjr.org>
Message-ID: <C248375C-FEE3-4DDC-96DE-FA62CE665369@sprovoost.nl>

Op 2 okt. 2017, om 03:56 heeft Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:
> 
> On Monday 02 October 2017 12:35:38 AM Mark Friedenbach wrote:
>>> b. OP_RETURNTRUE (Luke). I proposed this in an earlier version of BIP114
>>> but now I think it doesn?t interact well with signature aggregation, and
>>> I worry that it would have some other unexpected effects. c. Generalised
>>> NOP method: user has to provide the returned value, so even VERIFY-type
>>> code could do anything
>> 
>> I see no reason to do either. Gate new behavior based on script execution
>> flags, which are set based on the script version.  Script versions not
>> understood are treated as "return true" to begin with.  The interpreter
>> isn't even going to try to decode the script according to the old rules,
>> let alone try to execute it, so there's no reason for the old soft-fork
>> compatability tricks.
>> 
>> The new soft-fork trick is that you increment the script version number.
>> That is all.
> 
> This breaks parallel softfork deployments.

If unknown script versions are treated as "return true", there's no need for versions to be deployed in sequence, right? Maybe they should be called numbered script types, rather than script versions.

Sjors
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171002/99d0f6a0/attachment.sig>

From roconnor at blockstream.io  Mon Oct  2 17:15:38 2017
From: roconnor at blockstream.io (Russell O'Connor)
Date: Mon, 2 Oct 2017 13:15:38 -0400
Subject: [bitcoin-dev] Merkle branch verification & tail-call semantics
 for generalized MAST
In-Reply-To: <921EB5CF-B472-4BD6-9493-1A681586FB51@friedenbach.org>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
	<201709302323.33004.luke@dashjr.org>
	<921EB5CF-B472-4BD6-9493-1A681586FB51@friedenbach.org>
Message-ID: <CAMZUoK=SwR6=vWCo54_Yd11nbbwD0q60n42Uj38Yq_sWD2zS9g@mail.gmail.com>

(Subject was: [bitcoin-dev] Version 1 witness programs (first draft)), but
I'm moving part of that conversation to this thread.

On Sun, Oct 1, 2017 at 5:32 PM, Johnson Lau <jl2012 at xbt.hk> wrote:

> 3. Do we want to allow static analysis of sigop?
> BIP114 and the related proposals are specifically designed to allow static
> analysis of sigop. I think this was one of the main reason of OP_EVAL not
> being accepted. This was also the main reason of Ethereum failing to do a
> DAO hacker softfork, leading to the ETH/ETC split. I?m not sure if we
> really want to give up this property. Once we do it, we have to support it
> forever.


I would very much like to retain the ability to do static analysis.  More
generally, the idea of interpreting arbitrary data as code, as done in
OP_EVAL and in TAILCALL, makes me quite anxious.  This at the root of many
security problems throughout the software industry, and I don't relish
giving more fuel to the underhanded Bitcoin Script contestants.

On Sun, Oct 1, 2017 at 8:45 PM, Luke Dashjr <luke at dashjr.org> wrote:

> > 3. Do we want to allow static analysis of sigop?
> > BIP114 and the related proposals are specifically designed to allow
> static
> > analysis of sigop. I think this was one of the main reason of OP_EVAL not
> > being accepted. This was also the main reason of Ethereum failing to do a
> > DAO hacker softfork, leading to the ETH/ETC split. I?m not sure if we
> > really want to give up this property. Once we do it, we have to support
> it
> > forever.
>
> It seems inevitable at this point. Maybe we could add a separate
> "executable-
> witness" array (in the same manner as the current witness was softforked
> in),
> and require tail-call and condition scripts to merely reference these by
> hash,
> but I'm not sure it's worth the effort?
>
> Thinking further, we could avoid adding a separate executable-witness
> commitment by either:
> A) Define that all the witness elements in v1 are type-tagged (put the
> minor
>    witness version on them all, and redefine minor 0 as a stack item?); or
> B) Use an empty element as a delimiter between stack and executable items.
>
> To avoid witness malleability, the executable items can be required to be
> sorted in some manner.
>
> The downside of these approaches is that we now need an addition 20 or 32
> bytes per script reference... which IMO may possibly be worse than losing
> static analysis. I wonder if there's a way to avoid that overhead?
>

Actually, I have a half-baked idea I've been thinking about along these
lines.

The idea is to add a flag to each stack item in the Script interpreter to
mark whether the item in the stack is "executable" or "non-executable", not
so different from how computers mark pages to implement executable space
protection.  By default, all stack items are marked "non-executable".  We
then redefine OP_PUSHDATA4 as OP_PUSHCODE within ScriptSigs.  The
operational semantics of OP_PUSHCODE would remain the same as OP_PUSHDATA4
except it would set the pushed item's associated flag to "executable".  All
data pushed by OP_PUSHCODE would be subject to the sigops limits and any
other similar static analysis limits.

Segwit v0 doesn't use OP_PUSHDATA codes to create the input stack, so we
would have to mark executable input stack items using a new witness v1
format. But, IIUC, TAILCALL isn't going to be compatible with Segwit v0
anyway.

During a TAILCALL, it is required that the top item on the stack have the
"executable" flag, otherwise TAILCALL is not used (and the script succeeds
or fails based on the top item's data value as usual).

All other operations can treat "executable" items as data, including the
merkle branch verification.  None of the Script operations can create
"executable" items; in particular, OP_PUSHDATA4 within the ScriptPubKey
also would not create "executable" items.  (We can talk about the behaviour
of OP_CAT when that time comes).

One last trick is that when "executable" values are duplicated, by OP_DUP,
OP_IFDUP, OP_PICK. then the newly created copy of the value on top of the
stack is marked "non-executable".

Because we make the "executable" flag non-copyable, we are now free to
allow unbounded uses of TAILCALL (i.e. TAILCALL can be used multiplie times
in a single input).  Why is this safe?  Because the number of "executable"
items decreases by at least one every time TAILCALL is invoked. the number
of OP_PUSHCODE occurrences in the witness puts an upper bound on the number
of invocations of TAILCALL allowed.  Using static analysis of the script
pubkey and the data within the OP_PUSHCODE data, we compute an upper bound
on the number of operations (of any type) that can occur during execution.

Unbounded TAILCALL should let us (in the presence of OP_CHECKSIGFROMSTACK)
have unbounded delegation.

Overall, I believe that OP_PUSHCODE

1. is fully backwards compatible.
2. maintains our ability to perform static analysis with TAILCALL.
3. never lets us interpret computed values as executable code.
4. extends TAILCALL to safely allow multiple TAILCALLs per script.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171002/794f9cab/attachment-0001.html>

From roconnor at blockstream.io  Mon Oct  2 20:38:49 2017
From: roconnor at blockstream.io (Russell O'Connor)
Date: Mon, 2 Oct 2017 16:38:49 -0400
Subject: [bitcoin-dev] Version 1 witness programs (first draft)
In-Reply-To: <BC800737-7B93-41BD-BA87-F25B25F95426@friedenbach.org>
References: <201710010113.30518.luke@dashjr.org>
	<5A220A8D-3A85-49D0-8DB2-6BDEC362EAEB@friedenbach.org>
	<201710010247.42180.luke@dashjr.org>
	<D811BF0D-8286-4A40-A443-09147E4EADDD@friedenbach.org>
	<CAMZUoK=1fZUeKkA6V2pFwqj-Fd-YnZD4sffP9yc0Y7vv8-XvhQ@mail.gmail.com>
	<460EDF1F-2BFD-4DBE-A921-73469C2EA9B9@friedenbach.org>
	<CAMZUoK=heF1FALyGbi7cpzLiQuhLnsq-5Z2-sTgq5b28sjjeUw@mail.gmail.com>
	<BC800737-7B93-41BD-BA87-F25B25F95426@friedenbach.org>
Message-ID: <CAMZUoKnf5VYYKgKjcq-_vAjbStXnqr3SVZweLHak+XB975JrrQ@mail.gmail.com>

On Sun, Oct 1, 2017 at 4:39 PM, Mark Friedenbach <mark at friedenbach.org>
wrote:

>
> > On Oct 1, 2017, at 12:41 PM, Russell O'Connor <roconnor at blockstream.io>
> wrote:
> >
> > Creating a Bitcoin script that does not allow malleability is difficult
> and requires wasting a lot of bytes to do so, typically when handling
> issues around non-0-or-1 witness values being used with OP_IF, and dealing
> with non-standard-zero values, etc.
>
> Script validation flags of the correct place to do this. We already have
> policy validation flags that check for these things. They were not made
> consensus rules with Segwit v0 mainly due to concern over scope creep in an
> already large overhaul, of my memory is correct. Script versions and
> quadratic hashing fixes where the minimum necessary to allow segwit to
> activate safely while still enabling future upgrades that would otherwise
> have been hard forks. We knew that we would be later changing the EC
> signature scheme to be something that supported signature aggregation, and
> that would be more appropriate time to discuss such changes. As we are
> considering to do now (although witness versions means we don?t need to
> omnibus the script upgrade here either, so a v1 before signature
> aggregation is ready is fine IMHO).
>

Script validation isn't the correct place to do this.  The reason is that
script operations are not aware of whether the stack items they are
processing are witness malleable items or Script computed values.  Let me
take OP_IF as one example.  When OP_IF operates directly on witness data,
it is subject to witness malleability, and therefore one needs to add extra
code around that to prevent witness malleability.  On the other hand, when
OP_IF operates on computed data, it isn't subject to malleability and can
safely process non-zero-or-one values. If OP_IF were restricted to
requiring canonical inputs, then for the cases that OP_IF operates on
computed data, they will need to add extra code to canonicalize their
inputs.  I don't think there is a correct answer here.  That is because I
believe this isn't the correct place to aim to restrict witness
malleability.

OTOH, signatures are a fine place to aim to restrict witness malleability.
In fact, if signatures could securely cover all witness data, I think
everyone here would jump at the opportunity to implement that.  However,
since that isn't known to be possible, we are left with doing the best we
can, which is to have signatures cover weight (or bytes).  This prevents
the worst effects of witness malleability and does so without burdening
Script development.  (This also requires signatures have a fixed size, so
it is understandable that signature-covers-weight wasn't included in Segwit
v0 scripts).


> In any case if there is any general witness malleability due to opcode
> semantics that it?s not fixed by one of our existing policy flags, that is
> a bug and I would encourage you to report it.
> > I'll argue that I don't want my counter-party going off and using a very
> deeply nested key in order to subvert the fee rate we've agreed upon after
> I've signed my part of the input.  If we are doing multi-party signing of
> inputs we need to communicate anyways to construct the transaction.  I see
> no problem with requiring my counter-party to choose their keys before I
> sign so that I know up front what our fee rate is going to be.  If they
> lose their keys and need a backup, they should have to come back to me to
> resign in order that we can negotiate a new fee rate for the transaction
> and who is going to be covering how much of the fee and on which inputs.
>
> Arguing that every single user should be forced to restart an interactive
> signing session. That?s a very strong statement based on something that I
> would say is a preference that depends on circumstances.
>
> What about an optional commitment to witness size in bytes? The value zero
> meaning ?I don?t care.? I would argue that it should be a maximum however,
> and therefor serialized as part of the witness. The serialization of this
> would be very compact (1 plus the difference between actual and maximum,
> with zero meaning not used.)


I would be fine your suggestion above, though I think Luke's suggestion of
having both SIGHASH_WITNESS_SIZE and SIGHASH_WITNESS_DEPTH flag is better
because it is simpler.

Those people worried about restarting interactive signing session in the
unlikely event of parties not knowing what keys they are planning to use
can use just the SIGHASH_WITNESS_DEPTH flag.  Those people worried about
counterparties fiddling with fee rates can use both flags.  The choice
doesn't even need to be made at script commitment time.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171002/36c4797d/attachment.html>

From mark at friedenbach.org  Thu Oct  5 20:33:56 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Thu, 5 Oct 2017 13:33:56 -0700
Subject: [bitcoin-dev] Version 1 witness programs (first draft)
In-Reply-To: <201710010113.30518.luke@dashjr.org>
References: <201710010113.30518.luke@dashjr.org>
Message-ID: <AEABDAC5-AAFB-4345-BD0D-4F61CA075A1C@friedenbach.org>

Here?s an additional (uncontroversial?) idea due to Russell O?Connor:

Instead of requiring that the last item popped off the stack in a CHECKMULTISIG be zero, have it instead be required that it is a bitfield specifying which pubkeys are used, or more likely the complement thereof. This allows signatures to be matched to pubkeys in the order given, and batch validated, with no risk of 3rd party malleability.

Mark

> On Sep 30, 2017, at 6:13 PM, Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> I've put together a first draft for what I hope to be a good next step for 
> Segwit and Bitcoin scripting:
>    https://github.com/luke-jr/bips/blob/witnessv1/bip-witnessv1.mediawiki
> 
> This introduces 5 key changes:
> 
> 1. Minor versions for witnesses, inside the witness itself. Essentially the 
> witness [major] version 1 simply indicates the witness commitment is SHA256d, 
> and nothing more.
> 
> The remaining two are witness version 1.0 (major 1, minor 0):
> 
> 2. As previously discussed, undefined opcodes immediately cause the script to 
> exit with success, making future opcode softforks a lot more flexible.
> 
> 3. If the final stack element is not exactly true or false, it is interpreted 
> as a tail-call Script and executed. (Credit to Mark Friedenbach)
> 
> 4. A new shorter fixed-length signature format, eliminating the need to guess 
> the signature size in advance. All signatures are 65 bytes, unless a condition 
> script is included (see #5).
> 
> 5. The ability for signatures to commit to additional conditions, expressed in 
> the form of a serialized Script in the signature itself. This would be useful 
> in combination with OP_CHECKBLOCKATHEIGHT (BIP 115), hopefully ending the 
> whole replay protection argument by introducing it early to Bitcoin before any 
> further splits.
> 
> This last part is a big ugly right now: the signature must commit to the 
> script interpreter flags and internal "sigversion", which basically serve the 
> same purpose. The reason for this, is that otherwise someone could move the 
> signature to a different context in an attempt to exploit differences in the 
> various Script interpretation modes. I don't consider the BIP deployable 
> without this getting resolved, but I'm not sure what the best approach would 
> be. Maybe it should be replaced with a witness [major] version and witness 
> stack?
> 
> There is also draft code implementing [the consensus side of] this:
>    https://github.com/bitcoin/bitcoin/compare/master...luke-jr:witnessv1
> 
> Thoughts? Anything I've overlooked / left missing that would be 
> uncontroversial and desirable? (Is any of this unexpectedly controversial for 
> some reason?)
> 
> Luke
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From roconnor at blockstream.io  Thu Oct  5 21:28:48 2017
From: roconnor at blockstream.io (Russell O'Connor)
Date: Thu, 5 Oct 2017 17:28:48 -0400
Subject: [bitcoin-dev] Version 1 witness programs (first draft)
In-Reply-To: <AEABDAC5-AAFB-4345-BD0D-4F61CA075A1C@friedenbach.org>
References: <201710010113.30518.luke@dashjr.org>
	<AEABDAC5-AAFB-4345-BD0D-4F61CA075A1C@friedenbach.org>
Message-ID: <CAMZUoKm09EALbX8Jk2_26uX6hm2u1a3=B6UTaLSWqeG_8SXPSw@mail.gmail.com>

On Thu, Oct 5, 2017 at 4:33 PM, Mark Friedenbach via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Here?s an additional (uncontroversial?) idea due to Russell O?Connor:
>

For the record, it's Johnson Lau's proposal where I read this idea.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171005/3dc6a749/attachment.html>

From bit.kevin at gmail.com  Tue Oct  3 15:52:16 2017
From: bit.kevin at gmail.com (=?UTF-8?B?5r2Y5b+X5b2q?=)
Date: Tue, 3 Oct 2017 23:52:16 +0800
Subject: [bitcoin-dev] A solution may solve Block Withholding Attack
Message-ID: <CA+fZXJKuE_C7231-OHM2gvFUYBKjfoDoOfh+04YqHZuQF41eag@mail.gmail.com>

Here is a solution may solve Block Withholding Attack. The general idea is
came from Aviv Zohar(avivz at cs.huji.ac.il), I made it work for Bitcoin.
Anyway, thanks Aviv.

=====================

DIFF_1 = 0x00000000FFFF0000000000000000000000000000000000000000000000000000;

Diff = DIFF_1 / target

this is equal to

Diff = DIFF_1 / (target - 0) or Diff = DIFF_1 / abs(target - 0)

now, we change diff algo to below:

New_Diff = DIFF_1 / abs(target - offset)

Offset is 32 bytes, like uint256 in Bitcoin, range is [0, 2^256),
define: offset_hash = DSHA256(offset).

we need to do a little change to the merkle root hash algo, put the
offset_hash as a tx hash in the front of tx hashes.

[offset_hash, coinbase_tx_hash, tx01_hash, tx02_hash, ? , tx_n_hash]

Actually could put offset_hash in any place in the array of hashes.

network_hash_range = network_hash_end - network_hash_begin

miner_hash_range = miner_hash_end - miner_hash_begin

The offset value MUST between network_hash_begin/end or
miner_hash_begin/end.

https://user-images.githubusercontent.com/514951/31133378-e00d9ca2-a891-11e7-8c61-73325f59f6ed.JPG

When mining pool send a job to miners, put the PoW hash range
(miner_hash_begin/end) in the job. So if the miners find a hash which value
is between [miner_hash_begin, miner_hash_end], means it's SHOULD be a
valid share, could submit the share to the pool. If the hash value is
between [network_hash_begin, network_hash_end] means find a valid block.

The network_diff is much much high than the miner's diff, means the
network_hash_range is much much smaller than miner_hash_range. By now,
a typical miner's pool diff is around 16K, network diff is 1123863285132,
so miner_hash_range is at least million times bigger than
network_hash_range.
The miners only know miner_hash_range, it's impossible for cheat miners
to find out which share could make a valid block or not.

Problems:
1. it's a hard fork.
2. will make existed asic dsha256 chips useless, but I think it's only a
small change to make new asic chips based on existed tech.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171003/00d1a45c/attachment-0001.html>

From james.hilliard1 at gmail.com  Fri Oct  6 14:36:15 2017
From: james.hilliard1 at gmail.com (James Hilliard)
Date: Fri, 6 Oct 2017 08:36:15 -0600
Subject: [bitcoin-dev] A solution may solve Block Withholding Attack
In-Reply-To: <CA+fZXJKuE_C7231-OHM2gvFUYBKjfoDoOfh+04YqHZuQF41eag@mail.gmail.com>
References: <CA+fZXJKuE_C7231-OHM2gvFUYBKjfoDoOfh+04YqHZuQF41eag@mail.gmail.com>
Message-ID: <CADvTj4p09Kq6SKKD_ttbjGsE7eyiq3hvDRQo3vUk6wCGVJU8UA@mail.gmail.com>

There have been some other proposals to deal with this such as
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2012-June/001506.html
that may be possible to implement in existing miners.

On Tue, Oct 3, 2017 at 9:52 AM, ??? via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Here is a solution may solve Block Withholding Attack. The general idea is
> came from Aviv Zohar(avivz at cs.huji.ac.il), I made it work for Bitcoin.
> Anyway, thanks Aviv.
>
> =====================
>
> DIFF_1 = 0x00000000FFFF0000000000000000000000000000000000000000000000000000;
>
> Diff = DIFF_1 / target
>
> this is equal to
>
> Diff = DIFF_1 / (target - 0) or Diff = DIFF_1 / abs(target - 0)
>
> now, we change diff algo to below:
>
> New_Diff = DIFF_1 / abs(target - offset)
>
> Offset is 32 bytes, like uint256 in Bitcoin, range is [0, 2^256),
> define: offset_hash = DSHA256(offset).
>
> we need to do a little change to the merkle root hash algo, put the
> offset_hash as a tx hash in the front of tx hashes.
>
> [offset_hash, coinbase_tx_hash, tx01_hash, tx02_hash, ? , tx_n_hash]
>
> Actually could put offset_hash in any place in the array of hashes.
>
> network_hash_range = network_hash_end - network_hash_begin
>
> miner_hash_range = miner_hash_end - miner_hash_begin
>
> The offset value MUST between network_hash_begin/end or
> miner_hash_begin/end.
>
> https://user-images.githubusercontent.com/514951/31133378-e00d9ca2-a891-11e7-8c61-73325f59f6ed.JPG
>
> When mining pool send a job to miners, put the PoW hash range
> (miner_hash_begin/end) in the job. So if the miners find a hash which value
> is between [miner_hash_begin, miner_hash_end], means it's SHOULD be a
> valid share, could submit the share to the pool. If the hash value is
> between [network_hash_begin, network_hash_end] means find a valid block.
>
> The network_diff is much much high than the miner's diff, means the
> network_hash_range is much much smaller than miner_hash_range. By now,
> a typical miner's pool diff is around 16K, network diff is 1123863285132,
> so miner_hash_range is at least million times bigger than
> network_hash_range.
> The miners only know miner_hash_range, it's impossible for cheat miners
> to find out which share could make a valid block or not.
>
> Problems:
> 1. it's a hard fork.
> 2. will make existed asic dsha256 chips useless, but I think it's only a
> small change to make new asic chips based on existed tech.
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From bit.kevin at gmail.com  Sun Oct  8 09:28:32 2017
From: bit.kevin at gmail.com (Kevin Pan)
Date: Sun, 8 Oct 2017 17:28:32 +0800
Subject: [bitcoin-dev] A solution may solve Block Withholding Attack
In-Reply-To: <CADvTj4p09Kq6SKKD_ttbjGsE7eyiq3hvDRQo3vUk6wCGVJU8UA@mail.gmail.com>
References: <CA+fZXJKuE_C7231-OHM2gvFUYBKjfoDoOfh+04YqHZuQF41eag@mail.gmail.com>
	<CADvTj4p09Kq6SKKD_ttbjGsE7eyiq3hvDRQo3vUk6wCGVJU8UA@mail.gmail.com>
Message-ID: <CA+fZXJ+dLr6tbKsKPhCvpOiMv-hT6iLGvboxphR7ByB4ghT1Jw@mail.gmail.com>

But I think this one is simpler and better than Luke's.

And now is different like 2012, pools need be more independ today. Pools
want
to express their opinion or standpoint. Some of can't do that like remove
the
NYA tag and one the reason is the Block Withholding Attack.

Kevin Pan

On Fri, Oct 6, 2017 at 10:36 PM, James Hilliard <james.hilliard1 at gmail.com>
wrote:

> There have been some other proposals to deal with this such as
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> 2012-June/001506.html
> that may be possible to implement in existing miners.
>
> On Tue, Oct 3, 2017 at 9:52 AM, ??? via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > Here is a solution may solve Block Withholding Attack. The general idea
> is
> > came from Aviv Zohar(avivz at cs.huji.ac.il), I made it work for Bitcoin.
> > Anyway, thanks Aviv.
> >
> > =====================
> >
> > DIFF_1 = 0x00000000FFFF0000000000000000000000000000000000000000000000
> 000000;
> >
> > Diff = DIFF_1 / target
> >
> > this is equal to
> >
> > Diff = DIFF_1 / (target - 0) or Diff = DIFF_1 / abs(target - 0)
> >
> > now, we change diff algo to below:
> >
> > New_Diff = DIFF_1 / abs(target - offset)
> >
> > Offset is 32 bytes, like uint256 in Bitcoin, range is [0, 2^256),
> > define: offset_hash = DSHA256(offset).
> >
> > we need to do a little change to the merkle root hash algo, put the
> > offset_hash as a tx hash in the front of tx hashes.
> >
> > [offset_hash, coinbase_tx_hash, tx01_hash, tx02_hash, ? , tx_n_hash]
> >
> > Actually could put offset_hash in any place in the array of hashes.
> >
> > network_hash_range = network_hash_end - network_hash_begin
> >
> > miner_hash_range = miner_hash_end - miner_hash_begin
> >
> > The offset value MUST between network_hash_begin/end or
> > miner_hash_begin/end.
> >
> > https://user-images.githubusercontent.com/514951/
> 31133378-e00d9ca2-a891-11e7-8c61-73325f59f6ed.JPG
> >
> > When mining pool send a job to miners, put the PoW hash range
> > (miner_hash_begin/end) in the job. So if the miners find a hash which
> value
> > is between [miner_hash_begin, miner_hash_end], means it's SHOULD be a
> > valid share, could submit the share to the pool. If the hash value is
> > between [network_hash_begin, network_hash_end] means find a valid block.
> >
> > The network_diff is much much high than the miner's diff, means the
> > network_hash_range is much much smaller than miner_hash_range. By now,
> > a typical miner's pool diff is around 16K, network diff is 1123863285132,
> > so miner_hash_range is at least million times bigger than
> > network_hash_range.
> > The miners only know miner_hash_range, it's impossible for cheat miners
> > to find out which share could make a valid block or not.
> >
> > Problems:
> > 1. it's a hard fork.
> > 2. will make existed asic dsha256 chips useless, but I think it's only a
> > small change to make new asic chips based on existed tech.
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171008/c60a6a4d/attachment.html>

From zawy at yahoo.com  Mon Oct  9 21:26:50 2017
From: zawy at yahoo.com (Scott Roberts)
Date: Mon, 9 Oct 2017 21:26:50 +0000 (UTC)
Subject: [bitcoin-dev] New difficulty algorithm needed for SegWit2x fork?
References: <1091872802.4256448.1507584410826.ref@mail.yahoo.com>
Message-ID: <1091872802.4256448.1507584410826@mail.yahoo.com>

Background:
The bitcoin difficulty algorithm does not seem to be a good one.? If there is a fork due to miners seeking maximum profit without due regard to security, users, and nodes, the "better" coin could end up being the minority chain. If 90% of hashrate is really going to at least initially go towards using SegWit2x, BTC would face 10x delays in confirmations until the next difficulty adjustment, negatively affecting its price relative to BTC1, causing further delays from even more miner abandonment (until the next adjustment). The 10% miners remaining on BTC do not inevitably lose by staying to endure 10x delays because they have 10x less competition, and the same situation applies to BTC1 miners. If the prices are the same and stable, all seems well for everyone, other things aside.? But if the BTC price does not fall to reflect the decreased hashrate, the situation seems to be a big problem for both coins: BTC1 miners will jump back to BTC when the difficulty adjustment occurs, initiating a potentially never-ending oscillation between the two coins, potentially worse than what BCH is experiencing.? They will not issue coins too fast like BCH because that is a side effect of the asymmetry in BCH's rise and fall algorithm.
Solution:
Hard fork to implement a new difficulty algorithm that uses a simple rolling average with a much smaller window.? Many small coins have done this as a way to stop big miners from coming on and then suddenly leaving, leaving constant miners stuck with a high difficulty for the rest of a (long) averaging window.? Even better, adjust the reward based on recent solvetimes to motivate more mining (or less) if the solvetimes are too slow (or too fast).? This will keep keep the coin issuance rate perfectly on schedule with real time.?
I recommend the following for Bitcoin, as fast, simple, and better than any other difficulty algorithm I'm aware of.? This is the result of a lot of work the past year.
=== Begin difficulty algorithm ===# Zawy v6 difficulty algorithm (modified for bitcoin)# Unmodified Zawy v6 for alt coins:?# http://zawy1.blogspot.com/2017/07/best-difficulty-algorithm-zawy-v1b.html# My failed attempts at something better:# https://github.com/seredat/karbowanec/commit/231db5270acb2e673a641a1800be910ce345668a## Keep negative solvetimes to correct bad timestamps.# Do not be tempted to use:# next_D = sum(last N Ds) * T / [max(last N TSs) - min(last N TSs];# D=difficulty, ST= Solvetime, TS = timestamp, T=TargetSolveTime
# set constants until next hard fork:
T=600;?N=30; # Averaging window. Smoother than N=15, faster response than N=60.X=5; # size of sudden hashrate changes expected as multiple of base hashrate.limit = X^(2/N); # limit rise and fall to protect against timestamp errors & manipulationadjust = 1/(1+0.67/N);? # keeps avg solvetime on track for small N.
# begin difficulty algorithm?
avg_ST=0; # avg SolveTimeavg_D=0;for ( i=height;? i > height-N;? i--) {? # go through N most recent blocks? ?avg_ST += (TS[i] - TS[i-1]) / N; # TS=timestamps? ?avg_D += D[i]/N;}avg_ST = T*limit if avg_ST > T*limit;?avg_ST = T/limit if avg_ST < T/limit;?
next_D = avg_D * T / avg_ST * adjust;?
# Tim Olsen suggested changing coin reward to protect against hash attacks.# Karbowanek coin suggested something similar.# After testing many ideas, I could not find anything better than the simplest idea below.# It was a surprise that coin issuance rate came out perfect.# BaseReward = coins per block
next_reward = BaseReward * avg_ST / T;
======= end algo ====
Due to the limit and keeping negative solvetimes in a true average, timestamp errors resulting in negative solvetimes are corrected in the next block. Otherwise, one would need to do like Zcash and cause a 5-block delay in the response by resorting to the median of past 11 blocks (MTP) as the most recent timestamp, offsetting the timestamps from their corresponding difficulties by 5 blocks. (it does not cause an averaging problem, but it does cause a 5-block delay in the response.)
Small N windows like keep the correct median, but cause avg solvetime to be above the target. The "adjust" constant (empirically determined) fixes this, but it causes the median to be that same percentage too low, below the ideal Poisson median which is 0.693 of the mean. I was not able to find a fix to this that did not slow down the response to hashrate changes.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171009/c018731b/attachment.html>

From zawy at yahoo.com  Mon Oct  9 22:57:32 2017
From: zawy at yahoo.com (Scott Roberts)
Date: Mon, 9 Oct 2017 22:57:32 +0000 (UTC)
Subject: [bitcoin-dev] New difficulty algorithm needed for SegWit2x fork?
 (reformatted text)
References: <1213518291.4328204.1507589852818.ref@mail.yahoo.com>
Message-ID: <1213518291.4328204.1507589852818@mail.yahoo.com>

Sorry, my previous email did not have the plain text I intended.

Background: 

The bitcoin difficulty algorithm does not seem to be a good one. If there 
is a fork due to miners seeking maximum profit without due regard to 
security, users, and nodes, the "better" coin could end up being the 
minority chain. If 90% of hashrate is really going to at least initially go 
towards using SegWit2x, BTC would face 10x delays in confirmations 
until the next difficulty adjustment, negatively affecting its price relative 
to BTC1, causing further delays from even more miner abandonment 
(until the next adjustment). The 10% miners remaining on BTC do not 
inevitably lose by staying to endure 10x delays because they have 10x 
less competition, and the same situation applies to BTC1 miners. If the 
prices are the same and stable, all seems well for everyone, other things 
aside. But if the BTC price does not fall to reflect the decreased hashrate, 
he situation seems to be a big problem for both coins: BTC1 miners will 
jump back to BTC when the difficulty adjustment occurs, initiating a 
potentially never-ending oscillation between the two coins, potentially 
worse than what BCH is experiencing.  They will not issue coins too fast 
like BCH because that is a side effect of the asymmetry in BCH's rise and 
fall algorithm. 

Solution: 

Hard fork to implement a new difficulty algorithm that uses a simple rolling 
average with a much smaller window.  Many small coins have done this as 
a way to stop big miners from coming on and then suddenly leaving, leaving 
constant miners stuck with a high difficulty for the rest of a (long) averaging 
window.  Even better, adjust the reward based on recent solvetimes to 
motivate more mining (or less) if the solvetimes are too slow (or too fast). 
This will keep keep coin issuance rate perfectly on schedule with real time. 

I recommend the following for Bitcoin, as fast, simple, and better than any 
other difficulty algorithm I'm aware of.  This is the result of a lot of work the 
past year. 

=== Begin difficulty algorithm === 
# Zawy v6 difficulty algorithm (modified for bitcoin) 
# Unmodified Zawy v6 for alt coins: 
# http://zawy1.blogspot.com/2017/07/best-difficulty-algorithm-zawy-v1b.html 
# All my failed attempts at something better: 
# https://github.com/seredat/karbowanec/commit/231db5270acb2e673a641a1800be910ce345668a 
# 
# Keep negative solvetimes to correct bad timestamps. 
# Do not be tempted to use: 
# next_D = sum(last N Ds) * T / [max(last N TSs) - min(last N TSs]; 
# ST= Solvetime, TS = timestamp 

# set constants until next hard fork: 

T=600; # coin's TargetSolvetime 
N=30; # Averaging window. Smoother than N=15, faster response than N=60. 
X=5; 
limit = X^(2/N); # limit rise and fall in case of timestamp manipulation 
adjust = 1/(1+0.67/N);  # keeps avg solvetime on track 

# begin difficulty algorithm 

avg_ST=0; avg_D=0; 
for ( i=height;  i > height-N;  i--) {  # go through N most recent blocks 
avg_ST += (TS[i] - TS[i-1]) / N; 
avg_D += D[i]/N; 
} 
avg_ST = T*limit if avg_ST > T*limit; 
avg_ST = T/limit if avg_ST < T/limit; 

next_D = avg_D * T / avg_ST * adjust; 

# Tim Olsen suggested changing reward to protect against hash attacks. 
# Karbowanek coin suggested something similar. 
# I could not find anything better than the simplest idea below. 
# It was a great surprise that coin issuance rate came out perfect. 
# BaseReward = coins per block 

next_reward = BaseReward * avg_ST / T; 

======= end algo ==== 

Due to the limit and keeping negative solvetimes in a true average, 
timestamp errors resulting in negative solvetimes are corrected in the next 
block. Otherwise, one would need to do like Zcash and cause a 5-block 
delay in the response by resorting to the median of past 11 blocks (MPT) 
as the most recent timestamp, offsetting the timestamps from their 
corresponding difficulties by 5 blocks. (it does not cause an averaging 
problem, but it does cause a 5-block delay in the response.)

From contact at taoeffect.com  Tue Oct 10 01:02:38 2017
From: contact at taoeffect.com (Tao Effect)
Date: Mon, 9 Oct 2017 18:02:38 -0700
Subject: [bitcoin-dev] Generalized sharding protocol for decentralized
 scaling without Miners owning our BTC
Message-ID: <16D7672F-AA36-47D7-AAEF-E767B9CE09FF@taoeffect.com>

Dear list,

In previous arguments over Drivechain (and Drivechain-like proposals) I promised that better scaling proposals ? that do not sacrifice Bitcoin's security ? would come along.

I planned to do a detailed writeup, but have decided to just send off this email with what I have, because I'm unlikely to have time to write up a detailed proposal.

The idea is very simple (and by no means novel*), and I'm sure others have mentioned either exactly it, or similar ideas (e.g. burning coins) before.

This is a generic sharding protocol for all blockchains, including Bitcoin.

Users simply say: "My coins on Chain A are going to be sent to Chain B".

Then they burn the coins on Chain A, and create a minting transaction on Chain B. The details of how to ensure that coins do not get lost needs to be worked out, but I'm fairly certain the folks on this list can figure out those details.

- Thin clients, nodes, and miners, can all very easily verify that said action took place, and therefore accept the "newly minted" coins on B as valid.
- Users client software now also knows where to look for the other coins (if for some reason it needs to).

This doesn't even need much modification to the Bitcoin protocol as most of the verification is done client-side.

It is fully decentralized, and there's no need to give our ownership of our coins to miners to get scale.

My sincere apologies if this has been brought up before (in which case, I would be very grateful for a link to the proposal).

Cheers,
Greg Slepak

* This idea is similar in spirit to Interledger.

--
Please do not email me anything that you are not comfortable also sharing with the NSA.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171009/2ff1f35a/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171009/2ff1f35a/attachment-0001.sig>

From truthcoin at gmail.com  Tue Oct 10 01:39:33 2017
From: truthcoin at gmail.com (Paul Sztorc)
Date: Mon, 9 Oct 2017 21:39:33 -0400
Subject: [bitcoin-dev] Generalized sharding protocol for decentralized
 scaling without Miners owning our BTC
In-Reply-To: <16D7672F-AA36-47D7-AAEF-E767B9CE09FF@taoeffect.com>
References: <16D7672F-AA36-47D7-AAEF-E767B9CE09FF@taoeffect.com>
Message-ID: <CA+XQW1jf-6HCic4beV5GSix8KRzJ-7nTc-ePipfs=ouwvHX0jA@mail.gmail.com>

That is only a one-way peg, not a two-way.

In fact, that is exactly what drivechain does, if one chooses parameters
for the drivechain that make it impossible for any side-to-main transfer to
succeed.

One-way pegs have strong first-mover disadvantages.

Paul

On Oct 9, 2017 9:24 PM, "Tao Effect via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

Dear list,

In previous arguments over Drivechain (and Drivechain-like proposals) I
promised that better scaling proposals ? that do not sacrifice Bitcoin's
security ? would come along.

I planned to do a detailed writeup, but have decided to just send off this
email with what I have, because I'm unlikely to have time to write up a
detailed proposal.

The idea is very simple (and by no means novel*), and I'm sure others have
mentioned either exactly it, or similar ideas (e.g. burning coins) before.

This is a generic sharding protocol for all blockchains, including Bitcoin.

Users simply say: "My coins on Chain A are going to be sent to Chain B".

Then they burn the coins on Chain A, and create a minting transaction on
Chain B. The details of how to ensure that coins do not get lost needs to
be worked out, but I'm fairly certain the folks on this list can figure out
those details.

- Thin clients, nodes, and miners, can all very easily verify that said
action took place, and therefore accept the "newly minted" coins on B as
valid.
- Users client software now also knows where to look for the other coins
(if for some reason it needs to).

This doesn't even need much modification to the Bitcoin protocol as most of
the verification is done client-side.

It is fully decentralized, and there's no need to give our ownership of our
coins to miners to get scale.

My sincere apologies if this has been brought up before (in which case, I
would be very grateful for a link to the proposal).

Cheers,
Greg Slepak

* This idea is similar in spirit to Interledger.

--
Please do not email me anything that you are not comfortable also sharing with
the NSA.


_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171009/ca05b959/attachment.html>

From mark at friedenbach.org  Tue Oct 10 02:19:11 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Mon, 9 Oct 2017 19:19:11 -0700
Subject: [bitcoin-dev] New difficulty algorithm needed for SegWit2x
	fork? (reformatted text)
In-Reply-To: <1213518291.4328204.1507589852818@mail.yahoo.com>
References: <1213518291.4328204.1507589852818.ref@mail.yahoo.com>
	<1213518291.4328204.1507589852818@mail.yahoo.com>
Message-ID: <B34C76A2-4FD7-4BA9-81AD-816B163463C9@friedenbach.org>

The problem of fast acting but non vulnerable difficulty adjustment algorithms is interesting. I would certainly like to see this space further explored, and even have some ideas myself.

However without commenting on the technical merits of this specific proposal, I think it must be said upfront that the stated goal is not good. The largest technical concern (ignoring governance) over B2X is that it is a rushed, poorly reviewed hard fork. Hard forks should not be rushed, and they should receive more than the usual level of expert and community review.

I?m that light, doing an even more rushed hard fork on an even newer idea with even less review would be hypocritical at best. I would suggest reframing as a hardfork wishlist research problem for the next properly planned hard fork, if one occurs. You might also find the hardfork research group a more accommodating venue for this discussion:

https://bitcoinhardforkresearch.github.io/

> On Oct 9, 2017, at 3:57 PM, Scott Roberts via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Sorry, my previous email did not have the plain text I intended.
> 
> Background: 
> 
> The bitcoin difficulty algorithm does not seem to be a good one. If there 
> is a fork due to miners seeking maximum profit without due regard to 
> security, users, and nodes, the "better" coin could end up being the 
> minority chain. If 90% of hashrate is really going to at least initially go 
> towards using SegWit2x, BTC would face 10x delays in confirmations 
> until the next difficulty adjustment, negatively affecting its price relative 
> to BTC1, causing further delays from even more miner abandonment 
> (until the next adjustment). The 10% miners remaining on BTC do not 
> inevitably lose by staying to endure 10x delays because they have 10x 
> less competition, and the same situation applies to BTC1 miners. If the 
> prices are the same and stable, all seems well for everyone, other things 
> aside. But if the BTC price does not fall to reflect the decreased hashrate, 
> he situation seems to be a big problem for both coins: BTC1 miners will 
> jump back to BTC when the difficulty adjustment occurs, initiating a 
> potentially never-ending oscillation between the two coins, potentially 
> worse than what BCH is experiencing.  They will not issue coins too fast 
> like BCH because that is a side effect of the asymmetry in BCH's rise and 
> fall algorithm. 
> 
> Solution: 
> 
> Hard fork to implement a new difficulty algorithm that uses a simple rolling 
> average with a much smaller window.  Many small coins have done this as 
> a way to stop big miners from coming on and then suddenly leaving, leaving 
> constant miners stuck with a high difficulty for the rest of a (long) averaging 
> window.  Even better, adjust the reward based on recent solvetimes to 
> motivate more mining (or less) if the solvetimes are too slow (or too fast). 
> This will keep keep coin issuance rate perfectly on schedule with real time. 
> 
> I recommend the following for Bitcoin, as fast, simple, and better than any 
> other difficulty algorithm I'm aware of.  This is the result of a lot of work the 
> past year. 
> 
> === Begin difficulty algorithm === 
> # Zawy v6 difficulty algorithm (modified for bitcoin) 
> # Unmodified Zawy v6 for alt coins: 
> # http://zawy1.blogspot.com/2017/07/best-difficulty-algorithm-zawy-v1b.html 
> # All my failed attempts at something better: 
> # https://github.com/seredat/karbowanec/commit/231db5270acb2e673a641a1800be910ce345668a 
> # 
> # Keep negative solvetimes to correct bad timestamps. 
> # Do not be tempted to use: 
> # next_D = sum(last N Ds) * T / [max(last N TSs) - min(last N TSs]; 
> # ST= Solvetime, TS = timestamp 
> 
> # set constants until next hard fork: 
> 
> T=600; # coin's TargetSolvetime 
> N=30; # Averaging window. Smoother than N=15, faster response than N=60. 
> X=5; 
> limit = X^(2/N); # limit rise and fall in case of timestamp manipulation 
> adjust = 1/(1+0.67/N);  # keeps avg solvetime on track 
> 
> # begin difficulty algorithm 
> 
> avg_ST=0; avg_D=0; 
> for ( i=height;  i > height-N;  i--) {  # go through N most recent blocks 
> avg_ST += (TS[i] - TS[i-1]) / N; 
> avg_D += D[i]/N; 
> } 
> avg_ST = T*limit if avg_ST > T*limit; 
> avg_ST = T/limit if avg_ST < T/limit; 
> 
> next_D = avg_D * T / avg_ST * adjust; 
> 
> # Tim Olsen suggested changing reward to protect against hash attacks. 
> # Karbowanek coin suggested something similar. 
> # I could not find anything better than the simplest idea below. 
> # It was a great surprise that coin issuance rate came out perfect. 
> # BaseReward = coins per block 
> 
> next_reward = BaseReward * avg_ST / T; 
> 
> ======= end algo ==== 
> 
> Due to the limit and keeping negative solvetimes in a true average, 
> timestamp errors resulting in negative solvetimes are corrected in the next 
> block. Otherwise, one would need to do like Zcash and cause a 5-block 
> delay in the response by resorting to the median of past 11 blocks (MPT) 
> as the most recent timestamp, offsetting the timestamps from their 
> corresponding difficulties by 5 blocks. (it does not cause an averaging 
> problem, but it does cause a 5-block delay in the response.)
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171009/198043c0/attachment.html>

From benkloester at gmail.com  Tue Oct 10 02:57:23 2017
From: benkloester at gmail.com (Ben Kloester)
Date: Tue, 10 Oct 2017 13:57:23 +1100
Subject: [bitcoin-dev] New difficulty algorithm needed for SegWit2x
 fork? (reformatted text)
In-Reply-To: <B34C76A2-4FD7-4BA9-81AD-816B163463C9@friedenbach.org>
References: <1213518291.4328204.1507589852818.ref@mail.yahoo.com>
	<1213518291.4328204.1507589852818@mail.yahoo.com>
	<B34C76A2-4FD7-4BA9-81AD-816B163463C9@friedenbach.org>
Message-ID: <CANgJ=T8M1fYFBai7gJA=Znmix9WKfRxm7y9yQbJhB282SgDtTg@mail.gmail.com>

Is there a contingency plan in the case that the incumbent chain following
the Bitcoin Core consensus rules comes under 51% attack?

If the 2x fork really does have the support of >66% of miners (which
remains to be seen), it seems like they'd have spare capacity to perform
such an attack. In which case, a rushed hard fork might be the only option
to guarantee the survival of the chain, would it not?

I'm aware of Luke's work on BitcoinHardfork
<https://github.com/BitcoinHardfork>, but not aware of whether this has
actually been tested in the field by anyone - ie whether anyone actually
has even run the code much / created a testnet. What are the options for an
emergency hard fork, and how much testing has each seen?

*Ben Kloester*

On 10 October 2017 at 13:19, Mark Friedenbach via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> The problem of fast acting but non vulnerable difficulty adjustment
> algorithms is interesting. I would certainly like to see this space further
> explored, and even have some ideas myself.
>
> However without commenting on the technical merits of this specific
> proposal, I think it must be said upfront that the stated goal is not good.
> The largest technical concern (ignoring governance) over B2X is that it is
> a rushed, poorly reviewed hard fork. Hard forks should not be rushed, and
> they should receive more than the usual level of expert and community
> review.
>
> I?m that light, doing an even more rushed hard fork on an even newer idea
> with even less review would be hypocritical at best. I would suggest
> reframing as a hardfork wishlist research problem for the next properly
> planned hard fork, if one occurs. You might also find the hardfork research
> group a more accommodating venue for this discussion:
>
> https://bitcoinhardforkresearch.github.io/
>
> On Oct 9, 2017, at 3:57 PM, Scott Roberts via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Sorry, my previous email did not have the plain text I intended.
>
> Background:
>
> The bitcoin difficulty algorithm does not seem to be a good one. If there
> is a fork due to miners seeking maximum profit without due regard to
> security, users, and nodes, the "better" coin could end up being the
> minority chain. If 90% of hashrate is really going to at least initially
> go
> towards using SegWit2x, BTC would face 10x delays in confirmations
> until the next difficulty adjustment, negatively affecting its price
> relative
> to BTC1, causing further delays from even more miner abandonment
> (until the next adjustment). The 10% miners remaining on BTC do not
> inevitably lose by staying to endure 10x delays because they have 10x
> less competition, and the same situation applies to BTC1 miners. If the
> prices are the same and stable, all seems well for everyone, other things
> aside. But if the BTC price does not fall to reflect the decreased
> hashrate,
> he situation seems to be a big problem for both coins: BTC1 miners will
> jump back to BTC when the difficulty adjustment occurs, initiating a
> potentially never-ending oscillation between the two coins, potentially
> worse than what BCH is experiencing.  They will not issue coins too fast
> like BCH because that is a side effect of the asymmetry in BCH's rise and
> fall algorithm.
>
> Solution:
>
> Hard fork to implement a new difficulty algorithm that uses a simple
> rolling
> average with a much smaller window.  Many small coins have done this as
> a way to stop big miners from coming on and then suddenly leaving, leaving
> constant miners stuck with a high difficulty for the rest of a (long)
> averaging
> window.  Even better, adjust the reward based on recent solvetimes to
> motivate more mining (or less) if the solvetimes are too slow (or too
> fast).
> This will keep keep coin issuance rate perfectly on schedule with real
> time.
>
> I recommend the following for Bitcoin, as fast, simple, and better than
> any
> other difficulty algorithm I'm aware of.  This is the result of a lot of
> work the
> past year.
>
> === Begin difficulty algorithm ===
> # Zawy v6 difficulty algorithm (modified for bitcoin)
> # Unmodified Zawy v6 for alt coins:
> # http://zawy1.blogspot.com/2017/07/best-difficulty-
> algorithm-zawy-v1b.html
> # All my failed attempts at something better:
> # https://github.com/seredat/karbowanec/commit/
> 231db5270acb2e673a641a1800be910ce345668a
> #
> # Keep negative solvetimes to correct bad timestamps.
> # Do not be tempted to use:
> # next_D = sum(last N Ds) * T / [max(last N TSs) - min(last N TSs];
> # ST= Solvetime, TS = timestamp
>
> # set constants until next hard fork:
>
> T=600; # coin's TargetSolvetime
> N=30; # Averaging window. Smoother than N=15, faster response than N=60.
> X=5;
> limit = X^(2/N); # limit rise and fall in case of timestamp manipulation
> adjust = 1/(1+0.67/N);  # keeps avg solvetime on track
>
> # begin difficulty algorithm
>
> avg_ST=0; avg_D=0;
> for ( i=height;  i > height-N;  i--) {  # go through N most recent blocks
> avg_ST += (TS[i] - TS[i-1]) / N;
> avg_D += D[i]/N;
> }
> avg_ST = T*limit if avg_ST > T*limit;
> avg_ST = T/limit if avg_ST < T/limit;
>
> next_D = avg_D * T / avg_ST * adjust;
>
> # Tim Olsen suggested changing reward to protect against hash attacks.
> # Karbowanek coin suggested something similar.
> # I could not find anything better than the simplest idea below.
> # It was a great surprise that coin issuance rate came out perfect.
> # BaseReward = coins per block
>
> next_reward = BaseReward * avg_ST / T;
>
> ======= end algo ====
>
> Due to the limit and keeping negative solvetimes in a true average,
> timestamp errors resulting in negative solvetimes are corrected in the
> next
> block. Otherwise, one would need to do like Zcash and cause a 5-block
> delay in the response by resorting to the median of past 11 blocks (MPT)
> as the most recent timestamp, offsetting the timestamps from their
> corresponding difficulties by 5 blocks. (it does not cause an averaging
> problem, but it does cause a 5-block delay in the response.)
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171010/a592d3b6/attachment-0001.html>

From truthcoin at gmail.com  Tue Oct 10 11:20:36 2017
From: truthcoin at gmail.com (Paul Sztorc)
Date: Tue, 10 Oct 2017 07:20:36 -0400
Subject: [bitcoin-dev] Generalized sharding protocol for decentralized
 scaling without Miners owning our BTC
In-Reply-To: <55CAABF4-4FB8-4230-8E51-014C1D347D72@taoeffect.com>
References: <16D7672F-AA36-47D7-AAEF-E767B9CE09FF@taoeffect.com>
	<CA+XQW1jf-6HCic4beV5GSix8KRzJ-7nTc-ePipfs=ouwvHX0jA@mail.gmail.com>
	<55CAABF4-4FB8-4230-8E51-014C1D347D72@taoeffect.com>
Message-ID: <CA+XQW1i-3dfRGr2vy=_P0BuXNbnoR_OmmOGGOmCcNEgkZeT_gg@mail.gmail.com>

Haha, no. Because you "burned" the coins.

On Oct 10, 2017 1:20 AM, "Tao Effect" <contact at taoeffect.com> wrote:

> Paul,
>
> It's a two-way peg.
>
> There's nothing preventing transfers back to the main chain.
>
> They work in the exact same manner.
>
> Cheers,
> Greg
>
> --
> Please do not email me anything that you are not comfortable also sharing with
> the NSA.
>
> On Oct 9, 2017, at 6:39 PM, Paul Sztorc <truthcoin at gmail.com> wrote:
>
> That is only a one-way peg, not a two-way.
>
> In fact, that is exactly what drivechain does, if one chooses parameters
> for the drivechain that make it impossible for any side-to-main transfer to
> succeed.
>
> One-way pegs have strong first-mover disadvantages.
>
> Paul
>
> On Oct 9, 2017 9:24 PM, "Tao Effect via bitcoin-dev" <bitcoin-dev at lists.
> linuxfoundation.org> wrote:
>
> Dear list,
>
> In previous arguments over Drivechain (and Drivechain-like proposals) I
> promised that better scaling proposals ? that do not sacrifice Bitcoin's
> security ? would come along.
>
> I planned to do a detailed writeup, but have decided to just send off this
> email with what I have, because I'm unlikely to have time to write up a
> detailed proposal.
>
> The idea is very simple (and by no means novel*), and I'm sure others have
> mentioned either exactly it, or similar ideas (e.g. burning coins) before.
>
> This is a generic sharding protocol for all blockchains, including Bitcoin.
>
> Users simply say: "My coins on Chain A are going to be sent to Chain B".
>
> Then they burn the coins on Chain A, and create a minting transaction on
> Chain B. The details of how to ensure that coins do not get lost needs to
> be worked out, but I'm fairly certain the folks on this list can figure out
> those details.
>
> - Thin clients, nodes, and miners, can all very easily verify that said
> action took place, and therefore accept the "newly minted" coins on B as
> valid.
> - Users client software now also knows where to look for the other coins
> (if for some reason it needs to).
>
> This doesn't even need much modification to the Bitcoin protocol as most
> of the verification is done client-side.
>
> It is fully decentralized, and there's no need to give our ownership of
> our coins to miners to get scale.
>
> My sincere apologies if this has been brought up before (in which case, I
> would be very grateful for a link to the proposal).
>
> Cheers,
> Greg Slepak
>
> * This idea is similar in spirit to Interledger.
>
> --
> Please do not email me anything that you are not comfortable also sharing with
> the NSA.
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171010/25fb5d8e/attachment.html>

From contact at taoeffect.com  Tue Oct 10 05:19:58 2017
From: contact at taoeffect.com (Tao Effect)
Date: Mon, 9 Oct 2017 22:19:58 -0700
Subject: [bitcoin-dev] Generalized sharding protocol for decentralized
 scaling without Miners owning our BTC
In-Reply-To: <CA+XQW1jf-6HCic4beV5GSix8KRzJ-7nTc-ePipfs=ouwvHX0jA@mail.gmail.com>
References: <16D7672F-AA36-47D7-AAEF-E767B9CE09FF@taoeffect.com>
	<CA+XQW1jf-6HCic4beV5GSix8KRzJ-7nTc-ePipfs=ouwvHX0jA@mail.gmail.com>
Message-ID: <55CAABF4-4FB8-4230-8E51-014C1D347D72@taoeffect.com>

Paul,

It's a two-way peg.

There's nothing preventing transfers back to the main chain.

They work in the exact same manner.

Cheers,
Greg

--
Please do not email me anything that you are not comfortable also sharing with the NSA.

> On Oct 9, 2017, at 6:39 PM, Paul Sztorc <truthcoin at gmail.com <mailto:truthcoin at gmail.com>> wrote:
> 
> That is only a one-way peg, not a two-way.
> 
> In fact, that is exactly what drivechain does, if one chooses parameters for the drivechain that make it impossible for any side-to-main transfer to succeed.
> 
> One-way pegs have strong first-mover disadvantages.
> 
> Paul
> 
> On Oct 9, 2017 9:24 PM, "Tao Effect via bitcoin-dev" <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
> Dear list,
> 
> In previous arguments over Drivechain (and Drivechain-like proposals) I promised that better scaling proposals ? that do not sacrifice Bitcoin's security ? would come along.
> 
> I planned to do a detailed writeup, but have decided to just send off this email with what I have, because I'm unlikely to have time to write up a detailed proposal.
> 
> The idea is very simple (and by no means novel*), and I'm sure others have mentioned either exactly it, or similar ideas (e.g. burning coins) before.
> 
> This is a generic sharding protocol for all blockchains, including Bitcoin.
> 
> Users simply say: "My coins on Chain A are going to be sent to Chain B".
> 
> Then they burn the coins on Chain A, and create a minting transaction on Chain B. The details of how to ensure that coins do not get lost needs to be worked out, but I'm fairly certain the folks on this list can figure out those details.
> 
> - Thin clients, nodes, and miners, can all very easily verify that said action took place, and therefore accept the "newly minted" coins on B as valid.
> - Users client software now also knows where to look for the other coins (if for some reason it needs to).
> 
> This doesn't even need much modification to the Bitcoin protocol as most of the verification is done client-side.
> 
> It is fully decentralized, and there's no need to give our ownership of our coins to miners to get scale.
> 
> My sincere apologies if this has been brought up before (in which case, I would be very grateful for a link to the proposal).
> 
> Cheers,
> Greg Slepak
> 
> * This idea is similar in spirit to Interledger.
> 
> --
> Please do not email me anything that you are not comfortable also sharing with the NSA.
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
> 
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171009/f3c63867/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171009/f3c63867/attachment-0001.sig>

From greg_not_so at hotmail.com  Tue Oct 10 10:34:35 2017
From: greg_not_so at hotmail.com (greg misiorek)
Date: Tue, 10 Oct 2017 10:34:35 +0000
Subject: [bitcoin-dev] New difficulty algorithm needed for
 SegWit2x	fork? (reformatted text)
In-Reply-To: <B34C76A2-4FD7-4BA9-81AD-816B163463C9@friedenbach.org>
References: <1213518291.4328204.1507589852818.ref@mail.yahoo.com>
	<1213518291.4328204.1507589852818@mail.yahoo.com>,
	<B34C76A2-4FD7-4BA9-81AD-816B163463C9@friedenbach.org>
Message-ID: <BN6PR15MB17610E1A315F50BDD54D336CB1750@BN6PR15MB1761.namprd15.prod.outlook.com>

Yes, I agree. Hard forks should be as much scrutinized by fellow bitcoiners, i.e. developers and holders and not only rushed by miners or some other investment gurus, whose incentives are not entirely clear, to remain as decentralized as economically possible.

________________________________
From: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Mark Friedenbach via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
Sent: Monday, October 9, 2017 10:19 PM
To: Scott Roberts; Bitcoin Protocol Discussion
Subject: Re: [bitcoin-dev] New difficulty algorithm needed for SegWit2x fork? (reformatted text)

The problem of fast acting but non vulnerable difficulty adjustment algorithms is interesting. I would certainly like to see this space further explored, and even have some ideas myself.

However without commenting on the technical merits of this specific proposal, I think it must be said upfront that the stated goal is not good. The largest technical concern (ignoring governance) over B2X is that it is a rushed, poorly reviewed hard fork. Hard forks should not be rushed, and they should receive more than the usual level of expert and community review.

I?m that light, doing an even more rushed hard fork on an even newer idea with even less review would be hypocritical at best. I would suggest reframing as a hardfork wishlist research problem for the next properly planned hard fork, if one occurs. You might also find the hardfork research group a more accommodating venue for this discussion:

https://bitcoinhardforkresearch.github.io/
Welcome - Bitcoin Hard Fork Research<https://bitcoinhardforkresearch.github.io/>
bitcoinhardforkresearch.github.io
Bitcoin Hard Fork Research This website will be updated with relevant ongoing information about Bitcoin hard fork research. Resources: BIP-MMHF, draft patch last ...



On Oct 9, 2017, at 3:57 PM, Scott Roberts via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:

Sorry, my previous email did not have the plain text I intended.

Background:

The bitcoin difficulty algorithm does not seem to be a good one. If there
is a fork due to miners seeking maximum profit without due regard to
security, users, and nodes, the "better" coin could end up being the
minority chain. If 90% of hashrate is really going to at least initially go
towards using SegWit2x, BTC would face 10x delays in confirmations
until the next difficulty adjustment, negatively affecting its price relative
to BTC1, causing further delays from even more miner abandonment
(until the next adjustment). The 10% miners remaining on BTC do not
inevitably lose by staying to endure 10x delays because they have 10x
less competition, and the same situation applies to BTC1 miners. If the
prices are the same and stable, all seems well for everyone, other things
aside. But if the BTC price does not fall to reflect the decreased hashrate,
he situation seems to be a big problem for both coins: BTC1 miners will
jump back to BTC when the difficulty adjustment occurs, initiating a
potentially never-ending oscillation between the two coins, potentially
worse than what BCH is experiencing.  They will not issue coins too fast
like BCH because that is a side effect of the asymmetry in BCH's rise and
fall algorithm.

Solution:

Hard fork to implement a new difficulty algorithm that uses a simple rolling
average with a much smaller window.  Many small coins have done this as
a way to stop big miners from coming on and then suddenly leaving, leaving
constant miners stuck with a high difficulty for the rest of a (long) averaging
window.  Even better, adjust the reward based on recent solvetimes to
motivate more mining (or less) if the solvetimes are too slow (or too fast).
This will keep keep coin issuance rate perfectly on schedule with real time.

I recommend the following for Bitcoin, as fast, simple, and better than any
other difficulty algorithm I'm aware of.  This is the result of a lot of work the
past year.

=== Begin difficulty algorithm ===
# Zawy v6 difficulty algorithm (modified for bitcoin)
# Unmodified Zawy v6 for alt coins:
# http://zawy1.blogspot.com/2017/07/best-difficulty-algorithm-zawy-v1b.html
# All my failed attempts at something better:
# https://github.com/seredat/karbowanec/commit/231db5270acb2e673a641a1800be910ce345668a
#
# Keep negative solvetimes to correct bad timestamps.
# Do not be tempted to use:
# next_D = sum(last N Ds) * T / [max(last N TSs) - min(last N TSs];
# ST= Solvetime, TS = timestamp

# set constants until next hard fork:

T=600; # coin's TargetSolvetime
N=30; # Averaging window. Smoother than N=15, faster response than N=60.
X=5;
limit = X^(2/N); # limit rise and fall in case of timestamp manipulation
adjust = 1/(1+0.67/N);  # keeps avg solvetime on track

# begin difficulty algorithm

avg_ST=0; avg_D=0;
for ( i=height;  i > height-N;  i--) {  # go through N most recent blocks
avg_ST += (TS[i] - TS[i-1]) / N;
avg_D += D[i]/N;
}
avg_ST = T*limit if avg_ST > T*limit;
avg_ST = T/limit if avg_ST < T/limit;

next_D = avg_D * T / avg_ST * adjust;

# Tim Olsen suggested changing reward to protect against hash attacks.
# Karbowanek coin suggested something similar.
# I could not find anything better than the simplest idea below.
# It was a great surprise that coin issuance rate came out perfect.
# BaseReward = coins per block

next_reward = BaseReward * avg_ST / T;

======= end algo ====

Due to the limit and keeping negative solvetimes in a true average,
timestamp errors resulting in negative solvetimes are corrected in the next
block. Otherwise, one would need to do like Zcash and cause a 5-block
delay in the response by resorting to the median of past 11 blocks (MPT)
as the most recent timestamp, offsetting the timestamps from their
corresponding difficulties by 5 blocks. (it does not cause an averaging
problem, but it does cause a 5-block delay in the response.)
_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171010/423c22c5/attachment.html>

From contact at taoeffect.com  Tue Oct 10 00:04:55 2017
From: contact at taoeffect.com (Tao Effect)
Date: Mon, 9 Oct 2017 17:04:55 -0700
Subject: [bitcoin-dev] Generalized sharding protocol for decentralized
 scaling without Miners owning our BTC
Message-ID: <CA0A8089-7AD4-4A6D-95F2-11F0411E9806@taoeffect.com>

Dear list,

In previous arguments over Drivechain (and Drivechain-like proposals) I promised that better scaling proposals ? that do not sacrifice Bitcoin's security ? would come along.

I planned to do a detailed writeup, but have decided to just send off this email with what I have, because I'm unlikely to have time to write up a detailed proposal.

The idea is very simple, and I'm sure others have mentioned either exactly it, or similar ideas (e.g. burning coins) before.

This is a generic sharding protocol for all blockchains, including Bitcoin.

Users simply say: "My coins on Chain A are going to be sent to Chain B".

Then they burn the coins on Chain A, and create a minting transaction on Chain B. The details of how to ensure that coins do not get lost needs to be worked out, but I'm fairly certain the folks on this list can figure out those details.

- Thin clients, nodes, and miners, can all very easily verify that said action took place, and therefore accept the "newly minted" coins on B as valid.
- Users client software now also knows where to look for the other coins (if for some reason it needs to).

This doesn't even need much modification to the Bitcoin protocol as most of the verification is done client-side.

It is fully decentralized, and there's no need to give our ownership of our coins to miners to get scale.

My sincere apologies if this has been brought up before (in which case, I would be very grateful for a link to the proposal).

Cheers,
Greg Slepak

--
Please do not email me anything that you are not comfortable also sharing with the NSA.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171009/261e847b/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171009/261e847b/attachment.sig>

From contact at taoeffect.com  Tue Oct 10 14:09:44 2017
From: contact at taoeffect.com (Tao Effect)
Date: Tue, 10 Oct 2017 07:09:44 -0700
Subject: [bitcoin-dev] Generalized sharding protocol for decentralized
 scaling without Miners owning our BTC
In-Reply-To: <CA+XQW1i-3dfRGr2vy=_P0BuXNbnoR_OmmOGGOmCcNEgkZeT_gg@mail.gmail.com>
References: <16D7672F-AA36-47D7-AAEF-E767B9CE09FF@taoeffect.com>
	<CA+XQW1jf-6HCic4beV5GSix8KRzJ-7nTc-ePipfs=ouwvHX0jA@mail.gmail.com>
	<55CAABF4-4FB8-4230-8E51-014C1D347D72@taoeffect.com>
	<CA+XQW1i-3dfRGr2vy=_P0BuXNbnoR_OmmOGGOmCcNEgkZeT_gg@mail.gmail.com>
Message-ID: <FBD96A02-243E-4E09-9204-EC90DE5EE576@taoeffect.com>

Hi Paul,

I thought it was clear, but apparently you are getting stuck on the semantics of the word "burn".

The "burning" applies to the original coins you had.

When you transfer them back, you get newly minted coins, equivalent to the amount you "burned" on the chain you're transferring from ? as stated in the OP.

If you don't like the word "burn", pick another one.

--
Please do not email me anything that you are not comfortable also sharing with the NSA.

> On Oct 10, 2017, at 4:20 AM, Paul Sztorc <truthcoin at gmail.com <mailto:truthcoin at gmail.com>> wrote:
> 
> Haha, no. Because you "burned" the coins.
> 
> On Oct 10, 2017 1:20 AM, "Tao Effect" <contact at taoeffect.com <mailto:contact at taoeffect.com>> wrote:
> Paul,
> 
> It's a two-way peg.
> 
> There's nothing preventing transfers back to the main chain.
> 
> They work in the exact same manner.
> 
> Cheers,
> Greg
> 
> --
> Please do not email me anything that you are not comfortable also sharing with the NSA.
> 
>> On Oct 9, 2017, at 6:39 PM, Paul Sztorc <truthcoin at gmail.com <mailto:truthcoin at gmail.com>> wrote:
>> 
>> That is only a one-way peg, not a two-way.
>> 
>> In fact, that is exactly what drivechain does, if one chooses parameters for the drivechain that make it impossible for any side-to-main transfer to succeed.
>> 
>> One-way pegs have strong first-mover disadvantages.
>> 
>> Paul
>> 
>> On Oct 9, 2017 9:24 PM, "Tao Effect via bitcoin-dev" <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>> Dear list,
>> 
>> In previous arguments over Drivechain (and Drivechain-like proposals) I promised that better scaling proposals ? that do not sacrifice Bitcoin's security ? would come along.
>> 
>> I planned to do a detailed writeup, but have decided to just send off this email with what I have, because I'm unlikely to have time to write up a detailed proposal.
>> 
>> The idea is very simple (and by no means novel*), and I'm sure others have mentioned either exactly it, or similar ideas (e.g. burning coins) before.
>> 
>> This is a generic sharding protocol for all blockchains, including Bitcoin.
>> 
>> Users simply say: "My coins on Chain A are going to be sent to Chain B".
>> 
>> Then they burn the coins on Chain A, and create a minting transaction on Chain B. The details of how to ensure that coins do not get lost needs to be worked out, but I'm fairly certain the folks on this list can figure out those details.
>> 
>> - Thin clients, nodes, and miners, can all very easily verify that said action took place, and therefore accept the "newly minted" coins on B as valid.
>> - Users client software now also knows where to look for the other coins (if for some reason it needs to).
>> 
>> This doesn't even need much modification to the Bitcoin protocol as most of the verification is done client-side.
>> 
>> It is fully decentralized, and there's no need to give our ownership of our coins to miners to get scale.
>> 
>> My sincere apologies if this has been brought up before (in which case, I would be very grateful for a link to the proposal).
>> 
>> Cheers,
>> Greg Slepak
>> 
>> * This idea is similar in spirit to Interledger.
>> 
>> --
>> Please do not email me anything that you are not comfortable also sharing with the NSA.
>> 
>> 
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
>> 
>> 
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171010/0b61b6ae/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171010/0b61b6ae/attachment-0001.sig>

From truthcoin at gmail.com  Tue Oct 10 15:09:21 2017
From: truthcoin at gmail.com (Paul Sztorc)
Date: Tue, 10 Oct 2017 11:09:21 -0400
Subject: [bitcoin-dev] Generalized sharding protocol for decentralized
 scaling without Miners owning our BTC
In-Reply-To: <FBD96A02-243E-4E09-9204-EC90DE5EE576@taoeffect.com>
References: <16D7672F-AA36-47D7-AAEF-E767B9CE09FF@taoeffect.com>
	<CA+XQW1jf-6HCic4beV5GSix8KRzJ-7nTc-ePipfs=ouwvHX0jA@mail.gmail.com>
	<55CAABF4-4FB8-4230-8E51-014C1D347D72@taoeffect.com>
	<CA+XQW1i-3dfRGr2vy=_P0BuXNbnoR_OmmOGGOmCcNEgkZeT_gg@mail.gmail.com>
	<FBD96A02-243E-4E09-9204-EC90DE5EE576@taoeffect.com>
Message-ID: <daf438d1-7cca-aa0f-6bf7-3eef0d765d49@gmail.com>

I think this response speaks for itself.

On 10/10/2017 10:09 AM, Tao Effect wrote:
> Hi Paul,
>
> I thought it was clear, but apparently you are getting stuck on the
> semantics of the word "burn".
>
> The "burning" applies to the original coins you had.
>
> When you transfer them back, you get newly minted coins, equivalent to
> the amount you "burned" on the chain you're transferring from ? as
> stated in the OP.
>
> If you don't like the word "burn", pick another one.
>
> --
> Please do not email me anything that you are not comfortable also
> sharing?with the NSA.
>
>> On Oct 10, 2017, at 4:20 AM, Paul Sztorc <truthcoin at gmail.com
>> <mailto:truthcoin at gmail.com>> wrote:
>>
>> Haha, no. Because you "burned" the coins.
>>
>> On Oct 10, 2017 1:20 AM, "Tao Effect" <contact at taoeffect.com
>> <mailto:contact at taoeffect.com>> wrote:
>>
>>     Paul,
>>
>>     It's a two-way peg.
>>
>>     There's nothing preventing transfers back to the main chain.
>>
>>     They work in the exact same manner.
>>
>>     Cheers,
>>     Greg
>>
>>     --
>>     Please do not email me anything that you are not comfortable also
>>     sharing?with the NSA.
>>
>>>     On Oct 9, 2017, at 6:39 PM, Paul Sztorc <truthcoin at gmail.com
>>>     <mailto:truthcoin at gmail.com>> wrote:
>>>
>>>     That is only a one-way peg, not a two-way.
>>>
>>>     In fact, that is exactly what drivechain does, if one chooses
>>>     parameters for the drivechain that make it impossible for any
>>>     side-to-main transfer to succeed.
>>>
>>>     One-way pegs have strong first-mover disadvantages.
>>>
>>>     Paul
>>>
>>>     On Oct 9, 2017 9:24 PM, "Tao Effect via bitcoin-dev"
>>>     <bitcoin-dev at lists.linuxfoundation.org
>>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>>
>>>         Dear list,
>>>
>>>         In previous arguments over Drivechain (and Drivechain-like
>>>         proposals) I promised that better scaling proposals ? that
>>>         do not sacrifice Bitcoin's security ? would come along.
>>>
>>>         I planned to do a detailed writeup, but have decided to just
>>>         send off this email with what I have, because I'm unlikely
>>>         to have time to write up a detailed proposal.
>>>
>>>         The idea is very simple (and by no means novel*), and I'm
>>>         sure others have mentioned either exactly it, or similar
>>>         ideas (e.g. burning coins) before.
>>>
>>>         This is a generic sharding protocol for all blockchains,
>>>         including Bitcoin.
>>>
>>>         Users simply say: "My coins on Chain A are going to be sent
>>>         to Chain B".
>>>
>>>         Then they burn the coins on Chain A, and create a minting
>>>         transaction on Chain B. The details of how to ensure that
>>>         coins do not get lost needs to be worked out, but I'm fairly
>>>         certain the folks on this list can figure out those details.
>>>
>>>         - Thin clients, nodes, and miners, can all very easily
>>>         verify that said action took place, and therefore accept the
>>>         "newly minted" coins on B as valid.
>>>         - Users client software now also knows where to look for the
>>>         other coins (if for some reason it needs to).
>>>
>>>         This doesn't even need much modification to the Bitcoin
>>>         protocol as most of the verification is done client-side.
>>>
>>>         It is fully decentralized, and there's no need to give our
>>>         ownership of our coins to miners to get scale.
>>>
>>>         My sincere apologies if this has been brought up before (in
>>>         which case, I would be very grateful for a link to the
>>>         proposal).
>>>
>>>         Cheers,
>>>         Greg Slepak
>>>
>>>         * This idea is similar in spirit to Interledger.
>>>
>>>         --
>>>         Please do not email me anything that you are not comfortable
>>>         also sharing?with the NSA.
>>>
>>>
>>>         _______________________________________________
>>>         bitcoin-dev mailing list
>>>         bitcoin-dev at lists.linuxfoundation.org
>>>         <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>         <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
>>>
>>>
>>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171010/0bebbbfd/attachment-0001.html>

From contact at taoeffect.com  Tue Oct 10 19:25:03 2017
From: contact at taoeffect.com (Tao Effect)
Date: Tue, 10 Oct 2017 12:25:03 -0700
Subject: [bitcoin-dev] Generalized sharding protocol for decentralized
	scaling without Miners owning our BTC
In-Reply-To: <daf438d1-7cca-aa0f-6bf7-3eef0d765d49@gmail.com>
References: <16D7672F-AA36-47D7-AAEF-E767B9CE09FF@taoeffect.com>
	<CA+XQW1jf-6HCic4beV5GSix8KRzJ-7nTc-ePipfs=ouwvHX0jA@mail.gmail.com>
	<55CAABF4-4FB8-4230-8E51-014C1D347D72@taoeffect.com>
	<CA+XQW1i-3dfRGr2vy=_P0BuXNbnoR_OmmOGGOmCcNEgkZeT_gg@mail.gmail.com>
	<FBD96A02-243E-4E09-9204-EC90DE5EE576@taoeffect.com>
	<daf438d1-7cca-aa0f-6bf7-3eef0d765d49@gmail.com>
Message-ID: <B79CD106-A06E-4AF1-B67E-6DFE557468F8@taoeffect.com>

Is that what passes for a technical argument these days? Sheesh.

Whereas in Drivechain users are forced to give up their coins to a single group for whatever sidechains they interact with, the generic sharding algo lets them (1) keep their coins, (2) trust whatever group they want to trust (the miners of the various sidechains).

Drivechain offers objectively worse security.

--
Sent from my mobile device.
Please do not email me anything that you are not comfortable also sharing with the NSA.

> On Oct 10, 2017, at 8:09 AM, Paul Sztorc via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> I think this response speaks for itself.
> 
>> On 10/10/2017 10:09 AM, Tao Effect wrote:
>> Hi Paul,
>> 
>> I thought it was clear, but apparently you are getting stuck on the semantics of the word "burn".
>> 
>> The "burning" applies to the original coins you had.
>> 
>> When you transfer them back, you get newly minted coins, equivalent to the amount you "burned" on the chain you're transferring from ? as stated in the OP.
>> 
>> If you don't like the word "burn", pick another one.
>> 
>> --
>> Please do not email me anything that you are not comfortable also sharing with the NSA.
>> 
>>> On Oct 10, 2017, at 4:20 AM, Paul Sztorc <truthcoin at gmail.com> wrote:
>>> 
>>> Haha, no. Because you "burned" the coins.
>>> 
>>>> On Oct 10, 2017 1:20 AM, "Tao Effect" <contact at taoeffect.com> wrote:
>>>> Paul,
>>>> 
>>>> It's a two-way peg.
>>>> 
>>>> There's nothing preventing transfers back to the main chain.
>>>> 
>>>> They work in the exact same manner.
>>>> 
>>>> Cheers,
>>>> Greg
>>>> 
>>>> --
>>>> Please do not email me anything that you are not comfortable also sharing with the NSA.
>>>> 
>>>>> On Oct 9, 2017, at 6:39 PM, Paul Sztorc <truthcoin at gmail.com> wrote:
>>>>> 
>>>>> That is only a one-way peg, not a two-way.
>>>>> 
>>>>> In fact, that is exactly what drivechain does, if one chooses parameters for the drivechain that make it impossible for any side-to-main transfer to succeed.
>>>>> 
>>>>> One-way pegs have strong first-mover disadvantages.
>>>>> 
>>>>> Paul
>>>>> 
>>>>> On Oct 9, 2017 9:24 PM, "Tao Effect via bitcoin-dev" <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>> Dear list,
>>>>> 
>>>>> In previous arguments over Drivechain (and Drivechain-like proposals) I promised that better scaling proposals ? that do not sacrifice Bitcoin's security ? would come along.
>>>>> 
>>>>> I planned to do a detailed writeup, but have decided to just send off this email with what I have, because I'm unlikely to have time to write up a detailed proposal.
>>>>> 
>>>>> The idea is very simple (and by no means novel*), and I'm sure others have mentioned either exactly it, or similar ideas (e.g. burning coins) before.
>>>>> 
>>>>> This is a generic sharding protocol for all blockchains, including Bitcoin.
>>>>> 
>>>>> Users simply say: "My coins on Chain A are going to be sent to Chain B".
>>>>> 
>>>>> Then they burn the coins on Chain A, and create a minting transaction on Chain B. The details of how to ensure that coins do not get lost needs to be                                             worked out, but I'm fairly certain the folks on this list can figure out those details.
>>>>> 
>>>>> - Thin clients, nodes, and miners, can all very easily verify that said action took place, and therefore accept the "newly minted" coins on B as valid.
>>>>> - Users client software now also knows where to look for the other coins (if for some reason it                                             needs to).
>>>>> 
>>>>> This doesn't even need much modification to the Bitcoin protocol as most of the verification is done client-side.
>>>>> 
>>>>> It is fully decentralized, and there's no need to give our ownership of our coins to miners to get scale.
>>>>> 
>>>>> My sincere apologies if this has been brought up before (in which case, I would be very grateful for a link to the proposal).
>>>>> 
>>>>> Cheers,
>>>>> Greg Slepak
>>>>> 
>>>>> * This idea is similar in spirit to Interledger.
>>>>> 
>>>>> --
>>>>> Please do not email me anything that you are not comfortable also sharing with the NSA.
>>>>> 
>>>>> 
>>>>> _______________________________________________
>>>>> bitcoin-dev mailing list
>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>> 
>>>>> 
>>>> 
>> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171010/a217ed4f/attachment-0001.html>

From cryptaxe at gmail.com  Tue Oct 10 19:50:13 2017
From: cryptaxe at gmail.com (CryptAxe)
Date: Tue, 10 Oct 2017 12:50:13 -0700
Subject: [bitcoin-dev] Generalized sharding protocol for decentralized
 scaling without Miners owning our BTC
In-Reply-To: <B79CD106-A06E-4AF1-B67E-6DFE557468F8@taoeffect.com>
References: <16D7672F-AA36-47D7-AAEF-E767B9CE09FF@taoeffect.com>
	<CA+XQW1jf-6HCic4beV5GSix8KRzJ-7nTc-ePipfs=ouwvHX0jA@mail.gmail.com>
	<55CAABF4-4FB8-4230-8E51-014C1D347D72@taoeffect.com>
	<CA+XQW1i-3dfRGr2vy=_P0BuXNbnoR_OmmOGGOmCcNEgkZeT_gg@mail.gmail.com>
	<FBD96A02-243E-4E09-9204-EC90DE5EE576@taoeffect.com>
	<daf438d1-7cca-aa0f-6bf7-3eef0d765d49@gmail.com>
	<B79CD106-A06E-4AF1-B67E-6DFE557468F8@taoeffect.com>
Message-ID: <CAF5CFkg71g5vTCQ3rcbN+7Cjx_B3z7NT78Ug6a6S=KiSS8yo-A@mail.gmail.com>

Your method would change the number of Bitcoins in existence. Why?

On Oct 10, 2017 12:47 PM, "Tao Effect via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Is that what passes for a technical argument these days? Sheesh.
>
> Whereas in Drivechain users are forced to give up their coins to a single
> group for whatever sidechains they interact with, the generic sharding algo
> lets them (1) keep their coins, (2) trust whatever group they want to trust
> (the miners of the various sidechains).
>
> Drivechain offers objectively worse security.
>
> --
> Sent from my mobile device.
> Please do not email me anything that you are not comfortable also sharing
> with the NSA.
>
> On Oct 10, 2017, at 8:09 AM, Paul Sztorc via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> I think this response speaks for itself.
>
> On 10/10/2017 10:09 AM, Tao Effect wrote:
>
> Hi Paul,
>
> I thought it was clear, but apparently you are getting stuck on the
> semantics of the word "burn".
>
> The "burning" applies to the original coins you had.
>
> When you transfer them back, you get newly minted coins, equivalent to the
> amount you "burned" on the chain you're transferring from ? as stated in
> the OP.
>
> If you don't like the word "burn", pick another one.
>
> --
> Please do not email me anything that you are not comfortable also sharing with
> the NSA.
>
> On Oct 10, 2017, at 4:20 AM, Paul Sztorc <truthcoin at gmail.com> wrote:
>
> Haha, no. Because you "burned" the coins.
>
> On Oct 10, 2017 1:20 AM, "Tao Effect" <contact at taoeffect.com> wrote:
>
>> Paul,
>>
>> It's a two-way peg.
>>
>> There's nothing preventing transfers back to the main chain.
>>
>> They work in the exact same manner.
>>
>> Cheers,
>> Greg
>>
>> --
>> Please do not email me anything that you are not comfortable also sharing with
>> the NSA.
>>
>> On Oct 9, 2017, at 6:39 PM, Paul Sztorc <truthcoin at gmail.com> wrote:
>>
>> That is only a one-way peg, not a two-way.
>>
>> In fact, that is exactly what drivechain does, if one chooses parameters
>> for the drivechain that make it impossible for any side-to-main transfer to
>> succeed.
>>
>> One-way pegs have strong first-mover disadvantages.
>>
>> Paul
>>
>> On Oct 9, 2017 9:24 PM, "Tao Effect via bitcoin-dev" <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> Dear list,
>>
>> In previous arguments over Drivechain (and Drivechain-like proposals) I
>> promised that better scaling proposals ? that do not sacrifice Bitcoin's
>> security ? would come along.
>>
>> I planned to do a detailed writeup, but have decided to just send off
>> this email with what I have, because I'm unlikely to have time to write up
>> a detailed proposal.
>>
>> The idea is very simple (and by no means novel*), and I'm sure others
>> have mentioned either exactly it, or similar ideas (e.g. burning coins)
>> before.
>>
>> This is a generic sharding protocol for all blockchains, including
>> Bitcoin.
>>
>> Users simply say: "My coins on Chain A are going to be sent to Chain B".
>>
>> Then they burn the coins on Chain A, and create a minting transaction on
>> Chain B. The details of how to ensure that coins do not get lost needs to
>> be worked out, but I'm fairly certain the folks on this list can figure out
>> those details.
>>
>> - Thin clients, nodes, and miners, can all very easily verify that said
>> action took place, and therefore accept the "newly minted" coins on B as
>> valid.
>> - Users client software now also knows where to look for the other coins
>> (if for some reason it needs to).
>>
>> This doesn't even need much modification to the Bitcoin protocol as most
>> of the verification is done client-side.
>>
>> It is fully decentralized, and there's no need to give our ownership of
>> our coins to miners to get scale.
>>
>> My sincere apologies if this has been brought up before (in which case, I
>> would be very grateful for a link to the proposal).
>>
>> Cheers,
>> Greg Slepak
>>
>> * This idea is similar in spirit to Interledger.
>>
>> --
>> Please do not email me anything that you are not comfortable also sharing with
>> the NSA.
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>>
>>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171010/de8cb97c/attachment.html>

From contact at taoeffect.com  Tue Oct 10 20:13:20 2017
From: contact at taoeffect.com (Tao Effect)
Date: Tue, 10 Oct 2017 13:13:20 -0700
Subject: [bitcoin-dev] Generalized sharding protocol for decentralized
	scaling without Miners owning our BTC
In-Reply-To: <CAF5CFkg71g5vTCQ3rcbN+7Cjx_B3z7NT78Ug6a6S=KiSS8yo-A@mail.gmail.com>
References: <16D7672F-AA36-47D7-AAEF-E767B9CE09FF@taoeffect.com>
	<CA+XQW1jf-6HCic4beV5GSix8KRzJ-7nTc-ePipfs=ouwvHX0jA@mail.gmail.com>
	<55CAABF4-4FB8-4230-8E51-014C1D347D72@taoeffect.com>
	<CA+XQW1i-3dfRGr2vy=_P0BuXNbnoR_OmmOGGOmCcNEgkZeT_gg@mail.gmail.com>
	<FBD96A02-243E-4E09-9204-EC90DE5EE576@taoeffect.com>
	<daf438d1-7cca-aa0f-6bf7-3eef0d765d49@gmail.com>
	<B79CD106-A06E-4AF1-B67E-6DFE557468F8@taoeffect.com>
	<CAF5CFkg71g5vTCQ3rcbN+7Cjx_B3z7NT78Ug6a6S=KiSS8yo-A@mail.gmail.com>
Message-ID: <B822901D-C074-4987-B793-2A83C8C83EAF@taoeffect.com>

It would not change the number of Bitcoins in existence.

--
Sent from my mobile device.
Please do not email me anything that you are not comfortable also sharing with the NSA.

> On Oct 10, 2017, at 12:50 PM, CryptAxe <cryptaxe at gmail.com> wrote:
> 
> Your method would change the number of Bitcoins in existence. Why? 
> 
>> On Oct 10, 2017 12:47 PM, "Tao Effect via bitcoin-dev" <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> Is that what passes for a technical argument these days? Sheesh.
>> 
>> Whereas in Drivechain users are forced to give up their coins to a single group for whatever sidechains they interact with, the generic sharding algo lets them (1) keep their coins, (2) trust whatever group they want to trust (the miners of the various sidechains).
>> 
>> Drivechain offers objectively worse security.
>> 
>> --
>> Sent from my mobile device.
>> Please do not email me anything that you are not comfortable also sharing with the NSA.
>> 
>>> On Oct 10, 2017, at 8:09 AM, Paul Sztorc via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>> 
>>> I think this response speaks for itself.
>>> 
>>>> On 10/10/2017 10:09 AM, Tao Effect wrote:
>>>> Hi Paul,
>>>> 
>>>> I thought it was clear, but apparently you are getting stuck on the semantics of the word "burn".
>>>> 
>>>> The "burning" applies to the original coins you had.
>>>> 
>>>> When you transfer them back, you get newly minted coins, equivalent to the amount you "burned" on the chain you're transferring from ? as stated in the OP.
>>>> 
>>>> If you don't like the word "burn", pick another one.
>>>> 
>>>> --
>>>> Please do not email me anything that you are not comfortable also sharing with the NSA.
>>>> 
>>>>> On Oct 10, 2017, at 4:20 AM, Paul Sztorc <truthcoin at gmail.com> wrote:
>>>>> 
>>>>> Haha, no. Because you "burned" the coins.
>>>>> 
>>>>>> On Oct 10, 2017 1:20 AM, "Tao Effect" <contact at taoeffect.com> wrote:
>>>>>> Paul,
>>>>>> 
>>>>>> It's a two-way peg.
>>>>>> 
>>>>>> There's nothing preventing transfers back to the main chain.
>>>>>> 
>>>>>> They work in the exact same manner.
>>>>>> 
>>>>>> Cheers,
>>>>>> Greg
>>>>>> 
>>>>>> --
>>>>>> Please do not email me anything that you are not comfortable also sharing with the NSA.
>>>>>> 
>>>>>>> On Oct 9, 2017, at 6:39 PM, Paul Sztorc <truthcoin at gmail.com> wrote:
>>>>>>> 
>>>>>>> That is only a one-way peg, not a two-way.
>>>>>>> 
>>>>>>> In fact, that is exactly what drivechain does, if one chooses parameters for the drivechain that make it impossible for any side-to-main transfer to succeed.
>>>>>>> 
>>>>>>> One-way pegs have strong first-mover disadvantages.
>>>>>>> 
>>>>>>> Paul
>>>>>>> 
>>>>>>> On Oct 9, 2017 9:24 PM, "Tao Effect via bitcoin-dev" <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>>>> Dear list,
>>>>>>> 
>>>>>>> In previous arguments over Drivechain (and Drivechain-like                                             proposals) I promised that better scaling proposals ? that do not sacrifice Bitcoin's security ? would come along.
>>>>>>> 
>>>>>>> I planned to do a detailed writeup, but have decided to just send off this email with what I have, because I'm unlikely to have time to write up a detailed proposal.
>>>>>>> 
>>>>>>> The idea is very simple (and by no means novel*), and I'm sure others have mentioned either exactly it, or similar ideas (e.g. burning coins) before.
>>>>>>> 
>>>>>>> This is a generic sharding protocol for all blockchains, including Bitcoin.
>>>>>>> 
>>>>>>> Users simply say: "My coins on Chain A are going to be sent to                                             Chain B".
>>>>>>> 
>>>>>>> Then they burn the coins on Chain A, and create a minting transaction on Chain B. The details of how to ensure that coins do not get lost needs to be worked out, but I'm fairly certain the folks on this list can figure out those details.
>>>>>>> 
>>>>>>> - Thin clients, nodes, and miners, can all very easily verify that said action took place, and therefore accept the "newly minted" coins on B as valid.
>>>>>>> - Users client software now also knows where to look for the other coins (if for some reason it needs to).
>>>>>>> 
>>>>>>> This doesn't even need much modification to the Bitcoin protocol as most of the verification is done client-side.
>>>>>>> 
>>>>>>> It is fully decentralized, and there's no need to give our ownership of our coins to miners to get scale.
>>>>>>> 
>>>>>>> My sincere apologies if this has been brought up before (in which case, I would be very grateful for a link to the proposal).
>>>>>>> 
>>>>>>> Cheers,
>>>>>>> Greg Slepak
>>>>>>> 
>>>>>>> * This idea is similar in spirit to Interledger.
>>>>>>> 
>>>>>>> --
>>>>>>> Please do not email me anything that you are not comfortable also sharing with the NSA.
>>>>>>> 
>>>>>>> 
>>>>>>> _______________________________________________
>>>>>>> bitcoin-dev mailing list
>>>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>>>> 
>>>>>>> 
>>>>>> 
>>>> 
>>> 
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> 
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171010/f093139f/attachment-0001.html>

From lvella at gmail.com  Tue Oct 10 20:18:39 2017
From: lvella at gmail.com (Lucas Clemente Vella)
Date: Tue, 10 Oct 2017 17:18:39 -0300
Subject: [bitcoin-dev] Generalized sharding protocol for decentralized
 scaling without Miners owning our BTC
In-Reply-To: <CA+XQW1jf-6HCic4beV5GSix8KRzJ-7nTc-ePipfs=ouwvHX0jA@mail.gmail.com>
References: <16D7672F-AA36-47D7-AAEF-E767B9CE09FF@taoeffect.com>
	<CA+XQW1jf-6HCic4beV5GSix8KRzJ-7nTc-ePipfs=ouwvHX0jA@mail.gmail.com>
Message-ID: <CAGCathy2U7+Qy4gLB0S_j-kArvGHuELDgzweFR4grQQ9AZgAbg@mail.gmail.com>

2017-10-09 22:39 GMT-03:00 Paul Sztorc via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org>:

> That is only a one-way peg, not a two-way.
>
> In fact, that is exactly what drivechain does, if one chooses parameters
> for the drivechain that make it impossible for any side-to-main transfer to
> succeed.
>
> One-way pegs have strong first-mover disadvantages.
>

I understand the first-mover disadvantages, but I keep thinking that if the
new chain is Pareto optimal, i.e. is in all aspects at least good as the
original chain, but in some so much better to justify the change, the
initial resistance is an unstable equilibrium. Like a herd of buffaloes
attacking a lion: the first buffalo to attack is in awful disadvantage, but
if a critical mass of the herd follows, the movement succeeds beyond
turning back, and every buffalo benefited, both those who attacked the lion
and those that didn't (because the lion was chased away or killed).

-- 
Lucas Clemente Vella
lvella at gmail.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171010/533ac1c1/attachment.html>

From truthcoin at gmail.com  Tue Oct 10 20:23:45 2017
From: truthcoin at gmail.com (Paul Sztorc)
Date: Tue, 10 Oct 2017 16:23:45 -0400
Subject: [bitcoin-dev] Generalized sharding protocol for decentralized
 scaling without Miners owning our BTC
In-Reply-To: <CA+XQW1hjjY3btufV36AS7JO=CQ7TMwK7ohJ4QETbNuGWyQ6=dA@mail.gmail.com>
References: <16D7672F-AA36-47D7-AAEF-E767B9CE09FF@taoeffect.com>
	<CA+XQW1jf-6HCic4beV5GSix8KRzJ-7nTc-ePipfs=ouwvHX0jA@mail.gmail.com>
	<CAGCathy2U7+Qy4gLB0S_j-kArvGHuELDgzweFR4grQQ9AZgAbg@mail.gmail.com>
	<CA+XQW1hjjY3btufV36AS7JO=CQ7TMwK7ohJ4QETbNuGWyQ6=dA@mail.gmail.com>
Message-ID: <CA+XQW1giGJxq9WWZ1XRuKM4kPeSOU018eBgX1MZhEVsH1EwzKQ@mail.gmail.com>

What if two sidechains are implemented at once? What if people get excited
about one sidechain today, but a second even-better one is published the
very next week? What if the original mainchain decides to integrate the
features of the sidechain that you just one-way pegged to?

In these cases, the user looses money, whereas in the two-way peg they
would not lose a thing.

While the one-way peg is interesting, it really doesn't compare.

Paul

On Oct 10, 2017 4:19 PM, "Lucas Clemente Vella" <lvella at gmail.com> wrote:

2017-10-09 22:39 GMT-03:00 Paul Sztorc via bitcoin-dev <bitcoin-dev at lists.
linuxfoundation.org>:

> That is only a one-way peg, not a two-way.
>
> In fact, that is exactly what drivechain does, if one chooses parameters
> for the drivechain that make it impossible for any side-to-main transfer to
> succeed.
>
> One-way pegs have strong first-mover disadvantages.
>

I understand the first-mover disadvantages, but I keep thinking that if the
new chain is Pareto optimal, i.e. is in all aspects at least good as the
original chain, but in some so much better to justify the change, the
initial resistance is an unstable equilibrium. Like a herd of buffaloes
attacking a lion: the first buffalo to attack is in awful disadvantage, but
if a critical mass of the herd follows, the movement succeeds beyond
turning back, and every buffalo benefited, both those who attacked the lion
and those that didn't (because the lion was chased away or killed).

-- 
Lucas Clemente Vella
lvella at gmail.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171010/a29725fb/attachment.html>

From contact at taoeffect.com  Tue Oct 10 20:43:17 2017
From: contact at taoeffect.com (Tao Effect)
Date: Tue, 10 Oct 2017 13:43:17 -0700
Subject: [bitcoin-dev] Generalized sharding protocol for decentralized
	scaling without Miners owning our BTC
In-Reply-To: <F437D8FA-892B-46C7-B0B8-8B5487DD8034@gmail.com>
References: <16D7672F-AA36-47D7-AAEF-E767B9CE09FF@taoeffect.com>
	<CA+XQW1jf-6HCic4beV5GSix8KRzJ-7nTc-ePipfs=ouwvHX0jA@mail.gmail.com>
	<55CAABF4-4FB8-4230-8E51-014C1D347D72@taoeffect.com>
	<CA+XQW1i-3dfRGr2vy=_P0BuXNbnoR_OmmOGGOmCcNEgkZeT_gg@mail.gmail.com>
	<FBD96A02-243E-4E09-9204-EC90DE5EE576@taoeffect.com>
	<daf438d1-7cca-aa0f-6bf7-3eef0d765d49@gmail.com>
	<B79CD106-A06E-4AF1-B67E-6DFE557468F8@taoeffect.com>
	<CAF5CFkg71g5vTCQ3rcbN+7Cjx_B3z7NT78Ug6a6S=KiSS8yo-A@mail.gmail.com>
	<B822901D-C074-4987-B793-2A83C8C83EAF@taoeffect.com>
	<F437D8FA-892B-46C7-B0B8-8B5487DD8034@gmail.com>
Message-ID: <C216A90B-D08D-4B89-98EE-761ED303F180@taoeffect.com>

What?

That is not correct.

There is a fixed amount of Bitcoin, as I said.

The only difference is what chain it is on.

It is precisely because there is a fixed amount that when you burn-to-withdraw you mint on another chain.

I will not respond to any more emails unless they?re from core developers. Gotta run.

--
Sent from my mobile device.
Please do not email me anything that you are not comfortable also sharing with the NSA.

> On Oct 10, 2017, at 1:23 PM, James Hudon <jameshudon at gmail.com> wrote:
> 
> You're asking for newly minted bitcoin to go to you but you burned the bitcoin used in the peg. You're effectively losing your money and then stealing from the miners to gain it back. The miners had to issue your amount of bitcoin 2 times (once for your original bitcoin, again to make you whole). Why would they agree to this?
> --
> hudon
> 
>> On Oct 10, 2017, at 13:13, Tao Effect via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> 
>> It would not change the number of Bitcoins in existence.
>> 
>> --
>> Sent from my mobile device.
>> Please do not email me anything that you are not comfortable also sharing with the NSA.
>> 
>>> On Oct 10, 2017, at 12:50 PM, CryptAxe <cryptaxe at gmail.com> wrote:
>>> 
>>> Your method would change the number of Bitcoins in existence. Why? 
>>> 
>>> On Oct 10, 2017 12:47 PM, "Tao Effect via bitcoin-dev" <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>> Is that what passes for a technical argument these days? Sheesh.
>>> 
>>> Whereas in Drivechain users are forced to give up their coins to a single group for whatever sidechains they interact with, the generic sharding algo lets them (1) keep their coins, (2) trust whatever group they want to trust (the miners of the various sidechains).
>>> 
>>> Drivechain offers objectively worse security.
>>> 
>>> --
>>> Sent from my mobile device.
>>> Please do not email me anything that you are not comfortable also sharing with the NSA.
>>> 
>>>> On Oct 10, 2017, at 8:09 AM, Paul Sztorc via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>> 
>>>> I think this response speaks for itself.
>>>> 
>>>>> On 10/10/2017 10:09 AM, Tao Effect wrote:
>>>>> Hi Paul,
>>>>> 
>>>>> I thought it was clear, but apparently you are getting stuck on the semantics of the word "burn".
>>>>> 
>>>>> The "burning" applies to the original coins you had.
>>>>> 
>>>>> When you transfer them back, you get newly minted coins, equivalent to the amount you "burned" on the chain you're transferring from ? as stated in the OP.
>>>>> 
>>>>> If you don't like the word "burn", pick another one.
>>>>> 
>>>>> --
>>>>> Please do not email me anything that you are not comfortable also sharing with the NSA.
>>>>> 
>>>>>> On Oct 10, 2017, at 4:20 AM, Paul Sztorc <truthcoin at gmail.com> wrote:
>>>>>> 
>>>>>> Haha, no. Because you "burned" the coins.
>>>>>> 
>>>>>> On Oct 10, 2017 1:20 AM, "Tao Effect" <contact at taoeffect.com> wrote:
>>>>>> Paul,
>>>>>> 
>>>>>> It's a two-way peg.
>>>>>> 
>>>>>> There's nothing preventing transfers back to the main chain.
>>>>>> 
>>>>>> They work in the exact same manner.
>>>>>> 
>>>>>> Cheers,
>>>>>> Greg
>>>>>> 
>>>>>> --
>>>>>> Please do not email me anything that you are not comfortable also sharing with the NSA.
>>>>>> 
>>>>>>> On Oct 9, 2017, at 6:39 PM, Paul Sztorc <truthcoin at gmail.com> wrote:
>>>>>>> 
>>>>>>> That is only a one-way peg, not a two-way.
>>>>>>> 
>>>>>>> In fact, that is exactly what drivechain does, if one chooses parameters for the drivechain that make it impossible for any side-to-main transfer to succeed.
>>>>>>> 
>>>>>>> One-way pegs have strong first-mover disadvantages.
>>>>>>> 
>>>>>>> Paul
>>>>>>> 
>>>>>>> On Oct 9, 2017 9:24 PM, "Tao Effect via bitcoin-dev" <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>>>> Dear list,
>>>>>>> 
>>>>>>> In previous arguments over Drivechain (and Drivechain-like proposals) I promised that better scaling proposals ? that do not sacrifice Bitcoin's security ? would come along.
>>>>>>> 
>>>>>>> I planned to do a detailed writeup, but have decided to just send off this email with what I have, because I'm unlikely to have time to write up a detailed proposal.
>>>>>>> 
>>>>>>> The idea is very simple (and by no means novel*), and I'm sure others have mentioned either exactly it, or similar ideas (e.g. burning coins) before.
>>>>>>> 
>>>>>>> This is a generic sharding protocol for all blockchains, including Bitcoin.
>>>>>>> 
>>>>>>> Users simply say: "My coins on Chain A are going to be sent to Chain B".
>>>>>>> 
>>>>>>> Then they burn the coins on Chain A, and create a minting transaction on Chain B. The details of how to ensure that coins do not get lost needs to be worked out, but I'm fairly certain the folks on this list can figure out those details.
>>>>>>> 
>>>>>>> - Thin clients, nodes, and miners, can all very easily verify that said action took place, and therefore accept the "newly minted" coins on B as valid.
>>>>>>> - Users client software now also knows where to look for the other coins (if for some reason it needs to).
>>>>>>> 
>>>>>>> This doesn't even need much modification to the Bitcoin protocol as most of the verification is done client-side.
>>>>>>> 
>>>>>>> It is fully decentralized, and there's no need to give our ownership of our coins to miners to get scale.
>>>>>>> 
>>>>>>> My sincere apologies if this has been brought up before (in which case, I would be very grateful for a link to the proposal).
>>>>>>> 
>>>>>>> Cheers,
>>>>>>> Greg Slepak
>>>>>>> 
>>>>>>> * This idea is similar in spirit to Interledger.
>>>>>>> 
>>>>>>> --
>>>>>>> Please do not email me anything that you are not comfortable also sharing with the NSA.
>>>>>>> 
>>>>>>> 
>>>>>>> _______________________________________________
>>>>>>> bitcoin-dev mailing list
>>>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>>>> 
>>>>>>> 
>>>>>> 
>>>>> 
>>>> 
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>> 
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>> 
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 


From lvella at gmail.com  Tue Oct 10 20:23:43 2017
From: lvella at gmail.com (Lucas Clemente Vella)
Date: Tue, 10 Oct 2017 17:23:43 -0300
Subject: [bitcoin-dev] Generalized sharding protocol for decentralized
 scaling without Miners owning our BTC
In-Reply-To: <FBD96A02-243E-4E09-9204-EC90DE5EE576@taoeffect.com>
References: <16D7672F-AA36-47D7-AAEF-E767B9CE09FF@taoeffect.com>
	<CA+XQW1jf-6HCic4beV5GSix8KRzJ-7nTc-ePipfs=ouwvHX0jA@mail.gmail.com>
	<55CAABF4-4FB8-4230-8E51-014C1D347D72@taoeffect.com>
	<CA+XQW1i-3dfRGr2vy=_P0BuXNbnoR_OmmOGGOmCcNEgkZeT_gg@mail.gmail.com>
	<FBD96A02-243E-4E09-9204-EC90DE5EE576@taoeffect.com>
Message-ID: <CAGCathxqMOd3woSPF8DmnYndAo8vEsm80uS5V517vzcVEhjzOQ@mail.gmail.com>

2017-10-10 11:09 GMT-03:00 Tao Effect via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org>:

> When you transfer them back, you get newly minted coins, equivalent to the
> amount you "burned" on the chain you're transferring from ? as stated in
> the OP.
>

If you have to change Bitcoin to recognize a transfer from the sidechain
back into Bitcoin, you kill the purpose of the sidechain. You could as well
just change the Bitcoin to implement whatever desirable features the
sidechain would have. The whole idea of sidechains is to keep Bicoin
unchangend, and allow for the voluntary transfer of tokens out of Bitcoin
to the sidechain of your choosing.


-- 
Lucas Clemente Vella
lvella at gmail.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171010/3979cda4/attachment-0001.html>

From jameshudon at gmail.com  Tue Oct 10 20:57:03 2017
From: jameshudon at gmail.com (James Hudon)
Date: Tue, 10 Oct 2017 13:57:03 -0700
Subject: [bitcoin-dev] Generalized sharding protocol for decentralized
 scaling without Miners owning our BTC
In-Reply-To: <C216A90B-D08D-4B89-98EE-761ED303F180@taoeffect.com>
References: <16D7672F-AA36-47D7-AAEF-E767B9CE09FF@taoeffect.com>
	<CA+XQW1jf-6HCic4beV5GSix8KRzJ-7nTc-ePipfs=ouwvHX0jA@mail.gmail.com>
	<55CAABF4-4FB8-4230-8E51-014C1D347D72@taoeffect.com>
	<CA+XQW1i-3dfRGr2vy=_P0BuXNbnoR_OmmOGGOmCcNEgkZeT_gg@mail.gmail.com>
	<FBD96A02-243E-4E09-9204-EC90DE5EE576@taoeffect.com>
	<daf438d1-7cca-aa0f-6bf7-3eef0d765d49@gmail.com>
	<B79CD106-A06E-4AF1-B67E-6DFE557468F8@taoeffect.com>
	<CAF5CFkg71g5vTCQ3rcbN+7Cjx_B3z7NT78Ug6a6S=KiSS8yo-A@mail.gmail.com>
	<B822901D-C074-4987-B793-2A83C8C83EAF@taoeffect.com>
	<F437D8FA-892B-46C7-B0B8-8B5487DD8034@gmail.com>
	<C216A90B-D08D-4B89-98EE-761ED303F180@taoeffect.com>
Message-ID: <C1F5B781-1250-46CB-A6BB-930FC548239D@gmail.com>

You're asking for newly minted bitcoin to go to you but you burned the bitcoin used in the peg. You're effectively losing your money and then stealing from the miners to gain it back. The miners had to issue your amount of bitcoin 2 times (once for your original bitcoin, again to make you whole). Why would they agree to this?
--
hudon

> On Oct 10, 2017, at 13:43, Tao Effect via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> What?
> 
> That is not correct.
> 
> There is a fixed amount of Bitcoin, as I said.
> 
> The only difference is what chain it is on.
> 
> It is precisely because there is a fixed amount that when you burn-to-withdraw you mint on another chain.
> 
> I will not respond to any more emails unless they?re from core developers. Gotta run.
> 
> --
> Sent from my mobile device.
> Please do not email me anything that you are not comfortable also sharing with the NSA.
> 
>> On Oct 10, 2017, at 1:23 PM, James Hudon <jameshudon at gmail.com> wrote:
>> 
>> You're asking for newly minted bitcoin to go to you but you burned the bitcoin used in the peg. You're effectively losing your money and then stealing from the miners to gain it back. The miners had to issue your amount of bitcoin 2 times (once for your original bitcoin, again to make you whole). Why would they agree to this?
>> --
>> hudon
>> 
>>> On Oct 10, 2017, at 13:13, Tao Effect via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>> 
>>> It would not change the number of Bitcoins in existence.
>>> 
>>> --
>>> Sent from my mobile device.
>>> Please do not email me anything that you are not comfortable also sharing with the NSA.
>>> 
>>>> On Oct 10, 2017, at 12:50 PM, CryptAxe <cryptaxe at gmail.com> wrote:
>>>> 
>>>> Your method would change the number of Bitcoins in existence. Why? 
>>>> 
>>>> On Oct 10, 2017 12:47 PM, "Tao Effect via bitcoin-dev" <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>> Is that what passes for a technical argument these days? Sheesh.
>>>> 
>>>> Whereas in Drivechain users are forced to give up their coins to a single group for whatever sidechains they interact with, the generic sharding algo lets them (1) keep their coins, (2) trust whatever group they want to trust (the miners of the various sidechains).
>>>> 
>>>> Drivechain offers objectively worse security.
>>>> 
>>>> --
>>>> Sent from my mobile device.
>>>> Please do not email me anything that you are not comfortable also sharing with the NSA.
>>>> 
>>>>> On Oct 10, 2017, at 8:09 AM, Paul Sztorc via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>> 
>>>>> I think this response speaks for itself.
>>>>> 
>>>>>> On 10/10/2017 10:09 AM, Tao Effect wrote:
>>>>>> Hi Paul,
>>>>>> 
>>>>>> I thought it was clear, but apparently you are getting stuck on the semantics of the word "burn".
>>>>>> 
>>>>>> The "burning" applies to the original coins you had.
>>>>>> 
>>>>>> When you transfer them back, you get newly minted coins, equivalent to the amount you "burned" on the chain you're transferring from ? as stated in the OP.
>>>>>> 
>>>>>> If you don't like the word "burn", pick another one.
>>>>>> 
>>>>>> --
>>>>>> Please do not email me anything that you are not comfortable also sharing with the NSA.
>>>>>> 
>>>>>>> On Oct 10, 2017, at 4:20 AM, Paul Sztorc <truthcoin at gmail.com> wrote:
>>>>>>> 
>>>>>>> Haha, no. Because you "burned" the coins.
>>>>>>> 
>>>>>>> On Oct 10, 2017 1:20 AM, "Tao Effect" <contact at taoeffect.com> wrote:
>>>>>>> Paul,
>>>>>>> 
>>>>>>> It's a two-way peg.
>>>>>>> 
>>>>>>> There's nothing preventing transfers back to the main chain.
>>>>>>> 
>>>>>>> They work in the exact same manner.
>>>>>>> 
>>>>>>> Cheers,
>>>>>>> Greg
>>>>>>> 
>>>>>>> --
>>>>>>> Please do not email me anything that you are not comfortable also sharing with the NSA.
>>>>>>> 
>>>>>>>> On Oct 9, 2017, at 6:39 PM, Paul Sztorc <truthcoin at gmail.com> wrote:
>>>>>>>> 
>>>>>>>> That is only a one-way peg, not a two-way.
>>>>>>>> 
>>>>>>>> In fact, that is exactly what drivechain does, if one chooses parameters for the drivechain that make it impossible for any side-to-main transfer to succeed.
>>>>>>>> 
>>>>>>>> One-way pegs have strong first-mover disadvantages.
>>>>>>>> 
>>>>>>>> Paul
>>>>>>>> 
>>>>>>>> On Oct 9, 2017 9:24 PM, "Tao Effect via bitcoin-dev" <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>>>>> Dear list,
>>>>>>>> 
>>>>>>>> In previous arguments over Drivechain (and Drivechain-like proposals) I promised that better scaling proposals ? that do not sacrifice Bitcoin's security ? would come along.
>>>>>>>> 
>>>>>>>> I planned to do a detailed writeup, but have decided to just send off this email with what I have, because I'm unlikely to have time to write up a detailed proposal.
>>>>>>>> 
>>>>>>>> The idea is very simple (and by no means novel*), and I'm sure others have mentioned either exactly it, or similar ideas (e.g. burning coins) before.
>>>>>>>> 
>>>>>>>> This is a generic sharding protocol for all blockchains, including Bitcoin.
>>>>>>>> 
>>>>>>>> Users simply say: "My coins on Chain A are going to be sent to Chain B".
>>>>>>>> 
>>>>>>>> Then they burn the coins on Chain A, and create a minting transaction on Chain B. The details of how to ensure that coins do not get lost needs to be worked out, but I'm fairly certain the folks on this list can figure out those details.
>>>>>>>> 
>>>>>>>> - Thin clients, nodes, and miners, can all very easily verify that said action took place, and therefore accept the "newly minted" coins on B as valid.
>>>>>>>> - Users client software now also knows where to look for the other coins (if for some reason it needs to).
>>>>>>>> 
>>>>>>>> This doesn't even need much modification to the Bitcoin protocol as most of the verification is done client-side.
>>>>>>>> 
>>>>>>>> It is fully decentralized, and there's no need to give our ownership of our coins to miners to get scale.
>>>>>>>> 
>>>>>>>> My sincere apologies if this has been brought up before (in which case, I would be very grateful for a link to the proposal).
>>>>>>>> 
>>>>>>>> Cheers,
>>>>>>>> Greg Slepak
>>>>>>>> 
>>>>>>>> * This idea is similar in spirit to Interledger.
>>>>>>>> 
>>>>>>>> --
>>>>>>>> Please do not email me anything that you are not comfortable also sharing with the NSA.
>>>>>>>> 
>>>>>>>> 
>>>>>>>> _______________________________________________
>>>>>>>> bitcoin-dev mailing list
>>>>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>>>>> 
>>>>>>>> 
>>>>>>> 
>>>>>> 
>>>>> 
>>>>> _______________________________________________
>>>>> bitcoin-dev mailing list
>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>> 
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>> 
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From cryptaxe at gmail.com  Tue Oct 10 20:49:20 2017
From: cryptaxe at gmail.com (CryptAxe)
Date: Tue, 10 Oct 2017 13:49:20 -0700
Subject: [bitcoin-dev] Generalized sharding protocol for decentralized
 scaling without Miners owning our BTC
In-Reply-To: <C216A90B-D08D-4B89-98EE-761ED303F180@taoeffect.com>
References: <16D7672F-AA36-47D7-AAEF-E767B9CE09FF@taoeffect.com>
	<CA+XQW1jf-6HCic4beV5GSix8KRzJ-7nTc-ePipfs=ouwvHX0jA@mail.gmail.com>
	<55CAABF4-4FB8-4230-8E51-014C1D347D72@taoeffect.com>
	<CA+XQW1i-3dfRGr2vy=_P0BuXNbnoR_OmmOGGOmCcNEgkZeT_gg@mail.gmail.com>
	<FBD96A02-243E-4E09-9204-EC90DE5EE576@taoeffect.com>
	<daf438d1-7cca-aa0f-6bf7-3eef0d765d49@gmail.com>
	<B79CD106-A06E-4AF1-B67E-6DFE557468F8@taoeffect.com>
	<CAF5CFkg71g5vTCQ3rcbN+7Cjx_B3z7NT78Ug6a6S=KiSS8yo-A@mail.gmail.com>
	<B822901D-C074-4987-B793-2A83C8C83EAF@taoeffect.com>
	<F437D8FA-892B-46C7-B0B8-8B5487DD8034@gmail.com>
	<C216A90B-D08D-4B89-98EE-761ED303F180@taoeffect.com>
Message-ID: <CAF5CFkjz5WvkR_4HL2NSevDzHsG_LUTsYS_A9BHcOQctSynQoQ@mail.gmail.com>

You could technically call myself and Chris 'core developers'. You don't
get to have a fixed rate of Bitcoin and a second way to mint coins at the
same time.

On Oct 10, 2017 1:46 PM, "Tao Effect via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> What?
>
> That is not correct.
>
> There is a fixed amount of Bitcoin, as I said.
>
> The only difference is what chain it is on.
>
> It is precisely because there is a fixed amount that when you
> burn-to-withdraw you mint on another chain.
>
> I will not respond to any more emails unless they?re from core developers.
> Gotta run.
>
> --
> Sent from my mobile device.
> Please do not email me anything that you are not comfortable also sharing
> with the NSA.
>
> > On Oct 10, 2017, at 1:23 PM, James Hudon <jameshudon at gmail.com> wrote:
> >
> > You're asking for newly minted bitcoin to go to you but you burned the
> bitcoin used in the peg. You're effectively losing your money and then
> stealing from the miners to gain it back. The miners had to issue your
> amount of bitcoin 2 times (once for your original bitcoin, again to make
> you whole). Why would they agree to this?
> > --
> > hudon
> >
> >> On Oct 10, 2017, at 13:13, Tao Effect via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>
> >> It would not change the number of Bitcoins in existence.
> >>
> >> --
> >> Sent from my mobile device.
> >> Please do not email me anything that you are not comfortable also
> sharing with the NSA.
> >>
> >>> On Oct 10, 2017, at 12:50 PM, CryptAxe <cryptaxe at gmail.com> wrote:
> >>>
> >>> Your method would change the number of Bitcoins in existence. Why?
> >>>
> >>> On Oct 10, 2017 12:47 PM, "Tao Effect via bitcoin-dev" <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>> Is that what passes for a technical argument these days? Sheesh.
> >>>
> >>> Whereas in Drivechain users are forced to give up their coins to a
> single group for whatever sidechains they interact with, the generic
> sharding algo lets them (1) keep their coins, (2) trust whatever group they
> want to trust (the miners of the various sidechains).
> >>>
> >>> Drivechain offers objectively worse security.
> >>>
> >>> --
> >>> Sent from my mobile device.
> >>> Please do not email me anything that you are not comfortable also
> sharing with the NSA.
> >>>
> >>>> On Oct 10, 2017, at 8:09 AM, Paul Sztorc via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>>>
> >>>> I think this response speaks for itself.
> >>>>
> >>>>> On 10/10/2017 10:09 AM, Tao Effect wrote:
> >>>>> Hi Paul,
> >>>>>
> >>>>> I thought it was clear, but apparently you are getting stuck on the
> semantics of the word "burn".
> >>>>>
> >>>>> The "burning" applies to the original coins you had.
> >>>>>
> >>>>> When you transfer them back, you get newly minted coins, equivalent
> to the amount you "burned" on the chain you're transferring from ? as
> stated in the OP.
> >>>>>
> >>>>> If you don't like the word "burn", pick another one.
> >>>>>
> >>>>> --
> >>>>> Please do not email me anything that you are not comfortable also
> sharing with the NSA.
> >>>>>
> >>>>>> On Oct 10, 2017, at 4:20 AM, Paul Sztorc <truthcoin at gmail.com>
> wrote:
> >>>>>>
> >>>>>> Haha, no. Because you "burned" the coins.
> >>>>>>
> >>>>>> On Oct 10, 2017 1:20 AM, "Tao Effect" <contact at taoeffect.com>
> wrote:
> >>>>>> Paul,
> >>>>>>
> >>>>>> It's a two-way peg.
> >>>>>>
> >>>>>> There's nothing preventing transfers back to the main chain.
> >>>>>>
> >>>>>> They work in the exact same manner.
> >>>>>>
> >>>>>> Cheers,
> >>>>>> Greg
> >>>>>>
> >>>>>> --
> >>>>>> Please do not email me anything that you are not comfortable also
> sharing with the NSA.
> >>>>>>
> >>>>>>> On Oct 9, 2017, at 6:39 PM, Paul Sztorc <truthcoin at gmail.com>
> wrote:
> >>>>>>>
> >>>>>>> That is only a one-way peg, not a two-way.
> >>>>>>>
> >>>>>>> In fact, that is exactly what drivechain does, if one chooses
> parameters for the drivechain that make it impossible for any side-to-main
> transfer to succeed.
> >>>>>>>
> >>>>>>> One-way pegs have strong first-mover disadvantages.
> >>>>>>>
> >>>>>>> Paul
> >>>>>>>
> >>>>>>> On Oct 9, 2017 9:24 PM, "Tao Effect via bitcoin-dev" <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>>>>>> Dear list,
> >>>>>>>
> >>>>>>> In previous arguments over Drivechain (and Drivechain-like
> proposals) I promised that better scaling proposals ? that do not sacrifice
> Bitcoin's security ? would come along.
> >>>>>>>
> >>>>>>> I planned to do a detailed writeup, but have decided to just send
> off this email with what I have, because I'm unlikely to have time to write
> up a detailed proposal.
> >>>>>>>
> >>>>>>> The idea is very simple (and by no means novel*), and I'm sure
> others have mentioned either exactly it, or similar ideas (e.g. burning
> coins) before.
> >>>>>>>
> >>>>>>> This is a generic sharding protocol for all blockchains, including
> Bitcoin.
> >>>>>>>
> >>>>>>> Users simply say: "My coins on Chain A are going to be sent to
> Chain B".
> >>>>>>>
> >>>>>>> Then they burn the coins on Chain A, and create a minting
> transaction on Chain B. The details of how to ensure that coins do not get
> lost needs to be worked out, but I'm fairly certain the folks on this list
> can figure out those details.
> >>>>>>>
> >>>>>>> - Thin clients, nodes, and miners, can all very easily verify that
> said action took place, and therefore accept the "newly minted" coins on B
> as valid.
> >>>>>>> - Users client software now also knows where to look for the other
> coins (if for some reason it needs to).
> >>>>>>>
> >>>>>>> This doesn't even need much modification to the Bitcoin protocol
> as most of the verification is done client-side.
> >>>>>>>
> >>>>>>> It is fully decentralized, and there's no need to give our
> ownership of our coins to miners to get scale.
> >>>>>>>
> >>>>>>> My sincere apologies if this has been brought up before (in which
> case, I would be very grateful for a link to the proposal).
> >>>>>>>
> >>>>>>> Cheers,
> >>>>>>> Greg Slepak
> >>>>>>>
> >>>>>>> * This idea is similar in spirit to Interledger.
> >>>>>>>
> >>>>>>> --
> >>>>>>> Please do not email me anything that you are not comfortable also
> sharing with the NSA.
> >>>>>>>
> >>>>>>>
> >>>>>>> _______________________________________________
> >>>>>>> bitcoin-dev mailing list
> >>>>>>> bitcoin-dev at lists.linuxfoundation.org
> >>>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >>>>>>>
> >>>>>>>
> >>>>>>
> >>>>>
> >>>>
> >>>> _______________________________________________
> >>>> bitcoin-dev mailing list
> >>>> bitcoin-dev at lists.linuxfoundation.org
> >>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >>>
> >>> _______________________________________________
> >>> bitcoin-dev mailing list
> >>> bitcoin-dev at lists.linuxfoundation.org
> >>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >>>
> >> _______________________________________________
> >> bitcoin-dev mailing list
> >> bitcoin-dev at lists.linuxfoundation.org
> >> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171010/2693944e/attachment-0001.html>

From zawy at yahoo.com  Wed Oct 11 01:29:54 2017
From: zawy at yahoo.com (Scott Roberts)
Date: Wed, 11 Oct 2017 01:29:54 +0000 (UTC)
Subject: [bitcoin-dev] New difficulty algorithm needed for
	SegWit2x	fork? (reformatted text)
References: <1885357.5164984.1507685394910.ref@mail.yahoo.com>
Message-ID: <1885357.5164984.1507685394910@mail.yahoo.com>

I agree: a new difficulty algorithm starting from zero is inconceivably 
rushed. But it's also inconceivable to not have one ready in two months 
if my understanding of our current situation is correct. Is there any 
complaint or suggestion about this algorithm or the appropriate goals of 
an ideal difficulty algorithm? I feel like there is a discussion that needs 
to be hashed out before a draft BIP at the HF page, but I do not know 
where is best or who would be interested. If the community shows it is 
receptive and supportive I think I could get Karbowanek coin to put it 
into live action and solicit hash attacks. They are currently using a 
simpler N=17 like this since last November. They have tested all my 
attempted improvements the past few months, so they are familiar with all 
the in and outs. 

This particular coin split is looking different. Assuming users currently 
prefer SW, it still seems like miner support is going to convince enough 
users that SegWit2x is a worthy if not superior alternative. The result 
could be both coins oscillating with long delays, as long as the price is 
similar. As soon as it is not similar, maybe the loser will be in a death 
spiral, pushed to the margin like previous coins. This might be a bitcoin 
feature. But the 2016 window seems like it is too brutal. It seems like it 
will result in an accidental winner before the better coin can be 
determined by more rational means.

From benkloester at gmail.com  Wed Oct 11 01:44:52 2017
From: benkloester at gmail.com (Ben Kloester)
Date: Wed, 11 Oct 2017 12:44:52 +1100
Subject: [bitcoin-dev] New difficulty algorithm needed for SegWit2x
 fork? (reformatted text)
In-Reply-To: <B34C76A2-4FD7-4BA9-81AD-816B163463C9@friedenbach.org>
References: <1213518291.4328204.1507589852818.ref@mail.yahoo.com>
	<1213518291.4328204.1507589852818@mail.yahoo.com>
	<B34C76A2-4FD7-4BA9-81AD-816B163463C9@friedenbach.org>
Message-ID: <CANgJ=T827Z=epjFvhSGNg32X3mXH3XyMNcvuXSLYjf369X1gjA@mail.gmail.com>

Mark, this seems an awful lot like an answer of "no", to my question "Is
there a contingency plan in the case that the incumbent chain following the
Bitcoin Core consensus rules comes under 51% attack?" - is this a correct
interpretation?

In fact, beyond a no, it seems like a "no, and I disagree with the idea of
creating one".

So if Bitcoin comes under successful 51%, the project, in your vision, has
simply failed?

*Ben Kloester*

On 10 October 2017 at 13:19, Mark Friedenbach via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> The problem of fast acting but non vulnerable difficulty adjustment
> algorithms is interesting. I would certainly like to see this space further
> explored, and even have some ideas myself.
>
> However without commenting on the technical merits of this specific
> proposal, I think it must be said upfront that the stated goal is not good.
> The largest technical concern (ignoring governance) over B2X is that it is
> a rushed, poorly reviewed hard fork. Hard forks should not be rushed, and
> they should receive more than the usual level of expert and community
> review.
>
> I?m that light, doing an even more rushed hard fork on an even newer idea
> with even less review would be hypocritical at best. I would suggest
> reframing as a hardfork wishlist research problem for the next properly
> planned hard fork, if one occurs. You might also find the hardfork research
> group a more accommodating venue for this discussion:
>
> https://bitcoinhardforkresearch.github.io/
>
> On Oct 9, 2017, at 3:57 PM, Scott Roberts via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Sorry, my previous email did not have the plain text I intended.
>
> Background:
>
> The bitcoin difficulty algorithm does not seem to be a good one. If there
> is a fork due to miners seeking maximum profit without due regard to
> security, users, and nodes, the "better" coin could end up being the
> minority chain. If 90% of hashrate is really going to at least initially
> go
> towards using SegWit2x, BTC would face 10x delays in confirmations
> until the next difficulty adjustment, negatively affecting its price
> relative
> to BTC1, causing further delays from even more miner abandonment
> (until the next adjustment). The 10% miners remaining on BTC do not
> inevitably lose by staying to endure 10x delays because they have 10x
> less competition, and the same situation applies to BTC1 miners. If the
> prices are the same and stable, all seems well for everyone, other things
> aside. But if the BTC price does not fall to reflect the decreased
> hashrate,
> he situation seems to be a big problem for both coins: BTC1 miners will
> jump back to BTC when the difficulty adjustment occurs, initiating a
> potentially never-ending oscillation between the two coins, potentially
> worse than what BCH is experiencing.  They will not issue coins too fast
> like BCH because that is a side effect of the asymmetry in BCH's rise and
> fall algorithm.
>
> Solution:
>
> Hard fork to implement a new difficulty algorithm that uses a simple
> rolling
> average with a much smaller window.  Many small coins have done this as
> a way to stop big miners from coming on and then suddenly leaving, leaving
> constant miners stuck with a high difficulty for the rest of a (long)
> averaging
> window.  Even better, adjust the reward based on recent solvetimes to
> motivate more mining (or less) if the solvetimes are too slow (or too
> fast).
> This will keep keep coin issuance rate perfectly on schedule with real
> time.
>
> I recommend the following for Bitcoin, as fast, simple, and better than
> any
> other difficulty algorithm I'm aware of.  This is the result of a lot of
> work the
> past year.
>
> === Begin difficulty algorithm ===
> # Zawy v6 difficulty algorithm (modified for bitcoin)
> # Unmodified Zawy v6 for alt coins:
> # http://zawy1.blogspot.com/2017/07/best-difficulty-
> algorithm-zawy-v1b.html
> # All my failed attempts at something better:
> # https://github.com/seredat/karbowanec/commit/
> 231db5270acb2e673a641a1800be910ce345668a
> #
> # Keep negative solvetimes to correct bad timestamps.
> # Do not be tempted to use:
> # next_D = sum(last N Ds) * T / [max(last N TSs) - min(last N TSs];
> # ST= Solvetime, TS = timestamp
>
> # set constants until next hard fork:
>
> T=600; # coin's TargetSolvetime
> N=30; # Averaging window. Smoother than N=15, faster response than N=60.
> X=5;
> limit = X^(2/N); # limit rise and fall in case of timestamp manipulation
> adjust = 1/(1+0.67/N);  # keeps avg solvetime on track
>
> # begin difficulty algorithm
>
> avg_ST=0; avg_D=0;
> for ( i=height;  i > height-N;  i--) {  # go through N most recent blocks
> avg_ST += (TS[i] - TS[i-1]) / N;
> avg_D += D[i]/N;
> }
> avg_ST = T*limit if avg_ST > T*limit;
> avg_ST = T/limit if avg_ST < T/limit;
>
> next_D = avg_D * T / avg_ST * adjust;
>
> # Tim Olsen suggested changing reward to protect against hash attacks.
> # Karbowanek coin suggested something similar.
> # I could not find anything better than the simplest idea below.
> # It was a great surprise that coin issuance rate came out perfect.
> # BaseReward = coins per block
>
> next_reward = BaseReward * avg_ST / T;
>
> ======= end algo ====
>
> Due to the limit and keeping negative solvetimes in a true average,
> timestamp errors resulting in negative solvetimes are corrected in the
> next
> block. Otherwise, one would need to do like Zcash and cause a 5-block
> delay in the response by resorting to the median of past 11 blocks (MPT)
> as the most recent timestamp, offsetting the timestamps from their
> corresponding difficulties by 5 blocks. (it does not cause an averaging
> problem, but it does cause a 5-block delay in the response.)
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171011/338575fd/attachment.html>

From benkloester at gmail.com  Wed Oct 11 02:04:01 2017
From: benkloester at gmail.com (Ben Kloester)
Date: Wed, 11 Oct 2017 13:04:01 +1100
Subject: [bitcoin-dev] Generalized sharding protocol for decentralized
 scaling without Miners owning our BTC
In-Reply-To: <C216A90B-D08D-4B89-98EE-761ED303F180@taoeffect.com>
References: <16D7672F-AA36-47D7-AAEF-E767B9CE09FF@taoeffect.com>
	<CA+XQW1jf-6HCic4beV5GSix8KRzJ-7nTc-ePipfs=ouwvHX0jA@mail.gmail.com>
	<55CAABF4-4FB8-4230-8E51-014C1D347D72@taoeffect.com>
	<CA+XQW1i-3dfRGr2vy=_P0BuXNbnoR_OmmOGGOmCcNEgkZeT_gg@mail.gmail.com>
	<FBD96A02-243E-4E09-9204-EC90DE5EE576@taoeffect.com>
	<daf438d1-7cca-aa0f-6bf7-3eef0d765d49@gmail.com>
	<B79CD106-A06E-4AF1-B67E-6DFE557468F8@taoeffect.com>
	<CAF5CFkg71g5vTCQ3rcbN+7Cjx_B3z7NT78Ug6a6S=KiSS8yo-A@mail.gmail.com>
	<B822901D-C074-4987-B793-2A83C8C83EAF@taoeffect.com>
	<F437D8FA-892B-46C7-B0B8-8B5487DD8034@gmail.com>
	<C216A90B-D08D-4B89-98EE-761ED303F180@taoeffect.com>
Message-ID: <CANgJ=T8SoAmFk=HkuJJWi28hWsSp6taYH+tfyKegweoWzcy3ZQ@mail.gmail.com>

I don't get it. At the moment, the number of Bitcoin is fixed (at 21
million) by the geometric decay of the block reward.

Adding any other means of creating coins besides the existing block reward,
or altering the block reward schedule, is extremely likely to be seen as
messing with fixed supply. And not adding another method to create coins
wouldn't work - because then redemptions would have to come out of miner's
block reward, which I don't imagine they're going to share just because you
ask.

The only way you might convince users that adding a second way to mint
coins is not messing with fixed supply, is if there is some kind of proof
that the number of coins being minted is accounted for by past burnt coins.
We could call this 'regeneration'. But then you also need a way to prevent
double-regeneration, in which the same burnt coins are used as proof twice.

And you would also need per-sidechain accounting, so that you can't just
regenerate burnt coins that were originally burnt for sidechain A when all
you have is coins on sidechain B. But where to put all this logic? Building
a system that enforces the accounting for sidechains into Bitcoin, as Lucas
pointed out, is not much different to just building the sidechain itself
directly into Bitcoin.

And if you did assemble all that, what you have anyway is a two way peg,
which I suspect will be isomorphic to the very sidechain proposals you seem
to be criticising/attempting to do better than.



*Ben Kloester*

On 11 October 2017 at 07:43, Tao Effect via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> What?
>
> That is not correct.
>
> There is a fixed amount of Bitcoin, as I said.
>
> The only difference is what chain it is on.
>
> It is precisely because there is a fixed amount that when you
> burn-to-withdraw you mint on another chain.
>
> I will not respond to any more emails unless they?re from core developers.
> Gotta run.
>
> --
> Sent from my mobile device.
> Please do not email me anything that you are not comfortable also sharing
> with the NSA.
>
> > On Oct 10, 2017, at 1:23 PM, James Hudon <jameshudon at gmail.com> wrote:
> >
> > You're asking for newly minted bitcoin to go to you but you burned the
> bitcoin used in the peg. You're effectively losing your money and then
> stealing from the miners to gain it back. The miners had to issue your
> amount of bitcoin 2 times (once for your original bitcoin, again to make
> you whole). Why would they agree to this?
> > --
> > hudon
> >
> >> On Oct 10, 2017, at 13:13, Tao Effect via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>
> >> It would not change the number of Bitcoins in existence.
> >>
> >> --
> >> Sent from my mobile device.
> >> Please do not email me anything that you are not comfortable also
> sharing with the NSA.
> >>
> >>> On Oct 10, 2017, at 12:50 PM, CryptAxe <cryptaxe at gmail.com> wrote:
> >>>
> >>> Your method would change the number of Bitcoins in existence. Why?
> >>>
> >>> On Oct 10, 2017 12:47 PM, "Tao Effect via bitcoin-dev" <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>> Is that what passes for a technical argument these days? Sheesh.
> >>>
> >>> Whereas in Drivechain users are forced to give up their coins to a
> single group for whatever sidechains they interact with, the generic
> sharding algo lets them (1) keep their coins, (2) trust whatever group they
> want to trust (the miners of the various sidechains).
> >>>
> >>> Drivechain offers objectively worse security.
> >>>
> >>> --
> >>> Sent from my mobile device.
> >>> Please do not email me anything that you are not comfortable also
> sharing with the NSA.
> >>>
> >>>> On Oct 10, 2017, at 8:09 AM, Paul Sztorc via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>>>
> >>>> I think this response speaks for itself.
> >>>>
> >>>>> On 10/10/2017 10:09 AM, Tao Effect wrote:
> >>>>> Hi Paul,
> >>>>>
> >>>>> I thought it was clear, but apparently you are getting stuck on the
> semantics of the word "burn".
> >>>>>
> >>>>> The "burning" applies to the original coins you had.
> >>>>>
> >>>>> When you transfer them back, you get newly minted coins, equivalent
> to the amount you "burned" on the chain you're transferring from ? as
> stated in the OP.
> >>>>>
> >>>>> If you don't like the word "burn", pick another one.
> >>>>>
> >>>>> --
> >>>>> Please do not email me anything that you are not comfortable also
> sharing with the NSA.
> >>>>>
> >>>>>> On Oct 10, 2017, at 4:20 AM, Paul Sztorc <truthcoin at gmail.com>
> wrote:
> >>>>>>
> >>>>>> Haha, no. Because you "burned" the coins.
> >>>>>>
> >>>>>> On Oct 10, 2017 1:20 AM, "Tao Effect" <contact at taoeffect.com>
> wrote:
> >>>>>> Paul,
> >>>>>>
> >>>>>> It's a two-way peg.
> >>>>>>
> >>>>>> There's nothing preventing transfers back to the main chain.
> >>>>>>
> >>>>>> They work in the exact same manner.
> >>>>>>
> >>>>>> Cheers,
> >>>>>> Greg
> >>>>>>
> >>>>>> --
> >>>>>> Please do not email me anything that you are not comfortable also
> sharing with the NSA.
> >>>>>>
> >>>>>>> On Oct 9, 2017, at 6:39 PM, Paul Sztorc <truthcoin at gmail.com>
> wrote:
> >>>>>>>
> >>>>>>> That is only a one-way peg, not a two-way.
> >>>>>>>
> >>>>>>> In fact, that is exactly what drivechain does, if one chooses
> parameters for the drivechain that make it impossible for any side-to-main
> transfer to succeed.
> >>>>>>>
> >>>>>>> One-way pegs have strong first-mover disadvantages.
> >>>>>>>
> >>>>>>> Paul
> >>>>>>>
> >>>>>>> On Oct 9, 2017 9:24 PM, "Tao Effect via bitcoin-dev" <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>>>>>> Dear list,
> >>>>>>>
> >>>>>>> In previous arguments over Drivechain (and Drivechain-like
> proposals) I promised that better scaling proposals ? that do not sacrifice
> Bitcoin's security ? would come along.
> >>>>>>>
> >>>>>>> I planned to do a detailed writeup, but have decided to just send
> off this email with what I have, because I'm unlikely to have time to write
> up a detailed proposal.
> >>>>>>>
> >>>>>>> The idea is very simple (and by no means novel*), and I'm sure
> others have mentioned either exactly it, or similar ideas (e.g. burning
> coins) before.
> >>>>>>>
> >>>>>>> This is a generic sharding protocol for all blockchains, including
> Bitcoin.
> >>>>>>>
> >>>>>>> Users simply say: "My coins on Chain A are going to be sent to
> Chain B".
> >>>>>>>
> >>>>>>> Then they burn the coins on Chain A, and create a minting
> transaction on Chain B. The details of how to ensure that coins do not get
> lost needs to be worked out, but I'm fairly certain the folks on this list
> can figure out those details.
> >>>>>>>
> >>>>>>> - Thin clients, nodes, and miners, can all very easily verify that
> said action took place, and therefore accept the "newly minted" coins on B
> as valid.
> >>>>>>> - Users client software now also knows where to look for the other
> coins (if for some reason it needs to).
> >>>>>>>
> >>>>>>> This doesn't even need much modification to the Bitcoin protocol
> as most of the verification is done client-side.
> >>>>>>>
> >>>>>>> It is fully decentralized, and there's no need to give our
> ownership of our coins to miners to get scale.
> >>>>>>>
> >>>>>>> My sincere apologies if this has been brought up before (in which
> case, I would be very grateful for a link to the proposal).
> >>>>>>>
> >>>>>>> Cheers,
> >>>>>>> Greg Slepak
> >>>>>>>
> >>>>>>> * This idea is similar in spirit to Interledger.
> >>>>>>>
> >>>>>>> --
> >>>>>>> Please do not email me anything that you are not comfortable also
> sharing with the NSA.
> >>>>>>>
> >>>>>>>
> >>>>>>> _______________________________________________
> >>>>>>> bitcoin-dev mailing list
> >>>>>>> bitcoin-dev at lists.linuxfoundation.org
> >>>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >>>>>>>
> >>>>>>>
> >>>>>>
> >>>>>
> >>>>
> >>>> _______________________________________________
> >>>> bitcoin-dev mailing list
> >>>> bitcoin-dev at lists.linuxfoundation.org
> >>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >>>
> >>> _______________________________________________
> >>> bitcoin-dev mailing list
> >>> bitcoin-dev at lists.linuxfoundation.org
> >>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >>>
> >> _______________________________________________
> >> bitcoin-dev mailing list
> >> bitcoin-dev at lists.linuxfoundation.org
> >> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171011/3aecf220/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Wed Oct 11 02:48:13 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 10 Oct 2017 22:48:13 -0400
Subject: [bitcoin-dev] New difficulty algorithm needed for SegWit2x
	fork? (reformatted text)
In-Reply-To: <CANgJ=T827Z=epjFvhSGNg32X3mXH3XyMNcvuXSLYjf369X1gjA@mail.gmail.com>
References: <1213518291.4328204.1507589852818.ref@mail.yahoo.com>
	<1213518291.4328204.1507589852818@mail.yahoo.com>
	<B34C76A2-4FD7-4BA9-81AD-816B163463C9@friedenbach.org>
	<CANgJ=T827Z=epjFvhSGNg32X3mXH3XyMNcvuXSLYjf369X1gjA@mail.gmail.com>
Message-ID: <3gKnWsuNvEzNfEElWCweCKECVgKqukJcpMC5Oy-3YbEsJxGxVFKNg8PPCk2sP-3SblJAJb4wG9q83qvi0tmy4c1xXyeFisutguJDF5uC7QY=@protonmail.com>

Good morning Ben,

I am not Mark, and I am nowhere near being a true Core developer yet, but I would like to point out that even under a 51% attack, there is a practical limit to the number of blocks that can be orphaned.  It would still take years to rewrite history from the Genesis block, for instance.

What little data we have (BT1 / BT2 price ratio on BitFinex) suggests that tokens solely on the 2X chain will not be valued as highly as tokens solely on the Core chain.  As miners generate tokens that are only for a specific chain, they will have higher incentive to gain tokens on the Core chain rather than the 2X chain.

As is commonly said, hodling is free, whereas mining is not.  Hodlers have much greater power in hardfork situations than miners have: simply by selling their tokens on the 2X chain and not in the Core chain, hodlers can impose economic disincentives for mining of the 2X chain.

Miners can switch to BCH, but that is valued even less than BT2 tokens are, and thus even less attractive to mine on.

We should also pay attention, that BCH changed its difficulty algorithm, and it is often considered to be to its detriment due to sudden hashpower oscillations on that chain.  We should be wary of difficulty algorithm changes, as it is the difficulty which determines the security of the chain.

--

If we attempt to deploy a difficulty change, that is a hardfork, and hodlers will be divided on this situation.  Some will sell the tokens on the difficulty-change hardfork, some will sell the tokens on the non-difficulty-change hardfork.  Thus the economic punishment for mining the 2X chain will be diluted due to the introduction of the difficulty-change hardfork, due to splitting of the hodler base that passes judgment over development.

Thus, strategy-wise, it is better to not hardfork (whether difficulty adjustment, PoW change, or so on) in response to a contentious hardfork, as hodlers can remain united against or for the contentious hardfork.  Instead, it is better to let the market decide, which automatically imposes economic sanctions on miners who choose against the market's decision.  Thus, it is better to simply let 2X die under the hands of our benevolent hodlers.

Later, when it is obvious which fate is sealed, we can reconsider such changes (difficulty adjustment, PoW change, block size) when things are calmer.  However, such changes cannot be safely done in response to a contentious hardfork.

--

If indeed the Core chain is eradicated, then Bitcoin indeed has failed and I would very much rather sell my hodlings and find some other means to amuse myself.

Regards,
ZmnSCPxj
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171010/abf9db2a/attachment.html>

From mark at friedenbach.org  Wed Oct 11 04:08:52 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Tue, 10 Oct 2017 21:08:52 -0700
Subject: [bitcoin-dev] New difficulty algorithm needed for SegWit2x
	fork? (reformatted text)
In-Reply-To: <CANgJ=T827Z=epjFvhSGNg32X3mXH3XyMNcvuXSLYjf369X1gjA@mail.gmail.com>
References: <1213518291.4328204.1507589852818.ref@mail.yahoo.com>
	<1213518291.4328204.1507589852818@mail.yahoo.com>
	<B34C76A2-4FD7-4BA9-81AD-816B163463C9@friedenbach.org>
	<CANgJ=T827Z=epjFvhSGNg32X3mXH3XyMNcvuXSLYjf369X1gjA@mail.gmail.com>
Message-ID: <B8421BF5-C87F-472B-9292-C910C7CF5047@friedenbach.org>

You phrase the question as if ?deploying a hard fork to bitcoin? would protect the bitcoin chain from the attack. But that?s not what happens. If you are hard forking from the perspective of deployed nodes, you are an different ledger, regardless of circumstance or who did it. Instead of there being one altcoin fighting to take hashpower from bitcoin, there?d now be 2. It is not at all obvious to me that this would be a better outcome.

If that isn?t reason enough, changing the difficulty adjustment algorithm doesn?t solve the underlying issue?hashpower not being aligned with users? (or even its owners?) interests. Propose a fix to the underlying cause and that might be worth considering, if it passes peer review. But without that you?d just be making the state of affairs arguably worse.

And so yes, *if* this incentive problem can?t be solved, and the unaltered bitcoin chain dies from disuse after suffering a hashpower attack, especially a centrally and/or purposefully instigated one, then bitcoin would be failed a failed project.

The thesis (and value proposition) of bitcoin is that a particular category of economic incentives can be used to solve the problem of creating a secure trustess ledger. If those incentives failed, then he thesis of bitcoin would have been experimentally falsified, yes. Maybe the incentives can be made better to save the project, but we?d have to fix the source of the problem not the symptoms.

> On Oct 10, 2017, at 6:44 PM, Ben Kloester <benkloester at gmail.com> wrote:
> 
> Mark, this seems an awful lot like an answer of "no", to my question "Is there a contingency plan in the case that the incumbent chain following the Bitcoin Core consensus rules comes under 51% attack?" - is this a correct interpretation?
> 
> In fact, beyond a no, it seems like a "no, and I disagree with the idea of creating one".
> 
> So if Bitcoin comes under successful 51%, the project, in your vision, has simply failed?
> 
> Ben Kloester
> 
> 
>> On 10 October 2017 at 13:19, Mark Friedenbach via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> The problem of fast acting but non vulnerable difficulty adjustment algorithms is interesting. I would certainly like to see this space further explored, and even have some ideas myself.
>> 
>> However without commenting on the technical merits of this specific proposal, I think it must be said upfront that the stated goal is not good. The largest technical concern (ignoring governance) over B2X is that it is a rushed, poorly reviewed hard fork. Hard forks should not be rushed, and they should receive more than the usual level of expert and community review.
>> 
>> I?m that light, doing an even more rushed hard fork on an even newer idea with even less review would be hypocritical at best. I would suggest reframing as a hardfork wishlist research problem for the next properly planned hard fork, if one occurs. You might also find the hardfork research group a more accommodating venue for this discussion:
>> 
>> https://bitcoinhardforkresearch.github.io/
>> 
>>> On Oct 9, 2017, at 3:57 PM, Scott Roberts via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>> 
>>> Sorry, my previous email did not have the plain text I intended.
>>> 
>>> Background: 
>>> 
>>> The bitcoin difficulty algorithm does not seem to be a good one. If there 
>>> is a fork due to miners seeking maximum profit without due regard to 
>>> security, users, and nodes, the "better" coin could end up being the 
>>> minority chain. If 90% of hashrate is really going to at least initially go 
>>> towards using SegWit2x, BTC would face 10x delays in confirmations 
>>> until the next difficulty adjustment, negatively affecting its price relative 
>>> to BTC1, causing further delays from even more miner abandonment 
>>> (until the next adjustment). The 10% miners remaining on BTC do not 
>>> inevitably lose by staying to endure 10x delays because they have 10x 
>>> less competition, and the same situation applies to BTC1 miners. If the 
>>> prices are the same and stable, all seems well for everyone, other things 
>>> aside. But if the BTC price does not fall to reflect the decreased hashrate, 
>>> he situation seems to be a big problem for both coins: BTC1 miners will 
>>> jump back to BTC when the difficulty adjustment occurs, initiating a 
>>> potentially never-ending oscillation between the two coins, potentially 
>>> worse than what BCH is experiencing.  They will not issue coins too fast 
>>> like BCH because that is a side effect of the asymmetry in BCH's rise and 
>>> fall algorithm. 
>>> 
>>> Solution: 
>>> 
>>> Hard fork to implement a new difficulty algorithm that uses a simple rolling 
>>> average with a much smaller window.  Many small coins have done this as 
>>> a way to stop big miners from coming on and then suddenly leaving, leaving 
>>> constant miners stuck with a high difficulty for the rest of a (long) averaging 
>>> window.  Even better, adjust the reward based on recent solvetimes to 
>>> motivate more mining (or less) if the solvetimes are too slow (or too fast). 
>>> This will keep keep coin issuance rate perfectly on schedule with real time. 
>>> 
>>> I recommend the following for Bitcoin, as fast, simple, and better than any 
>>> other difficulty algorithm I'm aware of.  This is the result of a lot of work the 
>>> past year. 
>>> 
>>> === Begin difficulty algorithm === 
>>> # Zawy v6 difficulty algorithm (modified for bitcoin) 
>>> # Unmodified Zawy v6 for alt coins: 
>>> # http://zawy1.blogspot.com/2017/07/best-difficulty-algorithm-zawy-v1b.html 
>>> # All my failed attempts at something better: 
>>> # https://github.com/seredat/karbowanec/commit/231db5270acb2e673a641a1800be910ce345668a 
>>> # 
>>> # Keep negative solvetimes to correct bad timestamps. 
>>> # Do not be tempted to use: 
>>> # next_D = sum(last N Ds) * T / [max(last N TSs) - min(last N TSs]; 
>>> # ST= Solvetime, TS = timestamp 
>>> 
>>> # set constants until next hard fork: 
>>> 
>>> T=600; # coin's TargetSolvetime 
>>> N=30; # Averaging window. Smoother than N=15, faster response than N=60. 
>>> X=5; 
>>> limit = X^(2/N); # limit rise and fall in case of timestamp manipulation 
>>> adjust = 1/(1+0.67/N);  # keeps avg solvetime on track 
>>> 
>>> # begin difficulty algorithm 
>>> 
>>> avg_ST=0; avg_D=0; 
>>> for ( i=height;  i > height-N;  i--) {  # go through N most recent blocks 
>>> avg_ST += (TS[i] - TS[i-1]) / N; 
>>> avg_D += D[i]/N; 
>>> } 
>>> avg_ST = T*limit if avg_ST > T*limit; 
>>> avg_ST = T/limit if avg_ST < T/limit; 
>>> 
>>> next_D = avg_D * T / avg_ST * adjust; 
>>> 
>>> # Tim Olsen suggested changing reward to protect against hash attacks. 
>>> # Karbowanek coin suggested something similar. 
>>> # I could not find anything better than the simplest idea below. 
>>> # It was a great surprise that coin issuance rate came out perfect. 
>>> # BaseReward = coins per block 
>>> 
>>> next_reward = BaseReward * avg_ST / T; 
>>> 
>>> ======= end algo ==== 
>>> 
>>> Due to the limit and keeping negative solvetimes in a true average, 
>>> timestamp errors resulting in negative solvetimes are corrected in the next 
>>> block. Otherwise, one would need to do like Zcash and cause a 5-block 
>>> delay in the response by resorting to the median of past 11 blocks (MPT) 
>>> as the most recent timestamp, offsetting the timestamps from their 
>>> corresponding difficulties by 5 blocks. (it does not cause an averaging 
>>> problem, but it does cause a 5-block delay in the response.)
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> 
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> 
> 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171010/4c45d2f3/attachment-0001.html>

From zawy at yahoo.com  Wed Oct 11 14:50:20 2017
From: zawy at yahoo.com (Scott Roberts)
Date: Wed, 11 Oct 2017 14:50:20 +0000 (UTC)
Subject: [bitcoin-dev]  New difficulty algorithm part 2
References: <1664384101.5473696.1507733420536.ref@mail.yahoo.com>
Message-ID: <1664384101.5473696.1507733420536@mail.yahoo.com>

(This is new thread because I'm having trouble getting yahoo mail 

to use "reply-to", copy-pasting the subject did not work, and the 
list has not approved my gmail)
A hard fork in the near term is feasible only post-disaster (in my mind, 
that means Core failing from long transaction delays that destroys 
confidence and therefore price). A hard fork attempt to fix the situation 
will not work unless the difficulty is fixed to let price guide hash power 
instead of vice versa. We seem to be headed towards letting the tail wag 
the dog. BTC may find itself in the same position as BCH and all alts: the 
current difficulty algorithm is untenable and will require a fork. 

Current difficulty algorithm in presence of higher hashrate coin with 
the same POW: 
lower hashpower => wait times => lost confidence => lower price => defeat 

Difficulty algorithms that alts find absolutely necessary when there 
is a higher hash rate coin with the same POW: 
hodler faith => price => hashpower => survivable coin 

Alt experience time and time again is that Core will have to fork to a 
faster responding difficulty algorithm if it finds itself suddenly (and 
for the first time) with a lower hashrate. 


Mark Friedenbach wrote: 
> changing the difficulty adjustment algorithm doesn?t solve the underlying 
> issue, hashpower not being aligned with users? (or owners') interests. 

I define "users" as those who it it for value transfer (including 
purchases) without concern for long-term value. If SegWit2x reduces fees 
per coin, then hashpower is being aligned with their short-term interests. 

It does not solve it, but it is a pre-requisite if the coin has a lower 
hashrate (BTC at end of November). A faster responding diffulty is a 
pre-requisite in minority hashrate coins for letting price (hodlers) 
dictate hashpower instead of vice versa. This is the experience of alts. 

ZmnSCPxj wrote: 
> Hodlers have much greater power in hardfork situations than miners 

Not when hodlers are more evenly split between coins. Miners will prefer 
the coin with higher transaction fees which will erode hodler confidence 
via longer delays. This means transaction fees will evolve to the highest 
that common marketplace users can accepet (they are not intereseted in 
hodler security), not the lowest technologically feasible fee that provides 
the greatest security. Large blocks reduce network security while giving 
the higher total transaction fees to miners even as it can reduce fees per 
coin for users. The mining "lobby" will always describe this as "best for 
users". Non-hodling users and miners logically prefer SegWit2x. 

ZmnSCPxj wrote: 
> BCH changed its difficulty algorithm, and it is often considered to be to 
its detriment due to sudden hashpower oscillations 

BCH has survived this long because they did NOT use the bitcoin difficulty 
algorithm. Granted, it is a bad design that included an asymmetry that has 
resulted in too many coins being issued. If they had inverted the decrease 
rule to create a symmetrically fast increase rule instead of keeping 
bitcoin's increase logic, they would be in much better shape, much better 
than the bitcoin difficulty algorithm. Making it symmetrical and fast would 
have resulted in more obvious fast oscillations, but this would have helped 
price discovery to settle the oscillations to an acceptable level that 
could stabilize the price by preventing too many coins from being issued. 

Oscillations require: 1) comparable price and 2) miners having the option 
to go back and forth to a larger coin. Bitcoin's long, jumping difficulty 
averaging window may destroy the minority hashrate coin faster in fewer 
oscillations thanks to a first-to-market effect more than reason. In 
persuit of higher total transacton fees, miners are deciding SegWit2x is 
"first-to-market" to cause Core to have long delays. This is not a 
conspiracy, but simply seeking profit. Since fees per coin can also be 
reduced, they can convince themselves and others that it is the best 
option. 

A shorter difficulty algorithm averaging window enables more, faster 
oscillations to enable better price discovery before a winner is chosen. 
The design I'm proposing should be close to the ideal.  For example, Mark 
Friedenbach suggested a difficulty adjustment every 18 blocks by averaging 
the past 36 blocks. If a coin using that has the minority hashrate, then it 
could quickly develop into a sudden influx from the majority change for 18 
blocks, then they exit back to the majority chain for 36 blocks before 
doing it again. They get 1/3 of the blocks at "zero excess cost" 
(difficulty will be 1/10 the correct value if they are 10x base hashrate) 
and then they will leave the constant miners with a higher difficulty for 
36 blocks (at 3.33x higher difficulty if the "attackers" are 10x the base 
hashrate). This forces constant miners to start copying them, amplifying 
the oscillations and delays of the minority hashrate coin. A rolling 
average window of any length does not theoretically prevent this, unless 
the window is short enough to be comparable to the time cost of switching 
coins, if there is a time cost. A say this because in testing I was able 
to design an attack algorithm that always gets 1/3 of the coins at "zero 
excess cost".  But a rolling average with a shorter window should make the 
"accidental collusion" of miners seeking profit more unlikely to occur. 
The reward function I've proposed appears to reduce it to 1/6 total coins 
obtainable at "zero excess cost", and similarly reduce oscillations and 
assist better price discovery.

From ethan.scruples at gmail.com  Wed Oct 11 15:28:08 2017
From: ethan.scruples at gmail.com (Moral Agent)
Date: Wed, 11 Oct 2017 11:28:08 -0400
Subject: [bitcoin-dev] New difficulty algorithm needed for SegWit2x
 fork? (reformatted text)
In-Reply-To: <B8421BF5-C87F-472B-9292-C910C7CF5047@friedenbach.org>
References: <1213518291.4328204.1507589852818.ref@mail.yahoo.com>
	<1213518291.4328204.1507589852818@mail.yahoo.com>
	<B34C76A2-4FD7-4BA9-81AD-816B163463C9@friedenbach.org>
	<CANgJ=T827Z=epjFvhSGNg32X3mXH3XyMNcvuXSLYjf369X1gjA@mail.gmail.com>
	<B8421BF5-C87F-472B-9292-C910C7CF5047@friedenbach.org>
Message-ID: <CACiOHGxHzW42XzS+C=3OKsgbf=+XqtYgri8feRGsH28i2UaDCA@mail.gmail.com>

>Instead of there being one altcoin fighting to take hashpower from
bitcoin, there?d now be 2

Yes, there would be 2. One of which would (in the scenario we are
discussing) be producing blocks excruciatingly slowly but be the same in
all other aspects.

>changing the difficulty adjustment algorithm doesn?t solve the underlying
issue?hashpower not being aligned with users? (or even its owners?)
interests

I disagree. Changing the difficulty adjustment algorithm could improve the
functionality of a chain, which could be an important prerequisite to using
and trading the tokens on the chain. This property could help keep the
price of the token high, which is what pressures hashpower to align with
user interests.

>And so yes, *if* this incentive problem can?t be solved, and the unaltered
bitcoin chain dies from disuse after suffering a hashpower attack,
especially a centrally and/or purposefully instigated one, then bitcoin
would be failed a failed project.

IF the incentive problem could not be resolved then Bitcoin would be a
failed project.

But here is a bit of good news.

Bitcoin has developers!

And those developers can publish a contingency plan!

And that contingency plan can be an emergency hard fork to a different
retarget algorithm.

And that emergency hard fork can gain consensus if it is broadly preferred
over the status quo.

If 90% of the hash power follows NYA, blocks are going to take 100 minutes
until difficulty adjusts after 4.5 months.

That is quite a handicap, even for a honey badger. Emergency hard fork
carries a risk, but depending on the scenario in November, it could be a
risk worth taking.

One more thing. If miners think they are going to succeed in starving the
legacy chain to death, they might be more likely to try. If they get a
credible signal that the legacy chain will react by changing the retarget
function and thereby be more likely to survive, they might feel less
committed to a strategy of starving the legacy chain. This could be
especially true if they are giving up profit for what they fervently hope
will be a short period of time.

On Wed, Oct 11, 2017 at 12:08 AM, Mark Friedenbach via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> You phrase the question as if ?deploying a hard fork to bitcoin? would
> protect the bitcoin chain from the attack. But that?s not what happens. If
> you are hard forking from the perspective of deployed nodes, you are an
> different ledger, regardless of circumstance or who did it. Instead of
> there being one altcoin fighting to take hashpower from bitcoin, there?d
> now be 2. It is not at all obvious to me that this would be a better
> outcome.
>
> If that isn?t reason enough, changing the difficulty adjustment algorithm
> doesn?t solve the underlying issue?hashpower not being aligned with users?
> (or even its owners?) interests. Propose a fix to the underlying cause and
> that might be worth considering, if it passes peer review. But without that
> you?d just be making the state of affairs arguably worse.
>
> And so yes, *if* this incentive problem can?t be solved, and the unaltered
> bitcoin chain dies from disuse after suffering a hashpower attack,
> especially a centrally and/or purposefully instigated one, then bitcoin
> would be failed a failed project.
>
> The thesis (and value proposition) of bitcoin is that a particular
> category of economic incentives can be used to solve the problem of
> creating a secure trustess ledger. If those incentives failed, then he
> thesis of bitcoin would have been experimentally falsified, yes. Maybe the
> incentives can be made better to save the project, but we?d have to fix the
> source of the problem not the symptoms.
>
> On Oct 10, 2017, at 6:44 PM, Ben Kloester <benkloester at gmail.com> wrote:
>
> Mark, this seems an awful lot like an answer of "no", to my question "Is
> there a contingency plan in the case that the incumbent chain following the
> Bitcoin Core consensus rules comes under 51% attack?" - is this a correct
> interpretation?
>
> In fact, beyond a no, it seems like a "no, and I disagree with the idea of
> creating one".
>
> So if Bitcoin comes under successful 51%, the project, in your vision, has
> simply failed?
>
> *Ben Kloester*
>
> On 10 October 2017 at 13:19, Mark Friedenbach via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> The problem of fast acting but non vulnerable difficulty adjustment
>> algorithms is interesting. I would certainly like to see this space further
>> explored, and even have some ideas myself.
>>
>> However without commenting on the technical merits of this specific
>> proposal, I think it must be said upfront that the stated goal is not good.
>> The largest technical concern (ignoring governance) over B2X is that it is
>> a rushed, poorly reviewed hard fork. Hard forks should not be rushed, and
>> they should receive more than the usual level of expert and community
>> review.
>>
>> I?m that light, doing an even more rushed hard fork on an even newer idea
>> with even less review would be hypocritical at best. I would suggest
>> reframing as a hardfork wishlist research problem for the next properly
>> planned hard fork, if one occurs. You might also find the hardfork research
>> group a more accommodating venue for this discussion:
>>
>> https://bitcoinhardforkresearch.github.io/
>>
>> On Oct 9, 2017, at 3:57 PM, Scott Roberts via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> Sorry, my previous email did not have the plain text I intended.
>>
>> Background:
>>
>> The bitcoin difficulty algorithm does not seem to be a good one. If there
>> is a fork due to miners seeking maximum profit without due regard to
>> security, users, and nodes, the "better" coin could end up being the
>> minority chain. If 90% of hashrate is really going to at least initially
>> go
>> towards using SegWit2x, BTC would face 10x delays in confirmations
>> until the next difficulty adjustment, negatively affecting its price
>> relative
>> to BTC1, causing further delays from even more miner abandonment
>> (until the next adjustment). The 10% miners remaining on BTC do not
>> inevitably lose by staying to endure 10x delays because they have 10x
>> less competition, and the same situation applies to BTC1 miners. If the
>> prices are the same and stable, all seems well for everyone, other things
>> aside. But if the BTC price does not fall to reflect the decreased
>> hashrate,
>> he situation seems to be a big problem for both coins: BTC1 miners will
>> jump back to BTC when the difficulty adjustment occurs, initiating a
>> potentially never-ending oscillation between the two coins, potentially
>> worse than what BCH is experiencing.  They will not issue coins too fast
>> like BCH because that is a side effect of the asymmetry in BCH's rise and
>> fall algorithm.
>>
>> Solution:
>>
>> Hard fork to implement a new difficulty algorithm that uses a simple
>> rolling
>> average with a much smaller window.  Many small coins have done this as
>> a way to stop big miners from coming on and then suddenly leaving,
>> leaving
>> constant miners stuck with a high difficulty for the rest of a (long)
>> averaging
>> window.  Even better, adjust the reward based on recent solvetimes to
>> motivate more mining (or less) if the solvetimes are too slow (or too
>> fast).
>> This will keep keep coin issuance rate perfectly on schedule with real
>> time.
>>
>> I recommend the following for Bitcoin, as fast, simple, and better than
>> any
>> other difficulty algorithm I'm aware of.  This is the result of a lot of
>> work the
>> past year.
>>
>> === Begin difficulty algorithm ===
>> # Zawy v6 difficulty algorithm (modified for bitcoin)
>> # Unmodified Zawy v6 for alt coins:
>> # http://zawy1.blogspot.com/2017/07/best-difficulty-algorithm-
>> zawy-v1b.html
>> # All my failed attempts at something better:
>> # https://github.com/seredat/karbowanec/commit/231db5270acb2e6
>> 73a641a1800be910ce345668a
>> #
>> # Keep negative solvetimes to correct bad timestamps.
>> # Do not be tempted to use:
>> # next_D = sum(last N Ds) * T / [max(last N TSs) - min(last N TSs];
>> # ST= Solvetime, TS = timestamp
>>
>> # set constants until next hard fork:
>>
>> T=600; # coin's TargetSolvetime
>> N=30; # Averaging window. Smoother than N=15, faster response than N=60.
>> X=5;
>> limit = X^(2/N); # limit rise and fall in case of timestamp manipulation
>> adjust = 1/(1+0.67/N);  # keeps avg solvetime on track
>>
>> # begin difficulty algorithm
>>
>> avg_ST=0; avg_D=0;
>> for ( i=height;  i > height-N;  i--) {  # go through N most recent blocks
>> avg_ST += (TS[i] - TS[i-1]) / N;
>> avg_D += D[i]/N;
>> }
>> avg_ST = T*limit if avg_ST > T*limit;
>> avg_ST = T/limit if avg_ST < T/limit;
>>
>> next_D = avg_D * T / avg_ST * adjust;
>>
>> # Tim Olsen suggested changing reward to protect against hash attacks.
>> # Karbowanek coin suggested something similar.
>> # I could not find anything better than the simplest idea below.
>> # It was a great surprise that coin issuance rate came out perfect.
>> # BaseReward = coins per block
>>
>> next_reward = BaseReward * avg_ST / T;
>>
>> ======= end algo ====
>>
>> Due to the limit and keeping negative solvetimes in a true average,
>> timestamp errors resulting in negative solvetimes are corrected in the
>> next
>> block. Otherwise, one would need to do like Zcash and cause a 5-block
>> delay in the response by resorting to the median of past 11 blocks (MPT)
>> as the most recent timestamp, offsetting the timestamps from their
>> corresponding difficulties by 5 blocks. (it does not cause an averaging
>> problem, but it does cause a 5-block delay in the response.)
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171011/c9ac3993/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Thu Oct 12 10:40:24 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 12 Oct 2017 06:40:24 -0400
Subject: [bitcoin-dev] New difficulty algorithm part 2
In-Reply-To: <1664384101.5473696.1507733420536@mail.yahoo.com>
References: <1664384101.5473696.1507733420536.ref@mail.yahoo.com>
	<1664384101.5473696.1507733420536@mail.yahoo.com>
Message-ID: <NzOnTr-caLMhcX_xk64TLPkbu75N79WmAl3P9e2jOo5mCOFg9G3SIxgj6FXxo4Euau3h4u_iJe04NERnBpw8D_08ZwzbUQcjTCJMR663oOI=@protonmail.com>

Good morning,

>ZmnSCPxj wrote:
>> Hodlers have much greater power in hardfork situations than miners
>
>Not when hodlers are more evenly split between coins. Miners will prefer
>the coin with higher transaction fees which will erode hodler confidence
>via longer delays. This means transaction fees will evolve to the highest
>that common marketplace users can accepet (they are not intereseted in
>hodler security), not the lowest technologically feasible fee that provides
>the greatest security. Large blocks reduce network security while giving
>the higher total transaction fees to miners even as it can reduce fees per
>coin for users. The mining "lobby" will always describe this as "best for
>users". Non-hodling users and miners logically prefer SegWit2x.

Hodlers still have greater power than non-hodling users, whether miners or day-traders.

Hodlers holding millions in coin, total, can greatly drop price of any undesired hardfork.

Miners will prefer the coin with higher transaction fees as measured in real-world value.  Thus even if the unwanted chain provides 2 tokens as fee per block, whereas the wanted chain provides 1 token as fee per block, if the unwanted chain tokens are valued at 1/4 the wanted chain tokens, miners will still prefer the wanted chain regardless.  What the chains will compete in is the real-world value of the total mining reward.

Hodlers hodl all the cards here.

>ZmnSCPxj wrote:
>> BCH changed its difficulty algorithm, and it is often considered to be to
>its detriment due to sudden hashpower oscillations
>
>BCH has survived this long because they did NOT use the bitcoin difficulty
<snip>

All this speculation seems to suggest to me simply that a difficulty change leads to keeping a chain alive unnecessarily, when by rights, it should be dead and laid to rest.

If Bitcoin needs some sudden change in difficulty algorithm to survive, then it has failed.  Feel free to do your own hardfork into yet another derivative altcoin.

>Bitcoin has developers!
>
>And those developers can publish a contingency plan!
>
>And that contingency plan can be an emergency hard fork to a different retarget algorithm.
>
>And that emergency hard fork can gain consensus if it is broadly preferred over the status quo.

Every hardfork is an invitation to shatter the community even further than it already is.  There is no need for further shattering.

The idea that an emergency hardfork to a different difficulty algorithm is necessary arises from a lack of understanding of just how much power hodlers have over the destiny of a coin.

Every hodler who rejects a hardfork, will sell the hardfork coin, increasing its supply and reducing its price.

Every miner who mines a rejected hardfork, creates new tokens in the hardfork, increasing its supply and reducing its price.

Coins that are hedl will remain hedl, and are not part of the supply.  Thus coins on the desired chain will remain high in price, regardless of available transaction rate.  The lack of freshly-minted coins also contracts the supply.

In the end, this will result in the same behavior as in BCH, where hodlers sodl the unwanted hardfork as quickly as they could.  Indeed, due exactly to miner support, 2X is much more likely to quickly drop in price than BCH did.  I am sure you have seen the images pointing out how easy it was to determine when BCH blocks arrived: they arrived a little before each dip in BCH price.  Fast 2X block rate will lead to faster 2X death, with its miners becoming bagholders.

As most Core developers hodl vast amounts, it is far more likely that any hardfork that goes against what Core wishes will collapse, simply by Core developers acting in their capacity as hodlers of Bitcoin, without needing to do any special action in their capacity as developers.

Regards,
ZmnSCPxj
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171012/003fc7c4/attachment.html>

From wordsgalore at gmail.com  Thu Oct 12 08:51:33 2017
From: wordsgalore at gmail.com (Scott Roberts)
Date: Thu, 12 Oct 2017 04:51:33 -0400
Subject: [bitcoin-dev] New difficulty algorithm needed for SegWit2x
 fork? (reformatted text)
Message-ID: <CADtTMvnc1Gyu9avru5+QQq9GH=MA7F5XN2JjsSAeA1BxAgPRRA@mail.gmail.com>

Since there is no surviving argument in this thread contrary to my original
post, I'll begin work on a BIP.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171012/0541774a/attachment.html>

From mark at friedenbach.org  Thu Oct 12 15:25:23 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Thu, 12 Oct 2017 08:25:23 -0700
Subject: [bitcoin-dev] New difficulty algorithm part 2
In-Reply-To: <NzOnTr-caLMhcX_xk64TLPkbu75N79WmAl3P9e2jOo5mCOFg9G3SIxgj6FXxo4Euau3h4u_iJe04NERnBpw8D_08ZwzbUQcjTCJMR663oOI=@protonmail.com>
References: <1664384101.5473696.1507733420536.ref@mail.yahoo.com>
	<1664384101.5473696.1507733420536@mail.yahoo.com>
	<NzOnTr-caLMhcX_xk64TLPkbu75N79WmAl3P9e2jOo5mCOFg9G3SIxgj6FXxo4Euau3h4u_iJe04NERnBpw8D_08ZwzbUQcjTCJMR663oOI=@protonmail.com>
Message-ID: <8369AFB5-05BF-4483-A81D-82ED34B4A22F@friedenbach.org>



> On Oct 12, 2017, at 3:40 AM, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> As most Core developers hodl vast amounts, it is far more likely that any hardfork that goes against what Core wishes will collapse, simply by Core developers acting in their capacity as hodlers of Bitcoin, without needing to do any special action in their capacity as developers.

While this might be true of some, it is most certainly not true of many, and it is a very dangerous men to the safety and well being of people on this list.

You don?t get bitcoin for being a bitcoin developer, and there is no reason to suppose a developer has any more or less bitcoin than anyone else in the industry.

It is certainly the case that a large number of people and organizations who are not developers hold massive amounts of bitcoin (hundred of thousands each, millions in aggregate). 

From wordsgalore at gmail.com  Thu Oct 12 15:42:02 2017
From: wordsgalore at gmail.com (Scott Roberts)
Date: Thu, 12 Oct 2017 11:42:02 -0400
Subject: [bitcoin-dev] New difficulty algorithm part 2
Message-ID: <CADtTMvnr8SgSxV1Qcorv28TY=fR1yJdtAEtjkYvPJQ7pm8dBMQ@mail.gmail.com>

ZmnSCPxj wrote:
> Thus even if the unwanted chain provides 2 tokens as fee per block,
> whereas the wanted chain provides 1 token as fee per block, if the
> unwanted chain tokens are valued at 1/4 the wanted chain tokens, miners
> will still prefer the wanted chain regardless.

This is a good point I was not thinking about, but your math assumes
1/2 price for a coin that can do 2x more transactions. Holders like
Roger Ver have an interest in low price and more transactions. A coin
with 2x more transactions, 22% lower price, and 22% lower fees per
coin transferred will attract more merchants, customers, and miners
(they get 50% more total fees) and this will in turn attract more
hodlers and devs. This assumes it outweighs hodler security concerns.
Merchants and customers, to the extent they are not long term hodlers,
are not interested in price as much as stability, so they are somewhat
at odds with hodlers.

Bitcoin consensus truth is based on "might is right". Buyers and
sellers of goods and services ("users") can shift some might to miners
via fees, to the chagrin of hodlers who have more interest in security
and price increases. Some hodlers think meeting user needs is the
source of long term value. Others think mining infrastructure is. You
seem to require hodlers to correctly identify and rely solely on good
developers. Whatever combination of these is the case, bad money can
still drive out good, especially if the market determination is not
efficient.

A faster measurement of hashrate for difficulty enables the economic
determination to be more efficient and correct. It prevents the
biggest coin from bullying forks that have better ideas. Conversely,
it prevents miners from switching to an inferior coin simply because
it provides them with more "protection money" from fees that enables
them to bully Bitcoin Core out of existence, even in the presence of a
slightly larger hodler support.

Devs are a governing authority under the influence of users, hodlers,
and miners. Miners are like banks lobbying government for higher total
fees. Hodlers are the new 1%, holding 90% of the coin, lobbying both
devs and users for security, but equally interested in price
increases. Users are "the people" that devs need to protect against
both hodlers and miners. They do not care about price as long as it is
stable. They do not want to become the 99% owning 10% of the coin or
have to pay unecessary fees merely for their coin to be the biggest
bully on the block.  A faster responding difficulty will take a lot of
hot air out of the bully. It prevents miners from being able to
dictate that only coins with high fees are allowed.  They are less
able to destroy small coins that have a fast defense.

The 1% and banks would starve the people that feed them to death if
they were allowed complete control of the government. Are hodlers and
miners any wiser? Devs need to strive for an expansion of the coin
quantity to keep value constant which is the foundation of the 5
characteristics of an ideal currency.  Therefore devs should seek
peaceful and sustainable forks of bitcoin. This will enable constant
value, security, and low transaction fees per coin transfer. Alts
aside, the current situation of discouraging forks forbids constant
value via limited quantity.  It also forces a choice between high
security and low fees.  Forks with a faster difficulty will be more
capable of retaining value.

Users, devs, hodlers, and miners are naturally aligned and at odds in
different ways. A flow chart of the checks and balances should enable
better development towards a self-controlling feedback system, but the
goals need to be known before it could be designed and implemented.
Hodlers say price increases is the goal. Users say efficient transfer
of value. Miners say fees (at least that's the end game after mining).
I'm with users despite trying to be the 1% (which reminds me of a book
about how people often vote based on feeling good about their morality
and concern for society as a whole, despite it being contrary to their
personal best interests if that vote wins.)

From ZmnSCPxj at protonmail.com  Fri Oct 13 04:45:33 2017
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 13 Oct 2017 00:45:33 -0400
Subject: [bitcoin-dev] New difficulty algorithm part 2
In-Reply-To: <CADtTMvnr8SgSxV1Qcorv28TY=fR1yJdtAEtjkYvPJQ7pm8dBMQ@mail.gmail.com>
References: <CADtTMvnr8SgSxV1Qcorv28TY=fR1yJdtAEtjkYvPJQ7pm8dBMQ@mail.gmail.com>
Message-ID: <Hr8ORNHzR76wNhJHoagwXi2ewQ1qYSZScH0xeltVnqid2ljOowc2bj8-rkbdukpk9eyoPx1ReOZSUsNrcowRU9gL5UbKtblkQn2SUo06BHE=@protonmail.com>

Good morning,

>ZmnSCPxj wrote:
>> Thus even if the unwanted chain provides 2 tokens as fee per block,
>> whereas the wanted chain provides 1 token as fee per block, if the
>> unwanted chain tokens are valued at 1/4 the wanted chain tokens, miners
>> will still prefer the wanted chain regardless.
>
>This is a good point I was not thinking about, but your math assumes
>1/2 price for a coin that can do 2x more transactions. Holders like
>Roger Ver have an interest in low price and more transactions. A coin
>with 2x more transactions, 22% lower price, and 22% lower fees per
>coin transferred will attract more merchants, customers, and miners
>(they get 50% more total fees) and this will in turn attract more
>hodlers and devs. This assumes it outweighs hodler security concerns.
>Merchants and customers, to the extent they are not long term hodlers,
>are not interested in price as much as stability, so they are somewhat
>at odds with hodlers.

As of this moment, BT1 / BT2 price ratio in BitFinex is slightly higher than 7 : 1.  Twice the transaction rate cannot overcome this price ratio difference.  Even if you were to claim that the BitFinex data is off by a factor of 3, twice the transaction rate still cannot overcome the price ratio difference.  Do you have stronger data than what is available on BitFinex?  If not, your assumptions are incorrect and all conclusions suspect.

>Bitcoin consensus truth is based on "might is right". Buyers and
>sellers of goods and services ("users") can shift some might to miners
>via fees, to the chagrin of hodlers who have more interest in security
>and price increases. Some hodlers think meeting user needs is the
>source of long term value. Others think mining infrastructure is.

Mining infrastructure follows price.  If bitcoins were still trading at 1 USD per coin, nobody will build mining infrastructure to the same level as today, with 5000 USD per coin.

Price will follow user needs, i.e. demand.

>You
>seem to require hodlers to correctly identify and rely solely on good
>developers.

For the very specific case of 2X, it is very easy to make this identification.  Even without understanding the work being done, one can reasonably say that it is far more likely that a loose group of 100 or more developers will contain a few good or excellent developers, than a group of a few developers containing a similar number of good or excellent developers.

User needs will get met only on the chain that good developers work on.  Bitcoin today has too many limitations: viruses on Windows can steal all your money, fee estimates consistently overestimate, fees rise during spamming attacks, easy to lose psuedonymity, tiny UTXOs are infeasible to spend, cannot support dozens of thousands of transactions per second.  Rationally, long-term hodlers will select a chain with better developers who are more likely to discover or innovate methods to reduce, eliminate, or sidestep those limitations.  Perhaps the balance will change in the future, but it is certainly not the balance now, and thus any difficulty algorithm change in response to the current situation will be premature, and far more likely to cause disaster than avert one.

>Whatever combination of these is the case, bad money can
>still drive out good, especially if the market determination is not
>efficient.
>
>A faster measurement of hashrate for difficulty enables the economic
>determination to be more efficient and correct. It prevents the
>biggest coin from bullying forks that have better ideas. Conversely,
>it prevents miners from switching to an inferior coin simply because
>it provides them with more "protection money" from fees that enables
>them to bully Bitcoin Core out of existence, even in the presence of a
>slightly larger hodler support.

This requires that all chains follow the same difficulty adjustment: after all, it is also entirely the possibility that 2X will be the lower-hashrate coin in a few months, with the Core chain bullying them out of existence.  Perhaps you should cross-post your analysis to bitcoin-segwit2x also.  After all, the 2X developers should also want to have faster price discovery of the true price of 2X, away from the unfavorable (incorrect?) pricing on BitFinex.

>Devs are a governing authority under the influence of users, hodlers,
>and miners. Miners are like banks lobbying government for higher total
>fees. Hodlers are the new 1%, holding 90% of the coin, lobbying both
>devs and users for security, but equally interested in price
>increases. Users are "the people" that devs need to protect against
>both hodlers and miners. They do not care about price as long as it is
>stable. They do not want to become the 99% owning 10% of the coin or
>have to pay unecessary fees merely for their coin to be the biggest
>bully on the block. A faster responding difficulty will take a lot of
>hot air out of the bully. It prevents miners from being able to
>dictate that only coins with high fees are allowed. They are less
>able to destroy small coins that have a fast defense.
>
>The 1% and banks would starve the people that feed them to death if
>they were allowed complete control of the government. Are hodlers and
>miners any wiser?

Are developers any wiser, either?

Then consider this wisdom: The fewer back-incompatible changes to a coin, the better.  Hardforks of any kind are an invitation to disaster and, at this point, require massive coordination effort which cannot be feasibly done within a month.  Fast market determination can be done using off-chain methods (such as on-exchange trades), and are generally robust against temporary problems on-chain, although admittedly there is a counterparty risk involved.  The coin works, and in general there is usually very little need to fix it, especially using dangerous hardforks.

>Devs need to strive for an expansion of the coin
>quantity to keep value constant which is the foundation of the 5
>characteristics of an ideal currency.

Is that your goal?  This is a massive departure from the conception of Bitcoin as having a fixed limit and effectively becoming deflationary.  It will also lead to massive economic distortions in favor of those who receive newly-minted coins.  I doubt any developer would want to have this property.

Regards,
ZmnSCPxj
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171013/1afdebf0/attachment-0001.html>

From wordsgalore at gmail.com  Fri Oct 13 11:35:09 2017
From: wordsgalore at gmail.com (Scott Roberts)
Date: Fri, 13 Oct 2017 07:35:09 -0400
Subject: [bitcoin-dev] New difficulty algorithm part 2
In-Reply-To: <Hr8ORNHzR76wNhJHoagwXi2ewQ1qYSZScH0xeltVnqid2ljOowc2bj8-rkbdukpk9eyoPx1ReOZSUsNrcowRU9gL5UbKtblkQn2SUo06BHE=@protonmail.com>
References: <CADtTMvnr8SgSxV1Qcorv28TY=fR1yJdtAEtjkYvPJQ7pm8dBMQ@mail.gmail.com>
	<Hr8ORNHzR76wNhJHoagwXi2ewQ1qYSZScH0xeltVnqid2ljOowc2bj8-rkbdukpk9eyoPx1ReOZSUsNrcowRU9gL5UbKtblkQn2SUo06BHE=@protonmail.com>
Message-ID: <CADtTMvnrZp=JD4rkXQOZAPNS9BMNMqnTyfA65PRzZhWs+VxgHA@mail.gmail.com>

Yes, the current price ratio indicates there is no need for a new
difficulty algorithm. I do not desire to fork before a disaster, or to
otherwise employ a new difficulty before a fork is otherwise needed.

A 2-week delay in difficulty response is a 2 week error in
measurement. Slow response generally means less intelligence.

My goal is not to have a bunch of BTC clones that merchants and buyers
use equally, but to have a  better difficulty algorithm in place to be
used in the next BTC "Core" fork. If not for the current situation,
then for future security.

>  This is a massive departure from the conception of Bitcoin as having a fixed limit and effectively becoming deflationary.

You mean multiple forks is inflationary. The current limit in quantity
is deflationary because the use of the coin is rising faster than its
mining is producing (see velocity of money). Constant value is defined
as being neither. Bitcoin's deflationary quality created a massive
marketing advantage as well as paid the creator about million dollars
an hour. If it suddenly were able to be a constant value coin, its use
in the marketplace and as a real store of value would skyrocket and
the cries of "Ponzi scheme" would stop. The trick is in determining
constant value without a 3rd party such as an index of a basket of
commodities (which both Keynes and von Mises wanted, but was scuttled
by the U.S. at Bretton Woods).

On Fri, Oct 13, 2017 at 12:45 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
> Good morning,
>
>
>>ZmnSCPxj wrote:
>>> Thus even if the unwanted chain provides 2 tokens as fee per block,
>>> whereas the wanted chain provides 1 token as fee per block, if the
>>> unwanted chain tokens are valued at 1/4 the wanted chain tokens, miners
>>> will still prefer the wanted chain regardless.
>>
>>This is a good point I was not thinking about, but your math assumes
>>1/2 price for a coin that can do 2x more transactions. Holders like
>>Roger Ver have an interest in low price and more transactions. A coin
>>with 2x more transactions, 22% lower price, and 22% lower fees per
>>coin transferred will attract more merchants, customers, and miners
>>(they get 50% more total fees) and this will in turn attract more
>>hodlers and devs. This assumes it outweighs hodler security concerns.
>>Merchants and customers, to the extent they are not long term hodlers,
>>are not interested in price as much as stability, so they are somewhat
>>at odds with hodlers.
>
> As of this moment, BT1 / BT2 price ratio in BitFinex is slightly higher than
> 7 : 1.  Twice the transaction rate cannot overcome this price ratio
> difference.  Even if you were to claim that the BitFinex data is off by a
> factor of 3, twice the transaction rate still cannot overcome the price
> ratio difference.  Do you have stronger data than what is available on
> BitFinex?  If not, your assumptions are incorrect and all conclusions
> suspect.
>
>
>>Bitcoin consensus truth is based on "might is right". Buyers and
>>sellers of goods and services ("users") can shift some might to miners
>>via fees, to the chagrin of hodlers who have more interest in security
>>and price increases. Some hodlers think meeting user needs is the
>>source of long term value. Others think mining infrastructure is.
>
> Mining infrastructure follows price.  If bitcoins were still trading at 1
> USD per coin, nobody will build mining infrastructure to the same level as
> today, with 5000 USD per coin.
>
> Price will follow user needs, i.e. demand.
>
>>You
>>seem to require hodlers to correctly identify and rely solely on good
>>developers.
>
> For the very specific case of 2X, it is very easy to make this
> identification.  Even without understanding the work being done, one can
> reasonably say that it is far more likely that a loose group of 100 or more
> developers will contain a few good or excellent developers, than a group of
> a few developers containing a similar number of good or excellent
> developers.
>
> User needs will get met only on the chain that good developers work on.
> Bitcoin today has too many limitations: viruses on Windows can steal all
> your money, fee estimates consistently overestimate, fees rise during
> spamming attacks, easy to lose psuedonymity, tiny UTXOs are infeasible to
> spend, cannot support dozens of thousands of transactions per second.
> Rationally, long-term hodlers will select a chain with better developers who
> are more likely to discover or innovate methods to reduce, eliminate, or
> sidestep those limitations.  Perhaps the balance will change in the future,
> but it is certainly not the balance now, and thus any difficulty algorithm
> change in response to the current situation will be premature, and far more
> likely to cause disaster than avert one.
>
>>Whatever combination of these is the case, bad money can
>>still drive out good, especially if the market determination is not
>>efficient.
>>
>>A faster measurement of hashrate for difficulty enables the economic
>>determination to be more efficient and correct. It prevents the
>>biggest coin from bullying forks that have better ideas. Conversely,
>>it prevents miners from switching to an inferior coin simply because
>>it provides them with more "protection money" from fees that enables
>>them to bully Bitcoin Core out of existence, even in the presence of a
>>slightly larger hodler support.
>
> This requires that all chains follow the same difficulty adjustment: after
> all, it is also entirely the possibility that 2X will be the lower-hashrate
> coin in a few months, with the Core chain bullying them out of existence.
> Perhaps you should cross-post your analysis to bitcoin-segwit2x also.  After
> all, the 2X developers should also want to have faster price discovery of
> the true price of 2X, away from the unfavorable (incorrect?) pricing on
> BitFinex.
>
>>Devs are a governing authority under the influence of users, hodlers,
>>and miners. Miners are like banks lobbying government for higher total
>>fees. Hodlers are the new 1%, holding 90% of the coin, lobbying both
>>devs and users for security, but equally interested in price
>>increases. Users are "the people" that devs need to protect against
>>both hodlers and miners. They do not care about price as long as it is
>>stable. They do not want to become the 99% owning 10% of the coin or
>>have to pay unecessary fees merely for their coin to be the biggest
>>bully on the block. A faster responding difficulty will take a lot of
>>hot air out of the bully. It prevents miners from being able to
>>dictate that only coins with high fees are allowed. They are less
>>able to destroy small coins that have a fast defense.
>>
>>The 1% and banks would starve the people that feed them to death if
>>they were allowed complete control of the government. Are hodlers and
>>miners any wiser?
>
> Are developers any wiser, either?
>
> Then consider this wisdom: The fewer back-incompatible changes to a coin,
> the better.  Hardforks of any kind are an invitation to disaster and, at
> this point, require massive coordination effort which cannot be feasibly
> done within a month.  Fast market determination can be done using off-chain
> methods (such as on-exchange trades), and are generally robust against
> temporary problems on-chain, although admittedly there is a counterparty
> risk involved.  The coin works, and in general there is usually very little
> need to fix it, especially using dangerous hardforks.
>
>>Devs need to strive for an expansion of the coin
>>quantity to keep value constant which is the foundation of the 5
>>characteristics of an ideal currency.
>
> Is that your goal?  This is a massive departure from the conception of
> Bitcoin as having a fixed limit and effectively becoming deflationary.  It
> will also lead to massive economic distortions in favor of those who receive
> newly-minted coins.  I doubt any developer would want to have this property.
>
> Regards,
> ZmnSCPxj

From ilansky.sharkson at gmail.com  Fri Oct 13 12:27:17 2017
From: ilansky.sharkson at gmail.com (Ilan Oh)
Date: Fri, 13 Oct 2017 14:27:17 +0200
Subject: [bitcoin-dev] bitcoin-dev Digest, Vol 29, Issue 21
In-Reply-To: <mailman.557.1507895574.27509.bitcoin-dev@lists.linuxfoundation.org>
References: <mailman.557.1507895574.27509.bitcoin-dev@lists.linuxfoundation.org>
Message-ID: <CALTsm7gQc1h7iY-4Ad=VVh36fOtfL536a=p194XwowhQAXSgfw@mail.gmail.com>

> Mining infrastructure follows price.  If bitcoins were still trading at 1
USD per coin, nobody will build mining infrastructure to the same level as
today, with 5000 USD per coin.

In the case of bitcoin, it is the price that follows mining
infrastructures. The price is at 5000 because it is difficult to mine
bitcoin not the other way around, like you mention it. Even with a fixed
demand, price would go up as difficulty grow, the supply guide the market.
There is a strong incentive to mine blindly as it is difficult to estimate
for a miner where is the actual demand, with a start up currency without
actual economic support. Indeed at the genesis of this "mining-price" cycle
the incentive was to contribute to a network and create ones own supply,
and not respond to a demand.

Ilansky

Le 13 oct. 2017 13:55, <bitcoin-dev-request at lists.linuxfoundation.org> a
?crit :

> Send bitcoin-dev mailing list submissions to
>         bitcoin-dev at lists.linuxfoundation.org
>
> To subscribe or unsubscribe via the World Wide Web, visit
>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> or, via email, send a message with subject or body 'help' to
>         bitcoin-dev-request at lists.linuxfoundation.org
>
> You can reach the person managing the list at
>         bitcoin-dev-owner at lists.linuxfoundation.org
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of bitcoin-dev digest..."
>
>
> Today's Topics:
>
>    1. Re: New difficulty algorithm part 2 (ZmnSCPxj)
>    2. Re: New difficulty algorithm part 2 (Scott Roberts)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Fri, 13 Oct 2017 00:45:33 -0400
> From: ZmnSCPxj <ZmnSCPxj at protonmail.com>
> To: Scott Roberts <wordsgalore at gmail.com>
> Cc: "bitcoin-dev at lists.linuxfoundation.org"
>         <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] New difficulty algorithm part 2
> Message-ID:
>         <Hr8ORNHzR76wNhJHoagwXi2ewQ1qYSZScH0xeltVnqid2ljOowc2bj8-
> rkbdukpk9eyoPx1ReOZSUsNrcowRU9gL5UbKtblkQn2SUo06BHE=@protonmail.com>
>
> Content-Type: text/plain; charset="utf-8"
>
> Good morning,
>
> >ZmnSCPxj wrote:
> >> Thus even if the unwanted chain provides 2 tokens as fee per block,
> >> whereas the wanted chain provides 1 token as fee per block, if the
> >> unwanted chain tokens are valued at 1/4 the wanted chain tokens, miners
> >> will still prefer the wanted chain regardless.
> >
> >This is a good point I was not thinking about, but your math assumes
> >1/2 price for a coin that can do 2x more transactions. Holders like
> >Roger Ver have an interest in low price and more transactions. A coin
> >with 2x more transactions, 22% lower price, and 22% lower fees per
> >coin transferred will attract more merchants, customers, and miners
> >(they get 50% more total fees) and this will in turn attract more
> >hodlers and devs. This assumes it outweighs hodler security concerns.
> >Merchants and customers, to the extent they are not long term hodlers,
> >are not interested in price as much as stability, so they are somewhat
> >at odds with hodlers.
>
> As of this moment, BT1 / BT2 price ratio in BitFinex is slightly higher
> than 7 : 1.  Twice the transaction rate cannot overcome this price ratio
> difference.  Even if you were to claim that the BitFinex data is off by a
> factor of 3, twice the transaction rate still cannot overcome the price
> ratio difference.  Do you have stronger data than what is available on
> BitFinex?  If not, your assumptions are incorrect and all conclusions
> suspect.
>
> >Bitcoin consensus truth is based on "might is right". Buyers and
> >sellers of goods and services ("users") can shift some might to miners
> >via fees, to the chagrin of hodlers who have more interest in security
> >and price increases. Some hodlers think meeting user needs is the
> >source of long term value. Others think mining infrastructure is.
>
> Mining infrastructure follows price.  If bitcoins were still trading at 1
> USD per coin, nobody will build mining infrastructure to the same level as
> today, with 5000 USD per coin.
>
> Price will follow user needs, i.e. demand.
>
> >You
> >seem to require hodlers to correctly identify and rely solely on good
> >developers.
>
> For the very specific case of 2X, it is very easy to make this
> identification.  Even without understanding the work being done, one can
> reasonably say that it is far more likely that a loose group of 100 or more
> developers will contain a few good or excellent developers, than a group of
> a few developers containing a similar number of good or excellent
> developers.
>
> User needs will get met only on the chain that good developers work on.
> Bitcoin today has too many limitations: viruses on Windows can steal all
> your money, fee estimates consistently overestimate, fees rise during
> spamming attacks, easy to lose psuedonymity, tiny UTXOs are infeasible to
> spend, cannot support dozens of thousands of transactions per second.
> Rationally, long-term hodlers will select a chain with better developers
> who are more likely to discover or innovate methods to reduce, eliminate,
> or sidestep those limitations.  Perhaps the balance will change in the
> future, but it is certainly not the balance now, and thus any difficulty
> algorithm change in response to the current situation will be premature,
> and far more likely to cause disaster than avert one.
>
> >Whatever combination of these is the case, bad money can
> >still drive out good, especially if the market determination is not
> >efficient.
> >
> >A faster measurement of hashrate for difficulty enables the economic
> >determination to be more efficient and correct. It prevents the
> >biggest coin from bullying forks that have better ideas. Conversely,
> >it prevents miners from switching to an inferior coin simply because
> >it provides them with more "protection money" from fees that enables
> >them to bully Bitcoin Core out of existence, even in the presence of a
> >slightly larger hodler support.
>
> This requires that all chains follow the same difficulty adjustment: after
> all, it is also entirely the possibility that 2X will be the lower-hashrate
> coin in a few months, with the Core chain bullying them out of existence.
> Perhaps you should cross-post your analysis to bitcoin-segwit2x also.
> After all, the 2X developers should also want to have faster price
> discovery of the true price of 2X, away from the unfavorable (incorrect?)
> pricing on BitFinex.
>
> >Devs are a governing authority under the influence of users, hodlers,
> >and miners. Miners are like banks lobbying government for higher total
> >fees. Hodlers are the new 1%, holding 90% of the coin, lobbying both
> >devs and users for security, but equally interested in price
> >increases. Users are "the people" that devs need to protect against
> >both hodlers and miners. They do not care about price as long as it is
> >stable. They do not want to become the 99% owning 10% of the coin or
> >have to pay unecessary fees merely for their coin to be the biggest
> >bully on the block. A faster responding difficulty will take a lot of
> >hot air out of the bully. It prevents miners from being able to
> >dictate that only coins with high fees are allowed. They are less
> >able to destroy small coins that have a fast defense.
> >
> >The 1% and banks would starve the people that feed them to death if
> >they were allowed complete control of the government. Are hodlers and
> >miners any wiser?
>
> Are developers any wiser, either?
>
> Then consider this wisdom: The fewer back-incompatible changes to a coin,
> the better.  Hardforks of any kind are an invitation to disaster and, at
> this point, require massive coordination effort which cannot be feasibly
> done within a month.  Fast market determination can be done using off-chain
> methods (such as on-exchange trades), and are generally robust against
> temporary problems on-chain, although admittedly there is a counterparty
> risk involved.  The coin works, and in general there is usually very little
> need to fix it, especially using dangerous hardforks.
>
> >Devs need to strive for an expansion of the coin
> >quantity to keep value constant which is the foundation of the 5
> >characteristics of an ideal currency.
>
> Is that your goal?  This is a massive departure from the conception of
> Bitcoin as having a fixed limit and effectively becoming deflationary.  It
> will also lead to massive economic distortions in favor of those who
> receive newly-minted coins.  I doubt any developer would want to have this
> property.
>
> Regards,
> ZmnSCPxj
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> attachments/20171013/1afdebf0/attachment.html>
>
> ------------------------------
>
> Message: 2
> Date: Fri, 13 Oct 2017 07:35:09 -0400
> From: Scott Roberts <wordsgalore at gmail.com>
> To: ZmnSCPxj <ZmnSCPxj at protonmail.com>
> Cc: "bitcoin-dev at lists.linuxfoundation.org"
>         <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] New difficulty algorithm part 2
> Message-ID:
>         <CADtTMvnrZp=JD4rkXQOZAPNS9BMNMqnTyfA65PRzZhWs+VxgHA at mail.
> gmail.com>
> Content-Type: text/plain; charset="UTF-8"
>
> Yes, the current price ratio indicates there is no need for a new
> difficulty algorithm. I do not desire to fork before a disaster, or to
> otherwise employ a new difficulty before a fork is otherwise needed.
>
> A 2-week delay in difficulty response is a 2 week error in
> measurement. Slow response generally means less intelligence.
>
> My goal is not to have a bunch of BTC clones that merchants and buyers
> use equally, but to have a  better difficulty algorithm in place to be
> used in the next BTC "Core" fork. If not for the current situation,
> then for future security.
>
> >  This is a massive departure from the conception of Bitcoin as having a
> fixed limit and effectively becoming deflationary.
>
> You mean multiple forks is inflationary. The current limit in quantity
> is deflationary because the use of the coin is rising faster than its
> mining is producing (see velocity of money). Constant value is defined
> as being neither. Bitcoin's deflationary quality created a massive
> marketing advantage as well as paid the creator about million dollars
> an hour. If it suddenly were able to be a constant value coin, its use
> in the marketplace and as a real store of value would skyrocket and
> the cries of "Ponzi scheme" would stop. The trick is in determining
> constant value without a 3rd party such as an index of a basket of
> commodities (which both Keynes and von Mises wanted, but was scuttled
> by the U.S. at Bretton Woods).
>
> On Fri, Oct 13, 2017 at 12:45 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com>
> wrote:
> > Good morning,
> >
> >
> >>ZmnSCPxj wrote:
> >>> Thus even if the unwanted chain provides 2 tokens as fee per block,
> >>> whereas the wanted chain provides 1 token as fee per block, if the
> >>> unwanted chain tokens are valued at 1/4 the wanted chain tokens, miners
> >>> will still prefer the wanted chain regardless.
> >>
> >>This is a good point I was not thinking about, but your math assumes
> >>1/2 price for a coin that can do 2x more transactions. Holders like
> >>Roger Ver have an interest in low price and more transactions. A coin
> >>with 2x more transactions, 22% lower price, and 22% lower fees per
> >>coin transferred will attract more merchants, customers, and miners
> >>(they get 50% more total fees) and this will in turn attract more
> >>hodlers and devs. This assumes it outweighs hodler security concerns.
> >>Merchants and customers, to the extent they are not long term hodlers,
> >>are not interested in price as much as stability, so they are somewhat
> >>at odds with hodlers.
> >
> > As of this moment, BT1 / BT2 price ratio in BitFinex is slightly higher
> than
> > 7 : 1.  Twice the transaction rate cannot overcome this price ratio
> > difference.  Even if you were to claim that the BitFinex data is off by a
> > factor of 3, twice the transaction rate still cannot overcome the price
> > ratio difference.  Do you have stronger data than what is available on
> > BitFinex?  If not, your assumptions are incorrect and all conclusions
> > suspect.
> >
> >
> >>Bitcoin consensus truth is based on "might is right". Buyers and
> >>sellers of goods and services ("users") can shift some might to miners
> >>via fees, to the chagrin of hodlers who have more interest in security
> >>and price increases. Some hodlers think meeting user needs is the
> >>source of long term value. Others think mining infrastructure is.
> >
> > Mining infrastructure follows price.  If bitcoins were still trading at 1
> > USD per coin, nobody will build mining infrastructure to the same level
> as
> > today, with 5000 USD per coin.
> >
> > Price will follow user needs, i.e. demand.
> >
> >>You
> >>seem to require hodlers to correctly identify and rely solely on good
> >>developers.
> >
> > For the very specific case of 2X, it is very easy to make this
> > identification.  Even without understanding the work being done, one can
> > reasonably say that it is far more likely that a loose group of 100 or
> more
> > developers will contain a few good or excellent developers, than a group
> of
> > a few developers containing a similar number of good or excellent
> > developers.
> >
> > User needs will get met only on the chain that good developers work on.
> > Bitcoin today has too many limitations: viruses on Windows can steal all
> > your money, fee estimates consistently overestimate, fees rise during
> > spamming attacks, easy to lose psuedonymity, tiny UTXOs are infeasible to
> > spend, cannot support dozens of thousands of transactions per second.
> > Rationally, long-term hodlers will select a chain with better developers
> who
> > are more likely to discover or innovate methods to reduce, eliminate, or
> > sidestep those limitations.  Perhaps the balance will change in the
> future,
> > but it is certainly not the balance now, and thus any difficulty
> algorithm
> > change in response to the current situation will be premature, and far
> more
> > likely to cause disaster than avert one.
> >
> >>Whatever combination of these is the case, bad money can
> >>still drive out good, especially if the market determination is not
> >>efficient.
> >>
> >>A faster measurement of hashrate for difficulty enables the economic
> >>determination to be more efficient and correct. It prevents the
> >>biggest coin from bullying forks that have better ideas. Conversely,
> >>it prevents miners from switching to an inferior coin simply because
> >>it provides them with more "protection money" from fees that enables
> >>them to bully Bitcoin Core out of existence, even in the presence of a
> >>slightly larger hodler support.
> >
> > This requires that all chains follow the same difficulty adjustment:
> after
> > all, it is also entirely the possibility that 2X will be the
> lower-hashrate
> > coin in a few months, with the Core chain bullying them out of existence.
> > Perhaps you should cross-post your analysis to bitcoin-segwit2x also.
> After
> > all, the 2X developers should also want to have faster price discovery of
> > the true price of 2X, away from the unfavorable (incorrect?) pricing on
> > BitFinex.
> >
> >>Devs are a governing authority under the influence of users, hodlers,
> >>and miners. Miners are like banks lobbying government for higher total
> >>fees. Hodlers are the new 1%, holding 90% of the coin, lobbying both
> >>devs and users for security, but equally interested in price
> >>increases. Users are "the people" that devs need to protect against
> >>both hodlers and miners. They do not care about price as long as it is
> >>stable. They do not want to become the 99% owning 10% of the coin or
> >>have to pay unecessary fees merely for their coin to be the biggest
> >>bully on the block. A faster responding difficulty will take a lot of
> >>hot air out of the bully. It prevents miners from being able to
> >>dictate that only coins with high fees are allowed. They are less
> >>able to destroy small coins that have a fast defense.
> >>
> >>The 1% and banks would starve the people that feed them to death if
> >>they were allowed complete control of the government. Are hodlers and
> >>miners any wiser?
> >
> > Are developers any wiser, either?
> >
> > Then consider this wisdom: The fewer back-incompatible changes to a coin,
> > the better.  Hardforks of any kind are an invitation to disaster and, at
> > this point, require massive coordination effort which cannot be feasibly
> > done within a month.  Fast market determination can be done using
> off-chain
> > methods (such as on-exchange trades), and are generally robust against
> > temporary problems on-chain, although admittedly there is a counterparty
> > risk involved.  The coin works, and in general there is usually very
> little
> > need to fix it, especially using dangerous hardforks.
> >
> >>Devs need to strive for an expansion of the coin
> >>quantity to keep value constant which is the foundation of the 5
> >>characteristics of an ideal currency.
> >
> > Is that your goal?  This is a massive departure from the conception of
> > Bitcoin as having a fixed limit and effectively becoming deflationary.
> It
> > will also lead to massive economic distortions in favor of those who
> receive
> > newly-minted coins.  I doubt any developer would want to have this
> property.
> >
> > Regards,
> > ZmnSCPxj
>
>
> ------------------------------
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> End of bitcoin-dev Digest, Vol 29, Issue 21
> *******************************************
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171013/6f6c73fc/attachment-0001.html>

From wordsgalore at gmail.com  Fri Oct 13 13:57:33 2017
From: wordsgalore at gmail.com (Scott Roberts)
Date: Fri, 13 Oct 2017 09:57:33 -0400
Subject: [bitcoin-dev] bitcoin-dev Digest, Vol 29, Issue 21
In-Reply-To: <CALTsm7gQc1h7iY-4Ad=VVh36fOtfL536a=p194XwowhQAXSgfw@mail.gmail.com>
References: <mailman.557.1507895574.27509.bitcoin-dev@lists.linuxfoundation.org>
	<CALTsm7gQc1h7iY-4Ad=VVh36fOtfL536a=p194XwowhQAXSgfw@mail.gmail.com>
Message-ID: <CADtTMv=dx93za+wJ3vc8jLB2xfGrW_d32T7hodx2=Eo0JvuF4A@mail.gmail.com>

> ZmnSCPxj wrote
>> Mining infrastructure follows price.

Ilansky wrote:
> In the case of bitcoin, it is the price that follows mining infrastructures.

I generally agree with ZmnSCPxj that
good ideas => good devs => hodlers => price => mining

Except that each step is not an absolute, and can be biased by things
like miners who seek profit via fees and other means that are not good
for everyone else. Llansky's belief itself influences price away from
the ideal. Marketing "easy profits for hodlers!" and first-to-market
monopoly are other elements that influence price and thereby guide
mining away from good ideas (like a constant value currency). Then
price pulls in good devs that pulls in more mining. So it can snowball
into a monster.

We need not debate cause and effect since it's distant from the list's
goals. The relevance to me is that the biases away from ZmnSCPxj's
ideal are a reason a more responsive difficulty is needed.

Mining is for determining truth of the blockchain, not to make sure
there is only 1 blockchain. ZmnSCPxj indicates we should not do
anything that has more precision or speed in determining the correct
difficulty if it reduces Bitcoin's ability to be a monopoly. Not
coincidentally, the monopoly helps ensure hodlers become the new 1%. A
fork clone that uses the faster difficulty would attack BTC's slow
difficulty if it achieves a comparable price. All other things being
equal, it would lower BTC's value until it forks to fix the
difficulty.

On Fri, Oct 13, 2017 at 8:27 AM, Ilan Oh via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>> Mining infrastructure follows price.  If bitcoins were still trading at 1
>> USD per coin, nobody will build mining infrastructure to the same level as
>> today, with 5000 USD per coin.
>
> In the case of bitcoin, it is the price that follows mining infrastructures.
> The price is at 5000 because it is difficult to mine bitcoin not the other
> way around, like you mention it. Even with a fixed demand, price would go up
> as difficulty grow, the supply guide the market. There is a strong incentive
> to mine blindly as it is difficult to estimate for a miner where is the
> actual demand, with a start up currency without actual economic support.
> Indeed at the genesis of this "mining-price" cycle the incentive was to
> contribute to a network and create ones own supply, and not respond to a
> demand.
>
> Ilansky
>
> Le 13 oct. 2017 13:55, <bitcoin-dev-request at lists.linuxfoundation.org> a
> ?crit :
>>
>> Send bitcoin-dev mailing list submissions to
>>         bitcoin-dev at lists.linuxfoundation.org
>>
>> To subscribe or unsubscribe via the World Wide Web, visit
>>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> or, via email, send a message with subject or body 'help' to
>>         bitcoin-dev-request at lists.linuxfoundation.org
>>
>> You can reach the person managing the list at
>>         bitcoin-dev-owner at lists.linuxfoundation.org
>>
>> When replying, please edit your Subject line so it is more specific
>> than "Re: Contents of bitcoin-dev digest..."
>>
>>
>> Today's Topics:
>>
>>    1. Re: New difficulty algorithm part 2 (ZmnSCPxj)
>>    2. Re: New difficulty algorithm part 2 (Scott Roberts)
>>
>>
>> ----------------------------------------------------------------------
>>
>> Message: 1
>> Date: Fri, 13 Oct 2017 00:45:33 -0400
>> From: ZmnSCPxj <ZmnSCPxj at protonmail.com>
>> To: Scott Roberts <wordsgalore at gmail.com>
>> Cc: "bitcoin-dev at lists.linuxfoundation.org"
>>         <bitcoin-dev at lists.linuxfoundation.org>
>> Subject: Re: [bitcoin-dev] New difficulty algorithm part 2
>> Message-ID:
>>
>> <Hr8ORNHzR76wNhJHoagwXi2ewQ1qYSZScH0xeltVnqid2ljOowc2bj8-rkbdukpk9eyoPx1ReOZSUsNrcowRU9gL5UbKtblkQn2SUo06BHE=@protonmail.com>
>>
>> Content-Type: text/plain; charset="utf-8"
>>
>> Good morning,
>>
>> >ZmnSCPxj wrote:
>> >> Thus even if the unwanted chain provides 2 tokens as fee per block,
>> >> whereas the wanted chain provides 1 token as fee per block, if the
>> >> unwanted chain tokens are valued at 1/4 the wanted chain tokens, miners
>> >> will still prefer the wanted chain regardless.
>> >
>> >This is a good point I was not thinking about, but your math assumes
>> >1/2 price for a coin that can do 2x more transactions. Holders like
>> >Roger Ver have an interest in low price and more transactions. A coin
>> >with 2x more transactions, 22% lower price, and 22% lower fees per
>> >coin transferred will attract more merchants, customers, and miners
>> >(they get 50% more total fees) and this will in turn attract more
>> >hodlers and devs. This assumes it outweighs hodler security concerns.
>> >Merchants and customers, to the extent they are not long term hodlers,
>> >are not interested in price as much as stability, so they are somewhat
>> >at odds with hodlers.
>>
>> As of this moment, BT1 / BT2 price ratio in BitFinex is slightly higher
>> than 7 : 1.  Twice the transaction rate cannot overcome this price ratio
>> difference.  Even if you were to claim that the BitFinex data is off by a
>> factor of 3, twice the transaction rate still cannot overcome the price
>> ratio difference.  Do you have stronger data than what is available on
>> BitFinex?  If not, your assumptions are incorrect and all conclusions
>> suspect.
>>
>> >Bitcoin consensus truth is based on "might is right". Buyers and
>> >sellers of goods and services ("users") can shift some might to miners
>> >via fees, to the chagrin of hodlers who have more interest in security
>> >and price increases. Some hodlers think meeting user needs is the
>> >source of long term value. Others think mining infrastructure is.
>>
>> Mining infrastructure follows price.  If bitcoins were still trading at 1
>> USD per coin, nobody will build mining infrastructure to the same level as
>> today, with 5000 USD per coin.
>>
>> Price will follow user needs, i.e. demand.
>>
>> >You
>> >seem to require hodlers to correctly identify and rely solely on good
>> >developers.
>>
>> For the very specific case of 2X, it is very easy to make this
>> identification.  Even without understanding the work being done, one can
>> reasonably say that it is far more likely that a loose group of 100 or more
>> developers will contain a few good or excellent developers, than a group of
>> a few developers containing a similar number of good or excellent
>> developers.
>>
>> User needs will get met only on the chain that good developers work on.
>> Bitcoin today has too many limitations: viruses on Windows can steal all
>> your money, fee estimates consistently overestimate, fees rise during
>> spamming attacks, easy to lose psuedonymity, tiny UTXOs are infeasible to
>> spend, cannot support dozens of thousands of transactions per second.
>> Rationally, long-term hodlers will select a chain with better developers who
>> are more likely to discover or innovate methods to reduce, eliminate, or
>> sidestep those limitations.  Perhaps the balance will change in the future,
>> but it is certainly not the balance now, and thus any difficulty algorithm
>> change in response to the current situation will be premature, and far more
>> likely to cause disaster than avert one.
>>
>> >Whatever combination of these is the case, bad money can
>> >still drive out good, especially if the market determination is not
>> >efficient.
>> >
>> >A faster measurement of hashrate for difficulty enables the economic
>> >determination to be more efficient and correct. It prevents the
>> >biggest coin from bullying forks that have better ideas. Conversely,
>> >it prevents miners from switching to an inferior coin simply because
>> >it provides them with more "protection money" from fees that enables
>> >them to bully Bitcoin Core out of existence, even in the presence of a
>> >slightly larger hodler support.
>>
>> This requires that all chains follow the same difficulty adjustment: after
>> all, it is also entirely the possibility that 2X will be the lower-hashrate
>> coin in a few months, with the Core chain bullying them out of existence.
>> Perhaps you should cross-post your analysis to bitcoin-segwit2x also.  After
>> all, the 2X developers should also want to have faster price discovery of
>> the true price of 2X, away from the unfavorable (incorrect?) pricing on
>> BitFinex.
>>
>> >Devs are a governing authority under the influence of users, hodlers,
>> >and miners. Miners are like banks lobbying government for higher total
>> >fees. Hodlers are the new 1%, holding 90% of the coin, lobbying both
>> >devs and users for security, but equally interested in price
>> >increases. Users are "the people" that devs need to protect against
>> >both hodlers and miners. They do not care about price as long as it is
>> >stable. They do not want to become the 99% owning 10% of the coin or
>> >have to pay unecessary fees merely for their coin to be the biggest
>> >bully on the block. A faster responding difficulty will take a lot of
>> >hot air out of the bully. It prevents miners from being able to
>> >dictate that only coins with high fees are allowed. They are less
>> >able to destroy small coins that have a fast defense.
>> >
>> >The 1% and banks would starve the people that feed them to death if
>> >they were allowed complete control of the government. Are hodlers and
>> >miners any wiser?
>>
>> Are developers any wiser, either?
>>
>> Then consider this wisdom: The fewer back-incompatible changes to a coin,
>> the better.  Hardforks of any kind are an invitation to disaster and, at
>> this point, require massive coordination effort which cannot be feasibly
>> done within a month.  Fast market determination can be done using off-chain
>> methods (such as on-exchange trades), and are generally robust against
>> temporary problems on-chain, although admittedly there is a counterparty
>> risk involved.  The coin works, and in general there is usually very little
>> need to fix it, especially using dangerous hardforks.
>>
>> >Devs need to strive for an expansion of the coin
>> >quantity to keep value constant which is the foundation of the 5
>> >characteristics of an ideal currency.
>>
>> Is that your goal?  This is a massive departure from the conception of
>> Bitcoin as having a fixed limit and effectively becoming deflationary.  It
>> will also lead to massive economic distortions in favor of those who receive
>> newly-minted coins.  I doubt any developer would want to have this property.
>>
>> Regards,
>> ZmnSCPxj
>> -------------- next part --------------
>> An HTML attachment was scrubbed...
>> URL:
>> <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171013/1afdebf0/attachment.html>
>>
>> ------------------------------
>>
>> Message: 2
>> Date: Fri, 13 Oct 2017 07:35:09 -0400
>> From: Scott Roberts <wordsgalore at gmail.com>
>> To: ZmnSCPxj <ZmnSCPxj at protonmail.com>
>> Cc: "bitcoin-dev at lists.linuxfoundation.org"
>>         <bitcoin-dev at lists.linuxfoundation.org>
>> Subject: Re: [bitcoin-dev] New difficulty algorithm part 2
>> Message-ID:
>>
>> <CADtTMvnrZp=JD4rkXQOZAPNS9BMNMqnTyfA65PRzZhWs+VxgHA at mail.gmail.com>
>> Content-Type: text/plain; charset="UTF-8"
>>
>> Yes, the current price ratio indicates there is no need for a new
>> difficulty algorithm. I do not desire to fork before a disaster, or to
>> otherwise employ a new difficulty before a fork is otherwise needed.
>>
>> A 2-week delay in difficulty response is a 2 week error in
>> measurement. Slow response generally means less intelligence.
>>
>> My goal is not to have a bunch of BTC clones that merchants and buyers
>> use equally, but to have a  better difficulty algorithm in place to be
>> used in the next BTC "Core" fork. If not for the current situation,
>> then for future security.
>>
>> >  This is a massive departure from the conception of Bitcoin as having a
>> > fixed limit and effectively becoming deflationary.
>>
>> You mean multiple forks is inflationary. The current limit in quantity
>> is deflationary because the use of the coin is rising faster than its
>> mining is producing (see velocity of money). Constant value is defined
>> as being neither. Bitcoin's deflationary quality created a massive
>> marketing advantage as well as paid the creator about million dollars
>> an hour. If it suddenly were able to be a constant value coin, its use
>> in the marketplace and as a real store of value would skyrocket and
>> the cries of "Ponzi scheme" would stop. The trick is in determining
>> constant value without a 3rd party such as an index of a basket of
>> commodities (which both Keynes and von Mises wanted, but was scuttled
>> by the U.S. at Bretton Woods).
>>
>> On Fri, Oct 13, 2017 at 12:45 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com>
>> wrote:
>> > Good morning,
>> >
>> >
>> >>ZmnSCPxj wrote:
>> >>> Thus even if the unwanted chain provides 2 tokens as fee per block,
>> >>> whereas the wanted chain provides 1 token as fee per block, if the
>> >>> unwanted chain tokens are valued at 1/4 the wanted chain tokens,
>> >>> miners
>> >>> will still prefer the wanted chain regardless.
>> >>
>> >>This is a good point I was not thinking about, but your math assumes
>> >>1/2 price for a coin that can do 2x more transactions. Holders like
>> >>Roger Ver have an interest in low price and more transactions. A coin
>> >>with 2x more transactions, 22% lower price, and 22% lower fees per
>> >>coin transferred will attract more merchants, customers, and miners
>> >>(they get 50% more total fees) and this will in turn attract more
>> >>hodlers and devs. This assumes it outweighs hodler security concerns.
>> >>Merchants and customers, to the extent they are not long term hodlers,
>> >>are not interested in price as much as stability, so they are somewhat
>> >>at odds with hodlers.
>> >
>> > As of this moment, BT1 / BT2 price ratio in BitFinex is slightly higher
>> > than
>> > 7 : 1.  Twice the transaction rate cannot overcome this price ratio
>> > difference.  Even if you were to claim that the BitFinex data is off by
>> > a
>> > factor of 3, twice the transaction rate still cannot overcome the price
>> > ratio difference.  Do you have stronger data than what is available on
>> > BitFinex?  If not, your assumptions are incorrect and all conclusions
>> > suspect.
>> >
>> >
>> >>Bitcoin consensus truth is based on "might is right". Buyers and
>> >>sellers of goods and services ("users") can shift some might to miners
>> >>via fees, to the chagrin of hodlers who have more interest in security
>> >>and price increases. Some hodlers think meeting user needs is the
>> >>source of long term value. Others think mining infrastructure is.
>> >
>> > Mining infrastructure follows price.  If bitcoins were still trading at
>> > 1
>> > USD per coin, nobody will build mining infrastructure to the same level
>> > as
>> > today, with 5000 USD per coin.
>> >
>> > Price will follow user needs, i.e. demand.
>> >
>> >>You
>> >>seem to require hodlers to correctly identify and rely solely on good
>> >>developers.
>> >
>> > For the very specific case of 2X, it is very easy to make this
>> > identification.  Even without understanding the work being done, one can
>> > reasonably say that it is far more likely that a loose group of 100 or
>> > more
>> > developers will contain a few good or excellent developers, than a group
>> > of
>> > a few developers containing a similar number of good or excellent
>> > developers.
>> >
>> > User needs will get met only on the chain that good developers work on.
>> > Bitcoin today has too many limitations: viruses on Windows can steal all
>> > your money, fee estimates consistently overestimate, fees rise during
>> > spamming attacks, easy to lose psuedonymity, tiny UTXOs are infeasible
>> > to
>> > spend, cannot support dozens of thousands of transactions per second.
>> > Rationally, long-term hodlers will select a chain with better developers
>> > who
>> > are more likely to discover or innovate methods to reduce, eliminate, or
>> > sidestep those limitations.  Perhaps the balance will change in the
>> > future,
>> > but it is certainly not the balance now, and thus any difficulty
>> > algorithm
>> > change in response to the current situation will be premature, and far
>> > more
>> > likely to cause disaster than avert one.
>> >
>> >>Whatever combination of these is the case, bad money can
>> >>still drive out good, especially if the market determination is not
>> >>efficient.
>> >>
>> >>A faster measurement of hashrate for difficulty enables the economic
>> >>determination to be more efficient and correct. It prevents the
>> >>biggest coin from bullying forks that have better ideas. Conversely,
>> >>it prevents miners from switching to an inferior coin simply because
>> >>it provides them with more "protection money" from fees that enables
>> >>them to bully Bitcoin Core out of existence, even in the presence of a
>> >>slightly larger hodler support.
>> >
>> > This requires that all chains follow the same difficulty adjustment:
>> > after
>> > all, it is also entirely the possibility that 2X will be the
>> > lower-hashrate
>> > coin in a few months, with the Core chain bullying them out of
>> > existence.
>> > Perhaps you should cross-post your analysis to bitcoin-segwit2x also.
>> > After
>> > all, the 2X developers should also want to have faster price discovery
>> > of
>> > the true price of 2X, away from the unfavorable (incorrect?) pricing on
>> > BitFinex.
>> >
>> >>Devs are a governing authority under the influence of users, hodlers,
>> >>and miners. Miners are like banks lobbying government for higher total
>> >>fees. Hodlers are the new 1%, holding 90% of the coin, lobbying both
>> >>devs and users for security, but equally interested in price
>> >>increases. Users are "the people" that devs need to protect against
>> >>both hodlers and miners. They do not care about price as long as it is
>> >>stable. They do not want to become the 99% owning 10% of the coin or
>> >>have to pay unecessary fees merely for their coin to be the biggest
>> >>bully on the block. A faster responding difficulty will take a lot of
>> >>hot air out of the bully. It prevents miners from being able to
>> >>dictate that only coins with high fees are allowed. They are less
>> >>able to destroy small coins that have a fast defense.
>> >>
>> >>The 1% and banks would starve the people that feed them to death if
>> >>they were allowed complete control of the government. Are hodlers and
>> >>miners any wiser?
>> >
>> > Are developers any wiser, either?
>> >
>> > Then consider this wisdom: The fewer back-incompatible changes to a
>> > coin,
>> > the better.  Hardforks of any kind are an invitation to disaster and, at
>> > this point, require massive coordination effort which cannot be feasibly
>> > done within a month.  Fast market determination can be done using
>> > off-chain
>> > methods (such as on-exchange trades), and are generally robust against
>> > temporary problems on-chain, although admittedly there is a counterparty
>> > risk involved.  The coin works, and in general there is usually very
>> > little
>> > need to fix it, especially using dangerous hardforks.
>> >
>> >>Devs need to strive for an expansion of the coin
>> >>quantity to keep value constant which is the foundation of the 5
>> >>characteristics of an ideal currency.
>> >
>> > Is that your goal?  This is a massive departure from the conception of
>> > Bitcoin as having a fixed limit and effectively becoming deflationary.
>> > It
>> > will also lead to massive economic distortions in favor of those who
>> > receive
>> > newly-minted coins.  I doubt any developer would want to have this
>> > property.
>> >
>> > Regards,
>> > ZmnSCPxj
>>
>>
>> ------------------------------
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>> End of bitcoin-dev Digest, Vol 29, Issue 21
>> *******************************************
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From jon at thancodes.com  Thu Oct 19 06:52:48 2017
From: jon at thancodes.com (Jonathan Sterling)
Date: Thu, 19 Oct 2017 14:52:48 +0800
Subject: [bitcoin-dev] Improving Scalability via Block Time Decrease
Message-ID: <CAH01uEtLhLEj5XOp_MDRii2dR8-zUu4fUsCd25mzLDtpD_fwYQ@mail.gmail.com>

The current ten-minute block time was chosen by Satoshi as a tradeoff
between confirmation time and the amount of work wasted due to chain
splits. Is there not room for optimization in this number from:

A. Advances in technology in the last 8-9 years
B. A lack of any rigorous formula being used to determine what's the
optimal rate
C. The existence of similar chains that work at a much lower block times

Whilst I think we can all agree that 10 second block times would result in
a lot of chain splits due to Bitcoins 12-13 second propagation time (to 95%
of nodes), I think we'll find that we can go lower than 10 minutes without
much issue. Is this something that should be looked at or am I an idiot who
needs to read more? If I'm an idiot, I apologize; kindly point me in the
right direction.

Things I've read on the subject:
https://medium.facilelogin.com/the-mystery-behind-block-time-63351e35603a
(section header "Why Bitcoin Block Time Is 10 Minutes ?")
https://bitcointalk.org/index.php?topic=176108.0
https://bitcoin.stackexchange.com/questions/1863/why-was-the-target-block-time-chosen-to-be-10-minutes

Kind Regards,

Jonathan Sterling
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171019/d940fd4e/attachment.html>

From adan at stampery.co  Thu Oct 19 13:41:51 2017
From: adan at stampery.co (=?UTF-8?Q?Ad=c3=a1n_S=c3=a1nchez_de_Pedro_Crespo?=)
Date: Thu, 19 Oct 2017 15:41:51 +0200
Subject: [bitcoin-dev] Improving Scalability via Block Time Decrease
In-Reply-To: <CAH01uEtLhLEj5XOp_MDRii2dR8-zUu4fUsCd25mzLDtpD_fwYQ@mail.gmail.com>
References: <CAH01uEtLhLEj5XOp_MDRii2dR8-zUu4fUsCd25mzLDtpD_fwYQ@mail.gmail.com>
Message-ID: <40b6ef7b-f518-38cd-899a-8f301bc7ac3a@stampery.com>

Blockchains with fast confirmation times are currently believed to
suffer from reduced security due to a high stale rate.

As blocks take a certain time to propagate through the network, if miner
A mines a block and then miner B happens to mine another block before
miner A's block propagates to B, miner B's block will end up wasted and
will not "contribute to network security".

Furthermore, there is a centralization issue: if miner A is a mining
pool with 30% hashpower and B has 10% hashpower, A will have a risk of
producing a stale block 70% of the time (since the other 30% of the time
A produced the last block and so will get mining data immediately)
whereas B will have a risk of producing a stale block 90% of the time.

Thus, if the block interval is short enough for the stale rate
to be high, A will be substantially more efficient simply by virtue of
its size. With these two effects combined, blockchains which produce
blocks quickly are very likely to lead to one mining pool having a large
enough percentage of the network hashpower to have de facto control over
the mining process.

Another possible implication of reducing the average block time is that
block size should be reduced accordingly. In an hypothetical 5 minutes
block size Bitcoin blockchain, there would be twice the block space
available for miners to include transactions, which could lead to 2
immediate consequences: (1) the blockchain could grow up to twice the
rate, which is known to be bad for decentralization; and (2) transaction
fees might go down, making it cheaper for spammers to bloat our beloved
UTXO sets.

There have been numerous proposals that tried to overcome the downsides
of faster blocks, the most noteworthy probably being the "Greedy
Heaviest Observed Subtree" (GHOST) protocol:
http://www.cs.huji.ac.il/~yoni_sompo/pubs/15/btc_scalability_full.pdf

Personally, I can't see why Bitcoin would need or how could it even
benefit at all from faster blocks. Nevertheless, I would really love if
someone in the list who has already run the numbers could bring some
valid points on why 10 minutes is the optimal rate (other than "if it
ain't broke, don't fix it").

-- 
Ad?n S?nchez de Pedro Crespo
CTO, Stampery Inc.
San Francisco - Madrid

From ilansky.sharkson at gmail.com  Fri Oct 20 17:24:34 2017
From: ilansky.sharkson at gmail.com (Ilan Oh)
Date: Fri, 20 Oct 2017 19:24:34 +0200
Subject: [bitcoin-dev] bitcoin-dev Digest, Vol 29, Issue 24
In-Reply-To: <mailman.57.1508500809.30522.bitcoin-dev@lists.linuxfoundation.org>
References: <mailman.57.1508500809.30522.bitcoin-dev@lists.linuxfoundation.org>
Message-ID: <CALTsm7iy0Wh6e3SsE-OWj_+R=jhBGxXdhCaEMixzA_KD=TModw@mail.gmail.com>

The only blocktime reduction that would be a game changer, would be a 1
second blocktime or less, and by less I mean much less maybe 1000
blocks/second. Which would enable decentralized high frequency trading or
playing WoW on blockchain and other cool stuff.

But technology is not developped enough as far as I now, maybe with quantum
computers in the future, and it is even bitcoins goal?

Also there is a guy who wrote a script to avoid "sybil attack" from 2x
https://github.com/mariodian/ban-segshit8x-nodes

I don't know what it's worth, maybe check it out, I'm not huge support of
that kind of methods.

Ilansky


Le 20 oct. 2017 14:01, <bitcoin-dev-request at lists.linuxfoundation.org> a
?crit :

> Send bitcoin-dev mailing list submissions to
>         bitcoin-dev at lists.linuxfoundation.org
>
> To subscribe or unsubscribe via the World Wide Web, visit
>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> or, via email, send a message with subject or body 'help' to
>         bitcoin-dev-request at lists.linuxfoundation.org
>
> You can reach the person managing the list at
>         bitcoin-dev-owner at lists.linuxfoundation.org
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of bitcoin-dev digest..."
>
>
> Today's Topics:
>
>    1. Improving Scalability via Block Time Decrease (Jonathan Sterling)
>    2. Re: Improving Scalability via Block Time Decrease
>       (=?UTF-8?Q?Ad=c3=a1n_S=c3=a1nchez_de_Pedro_Crespo?=)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Thu, 19 Oct 2017 14:52:48 +0800
> From: Jonathan Sterling <jon at thancodes.com>
> To: bitcoin-dev at lists.linuxfoundation.org
> Subject: [bitcoin-dev] Improving Scalability via Block Time Decrease
> Message-ID:
>         <CAH01uEtLhLEj5XOp_MDRii2dR8-zUu4fUsCd25mzLDtpD_fwYQ at mail.
> gmail.com>
> Content-Type: text/plain; charset="utf-8"
>
> The current ten-minute block time was chosen by Satoshi as a tradeoff
> between confirmation time and the amount of work wasted due to chain
> splits. Is there not room for optimization in this number from:
>
> A. Advances in technology in the last 8-9 years
> B. A lack of any rigorous formula being used to determine what's the
> optimal rate
> C. The existence of similar chains that work at a much lower block times
>
> Whilst I think we can all agree that 10 second block times would result in
> a lot of chain splits due to Bitcoins 12-13 second propagation time (to 95%
> of nodes), I think we'll find that we can go lower than 10 minutes without
> much issue. Is this something that should be looked at or am I an idiot who
> needs to read more? If I'm an idiot, I apologize; kindly point me in the
> right direction.
>
> Things I've read on the subject:
> https://medium.facilelogin.com/the-mystery-behind-block-time-63351e35603a
> (section header "Why Bitcoin Block Time Is 10 Minutes ?")
> https://bitcointalk.org/index.php?topic=176108.0
> https://bitcoin.stackexchange.com/questions/1863/why-was-
> the-target-block-time-chosen-to-be-10-minutes
>
> Kind Regards,
>
> Jonathan Sterling
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> attachments/20171019/d940fd4e/attachment-0001.html>
>
> ------------------------------
>
> Message: 2
> Date: Thu, 19 Oct 2017 15:41:51 +0200
> From: "=?UTF-8?Q?Ad=c3=a1n_S=c3=a1nchez_de_Pedro_Crespo?="
>         <adan at stampery.co>
> To: bitcoin-dev at lists.linuxfoundation.org
> Subject: Re: [bitcoin-dev] Improving Scalability via Block Time
>         Decrease
> Message-ID: <40b6ef7b-f518-38cd-899a-8f301bc7ac3a at stampery.com>
> Content-Type: text/plain; charset=utf-8
>
> Blockchains with fast confirmation times are currently believed to
> suffer from reduced security due to a high stale rate.
>
> As blocks take a certain time to propagate through the network, if miner
> A mines a block and then miner B happens to mine another block before
> miner A's block propagates to B, miner B's block will end up wasted and
> will not "contribute to network security".
>
> Furthermore, there is a centralization issue: if miner A is a mining
> pool with 30% hashpower and B has 10% hashpower, A will have a risk of
> producing a stale block 70% of the time (since the other 30% of the time
> A produced the last block and so will get mining data immediately)
> whereas B will have a risk of producing a stale block 90% of the time.
>
> Thus, if the block interval is short enough for the stale rate
> to be high, A will be substantially more efficient simply by virtue of
> its size. With these two effects combined, blockchains which produce
> blocks quickly are very likely to lead to one mining pool having a large
> enough percentage of the network hashpower to have de facto control over
> the mining process.
>
> Another possible implication of reducing the average block time is that
> block size should be reduced accordingly. In an hypothetical 5 minutes
> block size Bitcoin blockchain, there would be twice the block space
> available for miners to include transactions, which could lead to 2
> immediate consequences: (1) the blockchain could grow up to twice the
> rate, which is known to be bad for decentralization; and (2) transaction
> fees might go down, making it cheaper for spammers to bloat our beloved
> UTXO sets.
>
> There have been numerous proposals that tried to overcome the downsides
> of faster blocks, the most noteworthy probably being the "Greedy
> Heaviest Observed Subtree" (GHOST) protocol:
> http://www.cs.huji.ac.il/~yoni_sompo/pubs/15/btc_scalability_full.pdf
>
> Personally, I can't see why Bitcoin would need or how could it even
> benefit at all from faster blocks. Nevertheless, I would really love if
> someone in the list who has already run the numbers could bring some
> valid points on why 10 minutes is the optimal rate (other than "if it
> ain't broke, don't fix it").
>
> --
> Ad?n S?nchez de Pedro Crespo
> CTO, Stampery Inc.
> San Francisco - Madrid
>
>
> ------------------------------
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> End of bitcoin-dev Digest, Vol 29, Issue 24
> *******************************************
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171020/25f557c0/attachment.html>

From mark at friedenbach.org  Fri Oct 20 18:55:55 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Fri, 20 Oct 2017 20:55:55 +0200
Subject: [bitcoin-dev] bitcoin-dev Digest, Vol 29, Issue 24
In-Reply-To: <CALTsm7iy0Wh6e3SsE-OWj_+R=jhBGxXdhCaEMixzA_KD=TModw@mail.gmail.com>
References: <mailman.57.1508500809.30522.bitcoin-dev@lists.linuxfoundation.org>
	<CALTsm7iy0Wh6e3SsE-OWj_+R=jhBGxXdhCaEMixzA_KD=TModw@mail.gmail.com>
Message-ID: <0CA57198-C99E-4AFA-A67B-2DE29164D74C@friedenbach.org>

You could do that today, with one of the 3 interoperable Lightning implementations available. Lowering the block interval on the other hand comes with a large number of centralizing downsides documented elsewhere. And getting down to 1sec or less on a global network is simply impossible due to the speed of light. 

If you want point of sale support, I suggest looking into the excellent work the Lightning teams have done.

> On Oct 20, 2017, at 7:24 PM, Ilan Oh via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> The only blocktime reduction that would be a game changer, would be a 1 second blocktime or less, and by less I mean much less maybe 1000 blocks/second. Which would enable decentralized high frequency trading or playing WoW on blockchain and other cool stuff. 
> 
> But technology is not developped enough as far as I now, maybe with quantum computers in the future, and it is even bitcoins goal?
> 
> Also there is a guy who wrote a script to avoid "sybil attack" from 2x
> https://github.com/mariodian/ban-segshit8x-nodes
> 
> I don't know what it's worth, maybe check it out, I'm not huge support of that kind of methods.
> 
> Ilansky
> 
> 
> Le 20 oct. 2017 14:01, <bitcoin-dev-request at lists.linuxfoundation.org> a ?crit :
>> Send bitcoin-dev mailing list submissions to
>>         bitcoin-dev at lists.linuxfoundation.org
>> 
>> To subscribe or unsubscribe via the World Wide Web, visit
>>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> or, via email, send a message with subject or body 'help' to
>>         bitcoin-dev-request at lists.linuxfoundation.org
>> 
>> You can reach the person managing the list at
>>         bitcoin-dev-owner at lists.linuxfoundation.org
>> 
>> When replying, please edit your Subject line so it is more specific
>> than "Re: Contents of bitcoin-dev digest..."
>> 
>> 
>> Today's Topics:
>> 
>>    1. Improving Scalability via Block Time Decrease (Jonathan Sterling)
>>    2. Re: Improving Scalability via Block Time Decrease
>>       (=?UTF-8?Q?Ad=c3=a1n_S=c3=a1nchez_de_Pedro_Crespo?=)
>> 
>> 
>> ----------------------------------------------------------------------
>> 
>> Message: 1
>> Date: Thu, 19 Oct 2017 14:52:48 +0800
>> From: Jonathan Sterling <jon at thancodes.com>
>> To: bitcoin-dev at lists.linuxfoundation.org
>> Subject: [bitcoin-dev] Improving Scalability via Block Time Decrease
>> Message-ID:
>>         <CAH01uEtLhLEj5XOp_MDRii2dR8-zUu4fUsCd25mzLDtpD_fwYQ at mail.gmail.com>
>> Content-Type: text/plain; charset="utf-8"
>> 
>> The current ten-minute block time was chosen by Satoshi as a tradeoff
>> between confirmation time and the amount of work wasted due to chain
>> splits. Is there not room for optimization in this number from:
>> 
>> A. Advances in technology in the last 8-9 years
>> B. A lack of any rigorous formula being used to determine what's the
>> optimal rate
>> C. The existence of similar chains that work at a much lower block times
>> 
>> Whilst I think we can all agree that 10 second block times would result in
>> a lot of chain splits due to Bitcoins 12-13 second propagation time (to 95%
>> of nodes), I think we'll find that we can go lower than 10 minutes without
>> much issue. Is this something that should be looked at or am I an idiot who
>> needs to read more? If I'm an idiot, I apologize; kindly point me in the
>> right direction.
>> 
>> Things I've read on the subject:
>> https://medium.facilelogin.com/the-mystery-behind-block-time-63351e35603a
>> (section header "Why Bitcoin Block Time Is 10 Minutes ?")
>> https://bitcointalk.org/index.php?topic=176108.0
>> https://bitcoin.stackexchange.com/questions/1863/why-was-the-target-block-time-chosen-to-be-10-minutes
>> 
>> Kind Regards,
>> 
>> Jonathan Sterling
>> -------------- next part --------------
>> An HTML attachment was scrubbed...
>> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171019/d940fd4e/attachment-0001.html>
>> 
>> ------------------------------
>> 
>> Message: 2
>> Date: Thu, 19 Oct 2017 15:41:51 +0200
>> From: "=?UTF-8?Q?Ad=c3=a1n_S=c3=a1nchez_de_Pedro_Crespo?="
>>         <adan at stampery.co>
>> To: bitcoin-dev at lists.linuxfoundation.org
>> Subject: Re: [bitcoin-dev] Improving Scalability via Block Time
>>         Decrease
>> Message-ID: <40b6ef7b-f518-38cd-899a-8f301bc7ac3a at stampery.com>
>> Content-Type: text/plain; charset=utf-8
>> 
>> Blockchains with fast confirmation times are currently believed to
>> suffer from reduced security due to a high stale rate.
>> 
>> As blocks take a certain time to propagate through the network, if miner
>> A mines a block and then miner B happens to mine another block before
>> miner A's block propagates to B, miner B's block will end up wasted and
>> will not "contribute to network security".
>> 
>> Furthermore, there is a centralization issue: if miner A is a mining
>> pool with 30% hashpower and B has 10% hashpower, A will have a risk of
>> producing a stale block 70% of the time (since the other 30% of the time
>> A produced the last block and so will get mining data immediately)
>> whereas B will have a risk of producing a stale block 90% of the time.
>> 
>> Thus, if the block interval is short enough for the stale rate
>> to be high, A will be substantially more efficient simply by virtue of
>> its size. With these two effects combined, blockchains which produce
>> blocks quickly are very likely to lead to one mining pool having a large
>> enough percentage of the network hashpower to have de facto control over
>> the mining process.
>> 
>> Another possible implication of reducing the average block time is that
>> block size should be reduced accordingly. In an hypothetical 5 minutes
>> block size Bitcoin blockchain, there would be twice the block space
>> available for miners to include transactions, which could lead to 2
>> immediate consequences: (1) the blockchain could grow up to twice the
>> rate, which is known to be bad for decentralization; and (2) transaction
>> fees might go down, making it cheaper for spammers to bloat our beloved
>> UTXO sets.
>> 
>> There have been numerous proposals that tried to overcome the downsides
>> of faster blocks, the most noteworthy probably being the "Greedy
>> Heaviest Observed Subtree" (GHOST) protocol:
>> http://www.cs.huji.ac.il/~yoni_sompo/pubs/15/btc_scalability_full.pdf
>> 
>> Personally, I can't see why Bitcoin would need or how could it even
>> benefit at all from faster blocks. Nevertheless, I would really love if
>> someone in the list who has already run the numbers could bring some
>> valid points on why 10 minutes is the optimal rate (other than "if it
>> ain't broke, don't fix it").
>> 
>> --
>> Ad?n S?nchez de Pedro Crespo
>> CTO, Stampery Inc.
>> San Francisco - Madrid
>> 
>> 
>> ------------------------------
>> 
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> 
>> 
>> End of bitcoin-dev Digest, Vol 29, Issue 24
>> *******************************************
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171020/065c4aa9/attachment-0001.html>

From zertsekel at gmail.com  Sun Oct 22 17:11:09 2017
From: zertsekel at gmail.com (Kosta Zertsekel)
Date: Sun, 22 Oct 2017 17:11:09 +0000
Subject: [bitcoin-dev] Bitcoin Core build system (automake vs cmake)
Message-ID: <CADxo8WLrKxkUHpQSYb-Yoq0Nzv9QP=k5qBmS2wiqhp0P8=rSMA@mail.gmail.com>

Hi guys,

I wonder why automake has become the build system for Bitcoin Core?
I mean - why not cmake which is considered better?
Can you please point to the relevant discussion or explanation?

Thanks,
--- Kosta Z.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171022/adc0c0f3/attachment.html>

From zertsekel at gmail.com  Mon Oct 23 11:52:04 2017
From: zertsekel at gmail.com (Kosta Zertsekel)
Date: Mon, 23 Oct 2017 04:52:04 -0700
Subject: [bitcoin-dev] Bitcoin Core build system (automake vs cmake)
In-Reply-To: <FB8D6509-5C2E-4F4F-9D7F-6CFB90591FB0@eeqj.com>
References: <CADxo8WLrKxkUHpQSYb-Yoq0Nzv9QP=k5qBmS2wiqhp0P8=rSMA@mail.gmail.com>
	<FB8D6509-5C2E-4F4F-9D7F-6CFB90591FB0@eeqj.com>
Message-ID: <CADxo8WLk_Ttaa3-jXQXaCJ3E+tKH9J7uUFAN_pfvtWOx_77cAA@mail.gmail.com>

>> On Oct 22, 2017, at 13:11, Kosta Zertsekel wrote:
>> I wonder why automake has become the build system for Bitcoin Core?
>> I mean - why not cmake which is considered better?
>> Can you please point to the relevant discussion or explanation?

> On Mon, Oct 23, 2017 at 6:24 AM, Jeffrey Paul <jp at eeqj.com> wrote:
> Considered by whom? Automake is the standard and I prefer it as it
requires
> no additional install on most systems. For that, I consider it better.

Well, here are some quotes about CMake build tools...

JetBrains (2014)
================
Our brief research showed that CMake and ?make? were the most popular
cross-platform tools, having ~30% of users each, while both Autotools
and qmake had less than 7% of users. So we ended up with CMake and make.
[https://blog.jetbrains.com/clion/2014/09/cmake-vs-the-others-round-1/]

KDE Project (2006)
==================
Now the next big change is happening: KDE is leaving the aging "autotool"
build chain behind. Some developers, not only in KDE, like to nickname
the autotools as "auto-hell" because of its difficult to comprehend
architecture. So, KDE 4 will feature a completely different build system:
CMake.
[https://lwn.net/Articles/188693/]

Also, there are more advanced build systems:
============================================
 - Meson [http://mesonbuild.com]
 - Ninja [https://ninja-build.org/]

All of them (CMake, Meson, Ninja) had a goal to replace automake.
Was there any discussion about choosing the best build system for
Bitcoin Core?

Thanks,
--- Kosta Z.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171023/b9f4437e/attachment.html>

From dermoth at aei.ca  Tue Oct 24 15:25:19 2017
From: dermoth at aei.ca (Thomas Guyot-Sionnest)
Date: Tue, 24 Oct 2017 11:25:19 -0400
Subject: [bitcoin-dev] Bitcoin Core build system (automake vs cmake)
In-Reply-To: <CADxo8WLk_Ttaa3-jXQXaCJ3E+tKH9J7uUFAN_pfvtWOx_77cAA@mail.gmail.com>
References: <CADxo8WLrKxkUHpQSYb-Yoq0Nzv9QP=k5qBmS2wiqhp0P8=rSMA@mail.gmail.com>
	<FB8D6509-5C2E-4F4F-9D7F-6CFB90591FB0@eeqj.com>
	<CADxo8WLk_Ttaa3-jXQXaCJ3E+tKH9J7uUFAN_pfvtWOx_77cAA@mail.gmail.com>
Message-ID: <20470035-2199-d822-f97a-11611a71f490@aei.ca>

On 23/10/17 07:52 AM, Kosta Zertsekel via bitcoin-dev wrote:
> >> On Oct 22, 2017, at 13:11, Kosta Zertsekel wrote:
> >> I wonder why automake has become the build system for Bitcoin Core?
> >> I mean - why not cmake which is considered better?
> >> Can you please point to the relevant discussion or explanation?
>
> > On Mon, Oct 23, 2017 at 6:24 AM, Jeffrey Paul <jp at eeqj.com
> <mailto:jp at eeqj.com>> wrote:
> > Considered by whom? Automake is the standard and I prefer it as it
> requires
> > no additional install on most systems. For that, I consider it better.
>
> Well, here are some quotes about CMake build tools...
>
> [...]
>
> All of them (CMake, Meson, Ninja) had a goal to replace automake.
> Was there any discussion about choosing the best build system for
> Bitcoin Core?

What exact problem are you trying to fix for bitcoin-core?

Each build system have their pros and cons, and what you need it the
right tool for the job. Unless there is a specific problem to solve and
that cmake can solve it without causing other issues, why would you want
to change?

Or better yet, convert yourself bitcoin-core to cmake and show the
developers that it makes build config simpler without scarifying
features (cross-platform builds, gitian...) then maybe they'll adopt it.

Regards,

-- 
Thomas



From mark at friedenbach.org  Sat Oct 28 04:40:01 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Fri, 27 Oct 2017 21:40:01 -0700
Subject: [bitcoin-dev] Merkle branch verification & tail-call semantics
 for generalized MAST
In-Reply-To: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
References: <5B6756D0-6BEF-4A01-BDB8-52C646916E29@friedenbach.org>
Message-ID: <3FE16880-868C-40BA-BCC5-954B15478FB2@friedenbach.org>

I have completed updating the three BIPs with all the feedback that I have received so far. In short summary, here is an incomplete list of the changes that were made:

* Modified the hashing function fast-SHA256 so that an internal node cannot be interpreted simultaneously as a leaf.
* Changed MERKLEBRANCHVERIFY to verify a configurable number of elements from the tree, instead of just one.
* Changed MERKLEBRANCHVERIFY to have two modes: one where the inputs are assumed to be hashes, and one where they are run through double-SHA256 first.
* Made tail-call eval compatible with BIP141?s CLEANSTACK consensus rule by allowing parameters to be passed on the alt-stack.
* Restricted tail-call eval to segwit scripts only, so that checking sigop and opcode limits of the policy script would not be necessary.

There were a bunch of other small modifications, typo fixes, and optimizations that were made as well.

I am now ready to submit these BIPs as a PR against the bitcoin/bips repo, and I request that the BIP editor assign numbers.

Thank you,
Mark Friedenbach

> On Sep 6, 2017, at 5:38 PM, Mark Friedenbach <mark at friedenbach.org> wrote:
> 
> I would like to propose two new script features to be added to the
> bitcoin protocol by means of soft-fork activation. These features are
> a new opcode, MERKLE-BRANCH-VERIFY (MBV) and tail-call execution
> semantics.
> 
> In brief summary, MERKLE-BRANCH-VERIFY allows script authors to force
> redemption to use values selected from a pre-determined set committed
> to in the scriptPubKey, but without requiring revelation of unused
> elements in the set for both enhanced privacy and smaller script
> sizes. Tail-call execution semantics allows a single level of
> recursion into a subscript, providing properties similar to P2SH while
> at the same time more flexible.
> 
> These two features together are enough to enable a range of
> applications such as tree signatures (minus Schnorr aggregation) as
> described by Pieter Wuille [1], and a generalized MAST useful for
> constructing private smart contracts. It also brings privacy and
> fungibility improvements to users of counter-signing wallet/vault
> services as unique redemption policies need only be revealed if/when
> exceptional circumstances demand it, leaving most transactions looking
> the same as any other MAST-enabled multi-sig script.
> 
> I believe that the implementation of these features is simple enough,
> and the use cases compelling enough that we could BIP 8/9 rollout of
> these features in relatively short order, perhaps before the end of
> the year.
> 
> I have written three BIPs to describe these features, and their
> associated implementation, for which I now invite public review and
> discussion:
> 
> Fast Merkle Trees
> BIP: https://gist.github.com/maaku/41b0054de0731321d23e9da90ba4ee0a
> Code: https://github.com/maaku/bitcoin/tree/fast-merkle-tree
> 
> MERKLEBRANCHVERIFY
> BIP: https://gist.github.com/maaku/bcf63a208880bbf8135e453994c0e431
> Code: https://github.com/maaku/bitcoin/tree/merkle-branch-verify
> 
> Tail-call execution semantics
> BIP: https://gist.github.com/maaku/f7b2e710c53f601279549aa74eeb5368
> Code: https://github.com/maaku/bitcoin/tree/tail-call-semantics
> 
> Note: I have circulated this idea privately among a few people, and I
> will note that there is one piece of feedback which I agree with but
> is not incorporated yet: there should be a multi-element MBV opcode
> that allows verifying multiple items are extracted from a single
> tree. It is not obvious how MBV could be modified to support this
> without sacrificing important properties, or whether should be a
> separate multi-MBV opcode instead.
> 
> Kind regards,
> Mark Friedenbach


From shiva at blockonomics.co  Mon Oct 30 08:56:40 2017
From: shiva at blockonomics.co (shiva sitamraju)
Date: Mon, 30 Oct 2017 14:26:40 +0530
Subject: [bitcoin-dev] Visually Differentiable - Bitcoin Addresses
Message-ID: <CABuOfujV1gAaSOKBB7S0_JKuwp+3iNhY5kN59F3LLndPENUA_Q@mail.gmail.com>

Hi,

When I copy and paste bitcoin address, I double check the first few bytes,
to make sure I copied the correct one. This is to make sure some rogue
software is not changing the address, or I incorrectly pasted the wrong
address.


With Bech32 address, its seems like in this department we are taking as
step in the backward direction. With the traditional address, I could
compare first few bytes like 1Ko or 1L3. With bech32, bc1. is all I can see
and compare which is likely to be same anyway. Note that most users will
only compare the first few bytes only (since addresses themselves are very
long and will overflow in a mobile text box).

Is there anyway to make the Bech32 addresses format more visually distinct
(atleast the first few bytes) ?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171030/66bd249b/attachment.html>

From thompson.benedictjames at gmail.com  Mon Oct 30 12:49:18 2017
From: thompson.benedictjames at gmail.com (Ben Thompson)
Date: Mon, 30 Oct 2017 12:49:18 +0000
Subject: [bitcoin-dev] Visually Differentiable - Bitcoin Addresses
In-Reply-To: <CABuOfujV1gAaSOKBB7S0_JKuwp+3iNhY5kN59F3LLndPENUA_Q@mail.gmail.com>
References: <CABuOfujV1gAaSOKBB7S0_JKuwp+3iNhY5kN59F3LLndPENUA_Q@mail.gmail.com>
Message-ID: <CAOxie=En8EqfuEtaPxH_v-2SYfUunudb4Zu0MQ-ZfEiPMxa6AQ@mail.gmail.com>

Checking the first few bytes of a Bitcoin Address should not be considered
sufficient for ensuring that it is correct as it takes less than a second
to generate a 3 character vanity address that matches the first 3
characters of an address.

On Mon, 30 Oct 2017, 11:44 shiva sitamraju via bitcoin-dev, <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi,
>
> When I copy and paste bitcoin address, I double check the first few bytes,
> to make sure I copied the correct one. This is to make sure some rogue
> software is not changing the address, or I incorrectly pasted the wrong
> address.
>
>
> With Bech32 address, its seems like in this department we are taking as
> step in the backward direction. With the traditional address, I could
> compare first few bytes like 1Ko or 1L3. With bech32, bc1. is all I can see
> and compare which is likely to be same anyway. Note that most users will
> only compare the first few bytes only (since addresses themselves are very
> long and will overflow in a mobile text box).
>
> Is there anyway to make the Bech32 addresses format more visually distinct
> (atleast the first few bytes) ?
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171030/f3848a6e/attachment.html>

From ricardojdfilipe at gmail.com  Mon Oct 30 12:14:42 2017
From: ricardojdfilipe at gmail.com (Ricardo Filipe)
Date: Mon, 30 Oct 2017 12:14:42 +0000
Subject: [bitcoin-dev] Visually Differentiable - Bitcoin Addresses
In-Reply-To: <CABuOfujV1gAaSOKBB7S0_JKuwp+3iNhY5kN59F3LLndPENUA_Q@mail.gmail.com>
References: <CABuOfujV1gAaSOKBB7S0_JKuwp+3iNhY5kN59F3LLndPENUA_Q@mail.gmail.com>
Message-ID: <CALC81CMgpzdeiD=T3yQazn5eAT7Nym4-t1bwGh1TD7rfuDT7EA@mail.gmail.com>

start double checking the last few bytes instead?

2017-10-30 8:56 GMT+00:00 shiva sitamraju via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org>:
> Hi,
>
> When I copy and paste bitcoin address, I double check the first few bytes,
> to make sure I copied the correct one. This is to make sure some rogue
> software is not changing the address, or I incorrectly pasted the wrong
> address.
>
>
> With Bech32 address, its seems like in this department we are taking as step
> in the backward direction. With the traditional address, I could compare
> first few bytes like 1Ko or 1L3. With bech32, bc1. is all I can see and
> compare which is likely to be same anyway. Note that most users will only
> compare the first few bytes only (since addresses themselves are very long
> and will overflow in a mobile text box).
>
> Is there anyway to make the Bech32 addresses format more visually distinct
> (atleast the first few bytes) ?
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From shiva at blockonomics.co  Mon Oct 30 13:13:56 2017
From: shiva at blockonomics.co (shiva sitamraju)
Date: Mon, 30 Oct 2017 18:43:56 +0530
Subject: [bitcoin-dev] Visually Differentiable - Bitcoin Addresses
In-Reply-To: <CAOxie=En8EqfuEtaPxH_v-2SYfUunudb4Zu0MQ-ZfEiPMxa6AQ@mail.gmail.com>
References: <CABuOfujV1gAaSOKBB7S0_JKuwp+3iNhY5kN59F3LLndPENUA_Q@mail.gmail.com>
	<CAOxie=En8EqfuEtaPxH_v-2SYfUunudb4Zu0MQ-ZfEiPMxa6AQ@mail.gmail.com>
Message-ID: <CABuOfui=G_iSaKdeVZ=M_udg-DoqAVxCrHOZaHuSJze4+N7CLw@mail.gmail.com>

For example bc1qeklep85ntjz4605drds6aww9u0qr46qzrv5xswd35uhjuj8ahfcqgf6hak
in 461e8a4aa0a0e75c06602c505bd7aa06e7116ba5cd98fd6e046e8cbeb00379d6 is 62
bytes ! This is very very long. This will create lot of usability problems
in

- Blockexplorers (atleast user should be visually able to compare in a
transaction having multiple outputs which one his address)
- Mobiles
- Payment terminals

>From my limited understanding, the purpose of inventing a bitcoin address
format is for usability and ease of identification (versus a ECDSA public
key), While I get the error/checksum capabilities Bech32 brings, any user
would prefer a 20 byte address with a checksum  over an address that would
wrap several lines !!


On Mon, Oct 30, 2017 at 6:19 PM, Ben Thompson <
thompson.benedictjames at gmail.com> wrote:

> Checking the first few bytes of a Bitcoin Address should not be considered
> sufficient for ensuring that it is correct as it takes less than a second
> to generate a 3 character vanity address that matches the first 3
> characters of an address.
>
> On Mon, 30 Oct 2017, 11:44 shiva sitamraju via bitcoin-dev, <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Hi,
>>
>> When I copy and paste bitcoin address, I double check the first few
>> bytes, to make sure I copied the correct one. This is to make sure some
>> rogue software is not changing the address, or I incorrectly pasted the
>> wrong address.
>>
>>
>> With Bech32 address, its seems like in this department we are taking as
>> step in the backward direction. With the traditional address, I could
>> compare first few bytes like 1Ko or 1L3. With bech32, bc1. is all I can see
>> and compare which is likely to be same anyway. Note that most users will
>> only compare the first few bytes only (since addresses themselves are very
>> long and will overflow in a mobile text box).
>>
>> Is there anyway to make the Bech32 addresses format more visually
>> distinct (atleast the first few bytes) ?
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171030/ae11b543/attachment.html>

From pieter.wuille at gmail.com  Mon Oct 30 14:26:29 2017
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Mon, 30 Oct 2017 07:26:29 -0700
Subject: [bitcoin-dev] Visually Differentiable - Bitcoin Addresses
In-Reply-To: <CABuOfui=G_iSaKdeVZ=M_udg-DoqAVxCrHOZaHuSJze4+N7CLw@mail.gmail.com>
References: <CABuOfujV1gAaSOKBB7S0_JKuwp+3iNhY5kN59F3LLndPENUA_Q@mail.gmail.com>
	<CAOxie=En8EqfuEtaPxH_v-2SYfUunudb4Zu0MQ-ZfEiPMxa6AQ@mail.gmail.com>
	<CABuOfui=G_iSaKdeVZ=M_udg-DoqAVxCrHOZaHuSJze4+N7CLw@mail.gmail.com>
Message-ID: <CAPg+sBiZGwQup0QRWVnBoHyR5Fx5tB6CtYgX7P=MM1-etm57Ww@mail.gmail.com>

On Oct 30, 2017 15:21, "shiva sitamraju via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

For example bc1qeklep85ntjz4605drds6aww9u0qr46qzrv5xswd35uhjuj8ahfcqgf6hak
in 461e8a4aa0a0e75c06602c505bd7aa06e7116ba5cd98fd6e046e8cbeb00379d6 is 62
bytes !


...

While I get the error/checksum capabilities Bech32 brings, any user would
prefer a 20 byte address with a checksum  over an address that would wrap
several lines !!


That's an unfair comparison. You're pasting a P2WSH address which contains
a 256-bit hash.

A P2WPKH address (which only contains a 160-bit hash, just like P2PKH and
P2SH) in Bech32 is only 42 characters, not 62.

Cheers,

-- 
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171030/00d5cdc5/attachment.html>

From thompson.benedictjames at gmail.com  Mon Oct 30 14:23:51 2017
From: thompson.benedictjames at gmail.com (Ben Thompson)
Date: Mon, 30 Oct 2017 14:23:51 +0000
Subject: [bitcoin-dev] Visually Differentiable - Bitcoin Addresses
In-Reply-To: <CALC81CMgpzdeiD=T3yQazn5eAT7Nym4-t1bwGh1TD7rfuDT7EA@mail.gmail.com>
References: <CABuOfujV1gAaSOKBB7S0_JKuwp+3iNhY5kN59F3LLndPENUA_Q@mail.gmail.com>
	<CALC81CMgpzdeiD=T3yQazn5eAT7Nym4-t1bwGh1TD7rfuDT7EA@mail.gmail.com>
Message-ID: <CAOxie=FmcyAgThXT4pN802KF-0-gd-dE84xoARB=yZH=1+FdKA@mail.gmail.com>

The last few bytes can be generated to be the same also.

On Mon, 30 Oct 2017, 14:20 Ricardo Filipe via bitcoin-dev, <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> start double checking the last few bytes instead?
>
> 2017-10-30 8:56 GMT+00:00 shiva sitamraju via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org>:
> > Hi,
> >
> > When I copy and paste bitcoin address, I double check the first few
> bytes,
> > to make sure I copied the correct one. This is to make sure some rogue
> > software is not changing the address, or I incorrectly pasted the wrong
> > address.
> >
> >
> > With Bech32 address, its seems like in this department we are taking as
> step
> > in the backward direction. With the traditional address, I could compare
> > first few bytes like 1Ko or 1L3. With bech32, bc1. is all I can see and
> > compare which is likely to be same anyway. Note that most users will only
> > compare the first few bytes only (since addresses themselves are very
> long
> > and will overflow in a mobile text box).
> >
> > Is there anyway to make the Bech32 addresses format more visually
> distinct
> > (atleast the first few bytes) ?
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171030/d84f94d4/attachment-0001.html>

From ethan.scruples at gmail.com  Mon Oct 30 14:39:07 2017
From: ethan.scruples at gmail.com (Moral Agent)
Date: Mon, 30 Oct 2017 10:39:07 -0400
Subject: [bitcoin-dev] Visually Differentiable - Bitcoin Addresses
In-Reply-To: <CABuOfui=G_iSaKdeVZ=M_udg-DoqAVxCrHOZaHuSJze4+N7CLw@mail.gmail.com>
References: <CABuOfujV1gAaSOKBB7S0_JKuwp+3iNhY5kN59F3LLndPENUA_Q@mail.gmail.com>
	<CAOxie=En8EqfuEtaPxH_v-2SYfUunudb4Zu0MQ-ZfEiPMxa6AQ@mail.gmail.com>
	<CABuOfui=G_iSaKdeVZ=M_udg-DoqAVxCrHOZaHuSJze4+N7CLw@mail.gmail.com>
Message-ID: <CACiOHGxYuqCONJzVm=zD2qkS4BR+Pvm9Ccofh_SCH-uzmW-LwA@mail.gmail.com>

If you are going to rely on human verification of addresses, the best way
might be map it to words.

For example, with a 6000 word list, a 25 byte address (with a checksum)
could be mapped to 16 words like this:

vocally           acquire        removed     unfounded
euphemism    sanctuary    sectional     driving
entree            freckles    aloof           vertebrae
scribble          surround      prelaw         effort

In my opinion, that is much faster to verify than this:

13gQFTYHuAcfnZjXo2NFsy1E8JGSLwXHCZ

or

bc1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3qccfmv3

Although I really do love Bech32.

On Mon, Oct 30, 2017 at 9:13 AM, shiva sitamraju via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> For example bc1qeklep85ntjz4605drds6aww9u0qr46qzrv5xswd35uhjuj8ahfcqgf6hak
> in 461e8a4aa0a0e75c06602c505bd7aa06e7116ba5cd98fd6e046e8cbeb00379d6 is 62
> bytes ! This is very very long. This will create lot of usability problems
> in
>
> - Blockexplorers (atleast user should be visually able to compare in a
> transaction having multiple outputs which one his address)
> - Mobiles
> - Payment terminals
>
> From my limited understanding, the purpose of inventing a bitcoin address
> format is for usability and ease of identification (versus a ECDSA public
> key), While I get the error/checksum capabilities Bech32 brings, any user
> would prefer a 20 byte address with a checksum  over an address that would
> wrap several lines !!
>
>
> On Mon, Oct 30, 2017 at 6:19 PM, Ben Thompson <
> thompson.benedictjames at gmail.com> wrote:
>
>> Checking the first few bytes of a Bitcoin Address should not be
>> considered sufficient for ensuring that it is correct as it takes less than
>> a second to generate a 3 character vanity address that matches the first 3
>> characters of an address.
>>
>> On Mon, 30 Oct 2017, 11:44 shiva sitamraju via bitcoin-dev, <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> Hi,
>>>
>>> When I copy and paste bitcoin address, I double check the first few
>>> bytes, to make sure I copied the correct one. This is to make sure some
>>> rogue software is not changing the address, or I incorrectly pasted the
>>> wrong address.
>>>
>>>
>>> With Bech32 address, its seems like in this department we are taking as
>>> step in the backward direction. With the traditional address, I could
>>> compare first few bytes like 1Ko or 1L3. With bech32, bc1. is all I can see
>>> and compare which is likely to be same anyway. Note that most users will
>>> only compare the first few bytes only (since addresses themselves are very
>>> long and will overflow in a mobile text box).
>>>
>>> Is there anyway to make the Bech32 addresses format more visually
>>> distinct (atleast the first few bytes) ?
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171030/612c7b18/attachment.html>

From roconnor at blockstream.io  Mon Oct 30 15:22:20 2017
From: roconnor at blockstream.io (Russell O'Connor)
Date: Mon, 30 Oct 2017 11:22:20 -0400
Subject: [bitcoin-dev] Simplicity: An alternative to Script
Message-ID: <CAMZUoK=VNRMda8oRCtxniE6-vLwG-b=je2Hx+sD9sCzS--v9kQ@mail.gmail.com>

I've been working on the design and implementation of an alternative to
Bitcoin Script, which I call Simplicity.  Today, I am presenting my design
at the PLAS 2017 Workshop <http://plas2017.cse.buffalo.edu/> on Programming
Languages and Analysis for Security.  You find a copy of my Simplicity
paper at https://blockstream.com/simplicity.pdf

Simplicity is a low-level, typed, functional, native MAST language where
programs are built from basic combinators.  Like Bitcoin Script, Simplicity
is designed to operate at the consensus layer.  While one can write
Simplicity by hand, it is expected to be the target of one, or multiple,
front-end languages.

Simplicity comes with formal denotational semantics (i.e. semantics of what
programs compute) and formal operational semantics (i.e. semantics of how
programs compute). These are both formalized in the Coq proof assistant and
proven equivalent.

Formal denotational semantics are of limited value unless one can use them
in practice to reason about programs. I've used Simplicity's formal
semantics to prove correct an implementation of the SHA-256 compression
function written in Simplicity.  I have also implemented a variant of ECDSA
signature verification in Simplicity, and plan to formally validate its
correctness along with the associated elliptic curve operations.

Simplicity comes with easy to compute static analyses that can compute
bounds on the space and time resources needed for evaluation.  This is
important for both node operators, so that the costs are knows before
evaluation, and for designing Simplicity programs, so that smart-contract
participants can know the costs of their contract before committing to it.

As a native MAST language, unused branches of Simplicity programs are
pruned at redemption time.  This enhances privacy, reduces the block weight
used, and can reduce space and time resource costs needed for evaluation.

To make Simplicity practical, jets replace common Simplicity expressions
(identified by their MAST root) and directly implement them with C code.  I
anticipate developing a broad set of useful jets covering arithmetic
operations, elliptic curve operations, and cryptographic operations
including hashing and digital signature validation.

The paper I am presenting at PLAS describes only the foundation of the
Simplicity language.  The final design includes extensions not covered in
the paper, including

- full convent support, allowing access to all transaction data.
- support for signature aggregation.
- support for delegation.

Simplicity is still in a research and development phase.  I'm working to
produce a bare-bones SDK that will include

- the formal semantics and correctness proofs in Coq
- a Haskell implementation for constructing Simplicity programs
- and a C interpreter for Simplicity.

After an SDK is complete the next step will be making Simplicity available
in the Elements project <https://elementsproject.org/> so that anyone can
start experimenting with Simplicity in sidechains. Only after extensive
vetting would it be suitable to consider Simplicity for inclusion in
Bitcoin.

Simplicity has a long ways to go still, and this work is not intended to
delay consideration of the various Merkelized Script proposals that are
currently ongoing.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171030/d8a6f806/attachment.html>

From mark at friedenbach.org  Mon Oct 30 15:31:22 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Mon, 30 Oct 2017 08:31:22 -0700
Subject: [bitcoin-dev] Simplicity: An alternative to Script
In-Reply-To: <CAMZUoK=VNRMda8oRCtxniE6-vLwG-b=je2Hx+sD9sCzS--v9kQ@mail.gmail.com>
References: <CAMZUoK=VNRMda8oRCtxniE6-vLwG-b=je2Hx+sD9sCzS--v9kQ@mail.gmail.com>
Message-ID: <E5CEEE3C-C557-43FC-82C8-9E203EAB0266@friedenbach.org>

So enthused that this is public now! Great work. 

Sent from my iPhone

> On Oct 30, 2017, at 8:22 AM, Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> I've been working on the design and implementation of an alternative to Bitcoin Script, which I call Simplicity.  Today, I am presenting my design at the PLAS 2017 Workshop on Programming Languages and Analysis for Security.  You find a copy of my Simplicity paper at https://blockstream.com/simplicity.pdf
> 
> Simplicity is a low-level, typed, functional, native MAST language where programs are built from basic combinators.  Like Bitcoin Script, Simplicity is designed to operate at the consensus layer.  While one can write Simplicity by hand, it is expected to be the target of one, or multiple, front-end languages.
> 
> Simplicity comes with formal denotational semantics (i.e. semantics of what programs compute) and formal operational semantics (i.e. semantics of how programs compute). These are both formalized in the Coq proof assistant and proven equivalent.
> 
> Formal denotational semantics are of limited value unless one can use them in practice to reason about programs. I've used Simplicity's formal semantics to prove correct an implementation of the SHA-256 compression function written in Simplicity.  I have also implemented a variant of ECDSA signature verification in Simplicity, and plan to formally validate its correctness along with the associated elliptic curve operations.
> 
> Simplicity comes with easy to compute static analyses that can compute bounds on  the space and time resources needed for evaluation.  This is important for both node operators, so that the costs are knows before evaluation, and for designing Simplicity programs, so that smart-contract  participants can know the costs of their contract before committing to it.
> 
> As a native MAST language, unused branches of Simplicity programs are pruned at redemption time.  This enhances privacy, reduces the block weight used, and can reduce space and time resource costs needed for evaluation.
> 
> To make Simplicity practical, jets replace common Simplicity expressions (identified by their MAST root) and directly implement them with C code.  I anticipate developing a broad set of useful jets covering arithmetic operations, elliptic curve operations, and cryptographic operations including hashing and digital signature validation.
> 
> The paper I am presenting at PLAS describes only the foundation of the Simplicity language.  The final design includes extensions not covered in the paper, including
> 
> - full convent support, allowing access to all transaction data.
> - support for signature aggregation.
> - support for delegation.
> 
> Simplicity is still in a research and development phase.  I'm working to produce a bare-bones SDK that will include 
> 
> - the formal semantics and correctness proofs in Coq
> - a Haskell implementation for constructing Simplicity programs
> - and a C interpreter for Simplicity.
> 
> After an SDK is complete the next step will be making Simplicity available in the Elements project so that anyone can start experimenting with Simplicity in sidechains. Only after extensive vetting would it be suitable to consider Simplicity for inclusion in Bitcoin.
> 
> Simplicity has a long ways to go still, and this work is not intended to delay consideration of the various Merkelized Script proposals that are currently ongoing.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171030/8d986d48/attachment-0001.html>

From danny.thorpe at gmail.com  Mon Oct 30 16:15:45 2017
From: danny.thorpe at gmail.com (Danny Thorpe)
Date: Mon, 30 Oct 2017 09:15:45 -0700
Subject: [bitcoin-dev] Visually Differentiable - Bitcoin Addresses
In-Reply-To: <CACiOHGxYuqCONJzVm=zD2qkS4BR+Pvm9Ccofh_SCH-uzmW-LwA@mail.gmail.com>
References: <CABuOfujV1gAaSOKBB7S0_JKuwp+3iNhY5kN59F3LLndPENUA_Q@mail.gmail.com>
	<CAOxie=En8EqfuEtaPxH_v-2SYfUunudb4Zu0MQ-ZfEiPMxa6AQ@mail.gmail.com>
	<CABuOfui=G_iSaKdeVZ=M_udg-DoqAVxCrHOZaHuSJze4+N7CLw@mail.gmail.com>
	<CACiOHGxYuqCONJzVm=zD2qkS4BR+Pvm9Ccofh_SCH-uzmW-LwA@mail.gmail.com>
Message-ID: <CAJN5wHW=ySsCxR237TAzXyqXf1VixsA2T7qCA8FCS12PPabU+Q@mail.gmail.com>

Humans are very visually oriented, recognizing differences in images more
easily than differences in text.

What about generating an image based on the bytes of an address, using
something like identicon, used by gravatar? Any small change to the text
input produces a significantly different image.

-Danny

On Oct 30, 2017 7:43 AM, "Moral Agent via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> If you are going to rely on human verification of addresses, the best way
> might be map it to words.
>
> For example, with a 6000 word list, a 25 byte address (with a checksum)
> could be mapped to 16 words like this:
>
> vocally           acquire        removed     unfounded
> euphemism    sanctuary    sectional     driving
> entree            freckles    aloof           vertebrae
> scribble          surround      prelaw         effort
>
> In my opinion, that is much faster to verify than this:
>
> 13gQFTYHuAcfnZjXo2NFsy1E8JGSLwXHCZ
>
> or
>
> bc1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3qccfmv3
>
> Although I really do love Bech32.
>
> On Mon, Oct 30, 2017 at 9:13 AM, shiva sitamraju via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> For example bc1qeklep85ntjz4605drds6aww9u0qr46qzrv5xswd35uhjuj8ahfcqgf6hak
>> in 461e8a4aa0a0e75c06602c505bd7aa06e7116ba5cd98fd6e046e8cbeb00379d6 is
>> 62 bytes ! This is very very long. This will create lot of usability
>> problems in
>>
>> - Blockexplorers (atleast user should be visually able to compare in a
>> transaction having multiple outputs which one his address)
>> - Mobiles
>> - Payment terminals
>>
>> From my limited understanding, the purpose of inventing a bitcoin address
>> format is for usability and ease of identification (versus a ECDSA public
>> key), While I get the error/checksum capabilities Bech32 brings, any user
>> would prefer a 20 byte address with a checksum  over an address that would
>> wrap several lines !!
>>
>>
>> On Mon, Oct 30, 2017 at 6:19 PM, Ben Thompson <
>> thompson.benedictjames at gmail.com> wrote:
>>
>>> Checking the first few bytes of a Bitcoin Address should not be
>>> considered sufficient for ensuring that it is correct as it takes less than
>>> a second to generate a 3 character vanity address that matches the first 3
>>> characters of an address.
>>>
>>> On Mon, 30 Oct 2017, 11:44 shiva sitamraju via bitcoin-dev, <
>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>>> Hi,
>>>>
>>>> When I copy and paste bitcoin address, I double check the first few
>>>> bytes, to make sure I copied the correct one. This is to make sure some
>>>> rogue software is not changing the address, or I incorrectly pasted the
>>>> wrong address.
>>>>
>>>>
>>>> With Bech32 address, its seems like in this department we are taking as
>>>> step in the backward direction. With the traditional address, I could
>>>> compare first few bytes like 1Ko or 1L3. With bech32, bc1. is all I can see
>>>> and compare which is likely to be same anyway. Note that most users will
>>>> only compare the first few bytes only (since addresses themselves are very
>>>> long and will overflow in a mobile text box).
>>>>
>>>> Is there anyway to make the Bech32 addresses format more visually
>>>> distinct (atleast the first few bytes) ?
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>
>>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171030/ec4752a9/attachment.html>

From ethan.scruples at gmail.com  Mon Oct 30 16:48:09 2017
From: ethan.scruples at gmail.com (Moral Agent)
Date: Mon, 30 Oct 2017 12:48:09 -0400
Subject: [bitcoin-dev] Visually Differentiable - Bitcoin Addresses
In-Reply-To: <CAJN5wHW=ySsCxR237TAzXyqXf1VixsA2T7qCA8FCS12PPabU+Q@mail.gmail.com>
References: <CABuOfujV1gAaSOKBB7S0_JKuwp+3iNhY5kN59F3LLndPENUA_Q@mail.gmail.com>
	<CAOxie=En8EqfuEtaPxH_v-2SYfUunudb4Zu0MQ-ZfEiPMxa6AQ@mail.gmail.com>
	<CABuOfui=G_iSaKdeVZ=M_udg-DoqAVxCrHOZaHuSJze4+N7CLw@mail.gmail.com>
	<CACiOHGxYuqCONJzVm=zD2qkS4BR+Pvm9Ccofh_SCH-uzmW-LwA@mail.gmail.com>
	<CAJN5wHW=ySsCxR237TAzXyqXf1VixsA2T7qCA8FCS12PPabU+Q@mail.gmail.com>
Message-ID: <CACiOHGz+Knj9LNHfNs4KKgMzb-KyRrDV-6ZWAskiz4Ab2sdTyg@mail.gmail.com>

Or like keyart:
https://pthree.org/2014/04/18/the-drunken-bishop-for-openpgp-keys/

Images would definitely be quicker to verify by a human, but I don't think
humans can RELIABLY verify anything close to 25 bytes through an image.

Our visual processing system is designed wrong for this purpose, since it
subconsciously "corrects" visual input to whatever we expect to see.

It isn't enough to say that any small change produces a "significantly"
different image. What you need is for it to be (practically) impossible to
construct an image that looks similar but is wrong, which is a far higher
standard. For example, any change to a private key renders a significantly
different address -- but it is possible for an attacker to grind their way
to a similar-looking address.

I would recommend displaying 16 words in a 4 x 4 grid, but otherwise with
no visual distractions.

For example, don't provide an image next to the words as a help. Don't use
colors to differentiate two different sets of 16 words. What will happen is
people will see a pattern that triggers a sensation of familiarity, and
they will not carefully verify all of the words -- which is what security
requires.

For higher security keys, you could grind an address with enough zeros at
the beginning to be expressed by fewer words. For example, you could grind
to an address that could be fully expressed with a 12 word (4 x 3) grid
that would be easier for a human to verify reliably.

On Mon, Oct 30, 2017 at 12:15 PM, Danny Thorpe <danny.thorpe at gmail.com>
wrote:

> Humans are very visually oriented, recognizing differences in images more
> easily than differences in text.
>
> What about generating an image based on the bytes of an address, using
> something like identicon, used by gravatar? Any small change to the text
> input produces a significantly different image.
>
> -Danny
>
> On Oct 30, 2017 7:43 AM, "Moral Agent via bitcoin-dev" <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> If you are going to rely on human verification of addresses, the best way
>> might be map it to words.
>>
>> For example, with a 6000 word list, a 25 byte address (with a checksum)
>> could be mapped to 16 words like this:
>>
>> vocally           acquire        removed     unfounded
>> euphemism    sanctuary    sectional     driving
>> entree            freckles    aloof           vertebrae
>> scribble          surround      prelaw         effort
>>
>> In my opinion, that is much faster to verify than this:
>>
>> 13gQFTYHuAcfnZjXo2NFsy1E8JGSLwXHCZ
>>
>> or
>>
>> bc1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3qccfmv3
>>
>> Although I really do love Bech32.
>>
>> On Mon, Oct 30, 2017 at 9:13 AM, shiva sitamraju via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> For example bc1qeklep85ntjz4605drds6aww9u0qr46qzrv5xswd35uhjuj8ahfcqgf6hak
>>> in 461e8a4aa0a0e75c06602c505bd7aa06e7116ba5cd98fd6e046e8cbeb00379d6 is
>>> 62 bytes ! This is very very long. This will create lot of usability
>>> problems in
>>>
>>> - Blockexplorers (atleast user should be visually able to compare in a
>>> transaction having multiple outputs which one his address)
>>> - Mobiles
>>> - Payment terminals
>>>
>>> From my limited understanding, the purpose of inventing a bitcoin
>>> address format is for usability and ease of identification (versus a ECDSA
>>> public key), While I get the error/checksum capabilities Bech32 brings, any
>>> user would prefer a 20 byte address with a checksum  over an address that
>>> would wrap several lines !!
>>>
>>>
>>> On Mon, Oct 30, 2017 at 6:19 PM, Ben Thompson <
>>> thompson.benedictjames at gmail.com> wrote:
>>>
>>>> Checking the first few bytes of a Bitcoin Address should not be
>>>> considered sufficient for ensuring that it is correct as it takes less than
>>>> a second to generate a 3 character vanity address that matches the first 3
>>>> characters of an address.
>>>>
>>>> On Mon, 30 Oct 2017, 11:44 shiva sitamraju via bitcoin-dev, <
>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>
>>>>> Hi,
>>>>>
>>>>> When I copy and paste bitcoin address, I double check the first few
>>>>> bytes, to make sure I copied the correct one. This is to make sure some
>>>>> rogue software is not changing the address, or I incorrectly pasted the
>>>>> wrong address.
>>>>>
>>>>>
>>>>> With Bech32 address, its seems like in this department we are taking
>>>>> as step in the backward direction. With the traditional address, I could
>>>>> compare first few bytes like 1Ko or 1L3. With bech32, bc1. is all I can see
>>>>> and compare which is likely to be same anyway. Note that most users will
>>>>> only compare the first few bytes only (since addresses themselves are very
>>>>> long and will overflow in a mobile text box).
>>>>>
>>>>> Is there anyway to make the Bech32 addresses format more visually
>>>>> distinct (atleast the first few bytes) ?
>>>>> _______________________________________________
>>>>> bitcoin-dev mailing list
>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>>
>>>>
>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171030/8f52182e/attachment-0001.html>

From chuaxuanlong at hotmail.com  Mon Oct 30 17:12:44 2017
From: chuaxuanlong at hotmail.com (Daryl - .)
Date: Mon, 30 Oct 2017 17:12:44 +0000
Subject: [bitcoin-dev] Optimization of Codes for Electrum
Message-ID: <KL1PR04MB12222FA12067384DA1164308D8590@KL1PR04MB1222.apcprd04.prod.outlook.com>

Dear Bitcoin-Dev,

I?m writing in to enquire on the post (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2013-July/002916.html) and I?d like to seek your help and understanding on the codes you modified in order to optimize the syncing of blockchain. For instance, the functions that you modified/variables/values that may lead to a better performance. I?m currently working on further optimising Electrum in terms of syncing and any help will be greatly appreciated.

Thank you and I really look forward to your prompt reply soon.

Regards,
Daryl
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171030/94c539a0/attachment.html>

From lf-lists at mattcorallo.com  Mon Oct 30 21:42:44 2017
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Mon, 30 Oct 2017 21:42:44 +0000
Subject: [bitcoin-dev] Simplicity: An alternative to Script
In-Reply-To: <CAMZUoK=VNRMda8oRCtxniE6-vLwG-b=je2Hx+sD9sCzS--v9kQ@mail.gmail.com>
References: <CAMZUoK=VNRMda8oRCtxniE6-vLwG-b=je2Hx+sD9sCzS--v9kQ@mail.gmail.com>
Message-ID: <E63C347E-5321-4F7F-B69C-75747E88AC06@mattcorallo.com>

I admittedly haven't had a chance to read the paper in full details, but I was curious how you propose dealing with "jets" in something like Bitcoin. AFAIU, other similar systems are left doing hard-forks to reduce the sigops/weight/fee-cost of transactions every time they want to add useful optimized drop-ins. For obvious reasons, this seems rather impractical and a potentially critical barrier to adoption of such optimized drop-ins, which I imagine would be required to do any new cryptographic algorithms due to the significant fee cost of interpreting such things.

Is there some insight I'm missing here?

Matt

On October 30, 2017 11:22:20 AM EDT, Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>I've been working on the design and implementation of an alternative to
>Bitcoin Script, which I call Simplicity.  Today, I am presenting my
>design
>at the PLAS 2017 Workshop <http://plas2017.cse.buffalo.edu/> on
>Programming
>Languages and Analysis for Security.  You find a copy of my Simplicity
>paper at https://blockstream.com/simplicity.pdf
>
>Simplicity is a low-level, typed, functional, native MAST language
>where
>programs are built from basic combinators.  Like Bitcoin Script,
>Simplicity
>is designed to operate at the consensus layer.  While one can write
>Simplicity by hand, it is expected to be the target of one, or
>multiple,
>front-end languages.
>
>Simplicity comes with formal denotational semantics (i.e. semantics of
>what
>programs compute) and formal operational semantics (i.e. semantics of
>how
>programs compute). These are both formalized in the Coq proof assistant
>and
>proven equivalent.
>
>Formal denotational semantics are of limited value unless one can use
>them
>in practice to reason about programs. I've used Simplicity's formal
>semantics to prove correct an implementation of the SHA-256 compression
>function written in Simplicity.  I have also implemented a variant of
>ECDSA
>signature verification in Simplicity, and plan to formally validate its
>correctness along with the associated elliptic curve operations.
>
>Simplicity comes with easy to compute static analyses that can compute
>bounds on the space and time resources needed for evaluation.  This is
>important for both node operators, so that the costs are knows before
>evaluation, and for designing Simplicity programs, so that
>smart-contract
>participants can know the costs of their contract before committing to
>it.
>
>As a native MAST language, unused branches of Simplicity programs are
>pruned at redemption time.  This enhances privacy, reduces the block
>weight
>used, and can reduce space and time resource costs needed for
>evaluation.
>
>To make Simplicity practical, jets replace common Simplicity
>expressions
>(identified by their MAST root) and directly implement them with C
>code.  I
>anticipate developing a broad set of useful jets covering arithmetic
>operations, elliptic curve operations, and cryptographic operations
>including hashing and digital signature validation.
>
>The paper I am presenting at PLAS describes only the foundation of the
>Simplicity language.  The final design includes extensions not covered
>in
>the paper, including
>
>- full convent support, allowing access to all transaction data.
>- support for signature aggregation.
>- support for delegation.
>
>Simplicity is still in a research and development phase.  I'm working
>to
>produce a bare-bones SDK that will include
>
>- the formal semantics and correctness proofs in Coq
>- a Haskell implementation for constructing Simplicity programs
>- and a C interpreter for Simplicity.
>
>After an SDK is complete the next step will be making Simplicity
>available
>in the Elements project <https://elementsproject.org/> so that anyone
>can
>start experimenting with Simplicity in sidechains. Only after extensive
>vetting would it be suitable to consider Simplicity for inclusion in
>Bitcoin.
>
>Simplicity has a long ways to go still, and this work is not intended
>to
>delay consideration of the various Merkelized Script proposals that are
>currently ongoing.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171030/2094b682/attachment.html>

From mark at friedenbach.org  Mon Oct 30 21:56:00 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Mon, 30 Oct 2017 14:56:00 -0700
Subject: [bitcoin-dev] Simplicity: An alternative to Script
In-Reply-To: <E63C347E-5321-4F7F-B69C-75747E88AC06@mattcorallo.com>
References: <CAMZUoK=VNRMda8oRCtxniE6-vLwG-b=je2Hx+sD9sCzS--v9kQ@mail.gmail.com>
	<E63C347E-5321-4F7F-B69C-75747E88AC06@mattcorallo.com>
Message-ID: <64173F46-551E-4C36-A43A-5FBDBFF761CD@friedenbach.org>

Script versions makes this no longer a hard-fork to do. The script version would implicitly encode which jets are optimized, and what their optimized cost is.

> On Oct 30, 2017, at 2:42 PM, Matt Corallo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> I admittedly haven't had a chance to read the paper in full details, but I was curious how you propose dealing with "jets" in something like Bitcoin. AFAIU, other similar systems are left doing hard-forks to reduce the sigops/weight/fee-cost of transactions every time they want to add useful optimized drop-ins. For obvious reasons, this seems rather impractical and a potentially critical barrier to adoption of such optimized drop-ins, which I imagine would be required to do any new cryptographic algorithms due to the significant fee cost of interpreting such things.
> 
> Is there some insight I'm missing here?
> 
> Matt
> 
> On October 30, 2017 11:22:20 AM EDT, Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> I've been working on the design and implementation of an alternative to Bitcoin Script, which I call Simplicity.  Today, I am presenting my design at the PLAS 2017 Workshop <http://plas2017.cse.buffalo.edu/> on Programming Languages and Analysis for Security.  You find a copy of my Simplicity paper at https://blockstream.com/simplicity.pdf <https://blockstream.com/simplicity.pdf>
> 
> Simplicity is a low-level, typed, functional, native MAST language where programs are built from basic combinators.  Like Bitcoin Script, Simplicity is designed to operate at the consensus layer.  While one can write Simplicity by hand, it is expected to be the target of one, or multiple, front-end languages.
> 
> Simplicity comes with formal denotational semantics (i.e. semantics of what programs compute) and formal operational semantics (i.e. semantics of how programs compute). These are both formalized in the Coq proof assistant and proven equivalent.
> 
> Formal denotational semantics are of limited value unless one can use them in practice to reason about programs. I've used Simplicity's formal semantics to prove correct an implementation of the SHA-256 compression function written in Simplicity.  I have also implemented a variant of ECDSA signature verification in Simplicity, and plan to formally validate its correctness along with the associated elliptic curve operations.
> 
> Simplicity comes with easy to compute static analyses that can compute bounds on the space and time resources needed for evaluation.  This is important for both node operators, so that the costs are knows before evaluation, and for designing Simplicity programs, so that smart-contract participants can know the costs of their contract before committing to it.
> 
> As a native MAST language, unused branches of Simplicity programs are pruned at redemption time.  This enhances privacy, reduces the block weight used, and can reduce space and time resource costs needed for evaluation.
> 
> To make Simplicity practical, jets replace common Simplicity expressions (identified by their MAST root) and directly implement them with C code.  I anticipate developing a broad set of useful jets covering arithmetic operations, elliptic curve operations, and cryptographic operations including hashing and digital signature validation.
> 
> The paper I am presenting at PLAS describes only the foundation of the Simplicity language.  The final design includes extensions not covered in the paper, including
> 
> - full convent support, allowing access to all transaction data.
> - support for signature aggregation.
> - support for delegation.
> 
> Simplicity is still in a research and development phase.  I'm working to produce a bare-bones SDK that will include 
> 
> - the formal semantics and correctness proofs in Coq
> - a Haskell implementation for constructing Simplicity programs
> - and a C interpreter for Simplicity.
> 
> After an SDK is complete the next step will be making Simplicity available in the Elements project <https://elementsproject.org/> so that anyone can start experimenting with Simplicity in sidechains. Only after extensive vetting would it be suitable to consider Simplicity for inclusion in Bitcoin.
> 
> Simplicity has a long ways to go still, and this work is not intended to delay consideration of the various Merkelized Script proposals that are currently ongoing.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171030/e25a609d/attachment-0001.html>

From lf-lists at mattcorallo.com  Mon Oct 30 22:14:44 2017
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Mon, 30 Oct 2017 18:14:44 -0400
Subject: [bitcoin-dev] Simplicity: An alternative to Script
In-Reply-To: <64173F46-551E-4C36-A43A-5FBDBFF761CD@friedenbach.org>
References: <CAMZUoK=VNRMda8oRCtxniE6-vLwG-b=je2Hx+sD9sCzS--v9kQ@mail.gmail.com>
	<E63C347E-5321-4F7F-B69C-75747E88AC06@mattcorallo.com>
	<64173F46-551E-4C36-A43A-5FBDBFF761CD@friedenbach.org>
Message-ID: <1689d7c6-7c32-aa78-6626-c344f19923de@mattcorallo.com>

Are you anticipating it will be reasonably possible to execute more
complicated things in interpreted form even after "jets" are put in
place? If not its just a soft-fork to add new script operations and
going through the effort of making them compatible with existing code
and using a full 32 byte hash to represent them seems wasteful - might
as well just add a "SHA256 opcode".

Either way it sounds like you're assuming a pretty aggressive soft-fork
cadence? I'm not sure if that's so practical right now (or are you
thinking it would be more practical if things were
drop-in-formally-verified-equivalent-replacements?).

Matt

On 10/30/17 17:56, Mark Friedenbach wrote:
> Script versions makes this no longer a hard-fork to do. The script
> version would implicitly encode which jets are optimized, and what their
> optimized cost is.
> 
>> On Oct 30, 2017, at 2:42 PM, Matt Corallo via bitcoin-dev
>> <bitcoin-dev at lists.linuxfoundation.org
>> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>
>> I admittedly haven't had a chance to read the paper in full details,
>> but I was curious how you propose dealing with "jets" in something
>> like Bitcoin. AFAIU, other similar systems are left doing hard-forks
>> to reduce the sigops/weight/fee-cost of transactions every time they
>> want to add useful optimized drop-ins. For obvious reasons, this seems
>> rather impractical and a potentially critical barrier to adoption of
>> such optimized drop-ins, which I imagine would be required to do any
>> new cryptographic algorithms due to the significant fee cost of
>> interpreting such things.
>>
>> Is there some insight I'm missing here?
>>
>> Matt
>>
>> On October 30, 2017 11:22:20 AM EDT, Russell O'Connor via bitcoin-dev
>> <bitcoin-dev at lists.linuxfoundation.org
>> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>
>>     I've been working on the design and implementation of an
>>     alternative to Bitcoin Script, which I call Simplicity.? Today, I
>>     am presenting my design at the PLAS 2017 Workshop
>>     <http://plas2017.cse.buffalo.edu/> on Programming Languages and
>>     Analysis for Security.? You find a copy of my Simplicity paper at
>>     https://blockstream.com/simplicity.pdf
>>     <https://blockstream.com/simplicity.pdf>
>>
>>     Simplicity is a low-level, typed, functional, native MAST language
>>     where programs are built from basic combinators.? Like Bitcoin
>>     Script, Simplicity is designed to operate at the consensus layer.?
>>     While one can write Simplicity by hand, it is expected to be the
>>     target of one, or multiple, front-end languages.
>>
>>     Simplicity comes with formal denotational semantics (i.e.
>>     semantics of what programs compute) and formal operational
>>     semantics (i.e. semantics of how programs compute). These are both
>>     formalized in the Coq proof assistant and proven equivalent.
>>
>>     Formal denotational semantics are of limited value unless one can
>>     use them in practice to reason about programs. I've used
>>     Simplicity's formal semantics to prove correct an implementation
>>     of the SHA-256 compression function written in Simplicity.? I have
>>     also implemented a variant of ECDSA signature verification in
>>     Simplicity, and plan to formally validate its correctness along
>>     with the associated elliptic curve operations.
>>
>>     Simplicity comes with easy to compute static analyses that can
>>     compute bounds on the space and time resources needed for
>>     evaluation.? This is important for both node operators, so that
>>     the costs are knows before evaluation, and for designing
>>     Simplicity programs, so that smart-contract participants can know
>>     the costs of their contract before committing to it.
>>
>>     As a native MAST language, unused branches of Simplicity programs
>>     are pruned at redemption time.? This enhances privacy, reduces the
>>     block weight used, and can reduce space and time resource costs
>>     needed for evaluation.
>>
>>     To make Simplicity practical, jets replace common Simplicity
>>     expressions (identified by their MAST root) and directly implement
>>     them with C code.? I anticipate developing a broad set of useful
>>     jets covering arithmetic operations, elliptic curve operations,
>>     and cryptographic operations including hashing and digital
>>     signature validation.
>>
>>     The paper I am presenting at PLAS describes only the foundation of
>>     the Simplicity language.? The final design includes extensions not
>>     covered in the paper, including
>>
>>     - full convent support, allowing access to all transaction data.
>>     - support for signature aggregation.
>>     - support for delegation.
>>
>>     Simplicity is still in a research and development phase.? I'm
>>     working to produce a bare-bones SDK that will include
>>
>>     - the formal semantics and correctness proofs in Coq
>>     - a Haskell implementation for constructing Simplicity programs
>>     - and a C interpreter for Simplicity.
>>
>>     After an SDK is complete the next step will be making Simplicity
>>     available in the Elements project <https://elementsproject.org/>
>>     so that anyone can start experimenting with Simplicity in
>>     sidechains. Only after extensive vetting would it be suitable to
>>     consider Simplicity for inclusion in Bitcoin.
>>
>>     Simplicity has a long ways to go still, and this work is not
>>     intended to delay consideration of the various Merkelized Script
>>     proposals that are currently ongoing.
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> <mailto:bitcoin-dev at lists.linuxfoundation.org>
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From mark at friedenbach.org  Mon Oct 30 22:32:42 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Mon, 30 Oct 2017 15:32:42 -0700
Subject: [bitcoin-dev] Simplicity: An alternative to Script
In-Reply-To: <1689d7c6-7c32-aa78-6626-c344f19923de@mattcorallo.com>
References: <CAMZUoK=VNRMda8oRCtxniE6-vLwG-b=je2Hx+sD9sCzS--v9kQ@mail.gmail.com>
	<E63C347E-5321-4F7F-B69C-75747E88AC06@mattcorallo.com>
	<64173F46-551E-4C36-A43A-5FBDBFF761CD@friedenbach.org>
	<1689d7c6-7c32-aa78-6626-c344f19923de@mattcorallo.com>
Message-ID: <6E10759E-DCEC-4C13-AD23-7DEE1BC20311@friedenbach.org>

I was just making a factual observation/correction. This is Russell?s project and I don?t want to speak for him. Personally I don?t think the particulars of bitcoin integration design space have been thoroughly explored enough to predict the exact approach that will be used.

It is possible to support a standard library of jets that are general purpose enough to allow the validation of new crypto primitives, like reusing sha2 to make Lamport signatures. Or use curve-agnostic jets to do Weil pairing validation. Or string manipulation and serialization jets to implement covenants. So I don?t think the situation is as dire as you make it sound.

> On Oct 30, 2017, at 3:14 PM, Matt Corallo <lf-lists at mattcorallo.com> wrote:
> 
> Are you anticipating it will be reasonably possible to execute more
> complicated things in interpreted form even after "jets" are put in
> place? If not its just a soft-fork to add new script operations and
> going through the effort of making them compatible with existing code
> and using a full 32 byte hash to represent them seems wasteful - might
> as well just add a "SHA256 opcode".
> 
> Either way it sounds like you're assuming a pretty aggressive soft-fork
> cadence? I'm not sure if that's so practical right now (or are you
> thinking it would be more practical if things were
> drop-in-formally-verified-equivalent-replacements?).
> 
> Matt
> 
>> On 10/30/17 17:56, Mark Friedenbach wrote:
>> Script versions makes this no longer a hard-fork to do. The script
>> version would implicitly encode which jets are optimized, and what their
>> optimized cost is.
>> 
>>> On Oct 30, 2017, at 2:42 PM, Matt Corallo via bitcoin-dev
>>> <bitcoin-dev at lists.linuxfoundation.org
>>> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>> 
>>> I admittedly haven't had a chance to read the paper in full details,
>>> but I was curious how you propose dealing with "jets" in something
>>> like Bitcoin. AFAIU, other similar systems are left doing hard-forks
>>> to reduce the sigops/weight/fee-cost of transactions every time they
>>> want to add useful optimized drop-ins. For obvious reasons, this seems
>>> rather impractical and a potentially critical barrier to adoption of
>>> such optimized drop-ins, which I imagine would be required to do any
>>> new cryptographic algorithms due to the significant fee cost of
>>> interpreting such things.
>>> 
>>> Is there some insight I'm missing here?
>>> 
>>> Matt
>>> 
>>> On October 30, 2017 11:22:20 AM EDT, Russell O'Connor via bitcoin-dev
>>> <bitcoin-dev at lists.linuxfoundation.org
>>> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>> 
>>>    I've been working on the design and implementation of an
>>>    alternative to Bitcoin Script, which I call Simplicity.  Today, I
>>>    am presenting my design at the PLAS 2017 Workshop
>>>    <http://plas2017.cse.buffalo.edu/> on Programming Languages and
>>>    Analysis for Security.  You find a copy of my Simplicity paper at
>>>    https://blockstream.com/simplicity.pdf
>>>    <https://blockstream.com/simplicity.pdf>
>>> 
>>>    Simplicity is a low-level, typed, functional, native MAST language
>>>    where programs are built from basic combinators.  Like Bitcoin
>>>    Script, Simplicity is designed to operate at the consensus layer. 
>>>    While one can write Simplicity by hand, it is expected to be the
>>>    target of one, or multiple, front-end languages.
>>> 
>>>    Simplicity comes with formal denotational semantics (i.e.
>>>    semantics of what programs compute) and formal operational
>>>    semantics (i.e. semantics of how programs compute). These are both
>>>    formalized in the Coq proof assistant and proven equivalent.
>>> 
>>>    Formal denotational semantics are of limited value unless one can
>>>    use them in practice to reason about programs. I've used
>>>    Simplicity's formal semantics to prove correct an implementation
>>>    of the SHA-256 compression function written in Simplicity.  I have
>>>    also implemented a variant of ECDSA signature verification in
>>>    Simplicity, and plan to formally validate its correctness along
>>>    with the associated elliptic curve operations.
>>> 
>>>    Simplicity comes with easy to compute static analyses that can
>>>    compute bounds on the space and time resources needed for
>>>    evaluation.  This is important for both node operators, so that
>>>    the costs are knows before evaluation, and for designing
>>>    Simplicity programs, so that smart-contract participants can know
>>>    the costs of their contract before committing to it.
>>> 
>>>    As a native MAST language, unused branches of Simplicity programs
>>>    are pruned at redemption time.  This enhances privacy, reduces the
>>>    block weight used, and can reduce space and time resource costs
>>>    needed for evaluation.
>>> 
>>>    To make Simplicity practical, jets replace common Simplicity
>>>    expressions (identified by their MAST root) and directly implement
>>>    them with C code.  I anticipate developing a broad set of useful
>>>    jets covering arithmetic operations, elliptic curve operations,
>>>    and cryptographic operations including hashing and digital
>>>    signature validation.
>>> 
>>>    The paper I am presenting at PLAS describes only the foundation of
>>>    the Simplicity language.  The final design includes extensions not
>>>    covered in the paper, including
>>> 
>>>    - full convent support, allowing access to all transaction data.
>>>    - support for signature aggregation.
>>>    - support for delegation.
>>> 
>>>    Simplicity is still in a research and development phase.  I'm
>>>    working to produce a bare-bones SDK that will include
>>> 
>>>    - the formal semantics and correctness proofs in Coq
>>>    - a Haskell implementation for constructing Simplicity programs
>>>    - and a C interpreter for Simplicity.
>>> 
>>>    After an SDK is complete the next step will be making Simplicity
>>>    available in the Elements project <https://elementsproject.org/>
>>>    so that anyone can start experimenting with Simplicity in
>>>    sidechains. Only after extensive vetting would it be suitable to
>>>    consider Simplicity for inclusion in Bitcoin.
>>> 
>>>    Simplicity has a long ways to go still, and this work is not
>>>    intended to delay consideration of the various Merkelized Script
>>>    proposals that are currently ongoing.
>>> 
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> 

From lf-lists at mattcorallo.com  Mon Oct 30 22:50:04 2017
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Mon, 30 Oct 2017 18:50:04 -0400
Subject: [bitcoin-dev] Simplicity: An alternative to Script
In-Reply-To: <6E10759E-DCEC-4C13-AD23-7DEE1BC20311@friedenbach.org>
References: <CAMZUoK=VNRMda8oRCtxniE6-vLwG-b=je2Hx+sD9sCzS--v9kQ@mail.gmail.com>
	<E63C347E-5321-4F7F-B69C-75747E88AC06@mattcorallo.com>
	<64173F46-551E-4C36-A43A-5FBDBFF761CD@friedenbach.org>
	<1689d7c6-7c32-aa78-6626-c344f19923de@mattcorallo.com>
	<6E10759E-DCEC-4C13-AD23-7DEE1BC20311@friedenbach.org>
Message-ID: <55cfee10-02f7-afd6-d4a3-2e8ff896e812@mattcorallo.com>

OK, fair enough, just wanted to make sure we were on the same page.
"Thorny issues there and there hasn't been a ton of effort put into what
Bitcoin integration and maintainability looks like" is a perfectly fair
response :)

Matt

On 10/30/17 18:32, Mark Friedenbach wrote:
> I was just making a factual observation/correction. This is Russell?s project and I don?t want to speak for him. Personally I don?t think the particulars of bitcoin integration design space have been thoroughly explored enough to predict the exact approach that will be used.
> 
> It is possible to support a standard library of jets that are general purpose enough to allow the validation of new crypto primitives, like reusing sha2 to make Lamport signatures. Or use curve-agnostic jets to do Weil pairing validation. Or string manipulation and serialization jets to implement covenants. So I don?t think the situation is as dire as you make it sound.
> 
>> On Oct 30, 2017, at 3:14 PM, Matt Corallo <lf-lists at mattcorallo.com> wrote:
>>
>> Are you anticipating it will be reasonably possible to execute more
>> complicated things in interpreted form even after "jets" are put in
>> place? If not its just a soft-fork to add new script operations and
>> going through the effort of making them compatible with existing code
>> and using a full 32 byte hash to represent them seems wasteful - might
>> as well just add a "SHA256 opcode".
>>
>> Either way it sounds like you're assuming a pretty aggressive soft-fork
>> cadence? I'm not sure if that's so practical right now (or are you
>> thinking it would be more practical if things were
>> drop-in-formally-verified-equivalent-replacements?).
>>
>> Matt
>>
>>> On 10/30/17 17:56, Mark Friedenbach wrote:
>>> Script versions makes this no longer a hard-fork to do. The script
>>> version would implicitly encode which jets are optimized, and what their
>>> optimized cost is.
>>>
>>>> On Oct 30, 2017, at 2:42 PM, Matt Corallo via bitcoin-dev
>>>> <bitcoin-dev at lists.linuxfoundation.org
>>>> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>>>
>>>> I admittedly haven't had a chance to read the paper in full details,
>>>> but I was curious how you propose dealing with "jets" in something
>>>> like Bitcoin. AFAIU, other similar systems are left doing hard-forks
>>>> to reduce the sigops/weight/fee-cost of transactions every time they
>>>> want to add useful optimized drop-ins. For obvious reasons, this seems
>>>> rather impractical and a potentially critical barrier to adoption of
>>>> such optimized drop-ins, which I imagine would be required to do any
>>>> new cryptographic algorithms due to the significant fee cost of
>>>> interpreting such things.
>>>>
>>>> Is there some insight I'm missing here?
>>>>
>>>> Matt
>>>>
>>>> On October 30, 2017 11:22:20 AM EDT, Russell O'Connor via bitcoin-dev
>>>> <bitcoin-dev at lists.linuxfoundation.org
>>>> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>>>
>>>>    I've been working on the design and implementation of an
>>>>    alternative to Bitcoin Script, which I call Simplicity.  Today, I
>>>>    am presenting my design at the PLAS 2017 Workshop
>>>>    <http://plas2017.cse.buffalo.edu/> on Programming Languages and
>>>>    Analysis for Security.  You find a copy of my Simplicity paper at
>>>>    https://blockstream.com/simplicity.pdf
>>>>    <https://blockstream.com/simplicity.pdf>
>>>>
>>>>    Simplicity is a low-level, typed, functional, native MAST language
>>>>    where programs are built from basic combinators.  Like Bitcoin
>>>>    Script, Simplicity is designed to operate at the consensus layer. 
>>>>    While one can write Simplicity by hand, it is expected to be the
>>>>    target of one, or multiple, front-end languages.
>>>>
>>>>    Simplicity comes with formal denotational semantics (i.e.
>>>>    semantics of what programs compute) and formal operational
>>>>    semantics (i.e. semantics of how programs compute). These are both
>>>>    formalized in the Coq proof assistant and proven equivalent.
>>>>
>>>>    Formal denotational semantics are of limited value unless one can
>>>>    use them in practice to reason about programs. I've used
>>>>    Simplicity's formal semantics to prove correct an implementation
>>>>    of the SHA-256 compression function written in Simplicity.  I have
>>>>    also implemented a variant of ECDSA signature verification in
>>>>    Simplicity, and plan to formally validate its correctness along
>>>>    with the associated elliptic curve operations.
>>>>
>>>>    Simplicity comes with easy to compute static analyses that can
>>>>    compute bounds on the space and time resources needed for
>>>>    evaluation.  This is important for both node operators, so that
>>>>    the costs are knows before evaluation, and for designing
>>>>    Simplicity programs, so that smart-contract participants can know
>>>>    the costs of their contract before committing to it.
>>>>
>>>>    As a native MAST language, unused branches of Simplicity programs
>>>>    are pruned at redemption time.  This enhances privacy, reduces the
>>>>    block weight used, and can reduce space and time resource costs
>>>>    needed for evaluation.
>>>>
>>>>    To make Simplicity practical, jets replace common Simplicity
>>>>    expressions (identified by their MAST root) and directly implement
>>>>    them with C code.  I anticipate developing a broad set of useful
>>>>    jets covering arithmetic operations, elliptic curve operations,
>>>>    and cryptographic operations including hashing and digital
>>>>    signature validation.
>>>>
>>>>    The paper I am presenting at PLAS describes only the foundation of
>>>>    the Simplicity language.  The final design includes extensions not
>>>>    covered in the paper, including
>>>>
>>>>    - full convent support, allowing access to all transaction data.
>>>>    - support for signature aggregation.
>>>>    - support for delegation.
>>>>
>>>>    Simplicity is still in a research and development phase.  I'm
>>>>    working to produce a bare-bones SDK that will include
>>>>
>>>>    - the formal semantics and correctness proofs in Coq
>>>>    - a Haskell implementation for constructing Simplicity programs
>>>>    - and a C interpreter for Simplicity.
>>>>
>>>>    After an SDK is complete the next step will be making Simplicity
>>>>    available in the Elements project <https://elementsproject.org/>
>>>>    so that anyone can start experimenting with Simplicity in
>>>>    sidechains. Only after extensive vetting would it be suitable to
>>>>    consider Simplicity for inclusion in Bitcoin.
>>>>
>>>>    Simplicity has a long ways to go still, and this work is not
>>>>    intended to delay consideration of the various Merkelized Script
>>>>    proposals that are currently ongoing.
>>>>
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>

From greg at xiph.org  Mon Oct 30 23:29:28 2017
From: greg at xiph.org (Gregory Maxwell)
Date: Mon, 30 Oct 2017 23:29:28 +0000
Subject: [bitcoin-dev] Simplicity: An alternative to Script
In-Reply-To: <E63C347E-5321-4F7F-B69C-75747E88AC06@mattcorallo.com>
References: <CAMZUoK=VNRMda8oRCtxniE6-vLwG-b=je2Hx+sD9sCzS--v9kQ@mail.gmail.com>
	<E63C347E-5321-4F7F-B69C-75747E88AC06@mattcorallo.com>
Message-ID: <CAAS2fgRUAh2GJWbG74pef5tmj4NmbHX3_fy-_GMYWP3Tj4TNWA@mail.gmail.com>

On Mon, Oct 30, 2017 at 9:42 PM, Matt Corallo via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> I admittedly haven't had a chance to read the paper in full details, but I
> was curious how you propose dealing with "jets" in something like Bitcoin.
> AFAIU, other similar systems are left doing hard-forks to reduce the
> sigops/weight/fee-cost of transactions every time they want to add useful
> optimized drop-ins. For obvious reasons, this seems rather impractical and a
> potentially critical barrier to adoption of such optimized drop-ins, which I
> imagine would be required to do any new cryptographic algorithms due to the
> significant fee cost of interpreting such things.

For some framing-- I think we're still a long way off from proposing
something like this in Bitcoin, and _how_ it's ultimately proposed is
an open question.

There are many ways to use simplicity, for an extreme example:  one
could define a collection of high level operations and combinators at
the level of things in Bitcoin Script (op_sha256, op_equal, op_cat,
etc.)  and make an interpreter that implements these operations as
discounted jets and ONLY these operations at all.

At that point you have a system which is functionally like Bitcoin
Script-- with the same performance characteristics-- but with a pretty
much perfectly rigorous formal specification and which is highly
amenable to the formal analysis of smart contracts written in it.

At the other extreme, you expose a full on Bitmachine and allow
arbitrary simplicity--  But this is probably slow enough to not be
very useful.  Simplicity itself is so simple that it doesn't natively
have a concept of a _bit_, library code programs the concept of a bit,
then the concept of a half adder ... and so on.   As a result a
completely unjetted implementation is slow (actually remarkably fast
considering that it's effectively interpreting a circuit constructed
from pure logic).

The most useful way of using it would probably be in-between: a good
collection of high level functions, and mid-level functions (e.g.
arithmetic and string operations) making a wide space of useful but
general software both possible and high performance.  But to get there
we need enough experience with it to know what the requisite
collection of operations would be.

One challenge is that I don't think we have a clear mental model for
how nominal validation costs are allowed to be before there is a
negative impact.  It's probably safe to assume 'pretty darn nominal'
is a requirement, but there is still a lot that can be done within
that envelope.

As far as consensus discounted jets goes:

>From my perspective there are three related ideas around this:

Is a particular script-root jetted or not in an implementation?
 -- In and of itself this is not of consensus consequence; esp.
because a major design feature of simplicity is that it should be
possible using to prove that an optimized C implementation of a
simplicity program is complete and correct (using VST+COQ).

Is a particular script-root 'standard and known' in the P2P network:
 -- This means that you can skip communicating it when sending
witnesses to peers; but this is something that could be negotiated on
a peer by peer basis-- like compressing transactions, and isn't at all
consensus normative.

Is a particular jet discounted and what are the discounts:
 -- This is inherently a consensus question; as the bitmachine costing
for a program is consensus normative (assuming that you allow
arbitrary simplicity code at all).

A script-versioning like mechanism can provide for a straight-forward
way to upgrade discounted cost tables in a compatible way--  if you're
running old software that doesn't have the required jets to justify a
particular discount collection -- well that's okay, you won't validate
those scripts at all. (so they'll be super fast for you!)

Another potential tool is the idea of sunsetting cost limits that
sunset; e.g. after N years, the limits go away with an assumption that
updated limits have been softforked in that ativate at that time and
themselves expire in N years.  Old software would become slower
validating due to newly discounted code they lack jets for... but
would continue validating (at least until they run out of performance
headroom).

This is theoretically attractive in a number of regards, but
unfortunately I think our industry hasn't shown sufficient maturity
about engineering tradeoffs to make this a politically viable choice
in the mid-term-- I known I'm personally uncomfortable with the
outspokenness of parties that hold positions which I think can fairly
be summarized "We should remove all limits and if the system crashes
and burns as a result, we'll just make a new one! YOLO.". But it's
interesting to think about in the long term.

There are also hybrid approaches where you can imagine this decision
being made by node operators, e.g. continuing to validate code that
exceeds your effort limits on probabilistic and best effort basis;
even more attractive if there were a protocol for efficiently showing
others that an operation had an invalid witness. Though there is a lot
to explore about the brittleness to partitioning that comes from any
expectation that you'd learn about invalid updates by exception.

In any case, these are all options that exist completely independently
of simplicity.  I think we should think of simplicity as a rigorous
base which we could _potentially_ use to build whatever future
direction of script we like out of... by itself it doesn't mandate a
particular depth or level of adoption.

And for the moment it's still also mostly just a base-- I don't
anticipate typical smart contracting end users programming directly w/
simplicity even if Bitcoin did support arbitrary simplicity--  I
expect they'd program in user friendly domain specific languages which
are formally tied to their implementations in simplicity that allow-
but do not force- closed loop formal reasoning about their contracts
all the way from their high level business rules straight through to
the machine code implementing the interpreter(s) that run in the
network.

But to get there we'll have to prove in practice that this is actually
workable. We have some evidence that it is,  e.g. Roconnor's SHA2
implementation in simplicity is proven to implement the same function
that a C implementation implements (via the compcert formalization of
C).  but there will need to be more.

From roconnor at blockstream.io  Tue Oct 31 20:38:16 2017
From: roconnor at blockstream.io (Russell O'Connor)
Date: Tue, 31 Oct 2017 16:38:16 -0400
Subject: [bitcoin-dev] Simplicity: An alternative to Script
In-Reply-To: <E63C347E-5321-4F7F-B69C-75747E88AC06@mattcorallo.com>
References: <CAMZUoK=VNRMda8oRCtxniE6-vLwG-b=je2Hx+sD9sCzS--v9kQ@mail.gmail.com>
	<E63C347E-5321-4F7F-B69C-75747E88AC06@mattcorallo.com>
Message-ID: <CAMZUoKmos5BMkFNsmNnTJhryfho_0fGhSKDQ82D6SPjPBhvd0A@mail.gmail.com>

(sorry, I forgot to reply-all earlier)

The very short answer to this question is that I plan on using Luke's
fail-success-on-unknown-operation in Simplicity.  This is something that
isn't detailed at all in the paper.

The plan is that discounted jets will be explicitly labeled as jets in the
commitment.  If you can provide a Merkle path from the root to a node that
is an explicit jet, but that jet isn't among the finite number of known
discounted jets, then the script is automatically successful (making it
anyone-can-spend).  When new jets are wanted they can be soft-forked into
the protocol (for example if we get a suitable quantum-resistant digital
signature scheme) and the list of known discounted jets grows.  Old nodes
get a merkle path to the new jet, which they view as an unknown jet, and
allow the transaction as a anyone-can-spend transaction.  New nodes see a
regular Simplicity redemption.  (I haven't worked out the details of how
the P2P protocol will negotiate with old nodes, but I don't forsee any
problems.)

Note that this implies that you should never participate in any Simplicity
contract where you don't get access to the entire source code of all
branches to check that it doesn't have an unknown jet.

On Mon, Oct 30, 2017 at 5:42 PM, Matt Corallo <lf-lists at mattcorallo.com>
wrote:

> I admittedly haven't had a chance to read the paper in full details, but I
> was curious how you propose dealing with "jets" in something like Bitcoin.
> AFAIU, other similar systems are left doing hard-forks to reduce the
> sigops/weight/fee-cost of transactions every time they want to add useful
> optimized drop-ins. For obvious reasons, this seems rather impractical and
> a potentially critical barrier to adoption of such optimized drop-ins,
> which I imagine would be required to do any new cryptographic algorithms
> due to the significant fee cost of interpreting such things.
>
> Is there some insight I'm missing here?
>
> Matt
>
>
> On October 30, 2017 11:22:20 AM EDT, Russell O'Connor via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> I've been working on the design and implementation of an alternative to
>> Bitcoin Script, which I call Simplicity.  Today, I am presenting my design
>> at the PLAS 2017 Workshop <http://plas2017.cse.buffalo.edu/> on
>> Programming Languages and Analysis for Security.  You find a copy of my
>> Simplicity paper at https://blockstream.com/simplicity.pdf
>>
>> Simplicity is a low-level, typed, functional, native MAST language where
>> programs are built from basic combinators.  Like Bitcoin Script, Simplicity
>> is designed to operate at the consensus layer.  While one can write
>> Simplicity by hand, it is expected to be the target of one, or multiple,
>> front-end languages.
>>
>> Simplicity comes with formal denotational semantics (i.e. semantics of
>> what programs compute) and formal operational semantics (i.e. semantics of
>> how programs compute). These are both formalized in the Coq proof assistant
>> and proven equivalent.
>>
>> Formal denotational semantics are of limited value unless one can use
>> them in practice to reason about programs. I've used Simplicity's formal
>> semantics to prove correct an implementation of the SHA-256 compression
>> function written in Simplicity.  I have also implemented a variant of ECDSA
>> signature verification in Simplicity, and plan to formally validate its
>> correctness along with the associated elliptic curve operations.
>>
>> Simplicity comes with easy to compute static analyses that can compute
>> bounds on the space and time resources needed for evaluation.  This is
>> important for both node operators, so that the costs are knows before
>> evaluation, and for designing Simplicity programs, so that smart-contract
>> participants can know the costs of their contract before committing to it.
>>
>> As a native MAST language, unused branches of Simplicity programs are
>> pruned at redemption time.  This enhances privacy, reduces the block weight
>> used, and can reduce space and time resource costs needed for evaluation.
>>
>> To make Simplicity practical, jets replace common Simplicity expressions
>> (identified by their MAST root) and directly implement them with C code.  I
>> anticipate developing a broad set of useful jets covering arithmetic
>> operations, elliptic curve operations, and cryptographic operations
>> including hashing and digital signature validation.
>>
>> The paper I am presenting at PLAS describes only the foundation of the
>> Simplicity language.  The final design includes extensions not covered in
>> the paper, including
>>
>> - full convent support, allowing access to all transaction data.
>> - support for signature aggregation.
>> - support for delegation.
>>
>> Simplicity is still in a research and development phase.  I'm working to
>> produce a bare-bones SDK that will include
>>
>> - the formal semantics and correctness proofs in Coq
>> - a Haskell implementation for constructing Simplicity programs
>> - and a C interpreter for Simplicity.
>>
>> After an SDK is complete the next step will be making Simplicity
>> available in the Elements project <https://elementsproject.org/> so that
>> anyone can start experimenting with Simplicity in sidechains. Only after
>> extensive vetting would it be suitable to consider Simplicity for inclusion
>> in Bitcoin.
>>
>> Simplicity has a long ways to go still, and this work is not intended to
>> delay consideration of the various Merkelized Script proposals that are
>> currently ongoing.
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171031/40b31969/attachment.html>

From mark at friedenbach.org  Tue Oct 31 20:46:49 2017
From: mark at friedenbach.org (Mark Friedenbach)
Date: Tue, 31 Oct 2017 13:46:49 -0700
Subject: [bitcoin-dev] Simplicity: An alternative to Script
In-Reply-To: <CAMZUoKmos5BMkFNsmNnTJhryfho_0fGhSKDQ82D6SPjPBhvd0A@mail.gmail.com>
References: <CAMZUoK=VNRMda8oRCtxniE6-vLwG-b=je2Hx+sD9sCzS--v9kQ@mail.gmail.com>
	<E63C347E-5321-4F7F-B69C-75747E88AC06@mattcorallo.com>
	<CAMZUoKmos5BMkFNsmNnTJhryfho_0fGhSKDQ82D6SPjPBhvd0A@mail.gmail.com>
Message-ID: <CAOG=w-vsTCTNW9x5TCHChN6_13pAabWjDQ30Eoo4xQduJ01fdQ@mail.gmail.com>

Nit, but if you go down that specific path I would suggest making just
the jet itself fail-open. That way you are not so limited in requiring
validation of the full contract -- one party can verify simply that
whatever condition they care about holds on reaching that part of the
contract. E.g. maybe their signature is needed at the top level, and
then they don't care what further restrictions are placed.

On Tue, Oct 31, 2017 at 1:38 PM, Russell O'Connor via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> (sorry, I forgot to reply-all earlier)
>
> The very short answer to this question is that I plan on using Luke's
> fail-success-on-unknown-operation in Simplicity.  This is something that
> isn't detailed at all in the paper.
>
> The plan is that discounted jets will be explicitly labeled as jets in the
> commitment.  If you can provide a Merkle path from the root to a node that
> is an explicit jet, but that jet isn't among the finite number of known
> discounted jets, then the script is automatically successful (making it
> anyone-can-spend).  When new jets are wanted they can be soft-forked into
> the protocol (for example if we get a suitable quantum-resistant digital
> signature scheme) and the list of known discounted jets grows.  Old nodes
> get a merkle path to the new jet, which they view as an unknown jet, and
> allow the transaction as a anyone-can-spend transaction.  New nodes see a
> regular Simplicity redemption.  (I haven't worked out the details of how the
> P2P protocol will negotiate with old nodes, but I don't forsee any
> problems.)
>
> Note that this implies that you should never participate in any Simplicity
> contract where you don't get access to the entire source code of all
> branches to check that it doesn't have an unknown jet.
>
> On Mon, Oct 30, 2017 at 5:42 PM, Matt Corallo <lf-lists at mattcorallo.com>
> wrote:
>>
>> I admittedly haven't had a chance to read the paper in full details, but I
>> was curious how you propose dealing with "jets" in something like Bitcoin.
>> AFAIU, other similar systems are left doing hard-forks to reduce the
>> sigops/weight/fee-cost of transactions every time they want to add useful
>> optimized drop-ins. For obvious reasons, this seems rather impractical and a
>> potentially critical barrier to adoption of such optimized drop-ins, which I
>> imagine would be required to do any new cryptographic algorithms due to the
>> significant fee cost of interpreting such things.
>>
>> Is there some insight I'm missing here?
>>
>> Matt
>>
>>
>> On October 30, 2017 11:22:20 AM EDT, Russell O'Connor via bitcoin-dev
>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>> I've been working on the design and implementation of an alternative to
>>> Bitcoin Script, which I call Simplicity.  Today, I am presenting my design
>>> at the PLAS 2017 Workshop on Programming Languages and Analysis for
>>> Security.  You find a copy of my Simplicity paper at
>>> https://blockstream.com/simplicity.pdf
>>>
>>> Simplicity is a low-level, typed, functional, native MAST language where
>>> programs are built from basic combinators.  Like Bitcoin Script, Simplicity
>>> is designed to operate at the consensus layer.  While one can write
>>> Simplicity by hand, it is expected to be the target of one, or multiple,
>>> front-end languages.
>>>
>>> Simplicity comes with formal denotational semantics (i.e. semantics of
>>> what programs compute) and formal operational semantics (i.e. semantics of
>>> how programs compute). These are both formalized in the Coq proof assistant
>>> and proven equivalent.
>>>
>>> Formal denotational semantics are of limited value unless one can use
>>> them in practice to reason about programs. I've used Simplicity's formal
>>> semantics to prove correct an implementation of the SHA-256 compression
>>> function written in Simplicity.  I have also implemented a variant of ECDSA
>>> signature verification in Simplicity, and plan to formally validate its
>>> correctness along with the associated elliptic curve operations.
>>>
>>> Simplicity comes with easy to compute static analyses that can compute
>>> bounds on the space and time resources needed for evaluation.  This is
>>> important for both node operators, so that the costs are knows before
>>> evaluation, and for designing Simplicity programs, so that smart-contract
>>> participants can know the costs of their contract before committing to it.
>>>
>>> As a native MAST language, unused branches of Simplicity programs are
>>> pruned at redemption time.  This enhances privacy, reduces the block weight
>>> used, and can reduce space and time resource costs needed for evaluation.
>>>
>>> To make Simplicity practical, jets replace common Simplicity expressions
>>> (identified by their MAST root) and directly implement them with C code.  I
>>> anticipate developing a broad set of useful jets covering arithmetic
>>> operations, elliptic curve operations, and cryptographic operations
>>> including hashing and digital signature validation.
>>>
>>> The paper I am presenting at PLAS describes only the foundation of the
>>> Simplicity language.  The final design includes extensions not covered in
>>> the paper, including
>>>
>>> - full convent support, allowing access to all transaction data.
>>> - support for signature aggregation.
>>> - support for delegation.
>>>
>>> Simplicity is still in a research and development phase.  I'm working to
>>> produce a bare-bones SDK that will include
>>>
>>> - the formal semantics and correctness proofs in Coq
>>> - a Haskell implementation for constructing Simplicity programs
>>> - and a C interpreter for Simplicity.
>>>
>>> After an SDK is complete the next step will be making Simplicity
>>> available in the Elements project so that anyone can start experimenting
>>> with Simplicity in sidechains. Only after extensive vetting would it be
>>> suitable to consider Simplicity for inclusion in Bitcoin.
>>>
>>> Simplicity has a long ways to go still, and this work is not intended to
>>> delay consideration of the various Merkelized Script proposals that are
>>> currently ongoing.
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From roconnor at blockstream.io  Tue Oct 31 21:01:05 2017
From: roconnor at blockstream.io (Russell O'Connor)
Date: Tue, 31 Oct 2017 17:01:05 -0400
Subject: [bitcoin-dev] Simplicity: An alternative to Script
In-Reply-To: <CAOG=w-vsTCTNW9x5TCHChN6_13pAabWjDQ30Eoo4xQduJ01fdQ@mail.gmail.com>
References: <CAMZUoK=VNRMda8oRCtxniE6-vLwG-b=je2Hx+sD9sCzS--v9kQ@mail.gmail.com>
	<E63C347E-5321-4F7F-B69C-75747E88AC06@mattcorallo.com>
	<CAMZUoKmos5BMkFNsmNnTJhryfho_0fGhSKDQ82D6SPjPBhvd0A@mail.gmail.com>
	<CAOG=w-vsTCTNW9x5TCHChN6_13pAabWjDQ30Eoo4xQduJ01fdQ@mail.gmail.com>
Message-ID: <CAMZUoKmNEaTEoHV6cWOdLR=G9XiqTQ9AmHhyxegVEEmXVhU+7w@mail.gmail.com>

That approach is worth considering.  However there is a wrinkle that
Simplicity's denotational semantics doesn't imply an order of operations.
For example, if one half of a pair contains a assertion failure
(fail-closed), and the other half contains a unknown jet (fail-open), then
does the program succeed or fail?

This could be solved by providing an order of operations; however I fear
that will complicate formal reasoning about Simplicity expressions.  Formal
reasoning is hard enough as is and I hesitate to complicate the semantics
in ways that make formal reasoning harder still.


On Oct 31, 2017 15:47, "Mark Friedenbach" <mark at friedenbach.org> wrote:

Nit, but if you go down that specific path I would suggest making just
the jet itself fail-open. That way you are not so limited in requiring
validation of the full contract -- one party can verify simply that
whatever condition they care about holds on reaching that part of the
contract. E.g. maybe their signature is needed at the top level, and
then they don't care what further restrictions are placed.

On Tue, Oct 31, 2017 at 1:38 PM, Russell O'Connor via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> (sorry, I forgot to reply-all earlier)
>
> The very short answer to this question is that I plan on using Luke's
> fail-success-on-unknown-operation in Simplicity.  This is something that
> isn't detailed at all in the paper.
>
> The plan is that discounted jets will be explicitly labeled as jets in the
> commitment.  If you can provide a Merkle path from the root to a node that
> is an explicit jet, but that jet isn't among the finite number of known
> discounted jets, then the script is automatically successful (making it
> anyone-can-spend).  When new jets are wanted they can be soft-forked into
> the protocol (for example if we get a suitable quantum-resistant digital
> signature scheme) and the list of known discounted jets grows.  Old nodes
> get a merkle path to the new jet, which they view as an unknown jet, and
> allow the transaction as a anyone-can-spend transaction.  New nodes see a
> regular Simplicity redemption.  (I haven't worked out the details of how
the
> P2P protocol will negotiate with old nodes, but I don't forsee any
> problems.)
>
> Note that this implies that you should never participate in any Simplicity
> contract where you don't get access to the entire source code of all
> branches to check that it doesn't have an unknown jet.
>
> On Mon, Oct 30, 2017 at 5:42 PM, Matt Corallo <lf-lists at mattcorallo.com>
> wrote:
>>
>> I admittedly haven't had a chance to read the paper in full details, but
I
>> was curious how you propose dealing with "jets" in something like
Bitcoin.
>> AFAIU, other similar systems are left doing hard-forks to reduce the
>> sigops/weight/fee-cost of transactions every time they want to add useful
>> optimized drop-ins. For obvious reasons, this seems rather impractical
and a
>> potentially critical barrier to adoption of such optimized drop-ins,
which I
>> imagine would be required to do any new cryptographic algorithms due to
the
>> significant fee cost of interpreting such things.
>>
>> Is there some insight I'm missing here?
>>
>> Matt
>>
>>
>> On October 30, 2017 11:22:20 AM EDT, Russell O'Connor via bitcoin-dev
>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>> I've been working on the design and implementation of an alternative to
>>> Bitcoin Script, which I call Simplicity.  Today, I am presenting my
design
>>> at the PLAS 2017 Workshop on Programming Languages and Analysis for
>>> Security.  You find a copy of my Simplicity paper at
>>> https://blockstream.com/simplicity.pdf
>>>
>>> Simplicity is a low-level, typed, functional, native MAST language where
>>> programs are built from basic combinators.  Like Bitcoin Script,
Simplicity
>>> is designed to operate at the consensus layer.  While one can write
>>> Simplicity by hand, it is expected to be the target of one, or multiple,
>>> front-end languages.
>>>
>>> Simplicity comes with formal denotational semantics (i.e. semantics of
>>> what programs compute) and formal operational semantics (i.e. semantics
of
>>> how programs compute). These are both formalized in the Coq proof
assistant
>>> and proven equivalent.
>>>
>>> Formal denotational semantics are of limited value unless one can use
>>> them in practice to reason about programs. I've used Simplicity's formal
>>> semantics to prove correct an implementation of the SHA-256 compression
>>> function written in Simplicity.  I have also implemented a variant of
ECDSA
>>> signature verification in Simplicity, and plan to formally validate its
>>> correctness along with the associated elliptic curve operations.
>>>
>>> Simplicity comes with easy to compute static analyses that can compute
>>> bounds on the space and time resources needed for evaluation.  This is
>>> important for both node operators, so that the costs are knows before
>>> evaluation, and for designing Simplicity programs, so that
smart-contract
>>> participants can know the costs of their contract before committing to
it.
>>>
>>> As a native MAST language, unused branches of Simplicity programs are
>>> pruned at redemption time.  This enhances privacy, reduces the block
weight
>>> used, and can reduce space and time resource costs needed for
evaluation.
>>>
>>> To make Simplicity practical, jets replace common Simplicity expressions
>>> (identified by their MAST root) and directly implement them with C
code.  I
>>> anticipate developing a broad set of useful jets covering arithmetic
>>> operations, elliptic curve operations, and cryptographic operations
>>> including hashing and digital signature validation.
>>>
>>> The paper I am presenting at PLAS describes only the foundation of the
>>> Simplicity language.  The final design includes extensions not covered
in
>>> the paper, including
>>>
>>> - full convent support, allowing access to all transaction data.
>>> - support for signature aggregation.
>>> - support for delegation.
>>>
>>> Simplicity is still in a research and development phase.  I'm working to
>>> produce a bare-bones SDK that will include
>>>
>>> - the formal semantics and correctness proofs in Coq
>>> - a Haskell implementation for constructing Simplicity programs
>>> - and a C interpreter for Simplicity.
>>>
>>> After an SDK is complete the next step will be making Simplicity
>>> available in the Elements project so that anyone can start experimenting
>>> with Simplicity in sidechains. Only after extensive vetting would it be
>>> suitable to consider Simplicity for inclusion in Bitcoin.
>>>
>>> Simplicity has a long ways to go still, and this work is not intended to
>>> delay consideration of the various Merkelized Script proposals that are
>>> currently ongoing.
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20171031/dfe2ecf7/attachment-0001.html>

