From sergiolerner at certimix.com  Wed Apr  1 02:34:56 2015
From: sergiolerner at certimix.com (Sergio Lerner)
Date: Tue, 31 Mar 2015 23:34:56 -0300
Subject: [Bitcoin-development] "network disruption as a service" and
 proof of local storage
In-Reply-To: <2B8DBE05-E38E-433F-A4D2-A6D93D2FD4AA@taplink.co>
References: <55034205.4030607@localhost.local>
	<7854077.3GbzoT9yL1@crushinator>	<f903ef03dc8bb30873e0bbbb9b3786e9@webmail.mckay.com>	<2210650.iUsfZECcCc@crushinator>
	<2B8DBE05-E38E-433F-A4D2-A6D93D2FD4AA@taplink.co>
Message-ID: <551B5950.3030603@certimix.com>

Matt is right:  the goal is to prove digital copies of a public file.
Nothing more, nothing less.

Regarding the IP, I don't claim that every machine should provide the
protocol. Mobiles phones shouldn't. But machines that what to be
prioritized in some way or that want to be rewarded for hosting a node
should use a fixed IP. That's the cost of prioritization/reward. The
protocol could be a service bit, advertised in the version message.

My response to your comment below:

On 27/03/2015 03:40 p.m., Jeremy Spilman wrote:
>
> It would be extremely impressive to achieve a reliable mechanism for discerning a local copy exists under these constraints, particularly without false positives and false negatives, and without imposing very substantial one-time encoding costs, e.g. on par with doubling the verification cost. 
I see it differently. The asymmetric-time protocol is quite reliable. If
can be made to have almost no false positives/false negatives (not
considering rare communication problems, such as congestion and packet
loss for more than 5 seconds).
These are my back-of-the-envelope calculations:
Bitcoind takes approximately 1 second to serve a 1 Mb block (seek time,
but mostly transfer time)
Then decryption of a block can take 150 msec without problem (15%
overhead). The last N blocks could be cached so they don't need to be
decrypted to be sent.
In 150 msec a PC can decrypt a 1MB of data split over 1024-bit blocks
decrypted by modexp 3 (0.2 msec for 3 bigint multiplications), so a full
block can be decrypted.
Encrypting such block would take approximately 15 seconds (which is much
less than the 10 minutes available to encrypt each block)
Then the protocol works with a security margin of approximately 50x.
A communication problem during 5 seconds would be needed to disturb a
protocol of that takes 100 msec for the prover.

Regards,
 Sergio.





From laanwj at gmail.com  Thu Apr  2 08:11:24 2015
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Thu, 2 Apr 2015 10:11:24 +0200
Subject: [Bitcoin-development] Bitcoin Core 0.10.1 release candidate 1
	available
Message-ID: <20150402081123.GA29572@amethyst.visucore.com>

Binaries for bitcoin Core version 0.10.1rc1 are now available from:

  https://bitcoin.org/bin/0.10.1/test

Source code can be found in github under the tag

  https://github.com/bitcoin/bitcoin/tree/v0.10.1rc1

This is a release candidate for a minor version release, bringing bug fixes and
translation updates. Release candidates are test runs for releases, when no critical
problems are found the release candidate will be tagged as 0.10.1.

Please report bugs using the issue tracker at github:

  https://github.com/bitcoin/bitcoin/issues

Upgrading and downgrading
=========================

How to Upgrade
--------------

If you are running an older version, shut it down. Wait until it has completely
shut down (which might take a few minutes for older versions), then run the
installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or
bitcoind/bitcoin-qt (on Linux).

Downgrade warning
------------------

Because release 0.10.0 and later makes use of headers-first synchronization and
parallel block download (see further), the block files and databases are not
backwards-compatible with pre-0.10 versions of Bitcoin Core or other software:

* Blocks will be stored on disk out of order (in the order they are
received, really), which makes it incompatible with some tools or
other programs. Reindexing using earlier versions will also not work
anymore as a result of this.

* The block index database will now hold headers for which no block is
stored on disk, which earlier versions won't support.

If you want to be able to downgrade smoothly, make a backup of your entire data
directory. Without this your node will need start syncing (or importing from
bootstrap.dat) anew afterwards. It is possible that the data from a completely
synchronised 0.10 node may be usable in older versions as-is, but this is not
supported and may break as soon as the older version attempts to reindex.

This does not affect wallet forward or backward compatibility.

Notable changes
===============

This is a minor release and hence there are no notable changes.
For the notable changes in 0.10 refer to the release notes for the
0.10.0 release at https://github.com/bitcoin/bitcoin/blob/v0.10.0/doc/release-notes.md

0.10.1 Change log
=================

Detailed release notes follow. This overview includes changes that affect external
behavior, not code moves, refactors or string updates.

RPC:
- `7f502be` fix crash: createmultisig and addmultisigaddress

Block (database) and transaction handling:
- `1d2cdd2` Fix InvalidateBlock to add chainActive.Tip to setBlockIndexCandidates
- `c91c660` fix InvalidateBlock to repopulate setBlockIndexCandidates
- `002c8a2` fix possible block db breakage during re-index
- `a1f425b` Add (optional) consistency check for the block chain data structures

P2P protocol and network code:
- `78f64ef` don't trickle for whitelisted nodes
- `ca301bf` Reduce fingerprinting through timestamps in 'addr' messages.
- `200f293` Ignore getaddr messages on Outbound connections.
- `d5d8998` Limit message sizes before transfer
- `aeb9279` Better fingerprinting protection for non-main-chain getdatas.
- `cf0218f` Make addrman's bucket placement deterministic (countermeasure 1 against eclipse attacks, see http://cs-people.bu.edu/heilman/eclipse/)
- `0c6f334` Always use a 50% chance to choose between tried and new entries (countermeasure 2 against eclipse attacks)
- `214154e` Do not bias outgoing connections towards fresh addresses (countermeasure 2 against eclipse attacks)
- `aa587d4` Scale up addrman (countermeasure 6 against eclipse attacks)

Validation:
- `d148f62` Acquire CCheckQueue's lock to avoid race condition

Build system:
- `8752b5c` 0.10 fix for crashes on OSX 10.6

Wallet:
- N/A

GUI:
- `2c08406` some mac specifiy cleanup (memory handling, unnecessary code)
- `81145a6` fix OSX dock icon window reopening
- `786cf72` fix a issue where "command line options"-action overwrite "Preference"-action (on OSX)

Tests:
- `1117378` add RPC test for InvalidateBlock

Miscellaneous:
- `c9e022b` Initialization: set Boost path locale in main thread
- `23126a0` Sanitize command strings before logging them.

Credits
=======

Thanks to everyone who contributed to this release:

- Alex Morcos
- Cory Fields
- dexX7
- fsb4000
- Gregory Maxwell
- Ivan Pustogarov
- Jonas Schnelli
- Pieter Wuille
- Ruben de Vries
- Suhas Daftuar
- Wladimir J. van der Laan

As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).




From jeanpaulkogelman at me.com  Tue Apr  7 21:32:52 2015
From: jeanpaulkogelman at me.com (Jean-Paul Kogelman)
Date: Tue, 07 Apr 2015 21:32:52 +0000 (GMT)
Subject: [Bitcoin-development] =?utf-8?q?_PAPER=3A_New_algorithm_for_the_d?=
 =?utf-8?q?iscrete_logarithm_problem_on_elliptic_curves?=
Message-ID: <9764d2ea-942c-4eef-8a07-d4e740977c0a@me.com>

FYI,

https://eprint.iacr.org/2015/310.pdf

jp
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150407/f1e62e19/attachment.html>

From gmaxwell at gmail.com  Tue Apr  7 21:37:15 2015
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Tue, 7 Apr 2015 21:37:15 +0000
Subject: [Bitcoin-development] PAPER: New algorithm for the discrete
 logarithm problem on elliptic curves
In-Reply-To: <9764d2ea-942c-4eef-8a07-d4e740977c0a@me.com>
References: <9764d2ea-942c-4eef-8a07-d4e740977c0a@me.com>
Message-ID: <CAAS2fgQ_4S2MWKEMd948MxbgPSojXKHfgGbrq=SqFmz5Tkipeg@mail.gmail.com>

On Tue, Apr 7, 2015 at 9:32 PM, Jean-Paul Kogelman
<jeanpaulkogelman at me.com> wrote:
> https://eprint.iacr.org/2015/310.pdf

http://www.reddit.com/r/Bitcoin/comments/31rcuo/new_algorithm_for_the_discrete_logarithm_problem/cq4b52u



From jeanpaulkogelman at me.com  Tue Apr  7 21:49:06 2015
From: jeanpaulkogelman at me.com (Jean-Paul Kogelman)
Date: Tue, 07 Apr 2015 21:49:06 +0000 (GMT)
Subject: [Bitcoin-development] =?utf-8?q?_Re=3A__PAPER=3A_New_algorithm_fo?=
 =?utf-8?q?r_the_discrete_logarithm_problem_on_elliptic_curves?=
Message-ID: <fe7fe2c8-ac93-453d-8ecf-930df2874e9a@me.com>

Ok, false alarm. :)

Sorry for the spam.

On Apr 07, 2015, at 02:37 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:

On Tue, Apr 7, 2015 at 9:32 PM, Jean-Paul Kogelman
<jeanpaulkogelman at me.com> wrote:
https://eprint.iacr.org/2015/310.pdf

http://www.reddit.com/r/Bitcoin/comments/31rcuo/new_algorithm_for_the_discrete_logarithm_problem/cq4b52u
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150407/40e2d52d/attachment.html>

From brianchoffman at gmail.com  Tue Apr  7 22:15:36 2015
From: brianchoffman at gmail.com (Brian Hoffman)
Date: Tue, 7 Apr 2015 18:15:36 -0400
Subject: [Bitcoin-development] PAPER: New algorithm for the discrete
	logarithm problem on elliptic curves
In-Reply-To: <fe7fe2c8-ac93-453d-8ecf-930df2874e9a@me.com>
References: <fe7fe2c8-ac93-453d-8ecf-930df2874e9a@me.com>
Message-ID: <FBFC5BB1-0A9B-466A-BBFF-6F724D7F617F@gmail.com>

That was easy.


> On Apr 7, 2015, at 5:49 PM, Jean-Paul Kogelman <jeanpaulkogelman at me.com> wrote:
> 
> Ok, false alarm. :)
> 
> Sorry for the spam.
> 
>> On Apr 07, 2015, at 02:37 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:
>> 
> 
>> On Tue, Apr 7, 2015 at 9:32 PM, Jean-Paul Kogelman
>> <jeanpaulkogelman at me.com> wrote:
>>> https://eprint.iacr.org/2015/310.pdf
>> 
>> http://www.reddit.com/r/Bitcoin/comments/31rcuo/new_algorithm_for_the_discrete_logarithm_problem/cq4b52u
> ------------------------------------------------------------------------------
> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT
> Develop your own process in accordance with the BPMN 2 standard
> Learn Process modeling best practices with Bonita BPM through live exercises
> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual- event?utm_
> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150407/c89e1df3/attachment.html>

From kefkius at maza.club  Wed Apr  8 07:05:43 2015
From: kefkius at maza.club (Kefkius)
Date: Wed, 08 Apr 2015 03:05:43 -0400
Subject: [Bitcoin-development] Request For Discussion / BIP number -
 Multi-Currency Hierarchy For Use In Multisignature Deterministic Wallets
Message-ID: <5524D347.4040507@maza.club>

I have a potential BIP, "Multi-Currency Hierarchy For Use In
Multisignature Deterministic Wallets." I'm requesting discussion on it,
and possibly assignment of a BIP number.

It's located in this github gist:
https://gist.github.com/Kefkius/1aa02945e532f8739023



From swansontec at gmail.com  Wed Apr  8 07:46:43 2015
From: swansontec at gmail.com (William Swanson)
Date: Wed, 8 Apr 2015 00:46:43 -0700
Subject: [Bitcoin-development] Request For Discussion / BIP number -
 Multi-Currency Hierarchy For Use In Multisignature Deterministic Wallets
In-Reply-To: <5524D347.4040507@maza.club>
References: <5524D347.4040507@maza.club>
Message-ID: <CABjHNoTbLz+dCPkctk95jPkdnagQQxOintYgswKCE6wB=TS9xg@mail.gmail.com>

It's not really clear why this is better than BIP 44 as it already
stands. You have the same fields, but they are just in a different
order. Couldn't you just use the existing BIP 44 hierarchy, but add
the convention that "wallet/account N" is the same wallet in each
supported currency?

For example, if I have a wallet called "business expenses", which
happens to be wallet m / 44' / 0' / 5', for Bitcoin, then the same
wallet would be m / 44' / 3' / 5' for Dogecoin, and m / 44' / 2' / 5'
for Litecoin.

I am trying to think of examples where your proposal is better than
BIP 44, but I can't think of any. Even backup recovery works fine. I
assume that your idea is to continue iterating over the different
wallet indices as long as you are finding funds in *any* currency.
Well, you can still do that with BIP 44. The fields are in a different
order, but that doesn't affect the algorithm in any way.

Maybe you have some deeper insight I'm not seeing, but if so, you need
to clearly explain that in your motivation section. The current
explanation, "This limits the possible implementations of
multi-currency, multisignature wallets," is pretty vauge. Also, there
is nothing in this spec that addresses the multisignature use-case.
The BIP 45 spec does a lot of extra work to make multisignature work
smoothly.

I'm not trying to criticize your proposal. I'm just trying to
understand what it's trying to accomplish.

-William Swanson


On Wed, Apr 8, 2015 at 12:05 AM, Kefkius <kefkius at maza.club> wrote:
> I have a potential BIP, "Multi-Currency Hierarchy For Use In
> Multisignature Deterministic Wallets." I'm requesting discussion on it,
> and possibly assignment of a BIP number.
>
> It's located in this github gist:
> https://gist.github.com/Kefkius/1aa02945e532f8739023
>
> ------------------------------------------------------------------------------
> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT
> Develop your own process in accordance with the BPMN 2 standard
> Learn Process modeling best practices with Bonita BPM through live exercises
> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual- event?utm_
> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development



From kinoshitajona at gmail.com  Wed Apr  8 16:28:42 2015
From: kinoshitajona at gmail.com (=?UTF-8?B?5pyo44OO5LiL44GY44KH44Gq?=)
Date: Thu, 9 Apr 2015 01:28:42 +0900
Subject: [Bitcoin-development] Request For Discussion / BIP number -
 Multi-Currency Hierarchy For Use In Multisignature Deterministic Wallets
In-Reply-To: <CABjHNoTbLz+dCPkctk95jPkdnagQQxOintYgswKCE6wB=TS9xg@mail.gmail.com>
References: <5524D347.4040507@maza.club>
	<CABjHNoTbLz+dCPkctk95jPkdnagQQxOintYgswKCE6wB=TS9xg@mail.gmail.com>
Message-ID: <CACvEmnE6jgeRmTbyoOfW+jf=EB_EmPN4FdBXz-anm4tfKJscqw@mail.gmail.com>

William,

I believe the reasoning for this is stated in the Coin Type section.

"Public derivation is used so that cosigners need only know one of each
other's public keys, rather than needing to distribute public keys for each
coin."

BIP44 has a coin level, but it's a private derived level, so cosigners
would not be able to generate multiple crypto currencies of each others'
without giving each other n xpubs where n is the number of currencies
shared. This new proposal basically sticks coin type on the public
derivation side of things so that I could generate litecoin or darkcoin
multisigs without your permission...

Kefkius,

This BIP seems like a good fit for multi-currency wallets based on
multisig. So kudos for putting it in writing.

However, I don't know if this is really a BIP thing. It's not improving
Bitcoin (Bitcoin Improvement Proposal... remember?), in fact, by definition
it is improving altcoin usability.

For that reason alone I will say I disagree for a BIP for this.
- Jona


2015-04-08 16:46 GMT+09:00 William Swanson <swansontec at gmail.com>:
>
> It's not really clear why this is better than BIP 44 as it already
> stands. You have the same fields, but they are just in a different
> order. Couldn't you just use the existing BIP 44 hierarchy, but add
> the convention that "wallet/account N" is the same wallet in each
> supported currency?
>
> For example, if I have a wallet called "business expenses", which
> happens to be wallet m / 44' / 0' / 5', for Bitcoin, then the same
> wallet would be m / 44' / 3' / 5' for Dogecoin, and m / 44' / 2' / 5'
> for Litecoin.
>
> I am trying to think of examples where your proposal is better than
> BIP 44, but I can't think of any. Even backup recovery works fine. I
> assume that your idea is to continue iterating over the different
> wallet indices as long as you are finding funds in *any* currency.
> Well, you can still do that with BIP 44. The fields are in a different
> order, but that doesn't affect the algorithm in any way.
>
> Maybe you have some deeper insight I'm not seeing, but if so, you need
> to clearly explain that in your motivation section. The current
> explanation, "This limits the possible implementations of
> multi-currency, multisignature wallets," is pretty vauge. Also, there
> is nothing in this spec that addresses the multisignature use-case.
> The BIP 45 spec does a lot of extra work to make multisignature work
> smoothly.
>
> I'm not trying to criticize your proposal. I'm just trying to
> understand what it's trying to accomplish.
>
> -William Swanson
>
>
> On Wed, Apr 8, 2015 at 12:05 AM, Kefkius <kefkius at maza.club> wrote:
> > I have a potential BIP, "Multi-Currency Hierarchy For Use In
> > Multisignature Deterministic Wallets." I'm requesting discussion on it,
> > and possibly assignment of a BIP number.
> >
> > It's located in this github gist:
> > https://gist.github.com/Kefkius/1aa02945e532f8739023
> >
> >
------------------------------------------------------------------------------
> > BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT
> > Develop your own process in accordance with the BPMN 2 standard
> > Learn Process modeling best practices with Bonita BPM through live
exercises
> > http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual-
event?utm_
> > source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF
> > _______________________________________________
> > Bitcoin-development mailing list
> > Bitcoin-development at lists.sourceforge.net
> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
------------------------------------------------------------------------------
> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT
> Develop your own process in accordance with the BPMN 2 standard
> Learn Process modeling best practices with Bonita BPM through live
exercises
> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual-
event?utm_
> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development




--
-----BEGIN PGP PUBLIC KEY BLOCK-----
Comment: http://openpgpjs.org

xsBNBFTmJ8oBB/9rd+7XLxZG/x/KnhkVK2WBG8ySx91fs+qQfHIK1JrakSV3
x6x0cK3XLClASLLDomm7Od3Q/fMFzdwCEqj6z60T8wgKxsjWYSGL3mq8ucdv
iBjC3wGauk5dQKtT7tkCFyQQbX/uMsBM4ccGBICoDmIJlwJIj7fAZVqGxGOM
bO1RhYb4dbQA2qxYP7wSsHJ6/ZNAXyEphOj6blUzdqO0exAbCOZWWF+E/1SC
EuKO4RmL7Imdep7uc2Qze1UpJCZx7ASHl2IZ4UD0G3Qr3pI6/jvNlaqCTa3U
3/YeJwEubFsd0AVy0zs809RcKKgX3W1q+hVDTeWinem9RiOG/vT+Eec/ABEB
AAHNI2tpbm9zaGl0YSA8a2lub3NoaXRham9uYUBnbWFpbC5jb20+wsByBBAB
CAAmBQJU5ifRBgsJCAcDAgkQRB9iZ30dlisEFQgCCgMWAgECGwMCHgEAAC6Z
B/9otobf0ASHYdlUBeIPXdDopyjQhR2RiZGYaS0VZ5zzHYLDDMW6ZIYm5CjO
Fc09ETLGKFxH2RcCOK2dzwz+KRU4xqOrt/l5gyd50cFE1nOhUN9+/XaPgrou
WhyT9xLeGit7Xqhht93z2+VanTtJAG6lWbAZLIZAMGMuLX6sJDCO0GiO5zxa
02Q2D3kh5GL57A5+oVOna12JBRaIA5eBGKVCp3KToT/z48pxBe3WAmLo0zXr
hEgTSzssfb2zTwtB3Ogoedj+cU2bHJvJ8upS/jMr3TcdguySmxJlGpocVC/e
qxq12Njv+LiETOrD8atGmXCnA+nFNljBkz+l6ADl93jHzsBNBFTmJ9EBCACu
Qq9ZnP+aLU/Rt6clAfiHfTFBsJvLKsdIKeE6qHzsU1E7A7bGQKTtLEnhCCQE
W+OQP+sgbOWowIdH9PpwLJ3Op+NhvLlMxRvbT36LwCmBL0yD7bMqxxmmVj8n
vlMMRSe4wDSIG19Oy7701imnHZPm/pnPlneg/Meu/UffpcDWYBbAFX8nrXPY
vkVULcI/qTcCxW/+S9fwoXjQhWHaiJJ6y3cYOSitN31W9zgcMvLwLX3JgDxE
flkwq/M+ZkfCYnS3GAPEt8GkVKy2eHtCJuNkGFlCAmKMX0yWzHRAkqOMN5KP
LFbkKY2GQl13ztWp82QYJZpj5af6dmyUosurn6AZABEBAAHCwF8EGAEIABMF
AlTmJ9QJEEQfYmd9HZYrAhsMAABKbgf/Ulu5JAk4fXgH0DtkMmdkFiKEFdkW
0Wkw7Vhd5eZ4NzeP9kOkD01OGweT9hqzwhfT2CNXCGxh4UnvEM1ZMFypIKdq
0XpLLJMrDOQO021UjAa56vHZPAVmAM01z5VzHJ7ekjgwrgMLmVkm0jWKEKaO
n/MW7CyphG7QcZ6cJX2f6uJcekBlZRw9TNYRnojMjkutlOVhYJ3J78nc/k0p
kcgV63GB6D7wHRF4TVe4xIBqKpbBhhN+ISwFN1z+gx3lfyRMSmiTSrGdKEQe
XSIQKG8XZQZUDhLNkqPS+7EMV1g7+lOfT4GhLL68dUXDa1e9YxGH6zkpVECw
Spe3vsHZr6CqFg==
=/vUJ
-----END PGP PUBLIC KEY BLOCK-----
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150409/a0f5b1a6/attachment.html>

From swansontec at gmail.com  Wed Apr  8 16:41:00 2015
From: swansontec at gmail.com (William Swanson)
Date: Wed, 8 Apr 2015 09:41:00 -0700
Subject: [Bitcoin-development] Request For Discussion / BIP number -
 Multi-Currency Hierarchy For Use In Multisignature Deterministic Wallets
In-Reply-To: <CACvEmnE6jgeRmTbyoOfW+jf=EB_EmPN4FdBXz-anm4tfKJscqw@mail.gmail.com>
References: <5524D347.4040507@maza.club>
	<CABjHNoTbLz+dCPkctk95jPkdnagQQxOintYgswKCE6wB=TS9xg@mail.gmail.com>
	<CACvEmnE6jgeRmTbyoOfW+jf=EB_EmPN4FdBXz-anm4tfKJscqw@mail.gmail.com>
Message-ID: <CABjHNoR_Tg6bq3mJ8vkFAOPNHz8RS-FKAEx9APMZAVhct5H0SA@mail.gmail.com>

Oops, sorry I missed that.

Since that's the reason this proposal exists, I would consider putting
it right up top where people can see it. Also, since this proposal is
specifically designed for multi-sig, I would look at what BIP45 is
doing and maybe incorporate a "cosigner_index" branch. Otherwise, this
idea seems like a reasonable way to organize a wallet.

-William

On Wed, Apr 8, 2015 at 9:28 AM, ?????? <kinoshitajona at gmail.com> wrote:
> William,
>
> I believe the reasoning for this is stated in the Coin Type section.
>
> "Public derivation is used so that cosigners need only know one of each
> other's public keys, rather than needing to distribute public keys for each
> coin."
>
> BIP44 has a coin level, but it's a private derived level, so cosigners would
> not be able to generate multiple crypto currencies of each others' without
> giving each other n xpubs where n is the number of currencies shared. This
> new proposal basically sticks coin type on the public derivation side of
> things so that I could generate litecoin or darkcoin multisigs without your
> permission...
>
> Kefkius,
>
> This BIP seems like a good fit for multi-currency wallets based on multisig.
> So kudos for putting it in writing.
>
> However, I don't know if this is really a BIP thing. It's not improving
> Bitcoin (Bitcoin Improvement Proposal... remember?), in fact, by definition
> it is improving altcoin usability.
>
> For that reason alone I will say I disagree for a BIP for this.
> - Jona
>
>
> 2015-04-08 16:46 GMT+09:00 William Swanson <swansontec at gmail.com>:
>>
>> It's not really clear why this is better than BIP 44 as it already
>> stands. You have the same fields, but they are just in a different
>> order. Couldn't you just use the existing BIP 44 hierarchy, but add
>> the convention that "wallet/account N" is the same wallet in each
>> supported currency?
>>
>> For example, if I have a wallet called "business expenses", which
>> happens to be wallet m / 44' / 0' / 5', for Bitcoin, then the same
>> wallet would be m / 44' / 3' / 5' for Dogecoin, and m / 44' / 2' / 5'
>> for Litecoin.
>>
>> I am trying to think of examples where your proposal is better than
>> BIP 44, but I can't think of any. Even backup recovery works fine. I
>> assume that your idea is to continue iterating over the different
>> wallet indices as long as you are finding funds in *any* currency.
>> Well, you can still do that with BIP 44. The fields are in a different
>> order, but that doesn't affect the algorithm in any way.
>>
>> Maybe you have some deeper insight I'm not seeing, but if so, you need
>> to clearly explain that in your motivation section. The current
>> explanation, "This limits the possible implementations of
>> multi-currency, multisignature wallets," is pretty vauge. Also, there
>> is nothing in this spec that addresses the multisignature use-case.
>> The BIP 45 spec does a lot of extra work to make multisignature work
>> smoothly.
>>
>> I'm not trying to criticize your proposal. I'm just trying to
>> understand what it's trying to accomplish.
>>
>> -William Swanson
>>
>>
>> On Wed, Apr 8, 2015 at 12:05 AM, Kefkius <kefkius at maza.club> wrote:
>> > I have a potential BIP, "Multi-Currency Hierarchy For Use In
>> > Multisignature Deterministic Wallets." I'm requesting discussion on it,
>> > and possibly assignment of a BIP number.
>> >
>> > It's located in this github gist:
>> > https://gist.github.com/Kefkius/1aa02945e532f8739023



From stephencalebmorse at gmail.com  Wed Apr  8 19:50:02 2015
From: stephencalebmorse at gmail.com (Stephen Morse)
Date: Wed, 8 Apr 2015 15:50:02 -0400
Subject: [Bitcoin-development] Build your own nHashType
Message-ID: <CABHVRKTNFoLm9LEO=ctT_UP9zW7QOMQzVXitKC=PAzj=HG9OHg@mail.gmail.com>

Seeking feedback on a proposal that will allow a transaction signer to
explicitly specify what is to be serialized for the signature hash. The
basic idea is to make the nHashType general enough that we won't need a new
sighash flag every time a new use case comes up.

If implemented into bitcoin (via a soft fork), this would make malleability
almost a non-issue (the TXID referenced by inputs just need to be updated
previous TX changes) and would enable hardware wallets to securely sign
without needing to download/process each transaction it spends from.

Please let me know your thoughts.

https://github.com/scmorse/bitcoin-misc/blob/master/sighash_proposal.md
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150408/268ef2b5/attachment.html>

From adrian at coinbase.com  Thu Apr  9 06:28:08 2015
From: adrian at coinbase.com (Adrian Macneil)
Date: Wed, 8 Apr 2015 23:28:08 -0700
Subject: [Bitcoin-development] Double spending and replace by fee
In-Reply-To: <FEB90DA4-2BF3-460F-8F35-9BCE929A2A31@petertodd.org>
References: <CANEZrP3Prp6EFUdH_VDWkq508HkeFBMn+swzZ9ycAMsrOazFZA@mail.gmail.com>
	<FEB90DA4-2BF3-460F-8F35-9BCE929A2A31@petertodd.org>
Message-ID: <C92CBBFE-A967-457B-B356-AF85F7BE8936@coinbase.com>

Fwiw, Coinbase relies on the current first-seen mempool behaviour. Wide adoption of RBF (without a suitable replacement available) would make it extremely difficult to pitch bitcoin as a viable alternative to credit cards payments to large merchants.

Adrian

> On Mar 28, 2015, at 7:22 AM, Peter Todd <pete at petertodd.org> wrote:
> 
> Signed PGP part
> Would you so us all a favor and make a list of companies *actually* relying on "first-seen" mempool behaviour. Because I've been having a hard time actually finding anyone who does who hasn't given up on it. Not very useful to talk about attacks against hypothetical defences.
> 
> On 28 March 2015 09:58:53 GMT-04:00, Mike Hearn <mike at plan99.net> wrote:
> >I've written a couple of blog posts on replace by fee and double
> >spending
> >mitigations. They sum up the last few years (!) worth of discussions on
> >this list and elsewhere, from my own perspective.
> >
> >I make no claim to be comprehensive or unbiased but I keep being asked
> >about these topics so figured I'd just write up my thoughts once so I
> >can
> >send links instead of answers :) And then so can anyone who happens to
> >agree.
> >
> >(1) Replace by fee scorched earth, a counter argument:
> >
> >https://medium.com/@octskyward/replace-by-fee-43edd9a1dd6d
> >
> >This article lays out the case against RBF-SE and argues it is harmful
> >to
> >Bitcoin.
> >
> >(2) Double spending and how to make it harder:
> >
> >https://medium.com/@octskyward/double-spending-in-bitcoin-be0f1d1e8008
> >
> >This article summarises a couple of double spending incidents against
> >merchants and then discusses the following techniques:
> >
> >   1. Risk analysis of transactions
> >   2. Payment channels
> >   3. Countersigning by a trusted third party
> >   4. Remote attestation
> >   5. ID verification
> >   6. Waiting for confirmations
> >   7. Punishment of double spending blocks
> >
> >I hope the material is useful / interesting.
> >
> >
> >------------------------------------------------------------------------
> >
> >------------------------------------------------------------------------------
> >Dive into the World of Parallel Programming The Go Parallel Website,
> >sponsored
> >by Intel and developed in partnership with Slashdot Media, is your hub
> >for all
> >things parallel software development, from weekly thought leadership
> >blogs to
> >news, videos, case studies, tutorials and more. Take a look and join
> >the
> >conversation now. http://goparallel.sourceforge.net/
> >
> >------------------------------------------------------------------------
> >
> >_______________________________________________
> >Bitcoin-development mailing list
> >Bitcoin-development at lists.sourceforge.net
> >https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> 
> 
> 
> ------------------------------------------------------------------------------
> Dive into the World of Parallel Programming The Go Parallel Website, sponsored
> by Intel and developed in partnership with Slashdot Media, is your hub for all
> things parallel software development, from weekly thought leadership blogs to
> news, videos, case studies, tutorials and more. Take a look and join the
> conversation now. http://goparallel.sourceforge.net/
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 801 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150408/35a58f48/attachment.sig>

From mike at plan99.net  Thu Apr  9 11:29:43 2015
From: mike at plan99.net (Mike Hearn)
Date: Thu, 9 Apr 2015 13:29:43 +0200
Subject: [Bitcoin-development] Build your own nHashType
In-Reply-To: <CABHVRKTNFoLm9LEO=ctT_UP9zW7QOMQzVXitKC=PAzj=HG9OHg@mail.gmail.com>
References: <CABHVRKTNFoLm9LEO=ctT_UP9zW7QOMQzVXitKC=PAzj=HG9OHg@mail.gmail.com>
Message-ID: <CANEZrP12kZ8vRAo=feprJ9_oRXUPKJ=iF6kZdxxbai=TxjzM9g@mail.gmail.com>

Hi Stephen,

It's an interesting idea. I'm not sure that all the combinations make
sense. Excluding the connected output script or value but still signing the
prev tx hash appears pointless: the script cannot change anyway, and you
still need to know what it is to actually calculate the inputs to it, so
what is the point of this?

I also worry that quite a few of these combinations could be unexpectedly
dangerous. If you don't sign the prevout hash or value and combine it with
a regular pay-to-address output then you've effectively written a blank
cheque that can be used by anyone, to claim any money ever sent to that
address ... no? And then any p2p node or miner could do so, making the
transaction pretty useless.

That isn't inherently a problem as long as people understand which
combinations have what effects or cannot be used for various reasons. But
it would need good documentation and careful thought to explore each
possibility people might use.

I'll leave the soft fork business to one side for now. I think any change
in CHECKSIG or new version of it would likely be ready around the same time
as the hard fork we need for changing the block size limit anyway, and it's
much cleaner to do it that way.

The most important change that we need in sighash calculation, IMO, is
ensuring that you don't have to hash data over and over again without a
good reason. The current sighash definition is unfortunate because it's
possible to make small transactions that involve hashing huge amounts of
data. It's not clear to me that your proposal fixes that: ideally there
would be one exactly one sighash for one transaction no matter how many
checksigs are involved in verifying it.

thanks,
-mike
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150409/4579e124/attachment.html>

From stephencalebmorse at gmail.com  Thu Apr  9 14:10:43 2015
From: stephencalebmorse at gmail.com (Stephen Morse)
Date: Thu, 9 Apr 2015 10:10:43 -0400
Subject: [Bitcoin-development] Build your own nHashType
In-Reply-To: <CANEZrP12kZ8vRAo=feprJ9_oRXUPKJ=iF6kZdxxbai=TxjzM9g@mail.gmail.com>
References: <CABHVRKTNFoLm9LEO=ctT_UP9zW7QOMQzVXitKC=PAzj=HG9OHg@mail.gmail.com>
	<CANEZrP12kZ8vRAo=feprJ9_oRXUPKJ=iF6kZdxxbai=TxjzM9g@mail.gmail.com>
Message-ID: <CABHVRKSET18D13+yi4MTPs6+4xwUD5vuJszCOJG9CaTi0+CAvA@mail.gmail.com>

Hi Mike,

Hi Stephen,
>
> It's an interesting idea. I'm not sure that all the combinations make
> sense. Excluding the connected output script or value but still signing the
> prev tx hash appears pointless: the script cannot change anyway, and you
> still need to know what it is to actually calculate the inputs to it, so
> what is the point of this?
>

That's a good point, maybe SIGHASH_WITHOUT_PREV_SCRIPTPUBKEY and
SIGHASH_WITHOUT_PREV_VALUE should be assumed false, since you need the data
anyway. That gets the total number of flags down to 17. If we eliminate
SIGHASH_WITHOUT_TX_VERSION (I can't think of any good reason for this one),
then we're down to a 2-byte nHashType. SIGHASH_SIGN_STACK_ELEMENT could
also be removed, I'm not convinced of the usefulness of that one either.


>
> I also worry that quite a few of these combinations could be unexpectedly
> dangerous. If you don't sign the prevout hash or value and combine it with
> a regular pay-to-address output then you've effectively written a blank
> cheque that can be used by anyone, to claim any money ever sent to that
> address ... no? And then any p2p
>
node or miner could do so, making the transaction pretty useless.
>
> That isn't inherently a problem as long as people understand which
> combinations have what effects or cannot be used for various reasons. But
> it would need good documentation and careful thought to explore each
> possibility people might use.
>

I don't think it's quite a blank check, but it would enable replay attacks
in the form of sending the money to the same place it was sent before if an
address ever receives coins again. Almost like auto-forwarding addresses.
If, in addition, you signed with just that input and no outputs as well,
then you're basically forfeiting your rights to any coins sent to that
address.

It allows for some dangerous combinations, but we already have some
dangerous nHashTypes. e.g. SIGHASH_NONE | SIGHASH_ANYONECANPAY. Good
documentation and careful developers shouldn't have any issues if they use
a standard set of sighash flag combinations for their standard use cases.
But developers that need special combinations can now use them, so long as
they are careful and think things through.


>
> I'll leave the soft fork business to one side for now. I think any change
> in CHECKSIG or new version of it would likely be ready around the same time
> as the hard fork we need for changing the block size limit anyway, and it's
> much cleaner to do it that way.
>
> The most important change that we need in sighash calculation, IMO, is
> ensuring that you don't have to hash data over and over again without a
> good reason. The current sighash definition is unfortunate because it's
> possible to make small transactions that involve hashing huge amounts of
> data. It's not clear to me that your proposal fixes that: ideally there
> would be one exactly one sighash for one transaction no matter how many
> checksigs are involved in verifying it.
>
>
It's hard, though, because there is different data needs to be signed for
each input. Although, I suppose if you signed your input with
SIGHASH_WITHOUT_PREV_SCRIPTPUBKEY, SIGHASH_WITHOUT_PREV_VALUE, and the
equivalent of SIGHASH_ALL, then the hash that needs to be signed would be
the same for all of your inputs. Strangely enough, I think we might have
just found use cases for the flags that we had nearly dismissed.

Another possibility would be to put the previous scriptPubKey and previous
output value at the END of the serialized transaction, so that you could
make use of some sort of a signature hash midstate. But that feels a little
messy. It sort of makes sense to have a base serialization for a
transaction and then append it with whatever input/output specific
information you have, but still, messy.

Is hashing transaction data once for each input really a huge bottleneck,
though? Do mobile devices have an issue with this?

Best,
Stephen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150409/8fc6b376/attachment.html>

From mike at plan99.net  Thu Apr  9 14:45:35 2015
From: mike at plan99.net (Mike Hearn)
Date: Thu, 9 Apr 2015 16:45:35 +0200
Subject: [Bitcoin-development] Build your own nHashType
In-Reply-To: <CABHVRKSET18D13+yi4MTPs6+4xwUD5vuJszCOJG9CaTi0+CAvA@mail.gmail.com>
References: <CABHVRKTNFoLm9LEO=ctT_UP9zW7QOMQzVXitKC=PAzj=HG9OHg@mail.gmail.com>
	<CANEZrP12kZ8vRAo=feprJ9_oRXUPKJ=iF6kZdxxbai=TxjzM9g@mail.gmail.com>
	<CABHVRKSET18D13+yi4MTPs6+4xwUD5vuJszCOJG9CaTi0+CAvA@mail.gmail.com>
Message-ID: <CANEZrP3mBibjUK99L=E9jHFAvQ0QLpx0ke112=yQjw-RhjWnyg@mail.gmail.com>

>
> I don't think it's quite a blank check, but it would enable replay attacks
> in the form of sending the money to the same place it was sent before if an
> address ever receives coins again.
>

Right, good point. I wonder if this sort of auto forwarding could even be a
useful feature. I can't think of one right now.


> It's hard, though, because there is different data needs to be signed for
> each input.
>

Yes but is that fundamental or is there a way to avoid it? That's what I'm
getting at.


> Another possibility would be to put the previous scriptPubKey and previous
> output value at the END of the serialized transaction, so that you could
> make use of some sort of a signature hash midstate.
>

Interesting idea! I don't agree it's messy. If anything it should be
simpler than what we have today - the need to edit a transaction *in the
middle* means that sighash computation involves constantly reserializing a
transaction before it even gets to be hashed.


> Is hashing transaction data once for each input really a huge bottleneck,
> though? Do mobile devices have an issue with this?
>

Consider what happens with very large transactions, like a big assurance
contract that might have thousands of inputs and be multiple megabytes in
size. Obviously such large transactions cannot happen today, but there is
user demand for giant contracts (or at least, users tell me there is,
whether they'd actually do it for real is a bit unclear).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150409/faa89170/attachment.html>

From jgarzik at bitpay.com  Thu Apr  9 14:22:52 2015
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Thu, 9 Apr 2015 07:22:52 -0700
Subject: [Bitcoin-development] Build your own nHashType
In-Reply-To: <CABHVRKSET18D13+yi4MTPs6+4xwUD5vuJszCOJG9CaTi0+CAvA@mail.gmail.com>
References: <CABHVRKTNFoLm9LEO=ctT_UP9zW7QOMQzVXitKC=PAzj=HG9OHg@mail.gmail.com>
	<CANEZrP12kZ8vRAo=feprJ9_oRXUPKJ=iF6kZdxxbai=TxjzM9g@mail.gmail.com>
	<CABHVRKSET18D13+yi4MTPs6+4xwUD5vuJszCOJG9CaTi0+CAvA@mail.gmail.com>
Message-ID: <CAJHLa0NgV=6D=TAy4sm_EAfYiZULK-d9GMcddW1-DZRHCE8Sew@mail.gmail.com>

On Thu, Apr 9, 2015 at 7:10 AM, Stephen Morse <stephencalebmorse at gmail.com>
wrote:

> Is hashing transaction data once for each input really a huge bottleneck,
> though? Do mobile devices have an issue with this?
>


Think about what slow transaction verification speed means.  Slower
propagation across the network.  More work per node.  Greater opportunity
for algorithmic attacks, races and other shenanigans by attackers.

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150409/dbb8cb15/attachment.html>

From pete at petertodd.org  Thu Apr  9 17:28:09 2015
From: pete at petertodd.org (Peter Todd)
Date: Thu, 9 Apr 2015 13:28:09 -0400
Subject: [Bitcoin-development] Build your own nHashType
In-Reply-To: <CAJHLa0NgV=6D=TAy4sm_EAfYiZULK-d9GMcddW1-DZRHCE8Sew@mail.gmail.com>
References: <CABHVRKTNFoLm9LEO=ctT_UP9zW7QOMQzVXitKC=PAzj=HG9OHg@mail.gmail.com>
	<CANEZrP12kZ8vRAo=feprJ9_oRXUPKJ=iF6kZdxxbai=TxjzM9g@mail.gmail.com>
	<CABHVRKSET18D13+yi4MTPs6+4xwUD5vuJszCOJG9CaTi0+CAvA@mail.gmail.com>
	<CAJHLa0NgV=6D=TAy4sm_EAfYiZULK-d9GMcddW1-DZRHCE8Sew@mail.gmail.com>
Message-ID: <20150409172808.GB27775@muck>

On Thu, Apr 09, 2015 at 07:22:52AM -0700, Jeff Garzik wrote:
> On Thu, Apr 9, 2015 at 7:10 AM, Stephen Morse <stephencalebmorse at gmail.com>
> wrote:
> 
> > Is hashing transaction data once for each input really a huge bottleneck,
> > though? Do mobile devices have an issue with this?
> >
> 
> 
> Think about what slow transaction verification speed means.  Slower
> propagation across the network.  More work per node.  Greater opportunity
> for algorithmic attacks, races and other shenanigans by attackers.

Keep in mind though we can always make part of the soft-fork be to make
the hash operations in the new CHECKSIG mechanism consume sigops.

For the OP: Have you looked at how CODESEPARATOR allows the signature to
sign code to run as part of verifying the signature? E.g. my signature
can say "valid if you run these additional opcodes and they return true"
where those additional opcodes take the transaction, hash it in the
defined way, and verify that the ECC signature correctly signs that
hash and the hash of the additional opcodes. For instance in this case
making a signature that's only valid if the tx fee is less than the
defined amount would be a matter of GET_FEE <max fee + 1> LESSTHAN VERIFY

This can be a much more general mechanism with easy to test modular
opcodes; for the consensus-critical codebase this can result in a much
easier and simpler to test CHECKSIG facility than a dozen new flags.

-- 
'peter'[:-1]@petertodd.org
000000000000000006975f442f50caa4fcc18e165746b3c77b641b75635afecb
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150409/3b1563d4/attachment.sig>

From kefkius at maza.club  Thu Apr  9 20:16:41 2015
From: kefkius at maza.club (Kefkius)
Date: Thu, 09 Apr 2015 16:16:41 -0400
Subject: [Bitcoin-development] Request For Discussion / BIP number -
 Multi-Currency Hierarchy For Use In Multisignature Deterministic Wallets
In-Reply-To: <CABjHNoR_Tg6bq3mJ8vkFAOPNHz8RS-FKAEx9APMZAVhct5H0SA@mail.gmail.com>
References: <5524D347.4040507@maza.club>	<CABjHNoTbLz+dCPkctk95jPkdnagQQxOintYgswKCE6wB=TS9xg@mail.gmail.com>	<CACvEmnE6jgeRmTbyoOfW+jf=EB_EmPN4FdBXz-anm4tfKJscqw@mail.gmail.com>
	<CABjHNoR_Tg6bq3mJ8vkFAOPNHz8RS-FKAEx9APMZAVhct5H0SA@mail.gmail.com>
Message-ID: <5526DE29.1060605@maza.club>

William,

I've amended the proposal's "Motivation" section slightly for
clarification. I'm not sure how a "cosigner_index" branch would benefit
this proposal. Granted, I don't fully understand the benefits of the
"cosigner_index" branch in BIP-0045. From what I understand, the
"wallet" branch of my proposal seems to accomplish a similar goal.

Jona,

Your explanation is correct. As for this being appropriate as a BIP, I
agree that it's an arguable point to say it improves Bitcoin. However,
this proposal exists because of BIP-0044, which also describes a
multi-currency hierarchy. For that reason, I think this is an
appropriate proposal.

Thank you both for your feedback.

On 04/08/2015 12:41 PM, William Swanson wrote:
> Oops, sorry I missed that.
>
> Since that's the reason this proposal exists, I would consider putting
> it right up top where people can see it. Also, since this proposal is
> specifically designed for multi-sig, I would look at what BIP45 is
> doing and maybe incorporate a "cosigner_index" branch. Otherwise, this
> idea seems like a reasonable way to organize a wallet.
>
> -William
>
> On Wed, Apr 8, 2015 at 9:28 AM, ?????? <kinoshitajona at gmail.com> wrote:
>> William,
>>
>> I believe the reasoning for this is stated in the Coin Type section.
>>
>> "Public derivation is used so that cosigners need only know one of each
>> other's public keys, rather than needing to distribute public keys for each
>> coin."
>>
>> BIP44 has a coin level, but it's a private derived level, so cosigners would
>> not be able to generate multiple crypto currencies of each others' without
>> giving each other n xpubs where n is the number of currencies shared. This
>> new proposal basically sticks coin type on the public derivation side of
>> things so that I could generate litecoin or darkcoin multisigs without your
>> permission...
>>
>> Kefkius,
>>
>> This BIP seems like a good fit for multi-currency wallets based on multisig.
>> So kudos for putting it in writing.
>>
>> However, I don't know if this is really a BIP thing. It's not improving
>> Bitcoin (Bitcoin Improvement Proposal... remember?), in fact, by definition
>> it is improving altcoin usability.
>>
>> For that reason alone I will say I disagree for a BIP for this.
>> - Jona
>>
>>
>> 2015-04-08 16:46 GMT+09:00 William Swanson <swansontec at gmail.com>:
>>> It's not really clear why this is better than BIP 44 as it already
>>> stands. You have the same fields, but they are just in a different
>>> order. Couldn't you just use the existing BIP 44 hierarchy, but add
>>> the convention that "wallet/account N" is the same wallet in each
>>> supported currency?
>>>
>>> For example, if I have a wallet called "business expenses", which
>>> happens to be wallet m / 44' / 0' / 5', for Bitcoin, then the same
>>> wallet would be m / 44' / 3' / 5' for Dogecoin, and m / 44' / 2' / 5'
>>> for Litecoin.
>>>
>>> I am trying to think of examples where your proposal is better than
>>> BIP 44, but I can't think of any. Even backup recovery works fine. I
>>> assume that your idea is to continue iterating over the different
>>> wallet indices as long as you are finding funds in *any* currency.
>>> Well, you can still do that with BIP 44. The fields are in a different
>>> order, but that doesn't affect the algorithm in any way.
>>>
>>> Maybe you have some deeper insight I'm not seeing, but if so, you need
>>> to clearly explain that in your motivation section. The current
>>> explanation, "This limits the possible implementations of
>>> multi-currency, multisignature wallets," is pretty vauge. Also, there
>>> is nothing in this spec that addresses the multisignature use-case.
>>> The BIP 45 spec does a lot of extra work to make multisignature work
>>> smoothly.
>>>
>>> I'm not trying to criticize your proposal. I'm just trying to
>>> understand what it's trying to accomplish.
>>>
>>> -William Swanson
>>>
>>>
>>> On Wed, Apr 8, 2015 at 12:05 AM, Kefkius <kefkius at maza.club> wrote:
>>>> I have a potential BIP, "Multi-Currency Hierarchy For Use In
>>>> Multisignature Deterministic Wallets." I'm requesting discussion on it,
>>>> and possibly assignment of a BIP number.
>>>>
>>>> It's located in this github gist:
>>>> https://gist.github.com/Kefkius/1aa02945e532f8739023
> ------------------------------------------------------------------------------
> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT
> Develop your own process in accordance with the BPMN 2 standard
> Learn Process modeling best practices with Bonita BPM through live exercises
> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual- event?utm_
> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development




From mike at plan99.net  Thu Apr  9 20:23:52 2015
From: mike at plan99.net (Mike Hearn)
Date: Thu, 9 Apr 2015 22:23:52 +0200
Subject: [Bitcoin-development] DevCore London
Message-ID: <CANEZrP1MqzgfVrRHDjwizWCjnJqmMyRXJWDPAhv-rYU06sYw0g@mail.gmail.com>

Next week on April 15th Gavin, Wladimir, Corey and myself will be at
DevCore London:

   https://everyeventgives.com/event/devcore-london

If you're in town why not come along?

It's often the case that conferences can be just talking shops, without
much meat for real developers. So in the afternoon I'll be doing two things:

   1. Running a hackathon/workshop type event. The theme is contracts, but
   we can hack on whatever you all feel like.

   2. My "talk" will actually be a live coding event. Writing contracts
   apps has become a lot easier in the past few years, and to prove it to you
   I will write a decentralised cross-platform Tor supporting document
   timestamping app that uses OP_RETURN outputs and has a nice GUI ..... in 30
   minutes, on stage.

   Don't think it can be done? Turn up and see for yourself.

See you there!
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150409/3b14e689/attachment.html>

From michael.wechner at wyona.com  Thu Apr  9 20:31:02 2015
From: michael.wechner at wyona.com (Michael Wechner)
Date: Thu, 09 Apr 2015 22:31:02 +0200
Subject: [Bitcoin-development] Some interviews from Amsterdam 2014
Message-ID: <5526E186.5060104@wyona.com>

Greetings

I did four interviews at the bitcoin conference Amsterdam 2014 with

- Gavin Andresen
- Peter Surda
- Patrick Byrne
- Stefan Thomas

which I have finally published at

https://www.youtube.com/user/WYONAPICTURES

Hope you like them :-)

Thanks

Michael



From swansontec at gmail.com  Thu Apr  9 22:24:11 2015
From: swansontec at gmail.com (William Swanson)
Date: Thu, 9 Apr 2015 15:24:11 -0700
Subject: [Bitcoin-development] Request For Discussion / BIP number -
 Multi-Currency Hierarchy For Use In Multisignature Deterministic Wallets
In-Reply-To: <5526DE29.1060605@maza.club>
References: <5524D347.4040507@maza.club>
	<CABjHNoTbLz+dCPkctk95jPkdnagQQxOintYgswKCE6wB=TS9xg@mail.gmail.com>
	<CACvEmnE6jgeRmTbyoOfW+jf=EB_EmPN4FdBXz-anm4tfKJscqw@mail.gmail.com>
	<CABjHNoR_Tg6bq3mJ8vkFAOPNHz8RS-FKAEx9APMZAVhct5H0SA@mail.gmail.com>
	<5526DE29.1060605@maza.club>
Message-ID: <CABjHNoQq7OmkmawA-Z-ugd37EFTefh5KqjUThF=fbg1k4u_ThQ@mail.gmail.com>

On Thu, Apr 9, 2015 at 1:16 PM, Kefkius <kefkius at maza.club> wrote:
> I've amended the proposal's "Motivation" section slightly for
> clarification. I'm not sure how a "cosigner_index" branch would benefit
> this proposal. Granted, I don't fully understand the benefits of the
> "cosigner_index" branch in BIP-0045. From what I understand, the
> "wallet" branch of my proposal seems to accomplish a similar goal.

Suppose Alice and Bob share a multi-sig wallet. Alice would like to
accept payment from Mallory, and Bob would like to accept payment from
Maude. So, they would each like to create a separate payment address.
If Alice and Bob both generate the same address, the incoming funds
would be mixed together (bad), and Mallory and Maude might learn about
the relationship between Alice and Bob (also bad).

Unfortunately, Alice and Bob are in a place where they can't
communicate (maybe Bob has no cell service). There is no way for Bob
to send a message like "I'm making a request on address_index N,
Alice, please use a different index for your request."

The cosigner_index solves this. When they set up the wallet, Alice and
Bob agree to always use a different value for the cosigner_index. That
way, addresses from Alice will never overlap with addresses from Bob,
since they are on different branches. Doing it this way adds privacy
and doesn't cost anything.

With this added in, your path would be:

m / purpose' / wallet' / coin_type / cosigner_index / change / address_index

XPUB's generated from your wallet would then be compatible with XPUB's
generated by other multi-sig wallets like CoPay, since the
(cosigner_index / change / address_index) structure stays the same.

-William Swanson



From etotheipi at gmail.com  Thu Apr  9 22:37:23 2015
From: etotheipi at gmail.com (Alan Reiner)
Date: Thu, 09 Apr 2015 18:37:23 -0400
Subject: [Bitcoin-development] Request For Discussion / BIP number -
 Multi-Currency Hierarchy For Use In Multisignature Deterministic Wallets
In-Reply-To: <CABjHNoQq7OmkmawA-Z-ugd37EFTefh5KqjUThF=fbg1k4u_ThQ@mail.gmail.com>
References: <5524D347.4040507@maza.club>	<CABjHNoTbLz+dCPkctk95jPkdnagQQxOintYgswKCE6wB=TS9xg@mail.gmail.com>	<CACvEmnE6jgeRmTbyoOfW+jf=EB_EmPN4FdBXz-anm4tfKJscqw@mail.gmail.com>	<CABjHNoR_Tg6bq3mJ8vkFAOPNHz8RS-FKAEx9APMZAVhct5H0SA@mail.gmail.com>	<5526DE29.1060605@maza.club>
	<CABjHNoQq7OmkmawA-Z-ugd37EFTefh5KqjUThF=fbg1k4u_ThQ@mail.gmail.com>
Message-ID: <5526FF23.9040402@gmail.com>

BTW, I had originally proposed a "no-collision" scheme for
multi-signature wallets, which doesn't require modifying the key tree
structure at all, except for adding new internal and external chains
(2*N chains).  All siblings watch all chains, but only generate
receiving and change addresses on their two chains. 

The original document is here, which might be educational for the
purposes of understand precisely the problem that needs a solution (and
mine is a different solution than BIP45).

https://www.dropbox.com/s/58poxi60d8nfj5w/MultisigWalletNoCollide.pdf

I prefer not adding even more levels to the key tree, and (IMO) it makes
more sense to add more chains to the wallet instead of adding a new tree
level (as it allows for a simpler tree in the event that you don't need
separate cosigners).  But I suspect that there's a certain momentum
behind the cosigner-index method already in BIP45?  Just throwing it out
there.

-Alan



On 04/09/2015 06:24 PM, William Swanson wrote:
> On Thu, Apr 9, 2015 at 1:16 PM, Kefkius <kefkius at maza.club> wrote:
>> I've amended the proposal's "Motivation" section slightly for
>> clarification. I'm not sure how a "cosigner_index" branch would benefit
>> this proposal. Granted, I don't fully understand the benefits of the
>> "cosigner_index" branch in BIP-0045. From what I understand, the
>> "wallet" branch of my proposal seems to accomplish a similar goal.
> Suppose Alice and Bob share a multi-sig wallet. Alice would like to
> accept payment from Mallory, and Bob would like to accept payment from
> Maude. So, they would each like to create a separate payment address.
> If Alice and Bob both generate the same address, the incoming funds
> would be mixed together (bad), and Mallory and Maude might learn about
> the relationship between Alice and Bob (also bad).
>
> Unfortunately, Alice and Bob are in a place where they can't
> communicate (maybe Bob has no cell service). There is no way for Bob
> to send a message like "I'm making a request on address_index N,
> Alice, please use a different index for your request."
>
> The cosigner_index solves this. When they set up the wallet, Alice and
> Bob agree to always use a different value for the cosigner_index. That
> way, addresses from Alice will never overlap with addresses from Bob,
> since they are on different branches. Doing it this way adds privacy
> and doesn't cost anything.
>
> With this added in, your path would be:
>
> m / purpose' / wallet' / coin_type / cosigner_index / change / address_index
>
> XPUB's generated from your wallet would then be compatible with XPUB's
> generated by other multi-sig wallets like CoPay, since the
> (cosigner_index / change / address_index) structure stays the same.
>
> -William Swanson
>
> ------------------------------------------------------------------------------
> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT
> Develop your own process in accordance with the BPMN 2 standard
> Learn Process modeling best practices with Bonita BPM through live exercises
> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual- event?utm_
> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development




From swansontec at gmail.com  Fri Apr 10 02:02:32 2015
From: swansontec at gmail.com (William Swanson)
Date: Thu, 9 Apr 2015 19:02:32 -0700
Subject: [Bitcoin-development] Request For Discussion / BIP number -
 Multi-Currency Hierarchy For Use In Multisignature Deterministic Wallets
In-Reply-To: <5526FF23.9040402@gmail.com>
References: <5524D347.4040507@maza.club>
	<CABjHNoTbLz+dCPkctk95jPkdnagQQxOintYgswKCE6wB=TS9xg@mail.gmail.com>
	<CACvEmnE6jgeRmTbyoOfW+jf=EB_EmPN4FdBXz-anm4tfKJscqw@mail.gmail.com>
	<CABjHNoR_Tg6bq3mJ8vkFAOPNHz8RS-FKAEx9APMZAVhct5H0SA@mail.gmail.com>
	<5526DE29.1060605@maza.club>
	<CABjHNoQq7OmkmawA-Z-ugd37EFTefh5KqjUThF=fbg1k4u_ThQ@mail.gmail.com>
	<5526FF23.9040402@gmail.com>
Message-ID: <CABjHNoQUMzUB+Q-dk+C=AzwXkVUC1fJOtVAB4TpXWhg2ONJdBg@mail.gmail.com>

Hello Alan,
Your scheme is basically the same as the BIP45 scheme, except that you
have collapsed the "cosigner_index" and "change" fields into a single
field with the formula:

    combined = 2*cosigner_index + change

This removes one level from the hierarchy, but ultimately produces the
same number and type of chains as BIP45 (just addressed differently).

I kinda like the BIP45's approach of giving each field has its own
dedicated purpose. What is the motivation behind flattening the
hierarchy?

I ask because the wallet I work on, Airbitz, will be adding multi-sig
at some point in the future, and we need to figure out what kind of HD
tree structure we will be using. Our ideal structure would basically
be BIP 44 plus some "no-collision" logic:

    m / purpose' / coin_type' / wallet' / cosigner_index / change /
address_index

I feel like interoperability with Copay would be worth the extra HD
branch. Assuming Kefkius adds similar no-collision logic, his proposal
is pretty close to our ideal:

    m / purpose' / wallet' / coin_type / cosigner_index / change / address_index

Of course, I am open to hearing your thoughts on this as well.

-William

On Thu, Apr 9, 2015 at 3:37 PM, Alan Reiner <etotheipi at gmail.com> wrote:
> BTW, I had originally proposed a "no-collision" scheme for
> multi-signature wallets, which doesn't require modifying the key tree
> structure at all, except for adding new internal and external chains
> (2*N chains).  All siblings watch all chains, but only generate
> receiving and change addresses on their two chains.
>
> The original document is here, which might be educational for the
> purposes of understand precisely the problem that needs a solution (and
> mine is a different solution than BIP45).
>
> https://www.dropbox.com/s/58poxi60d8nfj5w/MultisigWalletNoCollide.pdf
>
> I prefer not adding even more levels to the key tree, and (IMO) it makes
> more sense to add more chains to the wallet instead of adding a new tree
> level (as it allows for a simpler tree in the event that you don't need
> separate cosigners).  But I suspect that there's a certain momentum
> behind the cosigner-index method already in BIP45?  Just throwing it out
> there.



From etotheipi at gmail.com  Fri Apr 10 02:26:19 2015
From: etotheipi at gmail.com (Alan Reiner)
Date: Thu, 09 Apr 2015 22:26:19 -0400
Subject: [Bitcoin-development] Request For Discussion / BIP number -
 Multi-Currency Hierarchy For Use In Multisignature Deterministic Wallets
In-Reply-To: <CABjHNoQUMzUB+Q-dk+C=AzwXkVUC1fJOtVAB4TpXWhg2ONJdBg@mail.gmail.com>
References: <5524D347.4040507@maza.club>	<CABjHNoTbLz+dCPkctk95jPkdnagQQxOintYgswKCE6wB=TS9xg@mail.gmail.com>	<CACvEmnE6jgeRmTbyoOfW+jf=EB_EmPN4FdBXz-anm4tfKJscqw@mail.gmail.com>	<CABjHNoR_Tg6bq3mJ8vkFAOPNHz8RS-FKAEx9APMZAVhct5H0SA@mail.gmail.com>	<5526DE29.1060605@maza.club>	<CABjHNoQq7OmkmawA-Z-ugd37EFTefh5KqjUThF=fbg1k4u_ThQ@mail.gmail.com>	<5526FF23.9040402@gmail.com>
	<CABjHNoQUMzUB+Q-dk+C=AzwXkVUC1fJOtVAB4TpXWhg2ONJdBg@mail.gmail.com>
Message-ID: <552734CB.4070903@gmail.com>

The motivation was that I came up with it before BIP 45 existed, but
wasn't vocal enough about it because Armory didn't have BIP32 Multisig
trees implemented yet, so I didn't have a strong mental focus or
determination around it.  If there's momentum behind BIP45, we should
use it.  I wanted to share the document because it was also created to
be educational on the topic of "multisig address generation collisions"
as being disucussed in this thread.
 
Though we just put in BIP44 with my modification into our new wallet
format (in the works), and if I was to adopt this I'd like to simply
merge the two.  

    M / purpose' / coin' / account' / *cosigner* / change*0or1* / address

For reference my proposal (and the way I implemented it before BIP45
existed) is just BIP44 but with 2*N change branches instead of 2:

    M / purpose' / coin' / account' / change*2N* / address

Our new code has the goal of being able to easily reconfigure your BIP32
tree for your specific application.  But for the default
free-public-download software, it would be nice to have a standard
everyone agrees to.  BIP44 vs original-BIP32 doesn't really matter since
you only transfer the account branches, but this particular decision
with how the consigners avoid "collisions" does affect it. 

-Alan


On 04/09/2015 10:02 PM, William Swanson wrote:
> Hello Alan,
> Your scheme is basically the same as the BIP45 scheme, except that you
> have collapsed the "cosigner_index" and "change" fields into a single
> field with the formula:
>
>     combined = 2*cosigner_index + change
>
> This removes one level from the hierarchy, but ultimately produces the
> same number and type of chains as BIP45 (just addressed differently).
>
> I kinda like the BIP45's approach of giving each field has its own
> dedicated purpose. What is the motivation behind flattening the
> hierarchy?
>
> I ask because the wallet I work on, Airbitz, will be adding multi-sig
> at some point in the future, and we need to figure out what kind of HD
> tree structure we will be using. Our ideal structure would basically
> be BIP 44 plus some "no-collision" logic:
>
>     m / purpose' / coin_type' / wallet' / cosigner_index / change /
> address_index
>
> I feel like interoperability with Copay would be worth the extra HD
> branch. Assuming Kefkius adds similar no-collision logic, his proposal
> is pretty close to our ideal:
>
>     m / purpose' / wallet' / coin_type / cosigner_index / change / address_index
>
> Of course, I am open to hearing your thoughts on this as well.
>
> -William
>
> On Thu, Apr 9, 2015 at 3:37 PM, Alan Reiner <etotheipi at gmail.com> wrote:
>> BTW, I had originally proposed a "no-collision" scheme for
>> multi-signature wallets, which doesn't require modifying the key tree
>> structure at all, except for adding new internal and external chains
>> (2*N chains).  All siblings watch all chains, but only generate
>> receiving and change addresses on their two chains.
>>
>> The original document is here, which might be educational for the
>> purposes of understand precisely the problem that needs a solution (and
>> mine is a different solution than BIP45).
>>
>> https://www.dropbox.com/s/58poxi60d8nfj5w/MultisigWalletNoCollide.pdf
>>
>> I prefer not adding even more levels to the key tree, and (IMO) it makes
>> more sense to add more chains to the wallet instead of adding a new tree
>> level (as it allows for a simpler tree in the event that you don't need
>> separate cosigners).  But I suspect that there's a certain momentum
>> behind the cosigner-index method already in BIP45?  Just throwing it out
>> there.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150409/752836a9/attachment.html>

From stephencalebmorse at gmail.com  Fri Apr 10 02:56:20 2015
From: stephencalebmorse at gmail.com (Stephen Morse)
Date: Thu, 9 Apr 2015 22:56:20 -0400
Subject: [Bitcoin-development] Build your own nHashType
In-Reply-To: <20150409172808.GB27775@muck>
References: <CABHVRKTNFoLm9LEO=ctT_UP9zW7QOMQzVXitKC=PAzj=HG9OHg@mail.gmail.com>
	<CANEZrP12kZ8vRAo=feprJ9_oRXUPKJ=iF6kZdxxbai=TxjzM9g@mail.gmail.com>
	<CABHVRKSET18D13+yi4MTPs6+4xwUD5vuJszCOJG9CaTi0+CAvA@mail.gmail.com>
	<CAJHLa0NgV=6D=TAy4sm_EAfYiZULK-d9GMcddW1-DZRHCE8Sew@mail.gmail.com>
	<20150409172808.GB27775@muck>
Message-ID: <CABHVRKQOSHBzkWGoKROcXJd-mKcb3FvLLdSYMgOZJ3gC1zjNnw@mail.gmail.com>

Regarding the re-hashing the transaction data once per input being a
bottleneck, I was mistakenly only thinking about this from the point of
view of the signer. Full nodes have to check all transactions' inputs,
which is much more costly, as the link Gavin posted shows.

On Thu, Apr 9, 2015 at 10:45 AM, Mike Hearn <mike at plan99.net> wrote:
>
> Right, good point. I wonder if this sort of auto forwarding could even be
> a useful feature. I can't think of one right now.
>

I can think of a few convoluted use cases, but not any good ones. People
have definitely looked for this feature before, though, just look at this
Bitcoin SE post
<http://bitcoin.stackexchange.com/questions/1495/is-there-a-way-to-automatically-send-bitcoins-from-one-wallet-to-another>.
I think there are better ways to handle key management than
auto-forwarding, though. Anyone looking for this feature probably just
wasn't aware that there are better solutions.

On Thu, Apr 9, 2015 at 10:45 AM, Mike Hearn <mike at plan99.net> wrote:
>
> Yes but is that fundamental or is there a way to avoid it? That's what I'm
> getting at.
>

In the bitcointalk article referenced, Sergio actually gave us the answer:

> Hash(Tx,previn-index) = Hash ( Hash(outputs) || Hash
(Inputs-with-script-cleared) || <previn-index> )
>   (for SIGHASH_ALL)
>   This way the values "Hash(outputs)" and
"Hash(Inputs-with-script-cleared)" can be cached and reused.

Basically, just re-order the way stuff is serialized. Put the stuff that is
nearly always signed at the beginning, and vice versa. I'll see if I can
update the proposal to make this optimization possible. What I suspect,
though, is that with all the new controls, blocks with ordinary
transactions will verify faster, but an attacker could still create a very
CPU intensive block by signing inputs with a wide variety of nHashTypes and
then signing the last one with the equivalent of SIGHASH_ALL. I don't think
that's a big limitation, though, the attack is already somewhat possible,
and would be very hard to do, and doesn't really gain the attacker anything
(other than infamy).

On Thu, Apr 9, 2015 at 1:28 PM, Peter Todd <pete at petertodd.org> wrote:

> For the OP: Have you looked at how CODESEPARATOR allows the signature to
> sign code to run as part of verifying the signature? E.g. my signature
> can say "valid if you run these additional opcodes and they return true"
> where those additional opcodes take the transaction, hash it in the
> defined way, and verify that the ECC signature correctly signs that
> hash and the hash of the additional opcodes. For instance in this case
> making a signature that's only valid if the tx fee is less than the
> defined amount would be a matter of GET_FEE <max fee + 1> LESSTHAN VERIFY
>

I've never been able to really see a good use case for OP_CODESEPARATOR,
and I'm not sure I completely have my head wrapped around what you're
proposing. From this
<http://bitcoin.stackexchange.com/questions/34013/what-is-op-codeseparator-used-for>
 and this
<https://bitcointalk.org/index.php?topic=52949.msg631255#msg631255>,
though, it seems like OP_CODESEPARATOR cannot really be made useful unless
you already have a way to sign without hashing the TXIDs referenced by your
input, in which case you need to modify the nHashType.

Best,
Stephen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150409/f55fb600/attachment.html>

From laanwj at gmail.com  Fri Apr 10 08:46:50 2015
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Fri, 10 Apr 2015 10:46:50 +0200
Subject: [Bitcoin-development] Bitcoin Core 0.10.1 release candidate 2
	available
Message-ID: <20150410084648.GA7630@amethyst.visucore.com>

Hello,

I've just uploaded Bitcoin Core 0.10.1rc2 executables to:

https://bitcoin.org/bin/bitcoin-core-0.10.1/test/

The source code can be found in git under the tag 'v0.10.1rc2'

The only change in comparison to rc1 is a fix by Gavin Andresen:

- `1c62e84` Keep mempool consistent during block-reorgs

Thanks to everyone that participated in the gitian build process,

Wladimir




From pieter.wuille at gmail.com  Sun Apr 12 14:26:12 2015
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Sun, 12 Apr 2015 07:26:12 -0700
Subject: [Bitcoin-development] Deprecating Bitcoin Core's regtest-specific
	`setgenerate` behaviour
Message-ID: <CAPg+sBjNkzqTUupx5QYZ_uzMwAdY4qRc+PGR5R9qCKUxxcHx7g@mail.gmail.com>

Hello everyone,

Bitcoin Core's `setgenerate` RPC call has had a special meaning for
-regtest (namely instantaneously mining a number of blocks, instead of
starting a background CPU miner).

We're planning to deprecate that overloaded behaviour, and replace it with
a separate RPC call `generate`. Is there any software or user who would
need compatibility with the old behaviour? We're generally very
conservative in changing RPC behaviour, but as this is not related to any
production functionality, we may as well just switch it.

Note that the bitcoin.org developer documentation will need to be updated.

-- 
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150412/98b98d45/attachment.html>

From sean at msgilligan.com  Sun Apr 12 22:36:12 2015
From: sean at msgilligan.com (Sean Gilligan)
Date: Sun, 12 Apr 2015 15:36:12 -0700
Subject: [Bitcoin-development] Deprecating Bitcoin Core's
 regtest-specific `setgenerate` behaviour
In-Reply-To: <CAPg+sBjNkzqTUupx5QYZ_uzMwAdY4qRc+PGR5R9qCKUxxcHx7g@mail.gmail.com>
References: <CAPg+sBjNkzqTUupx5QYZ_uzMwAdY4qRc+PGR5R9qCKUxxcHx7g@mail.gmail.com>
Message-ID: <552AF35C.7060407@msgilligan.com>

I would recommend adding the new method and deprecating (as in warning
against using) the old one for one major release. Then removing it
altogether in the following major release.

I have written a Java RPC client and Groovy/Spock functional tests
<https://github.com/msgilligan/bitcoin-spock> that use the current call.
A separate `generate` or `generateblocks` call is a great idea.

However, I try to keep my tests compatible with the current stable and
unstable versions of Bitcoin Core (and the Omni Core fork) and would
have to write code that checks the RPC server version (or checks for the
presence of the new call, falling back to the old one) to support the
use cases that I need to support. Not a huge deal, but I'm probably not
the only one.

-- Sean


On 4/12/15 7:26 AM, Pieter Wuille wrote:
> Hello everyone,
>
> Bitcoin Core's `setgenerate` RPC call has had a special meaning for
> -regtest (namely instantaneously mining a number of blocks, instead of
> starting a background CPU miner).
>
> We're planning to deprecate that overloaded behaviour, and replace it
> with a separate RPC call `generate`. Is there any software or user who
> would need compatibility with the old behaviour? We're generally very
> conservative in changing RPC behaviour, but as this is not related to
> any production functionality, we may as well just switch it.
>
> Note that the bitcoin.org <http://bitcoin.org> developer documentation
> will need to be updated.
>
> -- 
> Pieter
>
>
>
> ------------------------------------------------------------------------------
> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT
> Develop your own process in accordance with the BPMN 2 standard
> Learn Process modeling best practices with Bonita BPM through live exercises
> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual- event?utm_
> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF
>
>
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150412/a9b2679a/attachment.html>

From gmaxwell at gmail.com  Wed Apr 15 03:34:50 2015
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Wed, 15 Apr 2015 03:34:50 +0000
Subject: [Bitcoin-development] Build your own nHashType
In-Reply-To: <CABHVRKTNFoLm9LEO=ctT_UP9zW7QOMQzVXitKC=PAzj=HG9OHg@mail.gmail.com>
References: <CABHVRKTNFoLm9LEO=ctT_UP9zW7QOMQzVXitKC=PAzj=HG9OHg@mail.gmail.com>
Message-ID: <CAAS2fgTndnSoSx8==EVvP_mMHX=TEMV0whN7s3RBoMYyYDmzJw@mail.gmail.com>

On Wed, Apr 8, 2015 at 7:50 PM, Stephen Morse
<stephencalebmorse at gmail.com> wrote:
> Seeking feedback on a proposal that will allow a transaction signer to
> explicitly specify what is to be serialized for the signature hash. The
> basic idea is to make the nHashType general enough that we won't need a new
> sighash flag every time a new use case comes up.
>
> If implemented into bitcoin (via a soft fork), this would make malleability
> almost a non-issue (the TXID referenced by inputs just need to be updated
> previous TX changes) and would enable hardware wallets to securely sign
> without needing to download/process each transaction it spends from.

I'm not sure if I'm super fond of that particular non-programmatic but
many options approach; It sort of has the problem that there are
relatively few useful options that don't rapidly extend into a choose
your own adventure with too many options to count; so you take a
complexity penalty perhaps without a matching functionality payoff.

but thats not why I'm commenting...

I wonder if anyone noticed that any sighash masking that eliminates
the txin txid enables covenants?

Covenants are payments which constrain their future payments (like
deed covenants), I've written about them in the past
https://bitcointalk.org/index.php?topic=278122.0  ... they can
sometimes be pretty useful but are also potentially a irritating hit
to fungibility, at least if used stupidly.

the approach here is that you make the scriptpubkey contain "[push:
0x30, 0x06, 0x02, 0x01, 0x04, 0x02, 0x01, 0x04, flags] [push pubkey
resulting from pubkey recovery] OP_CHECKSIG"  and set the flags to
match only the things you want to enforce in the spending transaction
hash them up and recover the EC public point.   You can think of that
construct as giving a you a OP_MASKED_TRANSACTION_HASH_EQUALS  ... the
recovered pubkey is just a kind of message hash, though a weird and
expensive to compute one.

I don't currently see how to get a perpetual covenant out of it-- e.g.
a coin that anyone can spend, but only to its same scriptpubkey, (the
obvious way requires the ability to be able to checksig stuff on the
stack) though I wouldn't be shocked if it were possible with a
sufficiently complex sighash flag and nothing else.



From s7r at sky-ip.org  Wed Apr 15 23:43:01 2015
From: s7r at sky-ip.org (s7r)
Date: Thu, 16 Apr 2015 02:43:01 +0300
Subject: [Bitcoin-development] 75%/95% threshold for transaction versions
Message-ID: <552EF785.7000207@sky-ip.org>

Hi,

Would it be wise to add a consensus rule like the one we have for blocks,

(if > 75% from last 1000 blocks are version 'n' mark version 'n' as
standard for blocks and if > 95% from the last 1000 blocks are version
'n' mark previous block versions as invalid)

but for transaction versions? In simple terms, if > 75% from all the
transactions in the latest 1000 blocks are version 'n', mark all
previous transaction versions as non-standard and if > 95% from all the
transactions in the latest 1000 blocks are version 'n' mark all previous
transaction versions as invalid.

At this moment, the standard in consensus is v1, but nothing is enforced
in the network related to transaction versions.

Regarding BIP62, as it can be read here [0] it is said that it requires
v2 transactions. It is also said that transaction version 2 will be
skipped and jump directly to v3, for an even version for transactions
and blocks (?). Might as well add the rule for invalidating previous
transaction versions if the majority updates - could this break anything
or affect functionality in any way?

BIP62 adds a newer transaction version which is optional and does not
mark previous v1 as non-standard or invalid. This means bitcoin core
will treat both v1 and v2/v3 transactions as standard and relay/mine
them with the same priority, regardless of the tx version?


Thanks.

[0]
https://bitcoin.stackexchange.com/questions/35904/how-much-of-bip-62-dealing-with-malleability-has-been-implemented



From allen.piscitello at gmail.com  Thu Apr 16 02:04:09 2015
From: allen.piscitello at gmail.com (Allen Piscitello)
Date: Wed, 15 Apr 2015 21:04:09 -0500
Subject: [Bitcoin-development] 75%/95% threshold for transaction versions
In-Reply-To: <552EF785.7000207@sky-ip.org>
References: <552EF785.7000207@sky-ip.org>
Message-ID: <CAJfRnm6E=huM6GYnmjqF2Wjwcp_79axktwu8+tTriF+rx8Oi8Q@mail.gmail.com>

If I had a time locked signed transaction where I threw away the key, this
would potentially invalidate my transaction.

What is the point of such a rule?

On Wed, Apr 15, 2015 at 6:43 PM, s7r <s7r at sky-ip.org> wrote:

> Hi,
>
> Would it be wise to add a consensus rule like the one we have for blocks,
>
> (if > 75% from last 1000 blocks are version 'n' mark version 'n' as
> standard for blocks and if > 95% from the last 1000 blocks are version
> 'n' mark previous block versions as invalid)
>
> but for transaction versions? In simple terms, if > 75% from all the
> transactions in the latest 1000 blocks are version 'n', mark all
> previous transaction versions as non-standard and if > 95% from all the
> transactions in the latest 1000 blocks are version 'n' mark all previous
> transaction versions as invalid.
>
> At this moment, the standard in consensus is v1, but nothing is enforced
> in the network related to transaction versions.
>
> Regarding BIP62, as it can be read here [0] it is said that it requires
> v2 transactions. It is also said that transaction version 2 will be
> skipped and jump directly to v3, for an even version for transactions
> and blocks (?). Might as well add the rule for invalidating previous
> transaction versions if the majority updates - could this break anything
> or affect functionality in any way?
>
> BIP62 adds a newer transaction version which is optional and does not
> mark previous v1 as non-standard or invalid. This means bitcoin core
> will treat both v1 and v2/v3 transactions as standard and relay/mine
> them with the same priority, regardless of the tx version?
>
>
> Thanks.
>
> [0]
>
> https://bitcoin.stackexchange.com/questions/35904/how-much-of-bip-62-dealing-with-malleability-has-been-implemented
>
>
> ------------------------------------------------------------------------------
> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT
> Develop your own process in accordance with the BPMN 2 standard
> Learn Process modeling best practices with Bonita BPM through live
> exercises
> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual-
> event?utm_
> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150415/b16356ea/attachment.html>

From gappleto97 at gmail.com  Thu Apr 16 02:14:12 2015
From: gappleto97 at gmail.com (gabe appleton)
Date: Wed, 15 Apr 2015 22:14:12 -0400
Subject: [Bitcoin-development] Where do I start?
In-Reply-To: <CANJO25K1Lox5aU-NN-j0An2ujNNHwPWNqX1ZXMs+z1udDZ1LOA@mail.gmail.com>
References: <CANJO25K1Lox5aU-NN-j0An2ujNNHwPWNqX1ZXMs+z1udDZ1LOA@mail.gmail.com>
Message-ID: <CANJO25KXoYXKZf-TZRD3HviU141+rYUB2d=4Xf9DqRrzD9P94w@mail.gmail.com>

Background: I'm a CS student quickly approaching his research project, and
I'd like to do something meaningful with it.

Essentially, I'd like to know what issues someone up for their bachelor's
degree might actually be able to help on, and where I can start. Obviously
I'm not going to be able to just dive into a 6-year-running project without
some prior research, so I'm looking for a start.

What are some current things that are lacking in Bitcoin core? Or am I
better off making something else for the ecosystem?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150415/56a2d99c/attachment.html>

From thyshizzle at outlook.com  Thu Apr 16 03:42:36 2015
From: thyshizzle at outlook.com (Thy Shizzle)
Date: Thu, 16 Apr 2015 13:42:36 +1000
Subject: [Bitcoin-development] Where do I start?
Message-ID: <BAY403-EAS312C142C08A2CD76B606E78C2E40@phx.gbl>

Zero conf :D
________________________________
From: gabe appleton<mailto:gappleto97 at gmail.com>
Sent: ?16/?04/?2015 12:15 PM
To: bitcoin-development at lists.sourceforge.net<mailto:bitcoin-development at lists.sourceforge.net>
Subject: [Bitcoin-development] Where do I start?

Background: I'm a CS student quickly approaching his research project, and
I'd like to do something meaningful with it.

Essentially, I'd like to know what issues someone up for their bachelor's
degree might actually be able to help on, and where I can start. Obviously
I'm not going to be able to just dive into a 6-year-running project without
some prior research, so I'm looking for a start.

What are some current things that are lacking in Bitcoin core? Or am I
better off making something else for the ecosystem?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150416/ea93eee5/attachment.html>
-------------- next part --------------
------------------------------------------------------------------------------
BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT
Develop your own process in accordance with the BPMN 2 standard
Learn Process modeling best practices with Bonita BPM through live exercises
http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual- event?utm_
source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF
-------------- next part --------------
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development at lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development

From pieter.wuille at gmail.com  Thu Apr 16 05:22:00 2015
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Wed, 15 Apr 2015 22:22:00 -0700
Subject: [Bitcoin-development] 75%/95% threshold for transaction versions
In-Reply-To: <552EF785.7000207@sky-ip.org>
References: <552EF785.7000207@sky-ip.org>
Message-ID: <CAPg+sBgAhdgPPjmT5i0PMYhQo=Hk6Weo8tpX_Wyn-NJ5Ye9D_A@mail.gmail.com>

On Apr 16, 2015 1:46 AM, "s7r" <s7r at sky-ip.org> wrote:
> but for transaction versions? In simple terms, if > 75% from all the
> transactions in the latest 1000 blocks are version 'n', mark all
> previous transaction versions as non-standard and if > 95% from all the
> transactions in the latest 1000 blocks are version 'n' mark all previous
> transaction versions as invalid.

What problem are you trying to solve?

The reason why BIP62 (as specified, it is just a draft) does not make v1
transactions invalid is because it is opt-in. The creator of a transaction
needs to agree to protect it from malleability, and this subjects him to
extra rules in the creation.

Forcing v3 transactions would require every piece of wallet software to be
changed.

-- 
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150415/a603225e/attachment.html>

From mike at plan99.net  Thu Apr 16 12:33:56 2015
From: mike at plan99.net (Mike Hearn)
Date: Thu, 16 Apr 2015 13:33:56 +0100
Subject: [Bitcoin-development] Where do I start?
In-Reply-To: <CANJO25KXoYXKZf-TZRD3HviU141+rYUB2d=4Xf9DqRrzD9P94w@mail.gmail.com>
References: <CANJO25K1Lox5aU-NN-j0An2ujNNHwPWNqX1ZXMs+z1udDZ1LOA@mail.gmail.com>
	<CANJO25KXoYXKZf-TZRD3HviU141+rYUB2d=4Xf9DqRrzD9P94w@mail.gmail.com>
Message-ID: <CANEZrP0vJug1tGNiL5wQUuA0-rr3eM1Yp8DbO3Apiu1CX=j3bQ@mail.gmail.com>

Hey Gabe,

That's diving into the deep end for sure! :)

> What are some current things that are lacking in Bitcoin core? Or am I
> better off making something else for the ecosystem?
>
That depends on your interests.

Many of the highest priority tasks in Bitcoin Core are rather complicated,
unfortunately, even for people with experience. You can consult the issue
tracker to get a feel for it.

Alternatively, there are lots of wallet apps out there and plenty of more
straightforward projects on them. However they may have less of a research
flavour.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150416/28c1c233/attachment.html>

From vertoe at qhor.net  Thu Apr 16 13:11:01 2015
From: vertoe at qhor.net (Vertoe Qhor)
Date: Thu, 16 Apr 2015 15:11:01 +0200
Subject: [Bitcoin-development] Request For Discussion / BIP number -
 Multi-Currency Hierarchy For Use In Multisignature Deterministic Wallets
In-Reply-To: <5526DE29.1060605@maza.club>
References: <5524D347.4040507@maza.club>	<CABjHNoTbLz+dCPkctk95jPkdnagQQxOintYgswKCE6wB=TS9xg@mail.gmail.com>	<CACvEmnE6jgeRmTbyoOfW+jf=EB_EmPN4FdBXz-anm4tfKJscqw@mail.gmail.com>	<CABjHNoR_Tg6bq3mJ8vkFAOPNHz8RS-FKAEx9APMZAVhct5H0SA@mail.gmail.com>
	<5526DE29.1060605@maza.club>
Message-ID: <552FB4E5.1010103@qhor.net>

I'm supporting this proposal and since I'm already using the Encompass
wallet software I would like to highlight that this use case is not only
practical but has already a working reference implementation.

The only donwside I see is that it means we get yet another HD wallet
definition.

Is there anything else what would speak against assigning a BIP number
to this proposal? This would allow kefkius and his team to use the
standard in Encompass and share it with other software packages which
might be interested in using deterministic cross-currency wallets.

On 04/09/2015 10:16 PM, Kefkius wrote:
> William,
>
> I've amended the proposal's "Motivation" section slightly for
> clarification. I'm not sure how a "cosigner_index" branch would benefit
> this proposal. Granted, I don't fully understand the benefits of the
> "cosigner_index" branch in BIP-0045. From what I understand, the
> "wallet" branch of my proposal seems to accomplish a similar goal.
>
> Jona,
>
> Your explanation is correct. As for this being appropriate as a BIP, I
> agree that it's an arguable point to say it improves Bitcoin. However,
> this proposal exists because of BIP-0044, which also describes a
> multi-currency hierarchy. For that reason, I think this is an
> appropriate proposal.
>
> Thank you both for your feedback.
>
> On 04/08/2015 12:41 PM, William Swanson wrote:
>> Oops, sorry I missed that.
>>
>> Since that's the reason this proposal exists, I would consider putting
>> it right up top where people can see it. Also, since this proposal is
>> specifically designed for multi-sig, I would look at what BIP45 is
>> doing and maybe incorporate a "cosigner_index" branch. Otherwise, this
>> idea seems like a reasonable way to organize a wallet.
>>
>> -William
>>
>> On Wed, Apr 8, 2015 at 9:28 AM, ?????? <kinoshitajona at gmail.com> wrote:
>>> William,
>>>
>>> I believe the reasoning for this is stated in the Coin Type section.
>>>
>>> "Public derivation is used so that cosigners need only know one of each
>>> other's public keys, rather than needing to distribute public keys for each
>>> coin."
>>>
>>> BIP44 has a coin level, but it's a private derived level, so cosigners would
>>> not be able to generate multiple crypto currencies of each others' without
>>> giving each other n xpubs where n is the number of currencies shared. This
>>> new proposal basically sticks coin type on the public derivation side of
>>> things so that I could generate litecoin or darkcoin multisigs without your
>>> permission...
>>>
>>> Kefkius,
>>>
>>> This BIP seems like a good fit for multi-currency wallets based on multisig.
>>> So kudos for putting it in writing.
>>>
>>> However, I don't know if this is really a BIP thing. It's not improving
>>> Bitcoin (Bitcoin Improvement Proposal... remember?), in fact, by definition
>>> it is improving altcoin usability.
>>>
>>> For that reason alone I will say I disagree for a BIP for this.
>>> - Jona
>>>
>>>
>>> 2015-04-08 16:46 GMT+09:00 William Swanson <swansontec at gmail.com>:
>>>> It's not really clear why this is better than BIP 44 as it already
>>>> stands. You have the same fields, but they are just in a different
>>>> order. Couldn't you just use the existing BIP 44 hierarchy, but add
>>>> the convention that "wallet/account N" is the same wallet in each
>>>> supported currency?
>>>>
>>>> For example, if I have a wallet called "business expenses", which
>>>> happens to be wallet m / 44' / 0' / 5', for Bitcoin, then the same
>>>> wallet would be m / 44' / 3' / 5' for Dogecoin, and m / 44' / 2' / 5'
>>>> for Litecoin.
>>>>
>>>> I am trying to think of examples where your proposal is better than
>>>> BIP 44, but I can't think of any. Even backup recovery works fine. I
>>>> assume that your idea is to continue iterating over the different
>>>> wallet indices as long as you are finding funds in *any* currency.
>>>> Well, you can still do that with BIP 44. The fields are in a different
>>>> order, but that doesn't affect the algorithm in any way.
>>>>
>>>> Maybe you have some deeper insight I'm not seeing, but if so, you need
>>>> to clearly explain that in your motivation section. The current
>>>> explanation, "This limits the possible implementations of
>>>> multi-currency, multisignature wallets," is pretty vauge. Also, there
>>>> is nothing in this spec that addresses the multisignature use-case.
>>>> The BIP 45 spec does a lot of extra work to make multisignature work
>>>> smoothly.
>>>>
>>>> I'm not trying to criticize your proposal. I'm just trying to
>>>> understand what it's trying to accomplish.
>>>>
>>>> -William Swanson
>>>>
>>>>
>>>> On Wed, Apr 8, 2015 at 12:05 AM, Kefkius <kefkius at maza.club> wrote:
>>>>> I have a potential BIP, "Multi-Currency Hierarchy For Use In
>>>>> Multisignature Deterministic Wallets." I'm requesting discussion on it,
>>>>> and possibly assignment of a BIP number.
>>>>>
>>>>> It's located in this github gist:
>>>>> https://gist.github.com/Kefkius/1aa02945e532f8739023
>> ------------------------------------------------------------------------------
>> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT
>> Develop your own process in accordance with the BPMN 2 standard
>> Learn Process modeling best practices with Bonita BPM through live exercises
>> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual- event?utm_
>> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
> ------------------------------------------------------------------------------
> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT
> Develop your own process in accordance with the BPMN 2 standard
> Learn Process modeling best practices with Bonita BPM through live exercises
> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual- event?utm_
> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development




From s7r at sky-ip.org  Thu Apr 16 16:12:35 2015
From: s7r at sky-ip.org (s7r)
Date: Thu, 16 Apr 2015 19:12:35 +0300
Subject: [Bitcoin-development] 75%/95% threshold for transaction versions
In-Reply-To: <CAPg+sBgAhdgPPjmT5i0PMYhQo=Hk6Weo8tpX_Wyn-NJ5Ye9D_A@mail.gmail.com>
References: <552EF785.7000207@sky-ip.org>
	<CAPg+sBgAhdgPPjmT5i0PMYhQo=Hk6Weo8tpX_Wyn-NJ5Ye9D_A@mail.gmail.com>
Message-ID: <552FDF73.6010104@sky-ip.org>

Hi Pieter,

Thanks for your reply. I agree. Allen has a good point in the previous
email too, so the suggestion might not fix anything and complicate things.

The problem I am trying to solve is making all transactions
non-malleable by default. I guess there is a very good reason why BIP62
will not touch v1 anyway.

I am trying to build a bitcoin contract which will relay on 3 things:
- coinjoin / txes with inputs from multiple users which are signed by
all users after they are merged together (every user is sure his coins
will not be spent without the other users to spend anything, as per
agreed contract);
- pre-signed txes with nLockTime 'n' weeks. These txes will be signed
before the inputs being spent are broadcasted/confirmed, using the txid
provided by the user before broadcasting it. Malleability hurts here.
- P2SH

In simple terms, how malleable transactions really are in the network at
this moment? Who can alter a txid without invalidating the tx? Just the
parties who sign it? The miners? Anyone in the network? This is a little
bit unclear to me.

Another thing I would like to confirm, the 3 pieces of the bitcoin
protocol mentioned above will be supported in _any_ future transaction
version or block version, regardless what changes are made or features
added to bitcoin core? The contract needs to be built and left unchanged
for a very very long period of time...


On 4/16/2015 8:22 AM, Pieter Wuille wrote:
> 
> On Apr 16, 2015 1:46 AM, "s7r" <s7r at sky-ip.org <mailto:s7r at sky-ip.org>>
> wrote:
>> but for transaction versions? In simple terms, if > 75% from all the
>> transactions in the latest 1000 blocks are version 'n', mark all
>> previous transaction versions as non-standard and if > 95% from all the
>> transactions in the latest 1000 blocks are version 'n' mark all previous
>> transaction versions as invalid.
> 
> What problem are you trying to solve?
> 
> The reason why BIP62 (as specified, it is just a draft) does not make v1
> transactions invalid is because it is opt-in. The creator of a
> transaction needs to agree to protect it from malleability, and this
> subjects him to extra rules in the creation.
> 
> Forcing v3 transactions would require every piece of wallet software to
> be changed.
> 
> -- 
> Pieter
> 



From mark at friedenbach.org  Thu Apr 16 17:34:31 2015
From: mark at friedenbach.org (Mark Friedenbach)
Date: Thu, 16 Apr 2015 10:34:31 -0700
Subject: [Bitcoin-development] 75%/95% threshold for transaction versions
In-Reply-To: <552FDF73.6010104@sky-ip.org>
References: <552EF785.7000207@sky-ip.org>
	<CAPg+sBgAhdgPPjmT5i0PMYhQo=Hk6Weo8tpX_Wyn-NJ5Ye9D_A@mail.gmail.com>
	<552FDF73.6010104@sky-ip.org>
Message-ID: <CAOG=w-vMjysbF5H8wWN2y45U3djFwpKMtXq3vCvB=-eFr7GqFg@mail.gmail.com>

At this moment anyone can alter the txid. Assume transactions are 100%
malleable.
On Apr 16, 2015 9:13 AM, "s7r" <s7r at sky-ip.org> wrote:

> Hi Pieter,
>
> Thanks for your reply. I agree. Allen has a good point in the previous
> email too, so the suggestion might not fix anything and complicate things.
>
> The problem I am trying to solve is making all transactions
> non-malleable by default. I guess there is a very good reason why BIP62
> will not touch v1 anyway.
>
> I am trying to build a bitcoin contract which will relay on 3 things:
> - coinjoin / txes with inputs from multiple users which are signed by
> all users after they are merged together (every user is sure his coins
> will not be spent without the other users to spend anything, as per
> agreed contract);
> - pre-signed txes with nLockTime 'n' weeks. These txes will be signed
> before the inputs being spent are broadcasted/confirmed, using the txid
> provided by the user before broadcasting it. Malleability hurts here.
> - P2SH
>
> In simple terms, how malleable transactions really are in the network at
> this moment? Who can alter a txid without invalidating the tx? Just the
> parties who sign it? The miners? Anyone in the network? This is a little
> bit unclear to me.
>
> Another thing I would like to confirm, the 3 pieces of the bitcoin
> protocol mentioned above will be supported in _any_ future transaction
> version or block version, regardless what changes are made or features
> added to bitcoin core? The contract needs to be built and left unchanged
> for a very very long period of time...
>
>
> On 4/16/2015 8:22 AM, Pieter Wuille wrote:
> >
> > On Apr 16, 2015 1:46 AM, "s7r" <s7r at sky-ip.org <mailto:s7r at sky-ip.org>>
> > wrote:
> >> but for transaction versions? In simple terms, if > 75% from all the
> >> transactions in the latest 1000 blocks are version 'n', mark all
> >> previous transaction versions as non-standard and if > 95% from all the
> >> transactions in the latest 1000 blocks are version 'n' mark all previous
> >> transaction versions as invalid.
> >
> > What problem are you trying to solve?
> >
> > The reason why BIP62 (as specified, it is just a draft) does not make v1
> > transactions invalid is because it is opt-in. The creator of a
> > transaction needs to agree to protect it from malleability, and this
> > subjects him to extra rules in the creation.
> >
> > Forcing v3 transactions would require every piece of wallet software to
> > be changed.
> >
> > --
> > Pieter
> >
>
>
> ------------------------------------------------------------------------------
> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT
> Develop your own process in accordance with the BPMN 2 standard
> Learn Process modeling best practices with Bonita BPM through live
> exercises
> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual-
> event?utm_
> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150416/17968d0a/attachment.html>

From s7r at sky-ip.org  Thu Apr 16 23:17:53 2015
From: s7r at sky-ip.org (s7r)
Date: Fri, 17 Apr 2015 02:17:53 +0300
Subject: [Bitcoin-development] 75%/95% threshold for transaction versions
In-Reply-To: <CAOG=w-vMjysbF5H8wWN2y45U3djFwpKMtXq3vCvB=-eFr7GqFg@mail.gmail.com>
References: <552EF785.7000207@sky-ip.org>	<CAPg+sBgAhdgPPjmT5i0PMYhQo=Hk6Weo8tpX_Wyn-NJ5Ye9D_A@mail.gmail.com>	<552FDF73.6010104@sky-ip.org>
	<CAOG=w-vMjysbF5H8wWN2y45U3djFwpKMtXq3vCvB=-eFr7GqFg@mail.gmail.com>
Message-ID: <55304321.3030300@sky-ip.org>



On 4/16/2015 8:34 PM, Mark Friedenbach wrote:
> At this moment anyone can alter the txid. Assume transactions are 100%
> malleable.
> 

Anyone can alter the txid - more details needed. The number of altered
txids in practice is not so high in order to make us believe anyone can
do it easily. It is obvious that all current bitcoin transactions are
malleable, but not by anyone and not that easy. At least I like to think so.

>From your answer I understand that right now if I create a transaction
(tx1) and broadcast it, you can alter its txid at your will, without any
mining power and/or access to my private keys so I would end up not
recognizing my own transaction and probably my change too (if my systems
rely hardly on txid)?

> On Apr 16, 2015 9:13 AM, "s7r" <s7r at sky-ip.org <mailto:s7r at sky-ip.org>>
> wrote:
> 
>     Hi Pieter,
> 
>     Thanks for your reply. I agree. Allen has a good point in the previous
>     email too, so the suggestion might not fix anything and complicate
>     things.
> 
>     The problem I am trying to solve is making all transactions
>     non-malleable by default. I guess there is a very good reason why BIP62
>     will not touch v1 anyway.
> 
>     I am trying to build a bitcoin contract which will relay on 3 things:
>     - coinjoin / txes with inputs from multiple users which are signed by
>     all users after they are merged together (every user is sure his coins
>     will not be spent without the other users to spend anything, as per
>     agreed contract);
>     - pre-signed txes with nLockTime 'n' weeks. These txes will be signed
>     before the inputs being spent are broadcasted/confirmed, using the txid
>     provided by the user before broadcasting it. Malleability hurts here.
>     - P2SH
> 
>     In simple terms, how malleable transactions really are in the network at
>     this moment? Who can alter a txid without invalidating the tx? Just the
>     parties who sign it? The miners? Anyone in the network? This is a little
>     bit unclear to me.
> 
>     Another thing I would like to confirm, the 3 pieces of the bitcoin
>     protocol mentioned above will be supported in _any_ future transaction
>     version or block version, regardless what changes are made or features
>     added to bitcoin core? The contract needs to be built and left unchanged
>     for a very very long period of time...
> 
> 
>     On 4/16/2015 8:22 AM, Pieter Wuille wrote:
>     >
>     > On Apr 16, 2015 1:46 AM, "s7r" <s7r at sky-ip.org
>     <mailto:s7r at sky-ip.org> <mailto:s7r at sky-ip.org <mailto:s7r at sky-ip.org>>>
>     > wrote:
>     >> but for transaction versions? In simple terms, if > 75% from all the
>     >> transactions in the latest 1000 blocks are version 'n', mark all
>     >> previous transaction versions as non-standard and if > 95% from
>     all the
>     >> transactions in the latest 1000 blocks are version 'n' mark all
>     previous
>     >> transaction versions as invalid.
>     >
>     > What problem are you trying to solve?
>     >
>     > The reason why BIP62 (as specified, it is just a draft) does not
>     make v1
>     > transactions invalid is because it is opt-in. The creator of a
>     > transaction needs to agree to protect it from malleability, and this
>     > subjects him to extra rules in the creation.
>     >
>     > Forcing v3 transactions would require every piece of wallet
>     software to
>     > be changed.
>     >
>     > --
>     > Pieter
>     >
> 
>     ------------------------------------------------------------------------------
>     BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT
>     Develop your own process in accordance with the BPMN 2 standard
>     Learn Process modeling best practices with Bonita BPM through live
>     exercises
>     http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual-
>     event?utm_
>     source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF
>     _______________________________________________
>     Bitcoin-development mailing list
>     Bitcoin-development at lists.sourceforge.net
>     <mailto:Bitcoin-development at lists.sourceforge.net>
>     https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> 



From pieter.wuille at gmail.com  Fri Apr 17 09:02:19 2015
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Fri, 17 Apr 2015 02:02:19 -0700
Subject: [Bitcoin-development] 75%/95% threshold for transaction versions
In-Reply-To: <55304321.3030300@sky-ip.org>
References: <552EF785.7000207@sky-ip.org>
	<CAPg+sBgAhdgPPjmT5i0PMYhQo=Hk6Weo8tpX_Wyn-NJ5Ye9D_A@mail.gmail.com>
	<552FDF73.6010104@sky-ip.org>
	<CAOG=w-vMjysbF5H8wWN2y45U3djFwpKMtXq3vCvB=-eFr7GqFg@mail.gmail.com>
	<55304321.3030300@sky-ip.org>
Message-ID: <CAPg+sBi3QgJK7-PuV-1vbur0AMUeXddUdv_-Mcjwgbefqj3rFg@mail.gmail.com>

> Anyone can alter the txid - more details needed. The number of altered
> txids in practice is not so high in order to make us believe anyone can
> do it easily. It is obvious that all current bitcoin transactions are
> malleable, but not by anyone and not that easy. At least I like to think
so.

Don't assume that because it does not (frequently) happen, that it cannot
happen. Large amounts of malleated transactions have happened in the past.
Especially if you build a system depends on non-malleability for its
security, you may at some point have an attacker who has financial gain
from malleation.

> >From your answer I understand that right now if I create a transaction
> (tx1) and broadcast it, you can alter its txid at your will, without any
> mining power and/or access to my private keys so I would end up not
> recognizing my own transaction and probably my change too (if my systems
> rely hardly on txid)?

In theory, yes, anyone can alter the txid without invalidating it, without
mining power and without access to the sender's private keys.

All it requires is seeing a transaction on the network, doing a trivial
modification to it, and rebroadcasting it quickly. If the modifies version
gets mined, you're out of luck. Having mining power helps of course.

After BIP62, you will, as a sender, optionally be able to protect others
from malleating. You're always able to re-sign yourself.

-- 
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150417/0f221669/attachment.html>

From s7r at sky-ip.org  Sat Apr 18 14:49:53 2015
From: s7r at sky-ip.org (s7r)
Date: Sat, 18 Apr 2015 17:49:53 +0300
Subject: [Bitcoin-development] 75%/95% threshold for transaction versions
In-Reply-To: <CAPg+sBi3QgJK7-PuV-1vbur0AMUeXddUdv_-Mcjwgbefqj3rFg@mail.gmail.com>
References: <552EF785.7000207@sky-ip.org>	<CAPg+sBgAhdgPPjmT5i0PMYhQo=Hk6Weo8tpX_Wyn-NJ5Ye9D_A@mail.gmail.com>	<552FDF73.6010104@sky-ip.org>	<CAOG=w-vMjysbF5H8wWN2y45U3djFwpKMtXq3vCvB=-eFr7GqFg@mail.gmail.com>	<55304321.3030300@sky-ip.org>
	<CAPg+sBi3QgJK7-PuV-1vbur0AMUeXddUdv_-Mcjwgbefqj3rFg@mail.gmail.com>
Message-ID: <55326F11.1010605@sky-ip.org>

Understood. That is unfortunate, but not the end of the world. If you
could please give feedback also to these last comments / questions:

How far are we at this moment from BIP62? Can an user send a
non-malleable tx now, if enforces some additional rules?

As for the security of the system, it does not fully rely on txids being
non malleable, but see this quote from my previous email:

[QUOTE]
I am trying to build a bitcoin contract which will relay on 3 things:
- coinjoin / txes with inputs from multiple users which are signed by
all users after they are merged together (every user is sure his coins
will not be spent without the other users to spend anything, as per
agreed contract);
- pre-signed txes with nLockTime 'n' weeks. These txes will be signed
before the inputs being spent are broadcasted/confirmed, using the txid
provided by the user before broadcasting it. Malleability hurts here.
- P2SH

Another thing I would like to confirm, the 3 pieces of the bitcoin
protocol mentioned above will be supported in _any_ future transaction
version or block version, regardless what changes are made or features
added to bitcoin core? The contract needs to be built and left unchanged
for a very very long period of time...
[/END QUOTE]

Can you comment on the quote please?

So, basically transaction malleability could affect the system in the
way that a pre-signed tx which offers the insurance and which is sent to
the user before the user sends the coins (spending user's coins back to
him after a certain period of time) could be invalidated. The insurance
tx signature will still be good, but invalid overall since the input
(txid) being spent does not exist (was altered / modified). The coins
won't be stolen or lost, but a new tx needs to be signed with the
altered (new) txid, for the system to work.

So, an user creates a transaction TX1 sending the coins to the server
but does not broadcast it. Instead, he provides the txid of TX1 to the
server. Server generates another transaction TX2 which spends TX1 back
to the user, with an nLockTime. User checks and if everything ok
broadcasts TX1. In case the txid of TX1 will be altered/modified, TX2
will become invalid (since it will be spending an inexistent input), and
the server will need to re-create and sign TX2 with the new
(altered/modified) txid of TX1, as per agreed contract. Should the
server disappear after user broadcasts TX1 and before the
altered/modified txid of TX1 gets confirmed, user's coins are forever
locked. It is true that no third party can benefit from this type of
attack, only the user will result with coins locked, but it is something
which could be used by competition to make a service useless / annoying
/ too complicated or less safe to use.

How could I mitigate this?

Thanks you for your time and help.

On 4/17/2015 12:02 PM, Pieter Wuille wrote:
>> Anyone can alter the txid - more details needed. The number of altered
>> txids in practice is not so high in order to make us believe anyone can
>> do it easily. It is obvious that all current bitcoin transactions are
>> malleable, but not by anyone and not that easy. At least I like to
> think so.
> 
> Don't assume that because it does not (frequently) happen, that it
> cannot happen. Large amounts of malleated transactions have happened in
> the past. Especially if you build a system depends on non-malleability
> for its security, you may at some point have an attacker who has
> financial gain from malleation.
> 
>> >From your answer I understand that right now if I create a transaction
>> (tx1) and broadcast it, you can alter its txid at your will, without any
>> mining power and/or access to my private keys so I would end up not
>> recognizing my own transaction and probably my change too (if my systems
>> rely hardly on txid)?
> 
> In theory, yes, anyone can alter the txid without invalidating it,
> without mining power and without access to the sender's private keys.
> 
> All it requires is seeing a transaction on the network, doing a trivial
> modification to it, and rebroadcasting it quickly. If the modifies
> version gets mined, you're out of luck. Having mining power helps of course.
> 
> After BIP62, you will, as a sender, optionally be able to protect others
> from malleating. You're always able to re-sign yourself.
> 
> -- 
> Pieter
> 



From pete at petertodd.org  Sat Apr 18 23:33:52 2015
From: pete at petertodd.org (Peter Todd)
Date: Sat, 18 Apr 2015 19:33:52 -0400
Subject: [Bitcoin-development] Build your own nHashType
In-Reply-To: <CABHVRKQOSHBzkWGoKROcXJd-mKcb3FvLLdSYMgOZJ3gC1zjNnw@mail.gmail.com>
References: <CABHVRKTNFoLm9LEO=ctT_UP9zW7QOMQzVXitKC=PAzj=HG9OHg@mail.gmail.com>
	<CANEZrP12kZ8vRAo=feprJ9_oRXUPKJ=iF6kZdxxbai=TxjzM9g@mail.gmail.com>
	<CABHVRKSET18D13+yi4MTPs6+4xwUD5vuJszCOJG9CaTi0+CAvA@mail.gmail.com>
	<CAJHLa0NgV=6D=TAy4sm_EAfYiZULK-d9GMcddW1-DZRHCE8Sew@mail.gmail.com>
	<20150409172808.GB27775@muck>
	<CABHVRKQOSHBzkWGoKROcXJd-mKcb3FvLLdSYMgOZJ3gC1zjNnw@mail.gmail.com>
Message-ID: <20150418233352.GA9878@muck>

On Thu, Apr 09, 2015 at 10:56:20PM -0400, Stephen Morse wrote:
> On Thu, Apr 9, 2015 at 1:28 PM, Peter Todd <pete at petertodd.org> wrote:
> 
> > For the OP: Have you looked at how CODESEPARATOR allows the signature to
> > sign code to run as part of verifying the signature? E.g. my signature
> > can say "valid if you run these additional opcodes and they return true"
> > where those additional opcodes take the transaction, hash it in the
> > defined way, and verify that the ECC signature correctly signs that
> > hash and the hash of the additional opcodes. For instance in this case
> > making a signature that's only valid if the tx fee is less than the
> > defined amount would be a matter of GET_FEE <max fee + 1> LESSTHAN VERIFY
> >
> 
> I've never been able to really see a good use case for OP_CODESEPARATOR,
> and I'm not sure I completely have my head wrapped around what you're
> proposing. From this
> <http://bitcoin.stackexchange.com/questions/34013/what-is-op-codeseparator-used-for>
>  and this
> <https://bitcointalk.org/index.php?topic=52949.msg631255#msg631255>,
> though, it seems like OP_CODESEPARATOR cannot really be made useful unless
> you already have a way to sign without hashing the TXIDs referenced by your
> input, in which case you need to modify the nHashType.

I wrote up how to do this on #bitcoin-wizards, Dec 9th 2014:

17:13 < petertodd> hearn: even now you can use OP_CODESEPARATOR to
implement efficient payword schemes
17:14 < petertodd> hearn: early on you could have used it to do some
really useful after-the-fact signing delegation by wrapping a IF ENDIF
around the CODESEPARATOR introduced into the middle of the
scriptSig/scriptPubKey pair - shame we got rid of that without thinking
the design through
17:15 < petertodd> hearn: e.g. "create a signature that delegates
signing authority to another pubkey"
17:15 < petertodd> probably all 100% accidental... but a nice accident
17:16 < hearn> it's probably for the best. i can imagine such things
being a surprise for implementations not expecting them. a script 2.0
effort that incorporates lots of neat features but still lets script 1.0
work would be nice to have, one day
17:17 < petertodd> satoshi belived in 1 implementation, and by putting
CODESEPARATOR into the scriptSig/scriptPubKey concatenation you had to
opt-in to making that feature possible to use in any particular
scriptPubKey
17:17 < petertodd> w/o the mis-matched ENDIF you can't pull off that
trick because you can't turn CODESEPARATOR off
17:19 < petertodd> to be explicit: scriptPubKey: ENDIF <pubkey>
CHECKSIG, then the normal case is scriptSig: <signature> 1 IF
17:19 < petertodd> they concatenate to  <signature> 1 IF ENDIF <pubkey>
CHECKSIG, CODESEPARATOR is evaluated, and the signature is evaluated on
the script ENDIF <pubkey> CHECKSIG
17:20 < petertodd> to delegate signing authority after the fact sign a
signature on the script <pubkey2> 0 IF ENDIF <pubkey> CHECKSIG
17:21 < petertodd> (remember that CODESEPARATORS are removed by
SignatureHash())
17:22 < petertodd> oops, I mean: <pubkey2> CHECKSIGVERIFY 0 IF ENDIF
<pubkey> CHECKSIG
17:22 < petertodd> anyway, to finally spend it, create another signature
with pubkey2 signing the script <pubkey2> CHECKSIGVERIFY 0 IF ENDIF
<pubkey> CHECKSIG again, and finally spend it with the scriptSig:
<pubkey-sig> <pubkey2-sig> CODESEPARATOR <pubkey2> 0 IF
17:24 < petertodd> after concatenation the script: <pubkey-sig>
<pubkey2-sig> CODESEPARATOR <pubkey2> 0 IF CODESEPARATOR ENDIF <pubkey>
CHECKSIG is evaluated, the inner signature satisfies, and the outer
signature is satisfied only if the scriptPubKey was essentially changed
after the fact to also require the inner, second, pubkey2 to be
satisfied
17:26 < petertodd> a nice use-case would, forinstance, have been to have
a signing robot be able to create signatures offline for a given txout
with SIGHASH_SINGLE such that you had a spending limit enforced, and
exactly who was then allowed to spend the funds - say a department of a
company - could be picked after the fact without re-spending the txout
17:33 < petertodd> gmaxwell: re: script validation state, a good model
would be to have the tx input to EvalScript() essentially be a
CMerkleTx, and the prevout scriptPubKey be the prevout CTxOut (*maybe*
the prevout tx itself... bit dubious there...)

-- 
'peter'[:-1]@petertodd.org
00000000000000000e7980aab9c096c46e7f34c43a661c5cb2ea71525ebb8af7
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150418/c061fc49/attachment.sig>

From laanwj at gmail.com  Tue Apr 21 07:22:41 2015
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Tue, 21 Apr 2015 09:22:41 +0200
Subject: [Bitcoin-development] Bitcoin Core 0.10.1 release candidate 3
	available
Message-ID: <20150421072240.GA27027@amethyst.visucore.com>


I've just uploaded Bitcoin Core 0.10.1rc3 executables to:

https://bitcoin.org/bin/bitcoin-core-0.10.1/test/

The source code can be found in git under the tag 'v0.10.1rc3' on the `0.10` branch.

New in this RC is another batch of bug fixes,

- `eae305f` Fix missing lock in submitblock
- `57d1f46` Fix CheckBlockIndex for reindex
- `bac6fca` Set nSequenceId when a block is fully linked
- `139cd81` Cap nAttempts penalty at 8 and switch to pow instead of a division loop
- `323de27` `7494e09` `df45564` Various initialization setup environment locale fixes

Full (preliminary) release notes for 0.10.1 can be found at https://github.com/bitcoin/bitcoin/blob/v0.10.1rc3/doc/release-notes.md 

Thanks to everyone that participated in development or in the gitian build process. I sincerely hope that this can be the final release candidate for 0.10.1,

Wladimir




From pete at petertodd.org  Tue Apr 21 07:59:12 2015
From: pete at petertodd.org (Peter Todd)
Date: Tue, 21 Apr 2015 03:59:12 -0400
Subject: [Bitcoin-development] Relative CHECKLOCKTIMEVERIFY (was CLTV
 proposal)
In-Reply-To: <55075795.20904@bluematt.me>
References: <20141001130826.GM28710@savin.petertodd.org>
	<55075795.20904@bluematt.me>
Message-ID: <20150421075912.GA25282@savin.petertodd.org>

On Mon, Mar 16, 2015 at 10:22:13PM +0000, Matt Corallo wrote:
> In building some CLTV-based contracts, it is often also useful to have a
> method of requiring, instead of locktime-is-at-least-N,
> locktime-is-at-least-N-plus-the-height-of-my-input. ie you could imagine
> an OP_RELATIVECHECKLOCKTIMEVERIFY that reads (does not pop) the top
> stack element, adds the height of the output being spent and then has
> identical semantics to CLTV.

Depending on what you mean by "identical" this isn't actually reorg
safe. For instance consider this implementation:

    nLockTime = stack[-1] + prevout.nHeight
    if (nLockTime > txTo.nLockTime):
        return False

Used with this scriptPubKey:

    10 RCLTV DROP <pubkey> CHECKSIG

If I create that output in tx1 which is mined at height 42 I can spend
it in a tx2 at height > 42+10 by setting tx2's nLockTime to >42+10, for
instance 53. However if a reorg happens and tx1 ends up at height 43
after the reorg I'm stuck - tx2's nLockTime is set at 42.

Thus RCTLV is only reorg safe if the height is compared against the
actual block height of the block containing the spending transaction,
not the spending transaction's nLockTime.

> A slightly different API (and different name) was described by maaku at
> http://www.reddit.com/r/Bitcoin/comments/2z2l91/time_to_lobby_bitcoins_core_devs_sf_bitcoin_devs/cpgc154
> which does a better job of saving softfork-available opcode space.
> 
> There are two major drawbacks to adding such an operation, however.
> 
> 1) More transaction information is exposed inside the script (prior to
> CLTV we only had the sigchecking operation exposed, with a CLTV and
> RCLTV/OP_CHECK_MATURITY_VERIFY we expose two more functions).
> 
> 2) Bitcoin Core's mempool invariant of "all transactions in the mempool
> could be thrown into one overside block and aside from block size, it
> would be valid" becomes harder to enforce. Currently, during reorgs,
> coinbase spends need checked (specifically, anything spending THE
> coinbase 100 blocks ago needs checked) and locktime transactions need
> checked. With such a new operation, any script which used this new
> opcode during its execution would need to be re-evaluated during reorgs.

Yup, definitely kinda ugly.

If the above style of RCTLV was used, one possibility might be to make
the relative locktime difference be required to be at least 100 blocks,
same as the coinbase maturity, and just accept that it's probably not
going to cause any problems, but could in an extremely big reorg. But
re-orgs that big might be big enough that we're screwed anyway...

With the 100 block rule, during a sufficiently large reorg that
coinbases become unavailble, simply disconnect entire blocks - all
txouts created by them.

> I think both of these requirements are reasonable and not particularly
> cumbersome, and the value of such an operation is quite nice for some
> protocols (including settings setting up a contest interval in a
> sidechain data validation operation).

So to be clear, right now the minimal interface to script execution is
simply:

    int bitcoinconsensus_verify_script(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen,
                                       const unsigned char *txTo        , unsigned int txToLen,
                                       unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err);

Where scriptPubKey is derived from the unspent coin in the UTXO set and
txTo is the transaction containing the script that is being executed.
The UTXO set itself currently contains CCoins entries, one for each
transaction with unspent outputs, which basically contain:

    nVersion - tx nVersion
    nHeight  - Height of the block the transaction is contained in.
    vout     - Unspent CTxOut's of the transaction.

The block nTime isn't directly available through the UTXO set, although
it can be found in the block headers. This does require nodes to have
the block headers, but at 4MB/year growth it's reasonable to assume the
UTXO set will grow faster.

Script execution does not have direct access to the current block
height/block time, however it does have indirect access via nLockTime.

Thus we have a few possibilities:

1) RCLTV against nLockTime

Needs a minimum age > COINBASE_MATURITY to be safe.


2) RCLTV against current block height/time

Completely reorg safe.


3) GET_TXOUT_HEIGHT/TIME <diff> ADD CLTV

To be reorg safe GET_TXOUT_HEIGHT/TIME must fail if minimum age <
COINBASE_MATURITY. This can be implemented by comparing against
nLockTime.


All three possibilities require us to make information about the
prevout's height/time available to VerifyScript(). The only question is
if we want VerifyScript() to also take the current block height/time - I
see no reason why it can't. As for the mempool, keeping track of what
transactions made use of these opcodes so they can be reevaluated if
their prevouts are re-organised seems fine to me.


Absolute CLTV
=============

If we are going to make the block height/time available to
VerifyScript() to implement RCLTV, should absolute CLTV should continue
to have the proposed behavior of checking against nLockTime? If we go
with RCLTV against current block height/time, I'm going to vote no,
because doing so needlessly limits it to only being able to compare
against a block height or a block time in a single transaction.
Similarly it can complicate multi-party signatures in some
circumstances, as all parties must agree on a common nLockTime.


Time-based locks
================

Do we want to support them at all? May cause incentive issues with
mining, see #bitcoin-wizards discussion, Jul 17th 2013:

https://download.wpsoftware.net/bitcoin/wizards/2013/07/13-07-17.log

-- 
'peter'[:-1]@petertodd.org
0000000000000000015e09479548c5b63b99a62d31b019e6479f195bf0cbd935
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150421/c66bedbc/attachment.sig>

From pete at petertodd.org  Tue Apr 21 11:37:14 2015
From: pete at petertodd.org (Peter Todd)
Date: Tue, 21 Apr 2015 07:37:14 -0400
Subject: [Bitcoin-development] Double spending and replace by fee
In-Reply-To: <C92CBBFE-A967-457B-B356-AF85F7BE8936@coinbase.com>
References: <CANEZrP3Prp6EFUdH_VDWkq508HkeFBMn+swzZ9ycAMsrOazFZA@mail.gmail.com>
	<FEB90DA4-2BF3-460F-8F35-9BCE929A2A31@petertodd.org>
	<C92CBBFE-A967-457B-B356-AF85F7BE8936@coinbase.com>
Message-ID: <20150421113714.GA3455@savin.petertodd.org>

On Wed, Apr 08, 2015 at 11:28:08PM -0700, Adrian Macneil wrote:
> Fwiw, Coinbase relies on the current first-seen mempool behaviour. Wide adoption of RBF (without a suitable replacement available) would make it extremely difficult to pitch bitcoin as a viable alternative to credit cards payments to large merchants.

Some questions:

1) Are you contractually obliged to accept zeroconf transactions with
   existing customers?

I keep hearing rumors of this, but would like some confirmation. In
particular, it would be good to know if you have the option of turning
zeroconf off at all, contractually speaking.


2) What are your double-spend losses to date?

3) Are you actively marketing zeroconf guarantees to new customers?

You're API is a bit unclear as to what exactly those guarantees are;
looks like they only apply if a merchant has "convert to fiat" turned
on.


4) What are your short, medium, and long term plans to move away from
   dependency on "first-seen" mempool policy?

e.g. hub-and-spoke payment channels, Lightning network, off-chain, etc.


5) What is your plan for new Bitcoin Core releases that break zeroconf
   via changed tx acceptance rules?

Basically every release we've ever made has added a zeroconf exploit due
to different tx acceptance rules. (e.g. my 95% success rate last summer)


6) What are your plans for Bitcoin Core releases that fundementally
   break zeroconf?

For instance changes like limiting the mempool size create zeroconf
vulnerabilities that can't be avoided in many situations. Yet they may
also be unavoidably needed for, for instance, DoS protection. Will you
oppose these improvements?


7) If a mining pool adopts adopted policy that broke zeroconf, e.g.
   replace-by-fee, would you take any action?

8) Would you take legal action against a mining pool for adopting
   replace-by-fee publicly?

9) Would you take action against a mining pool who is mining
   double-spends without explanation?

e.g. one that claims not to be running non-Bitcoin Core policy, but
keeps on mining double-spends.

-- 
'peter'[:-1]@petertodd.org
0000000000000000089abd68efc18c03d2a294295f3706a13966613a3ff3b390
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150421/af46a460/attachment.sig>

From kalle at rosenbaum.se  Wed Apr 22 20:03:47 2015
From: kalle at rosenbaum.se (Kalle Rosenbaum)
Date: Wed, 22 Apr 2015 22:03:47 +0200
Subject: [Bitcoin-development] Proof of Payment
In-Reply-To: <CAPswA9wNS2J=4YhpqWN8SmzJuUF8mek8XLUYTE+twLX9vM4Jhg@mail.gmail.com>
References: <CAPswA9zzVDxW8_WXg5833r2Z4pxZOppYtNLHMQ=Nw-H72cMz7w@mail.gmail.com>
	<A2849710-1069-45A1-89C0-9D8E40C4A8D6@newcastle.ac.uk>
	<CAPswA9wNS2J=4YhpqWN8SmzJuUF8mek8XLUYTE+twLX9vM4Jhg@mail.gmail.com>
Message-ID: <CAPswA9wZk_8EjbN8J-VbMGQ6nrZ7SthopJ=HYMtpxhSCsm_neA@mail.gmail.com>

Hi again

I've built a proof-of-concept for Proof of Payment. It's available at
http://www.rosenbaum.se:8080. The site contains links to the source code
for both the server and a Mycelium fork as well as pre-built apk:s.

I'm still very interested in feedback on this, so please let me know what
you think.

Stuff that has come up so far, and my answers:

* Some people think it's too complicated. I disagree. Using transactions as
the data structure actually makes it simple to implement both on the server
and in wallets. Just use existing wallet software to sign and verify PoPs.

* Other ideas on Proof of Payment use a single key from the proven
transaction, for example the first key from the first input of the
transaction. This is problematic when multisig and other P2SH transactions
are used. I also think that it's necessary to use *all* credentials used
for the transaction. Otherwise we wouldn't be sure that the sender actually
have all the needed credentials.

* Another suggestion is that a payment request from BIP70 is used as proof.
That is possible, but it's reusable which makes it inappropriate to send
over networks; If it is stolen somewhere, anyone can use it as many times
they like. As stated in BIP70, the payment request is suitable for dispute
resolution, more like a receipt. On the other hand, I think that PoP would
fit nicely into the workflow of BIP70: a) Read a url for the PoP request,
b) get the (possibly signed) PoP request. c) send the PoP through http POST
to the URL in the PoP request, d) profit!

* A thought of my own: The txid used in the PoP output is not strictly
necessary. It's more of a convenience for the verifier of the PoP. Without
it, the verifier would need to lookup the transaction based on the inputs
of the PoP,

Regards,
Kalle Rosenbaum

2015-03-14 19:16 GMT+01:00 Kalle Rosenbaum <kalle at rosenbaum.se>:

> Den 14 mar 2015 00:59 skrev "Patrick Mccorry (PGR)" <
> patrick.mccorry at newcastle.ac.uk>:
> >
> > That all seems more complicated than it needs to be - the service you
> are paying knows that it had received a payment from some public key Q
> (regardless of script type, as all scripts require a public key).
>
> The service knows it had received a payment from Q1, Q2,...,Qn. A tx may
> have multiple inputs and each input may have several public keys.
>
> >
> > So I want to rent a movie, they send me a challenge and I respond with a
> zero knowledge proof to demonstrate that I am the owner of Q, and as they
> know that Q made a payment - then there is a proof of payment - as this is
> provided by the time stamped transaction on the blockchain - in this sense
> you are bootstrapping trust from the blockchain.
> >
>
> Ok. Without knowing much about zero knowledge proof, i guess you'd need a
> challenge/response for each of the keys Q1,..,Qn. If we settle on only a
> single key, what key from what input should we use? One input may be a
> multisig (2 of 3) input. Is it ok to settle on only one of the multisig
> keys? Probably not. I'd say that we need 2 of 3 signatures (just as in a
> bitcoin transaction), and not necessarily the same two that made the
> payment.
>
> > For all of your scenarios, a simple challenge-response scheme would
> work. Adding an op_return makes the payment transaction worse as it is now
> distinguishable on the blockchain - you want use information that is
> already available on that transaction.
>
> I'm not sure I follow. Do you mean that it's a problem that the PoP itself
> reveals what transaction I'm proving? Well, maybe it is a problem under
> some circumstances. The least you can do to protect yourself from revealing
> information to third party is to communicate over secure channels. Could
> you please elaborate on this?
>
> Anyway, if both the client and the server knows what transaction to prove
> (ad-sign example) you are right that the tx info is kind of redundant. But
> if we don't send the tx hints from server to client, the client user must
> manually select the transaction to prove which makes the user experience
> worse.
>
> Thank you very much for your comments,
>
> /Kalle
>
> >
> > Sent from my iPhone
> >
> > On 13 Mar 2015, at 19:58, Kalle Rosenbaum <kalle at rosenbaum.se> wrote:
> >
> >> Hi all,
> >>
> >> I've been thinking about how a person can prove that she has made a
> payment. I came up with an idea I call Proof of Payment (PoP) and I would
> highly appreciate your comments. Has something like this been discussed
> somewhere before?
> >>
> >> Use cases
> >>
> >> There are several scenarios in which it would be useful to prove that
> you have paid for something. For example:
> >> A pre-paid hotel room where your PoP functions as a key to the door.
> >> An online video rental service where you pay for a video and watch it
> on any device.
> >> An ad-sign where you pay in advance for e.g. 2-weeks exclusivity.
> During this period you can upload new content to the sign whenever you like
> using PoP.
> >> A lottery where all participants pay to the same address, and the
> winner of the T-shirt is selected among the transactions to that address.
> You exchange the T-shirt for a PoP for the winning transaction.
> >>
> >> These use cases can be achieved without any personal information (no
> accounts, no e-mails, etc) being involved.
> >>
> >> Desirable properties:
> >> A PoP should be generated on demand.
> >> It should only be usable once to avoid issues due to theft.
> >> It should be able to create a PoP for any payment, regardless of script
> type (P2SH, P2PKH, etc.).
> >> Current methods of proving a payment, as I know of:
> >> BIP0070, The PaymentRequest together with the transactions fulfilling
> the payment makes some sort of proof. However, it does not meet 1 or 2 and
> it obviously only meets 3 if the payment is made through BIP0070. Also,
> there's no standard way to request/provide the proof.
> >> Signing messages, chosen by the entity that the proof is provided to,
> with the private keys used to sign the transaction. This could meet 1 and 2
> but probably not 3. This is not standardized either.
> >> Proof of Payment, the data structure
> >>
> >> A proof of payment for a transaction T, PoP(T), is used to prove that
> one has ownership of the credentials needed to unlock all the inputs of T.
> It has the exact same structure as a bitcoin transaction with the same
> inputs as T and with a single OP_RETURN output:
> >>
> >> OP_RETURN PoP <txid> <nonce>
> >>
> >> | Field     | Size [B] | Description                        |
> >> |-----------|----------|------------------------------------|
> >> | PoP       | 3        | Literal identifying this as a PoP  |
> >> | <txid>    | 32       | The transaction to Prove           |
> >> | <nonce>   | 5        | Unsigned integer                   |
> >>
> >> The PoP is signed using the same signing process that is used for
> bitcoin transactions. The purpose of the nonce is to make it harder to use
> a stolen PoP. Once the PoP has reached the destination, that PoP is useless
> since the destination will generate a new nonce for every PoP.
> >>
> >> Proof of Payment, the process
> >> A proof of payment request is sent from the server to the wallet. The
> request contains:
> >> a random nonce
> >> a destination where to send the PoP, for example a https URL
> >> data hinting the wallet which transaction to create a proof for. For
> example:
> >> txid, if known by the server
> >> PaymentRequest.PaymentDetails.merchant_data (in case of a BIP0070
> payment)
> >> amount
> >> label, message or other information from a BIP0021 URL
> >> The wallet identifies the transaction T, if possible. Otherwise asks
> the user to select among the ones that fit the hints in 1.3.
> >> The wallet checks that T is on the blockchain, meaning all the inputs
> are spent.
> >> The wallet creates an unsigned PoP (UPoP) for T, and asks the user to
> sign it.
> >> The user confirms
> >> The UPoP(T) is signed by the wallet, creating PoP(T).
> >> The PoP is sent to the destination in 1.2.
> >> The server receiving the PoP validates it and responds with ?valid? or
> ?invalid?
> >> The wallet displays the response in some way to the user.
> >> Remarks:
> >> The method of transferring the PoP request at step 1 is not very well
> thought through, but I think we can extend BIP0021 to cater for this. For
> example read a URI, representing a PoP request, using QR code or NFC. A
> more advanced approach would be to extend BIP0070.
> >> The nonce must be randomly generated by the server for every new PoP
> request.
> >> Validating a PoP
> >>
> >> The server needs to validate the PoP and reply with ?valid? or
> ?invalid?. That process is outlined below:
> >> Check the format of the PoP. It must pass normal transaction checks,
> except for the inputs being already spent.
> >> Check the output script. It must conform to the OP_RETURN output format
> outlined above.
> >> Check that the nonce is the same as the one you requested.
> >> Check that the txid in the output is the transaction you actually want
> proof for. If you don?t know what transaction you want proof for, check
> that the transaction actually pays for the product/service you deliver (in
> the video rental case, find the transaction among all payments for that
> specific video).
> >> Check that the inputs of the PoP are exactly the same as in transaction
> T.
> >> Check the signatures of all the inputs, as would be done on a normal
> transaction.
> >> If the signatures are valid, the PoP is valid.
> >> Security issues
> >> Someone can intercept the PoP-request and change the destination so
> that the user sends the PoP to the bad actor.
> >> Someone can intercept the PoP-request and change for example the txid
> to trick the user to sign a PoP for another transaction than the intended.
> This can of course be avoided by actually looking at the UPoP before
> signing it. The bad actor could also set hints for a transaction that the
> user didn?t make, resulting in a broken service.
> >> Someone can steal a PoP and try to use the service hoping to get a
> matching nonce. Probability per try: 1/(2^40). The server should have
> mechanism for detecting a brute force attack of this kind, or at least slow
> down the process by delaying the PoP request by some 100 ms or so.
> >> Even if a wallet has no funds it might still be valuable as a generator
> for PoPs. This makes it important to keep the security of the wallet after
> it has been emptied.
> >> The first two issues are the same as for traditional bitcoin payments.
> They could be mitigated by using secure connections and possibly also
> extending BIP0070 to support PoPs.
> >>
> >> Further work
> >> Figure out how to make use of, and extend, BIP0070 for the purpose of
> PoPs
> >> Define an extension for BIP0021 to support PoP requests (something
> along the lines of BIP0072)
> >> Implement a proof-of-concept
> >> Possibly propose BIPs for the different parts.
> >> Looking forward to reading your comments
> >> Regards,
> >> Kalle Rosenbaum
> >>
> >>
> ------------------------------------------------------------------------------
> >> Dive into the World of Parallel Programming The Go Parallel Website,
> sponsored
> >> by Intel and developed in partnership with Slashdot Media, is your hub
> for all
> >> things parallel software development, from weekly thought leadership
> blogs to
> >> news, videos, case studies, tutorials and more. Take a look and join
> the
> >> conversation now. http://goparallel.sourceforge.net/
> >>
> >> _______________________________________________
> >> Bitcoin-development mailing list
> >> Bitcoin-development at lists.sourceforge.net
> >> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150422/c92cc146/attachment.html>

From kalle at rosenbaum.se  Thu Apr 23 14:39:15 2015
From: kalle at rosenbaum.se (Kalle Rosenbaum)
Date: Thu, 23 Apr 2015 16:39:15 +0200
Subject: [Bitcoin-development] Proof of Payment
In-Reply-To: <55384AC9.80501@datamagi.no>
References: <CAPswA9zzVDxW8_WXg5833r2Z4pxZOppYtNLHMQ=Nw-H72cMz7w@mail.gmail.com>
	<A2849710-1069-45A1-89C0-9D8E40C4A8D6@newcastle.ac.uk>
	<CAPswA9wNS2J=4YhpqWN8SmzJuUF8mek8XLUYTE+twLX9vM4Jhg@mail.gmail.com>
	<CAPswA9wZk_8EjbN8J-VbMGQ6nrZ7SthopJ=HYMtpxhSCsm_neA@mail.gmail.com>
	<55384AC9.80501@datamagi.no>
Message-ID: <CAPswA9x7LGFjWce35+4=m1t-DCOA==R+6=1tdimgV7TsAkZ1MQ@mail.gmail.com>

Hi Martin,

Thank you very much for your comments. See my answers inline:

Den 23 apr 2015 03:28 skrev "Martin Lie" <martin at datamagi.no>:
>
> Hej, Kalle.
>
> I love the idea of standardised PoPs, including a protocol for
requesting/sending them as an extension of BIP-70.
>

Me too!

>
> A couple of comments:
>
> 1. You admit that the txid is just a convenience and not strictly
necessary. Perhaps this should be reflected in the sequence of bits/bytes
in the record you're proposing, e.g. "OP_RETURN POP_LITERAL <nonce> <txid>"?
>

I was thinking that txid should be mandatory just as the nonce so the order
was arbitrarily chosen. I think you may be right that it's more intuitive
to put txid last if it's not mandatory in a future version. It makes sense
to swap order. I'll put that on my todo list.

> 2. Building on #1, perhaps there could be other identifying information
than a txid? Perhaps a txid field shouldn't be "hardcoded" into the
standard at all?
>
> How about taking the same approach as BIP-43 (and others) and use a
prefix that determines how the rest of the records should be interpreted,
i.e. a "type" (or "purpose" or "version" or whatever you'd like to call it)
field. This would allow for different purposes/versions of a PoP, including
as of now unforeseen ones.
>
> The new structure would then be:
> OP_RETURN POP_PREFIX POP_TYPE POP_NONCE POP_PAYLOAD
>
> POP_PREFIX (? bytes): I'll leave it up to you to specify the exact bits
(and length) of the POP_PREFIX, but if your literal is used, it'd be 3
bytes: 0x506f50.
>
> Literals in Bitcoin protocols generally seem to be of the "binary" sort
as opposed to human-readable text, so perhaps the devs wouldn't ACK
something as "wasteful" as using 3 bytes just to identify it as a PoP
record? Obviously, this is a small detail that can be changed at short
notice, but as with all standards - once people start using it, you're
mostly stuck with what you have. ;)
>

Yes, maybe we could drop POP_PREFIX altogether. The server is expecting a
pop and can therefore just assume it's a pop. No need to explicitly write
that inside the pop. Can you think of a scenario where it is actually
needed. Keeping the POP_PREFIX makes sense only if other transaction-like
data structures with OP_RETURN appears in the same contexts as pops. What
do you think?

> POP_TYPE: (1 byte): 0x01 for your "standard" version, which would mean
that the payload contains a txid.
>

This is a good idea. Todo!

> POP_NONCE: (4 bytes): "2^32 re-uses should be enough for everyone", no? ;)
>

Euhm, well, I don't know... The bigger the better. If we drop POP_PREFIX we
could allow for 2 bytes version and 6 bytes nonce. Or 1 byte version and 7
bytes nonce.

> POP_PAYLOAD (32+ bytes): The contents of which is determined by POP_TYPE,
e.g. a txid or possibly extra nonce data. Or perhaps some text that makes
the purpose or context of this PoP human-readable? (This could then be
stored by wallets in order to show a list of what kind of proofs you've
sent.)
>

For now I think I'll stick to "txid is mandatory".

>
> 3. I noticed that your post-OP_RETURN structure included exactly 40
bytes. Is that due to the 40-byte limitation on OP_RETURN's "data"? Are you
aware that it will be increased to 80 bytes? Cf. https://
<https://github.com/bitcoin/bitcoin/pull/5286>github.com
<https://github.com/bitcoin/bitcoin/pull/5286>/
<https://github.com/bitcoin/bitcoin/pull/5286>bitcoin
<https://github.com/bitcoin/bitcoin/pull/5286>/
<https://github.com/bitcoin/bitcoin/pull/5286>bitcoin
<https://github.com/bitcoin/bitcoin/pull/5286>/pull/5286
<https://github.com/bitcoin/bitcoin/pull/5286>
>

Yes, I deliberately limited the data to 40 bytes for that reason. With
versioning, this may change in the future.

> :)
>
>
> Vennlig hilsen
> Martin Lie
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150423/22c25248/attachment.html>

From jtimon at jtimon.cc  Fri Apr 24 08:58:11 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Fri, 24 Apr 2015 10:58:11 +0200
Subject: [Bitcoin-development] 75%/95% threshold for transaction versions
In-Reply-To: <CABm2gDoBci9qjGt-FpgzuYvpDrG8iqfzBTnUqFTyYWP5SpLxLA@mail.gmail.com>
References: <552EF785.7000207@sky-ip.org>
	<CAPg+sBgAhdgPPjmT5i0PMYhQo=Hk6Weo8tpX_Wyn-NJ5Ye9D_A@mail.gmail.com>
	<552FDF73.6010104@sky-ip.org>
	<CAOG=w-vMjysbF5H8wWN2y45U3djFwpKMtXq3vCvB=-eFr7GqFg@mail.gmail.com>
	<55304321.3030300@sky-ip.org>
	<CAPg+sBi3QgJK7-PuV-1vbur0AMUeXddUdv_-Mcjwgbefqj3rFg@mail.gmail.com>
	<55326F11.1010605@sky-ip.org>
	<CABm2gDoBci9qjGt-FpgzuYvpDrG8iqfzBTnUqFTyYWP5SpLxLA@mail.gmail.com>
Message-ID: <CABm2gDr9t5G6DsyT8ZT_4UbqjhBXkA5cJRZhtZTv+Djz7mpSMg@mail.gmail.com>

Oh, no, sorry, it also covers bip62.

On Fri, Apr 24, 2015 at 10:55 AM, Jorge Tim?n <jtimon at jtimon.cc> wrote:
> s7r you may be interested in this video explaining several aspects of
> malleability: https://www.youtube.com/watch?v=jyDE-aFqJTs
> It is pre BIP62, but I believe it is very relevant and will hopefully
> clear some of your doubts.
> The signer of TX1 will always be able to change the signature and thus
> the tx ID.
>
> On Sat, Apr 18, 2015 at 4:49 PM, s7r <s7r at sky-ip.org> wrote:
>> Understood. That is unfortunate, but not the end of the world. If you
>> could please give feedback also to these last comments / questions:
>>
>> How far are we at this moment from BIP62? Can an user send a
>> non-malleable tx now, if enforces some additional rules?
>>
>> As for the security of the system, it does not fully rely on txids being
>> non malleable, but see this quote from my previous email:
>>
>> [QUOTE]
>> I am trying to build a bitcoin contract which will relay on 3 things:
>> - coinjoin / txes with inputs from multiple users which are signed by
>> all users after they are merged together (every user is sure his coins
>> will not be spent without the other users to spend anything, as per
>> agreed contract);
>> - pre-signed txes with nLockTime 'n' weeks. These txes will be signed
>> before the inputs being spent are broadcasted/confirmed, using the txid
>> provided by the user before broadcasting it. Malleability hurts here.
>> - P2SH
>>
>> Another thing I would like to confirm, the 3 pieces of the bitcoin
>> protocol mentioned above will be supported in _any_ future transaction
>> version or block version, regardless what changes are made or features
>> added to bitcoin core? The contract needs to be built and left unchanged
>> for a very very long period of time...
>> [/END QUOTE]
>>
>> Can you comment on the quote please?
>>
>> So, basically transaction malleability could affect the system in the
>> way that a pre-signed tx which offers the insurance and which is sent to
>> the user before the user sends the coins (spending user's coins back to
>> him after a certain period of time) could be invalidated. The insurance
>> tx signature will still be good, but invalid overall since the input
>> (txid) being spent does not exist (was altered / modified). The coins
>> won't be stolen or lost, but a new tx needs to be signed with the
>> altered (new) txid, for the system to work.
>>
>> So, an user creates a transaction TX1 sending the coins to the server
>> but does not broadcast it. Instead, he provides the txid of TX1 to the
>> server. Server generates another transaction TX2 which spends TX1 back
>> to the user, with an nLockTime. User checks and if everything ok
>> broadcasts TX1. In case the txid of TX1 will be altered/modified, TX2
>> will become invalid (since it will be spending an inexistent input), and
>> the server will need to re-create and sign TX2 with the new
>> (altered/modified) txid of TX1, as per agreed contract. Should the
>> server disappear after user broadcasts TX1 and before the
>> altered/modified txid of TX1 gets confirmed, user's coins are forever
>> locked. It is true that no third party can benefit from this type of
>> attack, only the user will result with coins locked, but it is something
>> which could be used by competition to make a service useless / annoying
>> / too complicated or less safe to use.
>>
>> How could I mitigate this?
>>
>> Thanks you for your time and help.
>>
>> On 4/17/2015 12:02 PM, Pieter Wuille wrote:
>>>> Anyone can alter the txid - more details needed. The number of altered
>>>> txids in practice is not so high in order to make us believe anyone can
>>>> do it easily. It is obvious that all current bitcoin transactions are
>>>> malleable, but not by anyone and not that easy. At least I like to
>>> think so.
>>>
>>> Don't assume that because it does not (frequently) happen, that it
>>> cannot happen. Large amounts of malleated transactions have happened in
>>> the past. Especially if you build a system depends on non-malleability
>>> for its security, you may at some point have an attacker who has
>>> financial gain from malleation.
>>>
>>>> >From your answer I understand that right now if I create a transaction
>>>> (tx1) and broadcast it, you can alter its txid at your will, without any
>>>> mining power and/or access to my private keys so I would end up not
>>>> recognizing my own transaction and probably my change too (if my systems
>>>> rely hardly on txid)?
>>>
>>> In theory, yes, anyone can alter the txid without invalidating it,
>>> without mining power and without access to the sender's private keys.
>>>
>>> All it requires is seeing a transaction on the network, doing a trivial
>>> modification to it, and rebroadcasting it quickly. If the modifies
>>> version gets mined, you're out of luck. Having mining power helps of course.
>>>
>>> After BIP62, you will, as a sender, optionally be able to protect others
>>> from malleating. You're always able to re-sign yourself.
>>>
>>> --
>>> Pieter
>>>
>>
>> ------------------------------------------------------------------------------
>> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT
>> Develop your own process in accordance with the BPMN 2 standard
>> Learn Process modeling best practices with Bonita BPM through live exercises
>> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual- event?utm_
>> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development



From jtimon at jtimon.cc  Fri Apr 24 08:55:57 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Fri, 24 Apr 2015 10:55:57 +0200
Subject: [Bitcoin-development] 75%/95% threshold for transaction versions
In-Reply-To: <55326F11.1010605@sky-ip.org>
References: <552EF785.7000207@sky-ip.org>
	<CAPg+sBgAhdgPPjmT5i0PMYhQo=Hk6Weo8tpX_Wyn-NJ5Ye9D_A@mail.gmail.com>
	<552FDF73.6010104@sky-ip.org>
	<CAOG=w-vMjysbF5H8wWN2y45U3djFwpKMtXq3vCvB=-eFr7GqFg@mail.gmail.com>
	<55304321.3030300@sky-ip.org>
	<CAPg+sBi3QgJK7-PuV-1vbur0AMUeXddUdv_-Mcjwgbefqj3rFg@mail.gmail.com>
	<55326F11.1010605@sky-ip.org>
Message-ID: <CABm2gDoBci9qjGt-FpgzuYvpDrG8iqfzBTnUqFTyYWP5SpLxLA@mail.gmail.com>

s7r you may be interested in this video explaining several aspects of
malleability: https://www.youtube.com/watch?v=jyDE-aFqJTs
It is pre BIP62, but I believe it is very relevant and will hopefully
clear some of your doubts.
The signer of TX1 will always be able to change the signature and thus
the tx ID.

On Sat, Apr 18, 2015 at 4:49 PM, s7r <s7r at sky-ip.org> wrote:
> Understood. That is unfortunate, but not the end of the world. If you
> could please give feedback also to these last comments / questions:
>
> How far are we at this moment from BIP62? Can an user send a
> non-malleable tx now, if enforces some additional rules?
>
> As for the security of the system, it does not fully rely on txids being
> non malleable, but see this quote from my previous email:
>
> [QUOTE]
> I am trying to build a bitcoin contract which will relay on 3 things:
> - coinjoin / txes with inputs from multiple users which are signed by
> all users after they are merged together (every user is sure his coins
> will not be spent without the other users to spend anything, as per
> agreed contract);
> - pre-signed txes with nLockTime 'n' weeks. These txes will be signed
> before the inputs being spent are broadcasted/confirmed, using the txid
> provided by the user before broadcasting it. Malleability hurts here.
> - P2SH
>
> Another thing I would like to confirm, the 3 pieces of the bitcoin
> protocol mentioned above will be supported in _any_ future transaction
> version or block version, regardless what changes are made or features
> added to bitcoin core? The contract needs to be built and left unchanged
> for a very very long period of time...
> [/END QUOTE]
>
> Can you comment on the quote please?
>
> So, basically transaction malleability could affect the system in the
> way that a pre-signed tx which offers the insurance and which is sent to
> the user before the user sends the coins (spending user's coins back to
> him after a certain period of time) could be invalidated. The insurance
> tx signature will still be good, but invalid overall since the input
> (txid) being spent does not exist (was altered / modified). The coins
> won't be stolen or lost, but a new tx needs to be signed with the
> altered (new) txid, for the system to work.
>
> So, an user creates a transaction TX1 sending the coins to the server
> but does not broadcast it. Instead, he provides the txid of TX1 to the
> server. Server generates another transaction TX2 which spends TX1 back
> to the user, with an nLockTime. User checks and if everything ok
> broadcasts TX1. In case the txid of TX1 will be altered/modified, TX2
> will become invalid (since it will be spending an inexistent input), and
> the server will need to re-create and sign TX2 with the new
> (altered/modified) txid of TX1, as per agreed contract. Should the
> server disappear after user broadcasts TX1 and before the
> altered/modified txid of TX1 gets confirmed, user's coins are forever
> locked. It is true that no third party can benefit from this type of
> attack, only the user will result with coins locked, but it is something
> which could be used by competition to make a service useless / annoying
> / too complicated or less safe to use.
>
> How could I mitigate this?
>
> Thanks you for your time and help.
>
> On 4/17/2015 12:02 PM, Pieter Wuille wrote:
>>> Anyone can alter the txid - more details needed. The number of altered
>>> txids in practice is not so high in order to make us believe anyone can
>>> do it easily. It is obvious that all current bitcoin transactions are
>>> malleable, but not by anyone and not that easy. At least I like to
>> think so.
>>
>> Don't assume that because it does not (frequently) happen, that it
>> cannot happen. Large amounts of malleated transactions have happened in
>> the past. Especially if you build a system depends on non-malleability
>> for its security, you may at some point have an attacker who has
>> financial gain from malleation.
>>
>>> >From your answer I understand that right now if I create a transaction
>>> (tx1) and broadcast it, you can alter its txid at your will, without any
>>> mining power and/or access to my private keys so I would end up not
>>> recognizing my own transaction and probably my change too (if my systems
>>> rely hardly on txid)?
>>
>> In theory, yes, anyone can alter the txid without invalidating it,
>> without mining power and without access to the sender's private keys.
>>
>> All it requires is seeing a transaction on the network, doing a trivial
>> modification to it, and rebroadcasting it quickly. If the modifies
>> version gets mined, you're out of luck. Having mining power helps of course.
>>
>> After BIP62, you will, as a sender, optionally be able to protect others
>> from malleating. You're always able to re-sign yourself.
>>
>> --
>> Pieter
>>
>
> ------------------------------------------------------------------------------
> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT
> Develop your own process in accordance with the BPMN 2 standard
> Learn Process modeling best practices with Bonita BPM through live exercises
> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual- event?utm_
> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development



From swansontec at gmail.com  Fri Apr 24 19:58:45 2015
From: swansontec at gmail.com (William Swanson)
Date: Fri, 24 Apr 2015 12:58:45 -0700
Subject: [Bitcoin-development] 75%/95% threshold for transaction versions
In-Reply-To: <552FDF73.6010104@sky-ip.org>
References: <552EF785.7000207@sky-ip.org>
	<CAPg+sBgAhdgPPjmT5i0PMYhQo=Hk6Weo8tpX_Wyn-NJ5Ye9D_A@mail.gmail.com>
	<552FDF73.6010104@sky-ip.org>
Message-ID: <CABjHNoTeMiLWkDBUqdV4HJ=nAhj8wqOjD4cypY9Dv2y9HJWJMg@mail.gmail.com>

On Thu, Apr 16, 2015 at 9:12 AM, s7r <s7r at sky-ip.org> wrote:
> Thanks for your reply. I agree. Allen has a good point in the previous
> email too, so the suggestion might not fix anything and complicate things.

The BIP 62 approach to malleability isn't the only option. Another
approach is to sign the transaction in such a way that the input
txid's are allowed to change without invalidating the signatures. That
way, if malleability happens, you just adjust you transaction to match
and re-broadcast. That proposal is here:

https://github.com/scmorse/bitcoin-misc/blob/master/sighash_proposal.md

The "Build your own nHashType" thread on this mailing list contains
the discussion.

I personally prefer this solution, since it nails the problem
completely with one simple and obvious change. The BIP 62 approach is
more like a game of wac-a-mole.

-William



From gmaxwell at gmail.com  Fri Apr 24 20:16:57 2015
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Fri, 24 Apr 2015 20:16:57 +0000
Subject: [Bitcoin-development] 75%/95% threshold for transaction versions
In-Reply-To: <CABjHNoTeMiLWkDBUqdV4HJ=nAhj8wqOjD4cypY9Dv2y9HJWJMg@mail.gmail.com>
References: <552EF785.7000207@sky-ip.org>
	<CAPg+sBgAhdgPPjmT5i0PMYhQo=Hk6Weo8tpX_Wyn-NJ5Ye9D_A@mail.gmail.com>
	<552FDF73.6010104@sky-ip.org>
	<CABjHNoTeMiLWkDBUqdV4HJ=nAhj8wqOjD4cypY9Dv2y9HJWJMg@mail.gmail.com>
Message-ID: <CAAS2fgSay0DqeWXfZwX-sN71sLHdRLD51PBmnJfJ5+TC0BQ8zg@mail.gmail.com>

On Fri, Apr 24, 2015 at 7:58 PM, William Swanson <swansontec at gmail.com> wrote:
> On Thu, Apr 16, 2015 at 9:12 AM, s7r <s7r at sky-ip.org> wrote:
>> Thanks for your reply. I agree. Allen has a good point in the previous
>> email too, so the suggestion might not fix anything and complicate things.
>
> The BIP 62 approach to malleability isn't the only option. Another
> approach is to sign the transaction in such a way that the input
> txid's are allowed to change without invalidating the signatures. That
> way, if malleability happens, you just adjust you transaction to match
> and re-broadcast. That proposal is here:

This is not a free choice. There are several concerns, from mild to
severe, that arise when you do not sign enough.

In particular not covering the ID allows for transaction replay which
can result in monetary losses far more severe than any possible
mishandling of malleability could result in. Byzantine attackers can
costlessly replay your old transactions any time anyone reuses an
address, even accidentally (which cannot be easily prevented since
they can race).

Other fun effects also show up like being able to backwards compute
signatures to result in a kind of limited covenant- coins which can
only be spent a particular way which has some implications for
fungibility. (See here for a discussion in general of covenants:
https://bitcointalk.org/index.php?topic=278122.0)

There are no free lunches;  the proposal linked to there is itself a
game of wack-a-mole with assorted masking flags; many of which we have
no notion of if they're useful for any particular application(s); and
it doesn't provide tools to address the replay issue; and in order to
'improve' malleability via that mechanism you must always mask out the
inputs completely; meaning you'd always be exposed to replay and not
just in specialized 'contract' applications where "there won't be
address reuse" could be a strong assumption enforced by the
application.



From justus.ranvier at monetas.net  Fri Apr 24 20:00:46 2015
From: justus.ranvier at monetas.net (Justus Ranvier)
Date: Fri, 24 Apr 2015 22:00:46 +0200
Subject: [Bitcoin-development] Reusable payment codes
Message-ID: <CAHabJ+Mn0=vfLvTJ+z3tx8cFAAuLD1pLp4rOe3pM6MtCrCxjwg@mail.gmail.com>

-----BEGIN PGP SIGNED MESSAGE-----

Hash: SHA1


https://github.com/justusranvier/rfc/blob/payment_code/bips/bip-pc01.mediawiki


This link contains an RFC for a new type of Bitcoin address called a
"payment code"


Payment codes are SPV-friendly alternatives to DarkWallet-style stealth
addresses which provide useful features such as positively identifying
senders to recipients and automatically providing for transaction refunds.


Payment codes can be publicly advertised and associated with a real-life
identity without causing a loss of financial privacy.


Compared to stealth addresses, payment codes require less blockchain data
storage.


Payment codes require 65 bytes of OP_RETURN data per sender-recipient pair,
while stealth addresses require 40 bytes per transaction.


-----BEGIN PGP SIGNATURE-----

Version: GnuPG v1


iQIcBAEBAgAGBQJVOqCRAAoJECpf2nDq2eYjluEP/RVJk+miDIihY4ilIvUbKvMd

JLLqHr7Q1dlZyMIG/UqVWdoP5hzg/16B+q2iAB9jXozPnrDp0mggBh6rIGroevAa

Kqfrs+Rrog1w9auhd67LWORDqav6YIrjTJIxdLxe11IEiq5rWbHPNUEDMzdEmHbz

QfTH7KWAP2BasO5ETXcfu6BcccrXZ3XOKLON2h3NGD/cEDizY+uT2k3QN54z+KxG

NB9scKbzVvsJwkyBrgbV+As9H3k6PnFsojYgAaE9gkp7D2+ahjzUiOH5rv6TbbYR

o2X5MOiTY2/YZEqZPG7IR03ZAgeLVCvXXysjPOfzUKbmTF4w849sm8BuhixzDXHo

2V/HHKoGclIohcODBCWi0tVQXshZt4QkCNJBW5o3nL6Nn2YOp6hmw8YKAHnw3E7h

/wIgk5f+NOLl/iIxoAxAdavEj5P6N4ic+OB6MAjnhEilWfBvCIpqWLGNvrtOhEa9

EnPHcgb4ILBu4OionJhsNpJ/O95C0OEypMm25MIS+rQcV4Uxe5IOS2OuT/GreLET

n/7Y0mJbqYbLBjVsfS+DNjvsgyJl5AxhcMrdVyXJjSYVcCoRhcoX5Ceidd+YkbHI

OMs5f63tM1Rgi/WY4Ct80SD5EbULZuu8j1KJ9HPGuMt081JSBH+L5isiKuazPeO+

SGApMBd4Q89fKzL2djae

=Dypr

-----END PGP SIGNATURE-----
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150424/4954b46c/attachment.html>

From gmaxwell at gmail.com  Fri Apr 24 20:58:39 2015
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Fri, 24 Apr 2015 20:58:39 +0000
Subject: [Bitcoin-development] Reusable payment codes
In-Reply-To: <CAHabJ+Mn0=vfLvTJ+z3tx8cFAAuLD1pLp4rOe3pM6MtCrCxjwg@mail.gmail.com>
References: <CAHabJ+Mn0=vfLvTJ+z3tx8cFAAuLD1pLp4rOe3pM6MtCrCxjwg@mail.gmail.com>
Message-ID: <CAAS2fgRVcwNfYv8fnoS_uRtDoGqRiWAXcPgaK8if8FO_G6LQoQ@mail.gmail.com>

On Fri, Apr 24, 2015 at 8:00 PM, Justus Ranvier
<justus.ranvier at monetas.net> wrote:
> https://github.com/justusranvier/rfc/blob/payment_code/bips/bip-pc01.mediawiki
>
> This link contains an RFC for a new type of Bitcoin address called a
> "payment code"
>
> Payment codes are SPV-friendly alternatives to DarkWallet-style stealth
> addresses which provide useful features such as positively identifying
> senders to recipients and automatically providing for transaction refunds.

So this requires making dust payments to a constantly reused address
in order to (ab)use the blockchain as a messaging layer.

Indeed, this is more SPV compatible; but it seems likely to me that
_in practice_ it would almost completely undermine the privacy the
idea hoped to provide; because you'd have an observable linkage to a
highly reused address.

It would also more than double the data sent for the application where
'stealth addresses' are most important: one-time anonymous donations
(in other contexts; you have two way communication between the
participants, and so you can just given them a one off address without
singling in the public network.)

> Alice selects the first exposed public key of the first input of the transaction

So this creates strong "binding" that we would really strongly like to
avoid in the network; basically what this says is that "You can only
pay to person X if you use scheme Y for your own Bitcoins"-- who says
any of your inputs have a ECDH pubkey at all? Of if they do, who says
its one that you have access to the private key for for use in this
scheme (e.g. it could be in a HSM that only signs according to a
policy).   We should avoid creating txout features that restrict what
kind of scriptPubkey the sender can use, or otherwise we'll never be
able to deploy new signature features. (We can see how long P2SH took
to gain adoption because some wallets refused to implement sending to
it, even though doing so was trivial).

This kind of binding was intentionally designed out of the stealth
address proposal;  I think this scheme can be made to work without any
increase in size by reusing the payment code as the ephemeral public
key (or actually being substantially smaller e.g. use the shared
secret as the chain code, but I should give it more thought)

Also, SPV wallets do not need to have access to the public keys being
spent by a particular transaction they learn about; providing that
access is fundamentally expensive and pushes things back towards
centralization.

> in uncompressed DER format

This is fundamentally more expensive to compute; please don't specify
"uncompressed".

This appears incompatible with multisignature; which is unfortunate.

I do very much like the fact that this scheme establishes a shared
chain once and then doesn't need to reestablish; this was one of the
improvements I wanted for the stealth address.

I'm disappointed that there isn't any thought given to solving the
scanning privacy without forcing non-private pure-overhead messaging
transactions on heavily reused addresses. Are you aware of the IBE
approach that allows someone to request a third party scan for them
with block by block control over their delegation of scanning?



From justus.ranvier at monetas.net  Sat Apr 25 00:20:59 2015
From: justus.ranvier at monetas.net (Justus Ranvier)
Date: Sat, 25 Apr 2015 02:20:59 +0200
Subject: [Bitcoin-development] Fwd:  Reusable payment codes
In-Reply-To: <CAHabJ+MtWJS=e3tkGih=xoP4ARgHe8X=D_p9OWTnRJi0z9epBw@mail.gmail.com>
References: <CAHabJ+Mn0=vfLvTJ+z3tx8cFAAuLD1pLp4rOe3pM6MtCrCxjwg@mail.gmail.com>
	<CAAS2fgRVcwNfYv8fnoS_uRtDoGqRiWAXcPgaK8if8FO_G6LQoQ@mail.gmail.com>
	<CAHabJ+MtWJS=e3tkGih=xoP4ARgHe8X=D_p9OWTnRJi0z9epBw@mail.gmail.com>
Message-ID: <CAHabJ+PWRUYEO8mY68kH_wy5iozx0JQG1N_aQhUWcvnMR36A+A@mail.gmail.com>

On Fri, Apr 24, 2015 at 10:58 PM, Gregory Maxwell <gmaxwell at gmail.com>
wrote:

> So this requires making dust payments to a constantly reused address
> in order to (ab)use the blockchain as a messaging layer.
>
> Indeed, this is more SPV compatible; but it seems likely to me that
> _in practice_ it would almost completely undermine the privacy the
> idea hoped to provide; because you'd have an observable linkage to a
> highly reused address.
>

I agree that the output associated with notification transactions would
require special handling to avoid privacy leaks. At a minimum they'd
require mixing or being donated to miners as a transaction fee.


>
> It would also more than double the data sent for the application where
> 'stealth addresses' are most important: one-time anonymous donations
> (in other contexts; you have two way communication between the
> participants, and so you can just given them a one off address without
> singling in the public network.)
>

Communication is only one way, except for the case in which the recipient
wants to send a refund. Assuming no refund and only a single anonymous
donation in the lifetime of the sender's identity, payment codes would
require 65 bytes vs 40 bytes for stealth addresses.

As soon as the sender sends more than one donation to the same recipient,
payment codes show an space advantage over stealth addresses.

This kind of binding was intentionally designed out of the stealth
>
address proposal;  I think this scheme can be made to work without any
> increase in size by reusing the payment code as the ephemeral public
> key (or actually being substantially smaller e.g. use the shared
> secret as the chain code, but I should give it more thought)
>

With 97 byte standard OP_RETURN values the ephemeral public
key could be appended to the chain code, but that's undesirable for other
reasons.

This is fundamentally more expensive to compute; please don't specify
> "uncompressed".
>

Taking the SHA512 of something less than 512 bits seemed wrong.


> This appears incompatible with multisignature; which is unfortunate.
>

I agree. I could not find a straightforward way to express a multisignature
payment code in less than 80 bytes.


> I'm disappointed that there isn't any thought given to solving the
> scanning privacy without forcing non-private pure-overhead messaging
> transactions on heavily reused addresses. Are you aware of the IBE
> approach that allows someone to request a third party scan for them
> with block by block control over their delegation of scanning?
>

I suspect this is a case where we just can't have all the features we want.

In this proposal I optimized for non-reliance on third party services and a
guaranteed ability to recover spendable funds from a seed backup.

Gaining those two features resulted in some tradeoffs as you noted, but I
think there are enough benefits to make them worthwhile.

In particular, payment codes could be the basis for a Heartbleed-free
payment protocol that can positively identify customers and automatically
provide refund capabilities in a merchant-customer relationship. A merchant
only requires one payment code which they can safely use for all their
customers, meaning they only ever need to associate 65 bytes with their
identity to allow customers to make sure they are paying the right entity.

Exchanges could restrict bitcoin withdrawals to a single payment code known
to be associated with their identified customer. This would make thefts
easier (without involving address reuse as in locking withdrawals to a
single P2PKH address).

In some jurisdictions the ability to prove that withdrawals are sent to a
positively-identified party, rather than arbitrary third parties, might
move some Bitcoin businesses out of money transmitter territory into less
onerous regulatory situations.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150425/c29abbbd/attachment.html>

From justus.ranvier at monetas.net  Sat Apr 25 00:21:20 2015
From: justus.ranvier at monetas.net (Justus Ranvier)
Date: Sat, 25 Apr 2015 02:21:20 +0200
Subject: [Bitcoin-development] Fwd:  Reusable payment codes
In-Reply-To: <CAHabJ+Oabx80+_1KutfrPUt5QEnMivfNeeh4uJJJOsiHRQqSZw@mail.gmail.com>
References: <CAHabJ+Mn0=vfLvTJ+z3tx8cFAAuLD1pLp4rOe3pM6MtCrCxjwg@mail.gmail.com>
	<CAAS2fgRVcwNfYv8fnoS_uRtDoGqRiWAXcPgaK8if8FO_G6LQoQ@mail.gmail.com>
	<CAHabJ+MtWJS=e3tkGih=xoP4ARgHe8X=D_p9OWTnRJi0z9epBw@mail.gmail.com>
	<CAHabJ+Oabx80+_1KutfrPUt5QEnMivfNeeh4uJJJOsiHRQqSZw@mail.gmail.com>
Message-ID: <CAHabJ+N1acagTJ_-P=BJ_5unHU6ywNZK+wNzZJzTmyFdZ4AMrQ@mail.gmail.com>

I have pushed an updated version of the proposal which incorporates some of
the received feedback and adds a note about the consequences of sharing a
payment code-enabled walled on multiple devices:

https://github.com/justusranvier/rfc/blob/payment_code/bips/bip-pc01.mediawiki

https://github.com/justusranvier/rfc/commit/8c4d3429012eb15847c4ae68f212c8b2dcd1b521

On Sat, Apr 25, 2015 at 12:21 AM, Justus Ranvier <justus.ranvier at monetas.net
> wrote:

>
>
> On Fri, Apr 24, 2015 at 10:58 PM, Gregory Maxwell <gmaxwell at gmail.com>
> wrote:
>
>> So this requires making dust payments to a constantly reused address
>> in order to (ab)use the blockchain as a messaging layer.
>>
>> Indeed, this is more SPV compatible; but it seems likely to me that
>> _in practice_ it would almost completely undermine the privacy the
>> idea hoped to provide; because you'd have an observable linkage to a
>> highly reused address.
>>
>
> I agree that the output associated with notification transactions would
> require special handling to avoid privacy leaks. At a minimum they'd
> require mixing or being donated to miners as a transaction fee.
>
>
>>
>> It would also more than double the data sent for the application where
>> 'stealth addresses' are most important: one-time anonymous donations
>> (in other contexts; you have two way communication between the
>> participants, and so you can just given them a one off address without
>> singling in the public network.)
>>
>
> Communication is only one way, except for the case in which the recipient
> wants to send a refund. Assuming no refund and only a single anonymous
> donation in the lifetime of the sender's identity, payment codes would
> require 65 bytes vs 40 bytes for stealth addresses.
>
> As soon as the sender sends more than one donation to the same recipient,
> payment codes show an space advantage over stealth addresses.
>
> This kind of binding was intentionally designed out of the stealth
>>
> address proposal;  I think this scheme can be made to work without any
>> increase in size by reusing the payment code as the ephemeral public
>> key (or actually being substantially smaller e.g. use the shared
>> secret as the chain code, but I should give it more thought)
>>
>
> With 97 byte standard OP_RETURN values the ephemeral public
> key could be appended to the chain code, but that's undesirable for other
> reasons.
>
> This is fundamentally more expensive to compute; please don't specify
>> "uncompressed".
>>
>
> Taking the SHA512 of something less than 512 bits seemed wrong.
>
>
>> This appears incompatible with multisignature; which is unfortunate.
>>
>
> I agree. I could not find a straightforward way to express a
> multisignature payment code in less than 80 bytes.
>
>
>> I'm disappointed that there isn't any thought given to solving the
>> scanning privacy without forcing non-private pure-overhead messaging
>> transactions on heavily reused addresses. Are you aware of the IBE
>> approach that allows someone to request a third party scan for them
>> with block by block control over their delegation of scanning?
>>
>
> I suspect this is a case where we just can't have all the features we want.
>
> In this proposal I optimized for non-reliance on third party services and
> a guaranteed ability to recover spendable funds from a seed backup.
>
> Gaining those two features resulted in some tradeoffs as you noted, but I
> think there are enough benefits to make them worthwhile.
>
> In particular, payment codes could be the basis for a Heartbleed-free
> payment protocol that can positively identify customers and automatically
> provide refund capabilities in a merchant-customer relationship. A merchant
> only requires one payment code which they can safely use for all their
> customers, meaning they only ever need to associate 65 bytes with their
> identity to allow customers to make sure they are paying the right entity.
>
> Exchanges could restrict bitcoin withdrawals to a single payment code
> known to be associated with their identified customer. This would make
> thefts easier (without involving address reuse as in locking withdrawals to
> a single P2PKH address).
>
> In some jurisdictions the ability to prove that withdrawals are sent to a
> positively-identified party, rather than arbitrary third parties, might
> move some Bitcoin businesses out of money transmitter territory into less
> onerous regulatory situations.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150425/1536c9c0/attachment.html>

From justus.ranvier at monetas.net  Sat Apr 25 00:22:30 2015
From: justus.ranvier at monetas.net (Justus Ranvier)
Date: Sat, 25 Apr 2015 02:22:30 +0200
Subject: [Bitcoin-development] Fwd:  Reusable payment codes
In-Reply-To: <CAHabJ+NDqMN-rQ1BN1TfOjGLQHH-3Wd28LdoF95Agn4HdRrThg@mail.gmail.com>
References: <CAHabJ+Mn0=vfLvTJ+z3tx8cFAAuLD1pLp4rOe3pM6MtCrCxjwg@mail.gmail.com>
	<1AE7B0A2-90EE-42EE-9D30-4DC1B5892E53@newcastle.ac.uk>
	<CAHabJ+NDqMN-rQ1BN1TfOjGLQHH-3Wd28LdoF95Agn4HdRrThg@mail.gmail.com>
Message-ID: <CAHabJ+PMdQ-f7G8RNz0R7mfGUwBMAsnCyO=NmQhxyq0+gB1aPg@mail.gmail.com>

Taking the hash of the secret would then require an extra step to make sure
the hash is valid for secp256k1.

Using the x value directly avoids the need for that check.

On Fri, Apr 24, 2015 at 10:35 PM, Patrick Mccorry (PGR) <
patrick.mccorry at newcastle.ac.uk> wrote:

>  When computing the diffie Hellman secret - why do you choose the x
> co-ordinate instead of the hash of the secret which is standard practice
> for stealth addresses
>
> Sent from my iPhone
>
> On 24 Apr 2015, at 21:27, Justus Ranvier <justus.ranvier at monetas.net>
> wrote:
>
>   -----BEGIN PGP SIGNED MESSAGE-----
>
> Hash: SHA1
>
>
>
> https://github.com/justusranvier/rfc/blob/payment_code/bips/bip-pc01.mediawiki
>
>
>  This link contains an RFC for a new type of Bitcoin address called a
> "payment code"
>
>
>  Payment codes are SPV-friendly alternatives to DarkWallet-style stealth
> addresses which provide useful features such as positively identifying
> senders to recipients and automatically providing for transaction refunds.
>
>
>  Payment codes can be publicly advertised and associated with a real-life
> identity without causing a loss of financial privacy.
>
>
>  Compared to stealth addresses, payment codes require less blockchain
> data storage.
>
>
>  Payment codes require 65 bytes of OP_RETURN data per sender-recipient
> pair, while stealth addresses require 40 bytes per transaction.
>
>
>  -----BEGIN PGP SIGNATURE-----
>
> Version: GnuPG v1
>
>
>  iQIcBAEBAgAGBQJVOqCRAAoJECpf2nDq2eYjluEP/RVJk+miDIihY4ilIvUbKvMd
>
> JLLqHr7Q1dlZyMIG/UqVWdoP5hzg/16B+q2iAB9jXozPnrDp0mggBh6rIGroevAa
>
> Kqfrs+Rrog1w9auhd67LWORDqav6YIrjTJIxdLxe11IEiq5rWbHPNUEDMzdEmHbz
>
> QfTH7KWAP2BasO5ETXcfu6BcccrXZ3XOKLON2h3NGD/cEDizY+uT2k3QN54z+KxG
>
> NB9scKbzVvsJwkyBrgbV+As9H3k6PnFsojYgAaE9gkp7D2+ahjzUiOH5rv6TbbYR
>
> o2X5MOiTY2/YZEqZPG7IR03ZAgeLVCvXXysjPOfzUKbmTF4w849sm8BuhixzDXHo
>
> 2V/HHKoGclIohcODBCWi0tVQXshZt4QkCNJBW5o3nL6Nn2YOp6hmw8YKAHnw3E7h
>
> /wIgk5f+NOLl/iIxoAxAdavEj5P6N4ic+OB6MAjnhEilWfBvCIpqWLGNvrtOhEa9
>
> EnPHcgb4ILBu4OionJhsNpJ/O95C0OEypMm25MIS+rQcV4Uxe5IOS2OuT/GreLET
>
> n/7Y0mJbqYbLBjVsfS+DNjvsgyJl5AxhcMrdVyXJjSYVcCoRhcoX5Ceidd+YkbHI
>
> OMs5f63tM1Rgi/WY4Ct80SD5EbULZuu8j1KJ9HPGuMt081JSBH+L5isiKuazPeO+
>
> SGApMBd4Q89fKzL2djae
>
> =Dypr
>
> -----END PGP SIGNATURE-----
>
>
> ------------------------------------------------------------------------------
> One dashboard for servers and applications across Physical-Virtual-Cloud
> Widest out-of-the-box monitoring support with 50+ applications
> Performance metrics, stats and reports that give you Actionable Insights
> Deep dive visibility with transaction tracing using APM Insight.
> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y
>
>  _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150425/40b3ed26/attachment.html>

From justus.ranvier at monetas.net  Sat Apr 25 02:34:13 2015
From: justus.ranvier at monetas.net (Justus Ranvier)
Date: Sat, 25 Apr 2015 04:34:13 +0200
Subject: [Bitcoin-development] Fwd: Reusable payment codes
In-Reply-To: <CAAS2fgSAT2otym64oUACpWD8jWLAB6dBusONn-WUx2DK59SB5w@mail.gmail.com>
References: <CAHabJ+Mn0=vfLvTJ+z3tx8cFAAuLD1pLp4rOe3pM6MtCrCxjwg@mail.gmail.com>
	<1AE7B0A2-90EE-42EE-9D30-4DC1B5892E53@newcastle.ac.uk>
	<CAHabJ+NDqMN-rQ1BN1TfOjGLQHH-3Wd28LdoF95Agn4HdRrThg@mail.gmail.com>
	<CAHabJ+PMdQ-f7G8RNz0R7mfGUwBMAsnCyO=NmQhxyq0+gB1aPg@mail.gmail.com>
	<CAAS2fgSAT2otym64oUACpWD8jWLAB6dBusONn-WUx2DK59SB5w@mail.gmail.com>
Message-ID: <CAHabJ+O7n=_ACXJx6_2DzoFC6h=2dk0aR3u3_LZhHgDut1gNMA@mail.gmail.com>

On Sat, Apr 25, 2015 at 3:30 AM, Gregory Maxwell <gmaxwell at gmail.com> wrote:

> On Sat, Apr 25, 2015 at 12:22 AM, Justus Ranvier
> <justus.ranvier at monetas.net> wrote:
> > Taking the hash of the secret would then require an extra step to make
> sure
> > the hash is valid for secp256k1.
>
> The x value may not be a valid member of the group, effectively the
> same as with a hash. Its also very unequally distributed, as only
> about half the possible values are points on the curve.


ack


> > With 97 byte standard OP_RETURN values the ephemeral public
> > key could be appended to the chain code, but that's undesirable for
> other reasons.
>
> Can you elaborate?  Storing a ~33 byte (deterministically generated)
> ephemeral key should be all that is required. Everything else,
> including the chain code could be derived from it. What reason do you
> have to include additional data?
>

The goal of the notification transaction is to send the same payment code
to every recipient, but obscure the identity of the sender of the
notification transaction from third party blockchain observers.

The shared secret is used for that purpose, and the sender's public key
used for ECDH can't be one derived from the payment code since the
recipient doesn't yet know the payment code.

The notification transaction needs to communicate the 65 byte payment code
along with one ephemeral public key used for ECDH. If that ephemeral key is
not located in a signature script, it has to be somewhere else (such as in
the same OP_RETURN output as the payment code.)


> > Taking the SHA512 of something less than 512 bits seemed wrong.
>
> Why should it?  Adding the Y does not increase the entropy at all.  As
> an aside, I think this can be reformulated to only need 256 bits of
> output, and then the need for yet-another-hash-function could be
> avoided in some cases.
>

Already fixed in
https://github.com/justusranvier/rfc/commit/8c4d3429012eb15847c4ae68f212c8b2dcd1b521
but it would be good to get confirmation of whether the way I fixed it is
valid.

> In this proposal I optimized for non-reliance on third party services
>
> The requirement for inputs is a guaranteed dependency on third party
> services; so if thats whats being optimized for here it must go (well,
> I think it must go for the reason of avoiding blocking users from
> using other schemes to control their coins too..).
>

I'm not sure what you mean by "the requirement for inputs is a guaranteed
dependency on third party
services"

At the proposal currently stands, an SPV wallet will have no trouble
sending or receiving notification transactions without access to a third
party service. The recipient just needs to see the transactions associated
with its notification address.

The point about restricting the types of scripts used as inputs is valid,
but I think workarounds are available. If nothing else, the sender can make
a suitable input using it's own (suitably mixed) coins first.

> I agree. I could not find a straightforward way to express a
> multisignature payment code in less than 80 bytes.
>
> A prior stealth address proposal here handled them fine with only a
> single ephemeral point in the op_return. It does result in a longer
> address (is that what you're referring to with '80 bytes'?)
>

I considered defining an additional path level for deterministic m-of-n
multisig and adding a few bytes to the payment code to express those
parameters, but thought it would be too limiting since it would preclude
multisig with truly independent keys. It is a thing that could be done,
however.

> Exchanges could restrict bitcoin withdrawals to a single payment code
> known to be associated with their identified customer.
> > In some jurisdictions the ability to prove that withdrawals are sent to
> a positively-identified party, rather than arbitrary third parties, might
> move some Bitcoin businesses out of money transmitter territory into less
> onerous regulatory situations.
>
> But this mandates horrible key management practices, reliance on a
> single "hardcoded" private key which you cannot change; even if it
> might be compromised or lost to the wind. It's less horrible than
> sticking to a single address because it doesn't wedge privacy, I
> agree; but care should be taken that a tortured dance for confused
> regulatory cargo-cult reasons doesn't mandate people not engage in
> sound practices like periodic key rotation. :)
>

Cold storage is still available (if admittedly less convenient than in
traditional wallets).

I would expect exchanges in practice to allow for payment codes to be
changed, just with non-trivial waiting periods and plenty of human
overview. It would be an infrequent event compared to the frequency of
withdrawals.

Various schemes which use public key authentication instead of passwords
for web site authentication could be used to continually verify that the
user hasn't lost access to the key.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150425/acb86657/attachment.html>

From stephencalebmorse at gmail.com  Sat Apr 25 14:32:36 2015
From: stephencalebmorse at gmail.com (Stephen Morse)
Date: Sat, 25 Apr 2015 10:32:36 -0400
Subject: [Bitcoin-development] 75%/95% threshold for transaction versions
In-Reply-To: <CABjHNoTeMiLWkDBUqdV4HJ=nAhj8wqOjD4cypY9Dv2y9HJWJMg@mail.gmail.com>
References: <552EF785.7000207@sky-ip.org>
	<CAPg+sBgAhdgPPjmT5i0PMYhQo=Hk6Weo8tpX_Wyn-NJ5Ye9D_A@mail.gmail.com>
	<552FDF73.6010104@sky-ip.org>
	<CABjHNoTeMiLWkDBUqdV4HJ=nAhj8wqOjD4cypY9Dv2y9HJWJMg@mail.gmail.com>
Message-ID: <CABHVRKTMg3sih8i3ta0v=jZU+fBzBR-i5b_b7C+drV4CAfGQJg@mail.gmail.com>

Hi William,

I personally prefer this solution, since it nails the problem
> completely with one simple and obvious change. The BIP 62 approach is
> more like a game of wac-a-mole.
>

The two are complementary, not competing. BIP62 prevents *non-signers* from
mutating the transactions, which is very important. The 'Build your own
nHashType' proposal enables chained transactions even in the face of
*signers* mutating the transaction. I believe that integrating both will
lead to the best defense against transaction malleability, and will enable
more complicated uses of chained transactions (such as micropayment
channels).

Best,
Stephen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150425/155f2e23/attachment.html>

From stephencalebmorse at gmail.com  Sat Apr 25 15:40:37 2015
From: stephencalebmorse at gmail.com (Stephen Morse)
Date: Sat, 25 Apr 2015 11:40:37 -0400
Subject: [Bitcoin-development] 75%/95% threshold for transaction versions
In-Reply-To: <CAAS2fgSay0DqeWXfZwX-sN71sLHdRLD51PBmnJfJ5+TC0BQ8zg@mail.gmail.com>
References: <552EF785.7000207@sky-ip.org>
	<CAPg+sBgAhdgPPjmT5i0PMYhQo=Hk6Weo8tpX_Wyn-NJ5Ye9D_A@mail.gmail.com>
	<552FDF73.6010104@sky-ip.org>
	<CABjHNoTeMiLWkDBUqdV4HJ=nAhj8wqOjD4cypY9Dv2y9HJWJMg@mail.gmail.com>
	<CAAS2fgSay0DqeWXfZwX-sN71sLHdRLD51PBmnJfJ5+TC0BQ8zg@mail.gmail.com>
Message-ID: <CABHVRKS0EYV0CqKW1MVtUZC3u4KvSxMB=Uks9UrCUBQbozO9xQ@mail.gmail.com>

Hi Gregory,

In particular not covering the ID allows for transaction replay which
> can result in monetary losses far more severe than any possible
> mishandling of malleability could result in. Byzantine attackers can
> costlessly replay your old transactions any time anyone reuses an
> address, even accidentally (which cannot be easily prevented since
> they can race).
>

With the SIGHASH_WITHOUT_PREV_VALUE flag, signatures have to explicitly
specify that they are to be signed without the previous UTXO's
value/amount. This means that, at worst, replay attacks can send the money
to the same place it was sent before (which in many cases is likely not be
a loss of funds), and only if the amount sent to the reused address is the
exact same as it was before. I don't think this is worse than an attacker
being able to mutate their transaction and extort a merchant who accepts
zero-conf transactions. Anyway, not signing the input ID wouldn't exactly
be the norm, there would be a defined set of flags for standard use cases.
Not signing the input TXID would only be used in specialized cases, such as
setting up micropayment channels.


> There are no free lunches;  the proposal linked to there is itself a
> game of wack-a-mole with assorted masking flags;


I agree that it is also a bit of wac-a-mole, but the defined space of
issues is possibly more limited here. There are only X number of things
that can be signed/not signed in a transaction, and the 'Build your own
nHashType' proposal enables you to fully specify which of those are being
signed. If you don't want to get burned by not fully signing your
transactions, then don't use the non-standard sighash flags.

many of which we have
> no notion of if they're useful for any particular application(s);


A few of the flags, indeed, may not ever be useful. But we can't predict
the future, and I think it's better to build in a more flexible solution
now than to wish we had more flexible nHashTypes later.

To the original point of this thread, hopefully the suggested proposal
won't be necessary as wallets will upgrade to use version 3 transactions
and the rules associated with them over time.

Best,
Stephen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150425/7e76a1b7/attachment.html>

From s7r at sky-ip.org  Sun Apr 26 00:01:10 2015
From: s7r at sky-ip.org (s7r)
Date: Sun, 26 Apr 2015 03:01:10 +0300
Subject: [Bitcoin-development] 75%/95% threshold for transaction versions
In-Reply-To: <CABHVRKS0EYV0CqKW1MVtUZC3u4KvSxMB=Uks9UrCUBQbozO9xQ@mail.gmail.com>
References: <552EF785.7000207@sky-ip.org>	<CAPg+sBgAhdgPPjmT5i0PMYhQo=Hk6Weo8tpX_Wyn-NJ5Ye9D_A@mail.gmail.com>	<552FDF73.6010104@sky-ip.org>	<CABjHNoTeMiLWkDBUqdV4HJ=nAhj8wqOjD4cypY9Dv2y9HJWJMg@mail.gmail.com>	<CAAS2fgSay0DqeWXfZwX-sN71sLHdRLD51PBmnJfJ5+TC0BQ8zg@mail.gmail.com>
	<CABHVRKS0EYV0CqKW1MVtUZC3u4KvSxMB=Uks9UrCUBQbozO9xQ@mail.gmail.com>
Message-ID: <553C2AC6.3000109@sky-ip.org>

Thank you all for your comments. The youtube video was indeed very
educative and nice to watch.

It's true that malleability is not the end of the world, but it is
annoying for contracts and micropayment channels, especially refunds
spending the fund tx before it is even in the blockchain, relying solely
on its txid.

BIP62 is good for preventing 3rd parties (non signers) to mutate txids,
but cannot do anything against 2nd parties (signers). I think we can
solve both by using NORMALIZEDTXID - wouldn't this be simpler and easier
to implement? Why are we talking about P3SH when we can just upgrade
P2SH to support additional OP codes? I saw that there have been talks
about a hard fork for increasing the block size, might as well take the
opportunity and fix this for good, by implementing BIP62, NORMALIZEDTXID
as well as BIP65. Couldn't all these be part of P2SH?

On 4/25/2015 6:40 PM, Stephen Morse wrote:
> Hi Gregory,
> 
>     In particular not covering the ID allows for transaction replay which
>     can result in monetary losses far more severe than any possible
>     mishandling of malleability could result in. Byzantine attackers can
>     costlessly replay your old transactions any time anyone reuses an
>     address, even accidentally (which cannot be easily prevented since
>     they can race).
> 
> 
> With the SIGHASH_WITHOUT_PREV_VALUE flag, signatures have to explicitly
> specify that they are to be signed without the previous UTXO's
> value/amount. This means that, at worst, replay attacks can send the
> money to the same place it was sent before (which in many cases is
> likely not be a loss of funds), and only if the amount sent to the
> reused address is the exact same as it was before. I don't think this is
> worse than an attacker being able to mutate their transaction and extort
> a merchant who accepts zero-conf transactions. Anyway, not signing the
> input ID wouldn't exactly be the norm, there would be a defined set of
> flags for standard use cases. Not signing the input TXID would only be
> used in specialized cases, such as setting up micropayment channels. 
>  
> 
>     There are no free lunches;  the proposal linked to there is itself a
>     game of wack-a-mole with assorted masking flags; 
> 
> 
> I agree that it is also a bit of wac-a-mole, but the defined space of
> issues is possibly more limited here. There are only X number of things
> that can be signed/not signed in a transaction, and the 'Build your own
> nHashType' proposal enables you to fully specify which of those are
> being signed. If you don't want to get burned by not fully signing your
> transactions, then don't use the non-standard sighash flags.
> 
>     many of which we have
>     no notion of if they're useful for any particular application(s); 
> 
> 
> A few of the flags, indeed, may not ever be useful. But we can't predict
> the future, and I think it's better to build in a more flexible solution
> now than to wish we had more flexible nHashTypes later.
> 
> To the original point of this thread, hopefully the suggested proposal
> won't be necessary as wallets will upgrade to use version 3 transactions
> and the rules associated with them over time. 
> 
> Best,
> Stephen
> 
> 
> ------------------------------------------------------------------------------
> One dashboard for servers and applications across Physical-Virtual-Cloud 
> Widest out-of-the-box monitoring support with 50+ applications
> Performance metrics, stats and reports that give you Actionable Insights
> Deep dive visibility with transaction tracing using APM Insight.
> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y
> 
> 
> 
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> 



From joseph at lightning.network  Sun Apr 26 06:51:37 2015
From: joseph at lightning.network (Joseph Poon)
Date: Sat, 25 Apr 2015 23:51:37 -0700
Subject: [Bitcoin-development] 75%/95% threshold for transaction versions
In-Reply-To: <553C2AC6.3000109@sky-ip.org>
References: <552EF785.7000207@sky-ip.org>
	<CAPg+sBgAhdgPPjmT5i0PMYhQo=Hk6Weo8tpX_Wyn-NJ5Ye9D_A@mail.gmail.com>
	<552FDF73.6010104@sky-ip.org>
	<CABjHNoTeMiLWkDBUqdV4HJ=nAhj8wqOjD4cypY9Dv2y9HJWJMg@mail.gmail.com>
	<CAAS2fgSay0DqeWXfZwX-sN71sLHdRLD51PBmnJfJ5+TC0BQ8zg@mail.gmail.com>
	<CABHVRKS0EYV0CqKW1MVtUZC3u4KvSxMB=Uks9UrCUBQbozO9xQ@mail.gmail.com>
	<553C2AC6.3000109@sky-ip.org>
Message-ID: <20150426065137.GA7911@lightning.network>

On Sun, Apr 26, 2015 at 03:01:10AM +0300, s7r wrote:
> It's true that malleability is not the end of the world, but it is
> annoying for contracts and micropayment channels, especially refunds
> spending the fund tx before it is even in the blockchain, relying
> solely on its txid.

Agreed, needing the transaction to be signed & broadcastable before the
refunds can be generated is similar to paying for a contract before the
terms have been decided.

>  I think we can solve both by using NORMALIZEDTXID - wouldn't this be
>  simpler and easier to implement? 

The current problem is that SIGHASH_NORMALIZED_TXID as presently
discussed implies stripping the sigScript, which is not sufficient for
the Lightning Network.

The currently discussed SIGHASH_NORMALIZED_TXID does not permit chained
transactions 2 levels deep, which is necessary for Lightning as well.
The path from the Commitment -> HTLC -> Refund requires up to 3 levels
deep of transactions. 

Suppose TxA -> TxB -> TxC -> TxD. All outputs are 2-of-2 multisig. TxA
has already entered into the blockchain, the rest have not yet been
broadcast. If TxB spends from TxA, it doesn't need new sighash flags, it
just does a plain SIGHASH_ALL. However, TxC needs
SIGHASH_NORMALIZED_TXID due to malleability risks.
SIGHASH_NORMALIZED_TXID works for TxC because the sigScript can change,
but because TxA's txid has already entered the blockchain, the parent's
input txids cannot change (with high degrees of certainty).

However, with TxD, the txid of TxB may be different, which will result
in an invalid transaction if SIGHASH_NORMALIZED_TXID only strips the
sigScript when obtaining the normalized txid of TxC. The reason for this
is TxC's input txid of TxB has changed (TxC's input 0 txid of TxB)!

Therefore, a functional SIGHASH_NORMALIZED which permits chained
transactions requires the parent transaction's sigScript *AND* txid to
be stripped when determining the parent's normalized txid. Similar to
OP_CHECKSIG, a part of the normalized TXID includes each input's
scriptPubKey, e.g. TxC's normalized TXID includes TxB's scriptPubKey
output which it is spending, so when TxD signs TxC's normalized TXID, it
includes TxB's output (this is a cheap way of increasing uniqueness but
is not an absolute necessity if it's too difficult). All this data
should be immediately available when validating the transaction and
appending it to the UTXO set.

If the txid and sigScript are removed when building the normalized input
txid as part of the spend/signature, it should be possible for chained
transactions to work. However, this isn't absolute security against
replay attacks. If there are two spends with all inputs having the same
values *AND* the same scriptPubKeys per input, then it can be replayed.
The odds of this occurring seems like a sort of uncanny valley of risks;
it's low enough that it shouldn't ever happen which may result in a lack
of documentation, so when it does happen it'll be a big surprise. So,
even if this "safer" method becomes a softfork, perhaps great care
should be taken before making this a default method of spending when the
sighash flag is not an absolute necessity (i.e. "don't do it!" I'm all
in favor of giving this a scary name so developers won't inadvertently
think "hey, normalization sounds like a good thing to do").

That said, it should cover an overwhelming majority of potential
replays, it's nearly impossible to create a "duplicate" replayable tx of
someone *else's* send, since the poteintally "replayable" transaction
signs the sigScript of the redeemed output.

As a side note, SIGHASH_NORMALIZED does not permit spending from any
transaction, which is desirable for the Lightning Network (HTLCs may
persist in new Commitment Transactions). However, this is merely a "nice
to have" and is not an absolute necessity, there is no significant loss
of functionality, merely some slight slowdown from significantly more
signatures. For Lightning in particular, the effect would probably be
batching Commitment Transactions (e.g. 1 mass update per second per
channel), with the only major discernable penalty is an order of
magnitude greater storage of signatures.

Additionally, I think it was Mark Friedenbach who brought up that
SIGHASH_NORMALIZED creates significant complexities with the need for an
additional hash with every UTXO (almost doubling the UTXO set size), and
with nodes which already have UTXO pruning enabled, it'll require
downloading the entire blockchain. I'm not sure if this problem is
insurmountable or not, but if a normalized sighash becomes the most
ideal candidate for a malleability soft-fork, then sooner may be better
than later as more nodes start using the pruning patch.


> Why are we talking about P3SH when we can just upgrade
> P2SH to support additional OP codes? 

Assuming you mean the current P2SH scriptPubKey format, it's not
possible to do so while making it a soft fork. If you use OP_EQUAL,
current nodes will treat "P3SH" transactions as P2SH ones.

I'm in favor of keeping P3SH conservative. It's possible to have your
cake and eat it too, by enabling script versions within P3SH.

If you create P3SH as:

OP_DUP <20-byte hash> OP_EQUALVERIFY

The redeemScript has the first byte as a version number, and there is
also an OP_TRUE pushed right before the redeemScript. The scriptSig
would look something like:

<sigs...> OP_TRUE <3 redeemScript>

When executing the script, the last item on the stack verifies against
the hash, then the redeemScript is copied/read, the 3 is popped off
(first byte unsigned int), the OP_TRUE is popped off the stack, and the
script then executes P3SH "version 3" (again, it is the first byte, NOT
an opcode). Any non-known version will return everything as true and not
continue with execution of the script, to permit future soft-forks. The
OP_TRUE is to ensure there is a OP_TRUE left on the stack just in case
for older nodes as this is an EQUALVERIFY.

This works because the address, 20-byte hash, has the 3 version number
as part of the hash, so it is the recipient who determines the version
number. For future soft-forks, it's incredibly flexible, just make the
version byte to 4. Prior addresses work the same, and it's not possible
to accidentally send it using different scripting versions. Perhaps this
can make things upgradeable enough that a malleability sighash flag can
go in sooner rather than later.

-- 
Joseph Poon



From jtimon at jtimon.cc  Sun Apr 26 11:35:33 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Sun, 26 Apr 2015 13:35:33 +0200
Subject: [Bitcoin-development] Relative CHECKLOCKTIMEVERIFY (was CLTV
	proposal)
In-Reply-To: <20150421075912.GA25282@savin.petertodd.org>
References: <20141001130826.GM28710@savin.petertodd.org>
	<55075795.20904@bluematt.me>
	<20150421075912.GA25282@savin.petertodd.org>
Message-ID: <CABm2gDo22grffq4j+Jy_HBD-VrROh32Dbseoa=g-5HXA9Uud1w@mail.gmail.com>

On Tue, Apr 21, 2015 at 9:59 AM, Peter Todd <pete at petertodd.org> wrote:
> Thus we have a few possibilities:
>
> 1) RCLTV against nLockTime
>
> Needs a minimum age > COINBASE_MATURITY to be safe.
>
>
> 2) RCLTV against current block height/time
>
> Completely reorg safe.

Yes, can we call this one OP_MATURITY to distinguish it from RCLTV?

> 3) GET_TXOUT_HEIGHT/TIME <diff> ADD CLTV
>
> To be reorg safe GET_TXOUT_HEIGHT/TIME must fail if minimum age <
> COINBASE_MATURITY. This can be implemented by comparing against
> nLockTime.

Mhmm, interesting.

> All three possibilities require us to make information about the
> prevout's height/time available to VerifyScript(). The only question is
> if we want VerifyScript() to also take the current block height/time - I
> see no reason why it can't. As for the mempool, keeping track of what
> transactions made use of these opcodes so they can be reevaluated if
> their prevouts are re-organised seems fine to me.

I'm totally fine with changing the interface to:

     int bitcoinconsensus_verify_script(const unsigned char
*scriptPubKey, unsigned int scriptPubKeyLen,
                                        const unsigned char *txTo
  , unsigned int txToLen, unsigned nHeight,
                                        unsigned int nIn, unsigned int
flags, bitcoinconsensus_error* err);

I prefer op_maturity over RCLTV and there are also gains for absolute
CLTV as you explain later.
When you validate the script inputs of a transaction you already have
a height, either the real final nHeight in ConnectBlock and the miner,
or nSpendHeight in AcceptToMemoryPool.
The costs are meaningless in my opinion, specially when we will
already have to change the interface to add libsecp256k1's context.

I'm infinitely more worried about the other assumption that the 3
solutions are already making.
Changing to

     int bitcoinconsensus_verify_script(const unsigned char
*scriptPubKey, unsigned int scriptPubKeyLen,
                                        const unsigned char *txTo
  , unsigned int txToLen, const CCoinsViewCache& inputs,
                                        unsigned int nIn, unsigned int
flags, bitcoinconsensus_error* err);

Is simply not possible because CCoinsViewCache is a C++.
You could solve it in a similar way in which you could solve that
dependency for VerifyTransaction.
For example:

typedef const CTxOut& (*TxOutputGetter)(const uint256& txid, uint32_t n);

      int bitcoinconsensus_verify_script(const unsigned char
*scriptPubKey, unsigned int scriptPubKeyLen,
                                        const unsigned char *txTo
  , unsigned int txToLen, TxOutputGetter utxoGetter,
                                        unsigned int nIn, unsigned int
flags, bitcoinconsensus_error* err);

Of course, this is assuming that CTxOut becomes a C struct instead of
a C++ class and little things like that.
In terms of code encapsulation, this is still 100 times uglier than
adding the nHeight so if we're doing it, yes, please, let's do both.

There's another possibility that could keep the utxo out of Script verification:

class CTxIn
{
public:
    COutPoint prevout;
    CScript scriptSig;
    uint32_t nSequence;
}

could turn into:

class CTxIn
{
public:
    COutPoint prevout;
    CScript scriptSig;
    uint32_t nHeight;
}

And a new softfork rule could enforce that all new CTxIn set nHeight
to the correct height in which its corresponding prevout got into the
chain.
That would remove the need for the TxOutputGetter param in
bitcoinconsensus_verify_script, but unfortunately it is not reorg safe
(apart from other ugly implementation details).

So, in summary, I think the new interface has to be something along these lines:

      int bitcoinconsensus_verify_script(const unsigned char
*scriptPubKey, unsigned int scriptPubKeyLen,
                                        const unsigned char *txTo,
unsigned int nIn,
                                        unsigned int txToLen,
TxOutputGetter utxoGetter, unsigned nHeight, secp256k1_context_t *ctx
                                        unsigned int flags,
bitcoinconsensus_error* err);

> Time-based locks
> ================
>
> Do we want to support them at all? May cause incentive issues with
> mining, see #bitcoin-wizards discussion, Jul 17th 2013:
>
> https://download.wpsoftware.net/bitcoin/wizards/2013/07/13-07-17.log

I'm totally fine not supporting time-based locks for the new operators.
Removing them from the regular nLockTime could be more complicated but
I wouldn't mind either.
Every time I think of a contract or protocol that involves time, I do
it in terms of block heights.
I would prefer to change all my clocks to work in blocks instead of
minutes over changing nHeights for timestamps in any of those
contracts.

> --
> 'peter'[:-1]@petertodd.org
> 0000000000000000015e09479548c5b63b99a62d31b019e6479f195bf0cbd935
>
> ------------------------------------------------------------------------------
> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT
> Develop your own process in accordance with the BPMN 2 standard
> Learn Process modeling best practices with Bonita BPM through live exercises
> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual- event?utm_
> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>



From jtimon at jtimon.cc  Sun Apr 26 12:20:04 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Sun, 26 Apr 2015 14:20:04 +0200
Subject: [Bitcoin-development] Relative CHECKLOCKTIMEVERIFY (was CLTV
	proposal)
In-Reply-To: <CABm2gDo22grffq4j+Jy_HBD-VrROh32Dbseoa=g-5HXA9Uud1w@mail.gmail.com>
References: <20141001130826.GM28710@savin.petertodd.org>
	<55075795.20904@bluematt.me>
	<20150421075912.GA25282@savin.petertodd.org>
	<CABm2gDo22grffq4j+Jy_HBD-VrROh32Dbseoa=g-5HXA9Uud1w@mail.gmail.com>
Message-ID: <CABm2gDovFzpL_7KFqPXxhu4VohRfcE5S_PLAUgjgo_b84GaYeQ@mail.gmail.com>

On Sun, Apr 26, 2015 at 1:35 PM, Jorge Tim?n <jtimon at jtimon.cc> wrote:
> There's another possibility that could keep the utxo out of Script verification:
>
> class CTxIn
> {
> public:
>     COutPoint prevout;
>     CScript scriptSig;
>     uint32_t nSequence;
> }
>
> could turn into:
>
> class CTxIn
> {
> public:
>     COutPoint prevout;
>     CScript scriptSig;
>     uint32_t nHeight;
> }
>
> And a new softfork rule could enforce that all new CTxIn set nHeight
> to the correct height in which its corresponding prevout got into the
> chain.
> That would remove the need for the TxOutputGetter param in
> bitcoinconsensus_verify_script, but unfortunately it is not reorg safe
> (apart from other ugly implementation details).

Wait, wait, this can be made reorg-safe and more backards compatible.
The new validation rule at the tx validation level (currently in
main::CheckInputs()) would be

for (unsigned int i = 0; i < tx.vin.size(); i++) {
// ...
            if (tx.vin.nHeight + 100 > tx.nLockTime)
                return state.Invalid(false, REJECT_INVALID,
"bad-txns-vin-height-reorg-unsafe");
            if (coins->nHeight > tx.vin.nHeight)
                return state.Invalid(false, REJECT_INVALID,
"bad-txns-vin-height-false");
// ...
}

Existing transactions that have used the deprecated CTxIn::nSequence
for something else will be fine if they've used low nSequences.
The only concern would be breaking some colored coins kernels, but
there's many others implemented that don't rely on CTxIn::nSequence.

Transactions that want to use OP_MATURITY just have to set the
corresponding CTxIn::nHeight and CTransaction::nLockTime properly.
This way op_maturity wouldn't require anything from the utxo and the
final interface could be:

 int bitcoinconsensus_verify_script(const unsigned char* scriptPubKey,
unsigned int scriptPubKeyLen,
                                        const unsigned char* txTo,
unsigned int txToLen,
                                        unsigned int nIn, unsigned int nHeight,
                                        unsigned int flags,
secp256k1_context_t* ctx,
                                        bitcoinconsensus_error* err);



From mike at plan99.net  Sun Apr 26 12:58:03 2015
From: mike at plan99.net (Mike Hearn)
Date: Sun, 26 Apr 2015 14:58:03 +0200
Subject: [Bitcoin-development] Fwd: Reusable payment codes
In-Reply-To: <CAHabJ+O7n=_ACXJx6_2DzoFC6h=2dk0aR3u3_LZhHgDut1gNMA@mail.gmail.com>
References: <CAHabJ+Mn0=vfLvTJ+z3tx8cFAAuLD1pLp4rOe3pM6MtCrCxjwg@mail.gmail.com>
	<1AE7B0A2-90EE-42EE-9D30-4DC1B5892E53@newcastle.ac.uk>
	<CAHabJ+NDqMN-rQ1BN1TfOjGLQHH-3Wd28LdoF95Agn4HdRrThg@mail.gmail.com>
	<CAHabJ+PMdQ-f7G8RNz0R7mfGUwBMAsnCyO=NmQhxyq0+gB1aPg@mail.gmail.com>
	<CAAS2fgSAT2otym64oUACpWD8jWLAB6dBusONn-WUx2DK59SB5w@mail.gmail.com>
	<CAHabJ+O7n=_ACXJx6_2DzoFC6h=2dk0aR3u3_LZhHgDut1gNMA@mail.gmail.com>
Message-ID: <CANEZrP20sFUHcabC4+JyR3rv6Xi9AXCUYo__3ZkfWyDjm1YQ7Q@mail.gmail.com>

Could you maybe write a short bit of text comparing this approach to
extending BIP70 and combining it with a simple Subspace style
store-and-forward network?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150426/7e1035ab/attachment.html>

From justus.ranvier at monetas.net  Sun Apr 26 14:50:00 2015
From: justus.ranvier at monetas.net (Justus Ranvier)
Date: Sun, 26 Apr 2015 16:50:00 +0200
Subject: [Bitcoin-development] Fwd: Reusable payment codes
In-Reply-To: <CANEZrP20sFUHcabC4+JyR3rv6Xi9AXCUYo__3ZkfWyDjm1YQ7Q@mail.gmail.com>
References: <CAHabJ+Mn0=vfLvTJ+z3tx8cFAAuLD1pLp4rOe3pM6MtCrCxjwg@mail.gmail.com>
	<1AE7B0A2-90EE-42EE-9D30-4DC1B5892E53@newcastle.ac.uk>
	<CAHabJ+NDqMN-rQ1BN1TfOjGLQHH-3Wd28LdoF95Agn4HdRrThg@mail.gmail.com>
	<CAHabJ+PMdQ-f7G8RNz0R7mfGUwBMAsnCyO=NmQhxyq0+gB1aPg@mail.gmail.com>
	<CAAS2fgSAT2otym64oUACpWD8jWLAB6dBusONn-WUx2DK59SB5w@mail.gmail.com>
	<CAHabJ+O7n=_ACXJx6_2DzoFC6h=2dk0aR3u3_LZhHgDut1gNMA@mail.gmail.com>
	<CANEZrP20sFUHcabC4+JyR3rv6Xi9AXCUYo__3ZkfWyDjm1YQ7Q@mail.gmail.com>
Message-ID: <CAHabJ+McTyW=6Vp1GwTzKefsP9Uo0w+A++sUBwMYJn4L3N__ow@mail.gmail.com>

Payment codes establish the identity of the payer and allow for simpler
methods for identifying the payee, and automatically provide the payee with
the information they need to send a refund.

If merchants and customers were using payment codes, they would not need
the BIP70 equivalents.

I think the best way to explain payment codes is that they add the missing
"from address" to transactions which users want, but we've had to tell them
they can't have.

A payment code behaves much more like an email address than a traditional
Bitcoin address.

On Sun, Apr 26, 2015 at 2:58 PM, Mike Hearn <mike at plan99.net> wrote:

> Could you maybe write a short bit of text comparing this approach to
> extending BIP70 and combining it with a simple Subspace style
> store-and-forward network?
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150426/880a3f4a/attachment.html>

From joseph at lightning.network  Sun Apr 26 16:48:03 2015
From: joseph at lightning.network (Joseph Poon)
Date: Sun, 26 Apr 2015 09:48:03 -0700
Subject: [Bitcoin-development] 75%/95% threshold for transaction versions
In-Reply-To: <20150426065137.GA7911@lightning.network>
References: <552EF785.7000207@sky-ip.org>
	<CAPg+sBgAhdgPPjmT5i0PMYhQo=Hk6Weo8tpX_Wyn-NJ5Ye9D_A@mail.gmail.com>
	<552FDF73.6010104@sky-ip.org>
	<CABjHNoTeMiLWkDBUqdV4HJ=nAhj8wqOjD4cypY9Dv2y9HJWJMg@mail.gmail.com>
	<CAAS2fgSay0DqeWXfZwX-sN71sLHdRLD51PBmnJfJ5+TC0BQ8zg@mail.gmail.com>
	<CABHVRKS0EYV0CqKW1MVtUZC3u4KvSxMB=Uks9UrCUBQbozO9xQ@mail.gmail.com>
	<553C2AC6.3000109@sky-ip.org>
	<20150426065137.GA7911@lightning.network>
Message-ID: <20150426164803.GA22592@lightning.network>

On Sat, Apr 25, 2015 at 11:51:37PM -0700, Joseph Poon wrote:
> signs the sigScript of the redeemed output.

Err, typo, I meant:
... signs the *scriptPubKey* of the redeemed output.

-- 
Joseph Poon



From tomh at thinlink.com  Mon Apr 27 00:50:22 2015
From: tomh at thinlink.com (Tom Harding)
Date: Sun, 26 Apr 2015 17:50:22 -0700
Subject: [Bitcoin-development] Proof of Payment
In-Reply-To: <CAPswA9wZk_8EjbN8J-VbMGQ6nrZ7SthopJ=HYMtpxhSCsm_neA@mail.gmail.com>
References: <CAPswA9zzVDxW8_WXg5833r2Z4pxZOppYtNLHMQ=Nw-H72cMz7w@mail.gmail.com>	<A2849710-1069-45A1-89C0-9D8E40C4A8D6@newcastle.ac.uk>	<CAPswA9wNS2J=4YhpqWN8SmzJuUF8mek8XLUYTE+twLX9vM4Jhg@mail.gmail.com>
	<CAPswA9wZk_8EjbN8J-VbMGQ6nrZ7SthopJ=HYMtpxhSCsm_neA@mail.gmail.com>
Message-ID: <553D87CE.5000005@thinlink.com>

On 4/22/2015 1:03 PM, Kalle Rosenbaum wrote:
>
> I've built a proof-of-concept for Proof of Payment. It's available at
> http://www.rosenbaum.se:8080. The site contains links to the source
> code for both the server and a Mycelium fork as well as pre-built apk:s.
>
>
>     >> There are several scenarios in which it would be useful to
>     prove that you have paid for something. For example:
>     >> A pre-paid hotel room where your PoP functions as a key to the
>     door.
>     >> An online video rental service where you pay for a video and
>     watch it on any device.
>     >> An ad-sign where you pay in advance for e.g. 2-weeks
>     exclusivity. During this period you can upload new content to the
>     sign whenever you like using PoP.
>     >> A lottery where all participants pay to the same address, and
>     the winner of the T-shirt is selected among the transactions to
>     that address. You exchange the T-shirt for a PoP for the winning
>     transaction.
>

Kalle,

You propose a standard format for proving that wallet-controlled funds
COULD HAVE BEEN spent as they were in a real transaction.  Standardized
PoP would give wallets a new way to communicate with the outside world.

PoP could allow payment and delivery to be separated in time in a
standard way, without relying on a mechanism external to bitcoin's
cryptosystem, and enable standardized real-world scenarios where sender
!= beneficiary, and/or receiver != provider.

Payment:
sender -> receiver

Delivery:
beneficiary <- provider

Some more use cases might be:
Waiting in comfort:
 - Send a payment ahead of time, then wander over and collect the goods
after X confirmations.

Authorized pickup :
 - Hot wallet software used by related people could facilitate the use
of 1 of N multisig funds.  Any one of the N wallets could collect goods
and services purchased by any of the others.

Non-monetary gifts:
 - Sender exports spent keys to a beneficiary, enabling PoP to work as a
gift claim

Contingent services:
 - Without Bob's permission, a 3rd party conditions action on a payment
made from Alice to Bob.  For example, if you donated at least .02 BTC to
Dorian, you (or combining scenarios, any of your N authorized family
members), can come to my dinner party.

I tried out your demo wallet and service and it worked as advertised.

Could the same standard also be used to prove that a transaction COULD
BE created?  To generalize the concept beyond actual payments, you could
call it something like proof of payment potential.

Why not make these proofs permanently INVALID transactions, to remove
any possibility of their being mined and spending everything to fees
when used in this way, and also in cases involving reorganizations?

I agree that PoP seems complementary to BIP70.





From laanwj at gmail.com  Mon Apr 27 06:40:10 2015
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Mon, 27 Apr 2015 08:40:10 +0200
Subject: [Bitcoin-development] Bitcoin Core 0.10.1 released
Message-ID: <20150427064009.GA14218@amethyst.visucore.com>

Bitcoin Core version 0.10.1 is now available from:

  <https://bitcoin.org/bin/bitcoin-core-0.10.1/>

The distribution is also available as torrent:

   https://bitcoin.org/bin/bitcoin-core-0.10.1/bitcoin-0.10.1.torrent

   magnet:?xt=urn:btih:b6f8da60aaf2007cd6db631637951ae673e31044&dn=bitcoin-core-0.10.1&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80%2Fannounce&tr=udp%3A%2F%2Ftracker.publicbt.com%3A80%2Fannounce&tr=udp%3A%2F%2Ftracker.ccc.de%3A80%2Fannounce&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&tr=udp%3A%2F%2Fopen.demonii.com%3A1337&ws=https%3A%2F%2Fbitcoin.org%2Fbin%2F

The source code can be found in git under the tag `v0.10.1`, or in `bitcoin-0.10.1.tar.gz` in the distribution.

This is a new minor version release, bringing bug fixes and translation 
updates. It is recommended to upgrade to this version.

Please report bugs using the issue tracker at github:

  <https://github.com/bitcoin/bitcoin/issues>

Upgrading and downgrading
=========================

How to Upgrade
--------------

If you are running an older version, shut it down. Wait until it has completely
shut down (which might take a few minutes for older versions), then run the
installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or
bitcoind/bitcoin-qt (on Linux).

Downgrade warning
------------------

Because release 0.10.0 and later makes use of headers-first synchronization and
parallel block download (see further), the block files and databases are not
backwards-compatible with pre-0.10 versions of Bitcoin Core or other software:

* Blocks will be stored on disk out of order (in the order they are
received, really), which makes it incompatible with some tools or
other programs. Reindexing using earlier versions will also not work
anymore as a result of this.

* The block index database will now hold headers for which no block is
stored on disk, which earlier versions won't support.

If you want to be able to downgrade smoothly, make a backup of your entire data
directory. Without this your node will need start syncing (or importing from
bootstrap.dat) anew afterwards. It is possible that the data from a completely
synchronised 0.10 node may be usable in older versions as-is, but this is not
supported and may break as soon as the older version attempts to reindex.

This does not affect wallet forward or backward compatibility.

Notable changes
===============

This is a minor release and hence there are no notable changes.
For the notable changes in 0.10, refer to the release notes for the
0.10.0 release at https://github.com/bitcoin/bitcoin/blob/v0.10.0/doc/release-notes.md

0.10.1 Change log
=================

Detailed release notes follow. This overview includes changes that affect external
behavior, not code moves, refactors or string updates.

RPC:
- `7f502be` fix crash: createmultisig and addmultisigaddress
- `eae305f` Fix missing lock in submitblock

Block (database) and transaction handling:
- `1d2cdd2` Fix InvalidateBlock to add chainActive.Tip to setBlockIndexCandidates
- `c91c660` fix InvalidateBlock to repopulate setBlockIndexCandidates
- `002c8a2` fix possible block db breakage during re-index
- `a1f425b` Add (optional) consistency check for the block chain data structures
- `1c62e84` Keep mempool consistent during block-reorgs
- `57d1f46` Fix CheckBlockIndex for reindex
- `bac6fca` Set nSequenceId when a block is fully linked

P2P protocol and network code:
- `78f64ef` don't trickle for whitelisted nodes
- `ca301bf` Reduce fingerprinting through timestamps in 'addr' messages.
- `200f293` Ignore getaddr messages on Outbound connections.
- `d5d8998` Limit message sizes before transfer
- `aeb9279` Better fingerprinting protection for non-main-chain getdatas.
- `cf0218f` Make addrman's bucket placement deterministic (countermeasure 1 against eclipse attacks, see http://cs-people.bu.edu/heilman/eclipse/)
- `0c6f334` Always use a 50% chance to choose between tried and new entries (countermeasure 2 against eclipse attacks)
- `214154e` Do not bias outgoing connections towards fresh addresses (countermeasure 2 against eclipse attacks)
- `aa587d4` Scale up addrman (countermeasure 6 against eclipse attacks)
- `139cd81` Cap nAttempts penalty at 8 and switch to pow instead of a division loop

Validation:
- `d148f62` Acquire CCheckQueue's lock to avoid race condition

Build system:
- `8752b5c` 0.10 fix for crashes on OSX 10.6

Wallet:
- N/A

GUI:
- `2c08406` some mac specifiy cleanup (memory handling, unnecessary code)
- `81145a6` fix OSX dock icon window reopening
- `786cf72` fix a issue where "command line options"-action overwrite "Preference"-action (on OSX)

Tests:
- `1117378` add RPC test for InvalidateBlock

Miscellaneous:
- `c9e022b` Initialization: set Boost path locale in main thread
- `23126a0` Sanitize command strings before logging them.
- `323de27` Initialization: setup environment before starting QT tests
- `7494e09` Initialization: setup environment before starting tests
- `df45564` Initialization: set fallback locale as environment variable

Credits
=======

Thanks to everyone who directly contributed to this release:

- Alex Morcos
- Cory Fields
- dexX7
- fsb4000
- Gavin Andresen
- Gregory Maxwell
- Ivan Pustogarov
- Jonas Schnelli
- Matt Corallo
- mrbandrews
- Pieter Wuille
- Ruben de Vries
- Suhas Daftuar
- Wladimir J. van der Laan

And all those who contributed additional code review and/or security research:
- 21E14
- Alison Kendler
- Aviv Zohar
- Ethan Heilman
- Evil-Knievel
- fanquake
- Jeff Garzik
- Jonas Nick
- Luke Dashjr
- Patrick Strateman
- Philip Kaufmann
- Sergio Demian Lerner
- Sharon Goldberg

As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).




From kalle at rosenbaum.se  Mon Apr 27 12:35:27 2015
From: kalle at rosenbaum.se (Kalle Rosenbaum)
Date: Mon, 27 Apr 2015 14:35:27 +0200
Subject: [Bitcoin-development] Proof of Payment
In-Reply-To: <553D87CE.5000005@thinlink.com>
References: <CAPswA9zzVDxW8_WXg5833r2Z4pxZOppYtNLHMQ=Nw-H72cMz7w@mail.gmail.com>
	<A2849710-1069-45A1-89C0-9D8E40C4A8D6@newcastle.ac.uk>
	<CAPswA9wNS2J=4YhpqWN8SmzJuUF8mek8XLUYTE+twLX9vM4Jhg@mail.gmail.com>
	<CAPswA9wZk_8EjbN8J-VbMGQ6nrZ7SthopJ=HYMtpxhSCsm_neA@mail.gmail.com>
	<553D87CE.5000005@thinlink.com>
Message-ID: <CAPswA9xUfr1D6New3hm+1Z1OqSfkAZ8L+VnbFZayG+uJecgaeA@mail.gmail.com>

>
> Some more use cases might be:
> Waiting in comfort:
>  - Send a payment ahead of time, then wander over and collect the goods
> after X confirmations.
>
> Authorized pickup :
>  - Hot wallet software used by related people could facilitate the use
> of 1 of N multisig funds.  Any one of the N wallets could collect goods
> and services purchased by any of the others.

I like this one, because it shows the power of reusing the transaction data
structure.

>
> Non-monetary gifts:
>  - Sender exports spent keys to a beneficiary, enabling PoP to work as a
> gift claim
>
> Contingent services:
>  - Without Bob's permission, a 3rd party conditions action on a payment
> made from Alice to Bob.  For example, if you donated at least .02 BTC to
> Dorian, you (or combining scenarios, any of your N authorized family
> members), can come to my dinner party.

This is an interesting one.

>
> I tried out your demo wallet and service and it worked as advertised.
>
> Could the same standard also be used to prove that a transaction COULD
> BE created?  To generalize the concept beyond actual payments, you could
> call it something like proof of payment potential.

I guess it's possible, but we'd have to remove the txid from the output,
since there is none. This is a way of saying "I'm in control of these
addresses". The other party/parties can then verify the funds on the
blockchain and watch those addresses for changes. Maybe there are some
interesting use cases here. Ideas?

>
> Why not make these proofs permanently INVALID transactions, to remove
> any possibility of their being mined and spending everything to fees
> when used in this way, and also in cases involving reorganizations?

Yes. Initially I thought it would be enough that the funds are already
spent, but I think you're right here. Reorgs could be a problem. Worse, you
also might want to prove 0-confirmation transactions, in which case it's a
huge security problem. Someone might intercept the PoP and publish it on
the bitcoin network, spending all the funds. But I still would like wallets
to be able to build/verify PoPs with little or no modifications. Could we
possibly change the version number on the PoP to something other than 1?
Maybe 2^4-1? Or a really high lock_time, but it would not make it invalid,
just delayed. Any suggestions here?

>
> I agree that PoP seems complementary to BIP70.
>
>

Thank you very much for your comments!

/Kalle
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150427/66ecb226/attachment.html>

From kalle at rosenbaum.se  Mon Apr 27 12:41:51 2015
From: kalle at rosenbaum.se (Kalle Rosenbaum)
Date: Mon, 27 Apr 2015 14:41:51 +0200
Subject: [Bitcoin-development] Proof of Payment
In-Reply-To: <CAPswA9xUfr1D6New3hm+1Z1OqSfkAZ8L+VnbFZayG+uJecgaeA@mail.gmail.com>
References: <CAPswA9zzVDxW8_WXg5833r2Z4pxZOppYtNLHMQ=Nw-H72cMz7w@mail.gmail.com>
	<A2849710-1069-45A1-89C0-9D8E40C4A8D6@newcastle.ac.uk>
	<CAPswA9wNS2J=4YhpqWN8SmzJuUF8mek8XLUYTE+twLX9vM4Jhg@mail.gmail.com>
	<CAPswA9wZk_8EjbN8J-VbMGQ6nrZ7SthopJ=HYMtpxhSCsm_neA@mail.gmail.com>
	<553D87CE.5000005@thinlink.com>
	<CAPswA9xUfr1D6New3hm+1Z1OqSfkAZ8L+VnbFZayG+uJecgaeA@mail.gmail.com>
Message-ID: <CAPswA9w=DMDokS8BrDPTtWa_qpdORbK+V4aNS4DoAKE_F1iVoA@mail.gmail.com>

"Or a really high lock_time, but it would not make it invalid, just
delayed."

Ok, this was a bad idea, since nodes would have to keep it in memory.
Please disregard that idea...

Kalle

Den 27 apr 2015 14:35 skrev "Kalle Rosenbaum" <kalle at rosenbaum.se>:
>
> >
> > Some more use cases might be:
> > Waiting in comfort:
> >  - Send a payment ahead of time, then wander over and collect the goods
> > after X confirmations.
> >
> > Authorized pickup :
> >  - Hot wallet software used by related people could facilitate the use
> > of 1 of N multisig funds.  Any one of the N wallets could collect goods
> > and services purchased by any of the others.
>
> I like this one, because it shows the power of reusing the transaction
data structure.
>
> >
> > Non-monetary gifts:
> >  - Sender exports spent keys to a beneficiary, enabling PoP to work as a
> > gift claim
> >
> > Contingent services:
> >  - Without Bob's permission, a 3rd party conditions action on a payment
> > made from Alice to Bob.  For example, if you donated at least .02 BTC to
> > Dorian, you (or combining scenarios, any of your N authorized family
> > members), can come to my dinner party.
>
> This is an interesting one.
>
> >
> > I tried out your demo wallet and service and it worked as advertised.
> >
> > Could the same standard also be used to prove that a transaction COULD
> > BE created?  To generalize the concept beyond actual payments, you could
> > call it something like proof of payment potential.
>
> I guess it's possible, but we'd have to remove the txid from the output,
since there is none. This is a way of saying "I'm in control of these
addresses". The other party/parties can then verify the funds on the
blockchain and watch those addresses for changes. Maybe there are some
interesting use cases here. Ideas?
>
> >
> > Why not make these proofs permanently INVALID transactions, to remove
> > any possibility of their being mined and spending everything to fees
> > when used in this way, and also in cases involving reorganizations?
>
> Yes. Initially I thought it would be enough that the funds are already
spent, but I think you're right here. Reorgs could be a problem. Worse, you
also might want to prove 0-confirmation transactions, in which case it's a
huge security problem. Someone might intercept the PoP and publish it on
the bitcoin network, spending all the funds. But I still would like wallets
to be able to build/verify PoPs with little or no modifications. Could we
possibly change the version number on the PoP to something other than 1?
Maybe 2^4-1? Or a really high lock_time, but it would not make it invalid,
just delayed. Any suggestions here?
>
> >
> > I agree that PoP seems complementary to BIP70.
> >
> >
>
> Thank you very much for your comments!
>
> /Kalle
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150427/2b7d51b6/attachment.html>

From brian at factom.org  Mon Apr 27 14:53:59 2015
From: brian at factom.org (Brian Deery)
Date: Mon, 27 Apr 2015 09:53:59 -0500
Subject: [Bitcoin-development] Reusable payment codes
Message-ID: <CAFjbNjFqj8OQS7PVd_yP7PCj68_jto=r-mT9gKXHsFRviBDt-A@mail.gmail.com>

Hi Justus:

CC'ing mailing list because more bloom filter and HD wallet experts there
can chime in for some of these thoughts.  I refined some ideas we went over
earlier.

Here are some critiques/worries about the payment codes.

With identities explicitly tied to a payment code, bloom filter clients can
have identities tied to them.

1. There will be a 1:1 relationship between a payment code owner and their
identity.  Presumably the payment code would be strongly and publicly tied
to the identity.  This makes the notification address strongly tied to the
user.  An SPV client connecting to a full node who has a list of
notification address can tie an identity to a bloom filter and connecting
IP.

2. The client can use a bloom filter with a higher false positive rate.  An
active attacker can counter that by sending several payment codes to an
individual user.  The user would then add to their bloom filter all the
shared addresses between them and the attacker.  Even with a high false
positive filter, always matching all the attacker's payment codes would
strongly tie the user to the filter.



Here are some data savings and privacy addition ideas:

65 bytes -> 0 bytes extra.

1. Can you choose only even or odd DER encoding?  That would save you 1
byte.  This would probably throw out 50% of possible addresses though.
2. Can the chain code be fixed or derived from the x value?  Could the
chain value be the x value itself?  (The main question is can a
deterministic public seed be represented as a single 32 bit number?  Maybe
the chain code can be a constant.  Maybe it is ok since subsequent pubkeys
are derived from this.  I only know enough crypto to be dangerous.) That
would save you 32 bytes.  Someone who understands HD wallets would be
better to look at this one.  it would probably be a non-standard derivation.

That leaves you with 32 bytes to communicate to bootstrap the channel.

3: Since you are already looking at the pubkey of the transaction sending
the notification transaction, then you are assuming control of the sending
mechanism.  If you can be sure to use a disposable bitcoin address to send
the notification, then 1 more savings might be possible.  Also assuming the
above two points are possible.

Can you encode the "x value" into the signature's R value?  This would
basically make this transaction look like a standard bitcoin transaction
and gets rid of the op_return completely.



I still like the idea of a common meeting point, a la bitmessage.  The
receiver of the payment code would trial-decode all payment codes sent to a
common pre-specified dead drop address (perhaps a charity address).  "to
send me money, first donate to this charity of my choice."  This trades off
more work on the receivers part to get some privacy as to the number of
people interacting with that receiver.


-cheers
-Brian Deery
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150427/ead7a570/attachment.html>

From justus.ranvier at monetas.net  Mon Apr 27 15:54:36 2015
From: justus.ranvier at monetas.net (Justus Ranvier)
Date: Mon, 27 Apr 2015 15:54:36 +0000
Subject: [Bitcoin-development] Reusable payment codes
In-Reply-To: <CAFjbNjFqj8OQS7PVd_yP7PCj68_jto=r-mT9gKXHsFRviBDt-A@mail.gmail.com>
References: <CAFjbNjFqj8OQS7PVd_yP7PCj68_jto=r-mT9gKXHsFRviBDt-A@mail.gmail.com>
Message-ID: <553E5BBC.7070305@monetas.net>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 04/27/2015 02:53 PM, Brian Deery wrote:
> 1. There will be a 1:1 relationship between a payment code owner
> and their identity.  Presumably the payment code would be strongly
> and publicly tied to the identity.  This makes the notification
> address strongly tied to the user.  An SPV client connecting to a
> full node who has a list of notification address can tie an
> identity to a bloom filter and connecting IP.

SPV clients that connect exclusively to hidden services through Tor
could mitigate this, especially if those clients broadcast their
transactions through different peers than the ones they use for
checking their balance.

Maybe they should even go the opposite way in terms of the false
positive rate.

A client could create a filter that *only* matches their notification
address and use that filter with a selected peer.

All the rest of their addresses would be contained in a different
filter that is never sent to the same full node which is watching
their notification address.

> 2. The client can use a bloom filter with a higher false positive
> rate.  An active attacker can counter that by sending several
> payment codes to an individual user.  The user would then add to
> their bloom filter all the shared addresses between them and the
> attacker.  Even with a high false positive filter, always matching
> all the attacker's payment codes would strongly tie the user to the
> filter.

I'm not sure this problem is solvable in general.

Any entity which has sent bitcoins to a known user could use that
knowledge to attempt to find their bloom filter (if they use one).

I think that for SPV to have any privacy at all clients need to get a
lot smarter about how they use bloom filters overall, such as by
connecting to more than one peer, only putting a subset of their
addresses in a single filter, and temporally varying the addresses
which they watch.


- -- 
Justus Ranvier                   | Monetas <http://monetas.net/>
<mailto:justus at monetas.net>      | Public key ID : C3F7BB2638450DB5
                                 | BM-2cTepVtZ6AyJAs2Y8LpcvZB8KbdaWLwKqc
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2

iQIcBAEBAgAGBQJVPlu8AAoJECpf2nDq2eYj/cAP/iL9qlIkk/jz2N3mT4dIdrSn
rQ+m7dHOSeucUhePrjdM79VzDUQWGmewdi5a1e8wCL2PCBeq/7mapEpHrvWu3xUU
g0qtCa6CbSceW5pO1/BGnKpt298wrBIueeweR3/BPum90RrXT+T/ssQvjGvlY4Jg
ADFeH4axalmCkc87OsJhsEbAAbP9i/u96rItV9ECpOET9pRxp4PzNT/7nz/x5n+q
Lm/vuWy1yoWLUjXiAmXWJVzPs8+Pzf1liy3SEzkam156kUwTj/CqjI/uhf7heSx2
FYSswBc/R1fga7eu++Bm449KUTmyTnnEIT4109A1w18fidY2Dg6PpKYp5CGug96t
aHit1hqLfc8HpNUVWLrBrHsC7riy+QGta4Ie7fAl9SvFcNturkXBFxZLO8f34WMb
HFuWkcCAgZcS3hb1ShmyodMjnOWvHQo/dXAoUc+zI8yuiH9wAD6T4LOTkSwCjvvv
9y4Ia4Mr6v6oHQpUM8ddCMU4AyAYvZXFb68SsnWMZCCio3Ff9wqp2d690oSq36G7
jdjmxot7LrPMnJjNKwTl2jndDTB9Huh9sjWyE9gGBkkIib1purOYtucDsY3h6z7i
5ppG1KTph+xaOLMEvyJZyDNvPhrQGk1ll1kMoD2k7P/5OGV7QwQ0IxpoAqZ1uxJG
44rCXd7P+2R+Bza9qHSH
=d2l3
-----END PGP SIGNATURE-----
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0xEAD9E623.asc
Type: application/pgp-keys
Size: 18399 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150427/5ec2884a/attachment.bin>

From mike at plan99.net  Mon Apr 27 16:46:33 2015
From: mike at plan99.net (Mike Hearn)
Date: Mon, 27 Apr 2015 18:46:33 +0200
Subject: [Bitcoin-development] Reusable payment codes
In-Reply-To: <CAFjbNjFqj8OQS7PVd_yP7PCj68_jto=r-mT9gKXHsFRviBDt-A@mail.gmail.com>
References: <CAFjbNjFqj8OQS7PVd_yP7PCj68_jto=r-mT9gKXHsFRviBDt-A@mail.gmail.com>
Message-ID: <CANEZrP0vXfKpmexNXuYUNoj4fqYiNM2GM=_pEiOdbL-G_73+HQ@mail.gmail.com>

>
> 1. There will be a 1:1 relationship between a payment code owner and their
> identity.
>

Bear in mind, the spec defines "identity" to mean:

     *Identity is a particular extended public/private key pair. *

So that's not quite what is meant normally by identity. It's not a
government / real name identity or an email address or phone number kind of
identity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150427/ab8b6e42/attachment.html>

From justus.ranvier at monetas.net  Mon Apr 27 17:02:36 2015
From: justus.ranvier at monetas.net (Justus Ranvier)
Date: Mon, 27 Apr 2015 17:02:36 +0000
Subject: [Bitcoin-development] Reusable payment codes
In-Reply-To: <CANEZrP0vXfKpmexNXuYUNoj4fqYiNM2GM=_pEiOdbL-G_73+HQ@mail.gmail.com>
References: <CAFjbNjFqj8OQS7PVd_yP7PCj68_jto=r-mT9gKXHsFRviBDt-A@mail.gmail.com>
	<CANEZrP0vXfKpmexNXuYUNoj4fqYiNM2GM=_pEiOdbL-G_73+HQ@mail.gmail.com>
Message-ID: <553E6BAC.8080307@monetas.net>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 04/27/2015 04:46 PM, Mike Hearn wrote:
> So that's not quite what is meant normally by identity. It's not a 
> government / real name identity or an email address or phone number
> kind of identity.

I expect that mappings would begin to develop between payment codes
and government / real name identities, at least as far as that
businesses which are required to collect that kind of information
would associate it with the payment code(s) known to be used by their
customers for their own use.

I proposed payment codes in this form because I'd rather see that kind
of mapping be limited to the application layer and kept away from the
blockchain/network layer.

Even if it makes certain kind of application-layer distasteful
behavior easier, it's a good trade if doing so can simultaneously
provide resistance to graph analysis and make transaction-level
censorship more difficult.

- -- 
Justus Ranvier                   | Monetas <http://monetas.net/>
<mailto:justus at monetas.net>      | Public key ID : C3F7BB2638450DB5
                                 | BM-2cTepVtZ6AyJAs2Y8LpcvZB8KbdaWLwKqc
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2

iQIcBAEBAgAGBQJVPmusAAoJECpf2nDq2eYjhxIP/3Jw9f6kcEsdFTXouQ5+D5gb
MjM8AW7EEA6KXj2PqrPv/H/brorW9/Ugcc8KweCjEdJAKOJV/Bl6sP5ydSZT6pmj
A0IFIkbdxKLY9JC3BbmVHuiAFrsL1u2EX5arUC3WNAWeWlVEmAL92cSlAka4BBxy
P/wh8xN0b4hsgA602Y4Btkv2fBHLQI9NMxW3AsujP3/S78mSxwKQZz4lYAMCowu8
NL/3toaFhrUsdHsH301jNAnxEEOodMVGmgjg/ZSdvWeHwdsE2J8Q9AJqiFDswjU5
q2kZuKmuJ6EXcGDlhelUuUpfHO34qS3/dyTydcqFrYB6eynZ8nV6S1SHaSlDEM10
b95+EpfIENtYdgAqJxwfbqpibpSEIW7cxCAopF0sSbQ2qv8rwRrcIah7KeARCrc0
e+HDcyLhYkrWrlK28vVmIxkEiQ/nmkTu9dOfoVJgXxcVl9AkiHGjo7QICOZHqfRB
TOupk9UUHMmdfZC5vpj9rd+VSXJJEF19ZbGF1QsFSMuxjKTb9jAy7Dk6U/9/xK9Q
+mH6QHhKzNKb8GsiowZJq3bF2mEYqmh/BPyQ06gfDLM4yvlTb+k4R6brFzm7tkWG
49hREmHK9w/wZXnH0lMCqMHRY/YqQF5bR3ujq7pB0WHLvbvDoSvyWvGQ9cVrRA24
ASb47sR77R1LlZntoSyy
=b7HG
-----END PGP SIGNATURE-----
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0xEAD9E623.asc
Type: application/pgp-keys
Size: 18399 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150427/4683ab4b/attachment.bin>

From pete at petertodd.org  Mon Apr 27 19:21:12 2015
From: pete at petertodd.org (Peter Todd)
Date: Mon, 27 Apr 2015 15:21:12 -0400
Subject: [Bitcoin-development] 75%/95% threshold for transaction versions
In-Reply-To: <CABHVRKTMg3sih8i3ta0v=jZU+fBzBR-i5b_b7C+drV4CAfGQJg@mail.gmail.com>
References: <552EF785.7000207@sky-ip.org>
	<CAPg+sBgAhdgPPjmT5i0PMYhQo=Hk6Weo8tpX_Wyn-NJ5Ye9D_A@mail.gmail.com>
	<552FDF73.6010104@sky-ip.org>
	<CABjHNoTeMiLWkDBUqdV4HJ=nAhj8wqOjD4cypY9Dv2y9HJWJMg@mail.gmail.com>
	<CABHVRKTMg3sih8i3ta0v=jZU+fBzBR-i5b_b7C+drV4CAfGQJg@mail.gmail.com>
Message-ID: <20150427191855.GE5223@muck>

On Sat, Apr 25, 2015 at 10:32:36AM -0400, Stephen Morse wrote:
> Hi William,
> 
> I personally prefer this solution, since it nails the problem
> > completely with one simple and obvious change. The BIP 62 approach is
> > more like a game of wac-a-mole.
> >
> 
> The two are complementary, not competing. BIP62 prevents *non-signers* from
> mutating the transactions, which is very important.

I strongly disagree.

There are exactly two cases where mutation matters to normal wallets:

1) Spending unconfirmed change. This can be more efficiently done by
   double-spending the first tx with a second that pays both recipients.

2) Large reorganizations. Making mutation impossible makes it more
   likely that after a large reorg all previously confirmed transactions
   will make it back to the blockchain succesfully.

Meanwhile, the "whack-a-mole" aspect of BIP62 is worrying - it's very
likely we'll miss a case. Even right now there are edge cases without
good solutions, like how in a multisig environment any of the key
holders can mutate transactions. Building wallets that make strong
assumptions about malleability and fail if those assumptions turn out to
be wrong is poor engineering.

> The 'Build your own
> nHashType' proposal enables chained transactions even in the face of
> *signers* mutating the transaction. I believe that integrating both will
> lead to the best defense against transaction malleability, and will enable
> more complicated uses of chained transactions (such as micropayment
> channels).

While I think there are better ways to do 'Build your own nHashType'
than what was recently proposed, I strongly agree that for protocols
that really, truly, need malleability resistance it's far better to use
a purpose-built signature hashing algorithm.

-- 
'peter'[:-1]@petertodd.org
00000000000000000e7980aab9c096c46e7f34c43a661c5cb2ea71525ebb8af7
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150427/4375115d/attachment.sig>

From pete at petertodd.org  Mon Apr 27 19:35:26 2015
From: pete at petertodd.org (Peter Todd)
Date: Mon, 27 Apr 2015 15:35:26 -0400
Subject: [Bitcoin-development] Relative CHECKLOCKTIMEVERIFY (was CLTV
 proposal)
In-Reply-To: <CABm2gDovFzpL_7KFqPXxhu4VohRfcE5S_PLAUgjgo_b84GaYeQ@mail.gmail.com>
References: <20141001130826.GM28710@savin.petertodd.org>
	<55075795.20904@bluematt.me>
	<20150421075912.GA25282@savin.petertodd.org>
	<CABm2gDo22grffq4j+Jy_HBD-VrROh32Dbseoa=g-5HXA9Uud1w@mail.gmail.com>
	<CABm2gDovFzpL_7KFqPXxhu4VohRfcE5S_PLAUgjgo_b84GaYeQ@mail.gmail.com>
Message-ID: <20150427193526.GH5223@muck>

On Sun, Apr 26, 2015 at 02:20:04PM +0200, Jorge Tim?n wrote:
> On Sun, Apr 26, 2015 at 1:35 PM, Jorge Tim?n <jtimon at jtimon.cc> wrote:
> > And a new softfork rule could enforce that all new CTxIn set nHeight
> > to the correct height in which its corresponding prevout got into the
> > chain.
> > That would remove the need for the TxOutputGetter param in
> > bitcoinconsensus_verify_script, but unfortunately it is not reorg safe
> > (apart from other ugly implementation details).
> 
> Wait, wait, this can be made reorg-safe and more backards compatible.
> The new validation rule at the tx validation level (currently in
> main::CheckInputs()) would be

<snip>

So, seems to me that RCLTV opens up a whole rats nest of design
decisions and compromises that CLTV doesn't. Yet CLTV itself is a big
step forward, it's been implemented on Viacoin for the past few months
with no issues found, and has an extremely simple and easy to audit
implementation.

I think I'm going to argue we implement it as-is in a soft-fork. Pieter
Wuille's been working on a new way to handle soft-fork upgrades in the
block nVersion field, so this would be a good opportunity to add
something simple and well tested, and also make sure the new nVersion
soft-fork mechanism works. Equally, doing both at the same time ensures
we don't burn yet another version bit.

-- 
'peter'[:-1]@petertodd.org
00000000000000000e7980aab9c096c46e7f34c43a661c5cb2ea71525ebb8af7
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150427/1dcaa3c3/attachment.sig>

From jtimon at jtimon.cc  Tue Apr 28 07:23:53 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Tue, 28 Apr 2015 09:23:53 +0200
Subject: [Bitcoin-development] Proof of Payment
In-Reply-To: <CAPswA9w=DMDokS8BrDPTtWa_qpdORbK+V4aNS4DoAKE_F1iVoA@mail.gmail.com>
References: <CAPswA9zzVDxW8_WXg5833r2Z4pxZOppYtNLHMQ=Nw-H72cMz7w@mail.gmail.com>
	<A2849710-1069-45A1-89C0-9D8E40C4A8D6@newcastle.ac.uk>
	<CAPswA9wNS2J=4YhpqWN8SmzJuUF8mek8XLUYTE+twLX9vM4Jhg@mail.gmail.com>
	<CAPswA9wZk_8EjbN8J-VbMGQ6nrZ7SthopJ=HYMtpxhSCsm_neA@mail.gmail.com>
	<553D87CE.5000005@thinlink.com>
	<CAPswA9xUfr1D6New3hm+1Z1OqSfkAZ8L+VnbFZayG+uJecgaeA@mail.gmail.com>
	<CAPswA9w=DMDokS8BrDPTtWa_qpdORbK+V4aNS4DoAKE_F1iVoA@mail.gmail.com>
Message-ID: <CABm2gDrumXjfo7=YmTSkRO0QPtPtUj4PF9yb1m80L60O-HZe6A@mail.gmail.com>

So at the low level, how does a "proof of payment" differ from just proving
that a given transaction is in a given block (what SPV nodes take as proof
of payment today)?
On Apr 27, 2015 2:42 PM, "Kalle Rosenbaum" <kalle at rosenbaum.se> wrote:

> "Or a really high lock_time, but it would not make it invalid, just
> delayed."
>
> Ok, this was a bad idea, since nodes would have to keep it in memory.
> Please disregard that idea...
>
> Kalle
>
> Den 27 apr 2015 14:35 skrev "Kalle Rosenbaum" <kalle at rosenbaum.se>:
> >
> > >
> > > Some more use cases might be:
> > > Waiting in comfort:
> > >  - Send a payment ahead of time, then wander over and collect the goods
> > > after X confirmations.
> > >
> > > Authorized pickup :
> > >  - Hot wallet software used by related people could facilitate the use
> > > of 1 of N multisig funds.  Any one of the N wallets could collect goods
> > > and services purchased by any of the others.
> >
> > I like this one, because it shows the power of reusing the transaction
> data structure.
> >
> > >
> > > Non-monetary gifts:
> > >  - Sender exports spent keys to a beneficiary, enabling PoP to work as
> a
> > > gift claim
> > >
> > > Contingent services:
> > >  - Without Bob's permission, a 3rd party conditions action on a payment
> > > made from Alice to Bob.  For example, if you donated at least .02 BTC
> to
> > > Dorian, you (or combining scenarios, any of your N authorized family
> > > members), can come to my dinner party.
> >
> > This is an interesting one.
> >
> > >
> > > I tried out your demo wallet and service and it worked as advertised.
> > >
> > > Could the same standard also be used to prove that a transaction COULD
> > > BE created?  To generalize the concept beyond actual payments, you
> could
> > > call it something like proof of payment potential.
> >
> > I guess it's possible, but we'd have to remove the txid from the output,
> since there is none. This is a way of saying "I'm in control of these
> addresses". The other party/parties can then verify the funds on the
> blockchain and watch those addresses for changes. Maybe there are some
> interesting use cases here. Ideas?
> >
> > >
> > > Why not make these proofs permanently INVALID transactions, to remove
> > > any possibility of their being mined and spending everything to fees
> > > when used in this way, and also in cases involving reorganizations?
> >
> > Yes. Initially I thought it would be enough that the funds are already
> spent, but I think you're right here. Reorgs could be a problem. Worse, you
> also might want to prove 0-confirmation transactions, in which case it's a
> huge security problem. Someone might intercept the PoP and publish it on
> the bitcoin network, spending all the funds. But I still would like wallets
> to be able to build/verify PoPs with little or no modifications. Could we
> possibly change the version number on the PoP to something other than 1?
> Maybe 2^4-1? Or a really high lock_time, but it would not make it invalid,
> just delayed. Any suggestions here?
> >
> > >
> > > I agree that PoP seems complementary to BIP70.
> > >
> > >
> >
> > Thank you very much for your comments!
> >
> > /Kalle
>
>
> ------------------------------------------------------------------------------
> One dashboard for servers and applications across Physical-Virtual-Cloud
> Widest out-of-the-box monitoring support with 50+ applications
> Performance metrics, stats and reports that give you Actionable Insights
> Deep dive visibility with transaction tracing using APM Insight.
> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150428/9bf79c5d/attachment.html>

From jtimon at jtimon.cc  Tue Apr 28 07:44:14 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Tue, 28 Apr 2015 09:44:14 +0200
Subject: [Bitcoin-development] Relative CHECKLOCKTIMEVERIFY (was CLTV
	proposal)
In-Reply-To: <20150427193526.GH5223@muck>
References: <20141001130826.GM28710@savin.petertodd.org>
	<55075795.20904@bluematt.me>
	<20150421075912.GA25282@savin.petertodd.org>
	<CABm2gDo22grffq4j+Jy_HBD-VrROh32Dbseoa=g-5HXA9Uud1w@mail.gmail.com>
	<CABm2gDovFzpL_7KFqPXxhu4VohRfcE5S_PLAUgjgo_b84GaYeQ@mail.gmail.com>
	<20150427193526.GH5223@muck>
Message-ID: <CABm2gDqTz9hDK0auje7OodKS935XFjcR818WsTb6FKDz=qO_SA@mail.gmail.com>

Even if it's new and has not received any feedback, I think my solution to
op_maturity is quite clean.
But anyway, yes, the non-relative cltv is much simpler in design and
doesn't have to wait for the other. On the other hand, I would upgrade it
to absolute cltv like you suggested and take the current height as a
parameter to verifyScript instead of using the nLockTime as reference.
If we know we're going to use it for rcltv/op_maturity, better put add soon
rather than later, specially if that will give us a more powerful cltv.
If we don't want that height param, we can leave it out of for op_maturity
too, but that's the wingle decision about rcltv/maturity that affects cltv
so better solve that first.
On Apr 27, 2015 9:35 PM, "Peter Todd" <pete at petertodd.org> wrote:

> On Sun, Apr 26, 2015 at 02:20:04PM +0200, Jorge Tim?n wrote:
> > On Sun, Apr 26, 2015 at 1:35 PM, Jorge Tim?n <jtimon at jtimon.cc> wrote:
> > > And a new softfork rule could enforce that all new CTxIn set nHeight
> > > to the correct height in which its corresponding prevout got into the
> > > chain.
> > > That would remove the need for the TxOutputGetter param in
> > > bitcoinconsensus_verify_script, but unfortunately it is not reorg safe
> > > (apart from other ugly implementation details).
> >
> > Wait, wait, this can be made reorg-safe and more backards compatible.
> > The new validation rule at the tx validation level (currently in
> > main::CheckInputs()) would be
>
> <snip>
>
> So, seems to me that RCLTV opens up a whole rats nest of design
> decisions and compromises that CLTV doesn't. Yet CLTV itself is a big
> step forward, it's been implemented on Viacoin for the past few months
> with no issues found, and has an extremely simple and easy to audit
> implementation.
>
> I think I'm going to argue we implement it as-is in a soft-fork. Pieter
> Wuille's been working on a new way to handle soft-fork upgrades in the
> block nVersion field, so this would be a good opportunity to add
> something simple and well tested, and also make sure the new nVersion
> soft-fork mechanism works. Equally, doing both at the same time ensures
> we don't burn yet another version bit.
>
> --
> 'peter'[:-1]@petertodd.org
> 00000000000000000e7980aab9c096c46e7f34c43a661c5cb2ea71525ebb8af7
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150428/ff9127d7/attachment.html>

From laanwj at gmail.com  Tue Apr 28 07:44:16 2015
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Tue, 28 Apr 2015 09:44:16 +0200
Subject: [Bitcoin-development] Bitcoin core 0.11 planning
Message-ID: <20150428074414.GA19918@amethyst.visucore.com>

Hello all,

The release window for 0.11 is nearing, I'd propose the following schedule:

2015-05-01  Soft translation string freeze
            Open Transifex translations for 0.11
            Finalize and close translation for 0.9

2015-05-15  Feature freeze, string freeze

2015-06-01  Split off 0.11 branch
            Tag and release 0.11.0rc1
            Start merging for 0.12 on master branch 

2015-07-01  Release 0.11.0 final (aim)

In contrast to former releases, which were protracted for months, let's try to be more strict about the dates. Of course it is always possible for last-minute critical issues to interfere with the planning. The release will not be held up for features, though, and anything that will not make it to 0.11 will be postponed to next release scheduled for end of the year.

Wladimir



From oleganza at gmail.com  Tue Apr 28 10:17:27 2015
From: oleganza at gmail.com (Oleg Andreev)
Date: Tue, 28 Apr 2015 12:17:27 +0200
Subject: [Bitcoin-development] 75%/95% threshold for transaction versions
In-Reply-To: <20150427191855.GE5223@muck>
References: <552EF785.7000207@sky-ip.org>
	<CAPg+sBgAhdgPPjmT5i0PMYhQo=Hk6Weo8tpX_Wyn-NJ5Ye9D_A@mail.gmail.com>
	<552FDF73.6010104@sky-ip.org>
	<CABjHNoTeMiLWkDBUqdV4HJ=nAhj8wqOjD4cypY9Dv2y9HJWJMg@mail.gmail.com>
	<CABHVRKTMg3sih8i3ta0v=jZU+fBzBR-i5b_b7C+drV4CAfGQJg@mail.gmail.com>
	<20150427191855.GE5223@muck>
Message-ID: <3B4C8493-CD37-4D43-ABF1-0AA5388CD78E@gmail.com>



> On 27 Apr 2015, at 21:21, Peter Todd <pete at petertodd.org> wrote:
> 
> Even right now there are edge cases without
> good solutions, like how in a multisig environment any of the key
> holders can mutate transactions.

Can't we add requirement for RFC6979 signatures to mitigate this? Of course, multiple signers can still mutate transaction by choosing a different set (but not the order, thankfully) of signatures. Or when a single signer has multiple participating keys.

In some interesting to me scenarios mutation by signer is not critical: it is mutation by non-signers that creates a problem. Do you know of any edge cases when non-signers can mutate transactions which are not covered by BIP62? What would be a more robust approach than "whack-a-mole" to work around mutability? (Normalized tx ids?)


From pete at petertodd.org  Tue Apr 28 10:49:41 2015
From: pete at petertodd.org (Peter Todd)
Date: Tue, 28 Apr 2015 10:49:41 +0000
Subject: [Bitcoin-development] Bitcoin core 0.11 planning
In-Reply-To: <20150428074414.GA19918@amethyst.visucore.com>
References: <20150428074414.GA19918@amethyst.visucore.com>
Message-ID: <4E63339A-69B1-4885-9D7F-6D14E75CE174@petertodd.org>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

I'll point out that at this rate the soonest we'll see CHECKLOCKTIMEVERIFY implemented on Bitcoin will be something like summer 2016, a year and a half after it got adopted on Viacoin. (and a few other alts whose names I forget)

Right now the shortest path to adoption would be to release a v0.12 with just a CLTV soft-fork as soon as the BIP66 softfork triggers. While there's been proposal to change the way the upgrade mechanism triggers to a multiple parallel fork scheme, that is quite complex, stateful, and will need lots of review, probably a few months worth; faster would be to continue with the existing mechanism.

IMO the main reason to accelerate CLTV is scalability. The only viable scalability improvements possible in the short/medium term that don't entirely rely on trusting third parties are payment channel based. While we have a working payment channel scheme - Jeremy Spilman's refund tx based system - it is fairly complex, needs good and immediate backups, and is susceptible to tx malleability. CLTV fixes those issues robustly. Of course, payment channel schemes can start off with Spilman's scheme first and go to CLTV later, but that is a lot of extra code to be written and later depreciated - I'm sure many authors are dubious about going down that path.

Thoughts?


On 28 April 2015 03:44:16 GMT-04:00, "Wladimir J. van der Laan" <laanwj at gmail.com> wrote:
>Hello all,
>
>The release window for 0.11 is nearing, I'd propose the following
>schedule:
>
>2015-05-01  Soft translation string freeze
>            Open Transifex translations for 0.11
>            Finalize and close translation for 0.9
>
>2015-05-15  Feature freeze, string freeze
>
>2015-06-01  Split off 0.11 branch
>            Tag and release 0.11.0rc1
>            Start merging for 0.12 on master branch
>
>2015-07-01  Release 0.11.0 final (aim)
>
>In contrast to former releases, which were protracted for months, let's
>try to be more strict about the dates. Of course it is always possible
>for last-minute critical issues to interfere with the planning. The
>release will not be held up for features, though, and anything that
>will not make it to 0.11 will be postponed to next release scheduled
>for end of the year.
>
>Wladimir
-----BEGIN PGP SIGNATURE-----

iQE9BAEBCAAnIBxQZXRlciBUb2RkIDxwZXRlQHBldGVydG9kZC5vcmc+BQJVP2Wy
AAoJEMCF8hzn9LncqOcH/3rDFbgWprqTfk8dKWAItRcY6ZyiQ+dNrqNgymaNP5Ig
MNKaTmWYyZRH6PW13JOv72ArXia+D82Mp5reTaLIb3TV5uef2biruOCaH9eI8Uv5
i2PCBLw3uqZIZZ5Qr/7nlp2CaBQIGDK3fg3jx10UyWpg4BxkKP2mLJibMG8l3JcK
Moi/kh6lvwySpT8NYtZfXax+5AQ2oLXiSzbFF8P0ioI9fJYaoVCAyS5VEE4KsZnV
thOaoPAWoK+spEYKFrjvyXnQXFe6m+KPfRPU3WKYSFhI7m8MW6bKxEnD0Lffo6qU
YS6jsE3A0LoKs4kD73ivHcMeXDhO6LXyPAu8zQtgGr8=
=Z/GT
-----END PGP SIGNATURE-----




From pieter.wuille at gmail.com  Tue Apr 28 11:01:00 2015
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Tue, 28 Apr 2015 04:01:00 -0700
Subject: [Bitcoin-development] Bitcoin core 0.11 planning
In-Reply-To: <4E63339A-69B1-4885-9D7F-6D14E75CE174@petertodd.org>
References: <20150428074414.GA19918@amethyst.visucore.com>
	<4E63339A-69B1-4885-9D7F-6D14E75CE174@petertodd.org>
Message-ID: <CAPg+sBjc4iguJ8KCnUf9LrLbPkWEMc5fvr7XZsA48XQKaecN5g@mail.gmail.com>

As softforks almost certainly require backports to older releases and other
software anyway, I don't think they should necessarily be bound to Bitcoin
Core major releases. If they don't require large code changes, we can
easily do them in minor releases too.
On Apr 28, 2015 12:51 PM, "Peter Todd" <pete at petertodd.org> wrote:

> -----BEGIN PGP SIGNED MESSAGE-----
> Hash: SHA256
>
> I'll point out that at this rate the soonest we'll see CHECKLOCKTIMEVERIFY
> implemented on Bitcoin will be something like summer 2016, a year and a
> half after it got adopted on Viacoin. (and a few other alts whose names I
> forget)
>
> Right now the shortest path to adoption would be to release a v0.12 with
> just a CLTV soft-fork as soon as the BIP66 softfork triggers. While there's
> been proposal to change the way the upgrade mechanism triggers to a
> multiple parallel fork scheme, that is quite complex, stateful, and will
> need lots of review, probably a few months worth; faster would be to
> continue with the existing mechanism.
>
> IMO the main reason to accelerate CLTV is scalability. The only viable
> scalability improvements possible in the short/medium term that don't
> entirely rely on trusting third parties are payment channel based. While we
> have a working payment channel scheme - Jeremy Spilman's refund tx based
> system - it is fairly complex, needs good and immediate backups, and is
> susceptible to tx malleability. CLTV fixes those issues robustly. Of
> course, payment channel schemes can start off with Spilman's scheme first
> and go to CLTV later, but that is a lot of extra code to be written and
> later depreciated - I'm sure many authors are dubious about going down that
> path.
>
> Thoughts?
>
>
> On 28 April 2015 03:44:16 GMT-04:00, "Wladimir J. van der Laan" <
> laanwj at gmail.com> wrote:
> >Hello all,
> >
> >The release window for 0.11 is nearing, I'd propose the following
> >schedule:
> >
> >2015-05-01  Soft translation string freeze
> >            Open Transifex translations for 0.11
> >            Finalize and close translation for 0.9
> >
> >2015-05-15  Feature freeze, string freeze
> >
> >2015-06-01  Split off 0.11 branch
> >            Tag and release 0.11.0rc1
> >            Start merging for 0.12 on master branch
> >
> >2015-07-01  Release 0.11.0 final (aim)
> >
> >In contrast to former releases, which were protracted for months, let's
> >try to be more strict about the dates. Of course it is always possible
> >for last-minute critical issues to interfere with the planning. The
> >release will not be held up for features, though, and anything that
> >will not make it to 0.11 will be postponed to next release scheduled
> >for end of the year.
> >
> >Wladimir
> -----BEGIN PGP SIGNATURE-----
>
> iQE9BAEBCAAnIBxQZXRlciBUb2RkIDxwZXRlQHBldGVydG9kZC5vcmc+BQJVP2Wy
> AAoJEMCF8hzn9LncqOcH/3rDFbgWprqTfk8dKWAItRcY6ZyiQ+dNrqNgymaNP5Ig
> MNKaTmWYyZRH6PW13JOv72ArXia+D82Mp5reTaLIb3TV5uef2biruOCaH9eI8Uv5
> i2PCBLw3uqZIZZ5Qr/7nlp2CaBQIGDK3fg3jx10UyWpg4BxkKP2mLJibMG8l3JcK
> Moi/kh6lvwySpT8NYtZfXax+5AQ2oLXiSzbFF8P0ioI9fJYaoVCAyS5VEE4KsZnV
> thOaoPAWoK+spEYKFrjvyXnQXFe6m+KPfRPU3WKYSFhI7m8MW6bKxEnD0Lffo6qU
> YS6jsE3A0LoKs4kD73ivHcMeXDhO6LXyPAu8zQtgGr8=
> =Z/GT
> -----END PGP SIGNATURE-----
>
>
>
> ------------------------------------------------------------------------------
> One dashboard for servers and applications across Physical-Virtual-Cloud
> Widest out-of-the-box monitoring support with 50+ applications
> Performance metrics, stats and reports that give you Actionable Insights
> Deep dive visibility with transaction tracing using APM Insight.
> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150428/1f3dd52d/attachment.html>

From kalle at rosenbaum.se  Tue Apr 28 12:41:40 2015
From: kalle at rosenbaum.se (Kalle Rosenbaum)
Date: Tue, 28 Apr 2015 14:41:40 +0200
Subject: [Bitcoin-development] Proof of Payment
In-Reply-To: <CABm2gDrumXjfo7=YmTSkRO0QPtPtUj4PF9yb1m80L60O-HZe6A@mail.gmail.com>
References: <CAPswA9zzVDxW8_WXg5833r2Z4pxZOppYtNLHMQ=Nw-H72cMz7w@mail.gmail.com>
	<A2849710-1069-45A1-89C0-9D8E40C4A8D6@newcastle.ac.uk>
	<CAPswA9wNS2J=4YhpqWN8SmzJuUF8mek8XLUYTE+twLX9vM4Jhg@mail.gmail.com>
	<CAPswA9wZk_8EjbN8J-VbMGQ6nrZ7SthopJ=HYMtpxhSCsm_neA@mail.gmail.com>
	<553D87CE.5000005@thinlink.com>
	<CAPswA9xUfr1D6New3hm+1Z1OqSfkAZ8L+VnbFZayG+uJecgaeA@mail.gmail.com>
	<CAPswA9w=DMDokS8BrDPTtWa_qpdORbK+V4aNS4DoAKE_F1iVoA@mail.gmail.com>
	<CABm2gDrumXjfo7=YmTSkRO0QPtPtUj4PF9yb1m80L60O-HZe6A@mail.gmail.com>
Message-ID: <CAPswA9z9K2w-uEHMOrAvAENs5L1iS8PYu2xMOFidDUJvU04O5w@mail.gmail.com>

Hi Jorge,

I don't think I understand the question. Proof of Payment is used to prove
that you have the credentials needed for a certain transaction. It does not
care where in the blockchain the transaction is. Or if it's in the
blockchain at all.

/Kalle

So at the low level, how does a "proof of payment" differ from just proving
that a given transaction is in a given block (what SPV nodes take as proof
of payment today)?
On Apr 27, 2015 2:42 PM, "Kalle Rosenbaum" <kalle at rosenbaum.se> wrote:

> "Or a really high lock_time, but it would not make it invalid, just
> delayed."
>
> Ok, this was a bad idea, since nodes would have to keep it in memory.
> Please disregard that idea...
>
> Kalle
>
> Den 27 apr 2015 14:35 skrev "Kalle Rosenbaum" <kalle at rosenbaum.se>:
> >
> > >
> > > Some more use cases might be:
> > > Waiting in comfort:
> > >  - Send a payment ahead of time, then wander over and collect the goods
> > > after X confirmations.
> > >
> > > Authorized pickup :
> > >  - Hot wallet software used by related people could facilitate the use
> > > of 1 of N multisig funds.  Any one of the N wallets could collect goods
> > > and services purchased by any of the others.
> >
> > I like this one, because it shows the power of reusing the transaction
> data structure.
> >
> > >
> > > Non-monetary gifts:
> > >  - Sender exports spent keys to a beneficiary, enabling PoP to work as
> a
> > > gift claim
> > >
> > > Contingent services:
> > >  - Without Bob's permission, a 3rd party conditions action on a payment
> > > made from Alice to Bob.  For example, if you donated at least .02 BTC
> to
> > > Dorian, you (or combining scenarios, any of your N authorized family
> > > members), can come to my dinner party.
> >
> > This is an interesting one.
> >
> > >
> > > I tried out your demo wallet and service and it worked as advertised.
> > >
> > > Could the same standard also be used to prove that a transaction COULD
> > > BE created?  To generalize the concept beyond actual payments, you
> could
> > > call it something like proof of payment potential.
> >
> > I guess it's possible, but we'd have to remove the txid from the output,
> since there is none. This is a way of saying "I'm in control of these
> addresses". The other party/parties can then verify the funds on the
> blockchain and watch those addresses for changes. Maybe there are some
> interesting use cases here. Ideas?
> >
> > >
> > > Why not make these proofs permanently INVALID transactions, to remove
> > > any possibility of their being mined and spending everything to fees
> > > when used in this way, and also in cases involving reorganizations?
> >
> > Yes. Initially I thought it would be enough that the funds are already
> spent, but I think you're right here. Reorgs could be a problem. Worse, you
> also might want to prove 0-confirmation transactions, in which case it's a
> huge security problem. Someone might intercept the PoP and publish it on
> the bitcoin network, spending all the funds. But I still would like wallets
> to be able to build/verify PoPs with little or no modifications. Could we
> possibly change the version number on the PoP to something other than 1?
> Maybe 2^4-1? Or a really high lock_time, but it would not make it invalid,
> just delayed. Any suggestions here?
> >
> > >
> > > I agree that PoP seems complementary to BIP70.
> > >
> > >
> >
> > Thank you very much for your comments!
> >
> > /Kalle
>
>
> ------------------------------------------------------------------------------
> One dashboard for servers and applications across Physical-Virtual-Cloud
> Widest out-of-the-box monitoring support with 50+ applications
> Performance metrics, stats and reports that give you Actionable Insights
> Deep dive visibility with transaction tracing using APM Insight.
> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150428/01883ab9/attachment.html>

From jtimon at jtimon.cc  Tue Apr 28 12:53:58 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Tue, 28 Apr 2015 14:53:58 +0200
Subject: [Bitcoin-development] Proof of Payment
In-Reply-To: <CAPswA9z9K2w-uEHMOrAvAENs5L1iS8PYu2xMOFidDUJvU04O5w@mail.gmail.com>
References: <CAPswA9zzVDxW8_WXg5833r2Z4pxZOppYtNLHMQ=Nw-H72cMz7w@mail.gmail.com>
	<A2849710-1069-45A1-89C0-9D8E40C4A8D6@newcastle.ac.uk>
	<CAPswA9wNS2J=4YhpqWN8SmzJuUF8mek8XLUYTE+twLX9vM4Jhg@mail.gmail.com>
	<CAPswA9wZk_8EjbN8J-VbMGQ6nrZ7SthopJ=HYMtpxhSCsm_neA@mail.gmail.com>
	<553D87CE.5000005@thinlink.com>
	<CAPswA9xUfr1D6New3hm+1Z1OqSfkAZ8L+VnbFZayG+uJecgaeA@mail.gmail.com>
	<CAPswA9w=DMDokS8BrDPTtWa_qpdORbK+V4aNS4DoAKE_F1iVoA@mail.gmail.com>
	<CABm2gDrumXjfo7=YmTSkRO0QPtPtUj4PF9yb1m80L60O-HZe6A@mail.gmail.com>
	<CAPswA9z9K2w-uEHMOrAvAENs5L1iS8PYu2xMOFidDUJvU04O5w@mail.gmail.com>
Message-ID: <CABm2gDpsv8mp3hjMfT_okaMQmW4AmCiFAz43dBR1M-rzntqfSg@mail.gmail.com>

Forget it, sorry, I misunderstood the proposal entirely, re-reading
with more care...

On Tue, Apr 28, 2015 at 2:41 PM, Kalle Rosenbaum <kalle at rosenbaum.se> wrote:
> Hi Jorge,
>
> I don't think I understand the question. Proof of Payment is used to prove
> that you have the credentials needed for a certain transaction. It does not
> care where in the blockchain the transaction is. Or if it's in the
> blockchain at all.
>
> /Kalle
>
> So at the low level, how does a "proof of payment" differ from just proving
> that a given transaction is in a given block (what SPV nodes take as proof
> of payment today)?
>
> On Apr 27, 2015 2:42 PM, "Kalle Rosenbaum" <kalle at rosenbaum.se> wrote:
>>
>> "Or a really high lock_time, but it would not make it invalid, just
>> delayed."
>>
>> Ok, this was a bad idea, since nodes would have to keep it in memory.
>> Please disregard that idea...
>>
>> Kalle
>>
>> Den 27 apr 2015 14:35 skrev "Kalle Rosenbaum" <kalle at rosenbaum.se>:
>> >
>> > >
>> > > Some more use cases might be:
>> > > Waiting in comfort:
>> > >  - Send a payment ahead of time, then wander over and collect the
>> > > goods
>> > > after X confirmations.
>> > >
>> > > Authorized pickup :
>> > >  - Hot wallet software used by related people could facilitate the use
>> > > of 1 of N multisig funds.  Any one of the N wallets could collect
>> > > goods
>> > > and services purchased by any of the others.
>> >
>> > I like this one, because it shows the power of reusing the transaction
>> > data structure.
>> >
>> > >
>> > > Non-monetary gifts:
>> > >  - Sender exports spent keys to a beneficiary, enabling PoP to work as
>> > > a
>> > > gift claim
>> > >
>> > > Contingent services:
>> > >  - Without Bob's permission, a 3rd party conditions action on a
>> > > payment
>> > > made from Alice to Bob.  For example, if you donated at least .02 BTC
>> > > to
>> > > Dorian, you (or combining scenarios, any of your N authorized family
>> > > members), can come to my dinner party.
>> >
>> > This is an interesting one.
>> >
>> > >
>> > > I tried out your demo wallet and service and it worked as advertised.
>> > >
>> > > Could the same standard also be used to prove that a transaction COULD
>> > > BE created?  To generalize the concept beyond actual payments, you
>> > > could
>> > > call it something like proof of payment potential.
>> >
>> > I guess it's possible, but we'd have to remove the txid from the output,
>> > since there is none. This is a way of saying "I'm in control of these
>> > addresses". The other party/parties can then verify the funds on the
>> > blockchain and watch those addresses for changes. Maybe there are some
>> > interesting use cases here. Ideas?
>> >
>> > >
>> > > Why not make these proofs permanently INVALID transactions, to remove
>> > > any possibility of their being mined and spending everything to fees
>> > > when used in this way, and also in cases involving reorganizations?
>> >
>> > Yes. Initially I thought it would be enough that the funds are already
>> > spent, but I think you're right here. Reorgs could be a problem. Worse, you
>> > also might want to prove 0-confirmation transactions, in which case it's a
>> > huge security problem. Someone might intercept the PoP and publish it on the
>> > bitcoin network, spending all the funds. But I still would like wallets to
>> > be able to build/verify PoPs with little or no modifications. Could we
>> > possibly change the version number on the PoP to something other than 1?
>> > Maybe 2^4-1? Or a really high lock_time, but it would not make it invalid,
>> > just delayed. Any suggestions here?
>> >
>> > >
>> > > I agree that PoP seems complementary to BIP70.
>> > >
>> > >
>> >
>> > Thank you very much for your comments!
>> >
>> > /Kalle
>>
>>
>>
>> ------------------------------------------------------------------------------
>> One dashboard for servers and applications across Physical-Virtual-Cloud
>> Widest out-of-the-box monitoring support with 50+ applications
>> Performance metrics, stats and reports that give you Actionable Insights
>> Deep dive visibility with transaction tracing using APM Insight.
>> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>



From pete at petertodd.org  Tue Apr 28 13:42:38 2015
From: pete at petertodd.org (Peter Todd)
Date: Tue, 28 Apr 2015 09:42:38 -0400
Subject: [Bitcoin-development] Bitcoin core 0.11 planning
In-Reply-To: <CAPg+sBjc4iguJ8KCnUf9LrLbPkWEMc5fvr7XZsA48XQKaecN5g@mail.gmail.com>
References: <20150428074414.GA19918@amethyst.visucore.com>
	<4E63339A-69B1-4885-9D7F-6D14E75CE174@petertodd.org>
	<CAPg+sBjc4iguJ8KCnUf9LrLbPkWEMc5fvr7XZsA48XQKaecN5g@mail.gmail.com>
Message-ID: <20150428134238.GA11026@muck>

On Tue, Apr 28, 2015 at 04:01:00AM -0700, Pieter Wuille wrote:
> As softforks almost certainly require backports to older releases and other
> software anyway, I don't think they should necessarily be bound to Bitcoin
> Core major releases. If they don't require large code changes, we can
> easily do them in minor releases too.

The code changes for absolute CLTV are quite small, and easily ported to
any Bitcoin Core version.

What's the oldest version you think we need backports for?

-- 
'peter'[:-1]@petertodd.org
00000000000000000e7980aab9c096c46e7f34c43a661c5cb2ea71525ebb8af7
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150428/f5b63150/attachment.sig>

From justusranvier at riseup.net  Tue Apr 28 13:53:07 2015
From: justusranvier at riseup.net (Justus Ranvier)
Date: Tue, 28 Apr 2015 13:53:07 +0000
Subject: [Bitcoin-development] Reusable payment codes
In-Reply-To: <553E6BAC.8080307@monetas.net>
References: <CAFjbNjFqj8OQS7PVd_yP7PCj68_jto=r-mT9gKXHsFRviBDt-A@mail.gmail.com>	<CANEZrP0vXfKpmexNXuYUNoj4fqYiNM2GM=_pEiOdbL-G_73+HQ@mail.gmail.com>
	<553E6BAC.8080307@monetas.net>
Message-ID: <553F90C3.7080704@localhost.local>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

The notification transactions are a pain point when it comes to
privacy, and yet they must exist in order to to ensure that nobody can
lose their money as long as they back up their wallet seed.

They could be treated as a backup, however, that clients would not
normally rely upon
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2

iQIcBAEBAgAGBQJVP5DDAAoJECpf2nDq2eYjdLsQAJ/nZKFavcJnCMUQ8hKp6dRq
2+7bAVIWYHuOV6sv/hvG2NaP3u24NYZ/Ji0oD3UAmkJxw9lsZuowwBBs+YAs6JAW
KHTl3QtwBh0IP/V90JOZ5Yn72YWXDsNbqy7R3JhEDKOu2wVeiLqWZ2EDgGwiZ0/k
aXFJbcVZEKttWYCNoZi0yRMH+S9gbi0LgOwvK9mRzF9IRz07SM1iKQeKPsW1X1UM
KNeikFROMS7dHTO5HRGyFcTSwhUf8RJq2kea+4sJtj8Vlb5rURuJanL3Fav+ZZjr
RWYubLp9EUrDMm9bciygL8+MKPas8hedHSW2JhjkshWYC/NoCXLBT6SGrrbj2SKL
zGGeLYknjwgLTCstKSQlXW3J/xcSFwBztr//o95SwRoIKI7jpuOE6cPfUZVEuTsU
Zm7IWuRw/1MMDF89gCtDkBJcX2mTARjiii1Hg0+7vCv6Q/fVgTNUvWEKeNtCNZjh
wOiwd4eP1gY4CwX68c+8CfF+NOSXImJTspZJvDQcTge1/bQJNOBn+cMYxjBcJsqL
ZUOvkWJqwiFERW7vjMhOVpqIyO38UluwsWgp7nlMl/npfv0ZDIrOqZrswHSTqfdc
P8gSaqvpc6cMaLL/ijvOtORkVB9ZlLmlTv6mIYWHeKEf6PjIOZEb2B75zPHFAvrz
TKLxjvWgvSJ4l5PrkCFA
=1Id2
-----END PGP SIGNATURE-----
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0xEAD9E623.asc
Type: application/pgp-keys
Size: 18399 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150428/c1551c94/attachment.bin>

From bbrelin at gmail.com  Wed Apr 29 17:12:08 2015
From: bbrelin at gmail.com (Braun Brelin)
Date: Wed, 29 Apr 2015 20:12:08 +0300
Subject: [Bitcoin-development] Looking for a good bitcoin script decompiler
	in Python
Message-ID: <CAJ2OvpgLaD3HKqQ_wqbmv6+7ZXWtXMFeHkwKUVOX4ahCZSU8Kg@mail.gmail.com>

Hi all,

I'm trying to find a good python script that will take the hash of the
locking and
unlocking tx scripts and output the actual op codes.

Any ideas where to look?

Thanks,
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150429/d96e280f/attachment.html>

From me at ricmoo.com  Wed Apr 29 22:16:36 2015
From: me at ricmoo.com (Richard Moore)
Date: Wed, 29 Apr 2015 18:16:36 -0400
Subject: [Bitcoin-development] Looking for a good bitcoin script
	decompiler in Python
In-Reply-To: <CAJ2OvpgLaD3HKqQ_wqbmv6+7ZXWtXMFeHkwKUVOX4ahCZSU8Kg@mail.gmail.com>
References: <CAJ2OvpgLaD3HKqQ_wqbmv6+7ZXWtXMFeHkwKUVOX4ahCZSU8Kg@mail.gmail.com>
Message-ID: <09C6C0EA-FE0B-43B4-9114-6482F9CF45BA@ricmoo.com>

I have a library, pycoind (https://github.com/ricmoo/pycoind <https://github.com/ricmoo/pycoind>) you might find useful.


>>> import pycoind

>>> str(pycoind.script.Tokenizer('76a9143f320f852a51643d3ffbaa1f49bfe521dd97764a88ac'.decode('hex')))
'OP_DUP OP_HASH160 3f320f852a51643d3ffbaa1f49bfe521dd97764a OP_EQUALVERIFY OP_CHECKSIG'




> On Apr 29, 2015, at 1:12 PM, Braun Brelin <bbrelin at gmail.com> wrote:
> 
> Hi all, 
> 
> I'm trying to find a good python script that will take the hash of the locking and 
> unlocking tx scripts and output the actual op codes.  
> 
> Any ideas where to look?  
> 
> Thanks,
> 
> 
> ------------------------------------------------------------------------------
> One dashboard for servers and applications across Physical-Virtual-Cloud 
> Widest out-of-the-box monitoring support with 50+ applications
> Performance metrics, stats and reports that give you Actionable Insights
> Deep dive visibility with transaction tracing using APM Insight.
> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y_______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development

.???`?.??.???`?.??.???`?.??.???`?.??.???`?.?><(((?>

Richard Moore ~ Founder
Genetic Mistakes Software inc.
phone: (778) 882-6125
email: ricmoo at geneticmistakes.com <mailto:ricmoo at geneticmistakes.com>
www: http://GeneticMistakes.com <http://geneticmistakes.com/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150429/72422ca0/attachment.html>

From justusranvier at riseup.net  Wed Apr 29 23:44:15 2015
From: justusranvier at riseup.net (Justus Ranvier)
Date: Wed, 29 Apr 2015 23:44:15 +0000
Subject: [Bitcoin-development] Reusable payment codes
In-Reply-To: <CAFjbNjFqj8OQS7PVd_yP7PCj68_jto=r-mT9gKXHsFRviBDt-A@mail.gmail.com>
References: <CAFjbNjFqj8OQS7PVd_yP7PCj68_jto=r-mT9gKXHsFRviBDt-A@mail.gmail.com>
Message-ID: <55416CCF.5090109@localhost.local>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 04/27/2015 02:53 PM, Brian Deery wrote:

> 1. There will be a 1:1 relationship between a payment code owner
> and their identity.  Presumably the payment code would be strongly
> and publicly tied to the identity.  This makes the notification
> address strongly tied to the user.  An SPV client connecting to a
> full node who has a list of notification address can tie an
> identity to a bloom filter and connecting IP.

I've updated the proposal to provide for alternate methods of
notification that can be used *in addition to* notification transactions.

This frees the sender from constantly monitoring an address known to
be associated with their identity, although they should check it
periodically since not all senders will be capable of using every type
of alternate notification method.

I defined a Bitmessage notification method as an example; more can be
added if required.

https://github.com/justusranvier/rfc/blob/payment_code/bips/bip-pc01.mediawiki
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2

iQIcBAEBAgAGBQJVQWzPAAoJECpf2nDq2eYj8uAP/RsP050K9z8oDGy0KO+zjFwM
iNzlsQaPY8kmR2k2oLXJp1n4QZIQAZly+vxjBZnOWXwAhrBcvnhNBvqdigwZYg3B
oGyvGvArzkve86Ke1WF1hZEAvml3cmQ5jxYKMlwhzRPcHq2kwznw+5jRuTbf1JbE
PxY5pOfnZ9ADVF5FkLR2KwBNvGA83Cle01hKd0eB6Omlb6azKDBXUqfzPPpB4lmp
A8D0P3zkayzBYIiybUExfPJHUthd5wXL/TLwFkysPV7SnJE64C6Q2StD4wUtNQRS
LDOw37RwhMx2Oz2YH3Ywi6w5tqYQP4LEWBuFb+LOqqphpV/FpFDl/Uznos00pz61
V9x2wrfg+MQnYk5/VIjPQxqvRsiu8yg4c2x0v+KIIMsuXKEPRFxaSS3DoaWUa1Jy
+WDobHndIDw1TDqctP8LIiZ7zbWNYKJ4HgUaacHvTiA7TrJXi1KHo2b1pmnTbKhv
fdHbjzd8UiMED6qeyrz1gGhjC2uSTwjZAmbBkCJccOGsrILoV1fifUW+de8qsBMH
6w6RiDwfeY2fHJHBS6O2Nhfk3OE5JaCWvy727ZXEq8lQ6dW0GOZvXg7INaktLagC
tqvg85J5eCm7X8xQ33vgx8q2xt+IriMI2UnTILtb2H8XSiMRQSP7XfWDMfVGu4pb
xbGZKbNS4WS+2FFKM4DK
=6l99
-----END PGP SIGNATURE-----
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0xEAD9E623.asc
Type: application/pgp-keys
Size: 18399 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150429/878dfe29/attachment.bin>

From jgarzik at bitpay.com  Wed Apr 29 23:27:19 2015
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Wed, 29 Apr 2015 19:27:19 -0400
Subject: [Bitcoin-development] Looking for a good bitcoin script
 decompiler in Python
In-Reply-To: <09C6C0EA-FE0B-43B4-9114-6482F9CF45BA@ricmoo.com>
References: <CAJ2OvpgLaD3HKqQ_wqbmv6+7ZXWtXMFeHkwKUVOX4ahCZSU8Kg@mail.gmail.com>
	<09C6C0EA-FE0B-43B4-9114-6482F9CF45BA@ricmoo.com>
Message-ID: <CAJHLa0Pmv_XwNdcwy2JUeCpPHhj5nN-RQHzgYnVXKqUtPWxkZw@mail.gmail.com>

python-bitcoinlib supports script parsing and execution.


On Wed, Apr 29, 2015 at 6:16 PM, Richard Moore <me at ricmoo.com> wrote:

> I have a library, pycoind (https://github.com/ricmoo/pycoind) you might
> find useful.
>
>
> >>> import pycoind
>
> >>>
> str(pycoind.script.Tokenizer('76a9143f320f852a51643d3ffbaa1f49bfe521dd97764a88ac'.decode('hex')))
> 'OP_DUP OP_HASH160 3f320f852a51643d3ffbaa1f49bfe521dd97764a OP_EQUALVERIFY
> OP_CHECKSIG'
>
>
>
>
> On Apr 29, 2015, at 1:12 PM, Braun Brelin <bbrelin at gmail.com> wrote:
>
> Hi all,
>
> I'm trying to find a good python script that will take the hash of the
> locking and
> unlocking tx scripts and output the actual op codes.
>
> Any ideas where to look?
>
> Thanks,
>
>
>
> ------------------------------------------------------------------------------
> One dashboard for servers and applications across Physical-Virtual-Cloud
> Widest out-of-the-box monitoring support with 50+ applications
> Performance metrics, stats and reports that give you Actionable Insights
> Deep dive visibility with transaction tracing using APM Insight.
>
> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y_______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
> .???`?.??.???`?.??.???`?.??.???`?.??.???`?.?><(((?>
>
> Richard Moore ~ Founder
> Genetic Mistakes Software inc.
> phone: (778) 882-6125
> email: ricmoo at geneticmistakes.com
> www: http://GeneticMistakes.com
>
>
>
> ------------------------------------------------------------------------------
> One dashboard for servers and applications across Physical-Virtual-Cloud
> Widest out-of-the-box monitoring support with 50+ applications
> Performance metrics, stats and reports that give you Actionable Insights
> Deep dive visibility with transaction tracing using APM Insight.
> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>


-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150429/b3dc9157/attachment.html>

From jtimon at jtimon.cc  Thu Apr 30 08:08:20 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Thu, 30 Apr 2015 10:08:20 +0200
Subject: [Bitcoin-development] Where do I start?
In-Reply-To: <CANEZrP0vJug1tGNiL5wQUuA0-rr3eM1Yp8DbO3Apiu1CX=j3bQ@mail.gmail.com>
References: <CANJO25K1Lox5aU-NN-j0An2ujNNHwPWNqX1ZXMs+z1udDZ1LOA@mail.gmail.com>
	<CANJO25KXoYXKZf-TZRD3HviU141+rYUB2d=4Xf9DqRrzD9P94w@mail.gmail.com>
	<CANEZrP0vJug1tGNiL5wQUuA0-rr3eM1Yp8DbO3Apiu1CX=j3bQ@mail.gmail.com>
Message-ID: <CABm2gDoUixqd3OuqNjH1Lg_sQyzSX9H3HWY+a3==frn7AFybgw@mail.gmail.com>

As Mike says it depends on your interests. But one thing that is almost
always welcomed is improving the tests, and it is unlikely that it
conflicts with other people's PRs (unless they're changing that part of the
code and need to update those tests. Improving documentation is also good
and you can do that while reading the code. Usually I just start cloning,
compiling and changing things as I read, "if I understand this correctly,
this change should not break the tests, if I understand this, this other
change should break the build", etc.
But again, is up to you.
On Apr 16, 2015 2:34 PM, "Mike Hearn" <mike at plan99.net> wrote:

> Hey Gabe,
>
> That's diving into the deep end for sure! :)
>
>> What are some current things that are lacking in Bitcoin core? Or am I
>> better off making something else for the ecosystem?
>>
> That depends on your interests.
>
> Many of the highest priority tasks in Bitcoin Core are rather complicated,
> unfortunately, even for people with experience. You can consult the issue
> tracker to get a feel for it.
>
> Alternatively, there are lots of wallet apps out there and plenty of more
> straightforward projects on them. However they may have less of a research
> flavour.
>
>
> ------------------------------------------------------------------------------
> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT
> Develop your own process in accordance with the BPMN 2 standard
> Learn Process modeling best practices with Bonita BPM through live
> exercises
> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual-
> event?utm_
> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150430/7c3c16d2/attachment.html>

From lemientelephone at gmail.com  Thu Apr 30 09:35:50 2015
From: lemientelephone at gmail.com (Telephone Lemien)
Date: Thu, 30 Apr 2015 11:35:50 +0200
Subject: [Bitcoin-development] Where do I start?
In-Reply-To: <CABm2gDoUixqd3OuqNjH1Lg_sQyzSX9H3HWY+a3==frn7AFybgw@mail.gmail.com>
References: <CANJO25K1Lox5aU-NN-j0An2ujNNHwPWNqX1ZXMs+z1udDZ1LOA@mail.gmail.com>
	<CANJO25KXoYXKZf-TZRD3HviU141+rYUB2d=4Xf9DqRrzD9P94w@mail.gmail.com>
	<CANEZrP0vJug1tGNiL5wQUuA0-rr3eM1Yp8DbO3Apiu1CX=j3bQ@mail.gmail.com>
	<CABm2gDoUixqd3OuqNjH1Lg_sQyzSX9H3HWY+a3==frn7AFybgw@mail.gmail.com>
Message-ID: <CAL6tyga=zN-HCu5CAwozBgvH+-gTkt+56uXQwqS1PUUmJxOwYw@mail.gmail.com>

Hello,
I'm a beginner in Bitcoin and I want to know, what are things those allo me
to understand Bitcoin protocol and make progress in java to become a good
developper.
Please tell me how I can begin.
Best regards

2015-04-30 10:08 GMT+02:00 Jorge Tim?n <jtimon at jtimon.cc>:

> As Mike says it depends on your interests. But one thing that is almost
> always welcomed is improving the tests, and it is unlikely that it
> conflicts with other people's PRs (unless they're changing that part of the
> code and need to update those tests. Improving documentation is also good
> and you can do that while reading the code. Usually I just start cloning,
> compiling and changing things as I read, "if I understand this correctly,
> this change should not break the tests, if I understand this, this other
> change should break the build", etc.
> But again, is up to you.
> On Apr 16, 2015 2:34 PM, "Mike Hearn" <mike at plan99.net> wrote:
>
>> Hey Gabe,
>>
>> That's diving into the deep end for sure! :)
>>
>>> What are some current things that are lacking in Bitcoin core? Or am I
>>> better off making something else for the ecosystem?
>>>
>> That depends on your interests.
>>
>> Many of the highest priority tasks in Bitcoin Core are rather
>> complicated, unfortunately, even for people with experience. You can
>> consult the issue tracker to get a feel for it.
>>
>> Alternatively, there are lots of wallet apps out there and plenty of more
>> straightforward projects on them. However they may have less of a research
>> flavour.
>>
>>
>> ------------------------------------------------------------------------------
>> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT
>> Develop your own process in accordance with the BPMN 2 standard
>> Learn Process modeling best practices with Bonita BPM through live
>> exercises
>> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual-
>> event?utm_
>> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>>
>
> ------------------------------------------------------------------------------
> One dashboard for servers and applications across Physical-Virtual-Cloud
> Widest out-of-the-box monitoring support with 50+ applications
> Performance metrics, stats and reports that give you Actionable Insights
> Deep dive visibility with transaction tracing using APM Insight.
> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150430/b9fb571c/attachment.html>

From jtimon at jtimon.cc  Thu Apr 30 10:28:05 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Thu, 30 Apr 2015 12:28:05 +0200
Subject: [Bitcoin-development] Where do I start?
In-Reply-To: <CAL6tyga=zN-HCu5CAwozBgvH+-gTkt+56uXQwqS1PUUmJxOwYw@mail.gmail.com>
References: <CANJO25K1Lox5aU-NN-j0An2ujNNHwPWNqX1ZXMs+z1udDZ1LOA@mail.gmail.com>
	<CANJO25KXoYXKZf-TZRD3HviU141+rYUB2d=4Xf9DqRrzD9P94w@mail.gmail.com>
	<CANEZrP0vJug1tGNiL5wQUuA0-rr3eM1Yp8DbO3Apiu1CX=j3bQ@mail.gmail.com>
	<CABm2gDoUixqd3OuqNjH1Lg_sQyzSX9H3HWY+a3==frn7AFybgw@mail.gmail.com>
	<CAL6tyga=zN-HCu5CAwozBgvH+-gTkt+56uXQwqS1PUUmJxOwYw@mail.gmail.com>
Message-ID: <CABm2gDpJqV7YGYCaubBbnSyMO-Q8Nv1w2T4msUbQzYJX_Xpn8A@mail.gmail.com>

Well, if you're interested in learning java while learning bitcoin,
probably you should be looking at https://github.com/bitcoinj/bitcoinj
or one of its related project (like the android bitcoin wallet based
on it).
There's a getting sterted page: https://bitcoinj.github.io/#getting-started

These links my be useful too:

https://bitcoin.org/en/bitcoin-for-developers
https://bitcoin.org/en/developer-documentation


On Thu, Apr 30, 2015 at 11:35 AM, Telephone Lemien
<lemientelephone at gmail.com> wrote:
> Hello,
> I'm a beginner in Bitcoin and I want to know, what are things those allo me
> to understand Bitcoin protocol and make progress in java to become a good
> developper.
> Please tell me how I can begin.
> Best regards
>
> 2015-04-30 10:08 GMT+02:00 Jorge Tim?n <jtimon at jtimon.cc>:
>>
>> As Mike says it depends on your interests. But one thing that is almost
>> always welcomed is improving the tests, and it is unlikely that it conflicts
>> with other people's PRs (unless they're changing that part of the code and
>> need to update those tests. Improving documentation is also good and you can
>> do that while reading the code. Usually I just start cloning, compiling and
>> changing things as I read, "if I understand this correctly, this change
>> should not break the tests, if I understand this, this other change should
>> break the build", etc.
>> But again, is up to you.
>>
>> On Apr 16, 2015 2:34 PM, "Mike Hearn" <mike at plan99.net> wrote:
>>>
>>> Hey Gabe,
>>>
>>> That's diving into the deep end for sure! :)
>>>>
>>>> What are some current things that are lacking in Bitcoin core? Or am I
>>>> better off making something else for the ecosystem?
>>>
>>> That depends on your interests.
>>>
>>> Many of the highest priority tasks in Bitcoin Core are rather
>>> complicated, unfortunately, even for people with experience. You can consult
>>> the issue tracker to get a feel for it.
>>>
>>> Alternatively, there are lots of wallet apps out there and plenty of more
>>> straightforward projects on them. However they may have less of a research
>>> flavour.
>>>
>>>
>>> ------------------------------------------------------------------------------
>>> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT
>>> Develop your own process in accordance with the BPMN 2 standard
>>> Learn Process modeling best practices with Bonita BPM through live
>>> exercises
>>> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual-
>>> event?utm_
>>> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF
>>> _______________________________________________
>>> Bitcoin-development mailing list
>>> Bitcoin-development at lists.sourceforge.net
>>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>>
>>
>>
>> ------------------------------------------------------------------------------
>> One dashboard for servers and applications across Physical-Virtual-Cloud
>> Widest out-of-the-box monitoring support with 50+ applications
>> Performance metrics, stats and reports that give you Actionable Insights
>> Deep dive visibility with transaction tracing using APM Insight.
>> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>



From me at thomaskerin.io  Thu Apr 30 15:50:34 2015
From: me at thomaskerin.io (Thomas Kerin)
Date: Thu, 30 Apr 2015 16:50:34 +0100
Subject: [Bitcoin-development] Where do I start?
In-Reply-To: <CABm2gDpJqV7YGYCaubBbnSyMO-Q8Nv1w2T4msUbQzYJX_Xpn8A@mail.gmail.com>
References: <CANJO25K1Lox5aU-NN-j0An2ujNNHwPWNqX1ZXMs+z1udDZ1LOA@mail.gmail.com>	<CANJO25KXoYXKZf-TZRD3HviU141+rYUB2d=4Xf9DqRrzD9P94w@mail.gmail.com>	<CANEZrP0vJug1tGNiL5wQUuA0-rr3eM1Yp8DbO3Apiu1CX=j3bQ@mail.gmail.com>	<CABm2gDoUixqd3OuqNjH1Lg_sQyzSX9H3HWY+a3==frn7AFybgw@mail.gmail.com>	<CAL6tyga=zN-HCu5CAwozBgvH+-gTkt+56uXQwqS1PUUmJxOwYw@mail.gmail.com>
	<CABm2gDpJqV7YGYCaubBbnSyMO-Q8Nv1w2T4msUbQzYJX_Xpn8A@mail.gmail.com>
Message-ID: <55424F4A.2080802@thomaskerin.io>

When dealing with any of the libraries or API's it's helps to know
what's going on under the hood. I find these pages to be invaluable.

https://en.bitcoin.it/wiki/Transactions
https://en.bitcoin.it/wiki/Protocol_specification
https://en.bitcoin.it/wiki/Script

On 30/04/15 11:28, Jorge Tim?n wrote:
> Well, if you're interested in learning java while learning bitcoin,
> probably you should be looking at https://github.com/bitcoinj/bitcoinj
> or one of its related project (like the android bitcoin wallet based
> on it).
> There's a getting sterted page: https://bitcoinj.github.io/#getting-started
>
> These links my be useful too:
>
> https://bitcoin.org/en/bitcoin-for-developers
> https://bitcoin.org/en/developer-documentation
>
>
> On Thu, Apr 30, 2015 at 11:35 AM, Telephone Lemien
> <lemientelephone at gmail.com> wrote:
>> Hello,
>> I'm a beginner in Bitcoin and I want to know, what are things those allo me
>> to understand Bitcoin protocol and make progress in java to become a good
>> developper.
>> Please tell me how I can begin.
>> Best regards
>>
>> 2015-04-30 10:08 GMT+02:00 Jorge Tim?n <jtimon at jtimon.cc>:
>>> As Mike says it depends on your interests. But one thing that is almost
>>> always welcomed is improving the tests, and it is unlikely that it conflicts
>>> with other people's PRs (unless they're changing that part of the code and
>>> need to update those tests. Improving documentation is also good and you can
>>> do that while reading the code. Usually I just start cloning, compiling and
>>> changing things as I read, "if I understand this correctly, this change
>>> should not break the tests, if I understand this, this other change should
>>> break the build", etc.
>>> But again, is up to you.
>>>
>>> On Apr 16, 2015 2:34 PM, "Mike Hearn" <mike at plan99.net> wrote:
>>>> Hey Gabe,
>>>>
>>>> That's diving into the deep end for sure! :)
>>>>> What are some current things that are lacking in Bitcoin core? Or am I
>>>>> better off making something else for the ecosystem?
>>>> That depends on your interests.
>>>>
>>>> Many of the highest priority tasks in Bitcoin Core are rather
>>>> complicated, unfortunately, even for people with experience. You can consult
>>>> the issue tracker to get a feel for it.
>>>>
>>>> Alternatively, there are lots of wallet apps out there and plenty of more
>>>> straightforward projects on them. However they may have less of a research
>>>> flavour.
>>>>
>>>>
>>>> ------------------------------------------------------------------------------
>>>> BPM Camp - Free Virtual Workshop May 6th at 10am PDT/1PM EDT
>>>> Develop your own process in accordance with the BPMN 2 standard
>>>> Learn Process modeling best practices with Bonita BPM through live
>>>> exercises
>>>> http://www.bonitasoft.com/be-part-of-it/events/bpm-camp-virtual-
>>>> event?utm_
>>>> source=Sourceforge_BPM_Camp_5_6_15&utm_medium=email&utm_campaign=VA_SF
>>>> _______________________________________________
>>>> Bitcoin-development mailing list
>>>> Bitcoin-development at lists.sourceforge.net
>>>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>>>
>>>
>>> ------------------------------------------------------------------------------
>>> One dashboard for servers and applications across Physical-Virtual-Cloud
>>> Widest out-of-the-box monitoring support with 50+ applications
>>> Performance metrics, stats and reports that give you Actionable Insights
>>> Deep dive visibility with transaction tracing using APM Insight.
>>> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y
>>> _______________________________________________
>>> Bitcoin-development mailing list
>>> Bitcoin-development at lists.sourceforge.net
>>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>>
> ------------------------------------------------------------------------------
> One dashboard for servers and applications across Physical-Virtual-Cloud 
> Widest out-of-the-box monitoring support with 50+ applications
> Performance metrics, stats and reports that give you Actionable Insights
> Deep dive visibility with transaction tracing using APM Insight.
> http://ad.doubleclick.net/ddm/clk/290420510;117567292;y
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development

-- 
Thomas Kerin
------------------------------------------------------------------------

My PGP key can be found here <http://pgp.mit.edu/pks/lookup?op=get&search=0x3F0D2F83A2966155>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20150430/8e0c1ee5/attachment.html>

