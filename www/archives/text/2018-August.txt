From vitteaymeric at gmail.com  Wed Aug  1 09:58:43 2018
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Wed, 1 Aug 2018 11:58:43 +0200
Subject: [bitcoin-dev] bitcoin-transactions
In-Reply-To: <CAAUq485wUxGyM0m5geQ2JvBz=yMw7tXu11vdkkYuAxDfaWJkRg@mail.gmail.com>
References: <ed8d80c4-7b11-2800-a6d0-ff2deb424072@gmail.com>
	<CAAUq485wUxGyM0m5geQ2JvBz=yMw7tXu11vdkkYuAxDfaWJkRg@mail.gmail.com>
Message-ID: <c6e469e7-30aa-08f5-7ce6-bfa42081bf39@gmail.com>

You are right, that's what I have been saying for online services that
ask for private keys, and even the seeds

The problem is that people can't refrain to put their keys for example
to get "free" coins, typically they try to use bitcoin-transactions,
don't succeed and go put their seeds in an online service

At least it gives an alternative, private keys are optional and the tool
will output the command to use with bitcoin-transactions, and if they
want to put directly their keys, then...

"Move your coins by yourself" refers more to "don't get trapped by your
wallet(s) or things that you don't master like multisig, segwit, bech32,
etc"

As I said the idea would be to end up with an offline tool should some
people support/finance the effort


Le 01/08/2018 ? 07:45, Marcel Jamin a ?crit?:
> IMHO you should almost never publish a service that asks users for
> private keys.
>
> A warning isn't enough. Your server might get compromised.
>
> "Move your coins by yourself" isn't even correct if your server is
> involved.
>
> On Tue, 31 Jul 2018 at 13:26, Aymeric Vitte via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org
> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>
>     I know this list is not to advertise personal projects but
>     https://peersm.com/wallet might be of some interest, this is the web
>     interface for https://github.com/Ayms/bitcoin-transactions since
>     apparently quasi nobody succeeds to use it
>
>     As far as I know (and surprisingly) this is the only online tool that
>     converts bech32 addresses (Sipa's one does not output something
>     understandable by everybody, the tool is using his code), the only one
>     that converts from any address to any address, maybe the only one that
>     decodes simply redeem scripts and probably the only one that allows to
>     create transactions by its own (the advanced mode is not
>     implemented for
>     now but will be soon)
>
>     Ideally it should be an offline tool if there is some incentive to do
>     so, so of course it is not advised to use his private keys for now
>
>     Maybe they are mistaken but some users are reporting invalid bech32
>     addresses from their Electrum wallet, after segwit, bech32 confusion
>     seems to be the topic of the moment
>
>     Regards
>
>     Aymeric
>
>     -- 
>     Bitcoin transactions made simple:
>     https://github.com/Ayms/bitcoin-transactions
>     Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
>     Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
>     Get the torrent dynamic blocklist: http://peersm.com/getblocklist
>     Check the 10 M passwords list: http://peersm.com/findmyass
>     Anti-spies and private torrents, dynamic blocklist:
>     http://torrent-live.org
>     Peersm : http://www.peersm.com
>     torrent-live: https://github.com/Ayms/torrent-live
>     node-Tor : https://www.github.com/Ayms/node-Tor
>     GitHub : https://www.github.com/Ayms
>
>     _______________________________________________
>     bitcoin-dev mailing list
>     bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

-- 
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180801/b5b352ad/attachment.html>

From bram at chia.net  Fri Aug  3 18:22:48 2018
From: bram at chia.net (Bram Cohen)
Date: Fri, 3 Aug 2018 11:22:48 -0700
Subject: [bitcoin-dev] BLS library released
Message-ID: <CAHUJnBCyhaKU+P2RYHv=+8jDpV6tk53qNStbh0WKFAw8hXSj7Q@mail.gmail.com>

BLS signatures have the same aggregation feature as Schnorr signatures but
even better because the aggregation can be done non-interactively, at the
expense of being a bit slower. We just released a first draft (but fully
functional) library for doing BLS signatures based on a construction based
on musig. Feedback, discussion, and usage is very welcome.

https://github.com/Chia-Network/bls-signatures
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180803/64cf8b43/attachment.html>

From marcel at jamin.net  Wed Aug  1 05:45:54 2018
From: marcel at jamin.net (Marcel Jamin)
Date: Wed, 1 Aug 2018 07:45:54 +0200
Subject: [bitcoin-dev] bitcoin-transactions
In-Reply-To: <ed8d80c4-7b11-2800-a6d0-ff2deb424072@gmail.com>
References: <ed8d80c4-7b11-2800-a6d0-ff2deb424072@gmail.com>
Message-ID: <CAAUq485wUxGyM0m5geQ2JvBz=yMw7tXu11vdkkYuAxDfaWJkRg@mail.gmail.com>

IMHO you should almost never publish a service that asks users for private
keys.

A warning isn't enough. Your server might get compromised.

"Move your coins by yourself" isn't even correct if your server is involved.

On Tue, 31 Jul 2018 at 13:26, Aymeric Vitte via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I know this list is not to advertise personal projects but
> https://peersm.com/wallet might be of some interest, this is the web
> interface for https://github.com/Ayms/bitcoin-transactions since
> apparently quasi nobody succeeds to use it
>
> As far as I know (and surprisingly) this is the only online tool that
> converts bech32 addresses (Sipa's one does not output something
> understandable by everybody, the tool is using his code), the only one
> that converts from any address to any address, maybe the only one that
> decodes simply redeem scripts and probably the only one that allows to
> create transactions by its own (the advanced mode is not implemented for
> now but will be soon)
>
> Ideally it should be an offline tool if there is some incentive to do
> so, so of course it is not advised to use his private keys for now
>
> Maybe they are mistaken but some users are reporting invalid bech32
> addresses from their Electrum wallet, after segwit, bech32 confusion
> seems to be the topic of the moment
>
> Regards
>
> Aymeric
>
> --
> Bitcoin transactions made simple:
> https://github.com/Ayms/bitcoin-transactions
> Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
> Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
> Get the torrent dynamic blocklist: http://peersm.com/getblocklist
> Check the 10 M passwords list: http://peersm.com/findmyass
> Anti-spies and private torrents, dynamic blocklist:
> http://torrent-live.org
> Peersm : http://www.peersm.com
> torrent-live: https://github.com/Ayms/torrent-live
> node-Tor : https://www.github.com/Ayms/node-Tor
> GitHub : https://www.github.com/Ayms
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180801/7f4e4e8f/attachment.html>

From stephane.traumat at gmail.com  Wed Aug  1 08:08:55 2018
From: stephane.traumat at gmail.com (=?UTF-8?Q?St=C3=A9phane_Traumat?=)
Date: Wed, 1 Aug 2018 10:08:55 +0200
Subject: [bitcoin-dev] BIP171 - Mocked implementation, generated specs,
 live API and 16 clients libs
Message-ID: <CAApT8LTr1Qq4cDpRJdk25t6gGLgEg47_VgGj=xPUBNTsj4ufNw@mail.gmail.com>

I just released CERISE (website <http://www.cerise.tech/> & github
<https://github.com/straumat/cerise>) a project with the following
artifacts :

   -

   A mocked server implementation to start developing clients :
   https://github.com/straumat/cerise.
   -

   A live & documented API to understand and directly calls the methods :
   http://api.cerise.tech/docs.
   -

   Specifications of the four methods : Enumerating supported currency-pair
   tokens
   <http://www.cerise.tech/specifications/0.3-SNAPSHOT/supportedCurrencyPairTokensAPI.html>
   , Currency-pair information
   <http://www.cerise.tech/specifications/0.3-SNAPSHOT/currencyPairInformationAPI.html>
   , Current exchange rate
   <http://www.cerise.tech/specifications/0.3-SNAPSHOT/currentExchangeRateAPI.html>
    & Historical exchange rates
   <http://www.cerise.tech/specifications/0.3-SNAPSHOT/historicalExchangeRatesAPI.html>
   .
   -

   16 client librairies for various langages (Java, PHP, c++, Rusty,
   Ruby?.) : http://www.cerise.tech/#clients.
   -

   and i?m working on a template project to allow developers to quickly
   build a BIP171 compliant server without having to worrying about parameters
   validation, security, rest mechanics? will be done in september.

-- 
*St?phane Traumat*
https://about.me/straumat
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180801/2b0e5d4a/attachment.html>

From leishman3 at gmail.com  Fri Aug  3 23:53:29 2018
From: leishman3 at gmail.com (Alexander Leishman)
Date: Fri, 3 Aug 2018 19:53:29 -0400
Subject: [bitcoin-dev] BLS library released
In-Reply-To: <CAHUJnBCyhaKU+P2RYHv=+8jDpV6tk53qNStbh0WKFAw8hXSj7Q@mail.gmail.com>
References: <CAHUJnBCyhaKU+P2RYHv=+8jDpV6tk53qNStbh0WKFAw8hXSj7Q@mail.gmail.com>
Message-ID: <DF75BA9F-36B3-4571-A392-7E619032224E@gmail.com>

Awesome! Haven?t had the chance to run it myself yet, so curious what benchmarks you are getting?

Best,
Alex 

> On Aug 3, 2018, at 14:22, Bram Cohen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> BLS signatures have the same aggregation feature as Schnorr signatures but even better because the aggregation can be done non-interactively, at the expense of being a bit slower. We just released a first draft (but fully functional) library for doing BLS signatures based on a construction based on musig. Feedback, discussion, and usage is very welcome.
> 
> https://github.com/Chia-Network/bls-signatures
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180803/4f4dc17d/attachment-0001.html>

From mjbecze at gmail.com  Fri Aug  3 23:28:02 2018
From: mjbecze at gmail.com (M Bz)
Date: Fri, 3 Aug 2018 19:28:02 -0400
Subject: [bitcoin-dev] BLS library released
In-Reply-To: <CAHUJnBCyhaKU+P2RYHv=+8jDpV6tk53qNStbh0WKFAw8hXSj7Q@mail.gmail.com>
References: <CAHUJnBCyhaKU+P2RYHv=+8jDpV6tk53qNStbh0WKFAw8hXSj7Q@mail.gmail.com>
Message-ID: <CALz06g4srMTg6TNg99xdWQrSzb=Tceaov1jeo0nWEpVEG_OS8w@mail.gmail.com>

nice! how does it compare to Shigeo's implementation?
https://github.com/herumi/bls

On Fri, Aug 3, 2018 at 7:10 PM Bram Cohen via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> BLS signatures have the same aggregation feature as Schnorr signatures but
> even better because the aggregation can be done non-interactively, at the
> expense of being a bit slower. We just released a first draft (but fully
> functional) library for doing BLS signatures based on a construction based
> on musig. Feedback, discussion, and usage is very welcome.
>
> https://github.com/Chia-Network/bls-signatures
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180803/591ffaf8/attachment.html>

From roconnor at blockstream.io  Sat Aug  4 12:22:28 2018
From: roconnor at blockstream.io (Russell O'Connor)
Date: Sat, 4 Aug 2018 08:22:28 -0400
Subject: [bitcoin-dev] Schnorr signatures BIP
In-Reply-To: <CAPg+sBg1WuG1MihC3zBHJpxVqC2Sys7Y52iWs6JXEMmnL_tE_w@mail.gmail.com>
References: <CAPg+sBj7f+=OYXuOMdNeJk3NBG67FSQSF8Xv3seFCvwxCWq69A@mail.gmail.com>
	<A899D97B-5D47-4AB0-8A7F-57F91C58ADE1@sprovoost.nl>
	<CAPg+sBg1WuG1MihC3zBHJpxVqC2Sys7Y52iWs6JXEMmnL_tE_w@mail.gmail.com>
Message-ID: <CAMZUoKm4Qs2yAc+WKgN1J2D8MDgbzNnK69kF+hbY2GDyRqdVdg@mail.gmail.com>

I propose changing the verification equation from "Let *R = sG - eP*" to

    Let *R = sG + eP*

This allows faster verification by avoiding negating a point (or a
coefficient).


If, instead of directly following the literal verification specification,
one is instead reconstructing R from r by finding a y coordinate that is a
quadratic residue, under the existing scheme one would verify


*sG - eP = R*

which is effectively verifying

  0 = *sG - eP* - R  or 0 = R - *sG + eP*

Either way one needs to negate at least one point (or one coefficient)
because of the opposite signs between sG and eP.


Under my proposed revised verification scheme, one would instead verify

  0 = sG + eP + (-R).

While it seems that this requires negating R, it does not.  Rather (-R) can
be directly constructed from r by finding a y coordinate that is *not* a
quadratic residue, which is precisely the same amount of work that
construction R from r was.

In either verification procedure, changing the verification equation to my
proposal removes one negation operation from the cost of doing verification.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180804/2fc635e5/attachment.html>

From roconnor at blockstream.io  Sun Aug  5 14:33:52 2018
From: roconnor at blockstream.io (Russell O'Connor)
Date: Sun, 5 Aug 2018 10:33:52 -0400
Subject: [bitcoin-dev] Schnorr signatures BIP
In-Reply-To: <CAMZUoKm4Qs2yAc+WKgN1J2D8MDgbzNnK69kF+hbY2GDyRqdVdg@mail.gmail.com>
References: <CAPg+sBj7f+=OYXuOMdNeJk3NBG67FSQSF8Xv3seFCvwxCWq69A@mail.gmail.com>
	<A899D97B-5D47-4AB0-8A7F-57F91C58ADE1@sprovoost.nl>
	<CAPg+sBg1WuG1MihC3zBHJpxVqC2Sys7Y52iWs6JXEMmnL_tE_w@mail.gmail.com>
	<CAMZUoKm4Qs2yAc+WKgN1J2D8MDgbzNnK69kF+hbY2GDyRqdVdg@mail.gmail.com>
Message-ID: <CAMZUoKm_ij4Ffzx5Wpipa5RAFA=5F06jhiTCMJhp3vAj1q+2jA@mail.gmail.com>

Over chat it has been pointed out to me that computing the non-quadratic
residue is not the same cost as computing a quadratic residue.  As pointed
out in footnote 7 of the the proposed BIP, c^((p+1)/4) is always a
quadratic residue and must be negated to find the non-quadratic residue.

In light of this, I revise my proposed change to make the verification
equation

R + sG + eP = 0.

(by 0 in the equation above I mean the identity element for the (+)
operation, which is the point at infinity.)

This equation is suitable for batch verification.  This equation is clearly
written as a linear combination that doesn't use negation.  In most
implementations, equality comparison tests are implemented by subtraction
and a comparison with zero. By writing the verification equation this way,
we clearly see that only the comparison with zero test is needed.

For single signature verification the check becomes, compute Q := sG + eP.
Verify that Q isn't the point at infinity and Q.x = r.  Verify that Q.y is
*not* a quadratic residue. (While I was incorrect earlier about the costs
of computing a non-residue, it is the case the *verifying* a value is a
quadratic residue is the same cost as verifying a value is a non-residue.)

Effectively in my first email I was suggesting that the 'e' value in a
signature be negated from the current BIP proposal.  In this revision I am
effectively suggesting that the 's' value in a signature should be the one
that is negated instead.

On Sat, Aug 4, 2018 at 8:22 AM, Russell O'Connor <roconnor at blockstream.io>
wrote:

> I propose changing the verification equation from "Let *R = sG - eP*" to
>
>     Let *R = sG + eP*
>
> This allows faster verification by avoiding negating a point (or a
> coefficient).
>
>
> If, instead of directly following the literal verification specification,
> one is instead reconstructing R from r by finding a y coordinate that is a
> quadratic residue, under the existing scheme one would verify
>
>
> *sG - eP = R*
>
> which is effectively verifying
>
>   0 = *sG - eP* - R  or 0 = R - *sG + eP*
>
> Either way one needs to negate at least one point (or one coefficient)
> because of the opposite signs between sG and eP.
>
>
> Under my proposed revised verification scheme, one would instead verify
>
>   0 = sG + eP + (-R).
>
> While it seems that this requires negating R, it does not.  Rather (-R)
> can be directly constructed from r by finding a y coordinate that is *not*
> a quadratic residue, which is precisely the same amount of work that
> construction R from r was.
>
> In either verification procedure, changing the verification equation to my
> proposal removes one negation operation from the cost of doing verification.
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180805/08b47da6/attachment.html>

From lautarodragan at gmail.com  Sun Aug  5 21:11:26 2018
From: lautarodragan at gmail.com (Lautaro Dragan)
Date: Sun, 5 Aug 2018 18:11:26 -0300
Subject: [bitcoin-dev] Claiming an OP_RETURN Prefix
Message-ID: <CAK6DEspS1+LWwJgbVfWaM3gHwmhYPGBuV+dLPATe--QwmUUa2Q@mail.gmail.com>

Hi everyone,

My name's Lautaro and I'm currently acting as Tech Lead of Po.et
<https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>. At Po.et we use
colored coins
<https://github.com/poetapp/node/blob/3c905bc5dbd3722ad39ac68041d9f2a099e5e84c/src/BlockchainWriter/ClaimController.ts#L101-L110>
to
store data on the Bitcoin blockchain with prefix "POET".

I've read in an old version of the OP_RETURN entry of the bitcoin wiki
<https://en.bitcoin.it/w/index.php?title=OP_RETURN&oldid=62560> that *protocols
wishing to claim OP_RETURN prefixes should use the standard Bitcoin
Improvement Proposals process*.

That entry seems to have changed recently
<https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>, no longer
stating that we should follow the BIP process, and I haven't been able to
find any existing BIP claiming an OP_RETURN prexif, but for the sake of
thoroughness I'd like to ask for your help or confirmation here.

Should we actually be using the BIP process to claim a prefix?

Thanks in advance,

Lautaro
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180805/c445b874/attachment.html>

From pete at petertodd.org  Sun Aug  5 23:57:55 2018
From: pete at petertodd.org (Peter Todd)
Date: Sun, 05 Aug 2018 23:57:55 +0000
Subject: [bitcoin-dev] Claiming an OP_RETURN Prefix
In-Reply-To: <CAK6DEspS1+LWwJgbVfWaM3gHwmhYPGBuV+dLPATe--QwmUUa2Q@mail.gmail.com>
References: <CAK6DEspS1+LWwJgbVfWaM3gHwmhYPGBuV+dLPATe--QwmUUa2Q@mail.gmail.com>
Message-ID: <F6AA346D-4AF5-4838-A91F-44FAF74A55E9@petertodd.org>



On August 5, 2018 9:11:26 PM UTC, Lautaro Dragan via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>Hi everyone,
>
>My name's Lautaro and I'm currently acting as Tech Lead of Po.et
><https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>. At Po.et we
>use
>colored coins
><https://github.com/poetapp/node/blob/3c905bc5dbd3722ad39ac68041d9f2a099e5e84c/src/BlockchainWriter/ClaimController.ts#L101-L110>
>to
>store data on the Bitcoin blockchain with prefix "POET".
>
>I've read in an old version of the OP_RETURN entry of the bitcoin wiki
><https://en.bitcoin.it/w/index.php?title=OP_RETURN&oldid=62560> that
>*protocols
>wishing to claim OP_RETURN prefixes should use the standard Bitcoin
>Improvement Proposals process*.
>
>That entry seems to have changed recently
><https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>, no longer
>stating that we should follow the BIP process, and I haven't been able
>to
>find any existing BIP claiming an OP_RETURN prexif, but for the sake of
>thoroughness I'd like to ask for your help or confirmation here.
>
>Should we actually be using the BIP process to claim a prefix?

It's better if you don't use a prefix at all from a censorship resistance and anonymity perspective; you're application should not require a prefix for technical reasons.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org

From lautarodragan at gmail.com  Mon Aug  6 00:55:59 2018
From: lautarodragan at gmail.com (Lautaro Dragan)
Date: Sun, 5 Aug 2018 21:55:59 -0300
Subject: [bitcoin-dev] Claiming an OP_RETURN Prefix
In-Reply-To: <F6AA346D-4AF5-4838-A91F-44FAF74A55E9@petertodd.org>
References: <CAK6DEspS1+LWwJgbVfWaM3gHwmhYPGBuV+dLPATe--QwmUUa2Q@mail.gmail.com>
	<F6AA346D-4AF5-4838-A91F-44FAF74A55E9@petertodd.org>
Message-ID: <CAK6DEsp=1A61kK5K+8xZOX3wSiUhRdVoTm5nUu9dYY3C1CsPnA@mail.gmail.com>

Thanks Peter for your prompt reply.

And now that I think of it you're right - as easy as it is for us to
differentiate OP_RETURN outputs that contain the Po.et prefix it would be
for miners to block those transactions altogether. Is this what you mean?

Still, a prefix is something we may have to live with for a little while
until we can address that issue.

Is there a formal / standard process to claim it we should follow?




El dom., 5 de ago. de 2018 a la(s) 20:58, Peter Todd <pete at petertodd.org>
escribi?:

>
>
> On August 5, 2018 9:11:26 PM UTC, Lautaro Dragan via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >Hi everyone,
> >
> >My name's Lautaro and I'm currently acting as Tech Lead of Po.et
> ><https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>. At Po.et we
> >use
> >colored coins
> ><
> https://github.com/poetapp/node/blob/3c905bc5dbd3722ad39ac68041d9f2a099e5e84c/src/BlockchainWriter/ClaimController.ts#L101-L110
> >
> >to
> >store data on the Bitcoin blockchain with prefix "POET".
> >
> >I've read in an old version of the OP_RETURN entry of the bitcoin wiki
> ><https://en.bitcoin.it/w/index.php?title=OP_RETURN&oldid=62560> that
> >*protocols
> >wishing to claim OP_RETURN prefixes should use the standard Bitcoin
> >Improvement Proposals process*.
> >
> >That entry seems to have changed recently
> ><https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>, no longer
> >stating that we should follow the BIP process, and I haven't been able
> >to
> >find any existing BIP claiming an OP_RETURN prexif, but for the sake of
> >thoroughness I'd like to ask for your help or confirmation here.
> >
> >Should we actually be using the BIP process to claim a prefix?
>
> It's better if you don't use a prefix at all from a censorship resistance
> and anonymity perspective; you're application should not require a prefix
> for technical reasons.
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180805/e3265ebe/attachment-0001.html>

From cryptaxe at gmail.com  Mon Aug  6 01:54:50 2018
From: cryptaxe at gmail.com (CryptAxe)
Date: Sun, 5 Aug 2018 18:54:50 -0700
Subject: [bitcoin-dev] Claiming an OP_RETURN Prefix
In-Reply-To: <CAK6DEsp=1A61kK5K+8xZOX3wSiUhRdVoTm5nUu9dYY3C1CsPnA@mail.gmail.com>
References: <CAK6DEspS1+LWwJgbVfWaM3gHwmhYPGBuV+dLPATe--QwmUUa2Q@mail.gmail.com>
	<F6AA346D-4AF5-4838-A91F-44FAF74A55E9@petertodd.org>
	<CAK6DEsp=1A61kK5K+8xZOX3wSiUhRdVoTm5nUu9dYY3C1CsPnA@mail.gmail.com>
Message-ID: <CAF5CFkjxs4KBGJvpzhsyCRfdu-EGXS3mUyVPntnpNLO3cRW+xQ@mail.gmail.com>

Don't worry about claiming it. There are no reserved prefixes enforced by
the software. For example anyone could create an output that uses the
witness coinbase commitment prefix bytes. It would just be ignored (unless
it was in the coinbase, in which case it would also need to be valid).

On Sun, Aug 5, 2018, 6:47 PM Lautaro Dragan via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Thanks Peter for your prompt reply.
>
> And now that I think of it you're right - as easy as it is for us to
> differentiate OP_RETURN outputs that contain the Po.et prefix it would be
> for miners to block those transactions altogether. Is this what you mean?
>
> Still, a prefix is something we may have to live with for a little while
> until we can address that issue.
>
> Is there a formal / standard process to claim it we should follow?
>
>
>
>
> El dom., 5 de ago. de 2018 a la(s) 20:58, Peter Todd <pete at petertodd.org>
> escribi?:
>
>>
>>
>> On August 5, 2018 9:11:26 PM UTC, Lautaro Dragan via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>> >Hi everyone,
>> >
>> >My name's Lautaro and I'm currently acting as Tech Lead of Po.et
>> ><https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>. At Po.et we
>> >use
>> >colored coins
>> ><
>> https://github.com/poetapp/node/blob/3c905bc5dbd3722ad39ac68041d9f2a099e5e84c/src/BlockchainWriter/ClaimController.ts#L101-L110
>> >
>> >to
>> >store data on the Bitcoin blockchain with prefix "POET".
>> >
>> >I've read in an old version of the OP_RETURN entry of the bitcoin wiki
>> ><https://en.bitcoin.it/w/index.php?title=OP_RETURN&oldid=62560> that
>> >*protocols
>> >wishing to claim OP_RETURN prefixes should use the standard Bitcoin
>> >Improvement Proposals process*.
>> >
>> >That entry seems to have changed recently
>> ><https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>, no longer
>> >stating that we should follow the BIP process, and I haven't been able
>> >to
>> >find any existing BIP claiming an OP_RETURN prexif, but for the sake of
>> >thoroughness I'd like to ask for your help or confirmation here.
>> >
>> >Should we actually be using the BIP process to claim a prefix?
>>
>> It's better if you don't use a prefix at all from a censorship resistance
>> and anonymity perspective; you're application should not require a prefix
>> for technical reasons.
>>
>> --
>> https://petertodd.org 'peter'[:-1]@petertodd.org
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180805/616dd36b/attachment.html>

From luke at dashjr.org  Mon Aug  6 02:04:18 2018
From: luke at dashjr.org (Luke Dashjr)
Date: Mon, 6 Aug 2018 02:04:18 +0000
Subject: [bitcoin-dev] Claiming an OP_RETURN Prefix
In-Reply-To: <CAK6DEspS1+LWwJgbVfWaM3gHwmhYPGBuV+dLPATe--QwmUUa2Q@mail.gmail.com>
References: <CAK6DEspS1+LWwJgbVfWaM3gHwmhYPGBuV+dLPATe--QwmUUa2Q@mail.gmail.com>
Message-ID: <201808060204.19511.luke@dashjr.org>

Are you doing coloured coins or storing data?

If the former, you should probably collaborate with the authors of BIP 160 
(yet to be added to the main repo), and/or write a new BIP if BIP 160 is 
insufficient for some reason.

If the latter, you just shouldn't do it at all.

Note that BIPs need to specify an actual protocol, not just claim a prefix.


On Sunday 05 August 2018 21:11:26 Lautaro Dragan via bitcoin-dev wrote:
> Hi everyone,
>
> My name's Lautaro and I'm currently acting as Tech Lead of Po.et
> <https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>. At Po.et we use
> colored coins
> <https://github.com/poetapp/node/blob/3c905bc5dbd3722ad39ac68041d9f2a099e5e
>84c/src/BlockchainWriter/ClaimController.ts#L101-L110> to
> store data on the Bitcoin blockchain with prefix "POET".
>
> I've read in an old version of the OP_RETURN entry of the bitcoin wiki
> <https://en.bitcoin.it/w/index.php?title=OP_RETURN&oldid=62560> that
> *protocols wishing to claim OP_RETURN prefixes should use the standard
> Bitcoin Improvement Proposals process*.
>
> That entry seems to have changed recently
> <https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>, no longer
> stating that we should follow the BIP process, and I haven't been able to
> find any existing BIP claiming an OP_RETURN prexif, but for the sake of
> thoroughness I'd like to ask for your help or confirmation here.
>
> Should we actually be using the BIP process to claim a prefix?
>
> Thanks in advance,
>
> Lautaro


From greg at xiph.org  Mon Aug  6 02:15:22 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Mon, 6 Aug 2018 02:15:22 +0000
Subject: [bitcoin-dev] Capping the size of locators [trivial protocol change
	BIP]
Message-ID: <CAAS2fgR=TvME_ps5oXYPeFJyjVZfaAtc=KQb5Ts2WQ4C2uO8+g@mail.gmail.com>

Coinr8d posted on bct that the node software would process large
locators limited only by the maximum message size yet sensible usage
of locators only results in messages of log2(n_blocks) size. He was
concerned that it might be a DOS vulnerability but quick measurements
indicated to me that it likely wasn't worse than many other protocol
messages.  It still seems silly to allow absurd locators. So I propose
that the size of locators be limited.

However, capping them is a P2P change that could potentially result in
network splits if older nodes would potentially produce larger
locators (esp if triggered to produce unexpectedly large ones by
forks).  A quick survey of node software indicated that no software I
could find would ever produce a locator with more than 42 hashes
before encountering other limits, so I think a limit of 64 will be
automatically compatible with all or virtually all nodes on the
network.

I'm bothering writing a BIP because there might be some naive
implementation lurking out there that sends a crazy number due to
sub-exponential backoff that would be broken by nodes enforcing a
limit... particularly since the correct use of locators was never
previously mandated and might not be obvious to all developers.

I take the opportunity to also specify that the locators be correctly
ordered in terms of total work, but  don't specify that they all come
from the same chain.

Cheers,

==Introduction==

===Abstract===

This document proposes limiting the locator messages used in the getblocks
and getheaders to 64 entries and requiring that be ordered by total
work.

===Copyright===

This document is licensed under the 2-clause BSD license.

==Motivation==

The Bitcoin P2P protocol uses a simple and efficient data structure
to reconcile blockchains between nodes called a locator.  A locator
communicates a list of known hashes which allows a peer to find a
recent common ancestor between the best chains on two nodes.  By
exponentially increasing the space between each entry, the locator
allows a log() sized message to find the difference between two nodes
with only a constant factor overhead.

Because short forks are much more common than long forks the typical
usage of the locator includes a small number of topmost hashes before
switching to exponential spacing.

The original Bitcoin implementation provided no explicit limit to the
number of hashes in a locator message, allowing for absurd and
wasteful uses like including
all hashes in a chain.

Although locators are very inexpensive for existing node software to
process there is no known utility for sending very large locators.
To reduce the worst case cost of processing a locator message it would
be useful if the size of locator messages were strictly
bounded to sensible levels.

Common implementations have implicit limitations of 2^32 blocks and an
exponent of 2 after the first 10 locators and so could never request
more than 42 hashes in any case.

== Specification ==

A locator included in a getblock or getheaders message may include no more
than 64 hashes, including the final hash_stop hash. Additionally, the blocks
referenced by the locator must be in order of equal or decreasing total
work.

Sending a locator that violates these requirements may result in normal
processing, the message being ignored, a disconnection, or a ban.

Implementations that seek to handle larger numbers of blocks than afforded
by this limit with an exponent of 2 can adaptively switch to a larger
exponent as required to stay within the limit.

== Acknowledgements ==

Thanks to Coinr8d on bitcointalk for pointing out that node software would
process and respond to locators with about 125,000 hashes in them.

From lautarodragan at gmail.com  Mon Aug  6 02:19:44 2018
From: lautarodragan at gmail.com (Lautaro Dragan)
Date: Sun, 5 Aug 2018 23:19:44 -0300
Subject: [bitcoin-dev] Claiming an OP_RETURN Prefix
In-Reply-To: <201808060204.19511.luke@dashjr.org>
References: <CAK6DEspS1+LWwJgbVfWaM3gHwmhYPGBuV+dLPATe--QwmUUa2Q@mail.gmail.com>
	<201808060204.19511.luke@dashjr.org>
Message-ID: <CAK6DEsrQaYQh02zdrtdO0DFfahcu7vA6kc_qp4fMBWTj+ux7MQ@mail.gmail.com>

Sorry for the confusion. We're doing coloured coins ? storing the "POET"
prefix followed by an IPFS hash in the output and storing the full data in
IPFS.

Would you point me to the current work on BIP 160 or the authors?

El dom., 5 de ago. de 2018 a la(s) 23:05, Luke Dashjr <luke at dashjr.org>
escribi?:

> Are you doing coloured coins or storing data?
>
> If the former, you should probably collaborate with the authors of BIP 160
> (yet to be added to the main repo), and/or write a new BIP if BIP 160 is
> insufficient for some reason.
>
> If the latter, you just shouldn't do it at all.
>
> Note that BIPs need to specify an actual protocol, not just claim a prefix.
>
>
> On Sunday 05 August 2018 21:11:26 Lautaro Dragan via bitcoin-dev wrote:
> > Hi everyone,
> >
> > My name's Lautaro and I'm currently acting as Tech Lead of Po.et
> > <https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>. At Po.et we
> use
> > colored coins
> > <
> https://github.com/poetapp/node/blob/3c905bc5dbd3722ad39ac68041d9f2a099e5e
> >84c/src/BlockchainWriter/ClaimController.ts#L101-L110> to
> > store data on the Bitcoin blockchain with prefix "POET".
> >
> > I've read in an old version of the OP_RETURN entry of the bitcoin wiki
> > <https://en.bitcoin.it/w/index.php?title=OP_RETURN&oldid=62560> that
> > *protocols wishing to claim OP_RETURN prefixes should use the standard
> > Bitcoin Improvement Proposals process*.
> >
> > That entry seems to have changed recently
> > <https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>, no longer
> > stating that we should follow the BIP process, and I haven't been able to
> > find any existing BIP claiming an OP_RETURN prexif, but for the sake of
> > thoroughness I'd like to ask for your help or confirmation here.
> >
> > Should we actually be using the BIP process to claim a prefix?
> >
> > Thanks in advance,
> >
> > Lautaro
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180805/ed0fdefe/attachment-0001.html>

From aj at erisian.com.au  Mon Aug  6 08:39:25 2018
From: aj at erisian.com.au (Anthony Towns)
Date: Mon, 6 Aug 2018 18:39:25 +1000
Subject: [bitcoin-dev] Schnorr signatures BIP
In-Reply-To: <CAMZUoKm_ij4Ffzx5Wpipa5RAFA=5F06jhiTCMJhp3vAj1q+2jA@mail.gmail.com>
References: <CAPg+sBj7f+=OYXuOMdNeJk3NBG67FSQSF8Xv3seFCvwxCWq69A@mail.gmail.com>
	<A899D97B-5D47-4AB0-8A7F-57F91C58ADE1@sprovoost.nl>
	<CAPg+sBg1WuG1MihC3zBHJpxVqC2Sys7Y52iWs6JXEMmnL_tE_w@mail.gmail.com>
	<CAMZUoKm4Qs2yAc+WKgN1J2D8MDgbzNnK69kF+hbY2GDyRqdVdg@mail.gmail.com>
	<CAMZUoKm_ij4Ffzx5Wpipa5RAFA=5F06jhiTCMJhp3vAj1q+2jA@mail.gmail.com>
Message-ID: <20180806083925.kg5px476bzhec44b@erisian.com.au>

On Sun, Aug 05, 2018 at 10:33:52AM -0400, Russell O'Connor via bitcoin-dev wrote:
> In light of this, I revise my proposed change to make the verification
> equation
> 
> R + sG + eP = 0.

Isn't the verification equation "R + s(-G) + eP = 0" equally good, then,
since -G is a constant? (ie, at worst it's a matter of optimising the
verifier for -G as well as G)

If not, what's the actual performance impact of having to negate "s"
as part of batch verifying ~10000 signatures? It seems like it should
be trivially small to me? (scalar_negate benchmarks at 0.00359us, while
ecdsa_verify benchmarks at 66us, which I believe then reduces by a factor
of ~3 for batches of 10k schnorr sigs?)

FWIW, I'm a fan of the formulation "s = r + H(R,P,m)p" mostly because
it seems like the simplest possible way of describing the setup, and I'm
all for optimising for people being able to understand what's going on.

Cheers,
aj


From eric at voskuil.org  Mon Aug  6 05:29:31 2018
From: eric at voskuil.org (Eric Voskuil)
Date: Sun, 5 Aug 2018 22:29:31 -0700
Subject: [bitcoin-dev] Capping the size of locators [trivial protocol
 change BIP]
In-Reply-To: <CAAS2fgR=TvME_ps5oXYPeFJyjVZfaAtc=KQb5Ts2WQ4C2uO8+g@mail.gmail.com>
References: <CAAS2fgR=TvME_ps5oXYPeFJyjVZfaAtc=KQb5Ts2WQ4C2uO8+g@mail.gmail.com>
Message-ID: <6fde4ed2-9b33-95b0-558f-145e43d3bc95@voskuil.org>

Libbitcoin has implemented a 11 + log2(height) limit since version3 for
this reason. This message can be very costly if not constrained.

The presumed protocol inherently limits valid locator size for a given
recipient. IMO it's worth considering instead describing the expected
semantics of the message and thereby its *inherent* limits. Doing so
gives the recipient an upper bound on valid locator size, eliminating
the need to introduce an arbitrary limit.

I have commonly seen locators with 100 elements, I believe from
BitcoinJ. I recall posting a query on the issue to their IRC but got no
response. So it would seem that a quick survey and a limit of 64 would
not have prevented the issue of concern.

But in any case, I agree that implementations should enforce a limit.

e

On 08/05/2018 07:15 PM, Gregory Maxwell via bitcoin-dev wrote:
> Coinr8d posted on bct that the node software would process large
> locators limited only by the maximum message size yet sensible usage
> of locators only results in messages of log2(n_blocks) size. He was
> concerned that it might be a DOS vulnerability but quick measurements
> indicated to me that it likely wasn't worse than many other protocol
> messages.  It still seems silly to allow absurd locators. So I propose
> that the size of locators be limited.
> 
> However, capping them is a P2P change that could potentially result in
> network splits if older nodes would potentially produce larger
> locators (esp if triggered to produce unexpectedly large ones by
> forks).  A quick survey of node software indicated that no software I
> could find would ever produce a locator with more than 42 hashes
> before encountering other limits, so I think a limit of 64 will be
> automatically compatible with all or virtually all nodes on the
> network.
> 
> I'm bothering writing a BIP because there might be some naive
> implementation lurking out there that sends a crazy number due to
> sub-exponential backoff that would be broken by nodes enforcing a
> limit... particularly since the correct use of locators was never
> previously mandated and might not be obvious to all developers.
> 
> I take the opportunity to also specify that the locators be correctly
> ordered in terms of total work, but  don't specify that they all come
> from the same chain.
> 
> Cheers,
> 
> ==Introduction==
> 
> ===Abstract===
> 
> This document proposes limiting the locator messages used in the getblocks
> and getheaders to 64 entries and requiring that be ordered by total
> work.
> 
> ===Copyright===
> 
> This document is licensed under the 2-clause BSD license.
> 
> ==Motivation==
> 
> The Bitcoin P2P protocol uses a simple and efficient data structure
> to reconcile blockchains between nodes called a locator.  A locator
> communicates a list of known hashes which allows a peer to find a
> recent common ancestor between the best chains on two nodes.  By
> exponentially increasing the space between each entry, the locator
> allows a log() sized message to find the difference between two nodes
> with only a constant factor overhead.
> 
> Because short forks are much more common than long forks the typical
> usage of the locator includes a small number of topmost hashes before
> switching to exponential spacing.
> 
> The original Bitcoin implementation provided no explicit limit to the
> number of hashes in a locator message, allowing for absurd and
> wasteful uses like including
> all hashes in a chain.
> 
> Although locators are very inexpensive for existing node software to
> process there is no known utility for sending very large locators.
> To reduce the worst case cost of processing a locator message it would
> be useful if the size of locator messages were strictly
> bounded to sensible levels.
> 
> Common implementations have implicit limitations of 2^32 blocks and an
> exponent of 2 after the first 10 locators and so could never request
> more than 42 hashes in any case.
> 
> == Specification ==
> 
> A locator included in a getblock or getheaders message may include no more
> than 64 hashes, including the final hash_stop hash. Additionally, the blocks
> referenced by the locator must be in order of equal or decreasing total
> work.
> 
> Sending a locator that violates these requirements may result in normal
> processing, the message being ignored, a disconnection, or a ban.
> 
> Implementations that seek to handle larger numbers of blocks than afforded
> by this limit with an exponent of 2 can adaptively switch to a larger
> exponent as required to stay within the limit.
> 
> == Acknowledgements ==
> 
> Thanks to Coinr8d on bitcointalk for pointing out that node software would
> process and respond to locators with about 125,000 hashes in them.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180805/645df6f7/attachment.sig>

From roconnor at blockstream.io  Mon Aug  6 14:00:59 2018
From: roconnor at blockstream.io (Russell O'Connor)
Date: Mon, 6 Aug 2018 10:00:59 -0400
Subject: [bitcoin-dev] Schnorr signatures BIP
In-Reply-To: <20180806083925.kg5px476bzhec44b@erisian.com.au>
References: <CAPg+sBj7f+=OYXuOMdNeJk3NBG67FSQSF8Xv3seFCvwxCWq69A@mail.gmail.com>
	<A899D97B-5D47-4AB0-8A7F-57F91C58ADE1@sprovoost.nl>
	<CAPg+sBg1WuG1MihC3zBHJpxVqC2Sys7Y52iWs6JXEMmnL_tE_w@mail.gmail.com>
	<CAMZUoKm4Qs2yAc+WKgN1J2D8MDgbzNnK69kF+hbY2GDyRqdVdg@mail.gmail.com>
	<CAMZUoKm_ij4Ffzx5Wpipa5RAFA=5F06jhiTCMJhp3vAj1q+2jA@mail.gmail.com>
	<20180806083925.kg5px476bzhec44b@erisian.com.au>
Message-ID: <CAMZUoKmu6Hsvj-Ux51KZR5xLY7r4d+GOiEn=WmOjGVfqwbz0PQ@mail.gmail.com>

On Mon, Aug 6, 2018 at 4:39 AM, Anthony Towns <aj at erisian.com.au> wrote:

> On Sun, Aug 05, 2018 at 10:33:52AM -0400, Russell O'Connor via bitcoin-dev
> wrote:
> > In light of this, I revise my proposed change to make the verification
> > equation
> >
> > R + sG + eP = 0.
>
> Isn't the verification equation "R + s(-G) + eP = 0" equally good, then,
> since -G is a constant? (ie, at worst it's a matter of optimising the
> verifier for -G as well as G)
>

Yes you are right.

Thanks, I withdraw my proposal.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180806/223ea8f3/attachment.html>

From crypto at timruffing.de  Mon Aug  6 21:12:48 2018
From: crypto at timruffing.de (Tim Ruffing)
Date: Mon, 06 Aug 2018 23:12:48 +0200
Subject: [bitcoin-dev] Schnorr signatures BIP
In-Reply-To: <CAPg+sBj7f+=OYXuOMdNeJk3NBG67FSQSF8Xv3seFCvwxCWq69A@mail.gmail.com>
References: <CAPg+sBj7f+=OYXuOMdNeJk3NBG67FSQSF8Xv3seFCvwxCWq69A@mail.gmail.com>
Message-ID: <2e620d305c86f65cbff44b5fba548dc85c118f84.camel@timruffing.de>

Is it intentional that the encoding of public (and private) keys is
unspecified? I'd consider at least the encoding of the public key to be
part of the signature scheme, so ideally it should be specified already
in this BIP. On the other hand, there may be good arguments against it,
but I'm not aware of any.

This issue leads to a discrepancy between the specification and the
test vectors because the data fields of test vectors "are given as byte
arrays", including public and secret key. As a consequence, even the
Python reference implementation in the BIP draft doesn't work on test
vectors (in a strict sense).

Best,
Tim


On Fri, 2018-07-06 at 11:08 -0700, Pieter Wuille via bitcoin-dev wrote:
> Hello everyone,
> 
> Here is a proposed BIP for 64-byte elliptic curve Schnorr signatures,
> over the same curve as is currently used in ECDSA:
> https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki
> 
> It is simply a draft specification of the signature scheme itself. It
> does not concern consensus rules, aggregation, or any other
> integration into Bitcoin - those things are left for other proposals,
> which can refer to this scheme if desirable. Standardizing the
> signature scheme is a first step towards that, and as it may be
> useful
> in other contexts to have a common Schnorr scheme available, it is
> its
> own informational BIP.
> 
> If accepted, we'll work on more production-ready reference
> implementations and tests.
> 
> This is joint work with several people listed in the document.
> 
> Cheers,
> 


From apoelstra at wpsoftware.net  Sun Aug 12 16:37:35 2018
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Sun, 12 Aug 2018 16:37:35 +0000
Subject: [bitcoin-dev] Schnorr signatures BIP
In-Reply-To: <2e620d305c86f65cbff44b5fba548dc85c118f84.camel@timruffing.de>
References: <CAPg+sBj7f+=OYXuOMdNeJk3NBG67FSQSF8Xv3seFCvwxCWq69A@mail.gmail.com>
	<2e620d305c86f65cbff44b5fba548dc85c118f84.camel@timruffing.de>
Message-ID: <20180812163734.GV499@boulet.lan>


I think it's just an oversight. We should specify that we use the standard
encoding from section 2.3 of http://www.secg.org/sec1-v2.pdf except that
we allow only compressed public keys.

Andrew


On Mon, Aug 06, 2018 at 11:12:48PM +0200, Tim Ruffing via bitcoin-dev wrote:
> Is it intentional that the encoding of public (and private) keys is
> unspecified? I'd consider at least the encoding of the public key to be
> part of the signature scheme, so ideally it should be specified already
> in this BIP. On the other hand, there may be good arguments against it,
> but I'm not aware of any.
> 
> This issue leads to a discrepancy between the specification and the
> test vectors because the data fields of test vectors "are given as byte
> arrays", including public and secret key. As a consequence, even the
> Python reference implementation in the BIP draft doesn't work on test
> vectors (in a strict sense).
> 
> Best,
> Tim
> 
> 
> On Fri, 2018-07-06 at 11:08 -0700, Pieter Wuille via bitcoin-dev wrote:
> > Hello everyone,
> > 
> > Here is a proposed BIP for 64-byte elliptic curve Schnorr signatures,
> > over the same curve as is currently used in ECDSA:
> > https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki
> > 
> > It is simply a draft specification of the signature scheme itself. It
> > does not concern consensus rules, aggregation, or any other
> > integration into Bitcoin - those things are left for other proposals,
> > which can refer to this scheme if desirable. Standardizing the
> > signature scheme is a first step towards that, and as it may be
> > useful
> > in other contexts to have a common Schnorr scheme available, it is
> > its
> > own informational BIP.
> > 
> > If accepted, we'll work on more production-ready reference
> > implementations and tests.
> > 
> > This is joint work with several people listed in the document.
> > 
> > Cheers,
> > 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> 

-- 
Andrew Poelstra
Mathematics Department, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

"A goose alone, I suppose, can know the loneliness of geese
 who can never find their peace,
 whether north or south or west or east"
       --Joanna Newsom

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180812/1a5026a0/attachment.sig>

From nakagat at gmail.com  Tue Aug  7 06:35:58 2018
From: nakagat at gmail.com (nakagat)
Date: Tue, 7 Aug 2018 15:35:58 +0900
Subject: [bitcoin-dev] Multisignature for bip-schnorr
Message-ID: <CAHk9a9ct_h485MY4gk7S++FAu5FEH3PL9pd9mrrh+wA8nWaVUA@mail.gmail.com>

Hi all,

I wrote a multisignature procedure using bip-schnorr.

If you have time to review and give feedback, I?d really appreciate it.
Thanks in advance!

Multisignature
https://gist.github.com/tnakagawa/0c3bc74a9a44bd26af9b9248dfbe598b

Original
https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki#Multisignatures_and_Threshold_Signatures

-- 
nakagawa

From lipsch.hth at gmail.com  Thu Aug  9 08:38:09 2018
From: lipsch.hth at gmail.com (hth lipsch)
Date: Thu, 9 Aug 2018 10:38:09 +0200
Subject: [bitcoin-dev] bitcoin-transactions
In-Reply-To: <c6e469e7-30aa-08f5-7ce6-bfa42081bf39@gmail.com>
References: <ed8d80c4-7b11-2800-a6d0-ff2deb424072@gmail.com>
	<CAAUq485wUxGyM0m5geQ2JvBz=yMw7tXu11vdkkYuAxDfaWJkRg@mail.gmail.com>
	<c6e469e7-30aa-08f5-7ce6-bfa42081bf39@gmail.com>
Message-ID: <CA+_Z2-LiV6L=ib064NKgm3E2va0ugkwDNxbsg3PWrbzHoQ43-A@mail.gmail.com>

private-key WEF WIF online/offline transaction services, without a fee are
not in the interest of mainstream bitcoin users.(gaius germanicus)
Bitcoin has grown into a Christmas tree fancy dress in the last 9 years
where efficiency and simplicity should be mandatory and hardcoded.

on the other hand, a safe and secure tool would be a welcome step in the
right direction

lipsch hth





Op wo 1 aug. 2018 11:59 schreef Aymeric Vitte via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org>:

> You are right, that's what I have been saying for online services that ask
> for private keys, and even the seeds
>
> The problem is that people can't refrain to put their keys for example to
> get "free" coins, typically they try to use bitcoin-transactions, don't
> succeed and go put their seeds in an online service
>
> At least it gives an alternative, private keys are optional and the tool
> will output the command to use with bitcoin-transactions, and if they want
> to put directly their keys, then...
>
> "Move your coins by yourself" refers more to "don't get trapped by your
> wallet(s) or things that you don't master like multisig, segwit, bech32,
> etc"
>
> As I said the idea would be to end up with an offline tool should some
> people support/finance the effort
>
> Le 01/08/2018 ? 07:45, Marcel Jamin a ?crit :
>
> IMHO you should almost never publish a service that asks users for private
> keys.
>
> A warning isn't enough. Your server might get compromised.
>
> "Move your coins by yourself" isn't even correct if your server is
> involved.
>
> On Tue, 31 Jul 2018 at 13:26, Aymeric Vitte via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> I know this list is not to advertise personal projects but
>> https://peersm.com/wallet might be of some interest, this is the web
>> interface for https://github.com/Ayms/bitcoin-transactions since
>> apparently quasi nobody succeeds to use it
>>
>> As far as I know (and surprisingly) this is the only online tool that
>> converts bech32 addresses (Sipa's one does not output something
>> understandable by everybody, the tool is using his code), the only one
>> that converts from any address to any address, maybe the only one that
>> decodes simply redeem scripts and probably the only one that allows to
>> create transactions by its own (the advanced mode is not implemented for
>> now but will be soon)
>>
>> Ideally it should be an offline tool if there is some incentive to do
>> so, so of course it is not advised to use his private keys for now
>>
>> Maybe they are mistaken but some users are reporting invalid bech32
>> addresses from their Electrum wallet, after segwit, bech32 confusion
>> seems to be the topic of the moment
>>
>> Regards
>>
>> Aymeric
>>
>> --
>> Bitcoin transactions made simple:
>> https://github.com/Ayms/bitcoin-transactions
>> Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
>> Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
>> Get the torrent dynamic blocklist: http://peersm.com/getblocklist
>> Check the 10 M passwords list: http://peersm.com/findmyass
>> Anti-spies and private torrents, dynamic blocklist:
>> http://torrent-live.org
>> Peersm : http://www.peersm.com
>> torrent-live: https://github.com/Ayms/torrent-live
>> node-Tor : https://www.github.com/Ayms/node-Tor
>> GitHub : https://www.github.com/Ayms
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
> --
> Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
> Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
> Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
> Get the torrent dynamic blocklist: http://peersm.com/getblocklist
> Check the 10 M passwords list: http://peersm.com/findmyass
> Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
> Peersm : http://www.peersm.com
> torrent-live: https://github.com/Ayms/torrent-live
> node-Tor : https://www.github.com/Ayms/node-Tor
> GitHub : https://www.github.com/Ayms
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180809/222cfc52/attachment.html>

From sergio.d.lerner at gmail.com  Fri Aug 10 00:21:17 2018
From: sergio.d.lerner at gmail.com (Sergio Demian Lerner)
Date: Thu, 9 Aug 2018 21:21:17 -0300
Subject: [bitcoin-dev] Simple change to the "merkleblock" command to protect
 from SPV proof extension attacks
Message-ID: <CAKzdR-oVncNaEA_+WHvdmLoD=SF=0AgpiN6WVXdbvnY6=NtYiA@mail.gmail.com>

Hi,
 While fixing RSK's SPV bridge I came up with an idea to fix the
MERKLEBLOCK command to prevent rogue peers from attacking SPV peers using
Bitcoin's Merkle tree structure flaws. The most annoying attack is the one
that tries to confuse a victim peer into thinking a transaction is an inner
node, extending such node with a new right-sided branch with a fake
transaction (*) .

The old idea to soft-fork Bitcoin to make invalid 64-byte transactions is
attractive, but also a coordination problem that could be avoided with this
new proposal.

The idea is simple, and it's not a fork, but a network protocol improvement.
Let A be the hash digest that must be combined with the hash digest B, such
that the upper node hash is SHA256(SHA256(A | B)).
Therefore A = SHA256(SHA256(X)) and B = SHA256(SHA256(Y)), and X and Y are
either Bitcoin transactions or other inner nodes.
Instead of storing A, the merkleblock structure should store a pre-image of
A, or SHA256(X).
If the block only has the coinbase, nothing is done.
The pre-image change could be done to both left and right hashes, but it's
enough to do it to all left-side hashes that do not have children in the
partial merkle tree structure (let's call them terminal hahes. to avoid
confusion with leaf hashes).

Verifiers (SPV nodes) would apply a single SHA256() operation to the
left-sided terminal hashes before combining them. The cost to the verifier
is in the worse case only 33% more.

This basically limits the attacker's ability to supply chosen-hash digests
in order to build a transaction. Because the left side contains most of the
previn hash, the attacker would need to bruteforce a huge space (about 208
bits) in order to come up with a pre-image that maps to a owned previn.
Meet-in-the-middle attacks would be expensive as UTXOs are not free.

To implement this change, a new command MERKLEBLOCK2 could be implemented
or the protocol version could be used to differentiate between the two
modes of the MERKLEBLOCK command.

If the idea gets community support, I may write the BIP/code or invite
anyone to do it.

regards

 (*)
https://bitslog.wordpress.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180809/c747d596/attachment-0001.html>

From pieter.wuille at gmail.com  Mon Aug 13 18:56:41 2018
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Mon, 13 Aug 2018 11:56:41 -0700
Subject: [bitcoin-dev] Witness serialization in PSBT non-witness UTXOs
Message-ID: <CAPg+sBgf-qSh0UVZF5RZnO+nygF-HN9=LL1gxE1JfXKrQhBbmw@mail.gmail.com>

Hello all,

BIP174 currently specifies that non-witness UTXOs (the transactions
being spent by non-witness inputs) should be serialized in network
format.

I believe there are two issues with this.

1. Even in case the transaction whose output being spent itself has a
witness, this witness is immaterial to PSBT. It's only there to be
able to verify the txid commits to the output/amount being spent,
which can be done without witness.

2. "Network format" is a bit ambiguous. We can imagine a future
softfork that introduces a new type of witness. Network format could
be interpreted as including that new witness type, which is clearly
unnecessary (by the above argument), and would gratuitously break
compatibility with existing signers if implemented pedantically.

So my suggestion is to update the specification to state that
non-witness UTXOs must be serialized without witness. If it's too late
for that, it should instead be updated to explicitly specify with or
witnout witness, but it's safe to drop the witness.

Opinions?

Cheers,

-- 
Pieter

From achow101-lists at achow101.com  Mon Aug 13 20:32:33 2018
From: achow101-lists at achow101.com (Achow101)
Date: Mon, 13 Aug 2018 20:32:33 +0000
Subject: [bitcoin-dev] Witness serialization in PSBT non-witness UTXOs
In-Reply-To: <CAPg+sBgf-qSh0UVZF5RZnO+nygF-HN9=LL1gxE1JfXKrQhBbmw@mail.gmail.com>
References: <CAPg+sBgf-qSh0UVZF5RZnO+nygF-HN9=LL1gxE1JfXKrQhBbmw@mail.gmail.com>
Message-ID: <7A_00K2wcfdgZMimY9aZ4gUFWyVIPOVrnueAFAosM-S-gIIoHXez6v5GcC8OrfTULz0NZ6n1g3T9jfVbgBvU_jKbgmNd-zlVqQVOC00NphA=@achow101.com>

Hi,

Since the BIP is already in proposed status, I think that we should specify the non-witness utxo to just be "witness or non-witness" serialization. This maintains compatibility with things that have already implemented but also maintains the forwards compatibility that is needed.

Andrew


??????? Original Message ???????
On August 13, 2018 11:56 AM, Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hello all,
>
> BIP174 currently specifies that non-witness UTXOs (the transactions
> being spent by non-witness inputs) should be serialized in network
> format.
>
> I believe there are two issues with this.
>
> 1.  Even in case the transaction whose output being spent itself has a
>     witness, this witness is immaterial to PSBT. It's only there to be
>     able to verify the txid commits to the output/amount being spent,
>     which can be done without witness.
>
> 2.  "Network format" is a bit ambiguous. We can imagine a future
>     softfork that introduces a new type of witness. Network format could
>     be interpreted as including that new witness type, which is clearly
>     unnecessary (by the above argument), and would gratuitously break
>     compatibility with existing signers if implemented pedantically.
>
>     So my suggestion is to update the specification to state that
>     non-witness UTXOs must be serialized without witness. If it's too late
>     for that, it should instead be updated to explicitly specify with or
>     witnout witness, but it's safe to drop the witness.
>
>     Opinions?
>
>     Cheers,
>
>     --
>     Pieter
>
>
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From greg at xiph.org  Mon Aug 13 20:39:38 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Mon, 13 Aug 2018 20:39:38 +0000
Subject: [bitcoin-dev] Witness serialization in PSBT non-witness UTXOs
In-Reply-To: <7A_00K2wcfdgZMimY9aZ4gUFWyVIPOVrnueAFAosM-S-gIIoHXez6v5GcC8OrfTULz0NZ6n1g3T9jfVbgBvU_jKbgmNd-zlVqQVOC00NphA=@achow101.com>
References: <CAPg+sBgf-qSh0UVZF5RZnO+nygF-HN9=LL1gxE1JfXKrQhBbmw@mail.gmail.com>
	<7A_00K2wcfdgZMimY9aZ4gUFWyVIPOVrnueAFAosM-S-gIIoHXez6v5GcC8OrfTULz0NZ6n1g3T9jfVbgBvU_jKbgmNd-zlVqQVOC00NphA=@achow101.com>
Message-ID: <CAAS2fgS7umEfkE3PkJexgc_jo5bWpWkozxKW6rQTS5A-FZXt-g@mail.gmail.com>

An alternative is to require reading either or but also require
writing without the witness.  It's likely that two years from now,
nothing will write the witnesses, and the requirement to support
reading them could be dropped.
On Mon, Aug 13, 2018 at 8:32 PM Achow101 via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Hi,
>
> Since the BIP is already in proposed status, I think that we should specify the non-witness utxo to just be "witness or non-witness" serialization. This maintains compatibility with things that have already implemented but also maintains the forwards compatibility that is needed.
>
> Andrew
>
>
> ??????? Original Message ???????
> On August 13, 2018 11:56 AM, Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > Hello all,
> >
> > BIP174 currently specifies that non-witness UTXOs (the transactions
> > being spent by non-witness inputs) should be serialized in network
> > format.
> >
> > I believe there are two issues with this.
> >
> > 1.  Even in case the transaction whose output being spent itself has a
> >     witness, this witness is immaterial to PSBT. It's only there to be
> >     able to verify the txid commits to the output/amount being spent,
> >     which can be done without witness.
> >
> > 2.  "Network format" is a bit ambiguous. We can imagine a future
> >     softfork that introduces a new type of witness. Network format could
> >     be interpreted as including that new witness type, which is clearly
> >     unnecessary (by the above argument), and would gratuitously break
> >     compatibility with existing signers if implemented pedantically.
> >
> >     So my suggestion is to update the specification to state that
> >     non-witness UTXOs must be serialized without witness. If it's too late
> >     for that, it should instead be updated to explicitly specify with or
> >     witnout witness, but it's safe to drop the witness.
> >
> >     Opinions?
> >
> >     Cheers,
> >
> >     --
> >     Pieter
> >
> >
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From sergio.d.lerner at gmail.com  Tue Aug 14 15:26:25 2018
From: sergio.d.lerner at gmail.com (Sergio Demian Lerner)
Date: Tue, 14 Aug 2018 12:26:25 -0300
Subject: [bitcoin-dev] Fwd: Simple change to the "merkleblock" command to
 protect from SPV proof extension attacks
In-Reply-To: <CAKzdR-oVncNaEA_+WHvdmLoD=SF=0AgpiN6WVXdbvnY6=NtYiA@mail.gmail.com>
References: <CAKzdR-oVncNaEA_+WHvdmLoD=SF=0AgpiN6WVXdbvnY6=NtYiA@mail.gmail.com>
Message-ID: <CAKzdR-rziKesAJVHSoCOg39Nh3zqst_MB_Q_zCGYorRYFMqhAw@mail.gmail.com>

Hi,
 While fixing RSK's SPV bridge I came up with an idea to fix the
MERKLEBLOCK command to prevent rogue peers from attacking SPV peers using
Bitcoin's Merkle tree structure flaws. The most annoying attack is the one
that tries to confuse a victim peer into thinking a transaction is an inner
node, extending such node with a new right-sided branch with a fake
transaction (*) .

The old idea to soft-fork Bitcoin to make invalid 64-byte transactions is
attractive, but also a coordination problem that could be avoided with this
new proposal.

The idea is simple, and it's not a fork, but a network protocol improvement.
Let A be the hash digest that must be combined with the hash digest B, such
that the upper node hash is SHA256(SHA256(A | B)).
Therefore A = SHA256(SHA256(X)) and B = SHA256(SHA256(Y)), and X and Y are
either Bitcoin transactions or other inner nodes.
Instead of storing A, the merkleblock structure should store a pre-image of
A, or SHA256(X).
If the block only has the coinbase, nothing is done.
The pre-image change could be done to both left and right hashes, but it's
enough to do it to all left-side hashes that do not have children in the
partial merkle tree structure (let's call them terminal hahes. to avoid
confusion with leaf hashes).

Verifiers (SPV nodes) would apply a single SHA256() operation to the
left-sided terminal hashes before combining them. The cost to the verifier
is in the worse case only 33% more.

This basically limits the attacker's ability to supply chosen-hash digests
in order to build a transaction. Because the left side contains most of the
previn hash, the attacker would need to bruteforce a huge space (about 208
bits) in order to come up with a pre-image that maps to a owned previn.
Meet-in-the-middle attacks would be expensive as UTXOs are not free.

To implement this change, a new command MERKLEBLOCK2 could be implemented
or the protocol version could be used to differentiate between the two
modes of the MERKLEBLOCK command.

If the idea gets community support, I may write the BIP/code or invite
anyone to do it.

regards

 (*)
https://bitslog.wordpress.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180814/51d0f150/attachment.html>

From ChristopherA at lifewithalacrity.com  Tue Aug 14 18:34:13 2018
From: ChristopherA at lifewithalacrity.com (Christopher Allen)
Date: Tue, 14 Aug 2018 11:34:13 -0700
Subject: [bitcoin-dev] Claiming an OP_RETURN Prefix
Message-ID: <CACrqygD_5jpkTvvcFo7eHxZfiH4evzZQc=YB=opBo6M_0EsZTQ@mail.gmail.com>

On August 5, 2018 9:11:26 PM UTC, Lautaro Dragan via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>Should we actually be using the BIP process to claim a prefix?

I recommend against using an op_return prefix, as they allow for
transaction censorship.

In fact, in our case, where we use an IPFS hash in an op_return, we remove
the IPFS multihash prefix information to post a ?bare? SHA256 hash to look
like many other hashes being posted in op_returns, to minimize any ability
for a miner to identify our transaction. The more projects that do this the
better ? a form of herd immunity.

Longer term I?m looking for more responsible ways to publish this hash, for
instance have the hash be in the witness script data, so that it can be
easily purged from nodes that do not wish to preserve it and prevent block
size bloat. However, to do so everyone has to do it the same way, ideally
have it look like any other transaction. I?ve not quite seen a solid
proposal for best practices here.

? Christopher Allen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180814/5c7a9e75/attachment.html>

From jtimon at jtimon.cc  Wed Aug 15 20:33:43 2018
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Wed, 15 Aug 2018 22:33:43 +0200
Subject: [bitcoin-dev] Claiming an OP_RETURN Prefix
In-Reply-To: <CACrqygD_5jpkTvvcFo7eHxZfiH4evzZQc=YB=opBo6M_0EsZTQ@mail.gmail.com>
References: <CACrqygD_5jpkTvvcFo7eHxZfiH4evzZQc=YB=opBo6M_0EsZTQ@mail.gmail.com>
Message-ID: <CABm2gDpOvXg7_Yv9jkX=+a7ALXHgA5-4Oh4ZQnzp=pw5-0bZPA@mail.gmail.com>

op_return outputs can be pruned because they are not spendable.
putting a hash on in the witness script data won't make things better
(it would actually make them worse) and it definitely doesn't help
"block size bloat".
I think I'm missing some context, but if you're using op_return purely
for timestamping I would recommend using pay 2 contract  instead.

On Tue, Aug 14, 2018 at 8:34 PM, Christopher Allen via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> On August 5, 2018 9:11:26 PM UTC, Lautaro Dragan via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>Should we actually be using the BIP process to claim a prefix?
>
> I recommend against using an op_return prefix, as they allow for transaction
> censorship.
>
> In fact, in our case, where we use an IPFS hash in an op_return, we remove
> the IPFS multihash prefix information to post a ?bare? SHA256 hash to look
> like many other hashes being posted in op_returns, to minimize any ability
> for a miner to identify our transaction. The more projects that do this the
> better ? a form of herd immunity.
>
> Longer term I?m looking for more responsible ways to publish this hash, for
> instance have the hash be in the witness script data, so that it can be
> easily purged from nodes that do not wish to preserve it and prevent block
> size bloat. However, to do so everyone has to do it the same way, ideally
> have it look like any other transaction. I?ve not quite seen a solid
> proposal for best practices here.
>
> ? Christopher Allen
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From judecn at gmail.com  Wed Aug 15 20:40:02 2018
From: judecn at gmail.com (Jude Nelson)
Date: Wed, 15 Aug 2018 20:40:02 +0000
Subject: [bitcoin-dev] Claiming an OP_RETURN Prefix
In-Reply-To: <CABm2gDpOvXg7_Yv9jkX=+a7ALXHgA5-4Oh4ZQnzp=pw5-0bZPA@mail.gmail.com>
References: <CACrqygD_5jpkTvvcFo7eHxZfiH4evzZQc=YB=opBo6M_0EsZTQ@mail.gmail.com>
	<CABm2gDpOvXg7_Yv9jkX=+a7ALXHgA5-4Oh4ZQnzp=pw5-0bZPA@mail.gmail.com>
Message-ID: <CAFsQEP1ttFbAZZzz49Jg3E3jbZjztNRDVGJAKOWULYzrn+7obQ@mail.gmail.com>

> I recommend against using an op_return prefix,
> as they allow for transaction censorship.

> In fact, in our case, where we use an IPFS hash in
> an op_return, we remove the IPFS multihash prefix
> information to post a ?bare? SHA256 hash to look like
> many other hashes being posted in op_returns, to
> minimize any ability for a miner to identify our transaction.
> The more projects that do this the better ? a form of herd
> immunity.

Can a miner identify which transactions came from your software simply by
running a copy themselves?  If so, then they can censor your transactions
no matter how you encode them.

On Wed, Aug 15, 2018 at 8:34 PM Jorge Tim?n via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> op_return outputs can be pruned because they are not spendable.
> putting a hash on in the witness script data won't make things better
> (it would actually make them worse) and it definitely doesn't help
> "block size bloat".
> I think I'm missing some context, but if you're using op_return purely
> for timestamping I would recommend using pay 2 contract  instead.
>
> On Tue, Aug 14, 2018 at 8:34 PM, Christopher Allen via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > On August 5, 2018 9:11:26 PM UTC, Lautaro Dragan via bitcoin-dev
> > <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>Should we actually be using the BIP process to claim a prefix?
> >
> > I recommend against using an op_return prefix, as they allow for
> transaction
> > censorship.
> >
> > In fact, in our case, where we use an IPFS hash in an op_return, we
> remove
> > the IPFS multihash prefix information to post a ?bare? SHA256 hash to
> look
> > like many other hashes being posted in op_returns, to minimize any
> ability
> > for a miner to identify our transaction. The more projects that do this
> the
> > better ? a form of herd immunity.
> >
> > Longer term I?m looking for more responsible ways to publish this hash,
> for
> > instance have the hash be in the witness script data, so that it can be
> > easily purged from nodes that do not wish to preserve it and prevent
> block
> > size bloat. However, to do so everyone has to do it the same way, ideally
> > have it look like any other transaction. I?ve not quite seen a solid
> > proposal for best practices here.
> >
> > ? Christopher Allen
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180815/e8fe75f4/attachment-0001.html>

From pete at petertodd.org  Wed Aug 15 21:46:18 2018
From: pete at petertodd.org (Peter Todd)
Date: Wed, 15 Aug 2018 21:46:18 +0000
Subject: [bitcoin-dev] Claiming an OP_RETURN Prefix
In-Reply-To: <CABm2gDpOvXg7_Yv9jkX=+a7ALXHgA5-4Oh4ZQnzp=pw5-0bZPA@mail.gmail.com>
References: <CACrqygD_5jpkTvvcFo7eHxZfiH4evzZQc=YB=opBo6M_0EsZTQ@mail.gmail.com>
	<CABm2gDpOvXg7_Yv9jkX=+a7ALXHgA5-4Oh4ZQnzp=pw5-0bZPA@mail.gmail.com>
Message-ID: <367FF84A-219E-4735-B9F7-09CEFEB20587@petertodd.org>



On August 15, 2018 8:33:43 PM UTC, "Jorge Tim?n via bitcoin-dev" <bitcoin-dev at lists.linuxfoundation.org> wrote:
>op_return outputs can be pruned because they are not spendable.
>putting a hash on in the witness script data won't make things better
>(it would actually make them worse) and it definitely doesn't help
>"block size bloat".
>I think I'm missing some context, but if you're using op_return purely
>for timestamping I would recommend using pay 2 contract  instead.

If you're *actually* just doing timestamping you're better off using OpenTimestamps. But many times people think they're just doing timestamping in reality mere timestamps are insufficient for the task.

Notably, this is something the Satoshi Bitcoin white paper gets wrong, incorrectly describing Bitcoin as a timestamping system: timestamping is insufficient to prevent double-spends.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org

From ChristopherA at lifewithalacrity.com  Wed Aug 15 21:54:50 2018
From: ChristopherA at lifewithalacrity.com (Christopher Allen)
Date: Wed, 15 Aug 2018 14:54:50 -0700
Subject: [bitcoin-dev] Claiming an OP_RETURN Prefix
In-Reply-To: <CAFsQEP1ttFbAZZzz49Jg3E3jbZjztNRDVGJAKOWULYzrn+7obQ@mail.gmail.com>
References: <CACrqygD_5jpkTvvcFo7eHxZfiH4evzZQc=YB=opBo6M_0EsZTQ@mail.gmail.com>
	<CABm2gDpOvXg7_Yv9jkX=+a7ALXHgA5-4Oh4ZQnzp=pw5-0bZPA@mail.gmail.com>
	<CAFsQEP1ttFbAZZzz49Jg3E3jbZjztNRDVGJAKOWULYzrn+7obQ@mail.gmail.com>
Message-ID: <CACrqygBJ=RdPpHqHzPNqqj0V2w5XL6GVtKobOWnj1EsVykUS8w@mail.gmail.com>

On Wed, Aug 15, 2018 at 2:24 PM Jude Nelson via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Can a miner identify which transactions came from your software simply by
> running a copy themselves?  If so, then they can censor your transactions
> no matter how you encode them.
>

Possibly, but in the IPFS case I suspect the latency required to inspect
all hashes would likely  impact the ability of the miner to succeed in the
block. (True? I don?t touch mining software.)

Thus as long as all hashes look the same, and there are multiple content
addressable schemes that use hashes that have to be searched in order to
know to censor, you have to censor all or none.

? Christopher Allen

>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180815/de4d77d3/attachment.html>

From luke at dashjr.org  Thu Aug 16 01:06:53 2018
From: luke at dashjr.org (Luke Dashjr)
Date: Thu, 16 Aug 2018 01:06:53 +0000
Subject: [bitcoin-dev] Claiming an OP_RETURN Prefix
In-Reply-To: <CACrqygBJ=RdPpHqHzPNqqj0V2w5XL6GVtKobOWnj1EsVykUS8w@mail.gmail.com>
References: <CACrqygD_5jpkTvvcFo7eHxZfiH4evzZQc=YB=opBo6M_0EsZTQ@mail.gmail.com>
	<CAFsQEP1ttFbAZZzz49Jg3E3jbZjztNRDVGJAKOWULYzrn+7obQ@mail.gmail.com>
	<CACrqygBJ=RdPpHqHzPNqqj0V2w5XL6GVtKobOWnj1EsVykUS8w@mail.gmail.com>
Message-ID: <201808160106.54960.luke@dashjr.org>

On Wednesday 15 August 2018 21:54:50 Christopher Allen via bitcoin-dev wrote:
> On Wed, Aug 15, 2018 at 2:24 PM Jude Nelson via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> > Can a miner identify which transactions came from your software simply by
> > running a copy themselves?  If so, then they can censor your transactions
> > no matter how you encode them.
>
> Possibly, but in the IPFS case I suspect the latency required to inspect
> all hashes would likely  impact the ability of the miner to succeed in the
> block. (True? I don?t touch mining software.)

Not true at all.

> Thus as long as all hashes look the same, and there are multiple content
> addressable schemes that use hashes that have to be searched in order to
> know to censor, you have to censor all or none.

Choosing not to mine transactions is not censorship.

Luke

From luke at dashjr.org  Thu Aug 16 02:37:11 2018
From: luke at dashjr.org (Luke Dashjr)
Date: Thu, 16 Aug 2018 02:37:11 +0000
Subject: [bitcoin-dev] Claiming an OP_RETURN Prefix
In-Reply-To: <CAK6DEso4-R78qLtQLfGxNUML5B1Y8gxXXVzrzmSwkPabMfkW+w@mail.gmail.com>
References: <CACrqygD_5jpkTvvcFo7eHxZfiH4evzZQc=YB=opBo6M_0EsZTQ@mail.gmail.com>
	<201808160106.54960.luke@dashjr.org>
	<CAK6DEso4-R78qLtQLfGxNUML5B1Y8gxXXVzrzmSwkPabMfkW+w@mail.gmail.com>
Message-ID: <201808160237.12395.luke@dashjr.org>

On Thursday 16 August 2018 02:22:21 Lautaro Dragan wrote:
> > Choosing not to mine transactions is not censorship.
>
> Is it not, if for political rather than economical reasons? These
> transactions pay fees like any other.

Miners have always chosen transaction on "political" basises, and doing such 
is their right. That's why the system is supposed to be comprised of many 
miners, all with their own policies - so the choices of one do not impact the 
overall ability to spend (presumably only spam should be rejected by all 
miners).

For fees to themselves justify the cost of a transaction, they would need to 
be magnitudes higher than we've ever seen on Bitcoin. But even then, nobody 
has an obligation to accept payment, no matter how reasonable it is, for a 
service they don't want to provide.

Luke

From lautarodragan at gmail.com  Thu Aug 16 02:22:21 2018
From: lautarodragan at gmail.com (Lautaro Dragan)
Date: Wed, 15 Aug 2018 23:22:21 -0300
Subject: [bitcoin-dev] Claiming an OP_RETURN Prefix
In-Reply-To: <201808160106.54960.luke@dashjr.org>
References: <CACrqygD_5jpkTvvcFo7eHxZfiH4evzZQc=YB=opBo6M_0EsZTQ@mail.gmail.com>
	<CAFsQEP1ttFbAZZzz49Jg3E3jbZjztNRDVGJAKOWULYzrn+7obQ@mail.gmail.com>
	<CACrqygBJ=RdPpHqHzPNqqj0V2w5XL6GVtKobOWnj1EsVykUS8w@mail.gmail.com>
	<201808160106.54960.luke@dashjr.org>
Message-ID: <CAK6DEso4-R78qLtQLfGxNUML5B1Y8gxXXVzrzmSwkPabMfkW+w@mail.gmail.com>

Thanks Christopher.

> op_return outputs can be pruned because they are not spendable.
putting a hash on in the witness script data won't make things better
(it would actually make them worse) and it definitely doesn't help
"block size bloat".

Agreed

> I think I'm missing some context, but if you're using op_return purely
for timestamping I would recommend using pay 2 contract  instead.

And

> If you're *actually* just doing timestamping you're better off using
OpenTimestamps. But many times people think they're just doing timestamping
in reality mere timestamps are insufficient for the task.

No, it's not only timestamping. Think of it as storing the URL of something
in the OP_RETURN, only that instead of a URL it's a hash. But it's not just
the hash of the work ? IPFS adds a few other elements that affect this
hash, so calculating it out of the file being added won't do. Also, the
batching OTS uses and the batching we use (using IPFS directories) are
incompatible.

> Can a miner identify which transactions came from your software simply by
running a copy themselves?  If so, then they can censor your transactions
no matter how you encode them.

Miners would have to try and `ipfs cat` every OP_RETURN of every
transaction (maybe filtering by byte length), which is a relatively high
cost operation. But such a script is straight forward to write and can be
hosted in a cheap AWS machine. We're talking about less than a week of
coding and less than a hundred bucks of hosting, so if they're out to get
you it won't make a difference.

> Choosing not to mine transactions is not censorship.

Is it not, if for political rather than economical reasons? These
transactions pay fees like any other.



El mi?., 15 de ago. de 2018 a la(s) 22:08, Luke Dashjr via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> escribi?:

> On Wednesday 15 August 2018 21:54:50 Christopher Allen via bitcoin-dev
> wrote:
> > On Wed, Aug 15, 2018 at 2:24 PM Jude Nelson via bitcoin-dev <
> > bitcoin-dev at lists.linuxfoundation.org> wrote:
> > > Can a miner identify which transactions came from your software simply
> by
> > > running a copy themselves?  If so, then they can censor your
> transactions
> > > no matter how you encode them.
> >
> > Possibly, but in the IPFS case I suspect the latency required to inspect
> > all hashes would likely  impact the ability of the miner to succeed in
> the
> > block. (True? I don?t touch mining software.)
>
> Not true at all.
>
> > Thus as long as all hashes look the same, and there are multiple content
> > addressable schemes that use hashes that have to be searched in order to
> > know to censor, you have to censor all or none.
>
> Choosing not to mine transactions is not censorship.
>
> Luke
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180815/ae997542/attachment-0001.html>

From bitcoin-dev at rgrant.org  Thu Aug 16 17:32:25 2018
From: bitcoin-dev at rgrant.org (Ryan Grant)
Date: Thu, 16 Aug 2018 17:32:25 +0000
Subject: [bitcoin-dev] Claiming an OP_RETURN Prefix
In-Reply-To: <CAFsQEP1ttFbAZZzz49Jg3E3jbZjztNRDVGJAKOWULYzrn+7obQ@mail.gmail.com>
References: <CACrqygD_5jpkTvvcFo7eHxZfiH4evzZQc=YB=opBo6M_0EsZTQ@mail.gmail.com>
	<CABm2gDpOvXg7_Yv9jkX=+a7ALXHgA5-4Oh4ZQnzp=pw5-0bZPA@mail.gmail.com>
	<CAFsQEP1ttFbAZZzz49Jg3E3jbZjztNRDVGJAKOWULYzrn+7obQ@mail.gmail.com>
Message-ID: <CAMnpzfqLQYboGgGHVYF_SjOs_nZd8cvD3chydcu1W1Ef_kLRPA@mail.gmail.com>

On Wed, Aug 15, 2018 at 8:40 PM, Jude Nelson via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Can a miner identify which transactions came from your software simply by
> running a copy themselves?  If so, then they can censor your transactions no
> matter how you encode them.

The hash of the file is deterministic and `ipfs add` tells us what it
is whether the network is connected or disconnected.  We don't upload
files to IPFS until the transaction has settled with several
confirmations.

From pete at petertodd.org  Fri Aug 17 18:58:50 2018
From: pete at petertodd.org (Peter Todd)
Date: Fri, 17 Aug 2018 20:58:50 +0200 (CEST)
Subject: [bitcoin-dev] =?utf-8?q?Brock_Pierce=3F?=
Message-ID: <20180817190030.B7807D62AA@emkei.cz>

>From a censorship resistance point of view, I don't see EOS as a viable solution period. And anything supported by a pedo like Brock is just begging for failure.

From pete at petertodd.org  Fri Aug 17 18:57:13 2018
From: pete at petertodd.org (Peter Todd)
Date: Fri, 17 Aug 2018 20:57:13 +0200 (CEST)
Subject: [bitcoin-dev] =?utf-8?q?Brock_Pierce=3F?=
Message-ID: <20180817190032.ECAAED62AC@emkei.cz>

>From a censorship resistance point of view, I don't see EOS as a viable solution period. And anything supported by a pedo like Brock is just begging for failure.

From pete at petertodd.org  Fri Aug 17 19:15:49 2018
From: pete at petertodd.org (Peter Todd)
Date: Fri, 17 Aug 2018 19:15:49 +0000
Subject: [bitcoin-dev] Brock Pierce?
In-Reply-To: <20180817190030.B7807D62AA@emkei.cz>
References: <20180817190030.B7807D62AA@emkei.cz>
Message-ID: <AAC8FDD1-8D4E-4E35-8EFF-8283D3643C4F@petertodd.org>

-----BEGIN PGP MESSAGE-----

hQEMA8xUMVQPvvGFAQf9HMeq6x4tXQlQEOeVj6IHlY7JRBREjSbmz9vPp9UyZs/v
xCZ4vE6J0AHJBIri8o96Sqfl4JV81DwEg17ex5WgVzrh+7F33o6fEMwm0dnH1Zl+
yyhbJZzequgZIUHySUanmZMR2k+tPiuUEMXkWKQ0iKOv/mttUnN5M5kL/qMX0dlV
oN1u3l5B1XRjLZA6ZZzhMNDztFsUh4RxrIJmKMyZEgZP0ouhLwPvOIP8bXC6VyED
Y3oIy7eDxr6Dydypg1ajxuKF5sqCZOSpdCGaiS0npz/a8rqLz8SCo2UvZijabYpx
RvZqArXJwH1jZ68ak7q2NlGM7w/bVzV1LvuQDqA+OtLCkQEjH5txfrszBDz5HIsZ
T5QEEDs9FeEd317o05BLv5aD7pOaoGQ+7sMOgWqVUB4DLi8pyYTdz4knEU2SLgcq
CVcuJYm2fEoQRVJ+JMmf97kiw00A2RvuKYkYK2FzNGKH9PMWgm5xmGrzkPGULnMW
76ID5XQHE6qCae5ZqP2cthn3CDmVf7+GRQ5Snyw0Bg4drxKFo1W3RN4Hi70fDAk5
nBZv5Epdex23yqG7BQh/glT5V3Xsta9j3k1S4YR5TyOrOkgYM8uDj5EQ2Eh+XcLZ
soXMa64ROl87VGRTpjp+sSjd5hvr8VTiXHGSnbSrJes3H6Vt156507zmQOvqI/Bv
fgoPEFc+rMBL/iuf2/dWh5gbEm4qIy3X5DjmPZszpVUoEktFsaqN+A4fjBaeH3cv
s/NPVMWL7nwg5r8+icrZ9FOv58WnLljL/T7M29eanS9Ktc5+WuH4w6vgn73HTUPX
IV6IKl7QbrFrDf9FuSGHf7i7w6RAgwX0FKDaAra5hx5VEOUeSTAUZAzSqdcXgxIJ
oJzfPxrvEh9Eu6uzTF2fBtX6QrQ9qbAr++R8Bre+003/x/QtIlk0Cp14vVOljr7o
dnt+VwB0p5UCXWcPdK/tVdbv3D1+9gYaMZbYs9NJiDT/oeX4V1oHTBH+WXf+DaDQ
Wb5bhmr32oEngl78IF7n0hXVpcF1qzikw2jWwI4oVRe6swcEEOUOj6w+3MVqZZuN
+hrLU4CkxC38pHzBPGOGKcAD3ceUeUZUx+YIG3yy9gn4dJ/ZdUEFbywIOtOgpatc
M17OkJY7vxENKKzu9lib38NVL32lpmFbvd5epONyfka0pN4r5mj698KuvS3gl3/E
Svkd/8itfYTIuCyoriLup+ohmIiib1XZysEeN1Iv22VLak6cvzg6L3cFgsGPUasw
KzwyqTBVukF+07tl06M6VjFHp9WFx1gRN0SospSZYrtn4GpoK3rxELBy0gB2xCdk
dWy5oTFZrVtMD1oX6UQ1w88wXJzheY7sw32deEbE/vbCyTg4wXt05qauCKJy+Tsc
HLM9r6j5Jel3uCvnWia4EcPI2Kg7/C+/gLPGq12JaNGFwG1VIHpW9pr04CMOEr+3
EtszVbl9V5h0MZ3/nHTv8RINtQ==
=t7vZ
-----END PGP MESSAGE-----

From pete at petertodd.org  Fri Aug 17 19:18:19 2018
From: pete at petertodd.org (Peter Todd)
Date: Fri, 17 Aug 2018 19:18:19 +0000
Subject: [bitcoin-dev] Brock Pierce?
In-Reply-To: <AAC8FDD1-8D4E-4E35-8EFF-8283D3643C4F@petertodd.org>
References: <20180817190030.B7807D62AA@emkei.cz>
	<AAC8FDD1-8D4E-4E35-8EFF-8283D3643C4F@petertodd.org>
Message-ID: <DC3158DF-9C7E-487B-B4B5-010128F9CD2D@petertodd.org>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

<try that afain, stupid k9mail>

Fake.

Note how this message isn't PGP signed, and the headers show it coming from a different server than my usual one.

Not at a computer to check, but likely the SPF filtering on the list mail server isn't working.

On August 17, 2018 7:15:49 PM UTC, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>-----BEGIN PGP MESSAGE-----
>
>hQEMA8xUMVQPvvGFAQf9HMeq6x4tXQlQEOeVj6IHlY7JRBREjSbmz9vPp9UyZs/v
>xCZ4vE6J0AHJBIri8o96Sqfl4JV81DwEg17ex5WgVzrh+7F33o6fEMwm0dnH1Zl+
>yyhbJZzequgZIUHySUanmZMR2k+tPiuUEMXkWKQ0iKOv/mttUnN5M5kL/qMX0dlV
>oN1u3l5B1XRjLZA6ZZzhMNDztFsUh4RxrIJmKMyZEgZP0ouhLwPvOIP8bXC6VyED
>Y3oIy7eDxr6Dydypg1ajxuKF5sqCZOSpdCGaiS0npz/a8rqLz8SCo2UvZijabYpx
>RvZqArXJwH1jZ68ak7q2NlGM7w/bVzV1LvuQDqA+OtLCkQEjH5txfrszBDz5HIsZ
>T5QEEDs9FeEd317o05BLv5aD7pOaoGQ+7sMOgWqVUB4DLi8pyYTdz4knEU2SLgcq
>CVcuJYm2fEoQRVJ+JMmf97kiw00A2RvuKYkYK2FzNGKH9PMWgm5xmGrzkPGULnMW
>76ID5XQHE6qCae5ZqP2cthn3CDmVf7+GRQ5Snyw0Bg4drxKFo1W3RN4Hi70fDAk5
>nBZv5Epdex23yqG7BQh/glT5V3Xsta9j3k1S4YR5TyOrOkgYM8uDj5EQ2Eh+XcLZ
>soXMa64ROl87VGRTpjp+sSjd5hvr8VTiXHGSnbSrJes3H6Vt156507zmQOvqI/Bv
>fgoPEFc+rMBL/iuf2/dWh5gbEm4qIy3X5DjmPZszpVUoEktFsaqN+A4fjBaeH3cv
>s/NPVMWL7nwg5r8+icrZ9FOv58WnLljL/T7M29eanS9Ktc5+WuH4w6vgn73HTUPX
>IV6IKl7QbrFrDf9FuSGHf7i7w6RAgwX0FKDaAra5hx5VEOUeSTAUZAzSqdcXgxIJ
>oJzfPxrvEh9Eu6uzTF2fBtX6QrQ9qbAr++R8Bre+003/x/QtIlk0Cp14vVOljr7o
>dnt+VwB0p5UCXWcPdK/tVdbv3D1+9gYaMZbYs9NJiDT/oeX4V1oHTBH+WXf+DaDQ
>Wb5bhmr32oEngl78IF7n0hXVpcF1qzikw2jWwI4oVRe6swcEEOUOj6w+3MVqZZuN
>+hrLU4CkxC38pHzBPGOGKcAD3ceUeUZUx+YIG3yy9gn4dJ/ZdUEFbywIOtOgpatc
>M17OkJY7vxENKKzu9lib38NVL32lpmFbvd5epONyfka0pN4r5mj698KuvS3gl3/E
>Svkd/8itfYTIuCyoriLup+ohmIiib1XZysEeN1Iv22VLak6cvzg6L3cFgsGPUasw
>KzwyqTBVukF+07tl06M6VjFHp9WFx1gRN0SospSZYrtn4GpoK3rxELBy0gB2xCdk
>dWy5oTFZrVtMD1oX6UQ1w88wXJzheY7sw32deEbE/vbCyTg4wXt05qauCKJy+Tsc
>HLM9r6j5Jel3uCvnWia4EcPI2Kg7/C+/gLPGq12JaNGFwG1VIHpW9pr04CMOEr+3
>EtszVbl9V5h0MZ3/nHTv8RINtQ==
>=t7vZ
>-----END PGP MESSAGE-----
>_______________________________________________
>bitcoin-dev mailing list
>bitcoin-dev at lists.linuxfoundation.org
>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

- --
https://petertodd.org 'peter'[:-1]@petertodd.org
-----BEGIN PGP SIGNATURE-----

iQE9BAEBCgAnIBxQZXRlciBUb2RkIDxwZXRlQHBldGVydG9kZC5vcmc+BQJbdx97
AAoJEGOZARBE6K+yz4MH/iNVDolc3WhC6/eF5P9EVfGbVfvS5hgvqa+9pxQHq8Wt
Bcdey7E0gTMAO8o/yPsYWcUJoj7zqILiHWnpO+qop065hql3AsCocx9ePLH3pZ+D
+bY0th9brMpF6sR4PyFXvvgwlnXMJaMGbujnzHrMtdx29Ll254idOOaq2n+FMPdM
rgkV8EYCH7xs2LCkGu4hkseqFgrbupXQ/X/RlLCB351Jbf6KlCol/Po7sqCg9Wlj
wVatmkp5eDMfFH3cUnrNC+tJY+OEiGf6rg3+Vu2CDex2Bf7PbIMJYuTiN3ZQB6Ak
OqbPcLpIiSjbry/cA1j+gWgD9YuuElB+1mFtxt1B+KE=
=ggZJ
-----END PGP SIGNATURE-----

From jb55 at jb55.com  Fri Aug 17 15:51:31 2018
From: jb55 at jb55.com (William Casarin)
Date: Fri, 17 Aug 2018 08:51:31 -0700
Subject: [bitcoin-dev] [announce] LNvis alpha - A Lightning Network
	Visualizer
Message-ID: <87h8jtxa7w.fsf@jb55.com>


Hello lightning/bitcoin devs,

I've been working on an OpenGL Lighting Network visualizer written in C
+ nanovg with no dependencies except for glfw. I thought I would release
the alpha here first for testing.

Right now it only parses c-lightning channels and node json, but I'm
currently adding support for LND. I've only tested on linux, so it would
be great if we could get this working on macos/windows as well.

Picture: https://jb55.com/s/abe49a248360d41c.png
Code: https://github.com/jb55/lnvis


How it works
------------

LNvis renders the Lightning Network channel gossip, which include nodes
and the edges (channels) between those nodes.

- Channels are colored by the node that opened the channel
- Channel widths are rendered proportional to the capacity
- Right clicking a node filters the view to that node and its neighbors
- Dragging a node in any view will focus that node and its neihbors

That's about it for now. Next things that I think would be fun to have:

- Filter by alias/id in the UI
- "Google Maps" mode for highlighting potential routes between nodes
- Realtime channel updates from network gossip

Any other ideas and suggesstions would be great.

Contributors welcome!

Cheers,
Will

From damgaard.martin at gmail.com  Sat Aug 18 20:10:04 2018
From: damgaard.martin at gmail.com (damgaard.martin at gmail.com)
Date: Sat, 18 Aug 2018 22:10:04 +0200
Subject: [bitcoin-dev] Suggestion for a universal bitcoin value scale
Message-ID: <5b787d19.1c69fb81.e0628.771a@mx.google.com>

Hi bitcoin-dev at lists.linuxfoundation.org
Here is my humble attempt to make a contribution to the impressive work that you all are doing. 
I am unfamiliar with the normal BIP procedures. I have therefore just tried to follow the example of BIP 176 by Jimmy Song, in order make something similar. I suggest a universal bitcoin value color scale, for tackling the same decimal problem, as identified by the BIP 176 proposal.
I have attached the document in three different formats (*.rtf, *.pdf and *.docx) as I do not know your preferred format. I hope you will find my suggestion useful.

Thank you and all the best 
Martin Damgaard
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180818/38605387/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: Universal bitcoin value color scale.rtf
Type: application/rtf
Size: 236624 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180818/38605387/attachment-0001.rtf>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: Universal bitcoin value color scale.pdf
Type: application/pdf
Size: 606867 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180818/38605387/attachment-0001.pdf>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: Universal bitcoin value color scale.docx
Type: application/vnd.openxmlformats-officedocument.wordprocessingml.document
Size: 44130 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180818/38605387/attachment-0001.docx>

From rodolfo at coinkite.com  Sun Aug 19 11:42:13 2018
From: rodolfo at coinkite.com (Rodolfo Novak)
Date: Sun, 19 Aug 2018 07:42:13 -0400
Subject: [bitcoin-dev] Suggestion for a universal bitcoin value scale
In-Reply-To: <5b787d19.1c69fb81.e0628.771a@mx.google.com>
References: <5b787d19.1c69fb81.e0628.771a@mx.google.com>
Message-ID: <7EA432A9-BF76-4B2A-B664-0F374BD5C18F@coinkite.com>

This is not a good solution. In UX colors have expected meaning. Red often means error, yellow cation, green possible, etc... 

Text doesn?t have good legibility in colors, monochrome high contrast being the best.

You will also have issues with colorblind people.

Rodolfo 

?.

> On Aug 18, 2018, at 16:10, Martin Damgaard via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Hi bitcoin-dev at lists.linuxfoundation.org
> Here is my humble attempt to make a contribution to the impressive work that you all are doing.
> I am unfamiliar with the normal BIP procedures. I have therefore just tried to follow the example of BIP 176 by Jimmy Song, in order make something similar. I suggest a universal bitcoin value color scale, for tackling the same decimal problem, as identified by the BIP 176 proposal.
> I have attached the document in three different formats (*.rtf, *.pdf and *.docx) as I do not know your preferred format. I hope you will find my suggestion useful.
>  
> Thank you and all the best
> Martin Damgaard
> <Universal bitcoin value color scale.rtf>
> <Universal bitcoin value color scale.pdf>
> <Universal bitcoin value color scale.docx>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180819/50ffe6d6/attachment.html>

From damgaard.martin at gmail.com  Sun Aug 19 14:21:55 2018
From: damgaard.martin at gmail.com (damgaard.martin at gmail.com)
Date: Sun, 19 Aug 2018 16:21:55 +0200
Subject: [bitcoin-dev] Suggestion for a universal bitcoin value scale
In-Reply-To: <CAJS4p67a+47PimeSizBsAb9nanjaOdgB41hDQXoKFj9OxMqMFA@mail.gmail.com>
References: <5b787d19.1c69fb81.e0628.771a@mx.google.com>
	<CAJS4p67a+47PimeSizBsAb9nanjaOdgB41hDQXoKFj9OxMqMFA@mail.gmail.com>
Message-ID: <5b797d04.1c69fb81.c5a5.9f78@mx.google.com>

Hi 
I have made a GitHub version of the suggestion:

https://github.com/damse0045/Universal-bitcoin-value-color-scale./tree/master

where I have collected the commons made to the first version in a remarks-file. 
I will try to make a new version incorporation the different commons, and if anyone would like to help they will be more than welcome to join.

All kind of suggestions are more than welcome, and thank you for the good points made so far. 

All the best 
Martin

Fra: Ad?n S?nchez de Pedro Crespo
Sendt: 19. august 2018 11:11
Til: damgaard.martin at gmail.com; bitcoin-dev at lists.linuxfoundation.org
Emne: Re: [bitcoin-dev] Suggestion for a universal bitcoin value scale

It would be great if you could submit this as a markdown document published somewhere with version control, such as GitHub. That'd make life easier for anyone willing to contribute to your proposal.

On Sat, 18 Aug 2018 22:26 Martin Damgaard via bitcoin-dev, <bitcoin-dev at lists.linuxfoundation.org> wrote:
Hi bitcoin-dev at lists.linuxfoundation.org
Here is my humble attempt to make a contribution to the impressive work that you all are doing. 
I am unfamiliar with the normal BIP procedures. I have therefore just tried to follow the example of BIP 176 by Jimmy Song, in order make something similar. I suggest a universal bitcoin value color scale, for tackling the same decimal problem, as identified by the BIP 176 proposal.
I have attached the document in three different formats (*.rtf, *.pdf and *.docx) as I do not know your preferred format. I hope you will find my suggestion useful.
?
Thank you and all the best 
Martin Damgaard
_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180819/43cbc940/attachment.html>

From greg at xiph.org  Mon Aug 20 20:14:50 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Mon, 20 Aug 2018 20:14:50 +0000
Subject: [bitcoin-dev] Getting around to fixing the timewarp attack.
Message-ID: <CAAS2fgRo5k8yBKXub46q7SQutskPKPmv5sXPZcM5+E_yzW5_mQ@mail.gmail.com>

Since 2012 (IIRC) we've known that Bitcoin's non-overlapping
difficulty calculation was vulnerable to gaming with inaccurate
timestamps to massively increase the rate of block production beyond
the system's intentional design. It can be fixed with a soft-fork that
further constraints block timestamps, and a couple of proposals have
been floated along these lines.

I put a demonstration of timewarp early in the testnet3 chain to also
let people test mitigations against that.  It pegs the difficulty way
down and then churned out blocks at the maximum rate that the median
time protocol rule allows.

I, and I assume others, haven't put a big priority into fixing this
vulnerability because it requires a majority hashrate and could easily
be blocked if someone started using it.

But there haven't been too many other network consensus rules going on
right now, and I believe at least several of the proposals suggested
are fully compatible with existing behaviour and only trigger in the
presence of exceptional circumstances-- e.g. a timewarp attack.  So
the risk of deploying these mitigations would be minimal.

Before I dust off my old fix and perhaps prematurely cause fixation on
a particular approach, I thought it would be useful to ask the list if
anyone else was aware of a favourite backwards compatible timewarp fix
proposal they wanted to point out.

Cheers.

From rhavar at protonmail.com  Mon Aug 20 23:36:14 2018
From: rhavar at protonmail.com (rhavar at protonmail.com)
Date: Mon, 20 Aug 2018 23:36:14 +0000
Subject: [bitcoin-dev] Suggestion for a universal bitcoin value scale
In-Reply-To: <5b787d19.1c69fb81.e0628.771a@mx.google.com>
References: <5b787d19.1c69fb81.e0628.771a@mx.google.com>
Message-ID: <xlH72fF0W83RnOFpO_YJZg8i72LT5xIliO623-2AkwrB1FdxS7Z-wnV8F7OpYm5LXwcQqcfx3o_Z-Y-tP6Dt7GpNqDH9DFnjTekJtXa7oAI=@protonmail.com>

I think you have correctly identified dealing with small amounts while working in the "bitcoin" denomination as a major pain point, and I will go as far as agreeing that a standard color coding would help people eyeball what 0.000011 BTC means if they were used to seeing the same color pallet.

However, I don't think it's a good solution. I strongly suspect very few services or wallets are going to be willing to adopt such a thing as it'll make their design look ridiculous and it's cumbersome to type.

Furthermore, my experience in using BIP76 (Bits Denomination) in several services with people of varying levels of familiarity to be entirely positive, and in my strong believe a vastly superior solution that should be advocated and used more.

And BTW i think what would help the readability of the "bitcoin" denomination more than colors if it was standard to always write it to 8 decimal places (e.g. 0.00001100 BTC) which I think is a bit more useful in allowing people to eyeball the size.

-Ryan

??????? Original Message ???????
On August 18, 2018 1:10 PM, Martin Damgaard via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi bitcoin-dev at lists.linuxfoundation.org
>
> Here is my humble attempt to make a contribution to the impressive work that you all are doing.
>
> I am unfamiliar with the normal BIP procedures. I have therefore just tried to follow the example of BIP 176 by Jimmy Song, in order make something similar. I suggest a universal bitcoin value color scale, for tackling the same decimal problem, as identified by the BIP 176 proposal.
>
> I have attached the document in three different formats (*.rtf, *.pdf and *.docx) as I do not know your preferred format. I hope you will find my suggestion useful.
>
> Thank you and all the best
>
> Martin Damgaard
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180820/3650a9b1/attachment.html>

From stephane.traumat at gmail.com  Tue Aug 21 21:12:47 2018
From: stephane.traumat at gmail.com (=?UTF-8?Q?St=C3=A9phane_Traumat?=)
Date: Tue, 21 Aug 2018 23:12:47 +0200
Subject: [bitcoin-dev] BIP171 - Specs, Mock server,
	template project and client librairies
Message-ID: <CAApT8LRcC4iApEWX4QLQRFUqXPokC4e68GD48KtjxcyPXgfPcQ@mail.gmail.com>

Hello,

I worked on the BIP 171
<https://github.com/bitcoin/bips/blob/master/bip-0171.mediawiki> and I
created Cerise <http://www.cerise.tech/> (github
<https://github.com/straumat/cerise>) that provides the following artifacts
:


   - BIP-0171 specifications <http://www.cerise.tech/#specifications>.
   - A mocked BIP-0171 compliant server available online
   <http://api.cerise.tech/swagger-ui.html> you can use to understand the
   API and make calls.
   - A mocked BIP-0171 compliant server as a Java application
   <https://github.com/straumat/cerise-server-mock/> you can use to develop
   your client application.
   - A mocked BIP-0171 compliant server as a Docker image
   <https://hub.docker.com/r/straumat/cerise-server-mock/> you can use to
   develop your client application.
   - A BIP-0171 library <https://github.com/straumat/cerise/> to transform
   your application in a BIP-0171 server.
   - A server template project
   <https://github.com/straumat/cerise-server-template> to quickly write
   your implementation and automatically produce your BIP-0171 server.
   - A collection of client libraries <http://www.cerise.tech/#clients> to
   call any BIP-0171 compliant server with your favorite language.

I made some proposal of evolutions here :
https://github.com/bitcoin/bips/wiki/Comments:BIP-0171

I hope it helps and if you have any suggestion on how I could help more,
let me know.
-- 
*St?phane Traumat*
https://about.me/straumat
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180821/5c88e22d/attachment.html>

From jtimon at jtimon.cc  Wed Aug 22 13:48:16 2018
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Wed, 22 Aug 2018 15:48:16 +0200
Subject: [bitcoin-dev] Getting around to fixing the timewarp attack.
In-Reply-To: <CAAS2fgRo5k8yBKXub46q7SQutskPKPmv5sXPZcM5+E_yzW5_mQ@mail.gmail.com>
References: <CAAS2fgRo5k8yBKXub46q7SQutskPKPmv5sXPZcM5+E_yzW5_mQ@mail.gmail.com>
Message-ID: <CABm2gDoqG5RFJRdZ83WN6vU1=A3TMTy44heRV76-z=8Gk5doqA@mail.gmail.com>

I only knew about ArtForz's fix, which isn't backwards compatible.

https://github.com/bitcoin/bitcoin/compare/0.11...jtimon:hardfork-timewarp-0.11
https://github.com/bitcoin/bips/blob/master/bip-0099.mediawiki#code


On Mon, Aug 20, 2018 at 10:14 PM, Gregory Maxwell via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Since 2012 (IIRC) we've known that Bitcoin's non-overlapping
> difficulty calculation was vulnerable to gaming with inaccurate
> timestamps to massively increase the rate of block production beyond
> the system's intentional design. It can be fixed with a soft-fork that
> further constraints block timestamps, and a couple of proposals have
> been floated along these lines.
>
> I put a demonstration of timewarp early in the testnet3 chain to also
> let people test mitigations against that.  It pegs the difficulty way
> down and then churned out blocks at the maximum rate that the median
> time protocol rule allows.
>
> I, and I assume others, haven't put a big priority into fixing this
> vulnerability because it requires a majority hashrate and could easily
> be blocked if someone started using it.
>
> But there haven't been too many other network consensus rules going on
> right now, and I believe at least several of the proposals suggested
> are fully compatible with existing behaviour and only trigger in the
> presence of exceptional circumstances-- e.g. a timewarp attack.  So
> the risk of deploying these mitigations would be minimal.
>
> Before I dust off my old fix and perhaps prematurely cause fixation on
> a particular approach, I thought it would be useful to ask the list if
> anyone else was aware of a favourite backwards compatible timewarp fix
> proposal they wanted to point out.
>
> Cheers.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From jl2012 at xbt.hk  Fri Aug 24 09:35:11 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Fri, 24 Aug 2018 17:35:11 +0800
Subject: [bitcoin-dev] Getting around to fixing the timewarp attack.
In-Reply-To: <CAAS2fgRo5k8yBKXub46q7SQutskPKPmv5sXPZcM5+E_yzW5_mQ@mail.gmail.com>
References: <CAAS2fgRo5k8yBKXub46q7SQutskPKPmv5sXPZcM5+E_yzW5_mQ@mail.gmail.com>
Message-ID: <50DD20FF-A67E-4DEF-96AF-705B62894AA0@xbt.hk>

To determine the new difficulty, it is supposed to compare the timestamps of block (2016n - 1) with block (2016n - 2017). However, an off-by-one bug makes it compares with block (2016n - 2016) instead.

A naive but perfect fix is to require every block (2016x) to have a timestamp not smaller than that of its parent block. However, a chain-split would happen even without any attack, unless super-majority of miners are enforcing the new rules. This also involves mandatory upgrade of pool software (cf. pool software upgrade is not mandatory for segwit). The best way is to do it with something like BIP34, which also requires new pool software. 

We could have a weaker version of this, to require the timestamp of block (2016x) not smaller than its parent block by t-seconds, with 0 <= t <= infinity. With a bigger t, the fix is less effective but also less likely to cause intentional/unintentional split. Status quo is t = infinity.

Reducing the value of t is a softfork. The aim is to find a t which is small-enough-to-prohibit-time-wrap-attack but also big-enough-to-avoid-split. With t=86400 (one day), a time-wrap attacker may bring down the difficulty by about 1/14 = 7.1% per round. Unless new blocks were coming incredibly slow, the attacker needs to manipulate the MTP for at least 24 hours, or try to rewrite 24 hours of history. Such scale of 51% attack is already above the 100-block coinbase maturity safety theshold and we are facing a much bigger problem.

With t=86400, a non-majority, opportunistic attacker may split the chain only if we have no new block for at least 24 - 2 = 22 hours (2-hours is the protocol limit for using a future timestamp) at the exact moment of retarget. That means no retarget is possible in the next 2016 blocks. Doing a time-wrap attack at this point is not quite interesting as the coin is probably already worthless. Again, this is a much bigger problem than the potential chain spilt. People will yell for a difficulty (and time wrap fix, maybe) hardfork to resuscitate the chain.

 


> On 21 Aug 2018, at 4:14 AM, Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Since 2012 (IIRC) we've known that Bitcoin's non-overlapping
> difficulty calculation was vulnerable to gaming with inaccurate
> timestamps to massively increase the rate of block production beyond
> the system's intentional design. It can be fixed with a soft-fork that
> further constraints block timestamps, and a couple of proposals have
> been floated along these lines.
> 
> I put a demonstration of timewarp early in the testnet3 chain to also
> let people test mitigations against that.  It pegs the difficulty way
> down and then churned out blocks at the maximum rate that the median
> time protocol rule allows.
> 
> I, and I assume others, haven't put a big priority into fixing this
> vulnerability because it requires a majority hashrate and could easily
> be blocked if someone started using it.
> 
> But there haven't been too many other network consensus rules going on
> right now, and I believe at least several of the proposals suggested
> are fully compatible with existing behaviour and only trigger in the
> presence of exceptional circumstances-- e.g. a timewarp attack.  So
> the risk of deploying these mitigations would be minimal.
> 
> Before I dust off my old fix and perhaps prematurely cause fixation on
> a particular approach, I thought it would be useful to ask the list if
> anyone else was aware of a favourite backwards compatible timewarp fix
> proposal they wanted to point out.
> 
> Cheers.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From shekharhiran at gmail.com  Sun Aug 26 19:58:50 2018
From: shekharhiran at gmail.com (Blockchain Group)
Date: Mon, 27 Aug 2018 01:28:50 +0530
Subject: [bitcoin-dev] Building a Bitcoin API and query system.
Message-ID: <CA+9w0-77oP3rmW37R6ty4fF_LhaOtQaL52yQUKynXEmZhQ9MeA@mail.gmail.com>

Hello everyone,

I am C++ & Node.js developer. I want to propose making a new Bitcoin API
that supports fast quering of Bitcoin blocks and transactions without the
need for syncing with all previous nodes.

In a typical case where I want to build a full fleged Bitcoin explorer cum
wallet system on my end with external APIs, I need to sync my node and then
query for the information I need to show separately. I am proposing a
unified method of finding/quering the blockchain data with a standardized
template containing minimal information about the actual mined block or
transaction yet satify the need of what I want to query.

I am working on making a template and a support mechanism on Node.js. I
want to propose it as an improvement (BIP). It will be a great help to
future web developers who want to make something similar.

Thanks
Sumit Lahiri.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180827/65f05e9a/attachment.html>

From fireduck at gmail.com  Tue Aug 28 15:15:06 2018
From: fireduck at gmail.com (=?UTF-8?B?Sm9zZXBoIEdsZWFzb24g4pGI?=)
Date: Tue, 28 Aug 2018 08:15:06 -0700
Subject: [bitcoin-dev] Building a Bitcoin API and query system.
In-Reply-To: <CA+9w0-77oP3rmW37R6ty4fF_LhaOtQaL52yQUKynXEmZhQ9MeA@mail.gmail.com>
References: <CA+9w0-77oP3rmW37R6ty4fF_LhaOtQaL52yQUKynXEmZhQ9MeA@mail.gmail.com>
Message-ID: <CA+ASnrGo8HovRSEDSmFaUcC2mV7Cwjy8eXvaBzCFnuiAHVT5zA@mail.gmail.com>

For what it is worth, electrum has a lot or possibly all of what you are
talking about since the electrum servers are designed to quickly answer the
queries of light clients.  So right now, you could sync up an electrum
server or use an existing public one and send queries to it with json-rpc.

https://github.com/kyuupichan/electrumx/blob/master/docs/protocol-methods.rst


On Tue, Aug 28, 2018 at 5:36 AM Blockchain Group via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hello everyone,
>
> I am C++ & Node.js developer. I want to propose making a new Bitcoin API
> that supports fast quering of Bitcoin blocks and transactions without the
> need for syncing with all previous nodes.
>
> In a typical case where I want to build a full fleged Bitcoin explorer cum
> wallet system on my end with external APIs, I need to sync my node and then
> query for the information I need to show separately. I am proposing a
> unified method of finding/quering the blockchain data with a standardized
> template containing minimal information about the actual mined block or
> transaction yet satify the need of what I want to query.
>
> I am working on making a template and a support mechanism on Node.js. I
> want to propose it as an improvement (BIP). It will be a great help to
> future web developers who want to make something similar.
>
> Thanks
> Sumit Lahiri.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180828/241a010d/attachment.html>

From ematiu at gmail.com  Tue Aug 28 15:47:10 2018
From: ematiu at gmail.com (Matias Alejo Garcia)
Date: Tue, 28 Aug 2018 12:47:10 -0300
Subject: [bitcoin-dev] Building a Bitcoin API and query system.
In-Reply-To: <CA+ASnrGo8HovRSEDSmFaUcC2mV7Cwjy8eXvaBzCFnuiAHVT5zA@mail.gmail.com>
References: <CA+9w0-77oP3rmW37R6ty4fF_LhaOtQaL52yQUKynXEmZhQ9MeA@mail.gmail.com>
	<CA+ASnrGo8HovRSEDSmFaUcC2mV7Cwjy8eXvaBzCFnuiAHVT5zA@mail.gmail.com>
Message-ID: <CA+vKqYeW9oi5bk8ZtZEvSJnoVzYdZ2+YXoLCSoe=PPCBhzMuvg@mail.gmail.com>

Hi Sumit,

Take a look at https://github.com/bitpay/bitcore/tree/v8.0.0, it is a
bitcoin indexing API server, with several modules, like a block explorer, a
wallet module, etc. It is built using Node.js.

mat?as

On Tue, Aug 28, 2018 at 12:43 PM Joseph Gleason ? via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> For what it is worth, electrum has a lot or possibly all of what you are
> talking about since the electrum servers are designed to quickly answer the
> queries of light clients.  So right now, you could sync up an electrum
> server or use an existing public one and send queries to it with json-rpc.
>
>
> https://github.com/kyuupichan/electrumx/blob/master/docs/protocol-methods.rst
>
>
> On Tue, Aug 28, 2018 at 5:36 AM Blockchain Group via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Hello everyone,
>>
>> I am C++ & Node.js developer. I want to propose making a new Bitcoin API
>> that supports fast quering of Bitcoin blocks and transactions without the
>> need for syncing with all previous nodes.
>>
>> In a typical case where I want to build a full fleged Bitcoin explorer
>> cum wallet system on my end with external APIs, I need to sync my node and
>> then query for the information I need to show separately. I am proposing a
>> unified method of finding/quering the blockchain data with a standardized
>> template containing minimal information about the actual mined block or
>> transaction yet satify the need of what I want to query.
>>
>> I am working on making a template and a support mechanism on Node.js. I
>> want to propose it as an improvement (BIP). It will be a great help to
>> future web developers who want to make something similar.
>>
>> Thanks
>> Sumit Lahiri.
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>


-- 
Mat?as Alejo Garcia
@ematiu
Roads? Where we're going, we don't need roads!
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180828/b50caacc/attachment.html>

From shekharhiran at gmail.com  Tue Aug 28 17:34:04 2018
From: shekharhiran at gmail.com (Blockchain Group)
Date: Tue, 28 Aug 2018 23:04:04 +0530
Subject: [bitcoin-dev] Building a Bitcoin API and query system.
In-Reply-To: <CA+vKqYeW9oi5bk8ZtZEvSJnoVzYdZ2+YXoLCSoe=PPCBhzMuvg@mail.gmail.com>
References: <CA+9w0-77oP3rmW37R6ty4fF_LhaOtQaL52yQUKynXEmZhQ9MeA@mail.gmail.com>
	<CA+ASnrGo8HovRSEDSmFaUcC2mV7Cwjy8eXvaBzCFnuiAHVT5zA@mail.gmail.com>
	<CA+vKqYeW9oi5bk8ZtZEvSJnoVzYdZ2+YXoLCSoe=PPCBhzMuvg@mail.gmail.com>
Message-ID: <CA+9w0-4NHoWZ8zbB06OvhWL5Y51jP3P10Hz3K=G85NCPfKj2Cw@mail.gmail.com>

Thanks, I'll check it out.

On Tue, Aug 28, 2018, 9:17 PM Matias Alejo Garcia <ematiu at gmail.com> wrote:

> Hi Sumit,
>
> Take a look at https://github.com/bitpay/bitcore/tree/v8.0.0, it is a
> bitcoin indexing API server, with several modules, like a block explorer, a
> wallet module, etc. It is built using Node.js.
>
> mat?as
>
> On Tue, Aug 28, 2018 at 12:43 PM Joseph Gleason ? via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> For what it is worth, electrum has a lot or possibly all of what you are
>> talking about since the electrum servers are designed to quickly answer the
>> queries of light clients.  So right now, you could sync up an electrum
>> server or use an existing public one and send queries to it with json-rpc.
>>
>>
>> https://github.com/kyuupichan/electrumx/blob/master/docs/protocol-methods.rst
>>
>>
>> On Tue, Aug 28, 2018 at 5:36 AM Blockchain Group via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> Hello everyone,
>>>
>>> I am C++ & Node.js developer. I want to propose making a new Bitcoin API
>>> that supports fast quering of Bitcoin blocks and transactions without the
>>> need for syncing with all previous nodes.
>>>
>>> In a typical case where I want to build a full fleged Bitcoin explorer
>>> cum wallet system on my end with external APIs, I need to sync my node and
>>> then query for the information I need to show separately. I am proposing a
>>> unified method of finding/quering the blockchain data with a standardized
>>> template containing minimal information about the actual mined block or
>>> transaction yet satify the need of what I want to query.
>>>
>>> I am working on making a template and a support mechanism on Node.js. I
>>> want to propose it as an improvement (BIP). It will be a great help to
>>> future web developers who want to make something similar.
>>>
>>> Thanks
>>> Sumit Lahiri.
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
>
> --
> Mat?as Alejo Garcia
> @ematiu
> Roads? Where we're going, we don't need roads!
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180828/7527bd24/attachment-0001.html>

From guido.dassori at gmail.com  Tue Aug 28 17:51:11 2018
From: guido.dassori at gmail.com (Guido Dassori)
Date: Tue, 28 Aug 2018 19:51:11 +0200
Subject: [bitcoin-dev] Building a Bitcoin API and query system.
In-Reply-To: <CA+9w0-4NHoWZ8zbB06OvhWL5Y51jP3P10Hz3K=G85NCPfKj2Cw@mail.gmail.com>
References: <CA+9w0-77oP3rmW37R6ty4fF_LhaOtQaL52yQUKynXEmZhQ9MeA@mail.gmail.com>
	<CA+ASnrGo8HovRSEDSmFaUcC2mV7Cwjy8eXvaBzCFnuiAHVT5zA@mail.gmail.com>
	<CA+vKqYeW9oi5bk8ZtZEvSJnoVzYdZ2+YXoLCSoe=PPCBhzMuvg@mail.gmail.com>
	<CA+9w0-4NHoWZ8zbB06OvhWL5Y51jP3P10Hz3K=G85NCPfKj2Cw@mail.gmail.com>
Message-ID: <CAJ_Ap8iO6-ugd49JvyjiE6Ke0e9CfMwV50rOH1Bao2whufO-gA@mail.gmail.com>

Hi Sumit,

There's no protocol api to fetch a single transaction over the p2p network.
You can query peers for mempool transactions, but once there are into a
block, no way to obtain them without fetching the entire block.

Also, you may want to take a look to spruned (
https://github.com/gdassori/spruned), it uses both the electrum & the p2p
network to do the same job you are researching on. It serves the data by
emulating some of the bitcoind rpc api, to be suitable by bitcoind backed
applications.

Guido

Il giorno mar 28 ago 2018 alle ore 19:41 Blockchain Group via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> ha scritto:

> Thanks, I'll check it out.
>
> On Tue, Aug 28, 2018, 9:17 PM Matias Alejo Garcia <ematiu at gmail.com>
> wrote:
>
>> Hi Sumit,
>>
>> Take a look at https://github.com/bitpay/bitcore/tree/v8.0.0, it is a
>> bitcoin indexing API server, with several modules, like a block explorer, a
>> wallet module, etc. It is built using Node.js.
>>
>> mat?as
>>
>> On Tue, Aug 28, 2018 at 12:43 PM Joseph Gleason ? via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> For what it is worth, electrum has a lot or possibly all of what you are
>>> talking about since the electrum servers are designed to quickly answer the
>>> queries of light clients.  So right now, you could sync up an electrum
>>> server or use an existing public one and send queries to it with json-rpc.
>>>
>>>
>>> https://github.com/kyuupichan/electrumx/blob/master/docs/protocol-methods.rst
>>>
>>>
>>> On Tue, Aug 28, 2018 at 5:36 AM Blockchain Group via bitcoin-dev <
>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>>> Hello everyone,
>>>>
>>>> I am C++ & Node.js developer. I want to propose making a new Bitcoin
>>>> API that supports fast quering of Bitcoin blocks and transactions without
>>>> the need for syncing with all previous nodes.
>>>>
>>>> In a typical case where I want to build a full fleged Bitcoin explorer
>>>> cum wallet system on my end with external APIs, I need to sync my node and
>>>> then query for the information I need to show separately. I am proposing a
>>>> unified method of finding/quering the blockchain data with a standardized
>>>> template containing minimal information about the actual mined block or
>>>> transaction yet satify the need of what I want to query.
>>>>
>>>> I am working on making a template and a support mechanism on Node.js. I
>>>> want to propose it as an improvement (BIP). It will be a great help to
>>>> future web developers who want to make something similar.
>>>>
>>>> Thanks
>>>> Sumit Lahiri.
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>
>>
>> --
>> Mat?as Alejo Garcia
>> @ematiu
>> Roads? Where we're going, we don't need roads!
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180828/85af1390/attachment.html>

From eric at voskuil.org  Tue Aug 28 18:14:46 2018
From: eric at voskuil.org (Eric Voskuil)
Date: Tue, 28 Aug 2018 11:14:46 -0700
Subject: [bitcoin-dev] Building a Bitcoin API and query system.
In-Reply-To: <CA+9w0-4NHoWZ8zbB06OvhWL5Y51jP3P10Hz3K=G85NCPfKj2Cw@mail.gmail.com>
References: <CA+9w0-77oP3rmW37R6ty4fF_LhaOtQaL52yQUKynXEmZhQ9MeA@mail.gmail.com>
	<CA+ASnrGo8HovRSEDSmFaUcC2mV7Cwjy8eXvaBzCFnuiAHVT5zA@mail.gmail.com>
	<CA+vKqYeW9oi5bk8ZtZEvSJnoVzYdZ2+YXoLCSoe=PPCBhzMuvg@mail.gmail.com>
	<CA+9w0-4NHoWZ8zbB06OvhWL5Y51jP3P10Hz3K=G85NCPfKj2Cw@mail.gmail.com>
Message-ID: <F9794091-8E63-4578-8E0E-B3CBE6FFB9E1@voskuil.org>

https://libbitcoin.org

> On Aug 28, 2018, at 10:34, Blockchain Group via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Thanks, I'll check it out.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180828/33f15001/attachment.html>

From dev at jonasschnelli.ch  Tue Aug 28 18:36:21 2018
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Tue, 28 Aug 2018 20:36:21 +0200
Subject: [bitcoin-dev] Building a Bitcoin API and query system.
In-Reply-To: <CA+9w0-77oP3rmW37R6ty4fF_LhaOtQaL52yQUKynXEmZhQ9MeA@mail.gmail.com>
References: <CA+9w0-77oP3rmW37R6ty4fF_LhaOtQaL52yQUKynXEmZhQ9MeA@mail.gmail.com>
Message-ID: <8AE1517F-88FB-479D-AE89-993A5545D210@jonasschnelli.ch>

Hi

To give a critical viewpoint on a such API:

Such APIs usually result in central validation, meaning that users trust API services rather the validating their own data. It break some of the fundamental properties of Bitcoin (avoid trusted third parties).
Systems or applications depending on a full indexed blockchain (a thus such API) do usually scale pretty bad.

I?d like to hear some concrete use-cases for a such block explorer(ish) API.

Thanks
?
Jonas

> Am 26.08.2018 um 21:58 schrieb Blockchain Group via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>:
> 
> Hello everyone,
> 
> I am C++ & Node.js developer. I want to propose making a new Bitcoin API that supports fast quering of Bitcoin blocks and transactions without the need for syncing with all previous nodes.
> 
> In a typical case where I want to build a full fleged Bitcoin explorer cum wallet system on my end with external APIs, I need to sync my node and then query for the information I need to show separately. I am proposing a unified method of finding/quering the blockchain data with a standardized template containing minimal information about the actual mined block or transaction yet satify the need of what I want to query.
> 
> I am working on making a template and a support mechanism on Node.js. I want to propose it as an improvement (BIP). It will be a great help to future web developers who want to make something similar.
> 
> Thanks
> Sumit Lahiri.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180828/15fc887c/attachment.sig>

From wordsgalore at gmail.com  Wed Aug 29 09:54:17 2018
From: wordsgalore at gmail.com (Zawy)
Date: Wed, 29 Aug 2018 05:54:17 -0400
Subject: [bitcoin-dev] Getting around to fixing the timewarp attack.
Message-ID: <CADtTMvkJHuz66KDNOnmsUBCEVkTpT7Ly9cB+o=C2n4KAR=4vZw@mail.gmail.com>

Rather than restricting every timestamp (or just the 2016*N+1
timestamps) to >= 1+ the previous timestamp as recorded on the
blockchain, the difficulty calculation could have the same restriction
but only in how the timestamps are used. I don't know about backwards
compatibility.  Either way, this would also prevent the powLimit
attack that is also capable of getting "unlimited" blocks in less than
4 weeks of > 50% selfish mining.  LTC, BCH, and LTC fixed to the
"Zeitgeist" or "timewarp" attack on GeistGeld in 2011 described by
Artforz in different ways, but all are still vulnerable by the
powLimit attack that I described here:
https://github.com/zawy12/difficulty-algorithms/issues/30

Other solutions may not prevent this other attack.

From erik at q32.com  Wed Aug 29 11:28:56 2018
From: erik at q32.com (Erik Aronesty)
Date: Wed, 29 Aug 2018 07:28:56 -0400
Subject: [bitcoin-dev] Multisignature for bip-schnorr
In-Reply-To: <CAHk9a9ct_h485MY4gk7S++FAu5FEH3PL9pd9mrrh+wA8nWaVUA@mail.gmail.com>
References: <CAHk9a9ct_h485MY4gk7S++FAu5FEH3PL9pd9mrrh+wA8nWaVUA@mail.gmail.com>
Message-ID: <CAJowKgLGA0tc_uYMhZhB157b2--wcLyPeNhoxxbSh2r+fS+bJg@mail.gmail.com>

It's cool but

- there's a lot of online steps.
- it's not a threshold system

Using a shamir scheme solves this and isn't subject to birthday attacks:

https://medium.com/@simulx/an-m-of-n-bitcoin-multisig-scheme-e7860ab34e7f



On Mon, Aug 13, 2018 at 7:08 AM nakagat via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi all,
>
> I wrote a multisignature procedure using bip-schnorr.
>
> If you have time to review and give feedback, I?d really appreciate it.
> Thanks in advance!
>
> Multisignature
> https://gist.github.com/tnakagawa/0c3bc74a9a44bd26af9b9248dfbe598b
>
> Original
>
> https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki#Multisignatures_and_Threshold_Signatures
>
> --
> nakagawa
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180829/dd3fa3cf/attachment-0001.html>

From shekharhiran at gmail.com  Wed Aug 29 12:25:57 2018
From: shekharhiran at gmail.com (Blockchain Group)
Date: Wed, 29 Aug 2018 17:55:57 +0530
Subject: [bitcoin-dev] Building a Bitcoin API and query system.
In-Reply-To: <8AE1517F-88FB-479D-AE89-993A5545D210@jonasschnelli.ch>
References: <CA+9w0-77oP3rmW37R6ty4fF_LhaOtQaL52yQUKynXEmZhQ9MeA@mail.gmail.com>
	<8AE1517F-88FB-479D-AE89-993A5545D210@jonasschnelli.ch>
Message-ID: <CA+9w0-74PBbFGxCXvQTm=oP+WmRUUaOMWY8QQ-8EyW7TRKvb2Q@mail.gmail.com>

Thanks, I'll check it out.

On Wed, Aug 29, 2018, 12:06 AM Jonas Schnelli <dev at jonasschnelli.ch> wrote:

> Hi
>
> To give a critical viewpoint on a such API:
>
> Such APIs usually result in central validation, meaning that users trust
> API services rather the validating their own data. It break some of the
> fundamental properties of Bitcoin (avoid trusted third parties).
> Systems or applications depending on a full indexed blockchain (a thus
> such API) do usually scale pretty bad.
>
> I?d like to hear some concrete use-cases for a such block explorer(ish)
> API.
>
> Thanks
> ?
> Jonas
>
> > Am 26.08.2018 um 21:58 schrieb Blockchain Group via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org>:
> >
> > Hello everyone,
> >
> > I am C++ & Node.js developer. I want to propose making a new Bitcoin API
> that supports fast quering of Bitcoin blocks and transactions without the
> need for syncing with all previous nodes.
> >
> > In a typical case where I want to build a full fleged Bitcoin explorer
> cum wallet system on my end with external APIs, I need to sync my node and
> then query for the information I need to show separately. I am proposing a
> unified method of finding/quering the blockchain data with a standardized
> template containing minimal information about the actual mined block or
> transaction yet satify the need of what I want to query.
> >
> > I am working on making a template and a support mechanism on Node.js. I
> want to propose it as an improvement (BIP). It will be a great help to
> future web developers who want to make something similar.
> >
> > Thanks
> > Sumit Lahiri.
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180829/2e8fa3d5/attachment.html>

From erik at q32.com  Wed Aug 29 12:09:36 2018
From: erik at q32.com (Erik Aronesty)
Date: Wed, 29 Aug 2018 08:09:36 -0400
Subject: [bitcoin-dev] Schnorr signatures BIP
In-Reply-To: <20180812163734.GV499@boulet.lan>
References: <CAPg+sBj7f+=OYXuOMdNeJk3NBG67FSQSF8Xv3seFCvwxCWq69A@mail.gmail.com>
	<2e620d305c86f65cbff44b5fba548dc85c118f84.camel@timruffing.de>
	<20180812163734.GV499@boulet.lan>
Message-ID: <CAJowKg+h11YkwOo-gyWCw+87Oh-9K34LOnJ1730hhpoVR2m5sA@mail.gmail.com>

Note:

This spec cannot be used directly with a shamir scheme to produce
single-round threshold multisigs, because shares of point R would need to
be broadcast to share participants in order to produce valid single
signatures.

(R, s) schemes can still be used "online", if share participants publish
the R(share).... but, not sure if it matter much, this choice eliminates
offline multiparty signing in exchange for batch validation.








On Sun, Aug 12, 2018 at 12:47 PM Andrew Poelstra via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> I think it's just an oversight. We should specify that we use the standard
> encoding from section 2.3 of http://www.secg.org/sec1-v2.pdf except that
> we allow only compressed public keys.
>
> Andrew
>
>
> On Mon, Aug 06, 2018 at 11:12:48PM +0200, Tim Ruffing via bitcoin-dev
> wrote:
> > Is it intentional that the encoding of public (and private) keys is
> > unspecified? I'd consider at least the encoding of the public key to be
> > part of the signature scheme, so ideally it should be specified already
> > in this BIP. On the other hand, there may be good arguments against it,
> > but I'm not aware of any.
> >
> > This issue leads to a discrepancy between the specification and the
> > test vectors because the data fields of test vectors "are given as byte
> > arrays", including public and secret key. As a consequence, even the
> > Python reference implementation in the BIP draft doesn't work on test
> > vectors (in a strict sense).
> >
> > Best,
> > Tim
> >
> >
> > On Fri, 2018-07-06 at 11:08 -0700, Pieter Wuille via bitcoin-dev wrote:
> > > Hello everyone,
> > >
> > > Here is a proposed BIP for 64-byte elliptic curve Schnorr signatures,
> > > over the same curve as is currently used in ECDSA:
> > > https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki
> > >
> > > It is simply a draft specification of the signature scheme itself. It
> > > does not concern consensus rules, aggregation, or any other
> > > integration into Bitcoin - those things are left for other proposals,
> > > which can refer to this scheme if desirable. Standardizing the
> > > signature scheme is a first step towards that, and as it may be
> > > useful
> > > in other contexts to have a common Schnorr scheme available, it is
> > > its
> > > own informational BIP.
> > >
> > > If accepted, we'll work on more production-ready reference
> > > implementations and tests.
> > >
> > > This is joint work with several people listed in the document.
> > >
> > > Cheers,
> > >
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> >
>
> --
> Andrew Poelstra
> Mathematics Department, Blockstream
> Email: apoelstra at wpsoftware.net
> Web:   https://www.wpsoftware.net/andrew
>
> "A goose alone, I suppose, can know the loneliness of geese
>  who can never find their peace,
>  whether north or south or west or east"
>        --Joanna Newsom
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180829/6070f716/attachment.html>

From eric at voskuil.org  Wed Aug 29 14:40:16 2018
From: eric at voskuil.org (Eric Voskuil)
Date: Wed, 29 Aug 2018 07:40:16 -0700
Subject: [bitcoin-dev] Building a Bitcoin API and query system.
In-Reply-To: <8AE1517F-88FB-479D-AE89-993A5545D210@jonasschnelli.ch>
References: <CA+9w0-77oP3rmW37R6ty4fF_LhaOtQaL52yQUKynXEmZhQ9MeA@mail.gmail.com>
	<8AE1517F-88FB-479D-AE89-993A5545D210@jonasschnelli.ch>
Message-ID: <758E3CA7-295B-4B77-BFF5-9AAE959D53EA@voskuil.org>

The API implementation is not what is centralizing, nor is full indexation non-scalable. The centralization is in not running the API from a node under your own control. This is of course implied by the comment, ?without the need for syncing?. In other words it is the deployment cost of the node that is centralizing.

Yet if people relied only on bitcoind and never centralized services there would be *no* block explorers (and no secure light wallets), because it does not provide remote query and does not fully index.

Block explorers and light wallets are pretty useful, so presumably some API must provide these features (ideally with reduced deployment cost). That will either be centralized or decentralized services. As such it seems wise to encourage the latter, as opposed to questioning whether there is any valid block explorer use case.

e


> On Aug 28, 2018, at 11:36, Jonas Schnelli via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Hi
> 
> To give a critical viewpoint on a such API:
> 
> Such APIs usually result in central validation, meaning that users trust API services rather the validating their own data. It break some of the fundamental properties of Bitcoin (avoid trusted third parties).
> Systems or applications depending on a full indexed blockchain (a thus such API) do usually scale pretty bad.
> 
> I?d like to hear some concrete use-cases for a such block explorer(ish) API.
> 
> Thanks
> ?
> Jonas
> 
>> Am 26.08.2018 um 21:58 schrieb Blockchain Group via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>:
>> 
>> Hello everyone,
>> 
>> I am C++ & Node.js developer. I want to propose making a new Bitcoin API that supports fast quering of Bitcoin blocks and transactions without the need for syncing with all previous nodes.
>> 
>> In a typical case where I want to build a full fleged Bitcoin explorer cum wallet system on my end with external APIs, I need to sync my node and then query for the information I need to show separately. I am proposing a unified method of finding/quering the blockchain data with a standardized template containing minimal information about the actual mined block or transaction yet satify the need of what I want to query.
>> 
>> I am working on making a template and a support mechanism on Node.js. I want to propose it as an improvement (BIP). It will be a great help to future web developers who want to make something similar.
>> 
>> Thanks
>> Sumit Lahiri.
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From shekharhiran at gmail.com  Wed Aug 29 16:06:43 2018
From: shekharhiran at gmail.com (Blockchain Group)
Date: Wed, 29 Aug 2018 21:36:43 +0530
Subject: [bitcoin-dev] Building a Bitcoin API and query system.
In-Reply-To: <758E3CA7-295B-4B77-BFF5-9AAE959D53EA@voskuil.org>
References: <CA+9w0-77oP3rmW37R6ty4fF_LhaOtQaL52yQUKynXEmZhQ9MeA@mail.gmail.com>
	<8AE1517F-88FB-479D-AE89-993A5545D210@jonasschnelli.ch>
	<758E3CA7-295B-4B77-BFF5-9AAE959D53EA@voskuil.org>
Message-ID: <CA+9w0-73LzutZaFEQVnb=f_vSh8K8QfULh8Qc6j3x9JpnNBZHg@mail.gmail.com>

Thanks! That is what my main point is.

On Wed, Aug 29, 2018, 8:10 PM Eric Voskuil <eric at voskuil.org> wrote:

> The API implementation is not what is centralizing, nor is full indexation
> non-scalable. The centralization is in not running the API from a node
> under your own control. This is of course implied by the comment, ?without
> the need for syncing?. In other words it is the deployment cost of the node
> that is centralizing.
>
> Yet if people relied only on bitcoind and never centralized services there
> would be *no* block explorers (and no secure light wallets), because it
> does not provide remote query and does not fully index.
>
> Block explorers and light wallets are pretty useful, so presumably some
> API must provide these features (ideally with reduced deployment cost).
> That will either be centralized or decentralized services. As such it seems
> wise to encourage the latter, as opposed to questioning whether there is
> any valid block explorer use case.
>
> e
>
>
> > On Aug 28, 2018, at 11:36, Jonas Schnelli via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> > Hi
> >
> > To give a critical viewpoint on a such API:
> >
> > Such APIs usually result in central validation, meaning that users trust
> API services rather the validating their own data. It break some of the
> fundamental properties of Bitcoin (avoid trusted third parties).
> > Systems or applications depending on a full indexed blockchain (a thus
> such API) do usually scale pretty bad.
> >
> > I?d like to hear some concrete use-cases for a such block explorer(ish)
> API.
> >
> > Thanks
> > ?
> > Jonas
> >
> >> Am 26.08.2018 um 21:58 schrieb Blockchain Group via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org>:
> >>
> >> Hello everyone,
> >>
> >> I am C++ & Node.js developer. I want to propose making a new Bitcoin
> API that supports fast quering of Bitcoin blocks and transactions without
> the need for syncing with all previous nodes.
> >>
> >> In a typical case where I want to build a full fleged Bitcoin explorer
> cum wallet system on my end with external APIs, I need to sync my node and
> then query for the information I need to show separately. I am proposing a
> unified method of finding/quering the blockchain data with a standardized
> template containing minimal information about the actual mined block or
> transaction yet satify the need of what I want to query.
> >>
> >> I am working on making a template and a support mechanism on Node.js. I
> want to propose it as an improvement (BIP). It will be a great help to
> future web developers who want to make something similar.
> >>
> >> Thanks
> >> Sumit Lahiri.
> >> _______________________________________________
> >> bitcoin-dev mailing list
> >> bitcoin-dev at lists.linuxfoundation.org
> >> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180829/4a0ea125/attachment-0001.html>

From eric at voskuil.org  Wed Aug 29 18:45:56 2018
From: eric at voskuil.org (Eric Voskuil)
Date: Wed, 29 Aug 2018 11:45:56 -0700
Subject: [bitcoin-dev] Building a Bitcoin API and query system.
In-Reply-To: <4EC6599E-D317-4E4F-9E4D-37B7006B8C15@jonasschnelli.ch>
References: <CA+9w0-77oP3rmW37R6ty4fF_LhaOtQaL52yQUKynXEmZhQ9MeA@mail.gmail.com>
	<8AE1517F-88FB-479D-AE89-993A5545D210@jonasschnelli.ch>
	<758E3CA7-295B-4B77-BFF5-9AAE959D53EA@voskuil.org>
	<4EC6599E-D317-4E4F-9E4D-37B7006B8C15@jonasschnelli.ch>
Message-ID: <43C5B077-AFFB-4FCB-8D43-C56FBF835526@voskuil.org>

You have created a straw man.

And light clients working against the P2P network (anonymous nodes) implies they are not fully validating, so you are contradicting yourself.

e

> On Aug 29, 2018, at 11:27, Jonas Schnelli <dev at jonasschnelli.ch> wrote:
> 
> 
>> The API implementation is not what is centralizing, nor is full indexation non-scalable. The centralization is in not running the API from a node under your own control. This is of course implied by the comment, ?without the need for syncing?. In other words it is the deployment cost of the node that is centralizing.
> 
> IMO an API that serves non verifiable data is supporting centralised validation. The ?API" which supports one of the most important properties in Bitcoin ? the ability to self-validate ? is the data available via the p2p network.
> 
>> 
>> Yet if people relied only on bitcoind and never centralized services there would be *no* block explorers (and no secure light wallets), because it does not provide remote query and does not fully index.
>> 
>> Block explorers and light wallets are pretty useful, so presumably some API must provide these features (ideally with reduced deployment cost). That will either be centralized or decentralized services. As such it seems wise to encourage the latter, as opposed to questioning whether there is any valid block explorer use case.
> 
> Bitcoin-Core has all required features to partially ?index? data (called the wallet) and provides them via the RPC API. If you don?t need to serve thousands of wallets (which smells after centralised validation), selective indexing (wallets) are the right choice. Also, if you have a proper light client architecture, you can use Bitcoin Core in pruned mode (<10GB of data) to serve an endless amount of wallets (client/server mode, I guess that is what you are referring to with "light clients").
> 
> I fail to see the use-cases where a fully index blockchain makes sense (the only one I can come up with is instant backup recovery where the transaction history needs to be preserved rather then recovering the UTXOs only).
> 
> Also, the p2p protocol has built in light client support with BIP37 (bloom filters) and soon BIP158 will be available on the network which does allow privacy-preserving "light clients" in a way where no trusted layer is required (client <-> p2p network rather then client <-> API provider <-> p2p network).
> 
> I don?t want to advocate against a full-index blockexplorer-like API. I just think its important to define the use case and be aware of the consequences and downsides.
> 
> /jonas

From shekharhiran at gmail.com  Wed Aug 29 18:29:18 2018
From: shekharhiran at gmail.com (Blockchain Group)
Date: Wed, 29 Aug 2018 23:59:18 +0530
Subject: [bitcoin-dev] Building a Bitcoin API and query system.
In-Reply-To: <4EC6599E-D317-4E4F-9E4D-37B7006B8C15@jonasschnelli.ch>
References: <CA+9w0-77oP3rmW37R6ty4fF_LhaOtQaL52yQUKynXEmZhQ9MeA@mail.gmail.com>
	<8AE1517F-88FB-479D-AE89-993A5545D210@jonasschnelli.ch>
	<758E3CA7-295B-4B77-BFF5-9AAE959D53EA@voskuil.org>
	<4EC6599E-D317-4E4F-9E4D-37B7006B8C15@jonasschnelli.ch>
Message-ID: <CA+9w0-4-BL5dJCTXD80hVfgt-kZY8AtYzLg_2yCn1m7KeeVs=g@mail.gmail.com>

Awesome, thanks for the information. I will work on it and keep it in mind.

On Wed, Aug 29, 2018, 11:57 PM Jonas Schnelli <dev at jonasschnelli.ch> wrote:

>
> > The API implementation is not what is centralizing, nor is full
> indexation non-scalable. The centralization is in not running the API from
> a node under your own control. This is of course implied by the comment,
> ?without the need for syncing?. In other words it is the deployment cost of
> the node that is centralizing.
>
> IMO an API that serves non verifiable data is supporting centralised
> validation. The ?API" which supports one of the most important properties
> in Bitcoin ? the ability to self-validate ? is the data available via the
> p2p network.
>
> >
> > Yet if people relied only on bitcoind and never centralized services
> there would be *no* block explorers (and no secure light wallets), because
> it does not provide remote query and does not fully index.
> >
> > Block explorers and light wallets are pretty useful, so presumably some
> API must provide these features (ideally with reduced deployment cost).
> That will either be centralized or decentralized services. As such it seems
> wise to encourage the latter, as opposed to questioning whether there is
> any valid block explorer use case.
>
> Bitcoin-Core has all required features to partially ?index? data (called
> the wallet) and provides them via the RPC API. If you don?t need to serve
> thousands of wallets (which smells after centralised validation), selective
> indexing (wallets) are the right choice. Also, if you have a proper light
> client architecture, you can use Bitcoin Core in pruned mode (<10GB of
> data) to serve an endless amount of wallets (client/server mode, I guess
> that is what you are referring to with "light clients").
>
> I fail to see the use-cases where a fully index blockchain makes sense
> (the only one I can come up with is instant backup recovery where the
> transaction history needs to be preserved rather then recovering the UTXOs
> only).
>
> Also, the p2p protocol has built in light client support with BIP37 (bloom
> filters) and soon BIP158 will be available on the network which does allow
> privacy-preserving "light clients" in a way where no trusted layer is
> required (client <-> p2p network rather then client <-> API provider <->
> p2p network).
>
> I don?t want to advocate against a full-index blockexplorer-like API. I
> just think its important to define the use case and be aware of the
> consequences and downsides.
>
> /jonas
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180829/95a5e31d/attachment.html>

From dev at jonasschnelli.ch  Wed Aug 29 18:27:51 2018
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Wed, 29 Aug 2018 20:27:51 +0200
Subject: [bitcoin-dev] Building a Bitcoin API and query system.
In-Reply-To: <758E3CA7-295B-4B77-BFF5-9AAE959D53EA@voskuil.org>
References: <CA+9w0-77oP3rmW37R6ty4fF_LhaOtQaL52yQUKynXEmZhQ9MeA@mail.gmail.com>
	<8AE1517F-88FB-479D-AE89-993A5545D210@jonasschnelli.ch>
	<758E3CA7-295B-4B77-BFF5-9AAE959D53EA@voskuil.org>
Message-ID: <4EC6599E-D317-4E4F-9E4D-37B7006B8C15@jonasschnelli.ch>


> The API implementation is not what is centralizing, nor is full indexation non-scalable. The centralization is in not running the API from a node under your own control. This is of course implied by the comment, ?without the need for syncing?. In other words it is the deployment cost of the node that is centralizing.

IMO an API that serves non verifiable data is supporting centralised validation. The ?API" which supports one of the most important properties in Bitcoin ? the ability to self-validate ? is the data available via the p2p network.

> 
> Yet if people relied only on bitcoind and never centralized services there would be *no* block explorers (and no secure light wallets), because it does not provide remote query and does not fully index.
> 
> Block explorers and light wallets are pretty useful, so presumably some API must provide these features (ideally with reduced deployment cost). That will either be centralized or decentralized services. As such it seems wise to encourage the latter, as opposed to questioning whether there is any valid block explorer use case.

Bitcoin-Core has all required features to partially ?index? data (called the wallet) and provides them via the RPC API. If you don?t need to serve thousands of wallets (which smells after centralised validation), selective indexing (wallets) are the right choice. Also, if you have a proper light client architecture, you can use Bitcoin Core in pruned mode (<10GB of data) to serve an endless amount of wallets (client/server mode, I guess that is what you are referring to with "light clients").

I fail to see the use-cases where a fully index blockchain makes sense (the only one I can come up with is instant backup recovery where the transaction history needs to be preserved rather then recovering the UTXOs only).

Also, the p2p protocol has built in light client support with BIP37 (bloom filters) and soon BIP158 will be available on the network which does allow privacy-preserving "light clients" in a way where no trusted layer is required (client <-> p2p network rather then client <-> API provider <-> p2p network).

I don?t want to advocate against a full-index blockexplorer-like API. I just think its important to define the use case and be aware of the consequences and downsides.

/jonas
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180829/f991e201/attachment.sig>

From shiva at blockonomics.co  Thu Aug 30 07:28:42 2018
From: shiva at blockonomics.co (shiva sitamraju)
Date: Thu, 30 Aug 2018 12:58:42 +0530
Subject: [bitcoin-dev] Testnet3 Reest
Message-ID: <CABuOfuh7M6siJW1FzXajsBSeYSu=TBEgx9SAmCbwnP=yb7rJOQ@mail.gmail.com>

Hi,

Testnet is now 1411795 blocks and a full sync is taking atleast 48 hours.

Is a testnet reset scheduled in the next release or any reason not to do a
reset ?

Fast onboarding/lower disk overheads would be  very much appreicated for
testing purposes

Regards


-- 
Shiva S
CEO @ Blockonomics <https://www.blockonomics.co>
Decentralized and Permissionless Payments
Join us on Telegram <https://t.me/BlockonomicsCo>
View our Welcome Guide
<https://www.blockonomics.co/docs/blockonomics-brochure.pdf>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180830/29db618f/attachment.html>

From vitteaymeric at gmail.com  Thu Aug 30 10:03:41 2018
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Thu, 30 Aug 2018 12:03:41 +0200
Subject: [bitcoin-dev] Building a Bitcoin API and query system.
In-Reply-To: <8AE1517F-88FB-479D-AE89-993A5545D210@jonasschnelli.ch>
References: <CA+9w0-77oP3rmW37R6ty4fF_LhaOtQaL52yQUKynXEmZhQ9MeA@mail.gmail.com>
	<8AE1517F-88FB-479D-AE89-993A5545D210@jonasschnelli.ch>
Message-ID: <fc603995-cdb1-2bef-4fdc-e3f0009fb998@gmail.com>



Le 28/08/2018 ? 20:36, Jonas Schnelli via bitcoin-dev a ?crit?:
> I?d like to hear some concrete use-cases for a such block explorer(ish) API.

https://github.com/Ayms/bitcoin-transactions which is somewhere
bitcoin-cli outside of bitcoin core with no wallet, which implies that
you don't want to mix/provide your wallet with/to the app creating your
transactions and/or you don't want to use wallet sw

Problem: quasi nobody succeeds to use it (and probably this trend is
unlikely to revert), that's why there is https://peersm.com/wallet which
is querying the info outside and output the right command to use with
the tool (or output the transaction if people put their keys, which is
of course not advised unless they are sure that the corresponding
addresses are dead ones)

It is planned to put the app for the advanced mode (ie people must know
all the parameters) as an offline one inside browsers, then back to the
above problem...

So probably the offline mode should include a phase where the tool
connects to some APIs/explorers like the one suggested here before
switching to the offline mode to enter the keys, this will always be not
very secure for the query phase unless it can become something
decentralized (and usable the same way on different networks), which as
far as I understand is envisioned here

-- 
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms



From shekharhiran at gmail.com  Thu Aug 30 11:40:51 2018
From: shekharhiran at gmail.com (Blockchain Group)
Date: Thu, 30 Aug 2018 17:10:51 +0530
Subject: [bitcoin-dev] Building a Bitcoin API and query system.
In-Reply-To: <fc603995-cdb1-2bef-4fdc-e3f0009fb998@gmail.com>
References: <CA+9w0-77oP3rmW37R6ty4fF_LhaOtQaL52yQUKynXEmZhQ9MeA@mail.gmail.com>
	<8AE1517F-88FB-479D-AE89-993A5545D210@jonasschnelli.ch>
	<fc603995-cdb1-2bef-4fdc-e3f0009fb998@gmail.com>
Message-ID: <CA+9w0-4UpbgpXs3xGNuwr9Uem40jRfUKCTR8xPumuHfK_5O0zg@mail.gmail.com>

Thanks, I'll check it out.

On Thu, Aug 30, 2018, 3:33 PM Aymeric Vitte <vitteaymeric at gmail.com> wrote:

>
>
> Le 28/08/2018 ? 20:36, Jonas Schnelli via bitcoin-dev a ?crit :
> > I?d like to hear some concrete use-cases for a such block explorer(ish)
> API.
>
> https://github.com/Ayms/bitcoin-transactions which is somewhere
> bitcoin-cli outside of bitcoin core with no wallet, which implies that
> you don't want to mix/provide your wallet with/to the app creating your
> transactions and/or you don't want to use wallet sw
>
> Problem: quasi nobody succeeds to use it (and probably this trend is
> unlikely to revert), that's why there is https://peersm.com/wallet which
> is querying the info outside and output the right command to use with
> the tool (or output the transaction if people put their keys, which is
> of course not advised unless they are sure that the corresponding
> addresses are dead ones)
>
> It is planned to put the app for the advanced mode (ie people must know
> all the parameters) as an offline one inside browsers, then back to the
> above problem...
>
> So probably the offline mode should include a phase where the tool
> connects to some APIs/explorers like the one suggested here before
> switching to the offline mode to enter the keys, this will always be not
> very secure for the query phase unless it can become something
> decentralized (and usable the same way on different networks), which as
> far as I understand is envisioned here
>
> --
> Bitcoin transactions made simple:
> https://github.com/Ayms/bitcoin-transactions
> Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
> Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
> Get the torrent dynamic blocklist: http://peersm.com/getblocklist
> Check the 10 M passwords list: http://peersm.com/findmyass
> Anti-spies and private torrents, dynamic blocklist:
> http://torrent-live.org
> Peersm : http://www.peersm.com
> torrent-live: https://github.com/Ayms/torrent-live
> node-Tor : https://www.github.com/Ayms/node-Tor
> GitHub : https://www.github.com/Ayms
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180830/4892d85a/attachment.html>

From rhavar at protonmail.com  Thu Aug 30 20:24:58 2018
From: rhavar at protonmail.com (rhavar at protonmail.com)
Date: Thu, 30 Aug 2018 20:24:58 +0000
Subject: [bitcoin-dev] bustapay BIP :: a practical sender/receiver coinjoin
	protocol
Message-ID: <TtjH2zicjKr8PBVCMOvA7ryt2z_XXvtrpC4y1wuWSxexNwMdbPGE7vPmu6UnzmfYqYBMxZ8NNoz4VUnODdIcjR4j-E1sYz_FA6ZZMjKHtuM=@protonmail.com>

I've just finished writing an implementing of this, and extremely happy with how it turned out. So I'd like to go and try go down the path of more formally describing it and getting some comments and ultimately encourage its wide-spread use.

==Abstract==

The way bitcoin transactions are overwhelming used is known to leak more
information than desirable. This has lead to fungibility concerns in bitcoin
and a raise of unreasonably effective blockchain analysis.

Bustapay proposes a simple, practical way to bust these assumptions to immediate
benefit of the sender and recievers. Furthermore it does so in such a way that
helps recievers avoid utxo bloat, a constant problem for bitcoin merchants.

==Copyright==

This BIP is in the public domain.

==Motivation==

One of the most powerful heuristic's employed by those whose goal is to undermine
bitcoin's fungiblity has been to assume all inputs of a transaction are signed by
a single party. In the few cases this assumption does not hold, it is generally
readibly recognizable (e.g. traditional coinjoins have a very obvious structure,
or multisig outputs are most frequently validated onchain).

Bustapay requires no changes to bitcoin and creates bitcoin transactions that are
indistinguishable from normal ones.

It is worth noting that this specification has been intentionally kept as simple
as possible to encourage adoption. There are almost an endless amount of extensions
possible but the harder the implementation of clients/server the less likely it
will ever be done. Should bustapay enjoy widespread adoption, a "v2" specification
will be created with desired extensions.

==Specification==

A bustapay payment is made from a sender to a receiver.

Step 1. Sender creates a bitcoin transaction paying the receiver

This transaction must be fully valid, signed and all inputs must use segwit. This transaction is known as the "template transaction". This transaction must not be propagated on the bitcoin network.

Step 2. Sender gives the "template transaction" to the receiver

This would generally be done as an HTTP POST. The exact URL to submit it to could be specified with a bip21 encoded address. Such as bitcoin:2NABbUr9yeRCp1oUCtVmgJF8HGRCo3ifpTT?bustapay=https://bp.bustabit.com/submit and the HTTP body should be the raw transaction hex encoded as text.

Step 3. Receiver processes the transaction and returns a partially signed coinjoin

The receiver validates the transaction is valid, pays himself and is eligible for propation. The receiver then adds one of his own inputs (known as the "contributed input") and increase the output that pays himself by the contributed input amount. Doing so will invalidate the "template transaction"'s original input signatures, so the sender needs to return this "partial transaction" back to the receiver to sign. This is returned as a hex-encoded raw transaction a response to the original HTTP POST request.

Step 4. Receiver validates, re-signs, and propagates on the bitcoin network

The receiver is responsible in making sure the "partial transaction" returned by the sender was changed correctly (it should assume the connection has been MITM'd and act accordingly), resign its original inputs and propagates this transaction over the bitcoin network. The client must be aware that the server can reorder inputs and outputs.

Step 5. Receiver observes the finalized transaction on the bitcoin network

Once the receiver has seen the finalized transactions on the network (and has enough confirmations) it can process it like a normal payment for the sent amount (as opposed to the amount that it looks like on the network). If the receiver does not see the finalized transaction after a timeout will propagate the original "template transaction" to ensure the payment happens and function a strong anti-DoS mechanism.

=== Implementation Notes ===
For anyone wanting to implement bustapay payments, here are some notes for receivers:

* A transaction can easily be checked if it's suitable for the mempool with testmempoolaccept in bitcoin core 0.17
* Tracking transactions by txid is precarious. To keep your sanity make sure all inputs are segwit. But remember segwit does not prevent txid malleability unless you validate the transaction. So really make sure you're using testmempoolaccept at the very least
* Bustapay could be abused by a malicious party to query if you own a deposit address or not. So never accept a bustapay transaction that pays an already used deposit address
* You will need to keep a mapping of which utxos people have showed you and which you revealed. So if you see them again, you can reveal the same one of your own
* Check if the transaction was already sorted according to BIP69, if so ensure the result stays that way. Otherwise probably just shuffle the inputs/outpus

Notes for sending applications:

* The HTTP response must *not* be trusted. It should be fully validated that no unexpected changes have been made to the transaction.
* The sender should be aware the original "template transaction" may be propagated at any time, and in fact can intentionally be
  done so for the purpose of RBF as it should have a slightly higher fee rate.

== Credits ==
The idea is obviously based upon Dr. Maxwell's seminal CoinJoin proposal, and reduced scope inspired by a simplification of the "pay 2 endpoint" (now offline) blog post by blockstream.

-Ryan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180830/29c49730/attachment.html>

From pete at petertodd.org  Thu Aug 30 20:02:39 2018
From: pete at petertodd.org (Peter Todd)
Date: Thu, 30 Aug 2018 16:02:39 -0400
Subject: [bitcoin-dev] Testnet3 Reest
In-Reply-To: <CABuOfuh7M6siJW1FzXajsBSeYSu=TBEgx9SAmCbwnP=yb7rJOQ@mail.gmail.com>
References: <CABuOfuh7M6siJW1FzXajsBSeYSu=TBEgx9SAmCbwnP=yb7rJOQ@mail.gmail.com>
Message-ID: <20180830200239.ujuzh7pitcuatdt3@petertodd.org>

On Thu, Aug 30, 2018 at 12:58:42PM +0530, shiva sitamraju via bitcoin-dev wrote:
> Hi,
> 
> Testnet is now 1411795 blocks and a full sync is taking atleast 48 hours.
> 
> Is a testnet reset scheduled in the next release or any reason not to do a
> reset ?
> 
> Fast onboarding/lower disk overheads would be  very much appreicated for
> testing purposes

Actually I'd advocate the opposite: I'd want testnet to be a *larger*
blockchain than mainnet to find size-related issues first.

Note that for testing regtest is often a better alternative, and you can setup
private regtest blockchains fairly easily and with good control over exactly
when and how blocks are created.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180830/1e4ab762/attachment.sig>

From bram at chia.net  Thu Aug 30 20:55:17 2018
From: bram at chia.net (Bram Cohen)
Date: Thu, 30 Aug 2018 13:55:17 -0700
Subject: [bitcoin-dev] Getting around to fixing the timewarp attack.
In-Reply-To: <50DD20FF-A67E-4DEF-96AF-705B62894AA0@xbt.hk>
References: <CAAS2fgRo5k8yBKXub46q7SQutskPKPmv5sXPZcM5+E_yzW5_mQ@mail.gmail.com>
	<50DD20FF-A67E-4DEF-96AF-705B62894AA0@xbt.hk>
Message-ID: <CAHUJnBBRDRNyWoJQ0jt_r5JzTwhg4edBhyDCFfa7ToiqxUSe-g@mail.gmail.com>

This seems like a case where a distinction should be made between soft
forks which are likely to cause non-upgraded miners to get orphaned and
ones where they are. Of course in this case it's only 1/2016 of all blocks
so it doesn't really matter, but it's worth thinking about the principle.
In general soft forks are better when they don't cause orphaning on
non-upgraded miners.

The whole problem seems to be caused by the difference between the
timestamps at the end of a period and the block right after it. Soft
forking to force those to be 'close enough' together sounds like a solid
approach. Given that blocks are generally send around fairly quickly, and
that blocks more than two hours in the future are ignored, it seems
reasonable to not allow a backwards jump of that plus some safety
parameter. Let's say three hours. It also feels like a good idea to not
allow a jump of more than three hours forwards either, just on principle.

That should result in minimal code changes, and rarely any orphaning of
non-upgraded miners at all, and still only 1/2016 blocks when they do. And
no trace of a hard fork. It suffers from still allowing the attack a little
bit, but three hours out of every two weeks seems like no big deal.

On Sat, Aug 25, 2018 at 5:10 AM Johnson Lau via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> To determine the new difficulty, it is supposed to compare the timestamps
> of block (2016n - 1) with block (2016n - 2017). However, an off-by-one bug
> makes it compares with block (2016n - 2016) instead.
>
> A naive but perfect fix is to require every block (2016x) to have a
> timestamp not smaller than that of its parent block. However, a chain-split
> would happen even without any attack, unless super-majority of miners are
> enforcing the new rules. This also involves mandatory upgrade of pool
> software (cf. pool software upgrade is not mandatory for segwit). The best
> way is to do it with something like BIP34, which also requires new pool
> software.
>
> We could have a weaker version of this, to require the timestamp of block
> (2016x) not smaller than its parent block by t-seconds, with 0 <= t <=
> infinity. With a bigger t, the fix is less effective but also less likely
> to cause intentional/unintentional split. Status quo is t = infinity.
>
> Reducing the value of t is a softfork. The aim is to find a t which is
> small-enough-to-prohibit-time-wrap-attack but also
> big-enough-to-avoid-split. With t=86400 (one day), a time-wrap attacker may
> bring down the difficulty by about 1/14 = 7.1% per round. Unless new blocks
> were coming incredibly slow, the attacker needs to manipulate the MTP for
> at least 24 hours, or try to rewrite 24 hours of history. Such scale of 51%
> attack is already above the 100-block coinbase maturity safety theshold and
> we are facing a much bigger problem.
>
> With t=86400, a non-majority, opportunistic attacker may split the chain
> only if we have no new block for at least 24 - 2 = 22 hours (2-hours is the
> protocol limit for using a future timestamp) at the exact moment of
> retarget. That means no retarget is possible in the next 2016 blocks. Doing
> a time-wrap attack at this point is not quite interesting as the coin is
> probably already worthless. Again, this is a much bigger problem than the
> potential chain spilt. People will yell for a difficulty (and time wrap
> fix, maybe) hardfork to resuscitate the chain.
>
>
>
>
> > On 21 Aug 2018, at 4:14 AM, Gregory Maxwell via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> > Since 2012 (IIRC) we've known that Bitcoin's non-overlapping
> > difficulty calculation was vulnerable to gaming with inaccurate
> > timestamps to massively increase the rate of block production beyond
> > the system's intentional design. It can be fixed with a soft-fork that
> > further constraints block timestamps, and a couple of proposals have
> > been floated along these lines.
> >
> > I put a demonstration of timewarp early in the testnet3 chain to also
> > let people test mitigations against that.  It pegs the difficulty way
> > down and then churned out blocks at the maximum rate that the median
> > time protocol rule allows.
> >
> > I, and I assume others, haven't put a big priority into fixing this
> > vulnerability because it requires a majority hashrate and could easily
> > be blocked if someone started using it.
> >
> > But there haven't been too many other network consensus rules going on
> > right now, and I believe at least several of the proposals suggested
> > are fully compatible with existing behaviour and only trigger in the
> > presence of exceptional circumstances-- e.g. a timewarp attack.  So
> > the risk of deploying these mitigations would be minimal.
> >
> > Before I dust off my old fix and perhaps prematurely cause fixation on
> > a particular approach, I thought it would be useful to ask the list if
> > anyone else was aware of a favourite backwards compatible timewarp fix
> > proposal they wanted to point out.
> >
> > Cheers.
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180830/579ee190/attachment-0001.html>

From jaejoon at gmail.com  Thu Aug 30 20:36:16 2018
From: jaejoon at gmail.com (Jimmy Song)
Date: Thu, 30 Aug 2018 15:36:16 -0500
Subject: [bitcoin-dev] Testnet3 Reest
In-Reply-To: <20180830200239.ujuzh7pitcuatdt3@petertodd.org>
References: <CABuOfuh7M6siJW1FzXajsBSeYSu=TBEgx9SAmCbwnP=yb7rJOQ@mail.gmail.com>
	<20180830200239.ujuzh7pitcuatdt3@petertodd.org>
Message-ID: <CAJR7vkqt0x6KamB5Bx_bC6Zu0oxJYHHNYHS9i4q4q3++iHRz2Q@mail.gmail.com>

Stupid question time:

Why don't we have multiple testnets?

On Thu, Aug 30, 2018 at 3:31 PM Peter Todd via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Thu, Aug 30, 2018 at 12:58:42PM +0530, shiva sitamraju via bitcoin-dev
> wrote:
> > Hi,
> >
> > Testnet is now 1411795 blocks and a full sync is taking atleast 48 hours.
> >
> > Is a testnet reset scheduled in the next release or any reason not to do
> a
> > reset ?
> >
> > Fast onboarding/lower disk overheads would be  very much appreicated for
> > testing purposes
>
> Actually I'd advocate the opposite: I'd want testnet to be a *larger*
> blockchain than mainnet to find size-related issues first.
>
> Note that for testing regtest is often a better alternative, and you can
> setup
> private regtest blockchains fairly easily and with good control over
> exactly
> when and how blocks are created.
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180830/33139c8d/attachment.html>

From jl2012 at xbt.hk  Thu Aug 30 20:44:25 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Fri, 31 Aug 2018 04:44:25 +0800
Subject: [bitcoin-dev] Testnet3 Reest
In-Reply-To: <20180830200239.ujuzh7pitcuatdt3@petertodd.org>
References: <CABuOfuh7M6siJW1FzXajsBSeYSu=TBEgx9SAmCbwnP=yb7rJOQ@mail.gmail.com>
	<20180830200239.ujuzh7pitcuatdt3@petertodd.org>
Message-ID: <7E247E56-38A5-4B99-941A-A2CC837D2567@xbt.hk>

A public testnet is still useful so in articles people could make references to these transactions.

Maybe we could have 2 testnets at the same time, with one having a smaller block size?

> On 31 Aug 2018, at 4:02 AM, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Signed PGP part
> On Thu, Aug 30, 2018 at 12:58:42PM +0530, shiva sitamraju via bitcoin-dev wrote:
>> Hi,
>> 
>> Testnet is now 1411795 blocks and a full sync is taking atleast 48 hours.
>> 
>> Is a testnet reset scheduled in the next release or any reason not to do a
>> reset ?
>> 
>> Fast onboarding/lower disk overheads would be  very much appreicated for
>> testing purposes
> 
> Actually I'd advocate the opposite: I'd want testnet to be a *larger*
> blockchain than mainnet to find size-related issues first.
> 
> Note that for testing regtest is often a better alternative, and you can setup
> private regtest blockchains fairly easily and with good control over exactly
> when and how blocks are created.
> 
> -- 
> https://petertodd.org 'peter'[:-1]@petertodd.org
> 
> 



From jl2012 at xbt.hk  Thu Aug 30 20:38:06 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Fri, 31 Aug 2018 04:38:06 +0800
Subject: [bitcoin-dev] SIGHASH2 for version 1 witness programme
In-Reply-To: <9CCCE945-9432-41B9-8559-AFE7CF233603@xbt.hk>
References: <9CCCE945-9432-41B9-8559-AFE7CF233603@xbt.hk>
Message-ID: <B35E0135-2135-405A-9627-F67EFB9D2614@xbt.hk>

After gathering some feedbacks I substantially revised the proposal. This version focus on improving security, and reduces the number of optional features.

Formatted BIP and sample code at:
https://github.com/jl2012/bips/blob/sighash2/bip-sighash2.mediawiki
https://github.com/jl2012/bitcoin/commits/sighash2

The major new features compared with BIP143:

1. If signing all inputs, also sign all input value. BIP143 signature only covers the value of the same input. In some cases this may not be adequate for hardware wallet to determine the right amount of fees. Signing all input values will secure any possible case.
2. Sign both scriptCode and previous scriptPubKey. In the original bitcoin design, previous scriptPubKey is signed as the scriptCode. However, this is not the case with P2SH and segwit. Explicitly committing to the scriptPubKey allows hardware wallet to confirm what it is actually signing (e.g. P2SH-segwit vs. Native-segwit).
3. SIGHASH2_NOINPUT: basically same as BIP118, but the signature commits to both scriptCode and scriptPubKey. This prevents signature replay if the same public key is used in different scripts.
4. SIGHASH2_MATCHOUTPUT (previously SIGHASH_SINGLE) disallows out-of-range case.
5. SIGHASH2_LASTOUTPUT: signs only the highest index output.
6. SIGHASH2_DUALOUTPUT: signs the matched output and the highest index output. Described by gmaxwell at https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016188.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016188.html>
7. Signing the amount of fees (optional, yes by default). In case of not signing all inputs or outputs, users may still want to commit to a specific fee amount.
8. Signing the witness size (optional, yes by default). While segwit fixed txid malleability, it is not a fix of script malleability. It may cause some trouble if an attacker could bloat the witness and reduce the fee priority of a transaction. Although the witness size is not malleable for most simple scripts, this is not guaranteed for more complex ones. Such kind of size malleability could be avoided if signatures commit to the size of witness.

Any suggestions are welcomed. But I have the following questions:

1. Should NOINPUT commit to scriptCode and/or scriptPubKey? I think it should, because that helps avoid signature replay in some cases, and also lets hardware wallets know what they are signing. I am asking this because BIP118 proposes the opposite. I want to make sure I?m not missing something here.
2. Do we want to add LASTOUTPUT and DUALOUTPUT? Suggested by gmaxwell, an example use case is kickstarter, where individual supporters send money to the last output for a kickstarter project, and send change to the matched output. However, I doubt if this would be actually used this way, because the kickstarter organiser could always take the money before the target is met, by making up the difference with his own input. This is an inherent problem for any anonymous kickstarter scheme. If these new SIGHASHs are not useful in other applications, I am not sure if we should add them.
3. Instead of these restrictive MATCH/LAST/DUALOUTPUT, do we want a fully flexible way to sign a subset of outputs? The indexes of signed outputs are put at the end of the signature, and the signature won?t commit to these index values. Therefore, a third party could collect all transactions of this kind and merge them into one transaction. To limit the sighash cost, number of signed outputs might not be more than 2 or 3. Some potential problems: a) code complexity; b) 1-byte or 2-byte index: 1-byte will limit the number of outputs to 256. 2-byte will use more space even for smaller txs; c) highly variable signature size makes witness size estimation more difficult
4. Should we sign the exact witness size (as proposed), or an upper size limit? Signing an upper limit will take up more space, as the limit has to be explicitly shown in the witness. The overhead could be avoided by showing the limit only if the actual witness size is not equal to the committed limit. However, I tend to keep it simple and sign the exact value. If in a multi-sig setup some signers are unable to accurately estimate the witness size, they should leave this responsibility to the last signer who should know the exact size.


> On 1 Jun 2018, at 2:35 AM, Johnson Lau via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Since 2016, I have made a number of proposals for the next generation of script. Since then, there has been a lot of exciting development on this topic. The most notable ones are Taproot and Graftroot proposed by Maxwell. It seems the most logical way is to implement MAST and other new script functions inside Taproot and/or Graftroot. Therefore, I substantially simplified my earlier proposal on SIGHASH2. It is a superset of the existing SIGHASH and the BIP118 SIGHASH_NOINPUT, with further flexibility but not being too complicated. It also fixes some minor problems that we found in the late stage of BIP143 review. For example, the theoretical (but not statistical) possibility of having same SignatureHash() results for a legacy and a witness transaction. This is fixed by padding a constant at the end of the message so collision would not be possible.
> 
> A formatted version and example code could be found here:
> https://github.com/jl2012/bips/blob/sighash2/bip-sighash2.mediawiki
> https://github.com/jl2012/bitcoin/commits/sighash2
> 
> 
> ========
> 
> BIP: YYY
>  Layer: Consensus (soft fork)
>  Title: Signature checking operations in version 1 witness program
>  Author: Johnson Lau <jl2012 at xbt.hk>
>  Comments-Summary: No comments yet.
>  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0YYY
>  Status: Draft
>  Type: Standards Track
>  Created: 2017-07-19
>  License: BSD-3-Clause
> 
> 
> *Abstract
> 
> This BIP defines signature checking operations in version 1 witness program.
> 
> *Motivation
> 
> Use of compact signatures to save space.
> 
> More SIGHASH options, more flexibility
> 
> *Specification
> 
> The following specification is applicable to OP_CHECKSIG and OP_CHECKSIGVERIFY in version 1 witness program.
> 
> **Public Key Format
> 
> The pubic key MUST be exactly 33 bytes.
> 
> If the first byte of the public key is a 0x02 or 0x03, it MUST be a compressed public key. The signature is a Schnorr signature (To be defined separately)
> 
> If the first byte of the public key is neither 0x02 nor 0x03, the signature is assumed valid. This is for future upgrade.
> 
> **Signature Format
> 
> The following rules apply only if the first byte of the public key is a 0x02 or 0x03.
> 
> If the signature size is 64 to 66 byte, it MUST be a valid Schnorr signature or the script execution MUST fail (cf. BIP146 NULLFAIL). The first 32-byte is the R value in big-endian. The next 32-byte is the S value in big-endian. The remaining data, if any, denotes the hashtype in little-endian (0 to 0xffff).
> 
> hashtype MUST be minimally encoded. Any trailing zero MUST be removed.
> 
> If the signature size is zero, it is accepted as the "valid failing" signature for OP_CHECKSIG to return a FALSE value to the stack. (cf. BIP66)
> 
> The script execution MUST fail with a signature size not 0, 64, 65, or 66-byte.
> 
> **New hashtype definitions
> 
> hashtype and the SignatureHash function are re-defined:
> 
>  Double SHA256 of the serialization of:
>     1. nVersion (4-byte little endian)
>     2. hashPrevouts (32-byte hash)
>     3. hashSequence (32-byte hash)
>     4. outpoint (32-byte hash + 4-byte little endian)
>     5. scriptCode (serialized as scripts inside CTxOuts)
>     6. nAmount (8-byte little endian)
>     7. nSequence (4-byte little endian)
>     8. hashOutputs (32-byte hash)
>     9. nLocktime (4-byte little endian)
>    10. nInputIndex (4-byte little endian)
>    11. nFees (8-byte little endian)
>    12. hashtype (4-byte little endian)
>    13. sigversion (4-byte little endian for the fixed value 0x01000000)
> 
> The bit 0 to 3 of hashtype denotes a value between 0 and 15:
> 
> 	? If the value is 1, the signature is invalid.
> 	? If the value is 3 or below, hashPrevouts is the hash of all input, same as defined in BIP143. Otherwise, it is 32-byte of 0x0000......0000.
> 	? If the value is 7 or below, outpoint is the COutPoint of the current input. Otherwise, it is 36-byte of 0x0000......0000.
> 	? If the value is 0, hashSequence is the hash of all sequence, same as defined in BIP143. Otherwise, it is 32-byte of 0x0000......0000.
> 	? If the value is even (including 0), nSequence is the nSequence of the current input. Otherwise, it is 0x00000000.
> 	? If the value is 6, 7, 10, 11, 14, or 15, nInputIndex is 0x00000000. Otherwise, it is the index of the current input.
> 	? If the value is 11 or below, nAmount is the value of the current input (same as BIP143). Otherwise, it is 0x0000000000000000.
> 
> The bit 4 and 5 of hashtype denotes a value between 0 and 3:
> 
> 	? If the value is 0, hashOutputs is same as the SIGHASH_ALL case in BIP143 as a hash of all outputs.
> 	? If the value is 1, the signature is invalid.
> 	? If the value is 2, hashOutputs is same as the SIGHASH_SINGLE case in BIP143 as a hash of the matching output. If a matching output does not exist, hashOutputs is 32-byte of 0x0000......0000.
> 	? If the value is 3, hashOutputs is 32-byte of 0x0000......0000.
> If bit 6 is set (SIGHASH2_NOFEE), nFees is 0x0000000000000000. Otherwise, it is the fee paid by the transaction.
> If bit 7 is set (SIGHASH2_NOLOCKTIME), nLockTime is 0x00000000. Otherwise, it is the transaction nLockTime.
> 
> If bit 8 is set (SIGHASH2_NOVERSION), nVersion is 0x00000000. Otherwise, it is the transaction nVersion.
> 
> If bit 9 is set (SIGHASH2_NOSCRIPTCODE), scriptCode is an empty script. Otherwise, it is same as described in BIP143.
> 
> Bits 10 to 15 are reserved and ignored, but the signature still commits to their value as hashtype.
> 
> hashtype of 0 is also known as SIGHASH2_ALL, which covers all the available options. In this case the singnature MUST be exactly 64-byte.
> 
> hashtype of 0x3ff is also known as SIGHASH2_NONE, which covers nothing and is effectively forfeiting the right related to this public key to anyone.
> 
> *Rationale
> 
> **Signature Format
> 
> The current DER format is a complete waste of block space. The new format saves ~8 bytes per signature.
> 
> **New hashtype definitions
> 
> The default and most commonly used case is SIGHASH2_ALL. Making it zero size to save space. As a result, the bit flags are defined in a negative way (e.g. NOLOCKTIME)
> 
> Why decouple INPUT and SEQUENCE? Maybe you want NOINPUT but still have a relative lock-time?
> 
> Why some combinations are missing? To save some bits for useless flags. If you sign all inputs, you must know its index and value. If you sign only this input, you must know its value, but probably don't know its index in the input vector.
> 
> Why only allow signing all SEQUENCE if all INPUT are signed? It doesn't make much sense if you care about their sequence without even knowing what they are.
> 
> Why signing INPUTINDEX? Legacy and BIP143 SINGLE|ANYONECANPAY behaves differently for input index. Better make it explicit and optional.
> 
> Why signing FEE? Sometimes you don't sign all inputs / outputs but still want to make sure the fees amount is correct.
> 
> Putting NOVERSION and NOSCRIPTCODE in the second byte makes most signatures below 66 bytes:
> 
> 	? NOVERSION: Currently the only use of transaction version is to enforce BIP68. It could be safely assumed that version 2 is used. The only case one would like to use NOVERSION is to make the signature compatible with some unknown new features that use a different transaction version.
> 	? NOSCRIPTCODE: It would be very rare if one could make a signature without knowing what the script is (at least they know the public key). The only scenario that a NOSCRIPTCODE is really needed is the public key being reused in different scripts, and the user wants to use a single signature to cover all these scripts.
> Reserved bits: These bits are ignored but should normally be unset. Users MUST NOT set these bits until they are defined by a future proposal, or they might lose money.
> Why sigversion? Make sure the message digest won't collide with SIGHASH schemes in the past (legacy and BIP143) and future (which will use a different sigversion).
> 
> *Examples
> 
> Equivalent SIGHASH2 value for other SIGHASH schemes:
> Legacy/BIP143 ALL: 0 (commit to everything)
> Legacy/BIP143 SINGLE with matching output: 0x62 (all input, one sequence, one output, no fee)
> Legacy SINGLE without matching output: 0x3ff (Not exactly. Both signatures commit to nothing, but the legacy one is valid only without a matched output. Practically, they are both "wildcard" signatures that allow anyone to spend any related UTXO)
> Legacy/BIP143 NONE: 0x72 (all input, one sequence, no output, no fee)
> Legacy/BIP143 ANYONECANPAY|ALL: 0x46 (one input without index, one sequence, all output, no fee)
> Legacy ANYONECANPAY|SINGLE with matching output: 0x64 (one input with index, one sequence, one output, no fee)
> Legacy/BIP143 ANYONECANPAY|NONE: 0x76 (one input without index, one sequence, no output, no fee)
> BIP143 SINGLE without matching output: 0x62 (all input, one sequence, no output, no fee)
> BIP143 ANYONECANPAY|SINGLE with matching output: 0x66 (one input without index, one sequence, one output, no fee)
> BIP143 ANYONECANPAY|SINGLE without matching output: 0x66 (one input without index, one sequence, no output, no fee)
> BIP118 NOINPUT: 0x14b (no input but with value, no index, no sequence, no fee, no scriptcode)
> 
> Notes:
> 
> 1. In legacy and BIP143 SIGHASH, only ALL but not other types implicitly commits to the fee paid.
> 2. Legacy SIGHASH always implicitly commits to the input value. BIP143 and BIP118 commits to that explicitly.
> 3. Legacy and BIP143 SIGHASH behaves differently in the case of SINGLE without matching output. In legacy SIGHASH it is a true "wildcard signature" that allows anyone to spend any related UTXO. In BIP143 such signature applies only to a specific UTXO.
> 4. BIP143 ANYONECANPAY never commits to the input index. Legacy ANYONECANPAY|SINGLE implicitly commits to the input index.
> 
> *Backward compatibility
> 
> This is a soft-fork.
> 
> *Deployment
> 
> Exact details TBD.
> 
> *Reference Implementation
> 
> https://github.com/jl2012/bitcoin/commits/sighash2 (To be updated)
> 
> *Copyright
> 
> This document is licensed as BSD 3-clause.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180831/134e94ee/attachment-0001.html>

From decker.christian at gmail.com  Thu Aug 30 20:51:15 2018
From: decker.christian at gmail.com (Christian Decker)
Date: Thu, 30 Aug 2018 22:51:15 +0200
Subject: [bitcoin-dev] SIGHASH2 for version 1 witness programme
In-Reply-To: <B35E0135-2135-405A-9627-F67EFB9D2614@xbt.hk>
References: <9CCCE945-9432-41B9-8559-AFE7CF233603@xbt.hk>
	<B35E0135-2135-405A-9627-F67EFB9D2614@xbt.hk>
Message-ID: <87sh2vlgsc.fsf@gmail.com>

Thanks for the update Johnson, just wanted to give a really quick NACK
on the SIGHASH_NOINPUT variant: the whole idea of BIP 118 is to have
floating transactions that can be bound to predecessors, and still
enforce some application logic. In eltoo's case this is the fact that
the state number needs to be smaller than the state number of the
transaction that is being rewritten. The state number that we bind to is
part of the `scriptPubKey`, so we can't commit to the `scriptPubKey` in
the signature since we don't know which output (and thus it's
scriptPubKey`) is at the time we sign.

If we are committing to `scriptPubKey` this whole way of enforcing order
in updates is no longer possible, and the only thing we actually get
from this change is a (very weak) malleability fix. The same argument
goes for `scriptCode`.

Cheers,
Christian

Johnson Lau <jl2012 at xbt.hk> writes:
> After gathering some feedbacks I substantially revised the proposal. This version focus on improving security, and reduces the number of optional features.
>
> Formatted BIP and sample code at:
> https://github.com/jl2012/bips/blob/sighash2/bip-sighash2.mediawiki
> https://github.com/jl2012/bitcoin/commits/sighash2
>
> The major new features compared with BIP143:
>
> 1. If signing all inputs, also sign all input value. BIP143 signature only covers the value of the same input. In some cases this may not be adequate for hardware wallet to determine the right amount of fees. Signing all input values will secure any possible case.
> 2. Sign both scriptCode and previous scriptPubKey. In the original bitcoin design, previous scriptPubKey is signed as the scriptCode. However, this is not the case with P2SH and segwit. Explicitly committing to the scriptPubKey allows hardware wallet to confirm what it is actually signing (e.g. P2SH-segwit vs. Native-segwit).
> 3. SIGHASH2_NOINPUT: basically same as BIP118, but the signature commits to both scriptCode and scriptPubKey. This prevents signature replay if the same public key is used in different scripts.
> 4. SIGHASH2_MATCHOUTPUT (previously SIGHASH_SINGLE) disallows out-of-range case.
> 5. SIGHASH2_LASTOUTPUT: signs only the highest index output.
> 6. SIGHASH2_DUALOUTPUT: signs the matched output and the highest index output. Described by gmaxwell at https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016188.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016188.html>
> 7. Signing the amount of fees (optional, yes by default). In case of not signing all inputs or outputs, users may still want to commit to a specific fee amount.
> 8. Signing the witness size (optional, yes by default). While segwit fixed txid malleability, it is not a fix of script malleability. It may cause some trouble if an attacker could bloat the witness and reduce the fee priority of a transaction. Although the witness size is not malleable for most simple scripts, this is not guaranteed for more complex ones. Such kind of size malleability could be avoided if signatures commit to the size of witness.
>
> Any suggestions are welcomed. But I have the following questions:
>
> 1. Should NOINPUT commit to scriptCode and/or scriptPubKey? I think it should, because that helps avoid signature replay in some cases, and also lets hardware wallets know what they are signing. I am asking this because BIP118 proposes the opposite. I want to make sure I?m not missing something here.
> 2. Do we want to add LASTOUTPUT and DUALOUTPUT? Suggested by gmaxwell, an example use case is kickstarter, where individual supporters send money to the last output for a kickstarter project, and send change to the matched output. However, I doubt if this would be actually used this way, because the kickstarter organiser could always take the money before the target is met, by making up the difference with his own input. This is an inherent problem for any anonymous kickstarter scheme. If these new SIGHASHs are not useful in other applications, I am not sure if we should add them.
> 3. Instead of these restrictive MATCH/LAST/DUALOUTPUT, do we want a fully flexible way to sign a subset of outputs? The indexes of signed outputs are put at the end of the signature, and the signature won?t commit to these index values. Therefore, a third party could collect all transactions of this kind and merge them into one transaction. To limit the sighash cost, number of signed outputs might not be more than 2 or 3. Some potential problems: a) code complexity; b) 1-byte or 2-byte index: 1-byte will limit the number of outputs to 256. 2-byte will use more space even for smaller txs; c) highly variable signature size makes witness size estimation more difficult
> 4. Should we sign the exact witness size (as proposed), or an upper size limit? Signing an upper limit will take up more space, as the limit has to be explicitly shown in the witness. The overhead could be avoided by showing the limit only if the actual witness size is not equal to the committed limit. However, I tend to keep it simple and sign the exact value. If in a multi-sig setup some signers are unable to accurately estimate the witness size, they should leave this responsibility to the last signer who should know the exact size.
>
>
>> On 1 Jun 2018, at 2:35 AM, Johnson Lau via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> 
>> Since 2016, I have made a number of proposals for the next generation of script. Since then, there has been a lot of exciting development on this topic. The most notable ones are Taproot and Graftroot proposed by Maxwell. It seems the most logical way is to implement MAST and other new script functions inside Taproot and/or Graftroot. Therefore, I substantially simplified my earlier proposal on SIGHASH2. It is a superset of the existing SIGHASH and the BIP118 SIGHASH_NOINPUT, with further flexibility but not being too complicated. It also fixes some minor problems that we found in the late stage of BIP143 review. For example, the theoretical (but not statistical) possibility of having same SignatureHash() results for a legacy and a witness transaction. This is fixed by padding a constant at the end of the message so collision would not be possible.
>> 
>> A formatted version and example code could be found here:
>> https://github.com/jl2012/bips/blob/sighash2/bip-sighash2.mediawiki
>> https://github.com/jl2012/bitcoin/commits/sighash2
>> 
>> 
>> ========
>> 
>> BIP: YYY
>>  Layer: Consensus (soft fork)
>>  Title: Signature checking operations in version 1 witness program
>>  Author: Johnson Lau <jl2012 at xbt.hk>
>>  Comments-Summary: No comments yet.
>>  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0YYY
>>  Status: Draft
>>  Type: Standards Track
>>  Created: 2017-07-19
>>  License: BSD-3-Clause
>> 
>> 
>> *Abstract
>> 
>> This BIP defines signature checking operations in version 1 witness program.
>> 
>> *Motivation
>> 
>> Use of compact signatures to save space.
>> 
>> More SIGHASH options, more flexibility
>> 
>> *Specification
>> 
>> The following specification is applicable to OP_CHECKSIG and OP_CHECKSIGVERIFY in version 1 witness program.
>> 
>> **Public Key Format
>> 
>> The pubic key MUST be exactly 33 bytes.
>> 
>> If the first byte of the public key is a 0x02 or 0x03, it MUST be a compressed public key. The signature is a Schnorr signature (To be defined separately)
>> 
>> If the first byte of the public key is neither 0x02 nor 0x03, the signature is assumed valid. This is for future upgrade.
>> 
>> **Signature Format
>> 
>> The following rules apply only if the first byte of the public key is a 0x02 or 0x03.
>> 
>> If the signature size is 64 to 66 byte, it MUST be a valid Schnorr signature or the script execution MUST fail (cf. BIP146 NULLFAIL). The first 32-byte is the R value in big-endian. The next 32-byte is the S value in big-endian. The remaining data, if any, denotes the hashtype in little-endian (0 to 0xffff).
>> 
>> hashtype MUST be minimally encoded. Any trailing zero MUST be removed.
>> 
>> If the signature size is zero, it is accepted as the "valid failing" signature for OP_CHECKSIG to return a FALSE value to the stack. (cf. BIP66)
>> 
>> The script execution MUST fail with a signature size not 0, 64, 65, or 66-byte.
>> 
>> **New hashtype definitions
>> 
>> hashtype and the SignatureHash function are re-defined:
>> 
>>  Double SHA256 of the serialization of:
>>     1. nVersion (4-byte little endian)
>>     2. hashPrevouts (32-byte hash)
>>     3. hashSequence (32-byte hash)
>>     4. outpoint (32-byte hash + 4-byte little endian)
>>     5. scriptCode (serialized as scripts inside CTxOuts)
>>     6. nAmount (8-byte little endian)
>>     7. nSequence (4-byte little endian)
>>     8. hashOutputs (32-byte hash)
>>     9. nLocktime (4-byte little endian)
>>    10. nInputIndex (4-byte little endian)
>>    11. nFees (8-byte little endian)
>>    12. hashtype (4-byte little endian)
>>    13. sigversion (4-byte little endian for the fixed value 0x01000000)
>> 
>> The bit 0 to 3 of hashtype denotes a value between 0 and 15:
>> 
>> 	? If the value is 1, the signature is invalid.
>> 	? If the value is 3 or below, hashPrevouts is the hash of all input, same as defined in BIP143. Otherwise, it is 32-byte of 0x0000......0000.
>> 	? If the value is 7 or below, outpoint is the COutPoint of the current input. Otherwise, it is 36-byte of 0x0000......0000.
>> 	? If the value is 0, hashSequence is the hash of all sequence, same as defined in BIP143. Otherwise, it is 32-byte of 0x0000......0000.
>> 	? If the value is even (including 0), nSequence is the nSequence of the current input. Otherwise, it is 0x00000000.
>> 	? If the value is 6, 7, 10, 11, 14, or 15, nInputIndex is 0x00000000. Otherwise, it is the index of the current input.
>> 	? If the value is 11 or below, nAmount is the value of the current input (same as BIP143). Otherwise, it is 0x0000000000000000.
>> 
>> The bit 4 and 5 of hashtype denotes a value between 0 and 3:
>> 
>> 	? If the value is 0, hashOutputs is same as the SIGHASH_ALL case in BIP143 as a hash of all outputs.
>> 	? If the value is 1, the signature is invalid.
>> 	? If the value is 2, hashOutputs is same as the SIGHASH_SINGLE case in BIP143 as a hash of the matching output. If a matching output does not exist, hashOutputs is 32-byte of 0x0000......0000.
>> 	? If the value is 3, hashOutputs is 32-byte of 0x0000......0000.
>> If bit 6 is set (SIGHASH2_NOFEE), nFees is 0x0000000000000000. Otherwise, it is the fee paid by the transaction.
>> If bit 7 is set (SIGHASH2_NOLOCKTIME), nLockTime is 0x00000000. Otherwise, it is the transaction nLockTime.
>> 
>> If bit 8 is set (SIGHASH2_NOVERSION), nVersion is 0x00000000. Otherwise, it is the transaction nVersion.
>> 
>> If bit 9 is set (SIGHASH2_NOSCRIPTCODE), scriptCode is an empty script. Otherwise, it is same as described in BIP143.
>> 
>> Bits 10 to 15 are reserved and ignored, but the signature still commits to their value as hashtype.
>> 
>> hashtype of 0 is also known as SIGHASH2_ALL, which covers all the available options. In this case the singnature MUST be exactly 64-byte.
>> 
>> hashtype of 0x3ff is also known as SIGHASH2_NONE, which covers nothing and is effectively forfeiting the right related to this public key to anyone.
>> 
>> *Rationale
>> 
>> **Signature Format
>> 
>> The current DER format is a complete waste of block space. The new format saves ~8 bytes per signature.
>> 
>> **New hashtype definitions
>> 
>> The default and most commonly used case is SIGHASH2_ALL. Making it zero size to save space. As a result, the bit flags are defined in a negative way (e.g. NOLOCKTIME)
>> 
>> Why decouple INPUT and SEQUENCE? Maybe you want NOINPUT but still have a relative lock-time?
>> 
>> Why some combinations are missing? To save some bits for useless flags. If you sign all inputs, you must know its index and value. If you sign only this input, you must know its value, but probably don't know its index in the input vector.
>> 
>> Why only allow signing all SEQUENCE if all INPUT are signed? It doesn't make much sense if you care about their sequence without even knowing what they are.
>> 
>> Why signing INPUTINDEX? Legacy and BIP143 SINGLE|ANYONECANPAY behaves differently for input index. Better make it explicit and optional.
>> 
>> Why signing FEE? Sometimes you don't sign all inputs / outputs but still want to make sure the fees amount is correct.
>> 
>> Putting NOVERSION and NOSCRIPTCODE in the second byte makes most signatures below 66 bytes:
>> 
>> 	? NOVERSION: Currently the only use of transaction version is to enforce BIP68. It could be safely assumed that version 2 is used. The only case one would like to use NOVERSION is to make the signature compatible with some unknown new features that use a different transaction version.
>> 	? NOSCRIPTCODE: It would be very rare if one could make a signature without knowing what the script is (at least they know the public key). The only scenario that a NOSCRIPTCODE is really needed is the public key being reused in different scripts, and the user wants to use a single signature to cover all these scripts.
>> Reserved bits: These bits are ignored but should normally be unset. Users MUST NOT set these bits until they are defined by a future proposal, or they might lose money.
>> Why sigversion? Make sure the message digest won't collide with SIGHASH schemes in the past (legacy and BIP143) and future (which will use a different sigversion).
>> 
>> *Examples
>> 
>> Equivalent SIGHASH2 value for other SIGHASH schemes:
>> Legacy/BIP143 ALL: 0 (commit to everything)
>> Legacy/BIP143 SINGLE with matching output: 0x62 (all input, one sequence, one output, no fee)
>> Legacy SINGLE without matching output: 0x3ff (Not exactly. Both signatures commit to nothing, but the legacy one is valid only without a matched output. Practically, they are both "wildcard" signatures that allow anyone to spend any related UTXO)
>> Legacy/BIP143 NONE: 0x72 (all input, one sequence, no output, no fee)
>> Legacy/BIP143 ANYONECANPAY|ALL: 0x46 (one input without index, one sequence, all output, no fee)
>> Legacy ANYONECANPAY|SINGLE with matching output: 0x64 (one input with index, one sequence, one output, no fee)
>> Legacy/BIP143 ANYONECANPAY|NONE: 0x76 (one input without index, one sequence, no output, no fee)
>> BIP143 SINGLE without matching output: 0x62 (all input, one sequence, no output, no fee)
>> BIP143 ANYONECANPAY|SINGLE with matching output: 0x66 (one input without index, one sequence, one output, no fee)
>> BIP143 ANYONECANPAY|SINGLE without matching output: 0x66 (one input without index, one sequence, no output, no fee)
>> BIP118 NOINPUT: 0x14b (no input but with value, no index, no sequence, no fee, no scriptcode)
>> 
>> Notes:
>> 
>> 1. In legacy and BIP143 SIGHASH, only ALL but not other types implicitly commits to the fee paid.
>> 2. Legacy SIGHASH always implicitly commits to the input value. BIP143 and BIP118 commits to that explicitly.
>> 3. Legacy and BIP143 SIGHASH behaves differently in the case of SINGLE without matching output. In legacy SIGHASH it is a true "wildcard signature" that allows anyone to spend any related UTXO. In BIP143 such signature applies only to a specific UTXO.
>> 4. BIP143 ANYONECANPAY never commits to the input index. Legacy ANYONECANPAY|SINGLE implicitly commits to the input index.
>> 
>> *Backward compatibility
>> 
>> This is a soft-fork.
>> 
>> *Deployment
>> 
>> Exact details TBD.
>> 
>> *Reference Implementation
>> 
>> https://github.com/jl2012/bitcoin/commits/sighash2 (To be updated)
>> 
>> *Copyright
>> 
>> This document is licensed as BSD 3-clause.
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From jl2012 at xbt.hk  Fri Aug 31 07:42:07 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Fri, 31 Aug 2018 15:42:07 +0800
Subject: [bitcoin-dev] SIGHASH2 for version 1 witness programme
In-Reply-To: <87sh2vlgsc.fsf@gmail.com>
References: <9CCCE945-9432-41B9-8559-AFE7CF233603@xbt.hk>
	<B35E0135-2135-405A-9627-F67EFB9D2614@xbt.hk>
	<87sh2vlgsc.fsf@gmail.com>
Message-ID: <23B1C9E3-9C94-43A3-A543-0AF9A8C10C7E@xbt.hk>

Great, I?ll revise it.

Follow-up questions:

1. Is there any useful case which one would like to use NOINPUT with scriptCode and/or scriptPubKey committed? (Note that with taproot/MAST, scriptCode and scriptPubKey are not interchangeable. scriptPubKey commits to all branches, and scriptCode is just one script branch). If yes, we could make this configurable.

2. Which of the following approaches is better?
A) sign scriptPubKey in every cases except NOINPUT
B) sign the type (P2SH-segwit vs. Native-segwit) of scriptPubKey in every cases, including NOINPUT
C) all of the above
D) none of the above

Option B is very easy to implement as SignatureHash() could distinguish the type by the size of scriptSig in TxTo. Option A is more complicated as GenericTransactionSignatureChecker needs to know the scriptPubKey.

If the only reason for doing this is to allow hardware wallet to distinguish the segwit type, option B is probably enough. This is also compatible with eltoo.

Option A is useful when a hardware wallet reuses the same public key in different scripts, but it couldn?t be applied to NOINPUT

3. Is the proposed DUALOUTPUT somehow useful for eltoo? Eltoo use NOINPUT|SINGLE to allow fee pumping, since it is an one-input-one-output tx. This is not possible with the existing LN as the tx is one-input-two-output. If we had DUALOUTPUT which signs the matched and last output, fee-pumping would be possible in the existing LN.




> On 31 Aug 2018, at 4:51 AM, Christian Decker <decker.christian at gmail.com> wrote:
> 
> Thanks for the update Johnson, just wanted to give a really quick NACK
> on the SIGHASH_NOINPUT variant: the whole idea of BIP 118 is to have
> floating transactions that can be bound to predecessors, and still
> enforce some application logic. In eltoo's case this is the fact that
> the state number needs to be smaller than the state number of the
> transaction that is being rewritten. The state number that we bind to is
> part of the `scriptPubKey`, so we can't commit to the `scriptPubKey` in
> the signature since we don't know which output (and thus it's
> scriptPubKey`) is at the time we sign.
> 
> If we are committing to `scriptPubKey` this whole way of enforcing order
> in updates is no longer possible, and the only thing we actually get
> from this change is a (very weak) malleability fix. The same argument
> goes for `scriptCode`.
> 
> Cheers,
> Christian
> 
> Johnson Lau <jl2012 at xbt.hk> writes:
>> After gathering some feedbacks I substantially revised the proposal. This version focus on improving security, and reduces the number of optional features.
>> 
>> Formatted BIP and sample code at:
>> https://github.com/jl2012/bips/blob/sighash2/bip-sighash2.mediawiki
>> https://github.com/jl2012/bitcoin/commits/sighash2
>> 
>> The major new features compared with BIP143:
>> 
>> 1. If signing all inputs, also sign all input value. BIP143 signature only covers the value of the same input. In some cases this may not be adequate for hardware wallet to determine the right amount of fees. Signing all input values will secure any possible case.
>> 2. Sign both scriptCode and previous scriptPubKey. In the original bitcoin design, previous scriptPubKey is signed as the scriptCode. However, this is not the case with P2SH and segwit. Explicitly committing to the scriptPubKey allows hardware wallet to confirm what it is actually signing (e.g. P2SH-segwit vs. Native-segwit).
>> 3. SIGHASH2_NOINPUT: basically same as BIP118, but the signature commits to both scriptCode and scriptPubKey. This prevents signature replay if the same public key is used in different scripts.
>> 4. SIGHASH2_MATCHOUTPUT (previously SIGHASH_SINGLE) disallows out-of-range case.
>> 5. SIGHASH2_LASTOUTPUT: signs only the highest index output.
>> 6. SIGHASH2_DUALOUTPUT: signs the matched output and the highest index output. Described by gmaxwell at https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016188.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016188.html>
>> 7. Signing the amount of fees (optional, yes by default). In case of not signing all inputs or outputs, users may still want to commit to a specific fee amount.
>> 8. Signing the witness size (optional, yes by default). While segwit fixed txid malleability, it is not a fix of script malleability. It may cause some trouble if an attacker could bloat the witness and reduce the fee priority of a transaction. Although the witness size is not malleable for most simple scripts, this is not guaranteed for more complex ones. Such kind of size malleability could be avoided if signatures commit to the size of witness.
>> 
>> Any suggestions are welcomed. But I have the following questions:
>> 
>> 1. Should NOINPUT commit to scriptCode and/or scriptPubKey? I think it should, because that helps avoid signature replay in some cases, and also lets hardware wallets know what they are signing. I am asking this because BIP118 proposes the opposite. I want to make sure I?m not missing something here.
>> 2. Do we want to add LASTOUTPUT and DUALOUTPUT? Suggested by gmaxwell, an example use case is kickstarter, where individual supporters send money to the last output for a kickstarter project, and send change to the matched output. However, I doubt if this would be actually used this way, because the kickstarter organiser could always take the money before the target is met, by making up the difference with his own input. This is an inherent problem for any anonymous kickstarter scheme. If these new SIGHASHs are not useful in other applications, I am not sure if we should add them.
>> 3. Instead of these restrictive MATCH/LAST/DUALOUTPUT, do we want a fully flexible way to sign a subset of outputs? The indexes of signed outputs are put at the end of the signature, and the signature won?t commit to these index values. Therefore, a third party could collect all transactions of this kind and merge them into one transaction. To limit the sighash cost, number of signed outputs might not be more than 2 or 3. Some potential problems: a) code complexity; b) 1-byte or 2-byte index: 1-byte will limit the number of outputs to 256. 2-byte will use more space even for smaller txs; c) highly variable signature size makes witness size estimation more difficult
>> 4. Should we sign the exact witness size (as proposed), or an upper size limit? Signing an upper limit will take up more space, as the limit has to be explicitly shown in the witness. The overhead could be avoided by showing the limit only if the actual witness size is not equal to the committed limit. However, I tend to keep it simple and sign the exact value. If in a multi-sig setup some signers are unable to accurately estimate the witness size, they should leave this responsibility to the last signer who should know the exact size.
>> 
>> 
>>> On 1 Jun 2018, at 2:35 AM, Johnson Lau via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>> 
>>> Since 2016, I have made a number of proposals for the next generation of script. Since then, there has been a lot of exciting development on this topic. The most notable ones are Taproot and Graftroot proposed by Maxwell. It seems the most logical way is to implement MAST and other new script functions inside Taproot and/or Graftroot. Therefore, I substantially simplified my earlier proposal on SIGHASH2. It is a superset of the existing SIGHASH and the BIP118 SIGHASH_NOINPUT, with further flexibility but not being too complicated. It also fixes some minor problems that we found in the late stage of BIP143 review. For example, the theoretical (but not statistical) possibility of having same SignatureHash() results for a legacy and a witness transaction. This is fixed by padding a constant at the end of the message so collision would not be possible.
>>> 
>>> A formatted version and example code could be found here:
>>> https://github.com/jl2012/bips/blob/sighash2/bip-sighash2.mediawiki
>>> https://github.com/jl2012/bitcoin/commits/sighash2
>>> 
>>> 
>>> ========
>>> 
>>> BIP: YYY
>>> Layer: Consensus (soft fork)
>>> Title: Signature checking operations in version 1 witness program
>>> Author: Johnson Lau <jl2012 at xbt.hk>
>>> Comments-Summary: No comments yet.
>>> Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0YYY
>>> Status: Draft
>>> Type: Standards Track
>>> Created: 2017-07-19
>>> License: BSD-3-Clause
>>> 
>>> 
>>> *Abstract
>>> 
>>> This BIP defines signature checking operations in version 1 witness program.
>>> 
>>> *Motivation
>>> 
>>> Use of compact signatures to save space.
>>> 
>>> More SIGHASH options, more flexibility
>>> 
>>> *Specification
>>> 
>>> The following specification is applicable to OP_CHECKSIG and OP_CHECKSIGVERIFY in version 1 witness program.
>>> 
>>> **Public Key Format
>>> 
>>> The pubic key MUST be exactly 33 bytes.
>>> 
>>> If the first byte of the public key is a 0x02 or 0x03, it MUST be a compressed public key. The signature is a Schnorr signature (To be defined separately)
>>> 
>>> If the first byte of the public key is neither 0x02 nor 0x03, the signature is assumed valid. This is for future upgrade.
>>> 
>>> **Signature Format
>>> 
>>> The following rules apply only if the first byte of the public key is a 0x02 or 0x03.
>>> 
>>> If the signature size is 64 to 66 byte, it MUST be a valid Schnorr signature or the script execution MUST fail (cf. BIP146 NULLFAIL). The first 32-byte is the R value in big-endian. The next 32-byte is the S value in big-endian. The remaining data, if any, denotes the hashtype in little-endian (0 to 0xffff).
>>> 
>>> hashtype MUST be minimally encoded. Any trailing zero MUST be removed.
>>> 
>>> If the signature size is zero, it is accepted as the "valid failing" signature for OP_CHECKSIG to return a FALSE value to the stack. (cf. BIP66)
>>> 
>>> The script execution MUST fail with a signature size not 0, 64, 65, or 66-byte.
>>> 
>>> **New hashtype definitions
>>> 
>>> hashtype and the SignatureHash function are re-defined:
>>> 
>>> Double SHA256 of the serialization of:
>>>    1. nVersion (4-byte little endian)
>>>    2. hashPrevouts (32-byte hash)
>>>    3. hashSequence (32-byte hash)
>>>    4. outpoint (32-byte hash + 4-byte little endian)
>>>    5. scriptCode (serialized as scripts inside CTxOuts)
>>>    6. nAmount (8-byte little endian)
>>>    7. nSequence (4-byte little endian)
>>>    8. hashOutputs (32-byte hash)
>>>    9. nLocktime (4-byte little endian)
>>>   10. nInputIndex (4-byte little endian)
>>>   11. nFees (8-byte little endian)
>>>   12. hashtype (4-byte little endian)
>>>   13. sigversion (4-byte little endian for the fixed value 0x01000000)
>>> 
>>> The bit 0 to 3 of hashtype denotes a value between 0 and 15:
>>> 
>>> 	? If the value is 1, the signature is invalid.
>>> 	? If the value is 3 or below, hashPrevouts is the hash of all input, same as defined in BIP143. Otherwise, it is 32-byte of 0x0000......0000.
>>> 	? If the value is 7 or below, outpoint is the COutPoint of the current input. Otherwise, it is 36-byte of 0x0000......0000.
>>> 	? If the value is 0, hashSequence is the hash of all sequence, same as defined in BIP143. Otherwise, it is 32-byte of 0x0000......0000.
>>> 	? If the value is even (including 0), nSequence is the nSequence of the current input. Otherwise, it is 0x00000000.
>>> 	? If the value is 6, 7, 10, 11, 14, or 15, nInputIndex is 0x00000000. Otherwise, it is the index of the current input.
>>> 	? If the value is 11 or below, nAmount is the value of the current input (same as BIP143). Otherwise, it is 0x0000000000000000.
>>> 
>>> The bit 4 and 5 of hashtype denotes a value between 0 and 3:
>>> 
>>> 	? If the value is 0, hashOutputs is same as the SIGHASH_ALL case in BIP143 as a hash of all outputs.
>>> 	? If the value is 1, the signature is invalid.
>>> 	? If the value is 2, hashOutputs is same as the SIGHASH_SINGLE case in BIP143 as a hash of the matching output. If a matching output does not exist, hashOutputs is 32-byte of 0x0000......0000.
>>> 	? If the value is 3, hashOutputs is 32-byte of 0x0000......0000.
>>> If bit 6 is set (SIGHASH2_NOFEE), nFees is 0x0000000000000000. Otherwise, it is the fee paid by the transaction.
>>> If bit 7 is set (SIGHASH2_NOLOCKTIME), nLockTime is 0x00000000. Otherwise, it is the transaction nLockTime.
>>> 
>>> If bit 8 is set (SIGHASH2_NOVERSION), nVersion is 0x00000000. Otherwise, it is the transaction nVersion.
>>> 
>>> If bit 9 is set (SIGHASH2_NOSCRIPTCODE), scriptCode is an empty script. Otherwise, it is same as described in BIP143.
>>> 
>>> Bits 10 to 15 are reserved and ignored, but the signature still commits to their value as hashtype.
>>> 
>>> hashtype of 0 is also known as SIGHASH2_ALL, which covers all the available options. In this case the singnature MUST be exactly 64-byte.
>>> 
>>> hashtype of 0x3ff is also known as SIGHASH2_NONE, which covers nothing and is effectively forfeiting the right related to this public key to anyone.
>>> 
>>> *Rationale
>>> 
>>> **Signature Format
>>> 
>>> The current DER format is a complete waste of block space. The new format saves ~8 bytes per signature.
>>> 
>>> **New hashtype definitions
>>> 
>>> The default and most commonly used case is SIGHASH2_ALL. Making it zero size to save space. As a result, the bit flags are defined in a negative way (e.g. NOLOCKTIME)
>>> 
>>> Why decouple INPUT and SEQUENCE? Maybe you want NOINPUT but still have a relative lock-time?
>>> 
>>> Why some combinations are missing? To save some bits for useless flags. If you sign all inputs, you must know its index and value. If you sign only this input, you must know its value, but probably don't know its index in the input vector.
>>> 
>>> Why only allow signing all SEQUENCE if all INPUT are signed? It doesn't make much sense if you care about their sequence without even knowing what they are.
>>> 
>>> Why signing INPUTINDEX? Legacy and BIP143 SINGLE|ANYONECANPAY behaves differently for input index. Better make it explicit and optional.
>>> 
>>> Why signing FEE? Sometimes you don't sign all inputs / outputs but still want to make sure the fees amount is correct.
>>> 
>>> Putting NOVERSION and NOSCRIPTCODE in the second byte makes most signatures below 66 bytes:
>>> 
>>> 	? NOVERSION: Currently the only use of transaction version is to enforce BIP68. It could be safely assumed that version 2 is used. The only case one would like to use NOVERSION is to make the signature compatible with some unknown new features that use a different transaction version.
>>> 	? NOSCRIPTCODE: It would be very rare if one could make a signature without knowing what the script is (at least they know the public key). The only scenario that a NOSCRIPTCODE is really needed is the public key being reused in different scripts, and the user wants to use a single signature to cover all these scripts.
>>> Reserved bits: These bits are ignored but should normally be unset. Users MUST NOT set these bits until they are defined by a future proposal, or they might lose money.
>>> Why sigversion? Make sure the message digest won't collide with SIGHASH schemes in the past (legacy and BIP143) and future (which will use a different sigversion).
>>> 
>>> *Examples
>>> 
>>> Equivalent SIGHASH2 value for other SIGHASH schemes:
>>> Legacy/BIP143 ALL: 0 (commit to everything)
>>> Legacy/BIP143 SINGLE with matching output: 0x62 (all input, one sequence, one output, no fee)
>>> Legacy SINGLE without matching output: 0x3ff (Not exactly. Both signatures commit to nothing, but the legacy one is valid only without a matched output. Practically, they are both "wildcard" signatures that allow anyone to spend any related UTXO)
>>> Legacy/BIP143 NONE: 0x72 (all input, one sequence, no output, no fee)
>>> Legacy/BIP143 ANYONECANPAY|ALL: 0x46 (one input without index, one sequence, all output, no fee)
>>> Legacy ANYONECANPAY|SINGLE with matching output: 0x64 (one input with index, one sequence, one output, no fee)
>>> Legacy/BIP143 ANYONECANPAY|NONE: 0x76 (one input without index, one sequence, no output, no fee)
>>> BIP143 SINGLE without matching output: 0x62 (all input, one sequence, no output, no fee)
>>> BIP143 ANYONECANPAY|SINGLE with matching output: 0x66 (one input without index, one sequence, one output, no fee)
>>> BIP143 ANYONECANPAY|SINGLE without matching output: 0x66 (one input without index, one sequence, no output, no fee)
>>> BIP118 NOINPUT: 0x14b (no input but with value, no index, no sequence, no fee, no scriptcode)
>>> 
>>> Notes:
>>> 
>>> 1. In legacy and BIP143 SIGHASH, only ALL but not other types implicitly commits to the fee paid.
>>> 2. Legacy SIGHASH always implicitly commits to the input value. BIP143 and BIP118 commits to that explicitly.
>>> 3. Legacy and BIP143 SIGHASH behaves differently in the case of SINGLE without matching output. In legacy SIGHASH it is a true "wildcard signature" that allows anyone to spend any related UTXO. In BIP143 such signature applies only to a specific UTXO.
>>> 4. BIP143 ANYONECANPAY never commits to the input index. Legacy ANYONECANPAY|SINGLE implicitly commits to the input index.
>>> 
>>> *Backward compatibility
>>> 
>>> This is a soft-fork.
>>> 
>>> *Deployment
>>> 
>>> Exact details TBD.
>>> 
>>> *Reference Implementation
>>> 
>>> https://github.com/jl2012/bitcoin/commits/sighash2 (To be updated)
>>> 
>>> *Copyright
>>> 
>>> This document is licensed as BSD 3-clause.
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From greg at xiph.org  Fri Aug 31 00:06:06 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Fri, 31 Aug 2018 00:06:06 +0000
Subject: [bitcoin-dev] Testnet3 Reest
In-Reply-To: <7E247E56-38A5-4B99-941A-A2CC837D2567@xbt.hk>
References: <CABuOfuh7M6siJW1FzXajsBSeYSu=TBEgx9SAmCbwnP=yb7rJOQ@mail.gmail.com>
	<20180830200239.ujuzh7pitcuatdt3@petertodd.org>
	<7E247E56-38A5-4B99-941A-A2CC837D2567@xbt.hk>
Message-ID: <CAAS2fgSF=hx581aGUBVv6zardKG4gex43B-jZbAu0a9Rupg1WQ@mail.gmail.com>

On Thu, Aug 30, 2018 at 11:21 PM Johnson Lau via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> A public testnet is still useful so in articles people could make references to these transactions.
> Maybe we could have 2 testnets at the same time, with one having a smaller block size?

I would much rather have a signed blocks testnet, with a predictable
structured reorg pattern* (and a config flag so you can make your node
ignore all blocks that are going to get reorged out in a reorg of nth
or larger).  There are many applications where the mined testnet just
doesn't give you anything useful... it's too stable when you want it
to be a bit unstable and too wildly unstable when you want a bit of
stability-- e.g. there are very few test cases where a 20,000 block
reorg does anything useful for you; yet they happen on testnet.

We looked at doing this previously in Bitcoin core and jtimon had some
patches,  but the existing approach increased the size of the
blockindex objects in memory  while not in signed testnet mode.   This
could probably have been fixed by turning one of the fields like the
merkel root into a union of it's normal value and a pointer a
look-aside block index that is used only in signed block testnet mode.

Obviously such a mode wouldn't be a replacement for an ordinary
testnet, but it would be a useful middle ground between regtest (that
never sees anything remotely surprising and can't easily be used for
collaborative testing) and full on testnet where your attempts to test
against ordinary noise require you cope your entirely universe being
removed from existence and replaced by something almost but not quite
entirely different at the whim of some cthulhuian blind idiot god.

From nakagat at gmail.com  Fri Aug 31 05:22:54 2018
From: nakagat at gmail.com (nakagat)
Date: Fri, 31 Aug 2018 14:22:54 +0900
Subject: [bitcoin-dev] Multisignature for bip-schnorr
In-Reply-To: <CAHk9a9ct_h485MY4gk7S++FAu5FEH3PL9pd9mrrh+wA8nWaVUA@mail.gmail.com>
References: <CAHk9a9ct_h485MY4gk7S++FAu5FEH3PL9pd9mrrh+wA8nWaVUA@mail.gmail.com>
Message-ID: <CAHk9a9etgH75Y1rO7v2JnVHnASqCgj5_jfMshBvjcTZkrRQdjg@mail.gmail.com>

Hi all,

I wrote t-of-k threshold signature procedure using bip-schnorr.

If you have time to review and give feedback, I?d really appreciate it.
Thanks in advance!

Threshold Signatures
https://gist.github.com/tnakagawa/e6cec9a89f698997dc58a09db541e1eb

Original
https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki#Multisignatures_and_Threshold_Signatures

-- 
nakagawa

2018?8?7?(?) 15:35 nakagat <nakagat at gmail.com>:
>
> Hi all,
>
> I wrote a multisignature procedure using bip-schnorr.
>
> If you have time to review and give feedback, I?d really appreciate it.
> Thanks in advance!
>
> Multisignature
> https://gist.github.com/tnakagawa/0c3bc74a9a44bd26af9b9248dfbe598b
>
> Original
> https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki#Multisignatures_and_Threshold_Signatures
>
> --
> nakagawa

