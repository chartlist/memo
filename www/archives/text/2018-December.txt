From adam.ficsor73 at gmail.com  Sat Dec  1 12:07:40 2018
From: adam.ficsor73 at gmail.com (Adam Ficsor)
Date: Sat, 1 Dec 2018 19:07:40 +0700
Subject: [bitcoin-dev] BIP Proposal - Address Paste Improvement
In-Reply-To: <CAH+Axy4dwjKebmZfz8+-MW4ghNnhiDCe7_rFcXBE7pK+5enJzw@mail.gmail.com>
References: <CAEPKjgeJX7-LaJNkVk0GKbC5KhOE0aT+otpa-N1EVtwC35m9LQ@mail.gmail.com>
	<prvlaj$8er$1@blaine.gmane.org> <20181108131130.134b2d43@simplexum.com>
	<ps1kj6$fk5$1@blaine.gmane.org> <20181108230004.3f9cabcb@simplexum.com>
	<CAEPKjge8+BsV7Mo2wRtEVWyfF-8LJq4y2tY5qmtVLE41ahcsRg@mail.gmail.com>
	<CAH+Axy4dwjKebmZfz8+-MW4ghNnhiDCe7_rFcXBE7pK+5enJzw@mail.gmail.com>
Message-ID: <CAEPKjgfUox5Cw6ZLdQHBXZX64MGFJqAKRneydLRj7PxcCfGB8w@mail.gmail.com>

If this needs to be a BIP or not, that is up to this list to decide, I will
not be pushy abut it. We simply encountered a well defined and common issue
and we took the time to work out and specify our solution, so it may come
in handy for other developers encountering this same issue. We can argue
about the significance of it, but I suspect all arguments will come down to
how much an individual developer values UX or how much he does not.

On Sat, Dec 1, 2018 at 11:57 AM James MacWhyte <macwhyte at gmail.com> wrote:

> I liked the cheekiness of your summary, Adam ;)
>
> I'm not sure why this needs to be a BIP. It is a UX detail--not really
> related to bitcoin protocol or procedures. I wouldn't even call it a
> description of best practices, since every product's use case is going to
> be different.
>
> If you think there is a compelling reason for why this needs to be a
> documented standard, please elaborate!
>
> Thanks,
> James
>
>
> On Sun, Nov 11, 2018 at 7:41 PM Adam Ficsor via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Thank you for all your comments. To sum up:
>>
>> - There were no comments related to the implementation details.
>> - There are concerns about this may incentivize users to use copypaste
>> functionality extensively.
>> - A counter argument was made that crypto hijackers use the clipboard,
>> because that is the most convenient thing to hijack, not because they can
>> only hijack that and, if Bitcoin users would move to other ways of
>> specifying destinations, that may end up being just as an issue, too.
>> - The rest of the conversation was about crypto hijackers, which I think
>> is off topic in this thread.
>>
>> Finally I'd like to note, there's already a work in progress
>> implementation in Wasabi:
>> https://github.com/zkSNACKs/WalletWasabi/pull/825
>>
>> On Fri, Nov 9, 2018 at 1:14 AM Dmitry Petukhov via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>>
>>> > > Do you know any reasonably convenient mechanism for end user to
>>> > > transfer an address from, say, a web page to the wallet address
>>> > > input field ?
>>> >
>>> > - QR code scanning of a Bitcoin URI
>>> > - On Android: A "bitcoin:" URI intent or a BIP70 payment message
>>> > intent
>>> > - On desktop OSes there are similar mechanisms to launch Apps from the
>>> > browser (e.g. for mailto: links)
>>>
>>> This works if the author of the web page thought about this, and
>>> created appropriate liks/qr codes. In many cases, addresses are
>>> just presented for users as text, to copy.
>>>
>>> People also send addresses in message apps and emails. Maybe if
>>> applications start to autodetect bitcoin addresses and convert them to
>>> bitcoin: links, there will be less need to copy-paste. But I suspect
>>> that this feature will not be quickly adopted by applications.
>>>
>>> > For cases where the payee is a well-known entity the BIP70 payment
>>> > protocol has authentication via certificates. That doesn't work for
>>> > the "the person in front of you is the only trust anchor you have"
>>> > usecase though.
>>>
>>> There are also BIP75 and BIP47 that may help, but the number of wallets
>>> that support these protocols is small (I think in part because of
>>> relative complexity of these protocols).
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>
>>
>> --
>> Best,
>> ?d?m
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>

-- 
Best,
?d?m
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181201/21b2a889/attachment.html>

From macwhyte at gmail.com  Sat Dec  1 04:57:20 2018
From: macwhyte at gmail.com (James MacWhyte)
Date: Fri, 30 Nov 2018 20:57:20 -0800
Subject: [bitcoin-dev] BIP Proposal - Address Paste Improvement
In-Reply-To: <CAEPKjge8+BsV7Mo2wRtEVWyfF-8LJq4y2tY5qmtVLE41ahcsRg@mail.gmail.com>
References: <CAEPKjgeJX7-LaJNkVk0GKbC5KhOE0aT+otpa-N1EVtwC35m9LQ@mail.gmail.com>
	<prvlaj$8er$1@blaine.gmane.org> <20181108131130.134b2d43@simplexum.com>
	<ps1kj6$fk5$1@blaine.gmane.org> <20181108230004.3f9cabcb@simplexum.com>
	<CAEPKjge8+BsV7Mo2wRtEVWyfF-8LJq4y2tY5qmtVLE41ahcsRg@mail.gmail.com>
Message-ID: <CAH+Axy4dwjKebmZfz8+-MW4ghNnhiDCe7_rFcXBE7pK+5enJzw@mail.gmail.com>

I liked the cheekiness of your summary, Adam ;)

I'm not sure why this needs to be a BIP. It is a UX detail--not really
related to bitcoin protocol or procedures. I wouldn't even call it a
description of best practices, since every product's use case is going to
be different.

If you think there is a compelling reason for why this needs to be a
documented standard, please elaborate!

Thanks,
James


On Sun, Nov 11, 2018 at 7:41 PM Adam Ficsor via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Thank you for all your comments. To sum up:
>
> - There were no comments related to the implementation details.
> - There are concerns about this may incentivize users to use copypaste
> functionality extensively.
> - A counter argument was made that crypto hijackers use the clipboard,
> because that is the most convenient thing to hijack, not because they can
> only hijack that and, if Bitcoin users would move to other ways of
> specifying destinations, that may end up being just as an issue, too.
> - The rest of the conversation was about crypto hijackers, which I think
> is off topic in this thread.
>
> Finally I'd like to note, there's already a work in progress
> implementation in Wasabi:
> https://github.com/zkSNACKs/WalletWasabi/pull/825
>
> On Fri, Nov 9, 2018 at 1:14 AM Dmitry Petukhov via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>>
>> > > Do you know any reasonably convenient mechanism for end user to
>> > > transfer an address from, say, a web page to the wallet address
>> > > input field ?
>> >
>> > - QR code scanning of a Bitcoin URI
>> > - On Android: A "bitcoin:" URI intent or a BIP70 payment message
>> > intent
>> > - On desktop OSes there are similar mechanisms to launch Apps from the
>> > browser (e.g. for mailto: links)
>>
>> This works if the author of the web page thought about this, and
>> created appropriate liks/qr codes. In many cases, addresses are
>> just presented for users as text, to copy.
>>
>> People also send addresses in message apps and emails. Maybe if
>> applications start to autodetect bitcoin addresses and convert them to
>> bitcoin: links, there will be less need to copy-paste. But I suspect
>> that this feature will not be quickly adopted by applications.
>>
>> > For cases where the payee is a well-known entity the BIP70 payment
>> > protocol has authentication via certificates. That doesn't work for
>> > the "the person in front of you is the only trust anchor you have"
>> > usecase though.
>>
>> There are also BIP75 and BIP47 that may help, but the number of wallets
>> that support these protocols is small (I think in part because of
>> relative complexity of these protocols).
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
>
> --
> Best,
> ?d?m
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181130/37af33c4/attachment.html>

From macwhyte at gmail.com  Sat Dec  1 05:06:29 2018
From: macwhyte at gmail.com (James MacWhyte)
Date: Fri, 30 Nov 2018 21:06:29 -0800
Subject: [bitcoin-dev] draft proposal: change forwarding (improved
 fungibility through wallet interoperability)
In-Reply-To: <CAAQdECAGuScCLoG_62g6G__yiyN8KRiPDBGYJ2pDBwxRCNFtZQ@mail.gmail.com>
References: <CAAQdECAGuScCLoG_62g6G__yiyN8KRiPDBGYJ2pDBwxRCNFtZQ@mail.gmail.com>
Message-ID: <CAH+Axy5Qa+2YHLhmnoqLR-94QmWyePcckDjj+8jGrU37q51ZCA@mail.gmail.com>

Hi Yuval!

Sorry for reviving an old email thread. Could you describe what the UX
would be like, or how a wallet developer might implement this? Is the
intention that someone would open their non-private wallet, and choose an
option that slowly siphons their funds into a different app? Why would
anyone want that feature?

If the user is privacy-conscious, why did they choose the non-private
wallet to begin with? Why wouldn't they just move all their funds to the
private wallet so they can continue to use just one app?

And if the user is not privacy-conscious, they would never choose to enable
this option, so why would the wallet developer even bother to implement it?

>From a product standpoint, I can't see how this would be useful, and
therefore I'm not sure why it needs to be a BIP. If I'm missing something,
please let me know!

Thanks,
James


On Tue, Nov 6, 2018 at 10:18 AM Yuval Kogman via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hello,
>
> I would like to propose a method based on BIP32 (and optionally BIP44) for
> improving fungibility and on chain privacy with wallets for which this is
> not a primary concern, requiring minimal changes to allow such wallets to
> safely forward change outputs to more specialized wallets. This is intended
> to complement more comprehensive proposals such as BIP79.
>
> Note that this draft is still incomplete, there are open questions about
> the particular format to use. In its current form it proposes two viable
> options (and two more are included completeness) and though I have a slight
> preference for the first option, I remain undecided given the tradeoffs,
> and so I am writing the mailing list to solicit inputs/criticism.
>
> https://gist.github.com/nothingmuch/652f3a98089a0600637eadab738b2d6a
>
> Thanks to SirMeow, Adam Ficsor, and Adam Gibson for reviewing earlier
> versions and providing valuable feedback and suggestions.
>
> Regards,
> Yuval
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181130/36adb957/attachment-0001.html>

From bob at mcelrath.org  Sun Dec  2 15:08:39 2018
From: bob at mcelrath.org (Bob McElrath)
Date: Sun, 2 Dec 2018 15:08:39 +0000
Subject: [bitcoin-dev] CPFP Carve-Out for Fee-Prediction Issues in
 Contracting Applications (eg Lightning)
In-Reply-To: <c3f68b73-84c6-7428-4bf6-b47802141392@mattcorallo.com>
References: <c3f68b73-84c6-7428-4bf6-b47802141392@mattcorallo.com>
Message-ID: <20181202150839.GE22873@mcelrath.org>

I've long thought about using SIGHASH_SINGLE, then either party can add inputs
to cover whatever fee they want on channel close and it doesn't have to be
pre-planned at setup.

For Lightning I think you'd want to cross-sign, e.g. Alice signs her input
and Bob's output, while Bob signs his input and Alice's output.  This would
demotivate the two parties from picking apart the transaction and broadcasting
one of the two SIGHASH_SINGLE's in a Lightning transaction.

Matt Corallo via bitcoin-dev [bitcoin-dev at lists.linuxfoundation.org] wrote:
> (cross-posted to both lists to make lightning-dev folks aware, please take
> lightning-dev off CC when responding).
> 
> As I'm sure everyone is aware, Lightning (and other similar systems) work by
> exchanging pre-signed transactions for future broadcast. Of course in many
> cases this requires either (a) predicting what the feerate required for
> timely confirmation will be at some (or, really, any) point in the future,
> or (b) utilizing CPFP and dependent transaction relay to allow parties to
> broadcast low-feerate transactions with children created at broadcast-time
> to increase the effective feerate. Ideally transactions could be constructed
> to allow for after-the-fact addition of inputs to increase fee without CPFP
> but it is not always possible to do so.
> 
> Option (a) is rather obviously intractible, and implementation complexity
> has led to channel failures in lightning in practice (as both sides must
> agree on a reasonable-in-the-future feerate). Option (b) is a much more
> natural choice (assuming some form of as-yet-unimplemented package relay on
> the P2P network) but is made difficult due to complexity around RBF/CPFP
> anti-DoS rules.
> 
> For example, if we take a simplified lightning design with pre-signed
> commitment transaction A with one 0-value anyone-can-spend output available
> for use as a CPFP output, a counterparty can prevent confirmation
> of/significantly increase the fee cost of confirming A by chaining a
> large-but-only-moderate-feerate transaction off of this anyone-can-spend
> output. This transaction, B, will have a large absolute fee while making the
> package (A, B) have a low-ish feerate, placing it solidly at the bottom of
> the mempool but without significant risk of it getting evicted during memory
> limiting. This large absolute fee forces a counterparty which wishes to have
> the commitment transaction confirm to increase on this absolute fee in order
> to meet RBF rules.
> 
> For this reason (and many other similar attacks utilizing the package size
> limits), in discussing the security model around CPFP, we've generally
> considered it too-difficulty-to-prevent third parties which are able to
> spend an output of a transaction from delaying its confirmation, at least
> until/unless the prevailing feerates decline and some of the mempool backlog
> gets confirmed.
> 
> You'll note, however, that this attack doesn't have to be permanent to work
> - Lightning's (and other contracting/payment channel systems') security
> model assumes the ability to get such commitment transactions confirmed in a
> timely manner, as otherwise HTLCs may time out and counterparties can claim
> the timeout-refund before we can claim the HTLC using the hash-preimage.
> 
> To partially-address the CPFP security model considerations, a next step
> might involve tweaking Lightning's commitment transaction to have two
> small-value outputs which are immediately spendable, one by each channel
> participant, allowing them to chain children off without allowng unrelated
> third-parties to chain children. Obviously this does not address the
> specific attack so we need a small tweak to the anti-DoS CPFP rules in
> Bitcoin Core/BIP 125:
> 
> The last transaction which is added to a package of dependent transactions
> in the mempool must:
>  * Have no more than one unconfirmed parent,
>  * Be of size no greater than 1K in virtual size.
> (for implementation sanity, this would effectively reduce all mempool
> package size limits by 1 1K-virtual-size transaction, and the last would be
> "allowed to violate the limits" as long as it meets the above criteria).
> 
> For contracting applications like lightning, this means that as long as the
> transaction we wish to confirm (in this case the commitment transaction)
>  * Has only two immediately-spendable (ie non-CSV) outputs,
>  * where each immediately-spendable output is only spendable by one
> counterparty,
>  * and is no larger than MAX_PACKAGE_VIRTUAL_SIZE - 1001 Vsize,
> each counterparty will always be able to independantly CPFP the transaction
> in question. ie because if the "malicious" (ie transaction-delaying) party
> bradcasts A with a child, it can never meet the "last transaction" carve-out
> as its transaction cannot both meet the package limit and have only one
> unconfirmed ancestor. Thus, the non-delaying counterparty can always
> independently add its own CPFP transaction, increasing the (A, Tx2) package
> feerate and confirming A without having to concern themselves with the (A,
> Tx1) package.
> 
> As an alternative proposal, at various points there have been discussions
> around solving the "RBF-pinning" problem by allowing transactors to mark
> their transactions as "likely-to-be-RBF'ed", which could enable a relay
> policy where children of such transactions would be rejected unless the
> resulting package would be "near the top of the mempool". This would
> theoretically imply such attacks are not possible to pull off consistently,
> as any "transaction-delaying" channel participant will have to place the
> package containing A at an effective feerate which makes confirmation to
> occur soon with some likelihood. It is, however, possible to pull off this
> attack with low probability in case of feerate spikes right after broadcast.
> 
> Note that this clearly relies on some form of package relay, which comes
> with its own challenges, but I'll start a separate thread on that.
> 
> See-also: lightning-dev thread about the changes to lightning spec required
> to incorporate this: https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-November/001643.html
> 
> Matt
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> 
> !DSPAM:5c014daf168271726154759!
--
Cheers, Bob McElrath

"For every complex problem, there is a solution that is simple, neat, and wrong."
    -- H. L. Mencken 


From nothingmuch at woobling.org  Sat Dec  1 15:33:52 2018
From: nothingmuch at woobling.org (Yuval Kogman)
Date: Sat, 1 Dec 2018 15:33:52 +0000
Subject: [bitcoin-dev] draft proposal: change forwarding (improved
 fungibility through wallet interoperability)
In-Reply-To: <CAH+Axy5Qa+2YHLhmnoqLR-94QmWyePcckDjj+8jGrU37q51ZCA@mail.gmail.com>
References: <CAAQdECAGuScCLoG_62g6G__yiyN8KRiPDBGYJ2pDBwxRCNFtZQ@mail.gmail.com>
	<CAH+Axy5Qa+2YHLhmnoqLR-94QmWyePcckDjj+8jGrU37q51ZCA@mail.gmail.com>
Message-ID: <CAAQdECC8V4cQxYOPda9+Fuob+n5oMx1vkfcv95sPaDyjTPyQKw@mail.gmail.com>

Hi,

On Sat, 1 Dec 2018 at 05:06, James MacWhyte <macwhyte at gmail.com> wrote:

> Is the intention that someone would open their non-private wallet, and
> choose an option that slowly siphons their funds into a different app?
>

Yes, that's the idea. And then send them back in a controlled manner.


> Why would anyone want that feature?
>

Most mobile wallets have no coin control features, which are tricky to
implement (lots of design/UI effort required). Some special purpose wallets
have additional privacy concerns and also lack coin control - for example
protip.is may inadvertently disclose browsing habits, or bisq arbitration
contracts are easily identifiable on the blockchain. The latter is actually
an inspiration to this, since it has functionality to allow funding
transactions from an external wallet, as well as withdrawing to one.

Conversely, fungibility focused wallets are highly specialized and limited
in scope. As far as I'm aware, JoinMarket and Wasabi are the only
maintained implementations of mixing wallets available today, and both are
desktop apps, with no hardware wallet integration. It is unlikely that e.g.
coinjoin functionality would be added the application specific wallets,
especially as these features require a great deal of care and effort to do
correctly (cf. SharedCoin)

The goal then is to allow people who are privacy conscious to utilize a
specialized wallet automatically, to isolate the activity of wallets which
don't provide a sufficient degree of control in order to achieve that
manually, and reducing the possibility of operator error.

Could you describe what the UX would be like
>

>From a payment standpoint the main difference is that change outputs would
not be usable, so the spendable balance would drop. The best idea I have
for handling that is to still display that balance but conveying that is
locked. However, I think simply removing it from the balance is also
acceptable. Funds would simply be added to the fungibility wallet similarly
to how they are used manually today.

For setup, the fungibility wallet would need to add functionality to export
these xpub variants, perhaps with a way of annotating what each account is
for (but see concerns about BIP44 recoverability). Like standard xpubs,
these would be easily conveyed by QR code.

The forwarding wallet would then offer an advanced configuration feature,
that allows adding and enabling the alternate change address chain. If the
fungibility wallet derives addresses differently, then the forwarding
wallet should reject the configuration value (which is the main technical
point of the writeup), to ensure funds are not misplaced.


> or how a wallet developer might implement this?
>

For fungibility wallets, this requires keeping track of these address
chains, and allowing them to be exported. This is similar to any sort of
scanning functionality implemented in a BIP32 capable wallet, plus the UI
to display them.

In the forwarding wallet, derivation of addresses is again already
implemented in any BIP32 capable wallet (i.e. checking for the next free
address), with the main change in the spending path being dependency
injection required to change the address chain parameters (from what I know
most BIP32 implementations are polymorphic with respect to derivations made
from a public extended key vs. a private extended key). The main effort
then is the setup functionality, which obviously will vary considerably
between wallets, but I imagine it would still be a simpler and safer change
than integrating comprehensive privacy features into the spend path
directly.

If the user is privacy-conscious, why did they choose the non-private
> wallet to begin with? Why wouldn't they just move all their funds to the
> private wallet so they can continue to use just one app?
>

Platform limitations, or application specific use cases, see above. More
broadly, the main rationale is that diverse, specialized wallets should be
used in a complementary way, as that is more achievable than expecting all
application specific wallets to have robust privacy features.

And if the user is not privacy-conscious, they would never choose to enable
> this option, so why would the wallet developer even bother to implement it?
>

I believe this is a low hanging fruit, easier to implement than coin
control, far easier to implement than safe mixing functionality, so wallet
developers (or contributes) would implement this to allow users more
reliable access to privacy features implemented by other wallets.


> From a product standpoint, I can't see how this would be useful, and
> therefore I'm not sure why it needs to be a BIP. If I'm missing something,
> please let me know!
>

The reason for documenting it in this way is because if deemed desirable
functionality (which itself is something the BIP process can help
determine), different implementations would need to agree on the details. I
hope I've managed to convince you of the usefulness, though I'm still not
sure about the practicality or desirability - as it stands right now I have
received fairly comprehensive criticism from LaurentMT though, and I've
been focusing on related idea to improve zerolink which I hope would to
revisit this change forwarding idea and address his concerns when I have
more clarity. The main weakness is the assumptions that fungibility wallets
handle arbitrary amounts allowing those funds to be tumbled and
recycled/consolidated, which realistically only applies to Join Market and
even then only if used correctly.

Regards,
Yuval
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181201/3d56135c/attachment.html>

From ZmnSCPxj at protonmail.com  Mon Dec  3 04:16:10 2018
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 03 Dec 2018 04:16:10 +0000
Subject: [bitcoin-dev] [Lightning-dev] CPFP Carve-Out for Fee-Prediction
	Issues in Contracting Applications (eg Lightning)
In-Reply-To: <20181202150839.GE22873@mcelrath.org>
References: <c3f68b73-84c6-7428-4bf6-b47802141392@mattcorallo.com>
	<20181202150839.GE22873@mcelrath.org>
Message-ID: <8-tJwX51A0xFHoEsKchKREO5i8YxqM48JWspLRiAV3TBHWrRUkUmcZqbAJH6Z6KBQAppPHwuClmzzoaLxtOQqWoHyQG8nzVJAuzAFFGl-s8=@protonmail.com>

Good morning Bob,

Would `SIGHASH_SINGLE` work?
Commitment transactions have a single input but multiple outputs.

Regards,
ZmnSCPxj


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Sunday, December 2, 2018 11:08 PM, Bob McElrath <bob at mcelrath.org> wrote:

> I've long thought about using SIGHASH_SINGLE, then either party can add inputs
> to cover whatever fee they want on channel close and it doesn't have to be
> pre-planned at setup.
>
> For Lightning I think you'd want to cross-sign, e.g. Alice signs her input
> and Bob's output, while Bob signs his input and Alice's output. This would
> demotivate the two parties from picking apart the transaction and broadcasting
> one of the two SIGHASH_SINGLE's in a Lightning transaction.
>
> Matt Corallo via bitcoin-dev [bitcoin-dev at lists.linuxfoundation.org] wrote:
>
> > (cross-posted to both lists to make lightning-dev folks aware, please take
> > lightning-dev off CC when responding).
> > As I'm sure everyone is aware, Lightning (and other similar systems) work by
> > exchanging pre-signed transactions for future broadcast. Of course in many
> > cases this requires either (a) predicting what the feerate required for
> > timely confirmation will be at some (or, really, any) point in the future,
> > or (b) utilizing CPFP and dependent transaction relay to allow parties to
> > broadcast low-feerate transactions with children created at broadcast-time
> > to increase the effective feerate. Ideally transactions could be constructed
> > to allow for after-the-fact addition of inputs to increase fee without CPFP
> > but it is not always possible to do so.
> > Option (a) is rather obviously intractible, and implementation complexity
> > has led to channel failures in lightning in practice (as both sides must
> > agree on a reasonable-in-the-future feerate). Option (b) is a much more
> > natural choice (assuming some form of as-yet-unimplemented package relay on
> > the P2P network) but is made difficult due to complexity around RBF/CPFP
> > anti-DoS rules.
> > For example, if we take a simplified lightning design with pre-signed
> > commitment transaction A with one 0-value anyone-can-spend output available
> > for use as a CPFP output, a counterparty can prevent confirmation
> > of/significantly increase the fee cost of confirming A by chaining a
> > large-but-only-moderate-feerate transaction off of this anyone-can-spend
> > output. This transaction, B, will have a large absolute fee while making the
> > package (A, B) have a low-ish feerate, placing it solidly at the bottom of
> > the mempool but without significant risk of it getting evicted during memory
> > limiting. This large absolute fee forces a counterparty which wishes to have
> > the commitment transaction confirm to increase on this absolute fee in order
> > to meet RBF rules.
> > For this reason (and many other similar attacks utilizing the package size
> > limits), in discussing the security model around CPFP, we've generally
> > considered it too-difficulty-to-prevent third parties which are able to
> > spend an output of a transaction from delaying its confirmation, at least
> > until/unless the prevailing feerates decline and some of the mempool backlog
> > gets confirmed.
> > You'll note, however, that this attack doesn't have to be permanent to work
> >
> > -   Lightning's (and other contracting/payment channel systems') security
> >     model assumes the ability to get such commitment transactions confirmed in a
> >     timely manner, as otherwise HTLCs may time out and counterparties can claim
> >     the timeout-refund before we can claim the HTLC using the hash-preimage.
> >
> >
> > To partially-address the CPFP security model considerations, a next step
> > might involve tweaking Lightning's commitment transaction to have two
> > small-value outputs which are immediately spendable, one by each channel
> > participant, allowing them to chain children off without allowng unrelated
> > third-parties to chain children. Obviously this does not address the
> > specific attack so we need a small tweak to the anti-DoS CPFP rules in
> > Bitcoin Core/BIP 125:
> > The last transaction which is added to a package of dependent transactions
> > in the mempool must:
> >
> > -   Have no more than one unconfirmed parent,
> > -   Be of size no greater than 1K in virtual size.
> >     (for implementation sanity, this would effectively reduce all mempool
> >     package size limits by 1 1K-virtual-size transaction, and the last would be
> >     "allowed to violate the limits" as long as it meets the above criteria).
> >
> >
> > For contracting applications like lightning, this means that as long as the
> > transaction we wish to confirm (in this case the commitment transaction)
> >
> > -   Has only two immediately-spendable (ie non-CSV) outputs,
> > -   where each immediately-spendable output is only spendable by one
> >     counterparty,
> >
> > -   and is no larger than MAX_PACKAGE_VIRTUAL_SIZE - 1001 Vsize,
> >     each counterparty will always be able to independantly CPFP the transaction
> >     in question. ie because if the "malicious" (ie transaction-delaying) party
> >     bradcasts A with a child, it can never meet the "last transaction" carve-out
> >     as its transaction cannot both meet the package limit and have only one
> >     unconfirmed ancestor. Thus, the non-delaying counterparty can always
> >     independently add its own CPFP transaction, increasing the (A, Tx2) package
> >     feerate and confirming A without having to concern themselves with the (A,
> >     Tx1) package.
> >
> >
> > As an alternative proposal, at various points there have been discussions
> > around solving the "RBF-pinning" problem by allowing transactors to mark
> > their transactions as "likely-to-be-RBF'ed", which could enable a relay
> > policy where children of such transactions would be rejected unless the
> > resulting package would be "near the top of the mempool". This would
> > theoretically imply such attacks are not possible to pull off consistently,
> > as any "transaction-delaying" channel participant will have to place the
> > package containing A at an effective feerate which makes confirmation to
> > occur soon with some likelihood. It is, however, possible to pull off this
> > attack with low probability in case of feerate spikes right after broadcast.
> > Note that this clearly relies on some form of package relay, which comes
> > with its own challenges, but I'll start a separate thread on that.
> > See-also: lightning-dev thread about the changes to lightning spec required
> > to incorporate this: https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-November/001643.html
> > Matt
> >
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> > !DSPAM:5c014daf168271726154759!
>
> --
> Cheers, Bob McElrath
>
> "For every complex problem, there is a solution that is simple, neat, and wrong."
> -- H. L. Mencken
>
> Lightning-dev mailing list
> Lightning-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev



From shatzakis at gmail.com  Mon Dec  3 18:27:52 2018
From: shatzakis at gmail.com (Steven Hatzakis)
Date: Mon, 3 Dec 2018 20:27:52 +0200
Subject: [bitcoin-dev] Proposal for Palindromic (Reversible) Mnemonics
Message-ID: <CABsxsG234DhY8Lxn0UMgXG0YnPdyJ5__U9P-aweV9L=xw7hxyw@mail.gmail.com>

Hi All,

I've developed a method to check if a mnemonic is also valid when the words
are put into reverse order (not the entropy), where a given 12 or 24-word
mnemonic could be valid both in little endian and big endian format. I've
coined these "Palindromic Mnemonics", but perhaps more user-friendly is
"reversible mnemonics."

Purpose:
A checksum-valid reversible mnemonic allows two separate vaults to be
connected to the same mnemonic string of words, where all a users must do
is enter the words in reverse order (the last word becomes first, second to
last becomes second, and so on) to access the secondary (reversed words)
vault. This utility could provide multiple use-cases, including related to
combinations with passphrases and plausible deniability, as well as
conveniences for those wishing to use a separate vault tied to the same
string of words.

Security:
For any randomly generated 12-word mnemonic (128-bits of security) the
chances of it also being reversible are 1/16 (I believe), as a total of 4
bit positions must be identical (4 bits from the normal mnemonic and
another 4 bits from the reversed string must match). For a 24-word
mnemonic, those values increase to 8 bits which need to match 8 bits from
the reversed string, leading to about 1 in every 256 mnemonics also being
reversible. While the message space of valid reversible mnemonics should be
2^124 for 12 words, that search must still be conducted over a field of 2^128,
as the hash-derived checksum values otherwise prevent a way to
deterministically find valid reversible mnemonics without first going
through invalid reversible ones to check. I think others should chime in on
whether they believe there is any security loss, in terms of entropy bits
(assuming the initial 128 bits were generated securely). I estimate at most
it would be 4-bits of loss for a 12-word mnemonic, but only if an attacker
had a way to search only the space of valid reversible mnemonics (2**124)
which I don't think is feasible (could be wrong?). There could also be
errors in my above assumptions, this is a work in progress and sharing it
here to solicit initial feedback/interest.

I've already written the code that can be used for testing (on GitHub user
@hatgit), and when run from terminal/command prompt it is pretty fast to
find a valid reversible mnemonics, whereas on IDLE in Python on a 32-bit
and 64-bit machine it could take a few seconds for 12 words and sometimes
10 minutes to find a valid 24-word reversible mnemonic.
Example 12 words reversible (with valid checksum each way):

limit exact seven clarify utility road image fresh leg cabbage hint canoe

And Reversed:

canoe hint cabbage leg fresh image road utility clarify seven exact limit


Example 24 reversible:

favorite uncover sugar wealth army shift goose fury market toe message
remain direct arrow duck afraid enroll salt knife school duck sunny grunt
argue

And reversed:

argue grunt sunny duck school knife salt enroll afraid duck arrow direct
remain message toe market fury goose shift army wealth sugar uncover
favorite


My two questions 1) are how useful could this be for you/users/devs/service
providers etc.. and 2) is any security loss occurring and whether it is
negligible or not?

Best regards,

Steven Hatzakis
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181203/cd2ca4c8/attachment.html>

From fireduck at gmail.com  Mon Dec  3 20:54:10 2018
From: fireduck at gmail.com (=?UTF-8?B?Sm9zZXBoIEdsZWFzb24g4pGI?=)
Date: Mon, 3 Dec 2018 12:54:10 -0800
Subject: [bitcoin-dev] Proposal for Palindromic (Reversible) Mnemonics
In-Reply-To: <CABsxsG234DhY8Lxn0UMgXG0YnPdyJ5__U9P-aweV9L=xw7hxyw@mail.gmail.com>
References: <CABsxsG234DhY8Lxn0UMgXG0YnPdyJ5__U9P-aweV9L=xw7hxyw@mail.gmail.com>
Message-ID: <CA+ASnrGEbksc-YeKR7bKpAv5=rcWcg8BeR6XDVUzvJ9C76bGpA@mail.gmail.com>

I have a suggestion.  If you are concerned about plausible deniability,
then it might make sense to just have the single mnemonic seed lead to a
single xprv key (as usual) and then do a private key derivation from that
based on a password string.  The password can be simple, as it is based on
the security of the seed, just as long as the user feels they need for
deniability.

A simple reverse scheme like you describe would just be another thing a
person would know to check if given some seed so I don't see it as
providing much value, but I could be missing something.

On Mon, Dec 3, 2018 at 10:45 AM Steven Hatzakis via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi All,
>
> I've developed a method to check if a mnemonic is also valid when the
> words are put into reverse order (not the entropy), where a given 12 or
> 24-word mnemonic could be valid both in little endian and big endian
> format. I've coined these "Palindromic Mnemonics", but perhaps more
> user-friendly is "reversible mnemonics."
>
> Purpose:
> A checksum-valid reversible mnemonic allows two separate vaults to be
> connected to the same mnemonic string of words, where all a users must do
> is enter the words in reverse order (the last word becomes first, second to
> last becomes second, and so on) to access the secondary (reversed words)
> vault. This utility could provide multiple use-cases, including related to
> combinations with passphrases and plausible deniability, as well as
> conveniences for those wishing to use a separate vault tied to the same
> string of words.
>
> Security:
> For any randomly generated 12-word mnemonic (128-bits of security) the
> chances of it also being reversible are 1/16 (I believe), as a total of 4
> bit positions must be identical (4 bits from the normal mnemonic and
> another 4 bits from the reversed string must match). For a 24-word
> mnemonic, those values increase to 8 bits which need to match 8 bits from
> the reversed string, leading to about 1 in every 256 mnemonics also being
> reversible. While the message space of valid reversible mnemonics should be
> 2^124 for 12 words, that search must still be conducted over a field of 2^128,
> as the hash-derived checksum values otherwise prevent a way to
> deterministically find valid reversible mnemonics without first going
> through invalid reversible ones to check. I think others should chime in on
> whether they believe there is any security loss, in terms of entropy bits
> (assuming the initial 128 bits were generated securely). I estimate at most
> it would be 4-bits of loss for a 12-word mnemonic, but only if an attacker
> had a way to search only the space of valid reversible mnemonics (2**124)
> which I don't think is feasible (could be wrong?). There could also be
> errors in my above assumptions, this is a work in progress and sharing it
> here to solicit initial feedback/interest.
>
> I've already written the code that can be used for testing (on GitHub user
> @hatgit), and when run from terminal/command prompt it is pretty fast to
> find a valid reversible mnemonics, whereas on IDLE in Python on a 32-bit
> and 64-bit machine it could take a few seconds for 12 words and sometimes
> 10 minutes to find a valid 24-word reversible mnemonic.
> Example 12 words reversible (with valid checksum each way):
>
> limit exact seven clarify utility road image fresh leg cabbage hint canoe
>
> And Reversed:
>
> canoe hint cabbage leg fresh image road utility clarify seven exact limit
>
>
> Example 24 reversible:
>
> favorite uncover sugar wealth army shift goose fury market toe message
> remain direct arrow duck afraid enroll salt knife school duck sunny grunt
> argue
>
> And reversed:
>
> argue grunt sunny duck school knife salt enroll afraid duck arrow direct
> remain message toe market fury goose shift army wealth sugar uncover
> favorite
>
>
> My two questions 1) are how useful could this be for
> you/users/devs/service providers etc.. and 2) is any security loss
> occurring and whether it is negligible or not?
>
> Best regards,
>
> Steven Hatzakis
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181203/4182bf2d/attachment.html>

From dscotese at litmocracy.com  Mon Dec  3 20:37:17 2018
From: dscotese at litmocracy.com (Dave Scotese)
Date: Mon, 3 Dec 2018 12:37:17 -0800
Subject: [bitcoin-dev] How much is too much time between difficulty changes?
Message-ID: <CAGLBAhdtXEjhZWavgytQAOuXUaJZc=ZQyvjB2KV-YczAh-H4WQ@mail.gmail.com>

The last difficulty change took about 20% longer than expected.  How large
does the time between difficulty changes have to get for us to make
changes?  In other words, if, at some point, block confirmation times are
averaging, say, hours or days, will we hardfork to speed things up?

One option is NO.  When enough economic interests align to amass the
computing power to get important bitcoin transactions into a block, then
they will work out a way to get that block confirmed.  This allows other
cryptocurrencies and technologies like LN to fill in.

There may be a group that will fork the code in order to adjust the
difficulty more rapidly, and bitcoin holders will put a value on
bitcoin-FDA ("Faster-Difficuly-Adjustment"), which is fine with me.  We can
learn how to fork peacefully from what we learned when BCH was born, and
what we learned when it split.

I think some insight into how core developers will handle increasing
demands to use faster difficulty adjustments (if they respond at all) will
be helpful, and this is why I'm asking.

Dave Scotese
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181203/9ca5ce6b/attachment-0001.html>

From rusty at rustcorp.com.au  Tue Dec  4 03:33:53 2018
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Tue, 04 Dec 2018 14:03:53 +1030
Subject: [bitcoin-dev] [Lightning-dev] CPFP Carve-Out for Fee-Prediction
	Issues in Contracting Applications (eg Lightning)
In-Reply-To: <c3f68b73-84c6-7428-4bf6-b47802141392@mattcorallo.com>
References: <c3f68b73-84c6-7428-4bf6-b47802141392@mattcorallo.com>
Message-ID: <878t163qzi.fsf@rustcorp.com.au>

Matt Corallo <lf-lists at mattcorallo.com> writes:
> As an alternative proposal, at various points there have been 
> discussions around solving the "RBF-pinning" problem by allowing 
> transactors to mark their transactions as "likely-to-be-RBF'ed", which 
> could enable a relay policy where children of such transactions would be 
> rejected unless the resulting package would be "near the top of the 
> mempool". This would theoretically imply such attacks are not possible 
> to pull off consistently, as any "transaction-delaying" channel 
> participant will have to place the package containing A at an effective 
> feerate which makes confirmation to occur soon with some likelihood. It 
> is, however, possible to pull off this attack with low probability in 
> case of feerate spikes right after broadcast.

I like this idea.

Firstly, it's incentive-compatible[1]: assuming blocks are full, miners
should always take a higher feerate tx if that tx would be in the
current block and the replaced txs would not.[2]

Secondly, it reduces the problem that the current lightning proposal
adds to the UTXO set with two anyone-can-spend txs for 1000 satoshis,
which might be too small to cleanup later.  This rule would allow a
simple single P2WSH(OP_TRUE) output, or, with IsStandard changed,
a literal OP_TRUE.

> Note that this clearly relies on some form of package relay, which comes 
> with its own challenges, but I'll start a separate thread on that.

Could be done client-side, right?  Do a quick check if this is above 250
satoshi per kweight but below minrelayfee, put it in a side-cache with a
60 second timeout sweep.  If something comes in which depends on it
which is above minrelayfee, then process them as a pair[3].

Cheers,
Rusty.
[1] Miners have generally been happy with Defaults Which Are Good For The
    Network, but I feel a long term development aim should to be reduce
    such cases to smaller and smaller corners.
[2] The actual condition is subtler, but this is a clear subset AFAICT.
[3] For Lightning, we don't care about child-pays-for-grandparent etc.

From macwhyte at gmail.com  Tue Dec  4 12:16:12 2018
From: macwhyte at gmail.com (James MacWhyte)
Date: Tue, 4 Dec 2018 04:16:12 -0800
Subject: [bitcoin-dev] Proposal for Palindromic (Reversible) Mnemonics
In-Reply-To: <CA+ASnrGEbksc-YeKR7bKpAv5=rcWcg8BeR6XDVUzvJ9C76bGpA@mail.gmail.com>
References: <CABsxsG234DhY8Lxn0UMgXG0YnPdyJ5__U9P-aweV9L=xw7hxyw@mail.gmail.com>
	<CA+ASnrGEbksc-YeKR7bKpAv5=rcWcg8BeR6XDVUzvJ9C76bGpA@mail.gmail.com>
Message-ID: <CAH+Axy4=8SyRL5W9Av_6dDOp43Qd+Cdkf2XZnpf1i6zCT4Pemg@mail.gmail.com>

I agree with Joseph. If you want plausible deniability, it would be better
to simply hide the funds somewhere in the HD chain. Same if you want a
second vault tied to the same phrase.

You are reducing security by eliminating all entropy that doesn't fit the
reversible criteria, although in practice it doesn't make a difference
because the numbers are so big. However, it doesn't seem like a very useful
feature to have.

Thanks for doing all that work though, it was fun to read about your idea
and what you found out through experimenting!

James


On Mon, Dec 3, 2018 at 1:00 PM Joseph Gleason ? via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I have a suggestion.  If you are concerned about plausible deniability,
> then it might make sense to just have the single mnemonic seed lead to a
> single xprv key (as usual) and then do a private key derivation from that
> based on a password string.  The password can be simple, as it is based on
> the security of the seed, just as long as the user feels they need for
> deniability.
>
> A simple reverse scheme like you describe would just be another thing a
> person would know to check if given some seed so I don't see it as
> providing much value, but I could be missing something.
>
> On Mon, Dec 3, 2018 at 10:45 AM Steven Hatzakis via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Hi All,
>>
>> I've developed a method to check if a mnemonic is also valid when the
>> words are put into reverse order (not the entropy), where a given 12 or
>> 24-word mnemonic could be valid both in little endian and big endian
>> format. I've coined these "Palindromic Mnemonics", but perhaps more
>> user-friendly is "reversible mnemonics."
>>
>> Purpose:
>> A checksum-valid reversible mnemonic allows two separate vaults to be
>> connected to the same mnemonic string of words, where all a users must do
>> is enter the words in reverse order (the last word becomes first, second to
>> last becomes second, and so on) to access the secondary (reversed words)
>> vault. This utility could provide multiple use-cases, including related to
>> combinations with passphrases and plausible deniability, as well as
>> conveniences for those wishing to use a separate vault tied to the same
>> string of words.
>>
>> Security:
>> For any randomly generated 12-word mnemonic (128-bits of security) the
>> chances of it also being reversible are 1/16 (I believe), as a total of 4
>> bit positions must be identical (4 bits from the normal mnemonic and
>> another 4 bits from the reversed string must match). For a 24-word
>> mnemonic, those values increase to 8 bits which need to match 8 bits from
>> the reversed string, leading to about 1 in every 256 mnemonics also being
>> reversible. While the message space of valid reversible mnemonics should be
>> 2^124 for 12 words, that search must still be conducted over a field of 2
>> ^128, as the hash-derived checksum values otherwise prevent a way to
>> deterministically find valid reversible mnemonics without first going
>> through invalid reversible ones to check. I think others should chime in on
>> whether they believe there is any security loss, in terms of entropy bits
>> (assuming the initial 128 bits were generated securely). I estimate at most
>> it would be 4-bits of loss for a 12-word mnemonic, but only if an attacker
>> had a way to search only the space of valid reversible mnemonics (2**124)
>> which I don't think is feasible (could be wrong?). There could also be
>> errors in my above assumptions, this is a work in progress and sharing it
>> here to solicit initial feedback/interest.
>>
>> I've already written the code that can be used for testing (on GitHub
>> user @hatgit), and when run from terminal/command prompt it is pretty fast
>> to find a valid reversible mnemonics, whereas on IDLE in Python on a 32-bit
>> and 64-bit machine it could take a few seconds for 12 words and sometimes
>> 10 minutes to find a valid 24-word reversible mnemonic.
>> Example 12 words reversible (with valid checksum each way):
>>
>> limit exact seven clarify utility road image fresh leg cabbage hint canoe
>>
>> And Reversed:
>>
>> canoe hint cabbage leg fresh image road utility clarify seven exact limit
>>
>>
>> Example 24 reversible:
>>
>> favorite uncover sugar wealth army shift goose fury market toe message
>> remain direct arrow duck afraid enroll salt knife school duck sunny grunt
>> argue
>>
>> And reversed:
>>
>> argue grunt sunny duck school knife salt enroll afraid duck arrow direct
>> remain message toe market fury goose shift army wealth sugar uncover
>> favorite
>>
>>
>> My two questions 1) are how useful could this be for
>> you/users/devs/service providers etc.. and 2) is any security loss
>> occurring and whether it is negligible or not?
>>
>> Best regards,
>>
>> Steven Hatzakis
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181204/fbd20ae0/attachment.html>

From shatzakis at gmail.com  Tue Dec  4 12:42:42 2018
From: shatzakis at gmail.com (Steven Hatzakis)
Date: Tue, 4 Dec 2018 14:42:42 +0200
Subject: [bitcoin-dev] Proposal for Palindromic (Reversible) Mnemonics
In-Reply-To: <CAH+Axy4=8SyRL5W9Av_6dDOp43Qd+Cdkf2XZnpf1i6zCT4Pemg@mail.gmail.com>
References: <CABsxsG234DhY8Lxn0UMgXG0YnPdyJ5__U9P-aweV9L=xw7hxyw@mail.gmail.com>
	<CA+ASnrGEbksc-YeKR7bKpAv5=rcWcg8BeR6XDVUzvJ9C76bGpA@mail.gmail.com>
	<CAH+Axy4=8SyRL5W9Av_6dDOp43Qd+Cdkf2XZnpf1i6zCT4Pemg@mail.gmail.com>
Message-ID: <CABsxsG2qBVA-imReWJci4JA=S0MhVMq9+ezyMF7SEw7Hqqa-gQ@mail.gmail.com>

Thanks, James and Joseph, for the feedback,
It has been a fun experiment!

I just want to note that the plausible deniability was not the motive but
just an example use-case, there are perhaps other use-cases that would be
on the user to decide. I think having a mnemonic that is also reversible
could be useful for other reasons - convenience related perhaps.
*Re security:* I am still not convinced entirely that security is reduced
at all because one still has to search through all entropy in the range
of 2^128 to see whether any of those are reversible (unless there is a way
to only search the field of 2^124 that are reversible, which I don't think
is possible because the hash-derived checksum cannot be determined before
hashing, only afterward). Therefore, security should still be 2^128 for a
12-word mnemonic whether it is reversible or not (as one in every 16 people
that already have one (12-word) is reversible, they just might not realize
it, so we can't say those are less secure).

Best regards,

On Tue, Dec 4, 2018 at 2:16 PM James MacWhyte <macwhyte at gmail.com> wrote:

> I agree with Joseph. If you want plausible deniability, it would be better
> to simply hide the funds somewhere in the HD chain. Same if you want a
> second vault tied to the same phrase.
>
> You are reducing security by eliminating all entropy that doesn't fit the
> reversible criteria, although in practice it doesn't make a difference
> because the numbers are so big. However, it doesn't seem like a very useful
> feature to have.
>
> Thanks for doing all that work though, it was fun to read about your idea
> and what you found out through experimenting!
>
> James
>
>
> On Mon, Dec 3, 2018 at 1:00 PM Joseph Gleason ? via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> I have a suggestion.  If you are concerned about plausible deniability,
>> then it might make sense to just have the single mnemonic seed lead to a
>> single xprv key (as usual) and then do a private key derivation from that
>> based on a password string.  The password can be simple, as it is based on
>> the security of the seed, just as long as the user feels they need for
>> deniability.
>>
>> A simple reverse scheme like you describe would just be another thing a
>> person would know to check if given some seed so I don't see it as
>> providing much value, but I could be missing something.
>>
>> On Mon, Dec 3, 2018 at 10:45 AM Steven Hatzakis via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> Hi All,
>>>
>>> I've developed a method to check if a mnemonic is also valid when the
>>> words are put into reverse order (not the entropy), where a given 12 or
>>> 24-word mnemonic could be valid both in little endian and big endian
>>> format. I've coined these "Palindromic Mnemonics", but perhaps more
>>> user-friendly is "reversible mnemonics."
>>>
>>> Purpose:
>>> A checksum-valid reversible mnemonic allows two separate vaults to be
>>> connected to the same mnemonic string of words, where all a users must do
>>> is enter the words in reverse order (the last word becomes first, second to
>>> last becomes second, and so on) to access the secondary (reversed words)
>>> vault. This utility could provide multiple use-cases, including related to
>>> combinations with passphrases and plausible deniability, as well as
>>> conveniences for those wishing to use a separate vault tied to the same
>>> string of words.
>>>
>>> Security:
>>> For any randomly generated 12-word mnemonic (128-bits of security) the
>>> chances of it also being reversible are 1/16 (I believe), as a total of 4
>>> bit positions must be identical (4 bits from the normal mnemonic and
>>> another 4 bits from the reversed string must match). For a 24-word
>>> mnemonic, those values increase to 8 bits which need to match 8 bits from
>>> the reversed string, leading to about 1 in every 256 mnemonics also being
>>> reversible. While the message space of valid reversible mnemonics should be
>>> 2^124 for 12 words, that search must still be conducted over a field of
>>> 2^128, as the hash-derived checksum values otherwise prevent a way to
>>> deterministically find valid reversible mnemonics without first going
>>> through invalid reversible ones to check. I think others should chime in on
>>> whether they believe there is any security loss, in terms of entropy bits
>>> (assuming the initial 128 bits were generated securely). I estimate at most
>>> it would be 4-bits of loss for a 12-word mnemonic, but only if an attacker
>>> had a way to search only the space of valid reversible mnemonics (2**124)
>>> which I don't think is feasible (could be wrong?). There could also be
>>> errors in my above assumptions, this is a work in progress and sharing it
>>> here to solicit initial feedback/interest.
>>>
>>> I've already written the code that can be used for testing (on GitHub
>>> user @hatgit), and when run from terminal/command prompt it is pretty fast
>>> to find a valid reversible mnemonics, whereas on IDLE in Python on a 32-bit
>>> and 64-bit machine it could take a few seconds for 12 words and sometimes
>>> 10 minutes to find a valid 24-word reversible mnemonic.
>>> Example 12 words reversible (with valid checksum each way):
>>>
>>> limit exact seven clarify utility road image fresh leg cabbage hint canoe
>>>
>>> And Reversed:
>>>
>>> canoe hint cabbage leg fresh image road utility clarify seven exact limit
>>>
>>>
>>> Example 24 reversible:
>>>
>>> favorite uncover sugar wealth army shift goose fury market toe message
>>> remain direct arrow duck afraid enroll salt knife school duck sunny grunt
>>> argue
>>>
>>> And reversed:
>>>
>>> argue grunt sunny duck school knife salt enroll afraid duck arrow direct
>>> remain message toe market fury goose shift army wealth sugar uncover
>>> favorite
>>>
>>>
>>> My two questions 1) are how useful could this be for
>>> you/users/devs/service providers etc.. and 2) is any security loss
>>> occurring and whether it is negligible or not?
>>>
>>> Best regards,
>>>
>>> Steven Hatzakis
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181204/6b7a7b5b/attachment-0001.html>

From shatzakis at gmail.com  Tue Dec  4 21:39:17 2018
From: shatzakis at gmail.com (Steven Hatzakis)
Date: Tue, 4 Dec 2018 23:39:17 +0200
Subject: [bitcoin-dev] Proposal for Palindromic (Reversible) Mnemonics
In-Reply-To: <CALYX514jH_wYrONu=hpj924p98cEcHnyZLdu2jDt5tkhoKL9kw@mail.gmail.com>
References: <CABsxsG234DhY8Lxn0UMgXG0YnPdyJ5__U9P-aweV9L=xw7hxyw@mail.gmail.com>
	<CA+ASnrGEbksc-YeKR7bKpAv5=rcWcg8BeR6XDVUzvJ9C76bGpA@mail.gmail.com>
	<CAH+Axy4=8SyRL5W9Av_6dDOp43Qd+Cdkf2XZnpf1i6zCT4Pemg@mail.gmail.com>
	<CABsxsG2qBVA-imReWJci4JA=S0MhVMq9+ezyMF7SEw7Hqqa-gQ@mail.gmail.com>
	<CALYX514jH_wYrONu=hpj924p98cEcHnyZLdu2jDt5tkhoKL9kw@mail.gmail.com>
Message-ID: <CABsxsG3HF1r0fTpnAY5Efw8AF6wxGtNfK0H3eAGhN-Wu2qhzpw@mail.gmail.com>

Hi Michael, thanks for the feedback.
To answer your question, the motivation was partly that some applications
do not accept passphrases, making mnemonics less versatile in those cases
in terms of vault separation when logging in to those services, although I
agree in that specific context reversible mnemonics don't add further
security (like a passphrase can) but it shouldn't lessen security either
(in terms of entropy and bit-security).

Of course, If someone finds a plaintexts recovery phrase (i.e. hacker) then
there is no security to prevent the funds being moved out whether it is
reversible or not (unless again a passphrase was present, and even that can
be brute forced so protecting the words are key) unless it represented some
multi-sig key or was a Shamir secret share (such as is being proposed under
SLIP0039 by Satoshi Labs, and Ian Coleman hosts a prototype).

I think comparable to vanity addresses, reversible mnemonics could be part
novelty, but I do think there is also an actual utility. I am not
suggesting they are used 100% of the time, rather a user could choose to
generate one manually or check if their existing one is already reversible.
Those options could be provided at the software level and then it would be
up to the user to chose. Bottom line, I think that users who have smaller
amounts in hot wallets could find it useful to have reversible mnemonics
for switching from one service to another without having to access yet
another mnemonic. Whereas, for those creating them offline (cold storage)
it could provide an additional vault and additional passphrase options.
Here's an example:

Vault #1 normal mnemonic
Vault #2 normal mnemonic w/passphrase
Vault #3 reversed mnemonic
Vault #4 reversed mnemonic w/passphrase


Best regards,

Steven Hatzakis


On Tue, Dec 4, 2018 at 4:16 PM Michael Dunworth <mike at sendwyre.com> wrote:

> Cool idea, and appreciate the explainer surrounding it!
>
> What are the motivators to have it? Simplifying the recovery process
> (easier to remember?) - Would love to know more from that if you're happy
> to share! That'd help gauge the security considerations.
>
> Security thoughts:
> - Probability of guessing is one thing, probability of getting access to a
> keyword/phrase is another thing. So if the recovery/accessibility becomes a
> motivator, that then can broaden the attack vectors pretty significantly.
> Which would result in a significant decrease in the security (IMO?).
> - Broadcasting the use of reversable mnemonics would become an attack
> vector potentially. Now any members of the security team or members within
> close proximity could learn that reversible phrases are used, and
> insulating this information from becoming public knowledge would become
> it's own security consideration. If it's already a 6.25% (1/16) chance
> they're reversible, I wouldn't want it publicly known that it's a 100%
> chance.
> - Feels like it could be useful in terms of a "duress password" although
> that might be implemented similarly to what Joseph mentioned where you
> would route the reverse phrase to somewhere other than the core assets.
>
> May be misunderstanding or have bad maths this early in the morning, but I
> think I'd be nervous to implement something like this without a pretty
> clear upside. Seems like it only adds additional risk?
>
> Thank you.
>
> Kind regards,
>
> Michael.
> ?
>
> On Tue, Dec 4, 2018 at 5:11 AM Steven Hatzakis via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Thanks, James and Joseph, for the feedback,
>> It has been a fun experiment!
>>
>> I just want to note that the plausible deniability was not the motive but
>> just an example use-case, there are perhaps other use-cases that would be
>> on the user to decide. I think having a mnemonic that is also reversible
>> could be useful for other reasons - convenience related perhaps.
>> *Re security:* I am still not convinced entirely that security is
>> reduced at all because one still has to search through all entropy in the
>> range of 2^128 to see whether any of those are reversible (unless there is
>> a way to only search the field of 2^124 that are reversible, which I don't
>> think is possible because the hash-derived checksum cannot be determined
>> before hashing, only afterward). Therefore, security should still be 2^128
>> for a 12-word mnemonic whether it is reversible or not (as one in every 16
>> people that already have one (12-word) is reversible, they just might not
>> realize it, so we can't say those are less secure).
>>
>> Best regards,
>>
>> On Tue, Dec 4, 2018 at 2:16 PM James MacWhyte <macwhyte at gmail.com> wrote:
>>
>>> I agree with Joseph. If you want plausible deniability, it would be
>>> better to simply hide the funds somewhere in the HD chain. Same if you want
>>> a second vault tied to the same phrase.
>>>
>>> You are reducing security by eliminating all entropy that doesn't fit
>>> the reversible criteria, although in practice it doesn't make a difference
>>> because the numbers are so big. However, it doesn't seem like a very useful
>>> feature to have.
>>>
>>> Thanks for doing all that work though, it was fun to read about your
>>> idea and what you found out through experimenting!
>>>
>>> James
>>>
>>>
>>> On Mon, Dec 3, 2018 at 1:00 PM Joseph Gleason ? via bitcoin-dev <
>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>>> I have a suggestion.  If you are concerned about plausible deniability,
>>>> then it might make sense to just have the single mnemonic seed lead to a
>>>> single xprv key (as usual) and then do a private key derivation from that
>>>> based on a password string.  The password can be simple, as it is based on
>>>> the security of the seed, just as long as the user feels they need for
>>>> deniability.
>>>>
>>>> A simple reverse scheme like you describe would just be another thing a
>>>> person would know to check if given some seed so I don't see it as
>>>> providing much value, but I could be missing something.
>>>>
>>>> On Mon, Dec 3, 2018 at 10:45 AM Steven Hatzakis via bitcoin-dev <
>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>
>>>>> Hi All,
>>>>>
>>>>> I've developed a method to check if a mnemonic is also valid when the
>>>>> words are put into reverse order (not the entropy), where a given 12 or
>>>>> 24-word mnemonic could be valid both in little endian and big endian
>>>>> format. I've coined these "Palindromic Mnemonics", but perhaps more
>>>>> user-friendly is "reversible mnemonics."
>>>>>
>>>>> Purpose:
>>>>> A checksum-valid reversible mnemonic allows two separate vaults to be
>>>>> connected to the same mnemonic string of words, where all a users must do
>>>>> is enter the words in reverse order (the last word becomes first, second to
>>>>> last becomes second, and so on) to access the secondary (reversed words)
>>>>> vault. This utility could provide multiple use-cases, including related to
>>>>> combinations with passphrases and plausible deniability, as well as
>>>>> conveniences for those wishing to use a separate vault tied to the same
>>>>> string of words.
>>>>>
>>>>> Security:
>>>>> For any randomly generated 12-word mnemonic (128-bits of security) the
>>>>> chances of it also being reversible are 1/16 (I believe), as a total of 4
>>>>> bit positions must be identical (4 bits from the normal mnemonic and
>>>>> another 4 bits from the reversed string must match). For a 24-word
>>>>> mnemonic, those values increase to 8 bits which need to match 8 bits from
>>>>> the reversed string, leading to about 1 in every 256 mnemonics also being
>>>>> reversible. While the message space of valid reversible mnemonics should be
>>>>> 2^124 for 12 words, that search must still be conducted over a field
>>>>> of 2^128, as the hash-derived checksum values otherwise prevent a way
>>>>> to deterministically find valid reversible mnemonics without first going
>>>>> through invalid reversible ones to check. I think others should chime in on
>>>>> whether they believe there is any security loss, in terms of entropy bits
>>>>> (assuming the initial 128 bits were generated securely). I estimate at most
>>>>> it would be 4-bits of loss for a 12-word mnemonic, but only if an attacker
>>>>> had a way to search only the space of valid reversible mnemonics (2**124)
>>>>> which I don't think is feasible (could be wrong?). There could also be
>>>>> errors in my above assumptions, this is a work in progress and sharing it
>>>>> here to solicit initial feedback/interest.
>>>>>
>>>>> I've already written the code that can be used for testing (on GitHub
>>>>> user @hatgit), and when run from terminal/command prompt it is pretty fast
>>>>> to find a valid reversible mnemonics, whereas on IDLE in Python on a 32-bit
>>>>> and 64-bit machine it could take a few seconds for 12 words and sometimes
>>>>> 10 minutes to find a valid 24-word reversible mnemonic.
>>>>> Example 12 words reversible (with valid checksum each way):
>>>>>
>>>>> limit exact seven clarify utility road image fresh leg cabbage hint
>>>>> canoe
>>>>>
>>>>> And Reversed:
>>>>>
>>>>> canoe hint cabbage leg fresh image road utility clarify seven exact
>>>>> limit
>>>>>
>>>>>
>>>>> Example 24 reversible:
>>>>>
>>>>> favorite uncover sugar wealth army shift goose fury market toe message
>>>>> remain direct arrow duck afraid enroll salt knife school duck sunny grunt
>>>>> argue
>>>>>
>>>>> And reversed:
>>>>>
>>>>> argue grunt sunny duck school knife salt enroll afraid duck arrow
>>>>> direct remain message toe market fury goose shift army wealth sugar uncover
>>>>> favorite
>>>>>
>>>>>
>>>>> My two questions 1) are how useful could this be for
>>>>> you/users/devs/service providers etc.. and 2) is any security loss
>>>>> occurring and whether it is negligible or not?
>>>>>
>>>>> Best regards,
>>>>>
>>>>> Steven Hatzakis
>>>>> _______________________________________________
>>>>> bitcoin-dev mailing list
>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>>
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>
>>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
>
> --
> Michael Dunworth
> Co-Founder, CEO
>
>
>
> We're now Wyre, Inc! Read about the rebrand here
> <https://medium.com/@wyre/wyre-raises-5-8m-series-a-10e90718009b>.
>
> Wyre uses blockchain technology to help make your bank transfers faster
> than email.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181204/6a7a371a/attachment-0001.html>

From roconnor at blockstream.io  Thu Dec  6 16:57:09 2018
From: roconnor at blockstream.io (Russell O'Connor)
Date: Thu, 6 Dec 2018 11:57:09 -0500
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <CAPg+sBiu0BjZEtz-t7m3M+TnAEDG_k1GKtxwkOKh6qrSezUO7g@mail.gmail.com>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<CAPg+sBiu0BjZEtz-t7m3M+TnAEDG_k1GKtxwkOKh6qrSezUO7g@mail.gmail.com>
Message-ID: <CAMZUoKkJdU0P_dVRvHn5zY6xUHYUptdK221ioQMp3FXZAerp3Q@mail.gmail.com>

One more item to consider is "signature covers witness weight".

While signing the witness weight doesn't completely eliminate witness
malleability (of the kind that can cause grief for compact blocks), it does
eliminate the worst kind of witness malleability from the user's
perspective, the kind where malicious relay nodes increase the amount of
witness data and therefore reduce the overall fee-rate of the transaction.
Generally users should strive to construct their Bitcoin Scripts in such a
way that witness malleability isn't possible, but as you are probably
aware, this can be quite difficult to achieve as Scripts become more
complex and maybe isn't even possible for some complex Scripts.

Given the new fixed-sized signature of the Schnorr BIP, it becomes much
easier to compute the final witness weight prior to signing.  In complex
multi-party signing protocol, the final witness weight might not be known
at signing time for everyone involved, so the "signature covers witness
weight" ought to be optional.


On Tue, Nov 27, 2018 at 11:59 PM Pieter Wuille via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Mon, 19 Nov 2018 at 14:37, Pieter Wuille <pieter.wuille at gmail.com>
> wrote:
> > Here is a combined proposal:
> > * Three new sighash flags are added: SIGHASH_NOINPUT, SIGHASH_NOFEE, and
> SIGHASH_SCRIPTMASK.
> > * A new opcode OP_MASK is added, which acts as a NOP during execution.
> > * The sighash is computed like in BIP143, but:
> >   * If SIGHASH_SCRIPTMASK is present, for every OP_MASK in scriptCode
> the subsequent opcode/push is removed.
> >   * The scriptPubKey being spent is added to the sighash, unless
> SIGHASH_SCRIPTMASK is set.
> >   * The transaction fee is added to the sighash, unless SIGHASH_NOFEE is
> set.
> >   * hashPrevouts, hashSequence, and outpoint are set to null when
> SIGHASH_NOINPUT is set (like BIP118, but not for scriptCode).
>
> Thanks for all the input so far. Going over the suggestions and other
> ideas:
>
> * OP_MASK should be required to be followed by a push, as suggested by
> Anthony Towns. The alternative would permit substituting arbitrary
> opcodes for masked pushes, which is at least very hard to reason
> about. This would effectively turn it into a multi-byte OP_MASKEDPUSH
> opcode.
>
> * It's probably better to sign the amounts of all inputs, as suggested
> by Johnson Lau. As that would cause default sighashes to sign all
> input and output amounts, is there still a need to sign the tx fee
> explicitly? Or in other words, are there situations where changing the
> set of inputs or outputs after signing is desired, but the net
> difference between them cannot change? If not, that would remove the
> need for NOFEE.
>
> * Do we need to keep the rule that sequence values of other inputs are
> only signed with default sighash? It feels cleaner to always sign the
> sequence values of all inputs that are included in the sighash anyway
> (so all of them, unless ANYONECANPAY or NOINPUT, which would make it
> sign only the current input's sequence value). If NOINPUT also blanks
> the sequence values (as currently specified by BIP118), and all input
> amounts are signed, that would make amounts/sequence values always be
> treated identically.
>
> * If MASK implies NOINPUT, and NOINPUT implies ANYONECANPAY, the 3 of
> them can be encoded in just 2 bits using the
> PARTIALSCRIPT/KNOWNSCRIPT/KNOWNTX/ALL_INPUTS encoding Anthony Towns
> suggested.
>
> * Regarding the discussion about preventing signatures from being
> rebound to a different script(path)/checksig:
>   * With MAST there is indeed less need for this, but at least
> single-tree MAST constructions cannot replace all script branches (a
> script with 40 IF/THEN/ELSE constructions may have 2^40 different
> execution paths, for which computing a Merkle tree is intractable).
>   * Just signing the opcode position of the CHECKSIG operator isn't
> enough for all cases either. For example, you could have a complex
> nested set of branches that puts a number of pubkeys on the stack, and
> then a CHECKMULTISIG after the last ENDIF to verify all of them. In
> such a situation, if the same key can occur in multiple combinations,
> you still may want to prevent a signature generated for one
> combination from being rebindable to the same key in another
> combination. I believe that signing the opcode position plus the
> true/false condition of all previous(?) IF statements is probably
> sufficient to achieve that, but it would also introduce unnecessary
> complexity for signers in most cases (see next point).
>   * Thinking about signing code, adding these sort of execution trace
> commitments to the sighash means they need to know which checksig
> operator etc. they are signing for. I believe that in practice for
> example HW devices will just whatever position the wallet indicated,
> rather than verifying it corresponds with a particular intended code
> path. Preventing rebinding isn't very useful if an attacker can make
> you bind to the wrong thing regardless, so I'm not convinced this is
> even worth having by default.
>   * An alternative (not sure who suggested it) is to simply make every
> CHECKSIG sign the opcode position of the last executed CODESEPARATOR
> (and remove the earlier cut-of-scriptCode effect of CODESEPARATOR).
> This gives a simple (but somewhat limited) way for scripts that need
> to prevent certain kinds of cross-execution-trace rebinding.
>
> A few misc ideas:
> * (Taken from
> https://github.com/jl2012/bips/blob/sighash2/bip-sighash2.mediawiki)
> For a default sign-everything sighash, the sighash byte can be
> dropped.
> * For the commitments to the scriptPubKey and scriptCode, an
> intermediary hash should be used (so the data included in the sighash
> includes a hash of those, rather than the script directly). This
> prevents a blow up in hashing time for large scripts with many
> different sighash types in its signatures.
> * When masking the scriptCode, the push opcode immediately following
> OP_MASKEDPUSH can be replaced by OP_VERIF (which will never collide
> with any real script, as OP_VERIF makes a script invalid even when
> occurring in an unexecuted branch).
> * Sighashes (and really all new hashes that are introduced) should be
> prefixed with a fixed 64-byte array as "tag", chosen to not collide
> with any existing use of SHA256 in Bitcoin, to prevent signatures from
> being re-interpretable as something else. Picking 64 bytes as tag size
> means it can be efficiently implemented as just a modified SHA256 IV.
>
> So a combined proposal:
> * All existing sighash flags, plus NOINPUT and MASK
> (ANYONECANPAY/NOINPUT/MASK are encoded in 2 bits).
> * A new opcode called OP_MASKEDPUSH, whose only runtime behaviour is
> failing if not immediately followed by a push, or when appearing as
> last opcode in the script.
> * Signatures are 64 plus an optional sighash byte. A missing sighash
> byte implies ALL, and ALL cannot be specified explicitly.
> * The sighash is computed from the following:
>   * A 64-byte constant tag
>   * Data about the spending transaction:
>     * The transaction version number
>     * The hash of txins' prevouts+amounts+sequences (or nothing if
> ANYONECANPAY)
>     * The hash of all txouts (or just the corresponding txout if
> SINGLE; nothing if NONE)
>     * The transaction locktime
>   * Data about the output being spent:
>     * The prevout (or nothing if NOINPUT)
>     * The amount
>     * The sequence number
>     * The hash of the scriptPubKey (or nothing if MASK)
>   * Data about the script being executed:
>     * The hash of the scriptCode (after masking out, if MASK is set)
>     * The opcode number of the last executed OP_CODESEPARATOR (or
> 0xFFFFFFFF if none)
>   * The sighash mode
>
> Cheers,
>
> --
> Pieter
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181206/49fae6ab/attachment.html>

From jl2012 at xbt.hk  Sun Dec  9 19:13:34 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Mon, 10 Dec 2018 03:13:34 +0800
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <CAMZUoKkJdU0P_dVRvHn5zY6xUHYUptdK221ioQMp3FXZAerp3Q@mail.gmail.com>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<CAPg+sBiu0BjZEtz-t7m3M+TnAEDG_k1GKtxwkOKh6qrSezUO7g@mail.gmail.com>
	<CAMZUoKkJdU0P_dVRvHn5zY6xUHYUptdK221ioQMp3FXZAerp3Q@mail.gmail.com>
Message-ID: <702FE74C-119C-4D14-BCD3-85C4355356A2@xbt.hk>

The current proposal is that a 64-byte signature will be used for the default ?signing all? sighash, and 65-byte for other sighash types. The space saved will allow a few more txs in a block, so I think it worths doing. However, this also makes witness weight estimation more difficult in multisig cases.

This idea of signing witness weight has been brought up before. I think the concern is the difficulty to estimate the witness weight for complex scripts, which need this feature most. So it will work when it is not needed, and will not work when it is needed.

Is there any script example that witness size malleability is unavoidable?

> On 7 Dec 2018, at 12:57 AM, Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> One more item to consider is "signature covers witness weight".
> 
> While signing the witness weight doesn't completely eliminate witness malleability (of the kind that can cause grief for compact blocks), it does eliminate the worst kind of witness malleability from the user's perspective, the kind where malicious relay nodes increase the amount of witness data and therefore reduce the overall fee-rate of the transaction.  Generally users should strive to construct their Bitcoin Scripts in such a way that witness malleability isn't possible, but as you are probably aware, this can be quite difficult to achieve as Scripts become more complex and maybe isn't even possible for some complex Scripts.
> 
> Given the new fixed-sized signature of the Schnorr BIP, it becomes much easier to compute the final witness weight prior to signing.  In complex multi-party signing protocol, the final witness weight might not be known at signing time for everyone involved, so the "signature covers witness weight" ought to be optional.
> 
> 



From dave at dtrt.org  Sun Dec  9 22:41:57 2018
From: dave at dtrt.org (David A. Harding)
Date: Sun, 9 Dec 2018 17:41:57 -0500
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <CAMZUoKkJdU0P_dVRvHn5zY6xUHYUptdK221ioQMp3FXZAerp3Q@mail.gmail.com>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<CAPg+sBiu0BjZEtz-t7m3M+TnAEDG_k1GKtxwkOKh6qrSezUO7g@mail.gmail.com>
	<CAMZUoKkJdU0P_dVRvHn5zY6xUHYUptdK221ioQMp3FXZAerp3Q@mail.gmail.com>
Message-ID: <20181209224157.mytaebwmw5o5wifa@email>

On Thu, Dec 06, 2018 at 11:57:09AM -0500, Russell O'Connor via bitcoin-dev wrote:
> One more item to consider is "signature covers witness weight".
> 
> While signing the witness weight doesn't completely eliminate witness
> malleability (of the kind that can cause grief for compact blocks), it does
> eliminate the worst kind of witness malleability from the user's
> perspective, the kind where malicious relay nodes increase the amount of
> witness data and therefore reduce the overall fee-rate of the transaction.

To what degree is this an actual problem?  If the mutated transaction
pays a feerate at least incremental-relay-fee[1] below the original
transaction, then the original transaction can be rebroadcast as an RBF
replacement of the mutated transaction (unless the mutated version has
been pinned[2]).

-Dave

[1] $ bitcoind -help-debug | grep -A2 incremental
  -incrementalrelayfee=<amt>
       Fee rate (in BTC/kB) used to define cost of relay, used for mempool
       limiting and BIP 125 replacement. (default: 0.00001)

[2] https://bitcoin.stackexchange.com/questions/80803/what-is-meant-by-transaction-pinning

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181209/7ae94da5/attachment.sig>

From soc1024 at illinois.edu  Fri Dec  7 19:25:31 2018
From: soc1024 at illinois.edu (Andrew Miller)
Date: Fri, 7 Dec 2018 13:25:31 -0600
Subject: [bitcoin-dev] call for demos: Cryptocurrency Implementers' Workshop
Message-ID: <CAF7tpEyqssS967aBs2X7uV=sAfY5hJpvSvrdhTN=q1FQBv_B_w@mail.gmail.com>

Hi all,
  I'm happy to announce the first Cryptocurrency Implementers' Workshop,
cohosted with Financial Crypto.
  http://fc19.ifca.ai/ciw/
  Now that the BITCOIN cryptocurrency research workshop has been folded
into the main FC conference, it's time to try something new. The goal of
this workshop is to focus on real world experience and engineering efforts.
As such we're soliciting submission of *running code* to give a live demo
at the workshop. Because of the tight timeline, there are only two weeks to
go before the submission deadline, Dec 21. More details below the fold, and
at the website link.

-- 
Andrew Miller
University of Illinois at Urbana-Champaign

With the inclusion of the BITCOIN: Bitcoin and Cryptocurrency Research
Workshop into the "Blockchain Track" of the Financial Cryptography
conference, we now want to try out an experimental new workshop format,
which focuses on engineering, development, and real world use of
cryptocurrencies and permissionless blockchains.

In this first iteration, the workshop will be a half day, and the program
will consist of two main components:

Invited talks on implementation post mortems:
-----
we will aim to have several talks from developers and engineers that have
led and maintained open source software projects in use by cryptocurrencies
today.

Artifact Evaluation and Demo show and tell:
----
We will have a technical program of demo presentations about open source
software artifacts. Presenters must submit their talk and demo abstract
along with the open source software itself for review. Presentation
abstracts should be no more than 6 pages in LNCS format, or the equivalent
length (no more than 2000 words) of text, Markdown, etc. The write up
should include:
motivation and application,
novelty or differences compared to alternative or related implementations,
challenges faced,
possible evaluation approaches
Submissions must include a software artifact that can be reviewed. It is
expected the review committee will at least be able to run the artifact and
observe the outputs. We recommend including a virtual machine image or
Docker-based build instructions to facilitate this.

Suggested topics
====
The following list is non-exhaustive:
Cryptography implementations, such as digital signatures, ring signatures,
zero knowledge proofs
Proof-of-work consensus protocols
Proof-of-stake consensus protocols
Mining hardware designs
Peer-to-peer networking and broadcast relay code
Full node synchronization
SPV and lightweight clients
Wallets and key management
Security vulnerabilities and defenses
Mining pools
Mining rig controllers
Staking wallets

Important Dates
====
Dec 21: Submission deadline
Jan 7: Presenter notification
Feb 22: Workshop

Submission Instructions
===
The submission website and instructions will be available mid December.
Demos accepted to this program will not be included in any proceedings.
Submission and acceptance in this workshop does not preclude publication
elsewhere.

Submissions may be anonymized at the authors' discretion, but it is not a
requirement.

Program Commitee
====
J. Ayo Akinyele (Yeletech)
Rebekah Mercer (Aarhus)
Pieter Wuille (Blockstream)
Benedikt B?nz (Stanford)
Ethan Heilman (Boston University, Commonwealth Crypto)
Patrick McCorry (Kings College London)
Justin Ehrenhofer (Monero Community WorkGroup)
Jacob Eberhardt (tu-berlin)
... (more to come)

Program Chairs
====
Andrew Miller (UIUC)
Christopher Allen

Contact email address: Andrew Miller <soc1024 at illinois.edu>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181207/e92b7511/attachment.html>

From wordsgalore at gmail.com  Wed Dec  5 14:08:56 2018
From: wordsgalore at gmail.com (Zawy)
Date: Wed, 5 Dec 2018 09:08:56 -0500
Subject: [bitcoin-dev] How much is too much time between difficulty
	changes?
In-Reply-To: <CAGLBAhdtXEjhZWavgytQAOuXUaJZc=ZQyvjB2KV-YczAh-H4WQ@mail.gmail.com>
References: <CAGLBAhdtXEjhZWavgytQAOuXUaJZc=ZQyvjB2KV-YczAh-H4WQ@mail.gmail.com>
Message-ID: <CADtTMv=y66ERvmJzcgu0P1xt_dBkwd_qqEc=g=GfJgwhsdEPZw@mail.gmail.com>

It's possible to let the difficulty linearly drop as the solvetime
goes beyond some limit (credit AS). If the limit is greater than any
delay in the past it could be backwards-compatible.

A simple daily-rolling average DA like BCH is probably the best option
if a faster DA is ever needed.

As a point of research interest (not likely to be needed by BTC), I've
taken the first above idea of "intra-block" timestamp-based difficulty
adjustment to the limit and made it symmetrical (higher D for fast
solves) and continuous. The result is a "tightening of the Poisson"
that increases "availability" (predictable solution times) at an
expense in "consistency" (orphans). It requires a very tight future
time limit to reduce timestamp manipulation. My objective was to help
small coins deal with persistent 20x hash rate changes that result in
long delays. About 3 coins have it on testnet.
https://github.com/zawy12/difficulty-algorithms/issues/36

From roconnor at blockstream.io  Tue Dec 11 15:36:59 2018
From: roconnor at blockstream.io (Russell O'Connor)
Date: Tue, 11 Dec 2018 10:36:59 -0500
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <20181209224157.mytaebwmw5o5wifa@email>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<CAPg+sBiu0BjZEtz-t7m3M+TnAEDG_k1GKtxwkOKh6qrSezUO7g@mail.gmail.com>
	<CAMZUoKkJdU0P_dVRvHn5zY6xUHYUptdK221ioQMp3FXZAerp3Q@mail.gmail.com>
	<20181209224157.mytaebwmw5o5wifa@email>
Message-ID: <CAMZUoKnnEJ9=w3Q2a__WEd2gMWDxT55G7omRM5DTuaoEdm1H7Q@mail.gmail.com>

I don't believe that the default RBF policy works that way.  My
understanding is that current policy requires an absolute fee increase (by
an amount related to incrementalrelayfee).  There have been proposals to
change default RBF policy, however even my proposal <
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015717.html>
still requires a minimal amount of absolute fee increase as a DoS defense.

(I'm reading your comment as attempting to rebroadcast the original
transaction with the same fee amount, with its relatively higher fee-rate).

On Mon, Dec 10, 2018 at 10:00 AM David A. Harding <dave at dtrt.org> wrote:

> On Thu, Dec 06, 2018 at 11:57:09AM -0500, Russell O'Connor via bitcoin-dev
> wrote:
> > One more item to consider is "signature covers witness weight".
> >
> > While signing the witness weight doesn't completely eliminate witness
> > malleability (of the kind that can cause grief for compact blocks), it
> does
> > eliminate the worst kind of witness malleability from the user's
> > perspective, the kind where malicious relay nodes increase the amount of
> > witness data and therefore reduce the overall fee-rate of the
> transaction.
>
> To what degree is this an actual problem?  If the mutated transaction
> pays a feerate at least incremental-relay-fee[1] below the original
> transaction, then the original transaction can be rebroadcast as an RBF
> replacement of the mutated transaction (unless the mutated version has
> been pinned[2]).
>
> -Dave
>
> [1] $ bitcoind -help-debug | grep -A2 incremental
>   -incrementalrelayfee=<amt>
>        Fee rate (in BTC/kB) used to define cost of relay, used for mempool
>        limiting and BIP 125 replacement. (default: 0.00001)
>
> [2]
> https://bitcoin.stackexchange.com/questions/80803/what-is-meant-by-transaction-pinning
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181211/ba277d2d/attachment.html>

From dave at dtrt.org  Tue Dec 11 17:47:24 2018
From: dave at dtrt.org (David A. Harding)
Date: Tue, 11 Dec 2018 12:47:24 -0500
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <CAMZUoKnnEJ9=w3Q2a__WEd2gMWDxT55G7omRM5DTuaoEdm1H7Q@mail.gmail.com>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<CAPg+sBiu0BjZEtz-t7m3M+TnAEDG_k1GKtxwkOKh6qrSezUO7g@mail.gmail.com>
	<CAMZUoKkJdU0P_dVRvHn5zY6xUHYUptdK221ioQMp3FXZAerp3Q@mail.gmail.com>
	<20181209224157.mytaebwmw5o5wifa@email>
	<CAMZUoKnnEJ9=w3Q2a__WEd2gMWDxT55G7omRM5DTuaoEdm1H7Q@mail.gmail.com>
Message-ID: <20181211174724.k7kxcwcnrtfm46og@email>

On Tue, Dec 11, 2018 at 10:36:59AM -0500, Russell O'Connor wrote:
> I don't believe that the default RBF policy works that way.  My
> understanding is that current policy requires an absolute fee increase (by
> an amount related to incrementalrelayfee).  

Indeed, you are correct (BIP125 rule 4[1]).

Thanks for the correction,

-Dave

[1] For the curious, the relevant code from master's validation.cpp:

    // Finally in addition to paying more fees than the conflicts the
    // new transaction must pay for its own bandwidth.
    CAmount nDeltaFees = nModifiedFees - nConflictingFees;
    if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))
    {
        return state.DoS(0, false,
                REJECT_INSUFFICIENTFEE, "insufficient fee", false,
                strprintf("rejecting replacement %s, not enough additional fees to relay; %s < %s",
                      hash.ToString(),
                      FormatMoney(nDeltaFees),
                      FormatMoney(::incrementalRelayFee.GetFee(nSize))));
    }
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181211/20ba89d0/attachment.sig>

From roconnor at blockstream.io  Tue Dec 11 22:50:24 2018
From: roconnor at blockstream.io (Russell O'Connor)
Date: Tue, 11 Dec 2018 17:50:24 -0500
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <702FE74C-119C-4D14-BCD3-85C4355356A2@xbt.hk>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<CAPg+sBiu0BjZEtz-t7m3M+TnAEDG_k1GKtxwkOKh6qrSezUO7g@mail.gmail.com>
	<CAMZUoKkJdU0P_dVRvHn5zY6xUHYUptdK221ioQMp3FXZAerp3Q@mail.gmail.com>
	<702FE74C-119C-4D14-BCD3-85C4355356A2@xbt.hk>
Message-ID: <CAMZUoKkYcXt7O39zdpz494f9Jm195mBtWyrH3siX4PBEAf8OKQ@mail.gmail.com>

On Sun, Dec 9, 2018 at 2:13 PM Johnson Lau <jl2012 at xbt.hk> wrote:

> The current proposal is that a 64-byte signature will be used for the
> default ?signing all? sighash, and 65-byte for other sighash types. The
> space saved will allow a few more txs in a block, so I think it worths
> doing. However, this also makes witness weight estimation more difficult in
> multisig cases.
>
> This idea of signing witness weight has been brought up before. I think
> the concern is the difficulty to estimate the witness weight for complex
> scripts, which need this feature most. So it will work when it is not
> needed, and will not work when it is needed.
>
> Is there any script example that witness size malleability is unavoidable?
>

I tend to think in opposite terms. Is there a proof that any script can be
transformed into an equivalent one that avoids witness weight
malleability?   But I admit there is a trade off:  If we don't allow for
signature covers weight, and we do need it, it will be too late to add.  On
the other hand if we add signature covers weight, but it turns out that no
Script ever needs to use it, then we've added that software complexity for
no gain.  However, I think the software complexity is relatively low,
making it worthwhile.

Moreover, even if witness weight malleability is entirely avoidable, it
always seems to come at a cost.  Taking as an example libwally's proposed "
<https://github.com/ElementsProject/libwally-core/blob/c6db6ccdfa54571afeeb582919240263424736a2/src/script.c#L718-L735>csv_2of3_then_2"
Script
<https://github.com/ElementsProject/libwally-core/blob/c6db6ccdfa54571afeeb582919240263424736a2/src/script.c#L718-L735>,
it begins with "OP_DEPTH OP_1SUB OP_1SUB" spending 3 vbytes to avoid any
possible witness malleability versus just taking a witness stack item to
determine the branch, costing 1 or 2 (unmalleated) vbytes.  Now to be fair,
under Taproot this particular script's witness malleability problem
probably goes away.  Nonetheless, I think it is fair to say that Bitcoin
Script was designed without any regard given to scriptSig/witness
malleability concerns and the result is that one is constantly fighting
against malleability issues.  Short of a wholesale replacement of Bitcoin
Script, I do think that having an option for signature covers weight is one
of the best ways to address the whole problem.

Regarding your point about 64/65-byte signatures; I speculate that in most
protocols, all parties that are able to consider signing the weight, know
what sighash flags the other parties are expected to be using.  However,
your point is well-taken, and if we choose to adopt the option of
signatures covering weight, we ought to make sure there exists a 65-byte
signature that performs the equivalent of a sigHashAll (of course, still
covering that particular sighash flag under the signature), to ensure that
anti-weight-malleability can be use even when the sighash flags that other
parties will use are unknown.  Even with the extra vbytes in the
signatures, there may be a net weight savings by avoiding the need for
anti-malleability Script code. (It might also be reasonable to have
participants create signatures for a small range of different weight
values? (Sorry in advance to PSBT)).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181211/1f119c76/attachment.html>

From rusty at rustcorp.com.au  Wed Dec 12 09:42:10 2018
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Wed, 12 Dec 2018 20:12:10 +1030
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
Message-ID: <87ftv3xerx.fsf@rustcorp.com.au>

Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:
> Here is a combined proposal:
> * Three new sighash flags are added: SIGHASH_NOINPUT, SIGHASH_NOFEE,
> and SIGHASH_SCRIPTMASK.
> * A new opcode OP_MASK is added, which acts as a NOP during execution.
> * The sighash is computed like in BIP143, but:
>   * If SIGHASH_SCRIPTMASK is present, for every OP_MASK in scriptCode
> the subsequent opcode/push is removed.

I'm asking on-list because I'm sure I'm not the only confused one.

Having the SIGHASH_SCRIPTMASK flag is redundant AFAICT: why not always
perform mask-removal for signing?

If you're signing arbitrary scripts, you're surely in trouble already?

And I am struggling to understand the role of scriptmask in a taproot
world, where the alternate script is both hidden and general?

I look forward to learning what I missed!
Rusty.

From jl2012 at xbt.hk  Wed Dec 12 19:53:38 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Thu, 13 Dec 2018 03:53:38 +0800
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <CAMZUoKkYcXt7O39zdpz494f9Jm195mBtWyrH3siX4PBEAf8OKQ@mail.gmail.com>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<CAPg+sBiu0BjZEtz-t7m3M+TnAEDG_k1GKtxwkOKh6qrSezUO7g@mail.gmail.com>
	<CAMZUoKkJdU0P_dVRvHn5zY6xUHYUptdK221ioQMp3FXZAerp3Q@mail.gmail.com>
	<702FE74C-119C-4D14-BCD3-85C4355356A2@xbt.hk>
	<CAMZUoKkYcXt7O39zdpz494f9Jm195mBtWyrH3siX4PBEAf8OKQ@mail.gmail.com>
Message-ID: <864604F8-0BAF-403B-9A61-4788930F065F@xbt.hk>



> On 12 Dec 2018, at 6:50 AM, Russell O'Connor <roconnor at blockstream.io> wrote:
> 
> On Sun, Dec 9, 2018 at 2:13 PM Johnson Lau <jl2012 at xbt.hk <mailto:jl2012 at xbt.hk>> wrote:
> The current proposal is that a 64-byte signature will be used for the default ?signing all? sighash, and 65-byte for other sighash types. The space saved will allow a few more txs in a block, so I think it worths doing. However, this also makes witness weight estimation more difficult in multisig cases.
> 
> This idea of signing witness weight has been brought up before. I think the concern is the difficulty to estimate the witness weight for complex scripts, which need this feature most. So it will work when it is not needed, and will not work when it is needed.
> 
> Is there any script example that witness size malleability is unavoidable?
> 
> I tend to think in opposite terms. Is there a proof that any script can be transformed into an equivalent one that avoids witness weight malleability?   But I admit there is a trade off:  If we don't allow for signature covers weight, and we do need it, it will be too late to add.  On the other hand if we add signature covers weight, but it turns out that no Script ever needs to use it, then we've added that software complexity for no gain.  However, I think the software complexity is relatively low, making it worthwhile.
> 
> Moreover, even if witness weight malleability is entirely avoidable, it always seems to come at a cost.  Taking as an example libwally's proposed " <https://github.com/ElementsProject/libwally-core/blob/c6db6ccdfa54571afeeb582919240263424736a2/src/script.c#L718-L735>csv_2of3_then_2" Script <https://github.com/ElementsProject/libwally-core/blob/c6db6ccdfa54571afeeb582919240263424736a2/src/script.c#L718-L735>, it begins with "OP_DEPTH OP_1SUB OP_1SUB" spending 3 vbytes to avoid any possible witness malleability versus just taking a witness stack item to determine the branch, costing 1 or 2 (unmalleated) vbytes.  Now to be fair, under Taproot this particular script's witness malleability problem probably goes away.  Nonetheless, I think it is fair to say that Bitcoin Script was designed without any regard given to scriptSig/witness malleability concerns and the result is that one is constantly fighting against malleability issues.  Short of a wholesale replacement of Bitcoin Script, I do think that having an option for signature covers weight is one of the best ways to address the whole problem.
> 
> Regarding your point about 64/65-byte signatures; I speculate that in most protocols, all parties that are able to consider signing the weight, know what sighash flags the other parties are expected to be using.  However, your point is well-taken, and if we choose to adopt the option of signatures covering weight, we ought to make sure there exists a 65-byte signature that performs the equivalent of a sigHashAll (of course, still covering that particular sighash flag under the signature), to ensure that anti-weight-malleability can be use even when the sighash flags that other parties will use are unknown.  Even with the extra vbytes in the signatures, there may be a net weight savings by avoiding the need for anti-malleability Script code. (It might also be reasonable to have participants create signatures for a small range of different weight values? (Sorry in advance to PSBT)).

I think the root cause of witness weight malleability is some opcodes accept variable size input (without affecting the output), and that input is provided by the puzzle solver. Going through the opcode list, I think such opcodes include IF, NOTIF, VERIFY, DROP, 2DROP, NIP, DEPTH, and all arithmetic opcode that accepts CScriptNum (including CHECKMULTISIG)

VERIFY, DROP, 2DROP, NIP are not real problem, since they should not be the first opcode to interact with data directly provided by the puzzle solver.

CHECKMULTISIG is fixed by BIP147. For the key number and sig number, they should be part of the script, so not malleable.

DEPTH is a problem only if its inputs are not later examined by other opcodes. Again, this is pointless.

The liberally example should be protected by the MINIMAL_IF policy, which requires the input of OP_IF be minimal. As you note, OP_IF could be replaced by taproot in many cases

Non-minimal CScriptNum is also banned as BIP62 policy.

For the purpose of preventing malicious third party witness bloating, all we need is the miners to enforce the policy. There is no reason for miners to accept size malleated txs, as that will reduce the usable block space. If they hate a tx, they would simply drop it, instead of wasting the block space.


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181213/a18091cd/attachment-0001.html>

From jl2012 at xbt.hk  Wed Dec 12 20:00:50 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Thu, 13 Dec 2018 04:00:50 +0800
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <87ftv3xerx.fsf@rustcorp.com.au>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<87ftv3xerx.fsf@rustcorp.com.au>
Message-ID: <DAAB7568-A004-4897-B5B3-0FBBC6895246@xbt.hk>



> On 12 Dec 2018, at 5:42 PM, Rusty Russell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:
>> Here is a combined proposal:
>> * Three new sighash flags are added: SIGHASH_NOINPUT, SIGHASH_NOFEE,
>> and SIGHASH_SCRIPTMASK.
>> * A new opcode OP_MASK is added, which acts as a NOP during execution.
>> * The sighash is computed like in BIP143, but:
>>  * If SIGHASH_SCRIPTMASK is present, for every OP_MASK in scriptCode
>> the subsequent opcode/push is removed.
> 
> I'm asking on-list because I'm sure I'm not the only confused one.
> 
> Having the SIGHASH_SCRIPTMASK flag is redundant AFAICT: why not always
> perform mask-removal for signing?

Because a hardware wallet may want to know what exact script it is signing?

Masked script has reduced security, but this is a tradeoff with functionality (e.g. eltoo can?t work without masking part of the script). So when you don?t need that extra functionality, you go back to better security

However, I?m not sure if there is any useful NOINPUT case with unmasked script.

> 
> If you're signing arbitrary scripts, you're surely in trouble already?
> 
> And I am struggling to understand the role of scriptmask in a taproot
> world, where the alternate script is both hidden and general?

It makes sure that your signature is applicable to a specific script branch, not others (assuming you use the same pubkey in many branches, which is avoidable)

> 
> I look forward to learning what I missed!
> Rusty.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From rusty at rustcorp.com.au  Wed Dec 12 23:49:02 2018
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Thu, 13 Dec 2018 10:19:02 +1030
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <DAAB7568-A004-4897-B5B3-0FBBC6895246@xbt.hk>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<87ftv3xerx.fsf@rustcorp.com.au>
	<DAAB7568-A004-4897-B5B3-0FBBC6895246@xbt.hk>
Message-ID: <87pnu6s3v5.fsf@rustcorp.com.au>

Johnson Lau <jl2012 at xbt.hk> writes:
>> On 12 Dec 2018, at 5:42 PM, Rusty Russell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> 
>> Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:
>>> Here is a combined proposal:
>>> * Three new sighash flags are added: SIGHASH_NOINPUT, SIGHASH_NOFEE,
>>> and SIGHASH_SCRIPTMASK.
>>> * A new opcode OP_MASK is added, which acts as a NOP during execution.
>>> * The sighash is computed like in BIP143, but:
>>>  * If SIGHASH_SCRIPTMASK is present, for every OP_MASK in scriptCode
>>> the subsequent opcode/push is removed.
>> 
>> Having the SIGHASH_SCRIPTMASK flag is redundant AFAICT: why not always
>> perform mask-removal for signing?
>
> Because a hardware wallet may want to know what exact script it is signing?

OK, removing OP_MASKs unconditionally would introduce a hole without
some explicit flag to say they've been removed (the "real script" could
be something different with OP_MASKs).  We could have the signature
commit to the outputscript, but that's a bit meh.

> Masked script has reduced security, but this is a tradeoff with
> functionality (e.g. eltoo can?t work without masking part of the
> script). So when you don?t need that extra functionality, you go back
> to better security
>
> However, I?m not sure if there is any useful NOINPUT case with unmasked script.

This is *not* true of Eltoo; the script itself need not change for the
rebinding (Christian, did something change?).

So, can we find an example where OP_MASK is useful?

>> If you're signing arbitrary scripts, you're surely in trouble already?
>> 
>> And I am struggling to understand the role of scriptmask in a taproot
>> world, where the alternate script is both hidden and general?
>
> It makes sure that your signature is applicable to a specific script branch, not others (assuming you use the same pubkey in many branches, which is avoidable)

If I'm using SIGHASH_NOINPUT, I'm already required to take care with key
reuse.

Without a concrete taproot proposal it's hard to make assertions, but
if the signature flags that it's using the taproot script, it's
no less safe, and more general AFAICT.

Thanks!
Rusty.

From aj at erisian.com.au  Thu Dec 13 00:05:53 2018
From: aj at erisian.com.au (Anthony Towns)
Date: Thu, 13 Dec 2018 10:05:53 +1000
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <CAMZUoKkYcXt7O39zdpz494f9Jm195mBtWyrH3siX4PBEAf8OKQ@mail.gmail.com>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<CAPg+sBiu0BjZEtz-t7m3M+TnAEDG_k1GKtxwkOKh6qrSezUO7g@mail.gmail.com>
	<CAMZUoKkJdU0P_dVRvHn5zY6xUHYUptdK221ioQMp3FXZAerp3Q@mail.gmail.com>
	<702FE74C-119C-4D14-BCD3-85C4355356A2@xbt.hk>
	<CAMZUoKkYcXt7O39zdpz494f9Jm195mBtWyrH3siX4PBEAf8OKQ@mail.gmail.com>
Message-ID: <20181213000553.cikilodf65an225g@erisian.com.au>

On Tue, Dec 11, 2018 at 05:50:24PM -0500, Russell O'Connor via bitcoin-dev wrote:
> On Sun, Dec 9, 2018 at 2:13 PM Johnson Lau <jl2012 at xbt.hk> wrote:
>     The current proposal is that a 64-byte signature will be used for the
>     default ?signing all? sighash, and 65-byte for other sighash types. The
>     space saved will allow a few more txs in a block, so I think it worths
>     doing. However, this also makes witness weight estimation more difficult in
>     multisig cases.

This seems strange to me -- why wouldn't you just assume every signature
is 65 witness bytes, and just be grateful for the prioritisation benefit
if someone chooses a shorter signature? Your error margin is just 0.25
vbytes per signature.

> I tend to think in opposite terms. Is there a proof that any script can be
> transformed into an equivalent one that avoids witness weight malleability?

An alternative generalisation: is there a proof that all valid witnesses
will have a weight within some small range?

> Moreover, even if witness weight malleability is entirely avoidable, it always
> seems to come at a cost.? Taking as an example libwally's proposed "
> csv_2of3_then_2" Script, it begins with "OP_DEPTH OP_1SUB OP_1SUB"

(DEPTH 2 NUMNOTEQUAL seems like it would have been more obvious...)

Cheers,
aj


From aj at erisian.com.au  Thu Dec 13 00:24:38 2018
From: aj at erisian.com.au (Anthony Towns)
Date: Thu, 13 Dec 2018 10:24:38 +1000
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <87ftv3xerx.fsf@rustcorp.com.au>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<87ftv3xerx.fsf@rustcorp.com.au>
Message-ID: <20181213002438.r3bylrjcpwit5v2k@erisian.com.au>

On Wed, Dec 12, 2018 at 08:12:10PM +1030, Rusty Russell via bitcoin-dev wrote:
> Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:
> > Here is a combined proposal:
> > * Three new sighash flags are added: SIGHASH_NOINPUT, SIGHASH_NOFEE,
> > and SIGHASH_SCRIPTMASK.
> > * A new opcode OP_MASK is added, which acts as a NOP during execution.
> > * The sighash is computed like in BIP143, but:
> >   * If SIGHASH_SCRIPTMASK is present, for every OP_MASK in scriptCode
> > the subsequent opcode/push is removed.
> I'm asking on-list because I'm sure I'm not the only confused one.
> Having the SIGHASH_SCRIPTMASK flag is redundant AFAICT: why not always
> perform mask-removal for signing?

The way I'm thinking about it is there's four amounts of knowledge you
could have about the input you're spending at the time you generate a
signature:

 ALL: you know everything about every input for this tx

 SINGLE: you know everything about the input you're signing for, but
   not necessarily the others

 SCRIPTPUBKEY: you know the exact scriptPubKey you're trying to satisfy, but
   don't know the txid

 SCRIPTMASK: you don't know the txid, don't know the scriptPubKey, don't
   know the other taproot branches, and maybe don't even know the masked
   out terms in the script -- but you do know the structure of the
   script, and the non-masked terms

There's no value to masking in any but the final case -- the txid and
scriptPubKey commit to the full scriptcode already, so also signing the
scriptcode is just belt-and-suspenders protection.

(It might be that the "SCRIPTPUBKEY" option isn't very useful in
practice; maybe you'll always either know the txid, or need to mask
something?)

> And I am struggling to understand the role of scriptmask in a taproot
> world, where the alternate script is both hidden and general?

In a taproot world, your scriptPubKey is a point P=Q+H(Q,S)*G, where S
is a merkle root of possibly many scripts, and is spendable either by:

  sig(P)
  Q, path(S,script), script, witness(script)

SCRIPTMASK lets you prepare a signature for one particular script in
advance, even before you've decided what the other scripts are (and even
what the base point Q is), let alone built an actual transaction.

At least, that's my current understanding; and I think it makes sense...

Cheers,
aj

From rusty at rustcorp.com.au  Thu Dec 13 00:37:28 2018
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Thu, 13 Dec 2018 11:07:28 +1030
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <87pnu6s3v5.fsf@rustcorp.com.au>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<87ftv3xerx.fsf@rustcorp.com.au>
	<DAAB7568-A004-4897-B5B3-0FBBC6895246@xbt.hk>
	<87pnu6s3v5.fsf@rustcorp.com.au>
Message-ID: <87h8fiqn1z.fsf@rustcorp.com.au>

Rusty Russell <rusty at rustcorp.com.au> writes:
>> However, I?m not sure if there is any useful NOINPUT case with unmasked script.
>
> This is *not* true of Eltoo; the script itself need not change for the
> rebinding (Christian, did something change?).

This is wrong, sorry.  I re-checked the paper, and the constant for the
timelock comparison changes on each new update.

(The alternative was a new opcode like OP_TIMELOCKGREATERVERIFY which
required remembering the nLocktime for the UTXO).

So now my opinion is closer to yours: what's the use for NOINPUT &&
!NOMASK?

And is it worthwhile doing the mask complexity, rather than just
removing the commitment to script with NOINPUT?  It *feels* safer to
restrict what scripts we can sign, but is it?

Note that NOINPUT is only useful when you can't just re-sign the tx, and
you need to be able to create a new tx even if this input is spent once
(an attacker can do this with SIGHASH_MASK or not!).  ie. any other
inputs need to be signed NOINPUT or this one
SIGHASH_SINGLE|ANYONECANPAY.

You already need both key-reuse and amount-reuse to be exploited.
SIGHASH_MASK only prevents you from reusing this input for a "normal"
output; if you used this key for multiple scripts of the same form,
you're vulnerable[1].  Which, given the lightning software will be using
the One True Script, is more likely that your normal wallet using the
same keys.

So I don't think it's worth it.  SIGHASH_NOINPUT is simply dangerous
with key-reuse, and Don't Do That.

Cheers,
Rusty.
[1] Attacker can basically clone channel state to another channel.

From jl2012 at xbt.hk  Thu Dec 13 12:32:44 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Thu, 13 Dec 2018 20:32:44 +0800
Subject: [bitcoin-dev] Safer NOINPUT with output tagging
Message-ID: <9F8C0789-48E9-448A-A239-DB4AFB902A00@xbt.hk>

NOINPUT is very powerful, but the tradeoff is the risks of signature replay. While the key holders are expected not to reuse key pair, little could be done to stop payers to reuse an address. Unfortunately, key-pair reuse has been a social and technical norm since the creation of Bitcoin (the first tx made in block 170 reused the previous public key). I don?t see any hope to change this norm any time soon, if possible at all.

As the people who are designing the layer-1 protocol, we could always blame the payer and/or payee for their stupidity, just like those people laughed at victims of Ethereum dumb contracts (DAO, Parity multisig, etc). The existing bitcoin script language is so restrictive. It disallows many useful smart contracts, but at the same time prevented many dumb contracts. After all, ?smart? and ?dumb? are non-technical judgement. The DAO contract has always been faithfully executed. It?s dumb only for those invested in the project. For me, it was just a comedy show.

So NOINPUT brings us more smart contract capacity, and at the same time we are one step closer to dumb contracts. The target is to find a design that exactly enables the smart contracts we want, while minimising the risks of misuse.

The risk I am trying to mitigate is a payer mistakenly pay to a previous address with the exactly same amount, and the previous UTXO has been spent using NOINPUT. Accidental double payment is not uncommon. Even if the payee was honest and willing to refund, the money might have been spent with a replayed NOINPUT signature. Once people lost a significant amount of money this way, payers (mostly exchanges) may refuse to send money to anything other than P2PKH, native-P2WPKH and native-P2WSH (as the only 3 types without possibility of NOINPUT)

The proposed solution is that an output must be ?tagged? for it to be spendable with NOINPUT, and the ?tag? must be made explicitly by the payer. There are 2 possible ways to do the tagging:

1. A certain bit in the tx version must be set
2. A certain bit in the scriptPubKey must be set

I will analyse the pros and cons later.

Using eltoo as example. The setup utxo is a simple 2-of-2 multisig, and should not be tagged. This makes it indistinguishable from normal 1-of-1 utxo. The trigger tx, which spends the setup utxo, should be tagged, so the update txs could spend the trigger utxo with NOINPUT. Similarly, all update txs should be tagged, so they could be spent by other update txs and settlement tx with NOINPUT. As the final destination, there is no need to tag in the settlement tx.

In payer?s perspective, tagging means ?I believe this address is for one-time-use only? Since we can?t control how other people manage their addresses, we should never do tagging when paying to other people.

I mentioned 2 ways of tagging, and they have pros and cons. First of all, tagging in either way should not complicate the eltoo protocol in anyway, nor bring extra block space overhead.

A clear advantage of tagging with scriptPubKey is we could tag on a per-output basis. However, scriptPubKey tagging is only possible with native-segwit, not P2SH. That means we have to disallow NOINPUT in P2SH-segwit (Otherwise, *all* P2SH addresses would become ?risky? for payers) This should be ok for eltoo, since it has no reason to use P2SH-segwit in intermediate txs, which is more expensive.

Another problem with scriptPubKey tagging is all the existing bech32 implementations will not understand the special tag, and will pay to a tagged address as usual. An upgrade would be needed for them to refuse sending to tagged addresses by default.

On the other hand, tagging with tx version will also protect P2SH-segwit, and all existing wallets are protected by default. However, it is somewhat a layer violation and you could only tag all or none output in the same tx. Also, as Bitcoin Core has just removed the tx version from the UTXO database, adding it back could be a little bit annoying, but doable.

There is an extension to the version tagging, which could make NOINPUT even safer. In addition to tagging requirement, NOINPUT will also sign the version of the previous tx. If the wallet always uses a randomised tx version, it makes accidental replay very unlikely. However, that will burn a few more bits in the tx version field.

While this seems fully compatible with eltoo, is there any other proposals require NOINPUT, and is adversely affected by either way of tagging?

From GOLEMXIVGOLEMXIVGOLEMXIV at protonmail.ch  Thu Dec 13 14:35:22 2018
From: GOLEMXIVGOLEMXIVGOLEMXIV at protonmail.ch (GOLEM XIV)
Date: Thu, 13 Dec 2018 14:35:22 +0000
Subject: [bitcoin-dev] METABIP: ONE SEED STANDARD
Message-ID: <iQHuFn8oFceD9sIR80eSaSJHd7Wfo8AUCGFyJCG5HDE2BKKeRUs9a5_MXoWJnGgqQTPHpJIk-q0LyC5ckR3lKbYmdrpILVov6t89BbqOu6I=@protonmail.ch>

From a user perspective it is desirable that, independent from software/hardware used, a seed would be the only information necessary to recover a wallet. Unfortunately, many users think that is currently the case with BIP39, while at the same time it is marked as "Unanimously discourage for implementation" in the bitcoin wiki. The situation is confusing, and a arguably a threat to users funds.

This METABIP is *not* proposing or advocating a specific format. It only claims the importance and urgency of a clear definition, remaining indifferent about the possible outcome even if it should be 'interoperability is not desired'. Its purpose is to be as synthetic and clear as possible about the characteristics of each existing format. Advantages/disadvantages categorization was explicitly avoided.

BIP39 (https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki):
- "Unanimously discouraged for implementation"
- widely implemented/supported
- weak KDF
- no version number
- no birth date
- requires a fixed word list
- extendable with pass phrases
- simple implementation

Electrum seeds (http://docs.electrum.org/en/latest/seedphrase.html):
- only supported by Electrum
- includes version number
- no birth date
- does not require a fixed word list
- extendable with pass phrases
- simple implementation

AEZeeds (https://github.com/lightningnetwork/lnd/tree/master/aezeed):
- only supported by LND
- includes version number
- includes birth date
- requires fixed word list
- pass phrase not only extends, but encrypts seed
- pass phrase can be modified
- complex implementation?

Cypherseed(https://gist.github.com/jonasschnelli/245f35894f6ff585b3f3d33c6f208991):
Includes all aspects of AEZeeds, with the differences:
- still in draft stage
- does not use words at all, but 5char blocks
- uses MAC tags for plausible deniability

?) AEZ is an authenticated-encryption (AE) scheme optimized for ease of correct use (?AE made EZ?). - "Easy to use, not to implement. The easiness claim for AEZ is with respect to ease and versatility of use, not implementation. Writing software for AEZ is not easy, while doing a hardware design for AEZ is far worse. From the hardware designer?s perspective, AEZ?s name might seem ironic, the name better suggesting anti-easy, the antithesis of easy, or anything-but easy!" - quoted from the original AEZ paper (http://web.cs.ucdavis.edu/~rogaway/aez/aez.pdf)

Hopefully, a tiny step towards consensus in this sensible theme.

G.
--
// there would be no flight without the dream of flying - Lem
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181213/37aeff0c/attachment-0001.html>

From roconnor at blockstream.io  Thu Dec 13 16:21:10 2018
From: roconnor at blockstream.io (Russell O'Connor)
Date: Thu, 13 Dec 2018 11:21:10 -0500
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <20181213000553.cikilodf65an225g@erisian.com.au>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<CAPg+sBiu0BjZEtz-t7m3M+TnAEDG_k1GKtxwkOKh6qrSezUO7g@mail.gmail.com>
	<CAMZUoKkJdU0P_dVRvHn5zY6xUHYUptdK221ioQMp3FXZAerp3Q@mail.gmail.com>
	<702FE74C-119C-4D14-BCD3-85C4355356A2@xbt.hk>
	<CAMZUoKkYcXt7O39zdpz494f9Jm195mBtWyrH3siX4PBEAf8OKQ@mail.gmail.com>
	<20181213000553.cikilodf65an225g@erisian.com.au>
Message-ID: <CAMZUoKkPCNaPyiSanDH8cAZuybywZsNE0ErYJTctcYc+VAWQxg@mail.gmail.com>

On Wed, Dec 12, 2018 at 7:06 PM Anthony Towns <aj at erisian.com.au> wrote:

> On Tue, Dec 11, 2018 at 05:50:24PM -0500, Russell O'Connor via bitcoin-dev
> wrote:
> > On Sun, Dec 9, 2018 at 2:13 PM Johnson Lau <jl2012 at xbt.hk> wrote:
> >     The current proposal is that a 64-byte signature will be used for the
> >     default ?signing all? sighash, and 65-byte for other sighash types.
> The
> >     space saved will allow a few more txs in a block, so I think it
> worths
> >     doing. However, this also makes witness weight estimation more
> difficult in
> >     multisig cases.
>
> This seems strange to me -- why wouldn't you just assume every signature
> is 65 witness bytes, and just be grateful for the prioritisation benefit
> if someone chooses a shorter signature? Your error margin is just 0.25
> vbytes per signature.
>

The issue is that the proposal is to sign the actual weight, rather than
sign an upper bound on the weight.
The problem with signing an upper bound, is that you need to specify that
upper bound someplace in the transaction, and we are out of sneaky places
to stash that data.
Signing the actual weight is easy because the total weight is implicit, but
now you need to know the total weight before signing.


> > I tend to think in opposite terms. Is there a proof that any script can
> be
> > transformed into an equivalent one that avoids witness weight
> malleability?
>
> An alternative generalisation: is there a proof that all valid witnesses
> will have a weight within some small range?
>
> > Moreover, even if witness weight malleability is entirely avoidable, it
> always
> > seems to come at a cost.  Taking as an example libwally's proposed "
> > csv_2of3_then_2" Script, it begins with "OP_DEPTH OP_1SUB OP_1SUB"
>
> (DEPTH 2 NUMNOTEQUAL seems like it would have been more obvious...)
>
> I think the 1SUB idea was derived from the csv_2of2_then_1 Script where
DEPTH 1SUB is shorter than DEPTH 1 NUMNOTEQUAL.


> Cheers,
> aj
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181213/f03327b9/attachment-0001.html>

From roconnor at blockstream.io  Thu Dec 13 16:34:17 2018
From: roconnor at blockstream.io (Russell O'Connor)
Date: Thu, 13 Dec 2018 11:34:17 -0500
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <CAAS2fgRma+Pw-rHJSOKRVBqoxqJ3AxHO9d696fWoa-sb17JEOQ@mail.gmail.com>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<CAPg+sBiu0BjZEtz-t7m3M+TnAEDG_k1GKtxwkOKh6qrSezUO7g@mail.gmail.com>
	<CAMZUoKkJdU0P_dVRvHn5zY6xUHYUptdK221ioQMp3FXZAerp3Q@mail.gmail.com>
	<702FE74C-119C-4D14-BCD3-85C4355356A2@xbt.hk>
	<CAMZUoKkYcXt7O39zdpz494f9Jm195mBtWyrH3siX4PBEAf8OKQ@mail.gmail.com>
	<CAAS2fgRma+Pw-rHJSOKRVBqoxqJ3AxHO9d696fWoa-sb17JEOQ@mail.gmail.com>
Message-ID: <CAMZUoKnFCHA+6F1trmH6UYXTXfdwEA08z3q=b0trvdZqjH67qw@mail.gmail.com>

On Wed, Dec 12, 2018 at 12:26 PM Gregory Maxwell <gmaxwell at gmail.com> wrote:

> On Wed, Dec 12, 2018 at 5:15 PM Russell O'Connor via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > I tend to think in opposite terms. Is there a proof that any script can
> be transformed into an equivalent one that avoids witness weight
> malleability?   But I admit there is a trade off:  If we don't allow for
> signature covers weight, and we do need it, it will be too late to add.  On
> the other hand if we add signature covers weight, but it turns out that no
> Script ever needs to use it, then we've added that software complexity for
> no gain.  However, I think the software complexity is relatively low,
> making it worthwhile.
> >
> > Moreover, even if witness weight malleability is entirely avoidable, it
> always seems to come at a cost.  Taking as an example libwally's proposed
> "csv_2of3_then_2"
>
> I'm largely in agreement with you-- but my difficulty in arguing for
> signing the weight is that it seemed to me that it was only easy to
> sign an upper bound because some witnesses are variable size... and
> signing an upper bound means more signalling overhead... offsetting
> the space gains for demalleating.
>

In multi-party protocols, the last person to sign knows what the total
weight is going to be (now that we have fixed sized signatures) and at
least they have the ability to sign it.  They are probably motivated to
sign the weight as long as they are interested in the success of the
transaction.  I suppose there could be asynchronous protocols where there
isn't a last person to sign, but that seems a bit weird.  Greg, you are
probably more familiar with examples of multi-party protocols than I am.

OTOH maybe the last person to sign isn't interested in the success of the
transaction and wants to cause grief by bloating the transaction and
signing the bloated weight.  I guess in such protocols, you'll have to keep
the anti-malleablity Script Code.

I totally get the idea that signing weight has a lot of issues in many
scenarios.  But I still feel than on the whole it is better to make the
option available than to be forced to rely on anti-malleability Script Code
or non-consensus relay policy.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181213/b933196e/attachment.html>

From roconnor at blockstream.io  Thu Dec 13 16:50:10 2018
From: roconnor at blockstream.io (Russell O'Connor)
Date: Thu, 13 Dec 2018 11:50:10 -0500
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <864604F8-0BAF-403B-9A61-4788930F065F@xbt.hk>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<CAPg+sBiu0BjZEtz-t7m3M+TnAEDG_k1GKtxwkOKh6qrSezUO7g@mail.gmail.com>
	<CAMZUoKkJdU0P_dVRvHn5zY6xUHYUptdK221ioQMp3FXZAerp3Q@mail.gmail.com>
	<702FE74C-119C-4D14-BCD3-85C4355356A2@xbt.hk>
	<CAMZUoKkYcXt7O39zdpz494f9Jm195mBtWyrH3siX4PBEAf8OKQ@mail.gmail.com>
	<864604F8-0BAF-403B-9A61-4788930F065F@xbt.hk>
Message-ID: <CAMZUoKkXJCWxm4_bGLrXzBPzVjxCanU9-0uLw8tXBu+QaYE5hw@mail.gmail.com>

On Wed, Dec 12, 2018 at 2:53 PM Johnson Lau <jl2012 at xbt.hk> wrote:

>
> I think the root cause of witness weight malleability is some opcodes
> accept variable size input (without affecting the output), and that input
> is provided by the puzzle solver. Going through the opcode list, I think
> such opcodes include IF, NOTIF, VERIFY, DROP, 2DROP, NIP, DEPTH, and all
> arithmetic opcode that accepts CScriptNum (including CHECKMULTISIG)
>
> VERIFY, DROP, 2DROP, NIP are not real problem, since they should not be
> the first opcode to interact with data directly provided by the puzzle
> solver.
>
> CHECKMULTISIG is fixed by BIP147. For the key number and sig number, they
> should be part of the script, so not malleable.
>
> DEPTH is a problem only if its inputs are not later examined by other
> opcodes. Again, this is pointless.
>
> The liberally example should be protected by the MINIMAL_IF policy, which
> requires the input of OP_IF be minimal. As you note, OP_IF could be
> replaced by taproot in many cases
>
> Non-minimal CScriptNum is also banned as BIP62 policy.
>
> For the purpose of preventing malicious third party witness bloating, all
> we need is the miners to enforce the policy. There is no reason for miners
> to accept size malleated txs, as that will reduce the usable block space.
> If they hate a tx, they would simply drop it, instead of wasting the block
> space.
>

I don't know if it such a clear cut case for miner's policy.  A miner is
passed a malleated tx.  They know that there is probably a non-malleated
variant floating around out there somewhere, and they would rather have
it.  But right now they don't, and they probably not going to try to
unmalleate it themselves.  So, why not stick it into their mempool?  If it
eventually makes it into one of their blocks, then it will because it has
the best fee rate available, and to reject it outright is harmful to their
bottom line.  If they find the non-malleated variant later, great, they can
replace it and gain a higher-fee rate tx.  Of course, such a policy opens
them up to a Denial of Service attack.

So what do they do?  Do they accept malleated tx's and implement an RBF
policy that requires sufficient fee rate increases?  Do they reject
malleated txs outright to avoid falling in this trap in the first place as
you suggest?  I don't know, but I don't think things are as clear cut as
you present.


That aside, your list of weight malleable opcodes is shorter than I
imagined and I'm grateful you've compiled it.  Perhaps the best solution is
to make MINIMAL_IF and minimal CScriptNum consensus enforced in the next
version of Script and all but eliminate weight malleability in practice?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181213/b5787537/attachment.html>

From aj at erisian.com.au  Fri Dec 14 00:47:29 2018
From: aj at erisian.com.au (Anthony Towns)
Date: Fri, 14 Dec 2018 10:47:29 +1000
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <CAMZUoKkPCNaPyiSanDH8cAZuybywZsNE0ErYJTctcYc+VAWQxg@mail.gmail.com>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<CAPg+sBiu0BjZEtz-t7m3M+TnAEDG_k1GKtxwkOKh6qrSezUO7g@mail.gmail.com>
	<CAMZUoKkJdU0P_dVRvHn5zY6xUHYUptdK221ioQMp3FXZAerp3Q@mail.gmail.com>
	<702FE74C-119C-4D14-BCD3-85C4355356A2@xbt.hk>
	<CAMZUoKkYcXt7O39zdpz494f9Jm195mBtWyrH3siX4PBEAf8OKQ@mail.gmail.com>
	<20181213000553.cikilodf65an225g@erisian.com.au>
	<CAMZUoKkPCNaPyiSanDH8cAZuybywZsNE0ErYJTctcYc+VAWQxg@mail.gmail.com>
Message-ID: <20181214004729.dc2ivs435bi55cdh@erisian.com.au>

On Thu, Dec 13, 2018 at 11:21:10AM -0500, Russell O'Connor wrote:
> On Wed, Dec 12, 2018 at 7:06 PM Anthony Towns <aj at erisian.com.au> wrote:
>     On Tue, Dec 11, 2018 at 05:50:24PM -0500, Russell O'Connor via bitcoin-dev
>     wrote:
>     > On Sun, Dec 9, 2018 at 2:13 PM Johnson Lau <jl2012 at xbt.hk> wrote:
>     >? ? ?The current proposal is that a 64-byte signature will be used for the
>     >? ? ?default ?signing all? sighash, and 65-byte for other sighash types.
>     The
>     >? ? ?space saved will allow a few more txs in a block, so I think it
>     worths
>     >? ? ?doing. However, this also makes witness weight estimation more
>     difficult in
>     >? ? ?multisig cases.
>     This seems strange to me -- why wouldn't you just assume every signature
>     is 65 witness bytes, and just be grateful for the prioritisation benefit
>     if someone chooses a shorter signature? Your error margin is just 0.25
>     vbytes per signature.
> The issue is that the proposal is to sign the actual weight, rather than sign
> an upper bound on the weight.

Sorry, I elided some of my reasoning. Suppose witness data wasn't
malleable; in that case any valid witness for a particular script would
have the exact same weight, and it would be good enough to just sign
the script, because that also commits to the witness weight. (And if
you're doing SIGHASH_ALL, you're committing to the exact transaction
weight too)

I think the benefit of signing the weight is mostly that it also commits
to the feerate and hence transaction priority: you know how much you're
paying in fees when you sign, but the reason you're paying any fees is
to get a particular priority for your transaction, so if that can change
from under you because the tx weight changes, you're being ripped off
(either because you get less priority than you were paying for, or
because you get more than you wanted and would have paid less if you'd
known).

But if, just from looking at the script, you can be sure the witness
weight will be between "w" and "w + 0.8%" and your fee is "f", you
know your feerate (and hence priority) is between "f/w - 0.8%" and
"f/w". If the "0.8%" is small enough, that's just a rounding error and
you probably have more uncertainty in your feerate estimations anyway. So
I think at that point it's reasonable to target the lower bound feerate
("f/w - 0.8%"), because your only potential loss is that you get a higher
feerate and would have saved "0.8%" on f if you'd been able to be 100%
sure of that.

> The problem with signing an upper bound, is that you need to specify that upper
> bound someplace in the transaction, and we are out of sneaky places to stash
> that data.
> Signing the actual weight is easy because the total weight is implicit, but now
> you need to know the total weight before signing.

The cases where the tx is malleable by someone else, and you know what
the weight should be in advance, and you can't take the final tx once it
hits your mempool and fix the weight to what it should be and
rebroadcast, seem limited to me?

Being able to commit to a minimum feerate seems like it would be more
generally useful: it would apply for ANYONECANPAY crowd-funding type
txes as well; "here's my input, and I'm paying 3 sat/vb feerate, but only
if everyone else does too!". You could do that, I think, with a rule
along the lines of:

  (a) take the actual tx feerate, f*4000/w
  (b) round it down to the nearest exponent of 1.05 sat/kvbyte,
      so 1.3 sat/vbyte becomes 1240.62 (1.05**146 < 1.05**147=1302)
  (c) if the signature doesn't have an extra byte, then it should
      commit to that exponent (146)
  (d) if the signature does have an extra byte, b, then b<=146 and
      the signature should commit to 146-(1+b)

That way if you sign something that says "minimum fee rate of 0.001 sat
per vbyte", you commit to an exponent of 0, and someone else can raise the
feerate anywhere up to 265.7 sat/vb just by tweaking your signature to
indicate how much they've raised the feerate. Likewise you could commit
to some other exponent, and anyone else could adjust your signature to
remain valid for a tx with a feerate of up to 265,742 times greater than
what you expected, but never more than 5% less than what you expected.

This seems too complicated to do any time soon; and maybe more
complicated than will ever be worthwhile, though.

Cheers,
aj


From aj at erisian.com.au  Fri Dec 14 09:30:02 2018
From: aj at erisian.com.au (Anthony Towns)
Date: Fri, 14 Dec 2018 19:30:02 +1000
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <87h8fiqn1z.fsf@rustcorp.com.au>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<87ftv3xerx.fsf@rustcorp.com.au>
	<DAAB7568-A004-4897-B5B3-0FBBC6895246@xbt.hk>
	<87pnu6s3v5.fsf@rustcorp.com.au> <87h8fiqn1z.fsf@rustcorp.com.au>
Message-ID: <20181214093002.p2nvfrlaycqblww3@erisian.com.au>

On Thu, Dec 13, 2018 at 11:07:28AM +1030, Rusty Russell via bitcoin-dev wrote:
> And is it worthwhile doing the mask complexity, rather than just
> removing the commitment to script with NOINPUT?  It *feels* safer to
> restrict what scripts we can sign, but is it?

If it's not safer in practice, we've spent a little extra complexity
committing to a subset of the script in each signature to no gain. If
it is safer in practice, we've prevented people from losing funds. I'm
all for less complexity, but not for that tradeoff.

Also, saying "I can't see how to break this, so it's probably good
enough, even if other people have a bad feeling about it" is a crypto
anti-pattern, isn't it?

I don't see how you could feasibly commit to more information than script
masking does for use cases where you want to be able to spend different
scripts with the same signature [0]. If that's possible, I'd probably
be for it.

At the same time, script masking does seem feasible, both for
lightning/eltoo, and even for possibly complex variations of scripts. So
committing to less doesn't seem wise.

> You already need both key-reuse and amount-reuse to be exploited.
> SIGHASH_MASK only prevents you from reusing this input for a "normal"
> output; if you used this key for multiple scripts of the same form,
> you're vulnerable[1].

For example, script masking seems general enough to prevent footguns
even if (for some reason) key and value reuse across eltoo channels
were a requirement, rather than prohibited: you'd make the script be
"<eltoo-channel-id> MASK <statenum> CLTV 2DROP <a+b> CHECKSIG", and your
signature will only apply to that channel, even if another channel has
the same capacity and uses the same keys, a and b.

> So I don't think it's worth it.  SIGHASH_NOINPUT is simply dangerous
> with key-reuse, and Don't Do That.

For my money, "NOINPUT" commits to dangerously little context, and
doesn't really feel safe to include as a primitive -- as evidenced by
the suggestion to add "_UNSAFE" or similar to its name. Personally, I'm
willing to accept a bit of risk, so that feeling doesn't make me strongly
against the idea; but it also makes it hard for me to want to support
adding it. To me, committing to a masked script is a huge improvement.

Heck, if it also makes it easier to do something safer, that's also
probably a win...

Cheers,
aj

[0] You could, perhaps, commit to knowing the private keys for all the
    *outputs* you're spending to, as well as the inputs, which comes
    close to saying "I know this is a scary NOINPUT transaction, but
    we're paying to ourselves, so it will all be okay".

From aj at erisian.com.au  Fri Dec 14 10:48:39 2018
From: aj at erisian.com.au (Anthony Towns)
Date: Fri, 14 Dec 2018 20:48:39 +1000
Subject: [bitcoin-dev] Schnorr and taproot (etc) upgrade
Message-ID: <20181214104839.ur4lde3dzncadmr4@erisian.com.au>

Hi *,

(All the following is heavily informed by talking with other smart people,
and while probably all the clever ideas are theirs, any nonsense and
mistakes are certainly my own. I guess I'll pretend there were Chatham
House rules or something to avoid any blame/responsibility accidently
landing on their shoulders? Anyway, I hope discussing this in public
turns out more useful and productive than disastrous and bikesheddy :)


Rusty wrote "Without a concrete taproot proposal it's hard to make
assertions". I'm not going to offer a completely concrete proposal,
but fwiw, here's my thoughts on what should be included in the segwit v1
proposal, which I think might be concrete enough for discussion purposes:

 - introduce 33-byte v1 witness addresses should encode a secp256k1 ECC
   point (P), spendable either by:

    - a direct schnorr signature (s,R) on that point
      (s*G = R + H(R,P,txdigest)*P), with the 1-byte sighash per the
      other thread indicating exactly what goes into the tx digest, etc

    - a script (s), the witness data for the script (wit(s)),
      with a taproot/merkle path to the script (P,path(S,s)),
      satisfying the taproot condition (Q = P + H(P,S)*G)

 - the taproot scripts should get a version, and since you have to
   provide P anyway in order to spend by a script, you've got 7-bits spare
   in the byte that encodes the evenness/oddness of P, so that gives you
   v1.0 to v1.127 for free. So if we define script version 0 initially,
   and just automatically accept any script with a later version, we
   can soft-fork arbitrary script upgrades without bumping the segwit
   (major) version.

 - we should replace the ECDSA CHECKSIG/CHECKMULTISIG ops with new
   Schnorr ops. A name that's been suggested for the new ops is "CHECKDLS"
   for discrete-log-signature; I'm using that.

   Rather than CHECKMULTISIG, a simple, more general approach seems to
   be "CHECKDLSADD" which takes a signature, a number, and a pubkey,
   and increments the number if the signature is valid, and leaves it
   untouched if not. So "2 of 3 multisig" becomes "0 <p> CHECKDLSADD
   <q> CHECKDLSADD <r> CHECKDLSADD 2 EQ", eg. That means replacing the
   current four CHECK(multi)SIG(verify) opcodes, with three opcodes:
   CHECKDLS, CHECKDLSVERIFY and CHECKDLSADD.

   To make batch verifiability of signatures work, the only acceptable
   invalid signature for CHECKDLS or CHECKDLSADD needs to be an empty
   vector; anything else should fail the script/transaction/block.

 - adding OP_MASK to support script masking via sighash per the other
   thread; note this only matters for the new CHECKDLS opcodes, since for
   direct signatures on the scriptPubKey, there is no script to mask.
   This means it's completely changeable with new script versions,
   if desired.

 - making (almost) all the currently invalid opcodes upgradeable
   with what I'm calling "OP_SUCCESS" semantics [0], so that we have more
   flexibility than OP_NOP gives us. An approach for those semantics
   that seems fairly easy to analyse is to treat script processing as
   going in phases:

      1. tokenise; check push sizes and overall script size
      2. if any OP_SUCCESS appeared; succeed
      3. if banned opcodes appeared; fail (OP_VERIF, OP_VERNOTIF?)
      4. otherwise, run the script; fail if there's an error
      5. if there's exactly one, non-zero item on the stack; succeed
      6. otherwise; fail

   (Obviously an implementation can do these in parallel if that's more
   efficient)

   That way any of the "OP_SUCCESS" opcodes can be replaced by any
   normal opcode (eg addition, a different sort of signature checking,
   push tx or blockchain data to the stack) in a soft-fork; and you
   can easily be sure that the new functionality is a soft-fork (as
   long as you're not trying to change how pushes work)

   [1]

   This even means you could use an OP_SUCCESS opcode to signal an
   upgrade of other opcodes, eg an OP_ARITH64BIT that upgrades OP_ADD
   etc to support arithmetic on 64 bit inputs.

 - and that's it.

I think this is a fairly modest collection of changes:

 signature/address stuff:
   - schnorr
   - new sighash (including "noinput")
   - taproot
   - merkelized-scripts
   - avoid weird CHECKMULTISIG behaviour
 upgradeability:
   - script minor versions
   - OP_SUCCESS

I think there's a good reason to bundle all those together: the signature
stuff go together with a new address version, and the upgradeability
stuff helps reduce the need to do more new address versions.

Well, it's modest at least compared to what's conceivable: there are a
*lot* of other neat ideas that could theoretically be done in the same
soft-fork, but IMHO are better left for later, eg:

 - graftroot, g'root, cross-input signature aggregation
 - non-interactive half-signature aggregation
 - re-enabling opcodes (CAT, MUL, XOR, etc)
 - check-sig-of-msg-on-stack, push txdata, other covenant-y things
 - different cryptosystems (eg, 384 bit curves for better protection
   against future quantum computing advances; conceivably pairing curves?)
 - "EVAL" and similar language features
 - [etc]

As far as how those things could get done in future, this collection of
features leaves four ways to make further improvements:

 - new segwit version (v2-v16)
   (needed for graftroot, signature aggregation, different signature
    systems)

 - different length segwit v1 pubkey
   (could be used to provide a hash instead of the actual taproot point,
    or use a larger ECC curve)

 - new segwit v1 script version (v1.0-v1.127)
   (needed for big redesigns/simplifications of script)

 - additional opcodes (OP_SUCCESS replacement)
   (can be used to re-enable disabled opcodes like MUL/CAT/XOR/etc;
    can be used to add more complicated things like CHECKSTACKDLS,
    or PUSHTXDATA; can be used to try out different signature
    schemes)

I think its worth noting that OP_SUCCESS upgrades could be
developed/deployed in parallel, since you just need to choose an opcode to
take over and (presumably) a versionbit to signal when the new behaviour
gets activated. The other methods require agreeing on everything that's
going to go in the new version, which needs a bit more coordination.

[2] 



Anyway, to get back to the intro sentence, and to give an example of how I
think v1 addresses will work, here's my take on Eltoo in a taproot world:

  Funding tx:
    inputs: <whatever>
    outputs:
      ...
      i. pay to Q = P+H(P,S)G
         P = muSig(A,B)
         S = "MASK <500M> CLTV <P> CHECKDLSVERIFY"
      ...

  Update tx n:
    nlocktime = 500M + n
    inputs:
      1. Funding tx, or Update tx m, m<n; 
           witness: P, (S or Sm),
             sig(P, sighash=in_scriptmask:"MASK VERIF CLTV <P> CHECKDLSVERIFY")
    outputs:
      1. pay to Qn = P+H(P,Sn)G
         Sn = "MASK <500M+n+1> CLTV <P> CHECKDLSVERIFY

  Settlement tx n:
    inputs:
      1. Update tx n (unknown txid); 
	   witness: sig(Qn, sighash=in_scriptpubkey)
           nseq = csv delay
           (note: Qn != Qm unless n=m, because Sn != Sm)
    outputs:
      1: pay A's balance to A
      2: pay B's balance to B
      3..n: HTLC paying to B: see below

  Cooperative close:
    inputs:
      Funding tx, sig(Q, sighash=in_all+out_all)
    outputs:
      1..n: as agreed

(I'm assuming you create "Update tx 0" and "Settlement tx 0" to pay
yourself back if setup fails, prior to publishing the funding tx. The
eltoo paper has a "trigger" phase for that purpose instead, aiui. Also,
these two txs don't actually need to use NOINPUT, because they directly
spend from the funding tx)

As far as the HTLC outputs go... For SHA256 preimages, you prepare
a taproot address Q=P+H(P,SH), where SH is the merkle root for the
tree of two scripts, "<t> CLTV <A> CHECKDLSVERIFY" and "HASH160 <h>
EQUAL <B> CHECKDLSVERIFY". For secp256k1 preimages, your address is
P'=muSig(A,B,n*G) for some value n that just ensures you have different
keys for each htlc, and you prepare two pre-signed transactions, spending
the settlement output (whose txid is unknown), both signed with sighash
committing to the scriptPubKey and a single output. One pays A and has
a partial signature from B and nTimeLock set to the timeout; so A can
complete the signature and claim after the timeout; the other pays B
and has a conditional partial signature from A, which B can complete
upon finding out the preimage.

The settlement and pre-signed-HTLC-spend transactions all make use of
the NOINPUT-commit-to-scriptPubKey varaint in this arrangement; so it
does seem like it's probably useful in practice; scriptless scripts make
the direct-signature path pretty useful.

Cheers,
aj

[0] aka OP_RETURNTRUE https://bitcointalk.org/index.php?topic=1106586.0
    aka OP_RETURNVALID https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-March/015838.html

[1] The "drawback" to this approach is that it means that you can't
    partially verify a script if you think you know what the first few
    opcodes mean; so if a script upgrade has happened but your node hasn't
    upgraded, even if you see a transaction in a block with what you
    think is "<p> OP_CHECKDLS OP_SUCCESS", you don't check the signature.

[2] One thing that could be feasible would be to have some simple
    OP_SUCCESS upgrades (like enabling CAT/XOR/etc or adding
    CHECKSTACKDLS) specced, implemented, and tested, and have them
    activate at the same time as schnorr/taproot/etc, while keeping them
    as an independent feature at the BIP/concept/implementation levels.

    The idea there is that if it turns out they're not ready in time,
    schnorr/taproot/etc don't need to get delayed, and the others can
    just be enabled when they're ready later using a separate version bit.
    I'm not sure if there's anyone who's interested in shepherding/doing
    the spec/implementation for any of the more straight-forward features
    like that, though.


From jl2012 at xbt.hk  Fri Dec 14 13:55:43 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Fri, 14 Dec 2018 21:55:43 +0800
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <20181214093002.p2nvfrlaycqblww3@erisian.com.au>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<87ftv3xerx.fsf@rustcorp.com.au>
	<DAAB7568-A004-4897-B5B3-0FBBC6895246@xbt.hk>
	<87pnu6s3v5.fsf@rustcorp.com.au> <87h8fiqn1z.fsf@rustcorp.com.au>
	<20181214093002.p2nvfrlaycqblww3@erisian.com.au>
Message-ID: <F9FE2267-0BCB-4C67-9AE8-3285B7459D51@xbt.hk>

I don?t think this has been mentioned: without signing the script or masked script, OP_CODESEPARATOR becomes unusable or insecure with NOINPUT.

In the new sighash proposal, we will sign the hash of the full script (or masked script), without any truncation. To make OP_CODESEPARATOR works like before, we will commit to the position of the last executed OP_CODESEPARATOR. If NOINPUT doesn?t commit to the masked script, it will just blindly committing to a random OP_CODESEPARATOR position, which a wallet couldn?t know what codes are actually being executed.

> On 14 Dec 2018, at 5:30 PM, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> On Thu, Dec 13, 2018 at 11:07:28AM +1030, Rusty Russell via bitcoin-dev wrote:
>> And is it worthwhile doing the mask complexity, rather than just
>> removing the commitment to script with NOINPUT?  It *feels* safer to
>> restrict what scripts we can sign, but is it?
> 
> If it's not safer in practice, we've spent a little extra complexity
> committing to a subset of the script in each signature to no gain. If
> it is safer in practice, we've prevented people from losing funds. I'm
> all for less complexity, but not for that tradeoff.
> 
> Also, saying "I can't see how to break this, so it's probably good
> enough, even if other people have a bad feeling about it" is a crypto
> anti-pattern, isn't it?
> 
> I don't see how you could feasibly commit to more information than script
> masking does for use cases where you want to be able to spend different
> scripts with the same signature [0]. If that's possible, I'd probably
> be for it.
> 
> At the same time, script masking does seem feasible, both for
> lightning/eltoo, and even for possibly complex variations of scripts. So
> committing to less doesn't seem wise.
> 
>> You already need both key-reuse and amount-reuse to be exploited.
>> SIGHASH_MASK only prevents you from reusing this input for a "normal"
>> output; if you used this key for multiple scripts of the same form,
>> you're vulnerable[1].
> 
> For example, script masking seems general enough to prevent footguns
> even if (for some reason) key and value reuse across eltoo channels
> were a requirement, rather than prohibited: you'd make the script be
> "<eltoo-channel-id> MASK <statenum> CLTV 2DROP <a+b> CHECKSIG", and your
> signature will only apply to that channel, even if another channel has
> the same capacity and uses the same keys, a and b.
> 
>> So I don't think it's worth it.  SIGHASH_NOINPUT is simply dangerous
>> with key-reuse, and Don't Do That.
> 
> For my money, "NOINPUT" commits to dangerously little context, and
> doesn't really feel safe to include as a primitive -- as evidenced by
> the suggestion to add "_UNSAFE" or similar to its name. Personally, I'm
> willing to accept a bit of risk, so that feeling doesn't make me strongly
> against the idea; but it also makes it hard for me to want to support
> adding it. To me, committing to a masked script is a huge improvement.
> 
> Heck, if it also makes it easier to do something safer, that's also
> probably a win...
> 
> Cheers,
> aj
> 
> [0] You could, perhaps, commit to knowing the private keys for all the
>    *outputs* you're spending to, as well as the inputs, which comes
>    close to saying "I know this is a scary NOINPUT transaction, but
>    we're paying to ourselves, so it will all be okay".
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From roconnor at blockstream.io  Sat Dec 15 23:38:46 2018
From: roconnor at blockstream.io (Russell O'Connor)
Date: Sat, 15 Dec 2018 18:38:46 -0500
Subject: [bitcoin-dev] Schnorr and taproot (etc) upgrade
In-Reply-To: <20181214104839.ur4lde3dzncadmr4@erisian.com.au>
References: <20181214104839.ur4lde3dzncadmr4@erisian.com.au>
Message-ID: <CAMZUoKnSi+8W7znTNv4BcjrrTDJubDeWeJ8ynUtzs04ES2z6AQ@mail.gmail.com>

On Fri, Dec 14, 2018 at 8:39 AM Anthony Towns via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>       5. if there's exactly one, non-zero item on the stack; succeed
>

Unless it is too much bikeshedding, I'd like to propose that to succeed the
stack must be exactly empty.  Script is more composable that way, removing
the need for special logic to handle top-level CHECKSIG, vs mid-level
CHECKSIGVERIFY.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181215/599d8d6a/attachment.html>

From rusty at rustcorp.com.au  Sun Dec 16 06:55:48 2018
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Sun, 16 Dec 2018 17:25:48 +1030
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <20181214093002.p2nvfrlaycqblww3@erisian.com.au>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<87ftv3xerx.fsf@rustcorp.com.au>
	<DAAB7568-A004-4897-B5B3-0FBBC6895246@xbt.hk>
	<87pnu6s3v5.fsf@rustcorp.com.au> <87h8fiqn1z.fsf@rustcorp.com.au>
	<20181214093002.p2nvfrlaycqblww3@erisian.com.au>
Message-ID: <8736qyhsej.fsf@rustcorp.com.au>

Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:
> On Thu, Dec 13, 2018 at 11:07:28AM +1030, Rusty Russell via bitcoin-dev wrote:
>> And is it worthwhile doing the mask complexity, rather than just
>> removing the commitment to script with NOINPUT?  It *feels* safer to
>> restrict what scripts we can sign, but is it?
>
> If it's not safer in practice, we've spent a little extra complexity
> committing to a subset of the script in each signature to no gain. If
> it is safer in practice, we've prevented people from losing funds. I'm
> all for less complexity, but not for that tradeoff.

There are many complexities we could add, each of which would prevent
loss of funds in some theoretical case.

>From practical experience; reuse of private keys between lightning and
other things is not how people will lose funds[1].

It *is* however non-trivially more complicated for wallets; they
currently have a set of script templates which they will sign (ie. no
OP_CODESEPARATOR) and I implemented BIP 143 with only the simplest of
naive code[2].  In particular, there is no code to parse scripts.

Bitcoind developers are not in a good position to assess complexity
here.  They have to implement *everything*, so each increment seems
minor.  In addition, none of these new script versions will ever make
bitcoind simpler, since they have to support all prior ones.  Wallets,
however, do not have to.

I also think that minimal complexity for (future) wallets is an
underappreciated feature: the state of wallets in bitcoin is poor[3]
so simplicity should be a key goal.

Respectfully,
Rusty.

[1] Reusing your revocation base point across two channels will lose
    funds in a much more trivial way, as will reusing payment hashes
    across invoices.
[2] In fact, I added SIGHASH_ANYONECANPAY and SIGHASH_SINGLE recently
    for Segwit and it worked first time!  Kudos to BIP143's authors for
    such a clear guide.
[3] Bitcoind's wallet can't restore from seed; this neatly demonstrates
    how hard the wallet problem is, but there are many others.












code, as modern wallets currently don't have to parse the scripts they
sign.







I'm telling you that this is not how people are losing funds.



>
> Also, saying "I can't see how to break this, so it's probably good
> enough, even if other people have a bad feeling about it" is a crypto
> anti-pattern, isn't it?
>
> I don't see how you could feasibly commit to more information than script
> masking does for use cases where you want to be able to spend different
> scripts with the same signature [0]. If that's possible, I'd probably
> be for it.
>
> At the same time, script masking does seem feasible, both for
> lightning/eltoo, and even for possibly complex variations of scripts. So
> committing to less doesn't seem wise.
>
>> You already need both key-reuse and amount-reuse to be exploited.
>> SIGHASH_MASK only prevents you from reusing this input for a "normal"
>> output; if you used this key for multiple scripts of the same form,
>> you're vulnerable[1].
>
> For example, script masking seems general enough to prevent footguns
> even if (for some reason) key and value reuse across eltoo channels
> were a requirement, rather than prohibited: you'd make the script be
> "<eltoo-channel-id> MASK <statenum> CLTV 2DROP <a+b> CHECKSIG", and your
> signature will only apply to that channel, even if another channel has
> the same capacity and uses the same keys, a and b.
>
>> So I don't think it's worth it.  SIGHASH_NOINPUT is simply dangerous
>> with key-reuse, and Don't Do That.
>
> For my money, "NOINPUT" commits to dangerously little context, and
> doesn't really feel safe to include as a primitive -- as evidenced by
> the suggestion to add "_UNSAFE" or similar to its name. Personally, I'm
> willing to accept a bit of risk, so that feeling doesn't make me strongly
> against the idea; but it also makes it hard for me to want to support
> adding it. To me, committing to a masked script is a huge improvement.
>
> Heck, if it also makes it easier to do something safer, that's also
> probably a win...
>
> Cheers,
> aj
>
> [0] You could, perhaps, commit to knowing the private keys for all the
>     *outputs* you're spending to, as well as the inputs, which comes
>     close to saying "I know this is a scary NOINPUT transaction, but
>     we're paying to ourselves, so it will all be okay".
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From rsomsen at gmail.com  Mon Dec 17 15:48:15 2018
From: rsomsen at gmail.com (Ruben Somsen)
Date: Tue, 18 Dec 2018 00:48:15 +0900
Subject: [bitcoin-dev] Safer NOINPUT with output tagging
In-Reply-To: <9F8C0789-48E9-448A-A239-DB4AFB902A00@xbt.hk>
References: <9F8C0789-48E9-448A-A239-DB4AFB902A00@xbt.hk>
Message-ID: <CAPv7TjYRVUGWCyFweootbMCJEkyFG4YOJ+M_N_N4j_t043bUfw@mail.gmail.com>

Hi Johnson,

The design considerations here seem similar to the ML discussion of
whether Graftroot should be optional [1].

>While this seems fully compatible with eltoo, is there any other proposals require NOINPUT, and is adversely affected by either way of tagging?

As far as I can tell it should be compatible with Statechains [2],
since it pretty much mirrors Eltoo in setup.

My understanding is somewhat lacking, so perhaps I am missing the
mark, but it is not completely clear to me how this affects
fungibility if taproot gets added and the setup and trigger tx for
Eltoo get combined into a single transaction. Would the NOINPUT
spending condition be hidden inside the taproot commitment?

Cheers,
Ruben Somsen

[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-May/016006.html
[2]  https://www.reddit.com/r/Bitcoin/comments/9nhjea/eli51525faq_for_statechains_offchain_transfer_of/

On Mon, Dec 17, 2018 at 8:20 PM Johnson Lau via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> NOINPUT is very powerful, but the tradeoff is the risks of signature replay. While the key holders are expected not to reuse key pair, little could be done to stop payers to reuse an address. Unfortunately, key-pair reuse has been a social and technical norm since the creation of Bitcoin (the first tx made in block 170 reused the previous public key). I don?t see any hope to change this norm any time soon, if possible at all.
>
> As the people who are designing the layer-1 protocol, we could always blame the payer and/or payee for their stupidity, just like those people laughed at victims of Ethereum dumb contracts (DAO, Parity multisig, etc). The existing bitcoin script language is so restrictive. It disallows many useful smart contracts, but at the same time prevented many dumb contracts. After all, ?smart? and ?dumb? are non-technical judgement. The DAO contract has always been faithfully executed. It?s dumb only for those invested in the project. For me, it was just a comedy show.
>
> So NOINPUT brings us more smart contract capacity, and at the same time we are one step closer to dumb contracts. The target is to find a design that exactly enables the smart contracts we want, while minimising the risks of misuse.
>
> The risk I am trying to mitigate is a payer mistakenly pay to a previous address with the exactly same amount, and the previous UTXO has been spent using NOINPUT. Accidental double payment is not uncommon. Even if the payee was honest and willing to refund, the money might have been spent with a replayed NOINPUT signature. Once people lost a significant amount of money this way, payers (mostly exchanges) may refuse to send money to anything other than P2PKH, native-P2WPKH and native-P2WSH (as the only 3 types without possibility of NOINPUT)
>
> The proposed solution is that an output must be ?tagged? for it to be spendable with NOINPUT, and the ?tag? must be made explicitly by the payer. There are 2 possible ways to do the tagging:
>
> 1. A certain bit in the tx version must be set
> 2. A certain bit in the scriptPubKey must be set
>
> I will analyse the pros and cons later.
>
> Using eltoo as example. The setup utxo is a simple 2-of-2 multisig, and should not be tagged. This makes it indistinguishable from normal 1-of-1 utxo. The trigger tx, which spends the setup utxo, should be tagged, so the update txs could spend the trigger utxo with NOINPUT. Similarly, all update txs should be tagged, so they could be spent by other update txs and settlement tx with NOINPUT. As the final destination, there is no need to tag in the settlement tx.
>
> In payer?s perspective, tagging means ?I believe this address is for one-time-use only? Since we can?t control how other people manage their addresses, we should never do tagging when paying to other people.
>
> I mentioned 2 ways of tagging, and they have pros and cons. First of all, tagging in either way should not complicate the eltoo protocol in anyway, nor bring extra block space overhead.
>
> A clear advantage of tagging with scriptPubKey is we could tag on a per-output basis. However, scriptPubKey tagging is only possible with native-segwit, not P2SH. That means we have to disallow NOINPUT in P2SH-segwit (Otherwise, *all* P2SH addresses would become ?risky? for payers) This should be ok for eltoo, since it has no reason to use P2SH-segwit in intermediate txs, which is more expensive.
>
> Another problem with scriptPubKey tagging is all the existing bech32 implementations will not understand the special tag, and will pay to a tagged address as usual. An upgrade would be needed for them to refuse sending to tagged addresses by default.
>
> On the other hand, tagging with tx version will also protect P2SH-segwit, and all existing wallets are protected by default. However, it is somewhat a layer violation and you could only tag all or none output in the same tx. Also, as Bitcoin Core has just removed the tx version from the UTXO database, adding it back could be a little bit annoying, but doable.
>
> There is an extension to the version tagging, which could make NOINPUT even safer. In addition to tagging requirement, NOINPUT will also sign the version of the previous tx. If the wallet always uses a randomised tx version, it makes accidental replay very unlikely. However, that will burn a few more bits in the tx version field.
>
> While this seems fully compatible with eltoo, is there any other proposals require NOINPUT, and is adversely affected by either way of tagging?
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From jl2012 at xbt.hk  Mon Dec 17 19:08:26 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Tue, 18 Dec 2018 03:08:26 +0800
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <8736qyhsej.fsf@rustcorp.com.au>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<87ftv3xerx.fsf@rustcorp.com.au>
	<DAAB7568-A004-4897-B5B3-0FBBC6895246@xbt.hk>
	<87pnu6s3v5.fsf@rustcorp.com.au> <87h8fiqn1z.fsf@rustcorp.com.au>
	<20181214093002.p2nvfrlaycqblww3@erisian.com.au>
	<8736qyhsej.fsf@rustcorp.com.au>
Message-ID: <6DE5291C-629D-4080-9B0C-E18BEFA28B16@xbt.hk>



> On 16 Dec 2018, at 2:55 PM, Rusty Russell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:
>> On Thu, Dec 13, 2018 at 11:07:28AM +1030, Rusty Russell via bitcoin-dev wrote:
>>> And is it worthwhile doing the mask complexity, rather than just
>>> removing the commitment to script with NOINPUT?  It *feels* safer to
>>> restrict what scripts we can sign, but is it?
>> 
>> If it's not safer in practice, we've spent a little extra complexity
>> committing to a subset of the script in each signature to no gain. If
>> it is safer in practice, we've prevented people from losing funds. I'm
>> all for less complexity, but not for that tradeoff.
> 
> There are many complexities we could add, each of which would prevent
> loss of funds in some theoretical case.

Every security measures are overkill, until someone get burnt. If these security measures are really effective, no one will get burnt. The inevitable conclusion is: every effective security measures are overkill.

> 
> From practical experience; reuse of private keys between lightning and
> other things is not how people will lose funds[1].

Assuming an user holds a private key exclusively and securely, currently there are only 2 ways to lose funds by private key reuse: 1. reusing the same signature nonce; 2. signing the hash ?one?, for the SIGHASH_SINGLE consensus bug.

People lost money for the first reason. Since this is a feature of the signature schemes we use, unavoidably that will happen again from time to time. The second one has been fixed in segwit (though incompletely), and could be completely fixed with a simple softfork.

Overall speaking, while private key reuse hurts fungibility and privacy, it is not terribly insecure, as long as you use rfc6979 and are not foolish enough to sign hash ?one?. This actually thanks to the fact that signatures always committed to the previous txid. It makes sure that a signature is never valid for more than one UTXO. Unfortunately, the guarantee of non-replayability incentified the practice of key-reuse, since the day-one of bitcoin. While NOINPUT fundamentally changes this security assumption, it won?t change this long-established culture of key reuse.

So you argument seems just begging the question. Without NOINPUT, it is just impossible to lose money by key reuse, and this is exactly the topic we are debating.


> 
> It *is* however non-trivially more complicated for wallets; they
> currently have a set of script templates which they will sign (ie. no
> OP_CODESEPARATOR) and I implemented BIP 143 with only the simplest of
> naive code[2].  In particular, there is no code to parse scripts.

Sorry that I?m not familiar with the implementation details of your wallet. But as you don?t have code to parse scripts, I assume your wallet can?t handle OP_CODESEPARATOR? However, this is exactly what you should do: only implement what you actually need, and ignore those unrelated details.

Also, trying to faithfully and completely reproduce the consensus code in a wallet (even if you don?t need that at all) could be extremely dangerous. Such wallet might be tricked, for example, to sign the hash ?one? and get all money stolen (I was told someone really did that, but I don?t know the details)

If you didn?t implement OP_CODESEPARATOR because you didn?t use it, there is no reason for you to fully implement OP_MASKEDPUSH nor script parsing. In existing signature schemes (e.g. BIP143), signatures always commit to the script being executed (the ?scriptCode?). I assume that all wallets would re-construct the scriptCode at signing time, based on the limited set of script templates they support. If a wallet had a function called GetScriptCodeForMultiSig() for this purpose, all they need now is a GetMaskedScriptCodeForMultiSig() that returns the masked template, or a new option in the existing GetScriptCodeForMultiSig(). It does not need to be something like GetMaskedScript(GetScriptCodeForMultiSig()). After all, only a very small number of script templates really need NOINPUT. A GetMaskedScript() in a wallet is just an overkill (and a vulnerability if mis-implemented) 

> 
> Bitcoind developers are not in a good position to assess complexity
> here.  They have to implement *everything*, so each increment seems
> minor.  In addition, none of these new script versions will ever make
> bitcoind simpler, since they have to support all prior ones.  Wallets,
> however, do not have to.
> 
> I also think that minimal complexity for (future) wallets is an
> underappreciated feature: the state of wallets in bitcoin is poor[3]
> so simplicity should be a key goal.

It is a 3-way tradeoff of security, complexity, and functionality. While not everyone might appreciate this, security seems to always be the dominent factor in bitcoin protocol development. It was the reason why most core contributors were hesitant towards BIP148, despite they all love the functionality of segwit.

It?s also about functionality here: as I mentioned in another reply, OP_CODESEPARATOR couldn?t function properly with NOINPUT but without OP_MASKEDPUSH

This debate happens because NOINPUT introduces the third way to lose fund with key reuse. And once it is deployed, we have to support it forever, and is not something that we could softfork it away.


> 
> Respectfully,
> Rusty.
> 
> [1] Reusing your revocation base point across two channels will lose
>    funds in a much more trivial way, as will reusing payment hashes
>    across invoices.
> [2] In fact, I added SIGHASH_ANYONECANPAY and SIGHASH_SINGLE recently
>    for Segwit and it worked first time!  Kudos to BIP143's authors for
>    such a clear guide.
> [3] Bitcoind's wallet can't restore from seed; this neatly demonstrates
>    how hard the wallet problem is, but there are many others.
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> code, as modern wallets currently don't have to parse the scripts they
> sign.
> 
> 
> 
> 
> 
> 
> 
> I'm telling you that this is not how people are losing funds.
> 
> 
> 
>> 
>> Also, saying "I can't see how to break this, so it's probably good
>> enough, even if other people have a bad feeling about it" is a crypto
>> anti-pattern, isn't it?
>> 
>> I don't see how you could feasibly commit to more information than script
>> masking does for use cases where you want to be able to spend different
>> scripts with the same signature [0]. If that's possible, I'd probably
>> be for it.
>> 
>> At the same time, script masking does seem feasible, both for
>> lightning/eltoo, and even for possibly complex variations of scripts. So
>> committing to less doesn't seem wise.
>> 
>>> You already need both key-reuse and amount-reuse to be exploited.
>>> SIGHASH_MASK only prevents you from reusing this input for a "normal"
>>> output; if you used this key for multiple scripts of the same form,
>>> you're vulnerable[1].
>> 
>> For example, script masking seems general enough to prevent footguns
>> even if (for some reason) key and value reuse across eltoo channels
>> were a requirement, rather than prohibited: you'd make the script be
>> "<eltoo-channel-id> MASK <statenum> CLTV 2DROP <a+b> CHECKSIG", and your
>> signature will only apply to that channel, even if another channel has
>> the same capacity and uses the same keys, a and b.
>> 
>>> So I don't think it's worth it.  SIGHASH_NOINPUT is simply dangerous
>>> with key-reuse, and Don't Do That.
>> 
>> For my money, "NOINPUT" commits to dangerously little context, and
>> doesn't really feel safe to include as a primitive -- as evidenced by
>> the suggestion to add "_UNSAFE" or similar to its name. Personally, I'm
>> willing to accept a bit of risk, so that feeling doesn't make me strongly
>> against the idea; but it also makes it hard for me to want to support
>> adding it. To me, committing to a masked script is a huge improvement.
>> 
>> Heck, if it also makes it easier to do something safer, that's also
>> probably a win...
>> 
>> Cheers,
>> aj
>> 
>> [0] You could, perhaps, commit to knowing the private keys for all the
>>    *outputs* you're spending to, as well as the inputs, which comes
>>    close to saying "I know this is a scary NOINPUT transaction, but
>>    we're paying to ourselves, so it will all be okay".
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From jl2012 at xbt.hk  Mon Dec 17 20:08:55 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Tue, 18 Dec 2018 04:08:55 +0800
Subject: [bitcoin-dev] Safer NOINPUT with output tagging
In-Reply-To: <CAPv7TjYRVUGWCyFweootbMCJEkyFG4YOJ+M_N_N4j_t043bUfw@mail.gmail.com>
References: <9F8C0789-48E9-448A-A239-DB4AFB902A00@xbt.hk>
	<CAPv7TjYRVUGWCyFweootbMCJEkyFG4YOJ+M_N_N4j_t043bUfw@mail.gmail.com>
Message-ID: <B4234D7B-B1AA-41C3-B60B-F1E89E90A47D@xbt.hk>



> On 17 Dec 2018, at 11:48 PM, Ruben Somsen <rsomsen at gmail.com> wrote:
> 
> Hi Johnson,
> 
> The design considerations here seem similar to the ML discussion of
> whether Graftroot should be optional [1].

Yes, but the ?tagging? emphasises more on the payer?s side: if the payer cannot guarantee that the payee would never reuse the key, the payer could avoid any NOINPUT-related trouble by tagging properly.

> 
>> While this seems fully compatible with eltoo, is there any other proposals require NOINPUT, and is adversely affected by either way of tagging?
> 
> As far as I can tell it should be compatible with Statechains [2],
> since it pretty much mirrors Eltoo in setup.
> 
> My understanding is somewhat lacking, so perhaps I am missing the
> mark, but it is not completely clear to me how this affects
> fungibility if taproot gets added and the setup and trigger tx for
> Eltoo get combined into a single transaction. Would the NOINPUT
> spending condition be hidden inside the taproot commitment?

For the design considerations I mentioned above, the tags must be explicit and configurable by the payer. So it couldn?t be hidden in taproot.

If you don?t care about fungibility, you can always tag your setup output, and makes it ready for NOINPUT spending. Every update will need 2 signatures: a NOINPUT to spend the setup output or an earlier update output, and a NOINPUT to settle the latest update output.

If you care about fungibility, you can?t tag your setup output. Every update will need 3 signatures: a SINGLEINPUT (aka ANYONECANPAY) to spend the setup output, a NOINPUT to spend an earlier update output, and a NOINPUT to settle the latest update output.

(Actually, as soon as you made the first update tx with SINGLEINPUT, you don?t strictly need to make any SINGLEINPUT signatures in the later updates again, as the first update tx (or any update with a SINGLEINPUT signature) could be effectively the trigger tx. While it makes the settlement more expensive, it also means accidentally missing a SINGLEINPUT signature will not lead to any fund loss. So security-wise it?s same as the always-tagging scenario.)

The most interesting observation is: you never have the need to use NOINPUT on an already confirmed UTXO, since nothing about a confirmed UTXO is mutable. And every smart contract must anchor to a confirmed UTXO, or the whole contract is double-spendable. So the ability to NOINPUT-spend a setup output should not be strictly needed. In some (but not all) case it might make the protocol simpler, though.

So the philosophy behind output tagging is ?avoid NOINPUT at all cost, until it is truly unavoidable"

> 
> Cheers,
> Ruben Somsen
> 
> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-May/016006.html
> [2]  https://www.reddit.com/r/Bitcoin/comments/9nhjea/eli51525faq_for_statechains_offchain_transfer_of/
> 
> On Mon, Dec 17, 2018 at 8:20 PM Johnson Lau via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> 
>> NOINPUT is very powerful, but the tradeoff is the risks of signature replay. While the key holders are expected not to reuse key pair, little could be done to stop payers to reuse an address. Unfortunately, key-pair reuse has been a social and technical norm since the creation of Bitcoin (the first tx made in block 170 reused the previous public key). I don?t see any hope to change this norm any time soon, if possible at all.
>> 
>> As the people who are designing the layer-1 protocol, we could always blame the payer and/or payee for their stupidity, just like those people laughed at victims of Ethereum dumb contracts (DAO, Parity multisig, etc). The existing bitcoin script language is so restrictive. It disallows many useful smart contracts, but at the same time prevented many dumb contracts. After all, ?smart? and ?dumb? are non-technical judgement. The DAO contract has always been faithfully executed. It?s dumb only for those invested in the project. For me, it was just a comedy show.
>> 
>> So NOINPUT brings us more smart contract capacity, and at the same time we are one step closer to dumb contracts. The target is to find a design that exactly enables the smart contracts we want, while minimising the risks of misuse.
>> 
>> The risk I am trying to mitigate is a payer mistakenly pay to a previous address with the exactly same amount, and the previous UTXO has been spent using NOINPUT. Accidental double payment is not uncommon. Even if the payee was honest and willing to refund, the money might have been spent with a replayed NOINPUT signature. Once people lost a significant amount of money this way, payers (mostly exchanges) may refuse to send money to anything other than P2PKH, native-P2WPKH and native-P2WSH (as the only 3 types without possibility of NOINPUT)
>> 
>> The proposed solution is that an output must be ?tagged? for it to be spendable with NOINPUT, and the ?tag? must be made explicitly by the payer. There are 2 possible ways to do the tagging:
>> 
>> 1. A certain bit in the tx version must be set
>> 2. A certain bit in the scriptPubKey must be set
>> 
>> I will analyse the pros and cons later.
>> 
>> Using eltoo as example. The setup utxo is a simple 2-of-2 multisig, and should not be tagged. This makes it indistinguishable from normal 1-of-1 utxo. The trigger tx, which spends the setup utxo, should be tagged, so the update txs could spend the trigger utxo with NOINPUT. Similarly, all update txs should be tagged, so they could be spent by other update txs and settlement tx with NOINPUT. As the final destination, there is no need to tag in the settlement tx.
>> 
>> In payer?s perspective, tagging means ?I believe this address is for one-time-use only? Since we can?t control how other people manage their addresses, we should never do tagging when paying to other people.
>> 
>> I mentioned 2 ways of tagging, and they have pros and cons. First of all, tagging in either way should not complicate the eltoo protocol in anyway, nor bring extra block space overhead.
>> 
>> A clear advantage of tagging with scriptPubKey is we could tag on a per-output basis. However, scriptPubKey tagging is only possible with native-segwit, not P2SH. That means we have to disallow NOINPUT in P2SH-segwit (Otherwise, *all* P2SH addresses would become ?risky? for payers) This should be ok for eltoo, since it has no reason to use P2SH-segwit in intermediate txs, which is more expensive.
>> 
>> Another problem with scriptPubKey tagging is all the existing bech32 implementations will not understand the special tag, and will pay to a tagged address as usual. An upgrade would be needed for them to refuse sending to tagged addresses by default.
>> 
>> On the other hand, tagging with tx version will also protect P2SH-segwit, and all existing wallets are protected by default. However, it is somewhat a layer violation and you could only tag all or none output in the same tx. Also, as Bitcoin Core has just removed the tx version from the UTXO database, adding it back could be a little bit annoying, but doable.
>> 
>> There is an extension to the version tagging, which could make NOINPUT even safer. In addition to tagging requirement, NOINPUT will also sign the version of the previous tx. If the wallet always uses a randomised tx version, it makes accidental replay very unlikely. However, that will burn a few more bits in the tx version field.
>> 
>> While this seems fully compatible with eltoo, is there any other proposals require NOINPUT, and is adversely affected by either way of tagging?
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From jl2012 at xbt.hk  Mon Dec 17 20:16:12 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Tue, 18 Dec 2018 04:16:12 +0800
Subject: [bitcoin-dev] Schnorr and taproot (etc) upgrade
In-Reply-To: <CAMZUoKnSi+8W7znTNv4BcjrrTDJubDeWeJ8ynUtzs04ES2z6AQ@mail.gmail.com>
References: <20181214104839.ur4lde3dzncadmr4@erisian.com.au>
	<CAMZUoKnSi+8W7znTNv4BcjrrTDJubDeWeJ8ynUtzs04ES2z6AQ@mail.gmail.com>
Message-ID: <E07C0182-1656-44B0-AD2E-8EAF9552ECC1@xbt.hk>



> On 16 Dec 2018, at 7:38 AM, Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> On Fri, Dec 14, 2018 at 8:39 AM Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>       5. if there's exactly one, non-zero item on the stack; succeed
> 
> Unless it is too much bikeshedding, I'd like to propose that to succeed the stack must be exactly empty.  Script is more composable that way, removing the need for special logic to handle top-level CHECKSIG, vs mid-level CHECKSIGVERIFY.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

I proposed the same in BIP114. I wish Satoshi had designed that way. But I?m not sure if that would do more harm than good. For example, people might lose money by copying an existing script template. But they might also lose money in the same way as CHECKMULTISIG is disabled. So I?m not sure.

Another related thing I?d like to bikeshed is to pop the stack after OP_CLTV and OP_CSV. The same pros and cons apply.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181218/27c5b742/attachment.html>

From roconnor at blockstream.io  Tue Dec 18 03:18:40 2018
From: roconnor at blockstream.io (Russell O'Connor)
Date: Mon, 17 Dec 2018 22:18:40 -0500
Subject: [bitcoin-dev] Schnorr and taproot (etc) upgrade
In-Reply-To: <E07C0182-1656-44B0-AD2E-8EAF9552ECC1@xbt.hk>
References: <20181214104839.ur4lde3dzncadmr4@erisian.com.au>
	<CAMZUoKnSi+8W7znTNv4BcjrrTDJubDeWeJ8ynUtzs04ES2z6AQ@mail.gmail.com>
	<E07C0182-1656-44B0-AD2E-8EAF9552ECC1@xbt.hk>
Message-ID: <CAMZUoKnc+0pBCP84RoezKrNMrsm2oK4XX=U9-B0Oyo4ELdiEJA@mail.gmail.com>

On Mon, Dec 17, 2018 at 3:16 PM Johnson Lau <jl2012 at xbt.hk> wrote:

>
> I proposed the same in BIP114. I wish Satoshi had designed that way.
>

Thanks.  I probably read that and internalized it and forgot you wrote it.


> But I?m not sure if that would do more harm than good. For example, people
> might lose money by copying an existing script template. But they might
> also lose money in the same way as CHECKMULTISIG is disabled. So I?m not
> sure.
>
> Another related thing I?d like to bikeshed is to pop the stack after
> OP_CLTV and OP_CSV. The same pros and cons apply.
>

This one is almost a no-brainer I think.  Nearly every instance of OP_CSV
is followed by an OP_DROP and we'd save 1 WU per OP_CSV if we pop the stack
afterwards.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181217/8d9e5536/attachment-0001.html>

From pete at petertodd.org  Tue Dec 18 04:22:58 2018
From: pete at petertodd.org (Peter Todd)
Date: Mon, 17 Dec 2018 23:22:58 -0500
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <6DE5291C-629D-4080-9B0C-E18BEFA28B16@xbt.hk>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<87ftv3xerx.fsf@rustcorp.com.au>
	<DAAB7568-A004-4897-B5B3-0FBBC6895246@xbt.hk>
	<87pnu6s3v5.fsf@rustcorp.com.au> <87h8fiqn1z.fsf@rustcorp.com.au>
	<20181214093002.p2nvfrlaycqblww3@erisian.com.au>
	<8736qyhsej.fsf@rustcorp.com.au>
	<6DE5291C-629D-4080-9B0C-E18BEFA28B16@xbt.hk>
Message-ID: <20181218042258.dfj7n5qmmcbbe2wo@petertodd.org>

On Tue, Dec 18, 2018 at 03:08:26AM +0800, Johnson Lau via bitcoin-dev wrote:
> >> If it's not safer in practice, we've spent a little extra complexity
> >> committing to a subset of the script in each signature to no gain. If
> >> it is safer in practice, we've prevented people from losing funds. I'm
> >> all for less complexity, but not for that tradeoff.
> > 
> > There are many complexities we could add, each of which would prevent
> > loss of funds in some theoretical case.
> 
> Every security measures are overkill, until someone get burnt. If these security measures are really effective, no one will get burnt. The inevitable conclusion is: every effective security measures are overkill.

This isn't really a security issue, it's a software reliability issue. And
you're making a trade-off between complexity of the core protocol and
complexity of wallet software.

A core protocol failure has high costs for every single Bitcoin user; a wallet
software failure affects a much smaller number of people. So I'd be inclined to
prioritise core protocol simplicity rather than stamping out one of many, many,
ways that wallet software can screw up and lose money.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181217/d4893b80/attachment-0001.sig>

From aj at erisian.com.au  Tue Dec 18 04:58:26 2018
From: aj at erisian.com.au (Anthony Towns)
Date: Tue, 18 Dec 2018 14:58:26 +1000
Subject: [bitcoin-dev] Schnorr and taproot (etc) upgrade
In-Reply-To: <CAMZUoKnc+0pBCP84RoezKrNMrsm2oK4XX=U9-B0Oyo4ELdiEJA@mail.gmail.com>
References: <20181214104839.ur4lde3dzncadmr4@erisian.com.au>
	<CAMZUoKnSi+8W7znTNv4BcjrrTDJubDeWeJ8ynUtzs04ES2z6AQ@mail.gmail.com>
	<E07C0182-1656-44B0-AD2E-8EAF9552ECC1@xbt.hk>
	<CAMZUoKnc+0pBCP84RoezKrNMrsm2oK4XX=U9-B0Oyo4ELdiEJA@mail.gmail.com>
Message-ID: <20181218045826.2latx2rdyzsuc77k@erisian.com.au>

On Mon, Dec 17, 2018 at 10:18:40PM -0500, Russell O'Connor wrote:
> On Mon, Dec 17, 2018 at 3:16 PM Johnson Lau <jl2012 at xbt.hk> wrote:
>     But I?m not sure if that would do more harm than good. For example, people
>     might lose money by copying an existing script template. But they might
>     also lose money in the same way as CHECKMULTISIG is disabled. So I?m not
>     sure.

Well, if CHECKSIG* and CHECKMULTISIG* are all disabled in favour of
CHECKDLS, CHECKDLSVERIFY and CHECKDLSADD with both different names and
different opcodes, copying a script template opcode-for-opcode from v0
to v1 will always fail. (With taproot, this doesn't necessarily mean you
lose money, even if the script is impossible to ever satisfy, since you
may be able to recover via the direct signature path)

>     Another related thing I?d like to bikeshed is to pop the stack after
>     OP_CLTV and OP_CSV. The same pros and cons apply.
> This one is almost a no-brainer I think.? Nearly every instance of OP_CSV is
> followed by an OP_DROP and we'd save 1 WU per OP_CSV if we pop the stack
> afterwards.

It's definitely bikeshedding so whatever; but to me, it seems like it'd
be easier for everyone to have it so that if you've got the same opcode
in v0 script and v1.0 script; they have precisely the same semantics.

(That said, constructions like "<n> CLTV <p> CHECKSIGVERIFY" that avoid
the DROP and work when you're expected to leave a true value on the
stack won't work if you have to end up with an empty stack)

Cheers,
aj


From jl2012 at xbt.hk  Tue Dec 18 10:00:59 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Tue, 18 Dec 2018 18:00:59 +0800
Subject: [bitcoin-dev] Schnorr and taproot (etc) upgrade
In-Reply-To: <20181218045826.2latx2rdyzsuc77k@erisian.com.au>
References: <20181214104839.ur4lde3dzncadmr4@erisian.com.au>
	<CAMZUoKnSi+8W7znTNv4BcjrrTDJubDeWeJ8ynUtzs04ES2z6AQ@mail.gmail.com>
	<E07C0182-1656-44B0-AD2E-8EAF9552ECC1@xbt.hk>
	<CAMZUoKnc+0pBCP84RoezKrNMrsm2oK4XX=U9-B0Oyo4ELdiEJA@mail.gmail.com>
	<20181218045826.2latx2rdyzsuc77k@erisian.com.au>
Message-ID: <B26BB224-A684-495C-A419-A8CB5947AAC4@xbt.hk>



> On 18 Dec 2018, at 12:58 PM, Anthony Towns <aj at erisian.com.au> wrote:
> 
> On Mon, Dec 17, 2018 at 10:18:40PM -0500, Russell O'Connor wrote:
>> On Mon, Dec 17, 2018 at 3:16 PM Johnson Lau <jl2012 at xbt.hk> wrote:
>>    But I?m not sure if that would do more harm than good. For example, people
>>    might lose money by copying an existing script template. But they might
>>    also lose money in the same way as CHECKMULTISIG is disabled. So I?m not
>>    sure.
> 
> Well, if CHECKSIG* and CHECKMULTISIG* are all disabled in favour of
> CHECKDLS, CHECKDLSVERIFY and CHECKDLSADD with both different names and
> different opcodes, copying a script template opcode-for-opcode from v0
> to v1 will always fail. (With taproot, this doesn't necessarily mean you
> lose money, even if the script is impossible to ever satisfy, since you
> may be able to recover via the direct signature path)
> 
>>    Another related thing I?d like to bikeshed is to pop the stack after
>>    OP_CLTV and OP_CSV. The same pros and cons apply.
>> This one is almost a no-brainer I think.  Nearly every instance of OP_CSV is
>> followed by an OP_DROP and we'd save 1 WU per OP_CSV if we pop the stack
>> afterwards.
> 
> It's definitely bikeshedding so whatever; but to me, it seems like it'd
> be easier for everyone to have it so that if you've got the same opcode
> in v0 script and v1.0 script; they have precisely the same semantics.
> 
> (That said, constructions like "<n> CLTV <p> CHECKSIGVERIFY" that avoid
> the DROP and work when you're expected to leave a true value on the
> stack won't work if you have to end up with an empty stack)
> 
> Cheers,
> aj
> 

I think you mean  <p> CHECKSIGVERIFY <n> CLTV, but this works only for simple script. Most likely you need a DROP if you use IF or CODESEPARATOR.

However, if we change the rule from ?one true stack item? to ?empty stack?, CLTV/CSV popping stack will make more sense. So I think either we change all, or change nothing.

The ?true stack item? and CLTV/CSV as NOP are tech debt. Fixing them in new script version makes script creation easier and sometimes cheaper, but the fix itself creates further tech debts in the code. So I don?t have strong opinion on this topic.

From jl2012 at xbt.hk  Tue Dec 18 10:48:40 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Tue, 18 Dec 2018 18:48:40 +0800
Subject: [bitcoin-dev] Safer NOINPUT with output tagging
In-Reply-To: <B4234D7B-B1AA-41C3-B60B-F1E89E90A47D@xbt.hk>
References: <9F8C0789-48E9-448A-A239-DB4AFB902A00@xbt.hk>
	<CAPv7TjYRVUGWCyFweootbMCJEkyFG4YOJ+M_N_N4j_t043bUfw@mail.gmail.com>
	<B4234D7B-B1AA-41C3-B60B-F1E89E90A47D@xbt.hk>
Message-ID: <BC5F60A5-5E45-4330-82A2-9124C83C232B@xbt.hk>



> On 18 Dec 2018, at 4:08 AM, Johnson Lau via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> 
> 
>> On 17 Dec 2018, at 11:48 PM, Ruben Somsen <rsomsen at gmail.com <mailto:rsomsen at gmail.com>> wrote:
>> 
>> Hi Johnson,
>> 
>> The design considerations here seem similar to the ML discussion of
>> whether Graftroot should be optional [1].
> 
> Yes, but the ?tagging? emphasises more on the payer?s side: if the payer cannot guarantee that the payee would never reuse the key, the payer could avoid any NOINPUT-related trouble by tagging properly.
> 
>> 
>>> While this seems fully compatible with eltoo, is there any other proposals require NOINPUT, and is adversely affected by either way of tagging?
>> 
>> As far as I can tell it should be compatible with Statechains [2],
>> since it pretty much mirrors Eltoo in setup.
>> 
>> My understanding is somewhat lacking, so perhaps I am missing the
>> mark, but it is not completely clear to me how this affects
>> fungibility if taproot gets added and the setup and trigger tx for
>> Eltoo get combined into a single transaction. Would the NOINPUT
>> spending condition be hidden inside the taproot commitment?
> 
> For the design considerations I mentioned above, the tags must be explicit and configurable by the payer. So it couldn?t be hidden in taproot.
> 
> If you don?t care about fungibility, you can always tag your setup output, and makes it ready for NOINPUT spending. Every update will need 2 signatures: a NOINPUT to spend the setup output or an earlier update output, and a NOINPUT to settle the latest update output.
> 
> If you care about fungibility, you can?t tag your setup output. Every update will need 3 signatures: a SINGLEINPUT (aka ANYONECANPAY) to spend the setup output, a NOINPUT to spend an earlier update output, and a NOINPUT to settle the latest update output.
> 
> (Actually, as soon as you made the first update tx with SINGLEINPUT, you don?t strictly need to make any SINGLEINPUT signatures in the later updates again, as the first update tx (or any update with a SINGLEINPUT signature) could be effectively the trigger tx. While it makes the settlement more expensive, it also means accidentally missing a SINGLEINPUT signature will not lead to any fund loss. So security-wise it?s same as the always-tagging scenario.)
> 
> The most interesting observation is: you never have the need to use NOINPUT on an already confirmed UTXO, since nothing about a confirmed UTXO is mutable. And every smart contract must anchor to a confirmed UTXO, or the whole contract is double-spendable. So the ability to NOINPUT-spend a setup output should not be strictly needed. In some (but not all) case it might make the protocol simpler, though.
> 
> So the philosophy behind output tagging is ?avoid NOINPUT at all cost, until it is truly unavoidable"
> 

After thinking more carefully, I believe output tagging could have no adverse effect on eltoo.

Consider a system without tagging, where you could always spend an output with NOINPUT. Under taproot, state update could be made in 2 ways:

a) Making 2 sigs for each update. One sig is a ?script path? locktime NOINPUT spending of the setup output or an earlier update output. One sig is a ?key path? relative-locktime NOINPUT spending of the new update output. In taproot terminology, ?key path? means direct spending with the scriptPubKey, and ?script path? means revealing the script hidden in taproot. Key path spending is always cheaper.

b) Making 3 sigs for each update. One sig is a key path SINGLEINPUT (aka ANYONECANPAY) or NOINPUT spending of the setup output, without any locktime. One sig is a script path locktime NOINPUT spending of an earlier update output (if this is not the first update). One sig is a key path relative-locktime NOINPUT spending of the new update output

Note that in b), the first signature could be either SINGLEINPUT or NOINPUT, and they just work as fine. So SINGLEINPUT should be used to avoid unnecessary replayability.

In the case of uncooperative channel closing, b) is always cheaper than a), since this first broadcast signature will be a key path signature. Also, b) has better privacy if no one is cheating (only the last update is broadcast). The only information leaked in b) is the use of SINGLEINPUT and the subsequent relative-locktime NOINPUT. However, the script path signature in a) will leak the state number, which is the maximum number of updates made in this channel.

In conclusion, b) is cheaper and more private, but it is more complex by requiring 3 sigs per update rather than 2. I think it is an acceptable tradeoff. (And as I mentioned in my last mail, missing some SINGLEINPUT sigs is not the end of the world. As long as you find one SINGLEINPUT sig in your backup, it safely falls back to the trigger tx model)

What if we require output tagging? For privacy reason you shouldn?t tag your setup tx, so the setup output could not be spent with NOINPUT. Option a) doesn?t work, but b) only requires SINGLEINPUT and has no problem. So in a fee-minimising and privacy-maximising eltoo design, output tagging should have no adverse effect.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181218/76d443f8/attachment-0001.html>

From rusty at rustcorp.com.au  Mon Dec 17 03:10:42 2018
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Mon, 17 Dec 2018 13:40:42 +1030
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <F9FE2267-0BCB-4C67-9AE8-3285B7459D51@xbt.hk>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<87ftv3xerx.fsf@rustcorp.com.au>
	<DAAB7568-A004-4897-B5B3-0FBBC6895246@xbt.hk>
	<87pnu6s3v5.fsf@rustcorp.com.au> <87h8fiqn1z.fsf@rustcorp.com.au>
	<20181214093002.p2nvfrlaycqblww3@erisian.com.au>
	<F9FE2267-0BCB-4C67-9AE8-3285B7459D51@xbt.hk>
Message-ID: <87mup4hmq5.fsf@rustcorp.com.au>

Johnson Lau <jl2012 at xbt.hk> writes:
> I don?t think this has been mentioned: without signing the script or masked script, OP_CODESEPARATOR becomes unusable or insecure with NOINPUT.
>
> In the new sighash proposal, we will sign the hash of the full script (or masked script), without any truncation. To make OP_CODESEPARATOR works like before, we will commit to the position of the last executed OP_CODESEPARATOR. If NOINPUT doesn?t commit to the masked script, it will just blindly committing to a random OP_CODESEPARATOR position, which a wallet couldn?t know what codes are actually being executed.

My anti-complexity argument leads me to ask why we'd support
OP_CODESEPARATOR at all?  Though my argument is weaker here: no wallet
need support it.

But I don't see how OP_CODESEPARATOR changes anything here, wrt NOINPUT?
Remember, anyone can create an output which can be spent by any NOINPUT,
whether we go for OP_MASK or simply not commiting to the input script.

Confused,
Rusty.

From rusty at rustcorp.com.au  Wed Dec 19 00:39:26 2018
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Wed, 19 Dec 2018 11:09:26 +1030
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <6DE5291C-629D-4080-9B0C-E18BEFA28B16@xbt.hk>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<87ftv3xerx.fsf@rustcorp.com.au>
	<DAAB7568-A004-4897-B5B3-0FBBC6895246@xbt.hk>
	<87pnu6s3v5.fsf@rustcorp.com.au> <87h8fiqn1z.fsf@rustcorp.com.au>
	<20181214093002.p2nvfrlaycqblww3@erisian.com.au>
	<8736qyhsej.fsf@rustcorp.com.au>
	<6DE5291C-629D-4080-9B0C-E18BEFA28B16@xbt.hk>
Message-ID: <87efaenydd.fsf@rustcorp.com.au>

Johnson Lau <jl2012 at xbt.hk> writes:
>> On 16 Dec 2018, at 2:55 PM, Rusty Russell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> 
>> Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:
>>> On Thu, Dec 13, 2018 at 11:07:28AM +1030, Rusty Russell via bitcoin-dev wrote:
>>>> And is it worthwhile doing the mask complexity, rather than just
>>>> removing the commitment to script with NOINPUT?  It *feels* safer to
>>>> restrict what scripts we can sign, but is it?
>>> 
>>> If it's not safer in practice, we've spent a little extra complexity
>>> committing to a subset of the script in each signature to no gain. If
>>> it is safer in practice, we've prevented people from losing funds. I'm
>>> all for less complexity, but not for that tradeoff.
>> 
>> There are many complexities we could add, each of which would prevent
>> loss of funds in some theoretical case.
>
> Every security measures are overkill, until someone get burnt. If these security measures are really effective, no one will get burnt. The inevitable conclusion is: every effective security measures are overkill.
>
>> 
>> From practical experience; reuse of private keys between lightning and
>> other things is not how people will lose funds[1].
>
> So you argument seems just begging the question. Without NOINPUT, it is just impossible to lose money by key reuse, and this is exactly the topic we are debating.

I think we're getting confused here.  I'm contributing my thoughts from
the lightning implementer's point of view; there are other important
considerations, but this is my contribution.

In *lightning* there are more ways to lose funds via secret reuse.

Meanwhile, both SIGHASH_NOINPUT and OP_MASK have the reuse-is-dangerous
property; with OP_MASK the danger is limited to reuse-on-the-same-script
(ie. if you use the same key for a non-lightning output and a lightning
output, you're safe with OP_MASK.  However, this is far less likely in
practice).

I state again: OP_MASK doesn't seem to gain *lightning* any significant
security benefit.

> It does not need to be something like GetMaskedScript(GetScriptCodeForMultiSig()). After all, only a very small number of script templates really need NOINPUT. A GetMaskedScript() in a wallet is just an overkill (and a vulnerability if mis-implemented) 

Our current transaction signing code is quite generic (and, if I may say
so, readable and elegant).  We could, of course, special case
GetMaskedScript() for the case we need (the Eltoo examples I've seen
have a single OP_MASK at the front, which makes it trivial).

> It?s also about functionality here: as I mentioned in another reply, OP_CODESEPARATOR couldn?t function properly with NOINPUT but without OP_MASKEDPUSH

The mailing list seems a bit backed up or something; I replied to that
in the hope you can clear my confusion on that one.

> This debate happens because NOINPUT introduces the third way to lose fund with key reuse. And once it is deployed, we have to support it forever, and is not something that we could softfork it away.

A would use the same words to encourage you to create the simplest
possible implementation?

I don't think we disagree on philosophy, just trade-offs.  And that's
OK.

Cheers,
Rusty.

From decker.christian at gmail.com  Wed Dec 19 22:09:50 2018
From: decker.christian at gmail.com (Christian Decker)
Date: Wed, 19 Dec 2018 23:09:50 +0100
Subject: [bitcoin-dev] Safer NOINPUT with output tagging
In-Reply-To: <CAPv7TjYRVUGWCyFweootbMCJEkyFG4YOJ+M_N_N4j_t043bUfw@mail.gmail.com>
References: <9F8C0789-48E9-448A-A239-DB4AFB902A00@xbt.hk>
	<CAPv7TjYRVUGWCyFweootbMCJEkyFG4YOJ+M_N_N4j_t043bUfw@mail.gmail.com>
Message-ID: <87efadp3rl.fsf@gmail.com>

Ruben Somsen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
writes:

> Hi Johnson,
>
> The design considerations here seem similar to the ML discussion of
> whether Graftroot should be optional [1].
>
>>While this seems fully compatible with eltoo, is there any other proposals require NOINPUT, and is adversely affected by either way of tagging?
>
> As far as I can tell it should be compatible with Statechains [2],
> since it pretty much mirrors Eltoo in setup.
>
> My understanding is somewhat lacking, so perhaps I am missing the
> mark, but it is not completely clear to me how this affects
> fungibility if taproot gets added and the setup and trigger tx for
> Eltoo get combined into a single transaction. Would the NOINPUT
> spending condition be hidden inside the taproot commitment?

I'm not aware of a way to combine the setup and trigger transaction. The
trigger transaction was introduced in order to delay the start of the
timeouts until a later time, to avoid having an absolute lifetime limit
and having really huge timeout. If we were to combine the trigger
transaction with the setup transaction (which is broadcast during
channel creation), all of those timeouts would start counting down
immediately, and we could just skip the trigger transaction
altogether. It'd be more interesting to combine update and trigger
transactions in a sort of cut-through combination, but that doesn't seem
possible outside of Mimblewimble.

Cheers,
Christian

From jl2012 at xbt.hk  Thu Dec 20 11:00:53 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Thu, 20 Dec 2018 19:00:53 +0800
Subject: [bitcoin-dev] Safer NOINPUT with output tagging
In-Reply-To: <87efadp3rl.fsf@gmail.com>
References: <9F8C0789-48E9-448A-A239-DB4AFB902A00@xbt.hk>
	<CAPv7TjYRVUGWCyFweootbMCJEkyFG4YOJ+M_N_N4j_t043bUfw@mail.gmail.com>
	<87efadp3rl.fsf@gmail.com>
Message-ID: <195B4583-CE97-4C3A-9582-3C0C013CC1E9@xbt.hk>



> On 20 Dec 2018, at 6:09 AM, Christian Decker <decker.christian at gmail.com> wrote:
> 
> Ruben Somsen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>>
> writes:
> 
>> Hi Johnson,
>> 
>> The design considerations here seem similar to the ML discussion of
>> whether Graftroot should be optional [1].
>> 
>>> While this seems fully compatible with eltoo, is there any other proposals require NOINPUT, and is adversely affected by either way of tagging?
>> 
>> As far as I can tell it should be compatible with Statechains [2],
>> since it pretty much mirrors Eltoo in setup.
>> 
>> My understanding is somewhat lacking, so perhaps I am missing the
>> mark, but it is not completely clear to me how this affects
>> fungibility if taproot gets added and the setup and trigger tx for
>> Eltoo get combined into a single transaction. Would the NOINPUT
>> spending condition be hidden inside the taproot commitment?
> 
> I'm not aware of a way to combine the setup and trigger transaction. The
> trigger transaction was introduced in order to delay the start of the
> timeouts until a later time, to avoid having an absolute lifetime limit
> and having really huge timeout. If we were to combine the trigger
> transaction with the setup transaction (which is broadcast during
> channel creation), all of those timeouts would start counting down
> immediately, and we could just skip the trigger transaction
> altogether. It'd be more interesting to combine update and trigger
> transactions in a sort of cut-through combination, but that doesn't seem
> possible outside of Mimblewimble.
> 
> Cheers,
> Christian


Correct me if I?m wrong.

For the sake of simplicity, in the following I assume BIP118, 143, and 141-P2WSH are used (i.e. no taproot). Also, I skipped all the possible optimisations.

1. A and B are going to setup a channel.

2. They create one setup tx, with a setup output of the following script: <s> CLTV DROP 2 Au Bu 2 CHECKMULTISIG. Do not sign

3. They create the update tx 0, spending the setup output with NOINPUT and locktime = s+1, to the update-0 output with the script:
IF 2 As0 Bs0 2 CHECKMULTISIG ELSE <s+1> CLTV DROP 2 Au Bu 2 CHECKMULTISIG ENDIF

4. They create the settlement tx 0, spending the update-0 output with As0 and Bs0 using BIP68 relative-locktime, with 2 settlement outputs

5. They sign the setup tx and let it confirm

6. To update, they create the update tx 1, spending the setup output with NOINPUT and locktime = s+2, to the update-1 output with the script:
IF 2 As1 Bs1 2 CHECKMULTISIG ELSE <s+2> CLTV DROP 2 Au Bu 2 CHECKMULTISIG ENDIF
and create the settlement tx 1, spending the update-1 output with As1 and Bs1 using relative-locktime, with 2 settlement outputs

7. To close the channel, broadcast update tx 1. Wait for several confirmations. And broadcast settlement-tx-1


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181220/4c9d8779/attachment-0001.html>

From decker.christian at gmail.com  Thu Dec 20 17:20:54 2018
From: decker.christian at gmail.com (Christian Decker)
Date: Thu, 20 Dec 2018 18:20:54 +0100
Subject: [bitcoin-dev] Safer NOINPUT with output tagging
In-Reply-To: <195B4583-CE97-4C3A-9582-3C0C013CC1E9@xbt.hk>
References: <9F8C0789-48E9-448A-A239-DB4AFB902A00@xbt.hk>
	<CAPv7TjYRVUGWCyFweootbMCJEkyFG4YOJ+M_N_N4j_t043bUfw@mail.gmail.com>
	<87efadp3rl.fsf@gmail.com>
	<195B4583-CE97-4C3A-9582-3C0C013CC1E9@xbt.hk>
Message-ID: <871s6cw1vt.fsf@gmail.com>

Johnson Lau <jl2012 at xbt.hk> writes:
> Correct me if I?m wrong.
>
> For the sake of simplicity, in the following I assume BIP118, 143, and
> 141-P2WSH are used (i.e. no taproot). Also, I skipped all the possible
> optimisations.
>
> 1. A and B are going to setup a channel.
>
> 2. They create one setup tx, with a setup output of the following
> script: <s> CLTV DROP 2 Au Bu 2 CHECKMULTISIG. Do not sign

If we are using a trigger transaction the output of the setup
transaction would simply be `2 Au Bu 2 OP_CMS`. If we were to use a CLTV
in there we would not have an option to later attach a collaborative
close transaction that is valid immediately. Furthermore the timeout of
the CLTV would start ticking down the exact moment the setup transaction
is confirmed, hence whatever effect we are trying to achieve with that
timelock is limited, and we have a limit to the total lifetime of the
channel.

> 3. They create the update tx 0, spending the setup output with NOINPUT
> and locktime = s+1, to the update-0 output with the script: IF 2 As0
> Bs0 2 CHECKMULTISIG ELSE <s+1> CLTV DROP 2 Au Bu 2 CHECKMULTISIG ENDIF

Update 0 is usually what I call the trigger transaction. It takes the
2-of-2 multisig from the setup transaction and translates it into the
two-branch output that further updates or settlements can be attached
to. The settlement transaction attached to the trigger / update 0
reflects the initial state of the channel, i.e., if A added 2 BTC and B
added 1 BTC then settlement 0 will have 2 outputs with value 2 and 1
respectively, with the user's keys (this can also be considered the
refund in case of one party disappearing right away).

The second branch in the script you posted is the update branch, which is
not encumbered by a CSV, while the first branch is the one encumbered
with the CSV and is called the settlement branch since we'll be
attaching settlement txs to it.

The CLTV looks correct to me and ensures that we can only attach any
state >= s+1.

So just to show the output script for state `i` how I think they are
correct:

```
OP_IF
  <timeout> OP_CSV 2 <As_i> <Bs_i> 2 OP_CHECKMULTISIG
OP_ELSE
  <s+1> OP_CLTV OP_DROP 2 <Au> <Bu> 2 OP_CHECKMULTISIG 
```

And the input scripts for the update tx and the settlement tx
respectively would be:

```
OP_FALSE <Sig_Bu> <Sig_Au>
```

and

```
OP_TRUE <Sig_Bs_i> <Sig_As_i>
```

> 4. They create the settlement tx 0, spending the update-0 output with
> As0 and Bs0 using BIP68 relative-locktime, with 2 settlement outputs

If I'm not mistaken the CSV needs to be in the scriptPubkey (or P2WSH
equivalent) since segwit witnesses only allow pushes. Hence the script
in point 3 needs to add that :-)

> 5. They sign the setup tx and let it confirm

They also need to sign (but not broadcast) update_0, in order to allow
either party to initiate the closure if the counterparty become
unresponsive. The order in which settlement_0 and update_0 are signed is
not important by the way, so we can just batch these. The important part
is that signing the setup acts as a commitment.

> 6. To update, they create the update tx 1, spending the setup output
> with NOINPUT and locktime = s+2, to the update-1 output with the
> script: IF 2 As1 Bs1 2 CHECKMULTISIG ELSE <s+2> CLTV DROP 2 Au Bu 2
> CHECKMULTISIG ENDIF and create the settlement tx 1, spending the
> update-1 output with As1 and Bs1 using relative-locktime, with 2
> settlement outputs

The output script of the updates are identical to the ones in the
trigger or update_0 transaction, so they'd also need a CSV (this is why
committing to the script structure with masking still works).

> 7. To close the channel, broadcast update tx 1. Wait for several
> confirmations. And broadcast settlement-tx-1

We have to differentiate 2 cases: collaborative close and unilateral
close. In the collaborative close we come to a mutual agreement that
we'd like to take this latest state and settle. So we create a new
transaction that spends the setup output, and add outputs according to
the state we agreed upon, and we sign it. This transaction is
immediately valid, and does not need to be signed with NOINPUT. So all
the chain sees is a setup transaction with some inputs and one multisig
output (singlesig with Schnorr) and a collaborative close transaction
that spends the setup (also not signed with NOINPUT). About as normal as
transactions in Bitcoin can get.

In the unilateral case, one party isn't there anymore, or refuses to
sign. So we take the trigger transaction (not signed with NOINPUT) and
the latest update_n transaction (signed with NOINPUT) and broadcast
them. Then we wait for the CSV timeout to expire, and then send the
settlement transaction, which gives us the enforcement of the latest
state that we agreed on. The chain sees a setup transaction and a
trigger transaction (normal transactions for all intents and purposes,
except for the output script of the trigger, but we can hide that with
taproot), followed by two more transactions which are signed with
NOINPUT. So 4 transactions in the worst case, of which 2 are special,
and 2 transactions in the good case.


So all in all I think it's a tradeoff between having a larger on-chain
footprint (4 txs vs 3 txs in the worst case) and putting a fixed
lifetime on the channel for the refund case if one party disappears
right away. We'll probably find out what acceptable parameters are for
these and where the cutoff points are :-)

From jl2012 at xbt.hk  Thu Dec 20 18:04:37 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Fri, 21 Dec 2018 02:04:37 +0800
Subject: [bitcoin-dev] Safer NOINPUT with output tagging
In-Reply-To: <871s6cw1vt.fsf@gmail.com>
References: <9F8C0789-48E9-448A-A239-DB4AFB902A00@xbt.hk>
	<CAPv7TjYRVUGWCyFweootbMCJEkyFG4YOJ+M_N_N4j_t043bUfw@mail.gmail.com>
	<87efadp3rl.fsf@gmail.com>
	<195B4583-CE97-4C3A-9582-3C0C013CC1E9@xbt.hk>
	<871s6cw1vt.fsf@gmail.com>
Message-ID: <34A8F2C4-4732-4BE7-84F5-699B8D709D06@xbt.hk>



> On 21 Dec 2018, at 1:20 AM, Christian Decker <decker.christian at gmail.com> wrote:
> 
> Johnson Lau <jl2012 at xbt.hk> writes:
>> Correct me if I?m wrong.
>> 
>> For the sake of simplicity, in the following I assume BIP118, 143, and
>> 141-P2WSH are used (i.e. no taproot). Also, I skipped all the possible
>> optimisations.
>> 
>> 1. A and B are going to setup a channel.
>> 
>> 2. They create one setup tx, with a setup output of the following
>> script: <s> CLTV DROP 2 Au Bu 2 CHECKMULTISIG. Do not sign
> 
> If we are using a trigger transaction the output of the setup
> transaction would simply be `2 Au Bu 2 OP_CMS`. If we were to use a CLTV
> in there we would not have an option to later attach a collaborative
> close transaction that is valid immediately. Furthermore the timeout of
> the CLTV would start ticking down the exact moment the setup transaction
> is confirmed, hence whatever effect we are trying to achieve with that
> timelock is limited, and we have a limit to the total lifetime of the
> channel.

CLTV is absolute locktime. Only CSV will have the ?time ticking? issue, but that?s not used here. The required locktime <s> is many years in the past. To collaboratively close, you just need to sign with SIGHASH_ALL, with a locktime s+1.

> 
>> 3. They create the update tx 0, spending the setup output with NOINPUT
>> and locktime = s+1, to the update-0 output with the script: IF 2 As0
>> Bs0 2 CHECKMULTISIG ELSE <s+1> CLTV DROP 2 Au Bu 2 CHECKMULTISIG ENDIF
> 
> Update 0 is usually what I call the trigger transaction. It takes the
> 2-of-2 multisig from the setup transaction and translates it into the
> two-branch output that further updates or settlements can be attached
> to. The settlement transaction attached to the trigger / update 0
> reflects the initial state of the channel, i.e., if A added 2 BTC and B
> added 1 BTC then settlement 0 will have 2 outputs with value 2 and 1
> respectively, with the user's keys (this can also be considered the
> refund in case of one party disappearing right away).
> 
> The second branch in the script you posted is the update branch, which is
> not encumbered by a CSV, while the first branch is the one encumbered
> with the CSV and is called the settlement branch since we'll be
> attaching settlement txs to it.
> 
> The CLTV looks correct to me and ensures that we can only attach any
> state >= s+1.
> 
> So just to show the output script for state `i` how I think they are
> correct:
> 
> ```
> OP_IF
>  <timeout> OP_CSV 2 <As_i> <Bs_i> 2 OP_CHECKMULTISIG
> OP_ELSE
>  <s+1> OP_CLTV OP_DROP 2 <Au> <Bu> 2 OP_CHECKMULTISIG 
> ```
> 
> And the input scripts for the update tx and the settlement tx
> respectively would be:
> 
> ```
> OP_FALSE <Sig_Bu> <Sig_Au>
> ```
> 
> and
> 
> ```
> OP_TRUE <Sig_Bs_i> <Sig_As_i>
> ```

I think the use of OP_CSV (BIP112) is not needed here (although it doesn?t really harm except taking a few more bytes). All you need is to sign the settlement tx with a BIP68 relative locktime. Since this is a 2-of-2 branch, both parties need to agree with the relative locktime, so it is not necessary to restrict it through OP_CSV


> 
>> 4. They create the settlement tx 0, spending the update-0 output with
>> As0 and Bs0 using BIP68 relative-locktime, with 2 settlement outputs
> 
> If I'm not mistaken the CSV needs to be in the scriptPubkey (or P2WSH
> equivalent) since segwit witnesses only allow pushes. Hence the script
> in point 3 needs to add that :-)

I believe you confused OP_CSV (BIP112) with BIP68. Relative locktime is enforced by BIP68 (i.e. setting the nSequence). OP_CSV indirectly enforces relative-locktime by checking the value of nSequence. BIP68 could work standalone without OP_CSV, while OP_CSV is dependant on BIP68. In the case of n-of-n eltoo state update, OP_CSV is not needed because all n parties need to agree with the same nSequence value of the settlement tx. This is enough to make sure the settlement tx has delayed settlement.

> 
>> 5. They sign the setup tx and let it confirm
> 
> They also need to sign (but not broadcast) update_0, in order to allow
> either party to initiate the closure if the counterparty become
> unresponsive. The order in which settlement_0 and update_0 are signed is
> not important by the way, so we can just batch these. The important part
> is that signing the setup acts as a commitment.

Sure. This is obvious.

> 
>> 6. To update, they create the update tx 1, spending the setup output
>> with NOINPUT and locktime = s+2, to the update-1 output with the
>> script: IF 2 As1 Bs1 2 CHECKMULTISIG ELSE <s+2> CLTV DROP 2 Au Bu 2
>> CHECKMULTISIG ENDIF and create the settlement tx 1, spending the
>> update-1 output with As1 and Bs1 using relative-locktime, with 2
>> settlement outputs
> 
> The output script of the updates are identical to the ones in the
> trigger or update_0 transaction, so they'd also need a CSV (this is why
> committing to the script structure with masking still works).
> 
>> 7. To close the channel, broadcast update tx 1. Wait for several
>> confirmations. And broadcast settlement-tx-1
> 
> We have to differentiate 2 cases: collaborative close and unilateral
> close. In the collaborative close we come to a mutual agreement that
> we'd like to take this latest state and settle. So we create a new
> transaction that spends the setup output, and add outputs according to
> the state we agreed upon, and we sign it. This transaction is
> immediately valid, and does not need to be signed with NOINPUT. So all
> the chain sees is a setup transaction with some inputs and one multisig
> output (singlesig with Schnorr) and a collaborative close transaction
> that spends the setup (also not signed with NOINPUT). About as normal as
> transactions in Bitcoin can get.

Collaborative close is always simple as I explained in the beginning

> 
> In the unilateral case, one party isn't there anymore, or refuses to
> sign. So we take the trigger transaction (not signed with NOINPUT) and
> the latest update_n transaction (signed with NOINPUT) and broadcast
> them. Then we wait for the CSV timeout to expire, and then send the
> settlement transaction, which gives us the enforcement of the latest
> state that we agreed on. The chain sees a setup transaction and a
> trigger transaction (normal transactions for all intents and purposes,
> except for the output script of the trigger, but we can hide that with
> taproot), followed by two more transactions which are signed with
> NOINPUT. So 4 transactions in the worst case, of which 2 are special,
> and 2 transactions in the good case.
> 
> 
> So all in all I think it's a tradeoff between having a larger on-chain
> footprint (4 txs vs 3 txs in the worst case) and putting a fixed
> lifetime on the channel for the refund case if one party disappears
> right away. We'll probably find out what acceptable parameters are for
> these and where the cutoff points are :-)

If no one is cheating (i.e. only the last update is broadcast), you always need only 3 txs. Think about this: every update tx could be a trigger tx, and you can settle directly on a trigger tx, so effectively you eliminate trigger tx.







From jl2012 at xbt.hk  Thu Dec 20 19:34:38 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Fri, 21 Dec 2018 03:34:38 +0800
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <87mup4hmq5.fsf@rustcorp.com.au>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<87ftv3xerx.fsf@rustcorp.com.au>
	<DAAB7568-A004-4897-B5B3-0FBBC6895246@xbt.hk>
	<87pnu6s3v5.fsf@rustcorp.com.au> <87h8fiqn1z.fsf@rustcorp.com.au>
	<20181214093002.p2nvfrlaycqblww3@erisian.com.au>
	<F9FE2267-0BCB-4C67-9AE8-3285B7459D51@xbt.hk>
	<87mup4hmq5.fsf@rustcorp.com.au>
Message-ID: <2302A26C-FB9C-47D2-AF6C-4D2EF02FFAC0@xbt.hk>



> On 17 Dec 2018, at 11:10 AM, Rusty Russell <rusty at rustcorp.com.au> wrote:
> 
> Johnson Lau <jl2012 at xbt.hk> writes:
>> I don?t think this has been mentioned: without signing the script or masked script, OP_CODESEPARATOR becomes unusable or insecure with NOINPUT.
>> 
>> In the new sighash proposal, we will sign the hash of the full script (or masked script), without any truncation. To make OP_CODESEPARATOR works like before, we will commit to the position of the last executed OP_CODESEPARATOR. If NOINPUT doesn?t commit to the masked script, it will just blindly committing to a random OP_CODESEPARATOR position, which a wallet couldn?t know what codes are actually being executed.
> 
> My anti-complexity argument leads me to ask why we'd support
> OP_CODESEPARATOR at all?  Though my argument is weaker here: no wallet
> need support it.

Because it could make scripts more compact in some cases?

This is an example: https://github.com/bitcoin/bitcoin/pull/11423#issuecomment-333441321 <https://github.com/bitcoin/bitcoin/pull/11423#issuecomment-333441321>

But this is probably not a good example for taproot, as it could be more efficient by making the 2 branches as different script merkle leaves.


> 
> But I don't see how OP_CODESEPARATOR changes anything here, wrt NOINPUT?
> Remember, anyone can create an output which can be spent by any NOINPUT,
> whether we go for OP_MASK or simply not commiting to the input script.
> 

Let me elaborate more. Currently, scriptCode is truncated at the last executed CODESEPARATOR. If we have a very big script with many CODESEPARATORs and CHECKSIGs, there will be a lot of hashing to do.

To fix this problem, it is proposed that the new sighash will always commit to the same H(script), instead of the truncated scriptCode. So we only need to do the H(script) once, even if the script is very big

In the case of NOINPUT with MASKEDSCRIPT, it will commit to the H(masked_script) instead of H(script).

To make CODESEPARATOR works as before, the sighash will also commit to the position of the last executed CODESEPARATOR. So the semantics doesn?t change. For scripts without CODESEPARATOR, the committed value is a constant.

IF NOINPUT does not commit to H(masked_script), technically it could still commit to the position of the last executed CODESEPARATOR. But since the wallet is not aware of the actual content of the script, it has to guess the meaning of such committed positions, like ?with the HD key path m/x/y/z, I assume the script template is blah blah blah because I never use this path for another script template, and the meaning of signing the 3rd CODESEPARATOR is blah blah blah?. It still works if the assumptions hold, but sounds quite unreliable to me.

Johnson

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181221/9fff479c/attachment-0001.html>

From rusty at rustcorp.com.au  Thu Dec 20 23:17:15 2018
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Fri, 21 Dec 2018 09:47:15 +1030
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <2302A26C-FB9C-47D2-AF6C-4D2EF02FFAC0@xbt.hk>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<87ftv3xerx.fsf@rustcorp.com.au>
	<DAAB7568-A004-4897-B5B3-0FBBC6895246@xbt.hk>
	<87pnu6s3v5.fsf@rustcorp.com.au> <87h8fiqn1z.fsf@rustcorp.com.au>
	<20181214093002.p2nvfrlaycqblww3@erisian.com.au>
	<F9FE2267-0BCB-4C67-9AE8-3285B7459D51@xbt.hk>
	<87mup4hmq5.fsf@rustcorp.com.au>
	<2302A26C-FB9C-47D2-AF6C-4D2EF02FFAC0@xbt.hk>
Message-ID: <87y38jn5z8.fsf@rustcorp.com.au>

Johnson Lau <jl2012 at xbt.hk> writes:

>> On 17 Dec 2018, at 11:10 AM, Rusty Russell <rusty at rustcorp.com.au> wrote:
>> My anti-complexity argument leads me to ask why we'd support
>> OP_CODESEPARATOR at all?  Though my argument is weaker here: no wallet
>> need support it.
>
> Because it could make scripts more compact in some cases?
>
> This is an example: https://github.com/bitcoin/bitcoin/pull/11423#issuecomment-333441321 <https://github.com/bitcoin/bitcoin/pull/11423#issuecomment-333441321>
>
> But this is probably not a good example for taproot, as it could be more efficient by making the 2 branches as different script merkle leaves.

Thanks, I hadn't seen this before!  That's also the first time I've seen
SIGHASH_NONE used.

>> But I don't see how OP_CODESEPARATOR changes anything here, wrt NOINPUT?
>> Remember, anyone can create an output which can be spent by any NOINPUT,
>> whether we go for OP_MASK or simply not commiting to the input script.
>> 
>
> Let me elaborate more. Currently, scriptCode is truncated at the last executed CODESEPARATOR. If we have a very big script with many CODESEPARATORs and CHECKSIGs, there will be a lot of hashing to do.
>
> To fix this problem, it is proposed that the new sighash will always commit to the same H(script), instead of the truncated scriptCode. So we only need to do the H(script) once, even if the script is very big

Yes, I read this as proposed, it is clever.  Not sure we'd be
introducing it if OP_CODESEPARATOR didn't already exist, but at least
it's a simplfication.

> In the case of NOINPUT with MASKEDSCRIPT, it will commit to the H(masked_script) instead of H(script).
>
> To make CODESEPARATOR works as before, the sighash will also commit to the position of the last executed CODESEPARATOR. So the semantics doesn?t change. For scripts without CODESEPARATOR, the committed value is a constant.
>
> IF NOINPUT does not commit to H(masked_script), technically it could still commit to the position of the last executed CODESEPARATOR. But since the wallet is not aware of the actual content of the script, it has to guess the meaning of such committed positions, like ?with the HD key path m/x/y/z, I assume the script template is blah blah blah because I never use this path for another script template, and the meaning of signing the 3rd CODESEPARATOR is blah blah blah?. It still works if the assumptions hold, but sounds quite unreliable to me.

My question is more fundamental.  If NOINPUT doesn't commit to the input
at all, no script, no code separator, nothing.  I'm struggling to
understand your original comment was "without signing the script or
masked script, OP_CODESEPARATOR becomes unusable or insecure with
NOINPUT."

I mean, non-useful, sure.  Its purpose is to alter signature behavior,
and from the script POV there's no signature with this form of NOINPUT.
But other than the already-established "I reused keys for multiple
outputs" oops, I don't see any new dangers?

Thanks,
Rusty.

From decker.christian at gmail.com  Fri Dec 21 11:15:37 2018
From: decker.christian at gmail.com (Christian Decker)
Date: Fri, 21 Dec 2018 12:15:37 +0100
Subject: [bitcoin-dev] Safer NOINPUT with output tagging
In-Reply-To: <34A8F2C4-4732-4BE7-84F5-699B8D709D06@xbt.hk>
References: <9F8C0789-48E9-448A-A239-DB4AFB902A00@xbt.hk>
	<CAPv7TjYRVUGWCyFweootbMCJEkyFG4YOJ+M_N_N4j_t043bUfw@mail.gmail.com>
	<87efadp3rl.fsf@gmail.com>
	<195B4583-CE97-4C3A-9582-3C0C013CC1E9@xbt.hk>
	<871s6cw1vt.fsf@gmail.com>
	<34A8F2C4-4732-4BE7-84F5-699B8D709D06@xbt.hk>
Message-ID: <87woo3uo4m.fsf@gmail.com>

Johnson Lau <jl2012 at xbt.hk> writes:
>> If we are using a trigger transaction the output of the setup
>> transaction would simply be `2 Au Bu 2 OP_CMS`. If we were to use a CLTV
>> in there we would not have an option to later attach a collaborative
>> close transaction that is valid immediately. Furthermore the timeout of
>> the CLTV would start ticking down the exact moment the setup transaction
>> is confirmed, hence whatever effect we are trying to achieve with that
>> timelock is limited, and we have a limit to the total lifetime of the
>> channel.
>
> CLTV is absolute locktime. Only CSV will have the ?time ticking?
> issue, but that?s not used here. The required locktime <s> is many
> years in the past. To collaboratively close, you just need to sign
> with SIGHASH_ALL, with a locktime s+1.

Correct, we're using the CLTV here as a weird "compare two numbers that
are committed to in the signatures" operation, by using locktimes in the
past as you correctly point out.

> I think the use of OP_CSV (BIP112) is not needed here (although it
> doesn?t really harm except taking a few more bytes). All you need is
> to sign the settlement tx with a BIP68 relative locktime. Since this
> is a 2-of-2 branch, both parties need to agree with the relative
> locktime, so it is not necessary to restrict it through OP_CSV

I keep forgetting about BIP68, but you're right, that should be
sufficient for our use-case and would safe us a few bytes.

>> In the unilateral case, one party isn't there anymore, or refuses to
>> sign. So we take the trigger transaction (not signed with NOINPUT) and
>> the latest update_n transaction (signed with NOINPUT) and broadcast
>> them. Then we wait for the CSV timeout to expire, and then send the
>> settlement transaction, which gives us the enforcement of the latest
>> state that we agreed on. The chain sees a setup transaction and a
>> trigger transaction (normal transactions for all intents and purposes,
>> except for the output script of the trigger, but we can hide that with
>> taproot), followed by two more transactions which are signed with
>> NOINPUT. So 4 transactions in the worst case, of which 2 are special,
>> and 2 transactions in the good case.
>> 
>> 
>> So all in all I think it's a tradeoff between having a larger on-chain
>> footprint (4 txs vs 3 txs in the worst case) and putting a fixed
>> lifetime on the channel for the refund case if one party disappears
>> right away. We'll probably find out what acceptable parameters are for
>> these and where the cutoff points are :-)
>
> If no one is cheating (i.e. only the last update is broadcast), you
> always need only 3 txs. Think about this: every update tx could be a
> trigger tx, and you can settle directly on a trigger tx, so
> effectively you eliminate trigger tx.

I seem to keep mentally mixing different variants of the protocol in my
head. You are of course correct that the trigger and the update can be
considered the same, hence the 3 txs limit is right. Sorry for the
confusion :-(

From ZmnSCPxj at protonmail.com  Fri Dec 21 11:40:06 2018
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 21 Dec 2018 11:40:06 +0000
Subject: [bitcoin-dev] Safer NOINPUT with output tagging
In-Reply-To: <9F8C0789-48E9-448A-A239-DB4AFB902A00@xbt.hk>
References: <9F8C0789-48E9-448A-A239-DB4AFB902A00@xbt.hk>
Message-ID: <8z5NQkaOUo9z-wdBphQtZrxIf7OCtVQFvK3neMWvcRsngld5XJs-vt7CLuY46ZOp_pX8gEd92pMdkEkp8CUOMH9lUTw5ocWsbDPiaKdSa2I=@protonmail.com>

Good morning Johnson,

> The proposed solution is that an output must be ?tagged? for it to be spendable with NOINPUT, and the ?tag? must be made explicitly by the payer. There are 2 possible ways to do the tagging:

First off, this is a very good idea I think.


>     While this seems fully compatible with eltoo, is there any other proposals require NOINPUT, and is adversely affected by either way of tagging?


It prevents use of SIGHASH_NOINPUT to support walletless offchain protocols.
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-May/015925.html
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-May/015926.html

In brief, this idea of "walletless offchain software" is motivated by the fact, that various onchain wallets exist with many features.
For instance, privacy-enhancement as in Samourai/Wasabi/etc.
And so on.
There are requests to include such features in e.g. Lightning software, for example: https://github.com/ElementsProject/lightning/issues/2105
But it is enough of a challenge to implement Lightning, without the additional burden of implementing nice onchain features like coin control and change labelling.

It would be best if we can retain features from an onchain wallet, while using our coin on an offchain system.
Further, it would allow onchain wallet developers to focus and gain expertise on onchain wallet features, and, vice versa, for offchain walletless software developers to focus on offchain software features.

The core idea comes from the way that offchain systems need to be set up:

1.  First we agree on a (currently unconfirmed) txid and output number on which to anchor our offchain system (the funding transaction).
2.  Then we sign a backout transaction (the initial commitment transactions under Poon-Dryja, or the timelock branches for CoinSwapCS, or the initial kickoff-settlement transactions for Decker-Russell-Osuntokun) spending the agreed TXO, to return the money back to the owner(s) in case some participant aborts the setting up of the offchain system.
3.  Then we sign and broadcast the funding transaction.

Unfortunately, the typical onchain wallet has a very simple and atomic (uncuttable) process for making transactions:

1.  Make, sign, and broadcast transaction with an output paying to the desired address.

Thus a typical onchain wallet cannot be used to set up a funding transaction for an offchain system.

Now suppose we take advantage of `SIGHASH_NOINPUT`, and modify our offchain system setup as below:

1.  First we agree on a N-of-N pubkey on which to anchor our offchain system (the funding address).
2.  Then we sign (with SIGHASH_NOINPUT) a backout transaction (the initial commitment transactions under Poon-Dryja, or the timelock branches for CoinSwapCS, or the initial kickoff-settlement transactions for Decker-Russell-Osuntokun), spending the agreed funding address, to return the money back to the owner(s) in case some participant aborts the setting up of the offchain system.
3.  Make, sign, and broadcast transaction with an output paying to the funding address.  This step can be done by any typical onchain wallet.

Note that only the starting backout transaction is *required* to sign with `SIGHASH_NOINPUT`.
For instance, a Poon-Dryja channel may sign succeeding commitment transactions with `SIGHASH_ALL`.
Finally, only in case of disaster (some participant aborts before the offchain system is set up) is the `SIGHASH_NOINPUT` backoff transaction broadcasted.
A "normal close" of the offchain system can be signed with typical `SIGHASH_ALL` for no fungibility problems.

With this, an offchain system need not require its implementing software to implement its own wallet.
Further, onchain wallets can directly put its funds into an offchain system, without requiring an onchain transfer to an offchain software wallet.

This can be helpful when building overall software.
We might take any commodity onchain wallet and any commodity offchain software, and we can integrate them easily to create a seamless wallet experience that allows spending and receiving onchain and offchain.
Further, improvements in one software component do not require re-building of the other software component.

--

That said:

1.  For Lightning and similar systems, the fact that the Lightning node will give you an address that, when paid using any commodity onchain wallet, opens a channel, means that people will make wrong assumptions.
    In particular, they are likely to assume that address reuse is safe and will attempt to "refill" their channel by paying to the same address again in the future.
    From this alone, we can immediately see that this idea is pointless.
2.  Dual-funding, which for some reason is asked for as a feature, cannot be done with this anyway.
3.  It may be better to provide some standard way of signing transactions without broadcasting them.
    This would still allow similar separation of concerns between onchain and offchain software components.

So output tagging still seems fine to me, even if this particular use cannot be supported.

Regards,
ZmnSCPxj



From jl2012 at xbt.hk  Fri Dec 21 15:37:05 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Fri, 21 Dec 2018 23:37:05 +0800
Subject: [bitcoin-dev] Safer NOINPUT with output tagging
In-Reply-To: <8z5NQkaOUo9z-wdBphQtZrxIf7OCtVQFvK3neMWvcRsngld5XJs-vt7CLuY46ZOp_pX8gEd92pMdkEkp8CUOMH9lUTw5ocWsbDPiaKdSa2I=@protonmail.com>
References: <9F8C0789-48E9-448A-A239-DB4AFB902A00@xbt.hk>
	<8z5NQkaOUo9z-wdBphQtZrxIf7OCtVQFvK3neMWvcRsngld5XJs-vt7CLuY46ZOp_pX8gEd92pMdkEkp8CUOMH9lUTw5ocWsbDPiaKdSa2I=@protonmail.com>
Message-ID: <34B38940-524D-42B9-8A67-6A62DCE04665@xbt.hk>



> On 21 Dec 2018, at 7:40 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
> 
> Good morning Johnson,
> 
>> The proposed solution is that an output must be ?tagged? for it to be spendable with NOINPUT, and the ?tag? must be made explicitly by the payer. There are 2 possible ways to do the tagging:
> 
> First off, this is a very good idea I think.
> 
> 
>>    While this seems fully compatible with eltoo, is there any other proposals require NOINPUT, and is adversely affected by either way of tagging?
> 
> 
> It prevents use of SIGHASH_NOINPUT to support walletless offchain protocols.
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-May/015925.html
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-May/015926.html
> 
> In brief, this idea of "walletless offchain software" is motivated by the fact, that various onchain wallets exist with many features.
> For instance, privacy-enhancement as in Samourai/Wasabi/etc.
> And so on.
> There are requests to include such features in e.g. Lightning software, for example: https://github.com/ElementsProject/lightning/issues/2105
> But it is enough of a challenge to implement Lightning, without the additional burden of implementing nice onchain features like coin control and change labelling.
> 
> It would be best if we can retain features from an onchain wallet, while using our coin on an offchain system.
> Further, it would allow onchain wallet developers to focus and gain expertise on onchain wallet features, and, vice versa, for offchain walletless software developers to focus on offchain software features.
> 
> The core idea comes from the way that offchain systems need to be set up:
> 
> 1.  First we agree on a (currently unconfirmed) txid and output number on which to anchor our offchain system (the funding transaction).
> 2.  Then we sign a backout transaction (the initial commitment transactions under Poon-Dryja, or the timelock branches for CoinSwapCS, or the initial kickoff-settlement transactions for Decker-Russell-Osuntokun) spending the agreed TXO, to return the money back to the owner(s) in case some participant aborts the setting up of the offchain system.
> 3.  Then we sign and broadcast the funding transaction.
> 
> Unfortunately, the typical onchain wallet has a very simple and atomic (uncuttable) process for making transactions:
> 
> 1.  Make, sign, and broadcast transaction with an output paying to the desired address.
> 
> Thus a typical onchain wallet cannot be used to set up a funding transaction for an offchain system.
> 
> Now suppose we take advantage of `SIGHASH_NOINPUT`, and modify our offchain system setup as below:
> 
> 1.  First we agree on a N-of-N pubkey on which to anchor our offchain system (the funding address).
> 2.  Then we sign (with SIGHASH_NOINPUT) a backout transaction (the initial commitment transactions under Poon-Dryja, or the timelock branches for CoinSwapCS, or the initial kickoff-settlement transactions for Decker-Russell-Osuntokun), spending the agreed funding address, to return the money back to the owner(s) in case some participant aborts the setting up of the offchain system.
> 3.  Make, sign, and broadcast transaction with an output paying to the funding address.  This step can be done by any typical onchain wallet.
> 
> Note that only the starting backout transaction is *required* to sign with `SIGHASH_NOINPUT`.
> For instance, a Poon-Dryja channel may sign succeeding commitment transactions with `SIGHASH_ALL`.
> Finally, only in case of disaster (some participant aborts before the offchain system is set up) is the `SIGHASH_NOINPUT` backoff transaction broadcasted.
> A "normal close" of the offchain system can be signed with typical `SIGHASH_ALL` for no fungibility problems.
> 
> With this, an offchain system need not require its implementing software to implement its own wallet.
> Further, onchain wallets can directly put its funds into an offchain system, without requiring an onchain transfer to an offchain software wallet.
> 
> This can be helpful when building overall software.
> We might take any commodity onchain wallet and any commodity offchain software, and we can integrate them easily to create a seamless wallet experience that allows spending and receiving onchain and offchain.
> Further, improvements in one software component do not require re-building of the other software component.
> 
> --
> 
> That said:
> 
> 1.  For Lightning and similar systems, the fact that the Lightning node will give you an address that, when paid using any commodity onchain wallet, opens a channel, means that people will make wrong assumptions.
>    In particular, they are likely to assume that address reuse is safe and will attempt to "refill" their channel by paying to the same address again in the future.
>    From this alone, we can immediately see that this idea is pointless.
> 2.  Dual-funding, which for some reason is asked for as a feature, cannot be done with this anyway.
> 3.  It may be better to provide some standard way of signing transactions without broadcasting them.
>    This would still allow similar separation of concerns between onchain and offchain software components.
> 
> So output tagging still seems fine to me, even if this particular use cannot be supported.
> 
> Regards,
> ZmnSCPxj
> 
> 

Generally speaking, I think walletless protocol is needed only when you want to rely a third party to open a offchain smart contract. It could be coinswap, eltoo, or anything similar.

However, since NOINPUT still commits to the input value, if the third party paid an unexpected value, even off by 1 satoshi, the smart contract is toast. It is not uncommon as some exchanges would deduct fees from withdrawal amount. Since we don?t have a social norm to require the payer to always pay the exact requested amount, the exchange might not be liable for the loss.

It is of course possible to have a NOINPUT_NOAMOUNT, but I can?t see any chance for this being accepted.

So, unless the payer is liable for paying a wrong amount, walletless contract opening is unreliable.

Johnson

From jl2012 at xbt.hk  Fri Dec 21 16:21:42 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Sat, 22 Dec 2018 00:21:42 +0800
Subject: [bitcoin-dev] Safer NOINPUT with output tagging
In-Reply-To: <87woo3uo4m.fsf@gmail.com>
References: <9F8C0789-48E9-448A-A239-DB4AFB902A00@xbt.hk>
	<CAPv7TjYRVUGWCyFweootbMCJEkyFG4YOJ+M_N_N4j_t043bUfw@mail.gmail.com>
	<87efadp3rl.fsf@gmail.com>
	<195B4583-CE97-4C3A-9582-3C0C013CC1E9@xbt.hk>
	<871s6cw1vt.fsf@gmail.com>
	<34A8F2C4-4732-4BE7-84F5-699B8D709D06@xbt.hk>
	<87woo3uo4m.fsf@gmail.com>
Message-ID: <96D7F9F7-4D1B-42ED-A82C-E714F3AED047@xbt.hk>



> On 21 Dec 2018, at 7:15 PM, Christian Decker <decker.christian at gmail.com> wrote:
> 
> Johnson Lau <jl2012 at xbt.hk> writes:
> 
>> I think the use of OP_CSV (BIP112) is not needed here (although it
>> doesn?t really harm except taking a few more bytes). All you need is
>> to sign the settlement tx with a BIP68 relative locktime. Since this
>> is a 2-of-2 branch, both parties need to agree with the relative
>> locktime, so it is not necessary to restrict it through OP_CSV
> 
> I keep forgetting about BIP68, but you're right, that should be
> sufficient for our use-case and would safe us a few bytes.
> 

With taproot, this actually saves a lot more than a few bytes. For each update, you will make 3 signatures. One is a SIGHASH_ALL spending the setup TXO with no locktime. One is a NOINPUT spending a previous update TXO with absolute locktime. One is a NOINPUT spending the latest update TXO with relative locktime. For the first and third signatures, you will just sign directly with the scriptPubKey, without revealing the hidden taproot script. The second signature will reveal the taproot script, but it is needed only when someone published an outdated update tx.




From jl2012 at xbt.hk  Fri Dec 21 18:54:42 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Sat, 22 Dec 2018 02:54:42 +0800
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <87y38jn5z8.fsf@rustcorp.com.au>
References: <CAPg+sBhuPG-2GXc+Bp0yv5ywry2fk56LPLT4AY0Kcs+YEoz4FA@mail.gmail.com>
	<87ftv3xerx.fsf@rustcorp.com.au>
	<DAAB7568-A004-4897-B5B3-0FBBC6895246@xbt.hk>
	<87pnu6s3v5.fsf@rustcorp.com.au> <87h8fiqn1z.fsf@rustcorp.com.au>
	<20181214093002.p2nvfrlaycqblww3@erisian.com.au>
	<F9FE2267-0BCB-4C67-9AE8-3285B7459D51@xbt.hk>
	<87mup4hmq5.fsf@rustcorp.com.au>
	<2302A26C-FB9C-47D2-AF6C-4D2EF02FFAC0@xbt.hk>
	<87y38jn5z8.fsf@rustcorp.com.au>
Message-ID: <73F32BC6-751E-4F35-BE6D-B31170FC0A54@xbt.hk>



> On 21 Dec 2018, at 7:17 AM, Rusty Russell <rusty at rustcorp.com.au> wrote:
> 
> Johnson Lau <jl2012 at xbt.hk> writes:
> 
>>> But I don't see how OP_CODESEPARATOR changes anything here, wrt NOINPUT?
>>> Remember, anyone can create an output which can be spent by any NOINPUT,
>>> whether we go for OP_MASK or simply not commiting to the input script.
>>> 
>> 
>> Let me elaborate more. Currently, scriptCode is truncated at the last executed CODESEPARATOR. If we have a very big script with many CODESEPARATORs and CHECKSIGs, there will be a lot of hashing to do.
>> 
>> To fix this problem, it is proposed that the new sighash will always commit to the same H(script), instead of the truncated scriptCode. So we only need to do the H(script) once, even if the script is very big
> 
> Yes, I read this as proposed, it is clever.  Not sure we'd be
> introducing it if OP_CODESEPARATOR didn't already exist, but at least
> it's a simplfication.
> 
>> In the case of NOINPUT with MASKEDSCRIPT, it will commit to the H(masked_script) instead of H(script).
>> 
>> To make CODESEPARATOR works as before, the sighash will also commit to the position of the last executed CODESEPARATOR. So the semantics doesn?t change. For scripts without CODESEPARATOR, the committed value is a constant.
>> 
>> IF NOINPUT does not commit to H(masked_script), technically it could still commit to the position of the last executed CODESEPARATOR. But since the wallet is not aware of the actual content of the script, it has to guess the meaning of such committed positions, like ?with the HD key path m/x/y/z, I assume the script template is blah blah blah because I never use this path for another script template, and the meaning of signing the 3rd CODESEPARATOR is blah blah blah?. It still works if the assumptions hold, but sounds quite unreliable to me.
> 
> My question is more fundamental.  If NOINPUT doesn't commit to the input
> at all, no script, no code separator, nothing.  I'm struggling to
> understand your original comment was "without signing the script or
> masked script, OP_CODESEPARATOR becomes unusable or insecure with
> NOINPUT."
> 
> I mean, non-useful, sure.  Its purpose is to alter signature behavior,
> and from the script POV there's no signature with this form of NOINPUT.
> But other than the already-established "I reused keys for multiple
> outputs" oops, I don't see any new dangers?
> 
> Thanks,
> Rusty.

The question I would like to ask is: is OP_CODESEPARATOR useful under taproot? Generally speaking, CODESEPARATOR is useful only with conditional opcodes (OP_IF etc), and conditional opcodes are mostly replaced by merklized scripts. I am not sure how much usability is left with CODESEPARATOR

If no one needs CODESEPARATOR, we might just disable it, and makes the validation code a bit simpler

If CODESEPARATOR is useful, then we should find a way to make it works with NOINPUT. With H(masked_script) committed, the meaning of the CODESEPARATOR position is very clear. Without H(masked_script), the meaning of the position totally relies on the assumption that ?this public key is only used in this script template?.

Ignore CODESEPARATOR and more generally, I agree with you that script masking does not help in the case of address (scriptPubKey) reuse, which is the commonest type of reuse. However, it prevents replayability when the same public key is reused in different scripts

From vitteaymeric at gmail.com  Fri Dec 21 23:58:04 2018
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Sat, 22 Dec 2018 00:58:04 +0100
Subject: [bitcoin-dev] BIP39 seeds
Message-ID: <68330522-7e7c-c3b4-99a9-1c68ddb56f23@gmail.com>

Has anybody already looked at this: given N randomly chosen words
belonging to a BIP39 2048 words dictionary, what is the probability to
get a "valid" BIP39 seed (ie with the right checksum)?

The result looks (very) surprising to me and might have some use cases,
just would like to know if this topic has already been discussed before
going further

-- 
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms


From ZmnSCPxj at protonmail.com  Sat Dec 22 14:25:16 2018
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 22 Dec 2018 14:25:16 +0000
Subject: [bitcoin-dev] Safer NOINPUT with output tagging
In-Reply-To: <34B38940-524D-42B9-8A67-6A62DCE04665@xbt.hk>
References: <9F8C0789-48E9-448A-A239-DB4AFB902A00@xbt.hk>
	<8z5NQkaOUo9z-wdBphQtZrxIf7OCtVQFvK3neMWvcRsngld5XJs-vt7CLuY46ZOp_pX8gEd92pMdkEkp8CUOMH9lUTw5ocWsbDPiaKdSa2I=@protonmail.com>
	<34B38940-524D-42B9-8A67-6A62DCE04665@xbt.hk>
Message-ID: <KFCfNAmHhRvsDJs70UW3l4ssqBtdBrb8gYP5A3cN2hsTPrXVg7f5Yrt2LOo5V0QdAhhoooc3lllXxiiXSVt_28obYBl_XKAgEQkGg1kOj8I=@protonmail.com>

Good morning Johnson,

> Generally speaking, I think walletless protocol is needed only when you want to rely a third party to open a offchain smart contract. It could be coinswap, eltoo, or anything similar.

I think a third party would be pointless in general, but then I am strongly against custodiality.

The idea is that you have some kind of hardware wallet or similar "somewhat cold" storage *that you control yourself*, and crate channels for your hot offchain Lightning wallet, without adding more transactions from your somewhat-cold storage to your hot offchain Lightning wallet on the blockchain.

Then you could feed a set of addresses to the hot offchain wallet (addresses your somewhat-cold storage controls) so that when channels are closed, the funds go to your somwhat-cold storage.

I also doubt that any custodial service would want to mess around with deducting funds from what the user input as the desired payment.  I have not seen a custodial service that does so (this is not a scientific study; I rarely use custodial services); custodial services will deduct more from your balance than what you send, but will not modify what you send, and will prevent you from sending more than your balance minus the fees they charge for sending onchain.

Even today, custodial services deducting from your sent value (rather than the balance remaining after you send) would be problematic when interacting with merchants (or their payment processors) accepting onchain payments; the merchant would refuse to service a lower value than what it charges and it may be very technically difficult to recover such funds from the merchant.
I expect such a custodial service would quickly lose users, but the world surprises me often.

Regards,
ZmnSCPxj

From jl2012 at xbt.hk  Sat Dec 22 16:56:29 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Sun, 23 Dec 2018 00:56:29 +0800
Subject: [bitcoin-dev] Safer NOINPUT with output tagging
In-Reply-To: <KFCfNAmHhRvsDJs70UW3l4ssqBtdBrb8gYP5A3cN2hsTPrXVg7f5Yrt2LOo5V0QdAhhoooc3lllXxiiXSVt_28obYBl_XKAgEQkGg1kOj8I=@protonmail.com>
References: <9F8C0789-48E9-448A-A239-DB4AFB902A00@xbt.hk>
	<8z5NQkaOUo9z-wdBphQtZrxIf7OCtVQFvK3neMWvcRsngld5XJs-vt7CLuY46ZOp_pX8gEd92pMdkEkp8CUOMH9lUTw5ocWsbDPiaKdSa2I=@protonmail.com>
	<34B38940-524D-42B9-8A67-6A62DCE04665@xbt.hk>
	<KFCfNAmHhRvsDJs70UW3l4ssqBtdBrb8gYP5A3cN2hsTPrXVg7f5Yrt2LOo5V0QdAhhoooc3lllXxiiXSVt_28obYBl_XKAgEQkGg1kOj8I=@protonmail.com>
Message-ID: <CAABEECD-2B12-4852-A440-58809EB6BF56@xbt.hk>



> On 22 Dec 2018, at 10:25 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
> 
> Good morning Johnson,
> 
>> Generally speaking, I think walletless protocol is needed only when you want to rely a third party to open a offchain smart contract. It could be coinswap, eltoo, or anything similar.
> 
> I think a third party would be pointless in general, but then I am strongly against custodiality.
> 
> The idea is that you have some kind of hardware wallet or similar "somewhat cold" storage *that you control yourself*, and crate channels for your hot offchain Lightning wallet, without adding more transactions from your somewhat-cold storage to your hot offchain Lightning wallet on the blockchain.
> 
> Then you could feed a set of addresses to the hot offchain wallet (addresses your somewhat-cold storage controls) so that when channels are closed, the funds go to your somwhat-cold storage.
> 
> I also doubt that any custodial service would want to mess around with deducting funds from what the user input as the desired payment.  I have not seen a custodial service that does so (this is not a scientific study; I rarely use custodial services); custodial services will deduct more from your balance than what you send, but will not modify what you send, and will prevent you from sending more than your balance minus the fees they charge for sending onchain.
> 
> Even today, custodial services deducting from your sent value (rather than the balance remaining after you send) would be problematic when interacting with merchants (or their payment processors) accepting onchain payments; the merchant would refuse to service a lower value than what it charges and it may be very technically difficult to recover such funds from the merchant.
> I expect such a custodial service would quickly lose users, but the world surprises me often.
> 
> Regards,
> ZmnSCPxj


If the users are expected to manually operate a hardware wallet to fund the channel, they might do stupid things like using 2 wallets to make 2 txs, thinking that they could combine the values this way; or ?refilling? the offchain wallet with the address, as you suggested. While I appreciate the goal to separate the coin-selecting wallet with the offchain wallet, I am not sure if we should rely on users to do critical steps like entering the right value or not reusing the address. Especially, the setup address should be hidden from user?s view, so only a very few ?intelligent advanced users" could try to refill the channel.

If we don?t rely on the user as the bridge between the hardware wallet and the offchain wallet, we need a communication protocol between them. With such protocol, there is no need to spend the setup TXO with NOINPUT.

From aj at erisian.com.au  Sun Dec 23 04:26:59 2018
From: aj at erisian.com.au (Anthony Towns)
Date: Sun, 23 Dec 2018 14:26:59 +1000
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <73F32BC6-751E-4F35-BE6D-B31170FC0A54@xbt.hk>
References: <87ftv3xerx.fsf@rustcorp.com.au>
	<DAAB7568-A004-4897-B5B3-0FBBC6895246@xbt.hk>
	<87pnu6s3v5.fsf@rustcorp.com.au> <87h8fiqn1z.fsf@rustcorp.com.au>
	<20181214093002.p2nvfrlaycqblww3@erisian.com.au>
	<F9FE2267-0BCB-4C67-9AE8-3285B7459D51@xbt.hk>
	<87mup4hmq5.fsf@rustcorp.com.au>
	<2302A26C-FB9C-47D2-AF6C-4D2EF02FFAC0@xbt.hk>
	<87y38jn5z8.fsf@rustcorp.com.au>
	<73F32BC6-751E-4F35-BE6D-B31170FC0A54@xbt.hk>
Message-ID: <20181223042659.munrqfe4l6nff2ug@erisian.com.au>

On Sat, Dec 22, 2018 at 02:54:42AM +0800, Johnson Lau wrote:
> The question I would like to ask is: is OP_CODESEPARATOR useful under taproot? Generally speaking, CODESEPARATOR is useful only with conditional opcodes (OP_IF etc), and conditional opcodes are mostly replaced by merklized scripts. I am not sure how much usability is left with CODESEPARATOR

If you don't have conditionals, then I think committing to the (masked)
script gives you everything you could do with codeseparator.

If you don't commit to the (masked) script, don't have conditionals,
and don't have codeseparator, then I don't think you can make a signature
distinguish which alternative script it's intending to sign; but you can
just give each alternative script in the MAST a slight variation of the
key and that seems good enough.

OTOH, I think for (roughly) the example you gave:

  DEPTH 3 EQUAL
  IF <Bob> CHECKSIGVERIFY HASH160 <H> EQUALVERIFY CODESEP
  ELSE <n> CLTV DROP
  ENDIF
  <Alice> CHECKSIG

then compared to the taproot equivalent:

  P = muSig(Alice,Bob)
  S1 = <Alice1> CHECKSIGVERIFY <Bob> CHECKSIGVERIFY HASH160 <H> EQUAL
  S2 = <Alice2> CHECKSIGVERIFY <n> CLTV

the IF+CODESEP approach is actually cheaper (lighter weight) if you're
mostly (>2/3rds of the time) taking the S1 branch. This is because the
"DEPTH 3 EQUAL IF/ELSE/ENDIF CODESEP <n> CLTV DROP" overhead is less
than the 32B overhead to choose a merkle branch).

(That said, I'm not sure what Alice's signature in the S1 branch actually
achieves in that script; and without that in S1, the taproot approach is
cheaper all the time. Scriptless scripts would be cheaper still)

> If no one needs CODESEPARATOR, we might just disable it, and makes the validation code a bit simpler

Since it only affects the behaviour of the checkdls (checksig) operators,
even if it was disabled, it could be re-enabled fairly easily in a new
script subversion if needed (ie, it could be re-added when upgrading
witness version 1 from script version 0 to 1).

Cheers,
aj


From jl2012 at xbt.hk  Sun Dec 23 16:33:48 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Mon, 24 Dec 2018 00:33:48 +0800
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <20181223042659.munrqfe4l6nff2ug@erisian.com.au>
References: <87ftv3xerx.fsf@rustcorp.com.au>
	<DAAB7568-A004-4897-B5B3-0FBBC6895246@xbt.hk>
	<87pnu6s3v5.fsf@rustcorp.com.au> <87h8fiqn1z.fsf@rustcorp.com.au>
	<20181214093002.p2nvfrlaycqblww3@erisian.com.au>
	<F9FE2267-0BCB-4C67-9AE8-3285B7459D51@xbt.hk>
	<87mup4hmq5.fsf@rustcorp.com.au>
	<2302A26C-FB9C-47D2-AF6C-4D2EF02FFAC0@xbt.hk>
	<87y38jn5z8.fsf@rustcorp.com.au>
	<73F32BC6-751E-4F35-BE6D-B31170FC0A54@xbt.hk>
	<20181223042659.munrqfe4l6nff2ug@erisian.com.au>
Message-ID: <F445FD1D-52E2-41E4-8FBD-3419A6317CF6@xbt.hk>



> On 23 Dec 2018, at 12:26 PM, Anthony Towns <aj at erisian.com.au> wrote:
> 
> On Sat, Dec 22, 2018 at 02:54:42AM +0800, Johnson Lau wrote:
>> The question I would like to ask is: is OP_CODESEPARATOR useful under taproot? Generally speaking, CODESEPARATOR is useful only with conditional opcodes (OP_IF etc), and conditional opcodes are mostly replaced by merklized scripts. I am not sure how much usability is left with CODESEPARATOR
> 
> If you don't have conditionals, then I think committing to the (masked)
> script gives you everything you could do with codeseparator.

I don?t think CODESEPARATOR is useful without conditionals. By useful I mean making a script more compact

> 
> If you don't commit to the (masked) script, don't have conditionals,
> and don't have codeseparator, then I don't think you can make a signature
> distinguish which alternative script it's intending to sign; but you can
> just give each alternative script in the MAST a slight variation of the
> key and that seems good enough.

You can and should always use a different in different branch. If this best practice is always followed, committing to masked script is not necessary

> 
> OTOH, I think for (roughly) the example you gave:
> 
>  DEPTH 3 EQUAL
>  IF <Bob> CHECKSIGVERIFY HASH160 <H> EQUALVERIFY CODESEP
>  ELSE <n> CLTV DROP
>  ENDIF
>  <Alice> CHECKSIG
> 
> then compared to the taproot equivalent:
> 
>  P = muSig(Alice,Bob)
>  S1 = <Alice1> CHECKSIGVERIFY <Bob> CHECKSIGVERIFY HASH160 <H> EQUAL
>  S2 = <Alice2> CHECKSIGVERIFY <n> CLTV
> 
> the IF+CODESEP approach is actually cheaper (lighter weight) if you're
> mostly (>2/3rds of the time) taking the S1 branch. This is because the
> "DEPTH 3 EQUAL IF/ELSE/ENDIF CODESEP <n> CLTV DROP" overhead is less
> than the 32B overhead to choose a merkle branch).
> 
> (That said, I'm not sure what Alice's signature in the S1 branch actually
> achieves in that script; and without that in S1, the taproot approach is
> cheaper all the time. Scriptless scripts would be cheaper still)
> 
>> If no one needs CODESEPARATOR, we might just disable it, and makes the validation code a bit simpler
> 
> Since it only affects the behaviour of the checkdls (checksig) operators,
> even if it was disabled, it could be re-enabled fairly easily in a new
> script subversion if needed (ie, it could be re-added when upgrading
> witness version 1 from script version 0 to 1).
> 
> Cheers,
> aj
> 

Yes, I don?t think it needs Alice signature in S1 at all. So the original example doesn?t even need CODESEPARATOR at all. 

Could anyone propose a better use case of CODESEPARATOR?



From stick at satoshilabs.com  Sun Dec 23 18:46:12 2018
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Sun, 23 Dec 2018 19:46:12 +0100
Subject: [bitcoin-dev] BIP39 seeds
In-Reply-To: <68330522-7e7c-c3b4-99a9-1c68ddb56f23@gmail.com>
References: <68330522-7e7c-c3b4-99a9-1c68ddb56f23@gmail.com>
Message-ID: <f2d73a92-e1c5-9072-e255-fa012a9f9d1b@satoshilabs.com>

On 22/12/2018 00:58, Aymeric Vitte via bitcoin-dev wrote:
> Has anybody already looked at this: given N randomly chosen words
> belonging to a BIP39 2048 words dictionary, what is the probability to
> get a "valid" BIP39 seed (ie with the right checksum)?

1:256 for 24 words
1:16 for 12 words

This ratio is not too great and will be improved in the upcoming SLIP39
standard: https://github.com/satoshilabs/slips/blob/master/slip-0039.md

-- 
Best Regards / S pozdravom,

Pavol "stick" Rusnak
CTO, SatoshiLabs

From escrivner at coinbase.com  Sun Dec 23 20:55:31 2018
From: escrivner at coinbase.com (Eric Scrivner)
Date: Sun, 23 Dec 2018 13:55:31 -0700
Subject: [bitcoin-dev] BIP39 seeds
In-Reply-To: <68330522-7e7c-c3b4-99a9-1c68ddb56f23@gmail.com>
References: <68330522-7e7c-c3b4-99a9-1c68ddb56f23@gmail.com>
Message-ID: <CAFTQ-6HgdQbFyU+THpNA-WTc0kQCF40tO9=uC4iWYNO+ee5hQQ@mail.gmail.com>

Quite interesting. Not familiar with prior art here, but would be
interested in what your results are showing if you?re willing to share?

On Sun, Dec 23, 2018 at 11:44 Aymeric Vitte via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Has anybody already looked at this: given N randomly chosen words
> belonging to a BIP39 2048 words dictionary, what is the probability to
> get a "valid" BIP39 seed (ie with the right checksum)?
>
> The result looks (very) surprising to me and might have some use cases,
> just would like to know if this topic has already been discussed before
> going further
>
> --
> Move your coins by yourself (browser version): https://peersm.com/wallet
> Bitcoin transactions made simple:
> https://github.com/Ayms/bitcoin-transactions
> Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
> Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
> Get the torrent dynamic blocklist: http://peersm.com/getblocklist
> Check the 10 M passwords list: http://peersm.com/findmyass
> Anti-spies and private torrents, dynamic blocklist:
> http://torrent-live.org
> Peersm : http://www.peersm.com
> torrent-live: https://github.com/Ayms/torrent-live
> node-Tor : https://www.github.com/Ayms/node-Tor
> GitHub : https://www.github.com/Ayms
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-- 
Eric Scrivner
Remote Software Engineer
M: (760) 617-5067
Coinbase
<https://www.google.com/url?q=https%3A%2F%2Fwww.coinbase.com%2F&sa=D&sntz=1&usg=AFrqEzct8dGnZ3Hwf_fvfMFBfoF5ElGMfA>
San Francisco, CA, USA
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181223/9bf930cc/attachment.html>

From jameson.lopp at gmail.com  Sun Dec 23 21:08:13 2018
From: jameson.lopp at gmail.com (Jameson Lopp)
Date: Sun, 23 Dec 2018 16:08:13 -0500
Subject: [bitcoin-dev] BIP39 seeds
In-Reply-To: <68330522-7e7c-c3b4-99a9-1c68ddb56f23@gmail.com>
References: <68330522-7e7c-c3b4-99a9-1c68ddb56f23@gmail.com>
Message-ID: <CADL_X_f08N9uHFN1FBWM4iC=oSWXdLD_WU3EtfhPse7xD5WHpA@mail.gmail.com>

I believe it would depend upon the entropy used for the seed, as that would
affect how many bits the checksum represents.
https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#Generating_the_mnemonic

So for a 24 word / 256 bit mnemonic the checksum is 8 bits, thus there are
8 valid checksums and if you picked a random checksum from the wordlist of
2048 words you'd have a 1 in 256 chance of picking a valid one.

On Sun, Dec 23, 2018 at 1:44 PM Aymeric Vitte via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Has anybody already looked at this: given N randomly chosen words
> belonging to a BIP39 2048 words dictionary, what is the probability to
> get a "valid" BIP39 seed (ie with the right checksum)?
>
> The result looks (very) surprising to me and might have some use cases,
> just would like to know if this topic has already been discussed before
> going further
>
> --
> Move your coins by yourself (browser version): https://peersm.com/wallet
> Bitcoin transactions made simple:
> https://github.com/Ayms/bitcoin-transactions
> Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
> Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
> Get the torrent dynamic blocklist: http://peersm.com/getblocklist
> Check the 10 M passwords list: http://peersm.com/findmyass
> Anti-spies and private torrents, dynamic blocklist:
> http://torrent-live.org
> Peersm : http://www.peersm.com
> torrent-live: https://github.com/Ayms/torrent-live
> node-Tor : https://www.github.com/Ayms/node-Tor
> GitHub : https://www.github.com/Ayms
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181223/1e291f73/attachment.html>

From vitteaymeric at gmail.com  Sun Dec 23 22:41:00 2018
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Sun, 23 Dec 2018 23:41:00 +0100
Subject: [bitcoin-dev] BIP39 seeds
In-Reply-To: <f2d73a92-e1c5-9072-e255-fa012a9f9d1b@satoshilabs.com>
References: <68330522-7e7c-c3b4-99a9-1c68ddb56f23@gmail.com>
	<f2d73a92-e1c5-9072-e255-fa012a9f9d1b@satoshilabs.com>
Message-ID: <db184306-7ec0-322e-5637-7889b51f50bf@gmail.com>

Exactly

This is surprising, I would have expected the probabilities to be much
more lower

It just means that scanning whatever (secret) book, document, link, etc,
you will find easily BIP39 seeds, even of 24 words

So, it just means that you don't have to write your seed since you can
recover it that way, given a secret source and specific algo with custom
parameters, this could be used for plausible deniability also

For now I still dislike BIP39 and alike (because I don't see very well
why it's easier to write n words that you cannot choose rather than a
32B BIP32 hex seed, and I have seen many people completely lost with
their wallets because of this), but I could change my mind, and despite
of further improvements for this ratio, could what I am suggesting make
sense?

Le 23/12/2018 ? 19:46, Pavol Rusnak a ?crit?:
> On 22/12/2018 00:58, Aymeric Vitte via bitcoin-dev wrote:
>> Has anybody already looked at this: given N randomly chosen words
>> belonging to a BIP39 2048 words dictionary, what is the probability to
>> get a "valid" BIP39 seed (ie with the right checksum)?
> 1:256 for 24 words
> 1:16 for 12 words
>
> This ratio is not too great and will be improved in the upcoming SLIP39
> standard: https://github.com/satoshilabs/slips/blob/master/slip-0039.md
>

From ZmnSCPxj at protonmail.com  Mon Dec 24 11:47:38 2018
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 24 Dec 2018 11:47:38 +0000
Subject: [bitcoin-dev] Safer NOINPUT with output tagging
In-Reply-To: <CAABEECD-2B12-4852-A440-58809EB6BF56@xbt.hk>
References: <9F8C0789-48E9-448A-A239-DB4AFB902A00@xbt.hk>
	<8z5NQkaOUo9z-wdBphQtZrxIf7OCtVQFvK3neMWvcRsngld5XJs-vt7CLuY46ZOp_pX8gEd92pMdkEkp8CUOMH9lUTw5ocWsbDPiaKdSa2I=@protonmail.com>
	<34B38940-524D-42B9-8A67-6A62DCE04665@xbt.hk>
	<KFCfNAmHhRvsDJs70UW3l4ssqBtdBrb8gYP5A3cN2hsTPrXVg7f5Yrt2LOo5V0QdAhhoooc3lllXxiiXSVt_28obYBl_XKAgEQkGg1kOj8I=@protonmail.com>
	<CAABEECD-2B12-4852-A440-58809EB6BF56@xbt.hk>
Message-ID: <B2h-WuZWvKKnCqz_qvciHFHf16SgY_63GAF_Y5KbsiJ_wRRoZMw-LBT6Beob9oYOzm9TMaeewJhZXqvPr7TizXOLBoOsOiKPQDyax4aefGY=@protonmail.com>

Good morning Johnson,

Indeed, manual operation is risky.

However the intent is to reduce the requirements on commodity wallets in order to integrate them into a combined onchain and offchain UI.

A boutique protocol would reduce the number of existing onchain wallets that could be integrated in such UI.


If we could make walletless offchain software in such method, *any* existing wallet with an API to programmatically send arbitrary amount to arbitrary address can be integrated into such UI.
This could include hardware wallets.

Regards,
ZmnSCPxj


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Sunday, December 23, 2018 12:56 AM, Johnson Lau <jl2012 at xbt.hk> wrote:

> > On 22 Dec 2018, at 10:25 PM, ZmnSCPxj ZmnSCPxj at protonmail.com wrote:
> > Good morning Johnson,
> >
> > > Generally speaking, I think walletless protocol is needed only when you want to rely a third party to open a offchain smart contract. It could be coinswap, eltoo, or anything similar.
> >
> > I think a third party would be pointless in general, but then I am strongly against custodiality.
> > The idea is that you have some kind of hardware wallet or similar "somewhat cold" storage that you control yourself, and crate channels for your hot offchain Lightning wallet, without adding more transactions from your somewhat-cold storage to your hot offchain Lightning wallet on the blockchain.
> > Then you could feed a set of addresses to the hot offchain wallet (addresses your somewhat-cold storage controls) so that when channels are closed, the funds go to your somwhat-cold storage.
> > I also doubt that any custodial service would want to mess around with deducting funds from what the user input as the desired payment. I have not seen a custodial service that does so (this is not a scientific study; I rarely use custodial services); custodial services will deduct more from your balance than what you send, but will not modify what you send, and will prevent you from sending more than your balance minus the fees they charge for sending onchain.
> > Even today, custodial services deducting from your sent value (rather than the balance remaining after you send) would be problematic when interacting with merchants (or their payment processors) accepting onchain payments; the merchant would refuse to service a lower value than what it charges and it may be very technically difficult to recover such funds from the merchant.
> > I expect such a custodial service would quickly lose users, but the world surprises me often.
> > Regards,
> > ZmnSCPxj
>
> If the users are expected to manually operate a hardware wallet to fund the channel, they might do stupid things like using 2 wallets to make 2 txs, thinking that they could combine the values this way; or ?refilling? the offchain wallet with the address, as you suggested. While I appreciate the goal to separate the coin-selecting wallet with the offchain wallet, I am not sure if we should rely on users to do critical steps like entering the right value or not reusing the address. Especially, the setup address should be hidden from user?s view, so only a very few ?intelligent advanced users" could try to refill the channel.
>
> If we don?t rely on the user as the bridge between the hardware wallet and the offchain wallet, we need a communication protocol between them. With such protocol, there is no need to spend the setup TXO with NOINPUT.



From ZmnSCPxj at protonmail.com  Mon Dec 24 12:01:58 2018
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 24 Dec 2018 12:01:58 +0000
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <F445FD1D-52E2-41E4-8FBD-3419A6317CF6@xbt.hk>
References: <87ftv3xerx.fsf@rustcorp.com.au>
	<20181214093002.p2nvfrlaycqblww3@erisian.com.au>
	<F9FE2267-0BCB-4C67-9AE8-3285B7459D51@xbt.hk>
	<87mup4hmq5.fsf@rustcorp.com.au>
	<2302A26C-FB9C-47D2-AF6C-4D2EF02FFAC0@xbt.hk>
	<87y38jn5z8.fsf@rustcorp.com.au>
	<73F32BC6-751E-4F35-BE6D-B31170FC0A54@xbt.hk>
	<20181223042659.munrqfe4l6nff2ug@erisian.com.au>
	<F445FD1D-52E2-41E4-8FBD-3419A6317CF6@xbt.hk>
Message-ID: <_gOQU8sPtEG5jisR7GskWPyvzLK1xixz8-v1YbRWlAXFq9YGPyMEj9Q-xZ6CYfwgiGeJR2Qlboq4UFU_y6pur1HBG_yRTIgngWqiENmJ1Bc=@protonmail.com>

Good morning,

> Could anyone propose a better use case of CODESEPARATOR?

Long ago, aj sent an email on Lightning-dev about use of CODESEPARATOR to impose Scriptless Script even without Schnorr. It involved 3 signatures with different CODESEPARATOR places, and forced R reuse so that the signatures to claim the funds revealed the privkey.

The script shown had all CODESEPARATOR in a single branch.

I cannot claim to understand the script, and am having difficulty digging through the mailinglist

Regards,
ZmnSCPxj

From tiago at posteo.de  Mon Dec 24 14:58:43 2018
From: tiago at posteo.de (Tiago Romagnani Silveira)
Date: Mon, 24 Dec 2018 15:58:43 +0100
Subject: [bitcoin-dev] BIP39 seeds
In-Reply-To: <f2d73a92-e1c5-9072-e255-fa012a9f9d1b@satoshilabs.com>
References: <68330522-7e7c-c3b4-99a9-1c68ddb56f23@gmail.com>
	<f2d73a92-e1c5-9072-e255-fa012a9f9d1b@satoshilabs.com>
Message-ID: <3db3dc04-6612-8c5c-8b37-316eb804e1f7@posteo.de>

Why is this a SLIP and not a BIP?
Will it require a BIP39 seed, or will work with any seed format?


On 12/23/18 19:46, Pavol Rusnak via bitcoin-dev wrote:
> On 22/12/2018 00:58, Aymeric Vitte via bitcoin-dev wrote:
>> Has anybody already looked at this: given N randomly chosen words
>> belonging to a BIP39 2048 words dictionary, what is the probability to
>> get a "valid" BIP39 seed (ie with the right checksum)?
> 1:256 for 24 words
> 1:16 for 12 words
>
> This ratio is not too great and will be improved in the upcoming SLIP39
> standard: https://github.com/satoshilabs/slips/blob/master/slip-0039.md
>


From jl2012 at xbt.hk  Mon Dec 24 21:23:44 2018
From: jl2012 at xbt.hk (Johnson Lau)
Date: Tue, 25 Dec 2018 05:23:44 +0800
Subject: [bitcoin-dev] Safer sighashes and more granular SIGHASH_NOINPUT
In-Reply-To: <_gOQU8sPtEG5jisR7GskWPyvzLK1xixz8-v1YbRWlAXFq9YGPyMEj9Q-xZ6CYfwgiGeJR2Qlboq4UFU_y6pur1HBG_yRTIgngWqiENmJ1Bc=@protonmail.com>
References: <87ftv3xerx.fsf@rustcorp.com.au>
	<20181214093002.p2nvfrlaycqblww3@erisian.com.au>
	<F9FE2267-0BCB-4C67-9AE8-3285B7459D51@xbt.hk>
	<87mup4hmq5.fsf@rustcorp.com.au>
	<2302A26C-FB9C-47D2-AF6C-4D2EF02FFAC0@xbt.hk>
	<87y38jn5z8.fsf@rustcorp.com.au>
	<73F32BC6-751E-4F35-BE6D-B31170FC0A54@xbt.hk>
	<20181223042659.munrqfe4l6nff2ug@erisian.com.au>
	<F445FD1D-52E2-41E4-8FBD-3419A6317CF6@xbt.hk>
	<_gOQU8sPtEG5jisR7GskWPyvzLK1xixz8-v1YbRWlAXFq9YGPyMEj9Q-xZ6CYfwgiGeJR2Qlboq4UFU_y6pur1HBG_yRTIgngWqiENmJ1Bc=@protonmail.com>
Message-ID: <4CE7B999-F1C3-4E7F-BCED-E02C5D0BE4BB@xbt.hk>

I find another proposed use of CODESEPARATOR here: https://lists.linuxfoundation.org/pipermail/lightning-dev/2016-March/000455.html <https://lists.linuxfoundation.org/pipermail/lightning-dev/2016-March/000455.html>

<KeyA> OP_CHECKSIG
OP_IF
<KeyB>
OP_ELSE
<Delay> OP_CSV OP_DROP
OP_CODESEPARATOR <KeyA>
OP_ENDIF
OP_CHECKSIG
It is actually 2 scripts:

S1: <KeyA> OP_CHECKSIGVERIFY <KeyB> OP_CHECKSIG
S2: <Delay> OP_CSV OP_DROP <KeyA> OP_CHECKSIG

Under taproot, we could make Q = P + H(P||S2)G, where P = MuSig(KeyA, KeyB)

S1 becomes a direct spending with Q, and there is no need to use OP_IF or CODESEPARATOR in S2 at all.


==================

If it is only to force R reuse, there is no need to use CODESEPARATOR:

Input: <R> <S2>  <S1>  Script: 2DUP EQUAL NOT VERIFY 2 PICK SWAP CAT <key> DUP TOALTSTACK CHECKSIGVERIFY CAT FROMALTSTACK CHECKSIG

But using CODESEPARATOR will save 3 bytes
Input: <S2> <R> <S1>    Script:  OVER SWAP CAT <key> DUP TOALTSTACK CHECKSIGVERIFY CODESEPARATOR SWAP CAT FROMALTSTACK CHECKSIG

However, a much better way would be:

Input: <S> Script: <known R> SWAP CAT <key> CHECKSIG

The discrete log of R could be a shared secret between A and B. If the purpose is to publish the private key to the whole world, R = G could be used.

> On 24 Dec 2018, at 8:01 PM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
> 
> Good morning,
> 
>> Could anyone propose a better use case of CODESEPARATOR?
> 
> Long ago, aj sent an email on Lightning-dev about use of CODESEPARATOR to impose Scriptless Script even without Schnorr. It involved 3 signatures with different CODESEPARATOR places, and forced R reuse so that the signatures to claim the funds revealed the privkey.
> 
> The script shown had all CODESEPARATOR in a single branch.
> 
> I cannot claim to understand the script, and am having difficulty digging through the mailinglist
> 
> Regards,
> ZmnSCPxj

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181225/2bf63818/attachment-0001.html>

From macwhyte at gmail.com  Tue Dec 25 00:30:26 2018
From: macwhyte at gmail.com (James MacWhyte)
Date: Tue, 25 Dec 2018 00:30:26 +0000
Subject: [bitcoin-dev] BIP39 seeds
In-Reply-To: <db184306-7ec0-322e-5637-7889b51f50bf@gmail.com>
References: <68330522-7e7c-c3b4-99a9-1c68ddb56f23@gmail.com>
	<f2d73a92-e1c5-9072-e255-fa012a9f9d1b@satoshilabs.com>
	<db184306-7ec0-322e-5637-7889b51f50bf@gmail.com>
Message-ID: <CAH+Axy6dKDOkE6cQYZUusTUxxOSwWchOWxYh6ZkhnOgXuELaYg@mail.gmail.com>

On Mon, Dec 24, 2018 at 2:48 PM Aymeric Vitte via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> I don't see very well why it's easier to write n words that you cannot
> choose rather than a 32B BIP32 hex seed, and I have seen many people
> completely lost with their wallets because of this
>

In practice it has quite a few qualities that make it a bit more resilient
for physical (written) storage.

If a few letters of a word get rubbed off or otherwise become illegible, it
is pretty easy for a native speaker to figure out what the word is supposed
to be. Even a non-native speaker could look through the word list and
figure out which word fits. Missing characters in a hex string require more
advanced brute force searching, which the average user isn't capable of.

Additionally, having the bits grouped into words makes a more serious
recovery easier. If you lose one entire word, it can be brute forced in
about 5 minutes on a normal pc, even if you don't know which position the
missing word is in (I have published a tool that does just this:
https://jmacwhyte.github.io/recovery-phrase-recovery). If you are missing
two words, you can brute force it in about a week (napkin math).

If you were missing a random chunk of a hex string, I don't know how you'd
go about brute forcing that in a timely manner.

As an aside, from a UX standpoint we've seen that the 12 words don't *look*
important so people don't take them seriously (and they get lost). A hex
string or equivalent would look more password-y, and therefore would most
likely be better protected by users.

James
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181225/81287f18/attachment.html>

From laanwj at gmail.com  Tue Dec 25 09:27:42 2018
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Tue, 25 Dec 2018 10:27:42 +0100
Subject: [bitcoin-dev] Bitcoin Core 0.17.1 released
Message-ID: <20181225092742.albj7cf3suxw4hyj@aurora.visucore.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Bitcoin Core version 0.17.1 is now available from:

  <https://bitcoincore.org/bin/bitcoin-core-0.17.1/>

or through BitTorrent:

    magnet:?xt=urn:btih:c56c87ccfaa8e6fbccc90d549121e61efd97cb6f&dn=bitcoin-core-0.17.1&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969&tr=udp%3A%2F%2Fzer0day.ch%3A1337&tr=udp%3A%2F%2Fexplodie.org%3A6969    

This is a new minor version release, with various bugfixes
and performance improvements, as well as updated translations.

Please report bugs using the issue tracker at GitHub:

  <https://github.com/bitcoin/bitcoin/issues>

To receive security and update notifications, please subscribe to:

  <https://bitcoincore.org/en/list/announcements/join/>

How to Upgrade
==============

If you are running an older version, shut it down. Wait until it has completely
shut down (which might take a few minutes for older versions), then run the
installer (on Windows) or just copy over `/Applications/Bitcoin-Qt` (on Mac)
or `bitcoind`/`bitcoin-qt` (on Linux).

If your node has a txindex, the txindex db will be migrated the first time you run 0.17.0 or newer, which may take up to a few hours. Your node will not be functional until this migration completes.

The first time you run version 0.15.0 or newer, your chainstate database will be converted to a
new format, which will take anywhere from a few minutes to half an hour,
depending on the speed of your machine.

Note that the block database format also changed in version 0.8.0 and there is no
automatic upgrade code from before version 0.8 to version 0.15.0. Upgrading
directly from 0.7.x and earlier without redownloading the blockchain is not supported.
However, as usual, old wallet versions are still supported.

Downgrading warning
- -------------------

The chainstate database for this release is not compatible with previous
releases, so if you run 0.15 and then decide to switch back to any
older version, you will need to run the old release with the `-reindex-chainstate`
option to rebuild the chainstate data structures in the old format.

If your node has pruning enabled, this will entail re-downloading and
processing the entire blockchain.

Compatibility
==============

Bitcoin Core is extensively tested on multiple operating systems using
the Linux kernel, macOS 10.10+, and Windows 7 and newer (Windows XP is not supported).

Bitcoin Core should also work on most other Unix-like systems but is not
frequently tested on them.

- From 0.17.0 onwards macOS <10.10 is no longer supported. 0.17.0 is built using Qt 5.9.x, which doesn't
support versions of macOS older than 10.10.

Notable changes
===============

`listtransactions` label support
- --------------------------------

The `listtransactions` RPC `account` parameter which was deprecated in 0.17.0
and renamed to `dummy` has been un-deprecated and renamed again to `label`.

When bitcoin is configured with the `-deprecatedrpc=accounts` setting, specifying
a label/account/dummy argument will return both outgoing and incoming
transactions. Without the `-deprecatedrpc=accounts` setting, it will only return
incoming transactions (because it used to be possible to create transactions
spending from specific accounts, but this is no longer possible with labels).

When `-deprecatedrpc=accounts` is set, it's possible to pass the empty string ""
to list transactions that don't have any label. Without
`-deprecatedrpc=accounts`, passing the empty string is an error because returning
only non-labeled transactions is not generally useful behavior and can cause
confusion.

0.17.1 change log
=================

### P2P protocol and network code
- - #14685 `9406502` Fix a deserialization overflow edge case (kazcw)
- - #14728 `b901578` Fix uninitialized read when stringifying an addrLocal (kazcw)

### Wallet
- - #14441 `5150acc` Restore ability to list incoming transactions by label (jnewbery)
- - #13546 `91fa15a` Fix use of uninitialized value `bnb_used` in CWallet::CreateTransaction(?) (practicalswift)
- - #14310 `bb90695` Ensure wallet is unlocked before signing (gustavonalle)
- - #14690 `5782fdc` Throw error if CPubKey is invalid during PSBT keypath serialization (instagibbs)
- - #14852 `2528443` backport: [tests] Add `wallet_balance.py` (MarcoFalke)
- - #14196 `3362a95` psbt: always drop the unnecessary utxo and convert non-witness utxo to witness when necessary (achow101)
- - #14588 `70ee1f8` Refactor PSBT signing logic to enforce invariant and fix signing bug (gwillen)
- - #14424 `89a9a9d` Stop requiring imported pubkey to sign non-PKH schemes (sipa, MeshCollider)

### RPC and other APIs
- - #14417 `fb9ad04` Fix listreceivedbyaddress not taking address as a string (etscrivner)
- - #14596 `de5e48a` Bugfix: RPC: Add `address_type` named param for createmultisig (luke-jr)
- - #14618 `9666dba` Make HTTP RPC debug logging more informative (practicalswift)
- - #14197 `7bee414` [psbt] Convert non-witness UTXOs to witness if witness sig created (achow101)
- - #14377 `a3fe125` Check that a separator is found for psbt inputs, outputs, and global map (achow101)
- - #14356 `7a590d8` Fix converttopsbt permitsigdata arg, add basic test (instagibbs)
- - #14453 `75b5d8c` Fix wallet unload during walletpassphrase timeout (promag)

### GUI
- - #14403 `0242b5a` Revert "Force TLS1.0+ for SSL connections" (real-or-random)
- - #14593 `df5131b` Explicitly disable "Dark Mode" appearance on macOS (fanquake)

### Build system
- - #14647 `7edebed` Remove illegal spacing in darwin.mk (ch4ot1c)
- - #14698 `ec71f06` Add bitcoin-tx.exe into Windows installer (ken2812221)

### Tests and QA
- - #13965 `29899ec` Fix extended functional tests fail (ken2812221)
- - #14011 `9461f98` Disable wallet and address book Qt tests on macOS minimal platform (ryanofsky)
- - #14180 `86fadee` Run all tests even if wallet is not compiled (MarcoFalke)
- - #14122 `8bc1bad` Test `rpc_help.py` failed: Check whether ZMQ is enabled or not (Kvaciral)
- - #14101 `96dc936` Use named args in validation acceptance tests (MarcoFalke)
- - #14020 `24d796a` Add tests for RPC help (promag)
- - #14052 `7ff32a6` Add some actual witness in `rpc_rawtransaction` (MarcoFalke)
- - #14215 `b72fbab` Use correct python index slices in example test (sdaftuar)
- - #14024 `06544fa` Add `TestNode::assert_debug_log` (MarcoFalke)
- - #14658 `60f7a97` Add test to ensure node can generate all rpc help texts at runtime (MarcoFalke)
- - #14632 `96f15e8` Fix a comment (fridokus)
- - #14700 `f9db08e` Avoid race in `p2p_invalid_block` by waiting for the block request (MarcoFalke)
- - #14845 `67225e2` Add `wallet_balance.py` (jnewbery)

### Documentation
- - #14161 `5f51fd6` doc/descriptors.md tweaks (ryanofsky)
- - #14276 `85aacc4` Add autogen.sh in ARM Cross-compilation (walterwhite81)

Credits
=======

Thanks to everyone who directly contributed to this release:

- - Andrew Chow
- - Chun Kuan Lee
- - David A. Harding
- - Eric Scrivner
- - fanquake
- - fridokus
- - Glenn Willen
- - Gregory Sanders
- - gustavonalle
- - John Newbery
- - Jon Layton
- - Jonas Schnelli
- - Jo?o Barbosa
- - Kaz Wesley
- - Kvaciral
- - Luke Dashjr
- - MarcoFalke
- - MeshCollider
- - Pieter Wuille
- - practicalswift
- - Russell Yanofsky
- - Sjors Provoost
- - Suhas Daftuar
- - Tim Ruffing
- - Walter
- - Wladimir J. van der Laan

As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).
-----BEGIN PGP SIGNATURE-----

iQEzBAEBCgAdFiEEnerg3HBjJJ+wVHRoHkrtYphs0l0FAlwh9x0ACgkQHkrtYphs
0l1yqQf/WzqxJkIrzyO9ZRaLKjaaxVz8E7jqHsyA+4mdObsSPjneGfKh7OEC2Fhx
VV7EF+A5kNFQgwnPwXlW3AaiuDhcGHEG4T0AB0JGaggLD6KrjpzuWHYx5k0COwdG
5sYRH4tZxbtWoF1+IQ1R8Ceac20VBqBUBJJfAAntg4VrGaBjDqFJzf+0GmQM0gyW
tq12nMIwevHWXsmtrQWhAbCeLI8pyhGLOtLqCgrrD5hqe72iV7t6Njs5E+kRkEM1
Um6a3nc7LTUMXufTwBf6Sie6azubybvI2/G2HvYEn7DKpLAXiihyO8iiheAi6g4U
JtAgFUiyIvmeLh8etboF3pLy/Q8F5A==
=LFNX
-----END PGP SIGNATURE-----


From vitteaymeric at gmail.com  Wed Dec 26 11:33:27 2018
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Wed, 26 Dec 2018 12:33:27 +0100
Subject: [bitcoin-dev] BIP39 seeds
In-Reply-To: <CAH+Axy6dKDOkE6cQYZUusTUxxOSwWchOWxYh6ZkhnOgXuELaYg@mail.gmail.com>
References: <68330522-7e7c-c3b4-99a9-1c68ddb56f23@gmail.com>
	<f2d73a92-e1c5-9072-e255-fa012a9f9d1b@satoshilabs.com>
	<db184306-7ec0-322e-5637-7889b51f50bf@gmail.com>
	<CAH+Axy6dKDOkE6cQYZUusTUxxOSwWchOWxYh6ZkhnOgXuELaYg@mail.gmail.com>
Message-ID: <743fb106-977e-1f34-47af-9fb3b8621e72@gmail.com>

Another drawback I think is that people are not using it as seeds, they
just go to a wallet sw which proposes a new seed, write it somewhere, do
something with the wallet and forget about it, go to another one, create
another wallet, etc

Apparently it is not very well known even here that the probabilities
are very high to get a valid BIP39 seed even with 24 words, so, even
with a tool like yours, they can be misleaded, for example trying a few
words to replace the missing/incorrect one, get a valid seed and stay
stuck with it forever trying to play with BIP44/49 to find their keys

Probably what I am suggesting is not new (and therefore maybe not a good
suggestion): given a secret seed (a book, a document, a link, etc) and a
derivation path (an algo with secret parameter(s) to derive/order the
words and select the valid bip39 sequences), you get your BIP39 seeds
and don't have to write them

Of course we don't have to use necessarilly BIP39 for this but this is
what we have everywhere and this is what is compatible with it, then you
could use the same or a fake written "not very well hidden" BIP39 seed
to plausibly deny your real wallet

Le 25/12/2018 ? 01:30, James MacWhyte a ?crit?:
>
>
> On Mon, Dec 24, 2018 at 2:48 PM Aymeric Vitte via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org
> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>
>
>     I don't see very well why it's easier to write n words that you
>     cannot choose rather than a 32B BIP32 hex seed, and I have seen
>     many people completely lost with their wallets because of this
>
>
> In practice it has quite a few qualities that make it a bit more
> resilient for physical (written) storage.
>
> If a few letters of a word get rubbed off or otherwise become
> illegible, it is pretty easy for a native speaker to figure out what
> the word is supposed to be. Even a non-native speaker could look
> through the word list and figure out which word fits. Missing
> characters in a hex string require more advanced brute force
> searching, which the average user isn't capable of.
>
> Additionally, having the bits grouped into words makes a more serious
> recovery easier. If you lose one entire word, it can be brute forced
> in about 5 minutes on a normal pc, even if you don't know which
> position the missing word is in (I have published a tool that does
> just this:?https://jmacwhyte.github.io/recovery-phrase-recovery). If
> you are missing two words, you can brute force it in about a week
> (napkin math).
>
> If you were missing a random chunk of a hex string, I don't know how
> you'd go about brute forcing that in a timely manner.
>
> As an aside, from a UX standpoint we've seen that the 12 words don't
> *look* important so people don't take them seriously (and they get
> lost). A hex string or equivalent would look more password-y, and
> therefore would most likely be better protected by users.
>
> James

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181226/e047093a/attachment-0001.html>

From macwhyte at gmail.com  Wed Dec 26 18:54:25 2018
From: macwhyte at gmail.com (James MacWhyte)
Date: Wed, 26 Dec 2018 18:54:25 +0000
Subject: [bitcoin-dev] BIP39 seeds
In-Reply-To: <743fb106-977e-1f34-47af-9fb3b8621e72@gmail.com>
References: <68330522-7e7c-c3b4-99a9-1c68ddb56f23@gmail.com>
	<f2d73a92-e1c5-9072-e255-fa012a9f9d1b@satoshilabs.com>
	<db184306-7ec0-322e-5637-7889b51f50bf@gmail.com>
	<CAH+Axy6dKDOkE6cQYZUusTUxxOSwWchOWxYh6ZkhnOgXuELaYg@mail.gmail.com>
	<743fb106-977e-1f34-47af-9fb3b8621e72@gmail.com>
Message-ID: <CAH+Axy7v=26P8=CJPUqymKOcromGz+zYZ2cb2KaASgXNPpE2tQ@mail.gmail.com>

On Wed, Dec 26, 2018 at 11:33 AM Aymeric Vitte <vitteaymeric at gmail.com>
wrote:

> so, even with a tool like yours, they can be misleaded, for example trying
> a few words to replace the missing/incorrect one, get a valid seed and stay
> stuck with it forever trying to play with BIP44/49 to find their keys
>

Just a small detail, but my tool actually looks up all the possible
combinations and then finds which one has been used before by looking for
past transactions on the blockchain. Therefore, it won't tell you your
phrase is correct unless it is a phrase that has actually been used before
(preventing what you described).

Using some algorithm to take some input and generate a bip39 phrase that
you can use with any bip39 wallet sounds perfectly reasonable.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181226/270226c7/attachment-0001.html>

From vitteaymeric at gmail.com  Thu Dec 27 11:04:18 2018
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Thu, 27 Dec 2018 12:04:18 +0100
Subject: [bitcoin-dev] BIP39 seeds
In-Reply-To: <CAH+Axy7v=26P8=CJPUqymKOcromGz+zYZ2cb2KaASgXNPpE2tQ@mail.gmail.com>
References: <68330522-7e7c-c3b4-99a9-1c68ddb56f23@gmail.com>
	<f2d73a92-e1c5-9072-e255-fa012a9f9d1b@satoshilabs.com>
	<db184306-7ec0-322e-5637-7889b51f50bf@gmail.com>
	<CAH+Axy6dKDOkE6cQYZUusTUxxOSwWchOWxYh6ZkhnOgXuELaYg@mail.gmail.com>
	<743fb106-977e-1f34-47af-9fb3b8621e72@gmail.com>
	<CAH+Axy7v=26P8=CJPUqymKOcromGz+zYZ2cb2KaASgXNPpE2tQ@mail.gmail.com>
Message-ID: <c91cd61b-3ec5-6c7a-c7e3-7ceb48539625@gmail.com>


Le 26/12/2018 ? 19:54, James MacWhyte a ?crit?:
>
> On Wed, Dec 26, 2018 at 11:33 AM Aymeric Vitte <vitteaymeric at gmail.com
> <mailto:vitteaymeric at gmail.com>> wrote:
>
>     so, even with a tool like yours, they can be misleaded, for
>     example trying a few words to replace the missing/incorrect one,
>     get a valid seed and stay stuck with it forever trying to play
>     with BIP44/49 to find their keys
>
>
> Just a small detail, but my tool actually looks up all the possible
> combinations and then finds which one has been used before by looking
> for past transactions on the blockchain. Therefore, it won't tell you
> your phrase is correct unless it is a phrase that has actually been
> used before (preventing what you described).

I saw that your tool was querying blockchain.info, but it cannot guess
what derivation path was used and if it is a standard one what addresses
were used, and even if successful it works only for bitcoin (so maybe it
should just output the ~1500 possible phrases and/or xprv, and be
completely offline, this is still doable for people)

>
> Using some algorithm to take some input and generate a bip39 phrase
> that you can use with any bip39 wallet sounds perfectly reasonable.

I forgot to mention that this can help also solving the "what if
something happens to me" case giving to the family the seed and the
parameter(s) for the derivation path, or an easy way to find it (better
than something like: remind this passphrase, take the sha256 of it, then
use some other stuff to find the encryption algo, take n bytes of the
hash, use it to decode my wallet or my seed... and then everybody
looking at you like crazy)

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181227/2d00c181/attachment-0001.html>

From tensiam at hotmail.com  Thu Dec 27 20:15:19 2018
From: tensiam at hotmail.com (Kenshiro [])
Date: Thu, 27 Dec 2018 20:15:19 +0000
Subject: [bitcoin-dev] Create a BIP to implement Confidential Transactions
	in Bitcoin Core
Message-ID: <DB6PR10MB1832D53720A629EEDB360838A6B60@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>

Hi,

I think Confidential Transactions (CT) are a great idea to provide enough privacy for normal users (hidden amounts) and fungibility.

I would like to request the creation of a BIP to implement CT in Bitcoin Core. I read that CT are already implemented in Grin and Monero so it looks that CT are enough mature to be implemented in Bitcoin.

If the CT transaction size is 3x the size of a normal transaction the block size could be increased by 3x too, or just keep the current block size and make CT transactions optional.

Thank you!

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181227/06d06157/attachment.html>

From somber.night at protonmail.com  Fri Dec 28 21:41:51 2018
From: somber.night at protonmail.com (SomberNight)
Date: Fri, 28 Dec 2018 21:41:51 +0000
Subject: [bitcoin-dev] Create a BIP to implement Confidential Transactions
	in Bitcoin Core
Message-ID: <3VIFGj5yxFpKlSgjMAlPCuTJOSzYkZI2l7tMwtQq4LStjiXgfS7A61jdZ5ZoyalJmjo71EQtNC_F06JgpQ1m046fWbq_6Nhe3BGkMOU-17I=@protonmail.com>

Hi Kenshiro,

That is not how the BIP process works. Instead of requesting the creation
of a BIP, you just create one. :)

Re CT in Bitcoin, I have my doubts whether you can get consensus for that.
>From section 4.6 of the Bulletproofs paper [0]:

"Bulletproofs ... are computationally binding. An adversary that could
break the discrete logarithm assumption could generate acceptable range
proofs for a value outside the correct range. ... An adversary that can
break the binding property of the commitment scheme or the soundness of
the proof system can generate coins out of thin air and thus create
uncontrolled but undetectable inflation rendering the currency useless"

I don't have the domain knowledge to debate whether quantum computers will
ever exist but AFAICT their emergence would easily kill a currency that
uses these kind of range proofs for confidential transactions.


[0]: https://eprint.iacr.org/2017/1066.pdf


> From: "Kenshiro []" tensiam at hotmail.com
>
> Hi,
>
> I think Confidential Transactions (CT) are a great idea to provide enough privacy for normal users (hidden amounts) and fungibility.
>
> I would like to request the creation of a BIP to implement CT in Bitcoin Core. I read that CT are already implemented in Grin and Monero so it looks that CT are enough mature to be implemented in Bitcoin.
>
> If the CT transaction size is 3x the size of a normal transaction the block size could be increased by 3x too, or just keep the current block size and make CT transactions optional.
>
> Thank you!

From tensiam at hotmail.com  Sat Dec 29 11:56:08 2018
From: tensiam at hotmail.com (Kenshiro [])
Date: Sat, 29 Dec 2018 11:56:08 +0000
Subject: [bitcoin-dev] Create a BIP to implement Confidential
 Transactions in Bitcoin Core
In-Reply-To: <3VIFGj5yxFpKlSgjMAlPCuTJOSzYkZI2l7tMwtQq4LStjiXgfS7A61jdZ5ZoyalJmjo71EQtNC_F06JgpQ1m046fWbq_6Nhe3BGkMOU-17I=@protonmail.com>
References: <3VIFGj5yxFpKlSgjMAlPCuTJOSzYkZI2l7tMwtQq4LStjiXgfS7A61jdZ5ZoyalJmjo71EQtNC_F06JgpQ1m046fWbq_6Nhe3BGkMOU-17I=@protonmail.com>
Message-ID: <DB6PR10MB1832A1A6EB2628CAB0035192A6B00@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>

I understand, thank you! :)


From: SomberNight <somber.night at protonmail.com>
Sent: Friday, December 28, 2018 22:41
To: bitcoin-dev at lists.linuxfoundation.org; tensiam at hotmail.com
Subject: [bitcoin-dev] Create a BIP to implement Confidential Transactions in Bitcoin Core

Hi Kenshiro,

That is not how the BIP process works. Instead of requesting the creation
of a BIP, you just create one. :)

Re CT in Bitcoin, I have my doubts whether you can get consensus for that.
>From section 4.6 of the Bulletproofs paper [0]:

"Bulletproofs ... are computationally binding. An adversary that could
break the discrete logarithm assumption could generate acceptable range
proofs for a value outside the correct range. ... An adversary that can
break the binding property of the commitment scheme or the soundness of
the proof system can generate coins out of thin air and thus create
uncontrolled but undetectable inflation rendering the currency useless"

I don't have the domain knowledge to debate whether quantum computers will
ever exist but AFAICT their emergence would easily kill a currency that
uses these kind of range proofs for confidential transactions.


[0]: https://eprint.iacr.org/2017/1066.pdf


> From: "Kenshiro []" tensiam at hotmail.com
>
> Hi,
>
> I think Confidential Transactions (CT) are a great idea to provide enough privacy for normal users (hidden amounts) and fungibility.
>
> I would like to request the creation of a BIP to implement CT in Bitcoin Core. I read that CT are already implemented in Grin and Monero so it looks that CT are enough mature to be implemented in Bitcoin.
>
> If the CT transaction size is 3x the size of a normal transaction the block size could be increased by 3x too, or just keep the current block size and make CT transactions optional.
>
> Thank you!
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181229/71457bb6/attachment.html>

From thealanevans at gmail.com  Mon Dec 31 16:52:24 2018
From: thealanevans at gmail.com (Alan Evans)
Date: Mon, 31 Dec 2018 12:52:24 -0400
Subject: [bitcoin-dev] BIP39 seeds
In-Reply-To: <c91cd61b-3ec5-6c7a-c7e3-7ceb48539625@gmail.com>
References: <68330522-7e7c-c3b4-99a9-1c68ddb56f23@gmail.com>
	<f2d73a92-e1c5-9072-e255-fa012a9f9d1b@satoshilabs.com>
	<db184306-7ec0-322e-5637-7889b51f50bf@gmail.com>
	<CAH+Axy6dKDOkE6cQYZUusTUxxOSwWchOWxYh6ZkhnOgXuELaYg@mail.gmail.com>
	<743fb106-977e-1f34-47af-9fb3b8621e72@gmail.com>
	<CAH+Axy7v=26P8=CJPUqymKOcromGz+zYZ2cb2KaASgXNPpE2tQ@mail.gmail.com>
	<c91cd61b-3ec5-6c7a-c7e3-7ceb48539625@gmail.com>
Message-ID: <CALPhJawf98+uqZXQRGH3Tjo1CnZJfE+CMw9J2ZqiHHmwDSdugQ@mail.gmail.com>

> Using some algorithm to take some input and generate a bip39 phrase that
you can use with any bip39 wallet sounds perfectly reasonable.

I think any method that doesn't use real entropy, but some fake source of
randomness, such as a book is asking to be hacked and so is not a
reasonable idea.

If an algorithm for book text to BIP39 sentence ever became well used,
common books will be systematically searched for accounts. People will also
choose their favourite passages, so I would expect to see collisions.

You should also note that BIP39 does not need input that is from the word
list. You can use *any text as its input*, the word list and checksum check
is just recommended to be a warning, but again, text chosen from public
sources or common phrases is a bad idea for many reasons.

>From BIP0039:
*> The conversion of the mnemonic sentence to a binary seed is completely
independent from generating the sentence. This results in rather simple
code; there are no constraints on sentence structure and clients are free
to implement their own wordlists or even whole sentence generators,
allowing for flexibility in wordlists for typo detection or other purposes.*
*> Although using a mnemonic not generated by the algorithm described in
"Generating the mnemonic" section is possible, this is not advised and
software must compute a checksum for the mnemonic sentence using a wordlist
and issue a warning if it is invalid.*

What you could do is use a regular true random BIP39 sentence in
conjunction with a phrase from a book as the "passphrase" giving you that
plausible deniability, right up to the point you put that in your will or
tell someone, i.e. for the "what if something happens to me" case. Though I
still think redirecting people to a book phase is risky for this, e.g.
books have editions, there may be a change in the key place.

>From BIP0039:
*> The described method also provides plausible deniability, because every
passphrase generates a valid seed (and thus a deterministic wallet) but
only the correct one will make the desired wallet available.*

Alan

P.S. "I have seen many people completely lost with their wallets because of
[BIP39]": I would say "despite" not "because". These people would have
lost/miss recorded a BIP32 hex seed as well.


On Thu, 27 Dec 2018 at 11:02, Aymeric Vitte via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> Le 26/12/2018 ? 19:54, James MacWhyte a ?crit :
>
>
> On Wed, Dec 26, 2018 at 11:33 AM Aymeric Vitte <vitteaymeric at gmail.com>
> wrote:
>
>> so, even with a tool like yours, they can be misleaded, for example
>> trying a few words to replace the missing/incorrect one, get a valid seed
>> and stay stuck with it forever trying to play with BIP44/49 to find their
>> keys
>>
>
> Just a small detail, but my tool actually looks up all the possible
> combinations and then finds which one has been used before by looking for
> past transactions on the blockchain. Therefore, it won't tell you your
> phrase is correct unless it is a phrase that has actually been used before
> (preventing what you described).
>
> I saw that your tool was querying blockchain.info, but it cannot guess
> what derivation path was used and if it is a standard one what addresses
> were used, and even if successful it works only for bitcoin (so maybe it
> should just output the ~1500 possible phrases and/or xprv, and be
> completely offline, this is still doable for people)
>
>
> Using some algorithm to take some input and generate a bip39 phrase that
> you can use with any bip39 wallet sounds perfectly reasonable.
>
> I forgot to mention that this can help also solving the "what if something
> happens to me" case giving to the family the seed and the parameter(s) for
> the derivation path, or an easy way to find it (better than something like:
> remind this passphrase, take the sha256 of it, then use some other stuff to
> find the encryption algo, take n bytes of the hash, use it to decode my
> wallet or my seed... and then everybody looking at you like crazy)
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20181231/9e7da7d2/attachment-0001.html>

