From pete at petertodd.org  Mon Aug  1 10:30:07 2022
From: pete at petertodd.org (Peter Todd)
Date: Mon, 1 Aug 2022 06:30:07 -0400
Subject: [bitcoin-dev] Regarding setting a lower minrelaytxfee
In-Reply-To: <JMG4yhnQ2xL1Pq51Jnyk37c6-Ip8zHuCjmPWc6AYJ0LxlhO7enV9xdr4YGkGbn_J-ecpueZsB-mIjowyVDyMINme1bXJk4BYYP7lBxR4Kfg=@protonmail.com>
References: <CAGHFe1BXdTkPZn4r_KTxYoz0sqcMsV830dm5JTTFURxDezBnDQ@mail.gmail.com>
 <Yt/h2Jv3m8ZsfZ8v@petertodd.org>
 <f889c7fc9db56ed448237c8a4091abaa@dtrt.org>
 <CAGHFe1C-u7DbTtg0dz+p8Moh=FbFN5dKZow5HgtMpxcVyS2ZdA@mail.gmail.com>
 <JMG4yhnQ2xL1Pq51Jnyk37c6-Ip8zHuCjmPWc6AYJ0LxlhO7enV9xdr4YGkGbn_J-ecpueZsB-mIjowyVDyMINme1bXJk4BYYP7lBxR4Kfg=@protonmail.com>
Message-ID: <YuerLzSvdJ8ZcqrR@petertodd.org>

On Sat, Jul 30, 2022 at 05:24:35PM +0000, alicexbt via bitcoin-dev wrote:
> However, I think developers should not make any changes in the default minimum fee rate required for relay. If there are incentives for users and miners to change it, they should use non-default value. In case, miners want to experiment with lower fee rate and see if this increases revenue they could try using it on odd dates (even dates remain default) for a month. We all could analyze how this worked for different mining pools and non-default value (lower or higher) could become normal in the future.

Without a way for lower-fee-rate transactions to get to those miners,
experiments like that are pointless.

If you want to propose things like this, propose a way to get non-standard txs
to miners, like a hashcash-based alternative broadcast scheme.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220801/1fa155de/attachment.sig>

From alfred_hodler at protonmail.com  Mon Aug  1 11:38:29 2022
From: alfred_hodler at protonmail.com (Alfred Hodler)
Date: Mon, 01 Aug 2022 11:38:29 +0000
Subject: [bitcoin-dev] New BIP: Private Payments
In-Reply-To: <CAPv7TjZHJoY2cN9=X7vxSOEbd-YLQLrFi87e8Yj-xZJUawjRYA@mail.gmail.com>
References: <-BUM-o-GxD7jpYy6cOdoALb-p2xbdEFds3De08nUFseeif6-OS6p_A7u7B_h45rkuflSix9kaC4e9fbOs_YwOL6xbrCF5ebjyGKurT4MeJU=@protonmail.com>
 <CAPv7TjZHJoY2cN9=X7vxSOEbd-YLQLrFi87e8Yj-xZJUawjRYA@mail.gmail.com>
Message-ID: <as1OIZRWFJz8-hXljBG0Y9urM8C9eLBfmM7cEdXQyQyvDDmOyMDM4Tp2-EgvpcgI1ysv1LKT5c7R68WXrhPsq5403AtBk8nMFX3USkxD5l0=@protonmail.com>

Hi Ruben,

I have incorporated your feedback. Using only the first four bytes of the notification code is a very valuable suggestion, so thank you for that. I have added you as a co-author.

In regards to hiding the recipient in the notification, the purpose is not only to allow Alice to send a notification herself, but also to break the link between the notifier (be that Alice or a third-party service) and Bob. Not doing so would reintroduce the same problem we have with BIP47 and unique per-recipient notification addresses -- namely that of social graph building. The tradeoff, as you noticed, is that light clients have to rely on some kind of OP_RETURN indexing service. I personally consider any inconvenience (to developers, as end users never see this) stemming from that to be acceptable because:

1) it reduces the amount of social metadata on the blockchain
2) notification services might otherwise be pressured into censoring certain recipients
3) it allows wallets to decide the level of outsourcing they are comfortable with
4) adversaries monitoring notifications might see a lot of notifications to someone and use that information to mount an attack

Thanks for all the feedback.

Alfred


From aliashraf.btc at protonmail.com  Mon Aug  1 13:19:05 2022
From: aliashraf.btc at protonmail.com (aliashraf.btc At protonmail)
Date: Mon, 01 Aug 2022 13:19:05 +0000
Subject: [bitcoin-dev] Regarding setting a lower minrelaytxfee
In-Reply-To: <YuerLzSvdJ8ZcqrR@petertodd.org>
References: <CAGHFe1BXdTkPZn4r_KTxYoz0sqcMsV830dm5JTTFURxDezBnDQ@mail.gmail.com>
 <Yt/h2Jv3m8ZsfZ8v@petertodd.org> <f889c7fc9db56ed448237c8a4091abaa@dtrt.org>
 <CAGHFe1C-u7DbTtg0dz+p8Moh=FbFN5dKZow5HgtMpxcVyS2ZdA@mail.gmail.com>
 <JMG4yhnQ2xL1Pq51Jnyk37c6-Ip8zHuCjmPWc6AYJ0LxlhO7enV9xdr4YGkGbn_J-ecpueZsB-mIjowyVDyMINme1bXJk4BYYP7lBxR4Kfg=@protonmail.com>
 <YuerLzSvdJ8ZcqrR@petertodd.org>
Message-ID: <bKNhJ_ASFgsOslPnOxW-ps5h2OUbHbVQfOelaLPey8lxezLEuevkua1WpAtVRNPRmCtj0fRAeOSe5OHWYOSafczcBuGzhRDqbVjGctAUdBI=@protonmail.com>

> On Sat, Jul 30, 2022 at 05:24:35PM +0000, alicexbt via bitcoin-dev wrote:
> like a hashcash-based alternative broadcast scheme.
Hi Peter,
I've been mulling the idea of attaching work to low fee txns, both as a compensation (e.g., in a sidechain, or an alt), and/or as a spam proof. Unfortunately, both suffer from ASICs:
For spam proof case, the adversary can easily buy a used/obsolete device to produce lots of spam txns very cheaply, unless you put the bar very high, making it almost impossible for average users to even try.
The compensation scenario is pretty off-topic, still, interesting enough for 1 min read:
Wallets commit to the latest blockchain state in the transaction AND attach work.
It is considered contribution to the security (illegitimate chains can't include the txn), hence isrewarded by fee discount/exemption depending on the offset of the state they've committed to (the closer, the better) and the amount of work attached.
For this to work, block difficulty is calculated inclusive with the work embedded in the txns, it contains. Sophisticated and consequential, yet not infeasible per se.

Unfortunately, this scheme is hard to balance with ASICs in the scene too, for instance, you can't subsidize wallets for their work like with a leverge, because miners can easily do it locally, seizing the subsidies for themselves, long story, not relevant just ignore it.

Cheers, Ali

------- Original Message -------
On Monday, August 1st, 2022 at 3:00 PM, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:


> On Sat, Jul 30, 2022 at 05:24:35PM +0000, alicexbt via bitcoin-dev wrote:
>
> > However, I think developers should not make any changes in the default minimum fee rate required for relay. If there are incentives for users and miners to change it, they should use non-default value. In case, miners want to experiment with lower fee rate and see if this increases revenue they could try using it on odd dates (even dates remain default) for a month. We all could analyze how this worked for different mining pools and non-default value (lower or higher) could become normal in the future.
>
>
> Without a way for lower-fee-rate transactions to get to those miners,
> experiments like that are pointless.
>
> If you want to propose things like this, propose a way to get non-standard txs
> to miners, like a hashcash-based alternative broadcast scheme.
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From pete at petertodd.org  Mon Aug  1 13:37:47 2022
From: pete at petertodd.org (Peter Todd)
Date: Mon, 1 Aug 2022 09:37:47 -0400
Subject: [bitcoin-dev] Regarding setting a lower minrelaytxfee
In-Reply-To: <bKNhJ_ASFgsOslPnOxW-ps5h2OUbHbVQfOelaLPey8lxezLEuevkua1WpAtVRNPRmCtj0fRAeOSe5OHWYOSafczcBuGzhRDqbVjGctAUdBI=@protonmail.com>
References: <CAGHFe1BXdTkPZn4r_KTxYoz0sqcMsV830dm5JTTFURxDezBnDQ@mail.gmail.com>
 <Yt/h2Jv3m8ZsfZ8v@petertodd.org>
 <f889c7fc9db56ed448237c8a4091abaa@dtrt.org>
 <CAGHFe1C-u7DbTtg0dz+p8Moh=FbFN5dKZow5HgtMpxcVyS2ZdA@mail.gmail.com>
 <JMG4yhnQ2xL1Pq51Jnyk37c6-Ip8zHuCjmPWc6AYJ0LxlhO7enV9xdr4YGkGbn_J-ecpueZsB-mIjowyVDyMINme1bXJk4BYYP7lBxR4Kfg=@protonmail.com>
 <YuerLzSvdJ8ZcqrR@petertodd.org>
 <bKNhJ_ASFgsOslPnOxW-ps5h2OUbHbVQfOelaLPey8lxezLEuevkua1WpAtVRNPRmCtj0fRAeOSe5OHWYOSafczcBuGzhRDqbVjGctAUdBI=@protonmail.com>
Message-ID: <YufXK6ayn8ZcBzYN@petertodd.org>

On Mon, Aug 01, 2022 at 01:19:05PM +0000, aliashraf.btc At protonmail wrote:
> > On Sat, Jul 30, 2022 at 05:24:35PM +0000, alicexbt via bitcoin-dev wrote:
> > like a hashcash-based alternative broadcast scheme.
> Hi Peter,
> I've been mulling the idea of attaching work to low fee txns, both as a compensation (e.g., in a sidechain, or an alt), and/or as a spam proof. Unfortunately, both suffer from ASICs:
> For spam proof case, the adversary can easily buy a used/obsolete device to produce lots of spam txns very cheaply, unless you put the bar very high, making it almost impossible for average users to even try.
> The compensation scenario is pretty off-topic, still, interesting enough for 1 min read:
> Wallets commit to the latest blockchain state in the transaction AND attach work.
> It is considered contribution to the security (illegitimate chains can't include the txn), hence isrewarded by fee discount/exemption depending on the offset of the state they've committed to (the closer, the better) and the amount of work attached.
> For this to work, block difficulty is calculated inclusive with the work embedded in the txns, it contains. Sophisticated and consequential, yet not infeasible per se.
> 
> Unfortunately, this scheme is hard to balance with ASICs in the scene too, for instance, you can't subsidize wallets for their work like with a leverge, because miners can easily do it locally, seizing the subsidies for themselves, long story, not relevant just ignore it.

We're not talking about a consensus system here. Just a way to rate-limit
access to a broadcast network used by a small minority of nodes. It's
completely ok to simply change the PoW algorithm in the _highly_ unlikely event
someone bothers to build an ASIC for it. Since this isn't a consensu system,
it's totally ok if multiple versions of the scheme run in parallel.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220801/e69f3291/attachment.sig>

From billy.tetrud at gmail.com  Wed Aug  3 15:37:05 2022
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Wed, 3 Aug 2022 10:37:05 -0500
Subject: [bitcoin-dev] On a new community process to specify covenants
In-Reply-To: <CAHUJnBB1wExgJhHUeU88ZMD28s6+9UT3Cfc43_UpK40hJwUFSg@mail.gmail.com>
References: <CALZpt+FhpZETHP8UpDGgw-Wg=m4Hxm8y9XZ9kXYgmt90_6Zt6w@mail.gmail.com>
 <CAHUJnBDu+PNvER-FmpT8593vX-wAZ1oPWJjQaJ=d7Y4pso_Txw@mail.gmail.com>
 <CALZpt+E4Ej3KJ4WqkUDTF3DRhPTbUT5mw2c_eHLuxH7w1BbWGg@mail.gmail.com>
 <CAHUJnBB1wExgJhHUeU88ZMD28s6+9UT3Cfc43_UpK40hJwUFSg@mail.gmail.com>
Message-ID: <CAGpPWDbbZ7PEpr4iwYwBn+5QcjjCx8qmTZVB98i2Z=UwDfwaTQ@mail.gmail.com>

@Antoine
I very much like your proposal of an open decentralized process for
investigating the problem and solution spaces. IRC sounds like a reasonable
place for this kind of thing to happen. I also agree with Ryan Grant's
comment about in-person cut-through (ie cut through the BS and resolve
misunderstandings). Perhaps every 3 IRC meetings or so, an in-person meetup
can be organized in various locations to facilitate that kind of cut
through.

I would imagine the phases the group could go through is:
1. Define the phases (these phases). This list of 6 phases could be a
starting point, but its probably best to open the floor to whether this
feels like a reasonable approach and if more phases are needed or if some
aren't.
2. Define and prioritize the motivations (ie the various features and
functionality we want out of covenants, like the ones you listed). By
prioritize, I mostly mean figure out which motivations are most motivating
to people and rate them by strength of motivation (rather than a ranked
list).
3. Define and prioritize the relevant constraints. These are things to
avoid in any covenant implementation. Constraints that have been brought up
in the past are things like preventing the possibility of infinite covenant
recursion, full enumeration, preventing dynamic state, etc. By prioritize
here, it might be useful to categorize them into categories like "no
tolerance", "some tolerance", "no reservations". Eg it might turn out most
people don't have any tolerance for infinite recursion, but don't mind
non-full enumeration.
4. Other criteria? These are other criteria we might want to evaluate
proposals according to. And some kind of way to prioritize them / evaluate
them against each other as trade offs.
5. Evaluate the proposals based on motivations, constraints, and other
criteria. This phase shouldn't involve comparing them to each other.
6. Produce a set of conclusions/opinions on which proposals are worth
pursuing further. This would be the phase where proposals are compared.

Each phase would probably span over more than one meeting. I imagine each
phase basically consisting of discussing each individual nominated item (ie
motivations, constraints, other criteria, or proposals) sequentially. The
consensus reached at the end of each phase would be considered of course a
group consensus of those who participated, not a global consensus, not a
"bitcoin community consensus". After each phase, the results of that phase
would be published more widely to get broader community feedback. These
results would include what the major opinions are, what level of consensus
each major opinion has, what the reasons/justifications behind each opinion
are, and various detailed opinions from individuals. It would be especially
great to have detailed evaluations of each proposal published by various
people so anyone can go back and understand their thought process (as
opposed to a list of names attached to basically a thumbs up or thumbs
down). Think like a supreme court decision kind of thing.

The process doesn't need to be complete after phase 6. Any previous phase
could be revisited, but after a phase is revisited, the phases after it
should probably be also revisited in order - or at least until its decided
a previous phase needs to be revisited again. Each iteration would solidify
consensus more about each phase. I would imagine the group might loop
through phases 2, 3, and 4 a couple times (since constraints might conflict
with motivating features). It might be likely that in phase 5 while
evaluating proposals, people realize that there are additional criteria
that should be added and can propose going back to step 4 to do that.
Hopefully we would get to the point where the motivations and constraints
and relatively solid consensuses and iterations can loop through phases 5
and 6 until the set of proposals the group thinks is worth pursuing  is
narrowed down (ideally to 1 or 2).






On Tue, Jul 26, 2022 at 11:47 AM Bram Cohen via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Mon, Jul 25, 2022 at 8:21 PM Antoine Riard <antoine.riard at gmail.com>
> wrote:
>
>> What would be the canonical definition and examples of capabilities in
>> the Bitcoin context ?
>>
>
> Payments into vaults which can only be accepted by that vault and are
> guaranteed to be subject to the vault's restrictions (the vault has a
> capability)
>
> Oracles whose validity can be verified on chain (so transactions can
> depend on what they say. The oracle has a capability)
>
> Colored coins whose validity can be verified on chain (the colored coins
> have a capability)
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220803/101b8a4d/attachment.html>

From chauhanansh.me at gmail.com  Wed Aug  3 15:40:34 2022
From: chauhanansh.me at gmail.com (Aaradhya Chauhan)
Date: Wed, 3 Aug 2022 21:10:34 +0530
Subject: [bitcoin-dev] Regarding setting a lower minrelaytxfee
In-Reply-To: <YufXK6ayn8ZcBzYN@petertodd.org>
References: <CAGHFe1BXdTkPZn4r_KTxYoz0sqcMsV830dm5JTTFURxDezBnDQ@mail.gmail.com>
 <Yt/h2Jv3m8ZsfZ8v@petertodd.org> <f889c7fc9db56ed448237c8a4091abaa@dtrt.org>
 <CAGHFe1C-u7DbTtg0dz+p8Moh=FbFN5dKZow5HgtMpxcVyS2ZdA@mail.gmail.com>
 <JMG4yhnQ2xL1Pq51Jnyk37c6-Ip8zHuCjmPWc6AYJ0LxlhO7enV9xdr4YGkGbn_J-ecpueZsB-mIjowyVDyMINme1bXJk4BYYP7lBxR4Kfg=@protonmail.com>
 <YuerLzSvdJ8ZcqrR@petertodd.org>
 <bKNhJ_ASFgsOslPnOxW-ps5h2OUbHbVQfOelaLPey8lxezLEuevkua1WpAtVRNPRmCtj0fRAeOSe5OHWYOSafczcBuGzhRDqbVjGctAUdBI=@protonmail.com>
 <YufXK6ayn8ZcBzYN@petertodd.org>
Message-ID: <CAGHFe1BsDnxn6nuoMwCtt56YjaXmT0mPZ6XnMJZpyC2Fa7e9aQ@mail.gmail.com>

So, can we conclude by something, whether or not it would be possible and
feasible in the future?

On Mon, 1 Aug 2022 at 19:08, Peter Todd via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Mon, Aug 01, 2022 at 01:19:05PM +0000, aliashraf.btc At protonmail
> wrote:
> > > On Sat, Jul 30, 2022 at 05:24:35PM +0000, alicexbt via bitcoin-dev
> wrote:
> > > like a hashcash-based alternative broadcast scheme.
> > Hi Peter,
> > I've been mulling the idea of attaching work to low fee txns, both as a
> compensation (e.g., in a sidechain, or an alt), and/or as a spam proof.
> Unfortunately, both suffer from ASICs:
> > For spam proof case, the adversary can easily buy a used/obsolete device
> to produce lots of spam txns very cheaply, unless you put the bar very
> high, making it almost impossible for average users to even try.
> > The compensation scenario is pretty off-topic, still, interesting enough
> for 1 min read:
> > Wallets commit to the latest blockchain state in the transaction AND
> attach work.
> > It is considered contribution to the security (illegitimate chains can't
> include the txn), hence isrewarded by fee discount/exemption depending on
> the offset of the state they've committed to (the closer, the better) and
> the amount of work attached.
> > For this to work, block difficulty is calculated inclusive with the work
> embedded in the txns, it contains. Sophisticated and consequential, yet not
> infeasible per se.
> >
> > Unfortunately, this scheme is hard to balance with ASICs in the scene
> too, for instance, you can't subsidize wallets for their work like with a
> leverge, because miners can easily do it locally, seizing the subsidies for
> themselves, long story, not relevant just ignore it.
>
> We're not talking about a consensus system here. Just a way to rate-limit
> access to a broadcast network used by a small minority of nodes. It's
> completely ok to simply change the PoW algorithm in the _highly_ unlikely
> event
> someone bothers to build an ASIC for it. Since this isn't a consensu
> system,
> it's totally ok if multiple versions of the scheme run in parallel.
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220803/72f0cd9f/attachment.html>

From vjudeu at gazeta.pl  Wed Aug  3 17:07:08 2022
From: vjudeu at gazeta.pl (vjudeu at gazeta.pl)
Date: Wed, 03 Aug 2022 19:07:08 +0200
Subject: [bitcoin-dev] Regarding setting a lower minrelaytxfee
In-Reply-To: <CAGHFe1BsDnxn6nuoMwCtt56YjaXmT0mPZ6XnMJZpyC2Fa7e9aQ@mail.gmail.com>
Message-ID: <166123291-fe0f05975e84c5e295606d87fdddcd64@pmq3v.m5r2.onet>

It is possible, because you can find nodes that accept low-fee transactions. And on some statistics, for example https://jochen-hoenicke.de/queue/#BTC,24h,weight,0 you can see that zero to one satoshi per virtual byte transactions could take more space than other transactions. You can be convinced that those charts are not fake by running a full node and reaching some nodes with different fee settings. If miners don't want to accept them, well, it is their choice to leave that money on the table. As long as the basic block reward is sufficient, they don't have to accept such low fee transactions, because they can wait instead, to receive them in some batched form.

Also, some miners could accept only 10 sats/vB or higher, because why not. As long as your transaction will reach enough nodes to be confirmed, you can safely pick lower fees. For now, de-facto standard is one satoshi per virtual byte, but:

1) it is only declared, so you can rely only on declarations, not on hard consensus rules
2) there is no way to make sure if some transaction was truly rejected by some miner, or maybe it was saved somewhere
3) you can never be sure if some node is a miner and can enforce those different fee rules or not

So, you can really judge only by how nodes behave, you cannot make sure in any way if anyone is running some additional rules. And fees are not a part of the consensus, so they can be freely adjusted by each node, and there is no way to make sure, what rules are really executed, you can only assume that, based on what transactions are included in blocks.



On 2022-08-03 18:19:12 user Aaradhya Chauhan via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
So, can we conclude by something, whether or not it would be possible and feasible in the future?


On Mon, 1 Aug 2022 at 19:08, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

On Mon, Aug 01, 2022 at 01:19:05PM +0000, aliashraf.btc At protonmail wrote:
> > On Sat, Jul 30, 2022 at 05:24:35PM +0000, alicexbt via bitcoin-dev wrote:
> > like a hashcash-based alternative broadcast scheme.
> Hi Peter,
> I've been mulling the idea of attaching work to low fee txns, both as a compensation (e.g., in a sidechain, or an alt), and/or as a spam proof. Unfortunately, both suffer from ASICs:
> For spam proof case, the adversary can easily buy a used/obsolete device to produce lots of spam txns very cheaply, unless you put the bar very high, making it almost impossible for average users to even try.
> The compensation scenario is pretty off-topic, still, interesting enough for 1 min read:
> Wallets commit to the latest blockchain state in the transaction AND attach work.
> It is considered contribution to the security (illegitimate chains can't include the txn), hence isrewarded by fee discount/exemption depending on the offset of the state they've committed to (the closer, the better) and the amount of work attached.
> For this to work, block difficulty is calculated inclusive with the work embedded in the txns, it contains. Sophisticated and consequential, yet not infeasible per se.
>
> Unfortunately, this scheme is hard to balance with ASICs in the scene too, for instance, you can't subsidize wallets for their work like with a leverge, because miners can easily do it locally, seizing the subsidies for themselves, long story, not relevant just ignore it.

We're not talking about a consensus system here. Just a way to rate-limit
access to a broadcast network used by a small minority of nodes. It's
completely ok to simply change the PoW algorithm in the _highly_ unlikely event
someone bothers to build an ASIC for it. Since this isn't a consensu system,
it's totally ok if multiple versions of the scheme run in parallel.

From chauhanansh.me at gmail.com  Wed Aug  3 18:22:32 2022
From: chauhanansh.me at gmail.com (Aaradhya Chauhan)
Date: Wed, 3 Aug 2022 23:52:32 +0530
Subject: [bitcoin-dev] Regarding setting a lower minrelaytxfee
In-Reply-To: <166123291-fe0f05975e84c5e295606d87fdddcd64@pmq3v.m5r2.onet>
References: <CAGHFe1BsDnxn6nuoMwCtt56YjaXmT0mPZ6XnMJZpyC2Fa7e9aQ@mail.gmail.com>
 <166123291-fe0f05975e84c5e295606d87fdddcd64@pmq3v.m5r2.onet>
Message-ID: <CAGHFe1BYPhewOH6o+EMuWFhkFsn4DUYtc9ziFinVw8PHVR9tJg@mail.gmail.com>

Thank you for answering. I'll check out the link you provided, while also
playing around with the fee settings for my own full node, at my home
server.

On Wed, 3 Aug 2022 at 23:02, vjudeu via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> It is possible, because you can find nodes that accept low-fee
> transactions. And on some statistics, for example
> https://jochen-hoenicke.de/queue/#BTC,24h,weight,0 you can see that zero
> to one satoshi per virtual byte transactions could take more space than
> other transactions. You can be convinced that those charts are not fake by
> running a full node and reaching some nodes with different fee settings. If
> miners don't want to accept them, well, it is their choice to leave that
> money on the table. As long as the basic block reward is sufficient, they
> don't have to accept such low fee transactions, because they can wait
> instead, to receive them in some batched form.
>
> Also, some miners could accept only 10 sats/vB or higher, because why not.
> As long as your transaction will reach enough nodes to be confirmed, you
> can safely pick lower fees. For now, de-facto standard is one satoshi per
> virtual byte, but:
>
> 1) it is only declared, so you can rely only on declarations, not on hard
> consensus rules
> 2) there is no way to make sure if some transaction was truly rejected by
> some miner, or maybe it was saved somewhere
> 3) you can never be sure if some node is a miner and can enforce those
> different fee rules or not
>
> So, you can really judge only by how nodes behave, you cannot make sure in
> any way if anyone is running some additional rules. And fees are not a part
> of the consensus, so they can be freely adjusted by each node, and there is
> no way to make sure, what rules are really executed, you can only assume
> that, based on what transactions are included in blocks.
>
>
>
> On 2022-08-03 18:19:12 user Aaradhya Chauhan via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> So, can we conclude by something, whether or not it would be possible and
> feasible in the future?
>
>
> On Mon, 1 Aug 2022 at 19:08, Peter Todd via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> On Mon, Aug 01, 2022 at 01:19:05PM +0000, aliashraf.btc At protonmail
> wrote:
> > > On Sat, Jul 30, 2022 at 05:24:35PM +0000, alicexbt via bitcoin-dev
> wrote:
> > > like a hashcash-based alternative broadcast scheme.
> > Hi Peter,
> > I've been mulling the idea of attaching work to low fee txns, both as a
> compensation (e.g., in a sidechain, or an alt), and/or as a spam proof.
> Unfortunately, both suffer from ASICs:
> > For spam proof case, the adversary can easily buy a used/obsolete device
> to produce lots of spam txns very cheaply, unless you put the bar very
> high, making it almost impossible for average users to even try.
> > The compensation scenario is pretty off-topic, still, interesting enough
> for 1 min read:
> > Wallets commit to the latest blockchain state in the transaction AND
> attach work.
> > It is considered contribution to the security (illegitimate chains can't
> include the txn), hence isrewarded by fee discount/exemption depending on
> the offset of the state they've committed to (the closer, the better) and
> the amount of work attached.
> > For this to work, block difficulty is calculated inclusive with the work
> embedded in the txns, it contains. Sophisticated and consequential, yet not
> infeasible per se.
> >
> > Unfortunately, this scheme is hard to balance with ASICs in the scene
> too, for instance, you can't subsidize wallets for their work like with a
> leverge, because miners can easily do it locally, seizing the subsidies for
> themselves, long story, not relevant just ignore it.
>
> We're not talking about a consensus system here. Just a way to rate-limit
> access to a broadcast network used by a small minority of nodes. It's
> completely ok to simply change the PoW algorithm in the _highly_ unlikely
> event
> someone bothers to build an ASIC for it. Since this isn't a consensu
> system,
> it's totally ok if multiple versions of the scheme run in parallel.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220803/a9af4854/attachment.html>

From billy.tetrud at gmail.com  Thu Aug  4 01:16:52 2022
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Wed, 3 Aug 2022 20:16:52 -0500
Subject: [bitcoin-dev] BIP Proposal: Receiving and Change Derivation
 Paths in a Single Descriptor
In-Reply-To: <20220728114016.2ff78722@simplexum.com>
References: <7bded922-5067-caee-e5be-9f620cfc7404@achow101.com>
 <20220728114016.2ff78722@simplexum.com>
Message-ID: <CAGpPWDaSsAn3GPoYdJmdJ6iW6M6G_2G8ua1cONhjSRRdSog8Pg@mail.gmail.com>

@Dmitry
>  various software might start to use extra indexes in a tuple for their
own non-standard purposes

This will be true regardless of whether the spec allows or doesn't allow
tuples of length more than 2. In fact, any other tuple other than <1;2>
will be nonstandard. We can't prevent people from using standards in
use-case-specific ways, and we can't prevent people from creating
non-standard extensions of standards.

> Wallet software that wishes to utilize non-standard extra indexes beyond
'receive' and 'change' should use separate descriptors instead for these
extra indexes.

What benefit would that gain? The wallets would still be doing something
non-standard and interpreting those indexes however they want. A descriptor
format is simply defining a space of address derivation paths. It is not
describing in any way what each path is intended for - those are
conventions outside the scope of this BIP IMO. Defining the conventions of
derivation path indexes should be a separate BIP. Single responsibility
principle.

On Thu, Jul 28, 2022 at 5:15 AM Dmitry Petukhov via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> The issue with tuples of lenth more than two is that the purpose for
> indexes beyond 'receive' and 'change' are not established, and
> therefore various software might start to use extra indexes in a tuple
> for their own non-standard purposes. This is bound to create
> incompatibilities where different wallet software that import the same
> descriptor would use those addresses for different purposes.
>
> Even if some auxiliary standard emerges for the meanings of extra
> indexes, since the indexes in the tuple are listed without omissions (no
> "<0;1;;;3>" allowed), all software will need to be aware of the
> existence of these purposes and define indexes for them: if one wishes
> to utilize position 3 in such a tuple, they will need to define an index
> for position 2 as well.
>
> I'd expect that emergence of new widely-used purposes for indexes would
> be a very rare event, and a separate BIP for each purpose wouldn't be
> excessive.
>
> I'd say that bip-multipath-descs should say that extra indexes are OK
> for address discovery (for scanning of the addresses of a wallet), but
> it should say that any interpretation of the purpose of such indexes
> and deriving new addresses at these indexes are strongly discouraged.
>
> Wallet software that wishes to utilize non-standard extra indexes beyond
> 'receive' and 'change' should use separate descriptors instead for
> these extra indexes.
>
> And when a new established purpose emerges for the next position in the
> index tuple, a new BIP should be made that defines such position.
>
> The BIP for position 3 would naturally come after the BIP for position
> 2, and thus software that implemnents BIP for position 3 would be aware
> of the previous BIP and will at least know to choose some index for
> position 2.
>
> ? Wed, 27 Jul 2022 14:58:28 +0000
> Andrew Chow via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
> wrote:
>
> > I've updated the BIP text to allow arbitrary length tuples.
> >
> > On 07/27/2022 04:44 AM, Pavol Rusnak wrote:
> >
> > > On Wed, 27 Jul 2022 at 00:28, Andrew Chow
> > > <achow101-lists at achow101.com> wrote:
> > >> However I don't see why this couldn't generalize to any sized
> > >> tuples. As long as the tuples are all the same length, and the
> > >> limit is one tuple per key expression, then we don't get any
> > >> combinatorial blowup issues.
> > >
> > > I think it's worthwhile to generalize for any sized tuples. I don't
> > > have any existing particular use case in mind, because BIP-44,
> > > BIP-84, etc. are fine with just using <0;1>, but there might be
> > > some upcoming standards in the future that will want to introduce
> > > more sub-paths.
> > >
> > > --
> > >
> > > Best Regards / S pozdravom,
> > >
> > > Pavol "stick" Rusnak
> > > Co-Founder, SatoshiLab
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220803/bc75c220/attachment-0001.html>

From billy.tetrud at gmail.com  Thu Aug  4 01:21:51 2022
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Wed, 3 Aug 2022 20:21:51 -0500
Subject: [bitcoin-dev] Regarding setting a lower minrelaytxfee
In-Reply-To: <CAGHFe1BYPhewOH6o+EMuWFhkFsn4DUYtc9ziFinVw8PHVR9tJg@mail.gmail.com>
References: <CAGHFe1BsDnxn6nuoMwCtt56YjaXmT0mPZ6XnMJZpyC2Fa7e9aQ@mail.gmail.com>
 <166123291-fe0f05975e84c5e295606d87fdddcd64@pmq3v.m5r2.onet>
 <CAGHFe1BYPhewOH6o+EMuWFhkFsn4DUYtc9ziFinVw8PHVR9tJg@mail.gmail.com>
Message-ID: <CAGpPWDbdCVYy7M=kv26oHJQHqi1VXd0eSpnLTceXrdWmkCq6Dw@mail.gmail.com>

I agree with Peter, it seems like we don't need a dust limit with full
blocks. And we should expect blocks to remain full indefinitely.

However, if we were to still have a dust limit, it shouldn't be a simple
constant. It should be determined by the mempool environment. Eg one could
define the dust limit to be the 5th percentile lowest fee in the last 100
blocks. Or the 1st percentile. Etc. This way, as the value of bitcoin
fluctuates (inevitably affecting the fees people are willing to pay), the
dust limit would automatically adjust to compensate. One might worry that
in high fee environments, the dust limit calculated this way might make for
too-high dust limits. But I don't think you could really say it would be
"too high" because it would match the actual mempool. We could have a
maximum dust limit set if that's a worry tho.

On Wed, Aug 3, 2022 at 5:35 PM Aaradhya Chauhan via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Thank you for answering. I'll check out the link you provided, while also
> playing around with the fee settings for my own full node, at my home
> server.
>
> On Wed, 3 Aug 2022 at 23:02, vjudeu via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> It is possible, because you can find nodes that accept low-fee
>> transactions. And on some statistics, for example
>> https://jochen-hoenicke.de/queue/#BTC,24h,weight,0 you can see that zero
>> to one satoshi per virtual byte transactions could take more space than
>> other transactions. You can be convinced that those charts are not fake by
>> running a full node and reaching some nodes with different fee settings. If
>> miners don't want to accept them, well, it is their choice to leave that
>> money on the table. As long as the basic block reward is sufficient, they
>> don't have to accept such low fee transactions, because they can wait
>> instead, to receive them in some batched form.
>>
>> Also, some miners could accept only 10 sats/vB or higher, because why
>> not. As long as your transaction will reach enough nodes to be confirmed,
>> you can safely pick lower fees. For now, de-facto standard is one satoshi
>> per virtual byte, but:
>>
>> 1) it is only declared, so you can rely only on declarations, not on hard
>> consensus rules
>> 2) there is no way to make sure if some transaction was truly rejected by
>> some miner, or maybe it was saved somewhere
>> 3) you can never be sure if some node is a miner and can enforce those
>> different fee rules or not
>>
>> So, you can really judge only by how nodes behave, you cannot make sure
>> in any way if anyone is running some additional rules. And fees are not a
>> part of the consensus, so they can be freely adjusted by each node, and
>> there is no way to make sure, what rules are really executed, you can only
>> assume that, based on what transactions are included in blocks.
>>
>>
>>
>> On 2022-08-03 18:19:12 user Aaradhya Chauhan via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>> So, can we conclude by something, whether or not it would be possible and
>> feasible in the future?
>>
>>
>> On Mon, 1 Aug 2022 at 19:08, Peter Todd via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> On Mon, Aug 01, 2022 at 01:19:05PM +0000, aliashraf.btc At protonmail
>> wrote:
>> > > On Sat, Jul 30, 2022 at 05:24:35PM +0000, alicexbt via bitcoin-dev
>> wrote:
>> > > like a hashcash-based alternative broadcast scheme.
>> > Hi Peter,
>> > I've been mulling the idea of attaching work to low fee txns, both as a
>> compensation (e.g., in a sidechain, or an alt), and/or as a spam proof.
>> Unfortunately, both suffer from ASICs:
>> > For spam proof case, the adversary can easily buy a used/obsolete
>> device to produce lots of spam txns very cheaply, unless you put the bar
>> very high, making it almost impossible for average users to even try.
>> > The compensation scenario is pretty off-topic, still, interesting
>> enough for 1 min read:
>> > Wallets commit to the latest blockchain state in the transaction AND
>> attach work.
>> > It is considered contribution to the security (illegitimate chains
>> can't include the txn), hence isrewarded by fee discount/exemption
>> depending on the offset of the state they've committed to (the closer, the
>> better) and the amount of work attached.
>> > For this to work, block difficulty is calculated inclusive with the
>> work embedded in the txns, it contains. Sophisticated and consequential,
>> yet not infeasible per se.
>> >
>> > Unfortunately, this scheme is hard to balance with ASICs in the scene
>> too, for instance, you can't subsidize wallets for their work like with a
>> leverge, because miners can easily do it locally, seizing the subsidies for
>> themselves, long story, not relevant just ignore it.
>>
>> We're not talking about a consensus system here. Just a way to rate-limit
>> access to a broadcast network used by a small minority of nodes. It's
>> completely ok to simply change the PoW algorithm in the _highly_ unlikely
>> event
>> someone bothers to build an ASIC for it. Since this isn't a consensu
>> system,
>> it's totally ok if multiple versions of the scheme run in parallel.
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220803/8badd1b8/attachment-0001.html>

From dp at simplexum.com  Thu Aug  4 07:09:33 2022
From: dp at simplexum.com (Dmitry Petukhov)
Date: Thu, 4 Aug 2022 09:09:33 +0200
Subject: [bitcoin-dev] BIP Proposal: Receiving and Change Derivation
 Paths in a Single Descriptor
In-Reply-To: <CAGpPWDaSsAn3GPoYdJmdJ6iW6M6G_2G8ua1cONhjSRRdSog8Pg@mail.gmail.com>
References: <7bded922-5067-caee-e5be-9f620cfc7404@achow101.com>
 <20220728114016.2ff78722@simplexum.com>
 <CAGpPWDaSsAn3GPoYdJmdJ6iW6M6G_2G8ua1cONhjSRRdSog8Pg@mail.gmail.com>
Message-ID: <20220804090933.228ad190@simplexum.com>

? Wed, 3 Aug 2022 20:16:52 -0500
Billy Tetrud <billy.tetrud at gmail.com> wrote:

> A descriptor format is simply defining a space of address
> derivation paths. It is not describing in any way what each path is
> intended for - those are conventions outside the scope of this BIP
> IMO. Defining the conventions of derivation path indexes should be a
> separate BIP. Single responsibility principle.

I see, you're right. I misread the BIP proposal text and missed that it
describes 'receive' and 'change' only as 'common usecase', not as
definitive designations for indexes. Considering this, I too see no need
to include such conventions in this BIP.

From ali at notatether.com  Thu Aug  4 12:18:56 2022
From: ali at notatether.com (Ali Sherief)
Date: Thu, 04 Aug 2022 12:18:56 +0000
Subject: [bitcoin-dev] BIP-notatether-signedmessage
In-Reply-To: <4Lz70s3l79z4x2h7@mail-41103.protonmail.ch>
References: <4Lz70s3l79z4x2h7@mail-41103.protonmail.ch>
Message-ID: <20220804121851.7e4zoqxaaolseazn@artanis>

Hi,

I have created a new BIP, called notatether-signedmessage. It can be viewed at https://github.com/ZenulAbidin/bips/blob/master/bip-notatether-signedmessage.mediawiki.

For those who want a quick summary, it defines a step-by-step process for signing and verifying messages from legacy, native/nested segwit, and taproot addresses. It does not define a new signature format itself, except in the case of Taproot. For those addresses, I have defined a signature format that has 1 byte header/recID, 64 bytes signature, and 32 bytes x coordinate of a public key. This is required to run the BIP340 Schnorr verify algorithm using only the signature - and the header byte is added for backwards compatibility. Otherwise, it completely integrates BIP137 signatures.

I am planning to move that format to its own BIP as soon as possible, in lieu that it is unacceptable to define formats in an Informational BIP.

Please leave your comments in this mailing list. CC'ing BIP editors.

- Ali


From michaelfolkson at protonmail.com  Thu Aug  4 14:54:54 2022
From: michaelfolkson at protonmail.com (Michael Folkson)
Date: Thu, 04 Aug 2022 14:54:54 +0000
Subject: [bitcoin-dev] RBF rules,
	setting policy defaults in Bitcoin Core and the role of BIPs
Message-ID: <zl3fWujFF4mSjfXz_d1gA73ALTnN_LaaGKyidRR6azX9toY2-j7cUkfVcU1ggIhJ0cjK9oA4q1jF5mDob6bdlDp4yaWHZKxxev-zjUQBqTk=@protonmail.com>

A short history of RBF and BIP125

The history of BIP125 is as far as I?m aware this. RBF rules were merged into Bitcoin Core in November 2015 [0]. Following that merge David Harding and Peter Todd drafted a BIP (BIP125 [1]) outlining the RBF rules that had been implemented in Bitcoin Core. The rationales for the rules in the BIP was a bit lacking (in my opinion) but recall this is 2015 (7 years ago!) when L2 protocols were in their infancy. Certainly the research on the security of L2 protocols has come a long way since and we have a much better idea of some of the possible attacks on L2 protocols that to some extent are impacted by policy rules.

In addition it was discovered [2] in May 2021 that the Bitcoin Core implementation of the RBF rules had never matched the RBF rules outlined in BIP125. Clearly this isn?t ideal but mistakes happen and will continue to happen. I certainly do not intend any criticism whatsoever to any of the individuals involved. Thankfully this discrepancy doesn?t seem to have resulted in any loss of funds or disruption. However, cross checking a specification with an implementation presumably led to the discovery and allowed for a post mortem on why the implementation didn?t match the specification.

There seems to be two views on what to do next given that the RBF rules need to be updated. One is to ditch the idea of a specification for RBF rules and just document them in the Core repo instead. The other is to have a new specification for the RBF rules in Core and attempt to correct the mistakes made with BIP125 by having a BIP that does correctly outline the RBF rules implemented in Core and includes detailed rationales for why those RBF rules have been implemented.

Should anyone care about where things are documented?

Perhaps not but I think if you are a stakeholder in L2 protocol security you should. Suppose in the long term future an attacker exploits a L2 vulnerability that is based on the default policy set by the dominant implementation on the network (Bitcoin Core). Which would you prefer the norm to be? A detailed static, well reviewed BIP standard that lays out the updated RBF rules and the rationales for those new rules that is reviewed outside the Core repo and hence not just by Core reviewers? Or cross checking Bitcoin Core code with non-standardized Core documentation typically reviewed only by Core reviewers?

For the same reason the norm for consensus changes is a specification (BIP) and a reference implementation (Bitcoin Core) I think the norm for material step change policy changes should be a specification (BIP) and a reference implementation (Bitcoin Core). Policy is of course less risky than consensus for various reasons including there being no chain split risk if the user changes the default policy of their node. Alternative implementations are free to set entirely different policy rules too. But with L2 protocol security to some extent relying on policy whether we like it or not I think we should aspire to similar standards where possible for policy too.

Specifications and implementations

The Bitcoin Core review process generally requires Concept ACKs, Approach ACKs and then code review, testing ACKs in that order. The reason for this is even if the code is perfect if it is implementing a concept or an approach that informed reviewers oppose then it doesn?t matter that the code is perfect. Documentation is generally done post merge if at all. For most PRs e.g. refactors this makes sense. There is no point documenting something in advance if it is still under review or may not get merged. For consensus PRs this clearly doesn?t make sense. Many of us have and continue to cross check the Taproot BIPs with the Taproot reference implementation in Bitcoin Core. Having two points of reference released simultaneously is treating consensus changes with the highest possible standards we can. I think we should strive towards the highest possible standards for step change default policy changes in Core too given L2 protocol security is (unfortunately, ideally this wouldn?t be the case) relying on them.

What are the new RBF rules replacing the BIP125 rules?

The new RBF rules as implemented in Core today are documented here [3] in the Core repo (thanks for the link glozow). To the extent that these are a work in progress or close to final (i.e. intended to be static) I don?t know. The devs who work on policy will have a much better idea on these questions than me. Will the new RBF rules continue to be iterated upon as new research on L2 security comes to light? Will this iteration make it impossible to maintain a static set of rules that the broader ecosystem can get comfortable with? Or is a new static set of RBF rules close to being finalized and there is just an aversion to using BIPs and a specification?

Generally, as time passes, the ecosystem grows, layers on top of the base layer get built out I get uncomfortable with what I perceive (correctly or incorrectly) as a slip in standards. If anything it should be going in the opposite direction. Standards should be improving and we should be striving to do better and be more rigorous than whatever the standard was in 2015. But I don?t work on policy in Core full time and it is very possible that there are subtleties that I?m entirely missing here. I think this is the right forum to ask about those subtleties though. Thanks to those who work on this important area.

[0]: https://github.com/bitcoin/bitcoin/pull/6871

[1]: https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki

[2]: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-May/018893.html

[3]: https://github.com/bitcoin/bitcoin/blob/master/doc/policy/mempool-replacements.md

--
Michael Folkson
Email: michaelfolkson at [protonmail.com](http://protonmail.com/)
Keybase: michaelfolkson
PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220804/0036ee9e/attachment.html>

From ali at notatether.com  Thu Aug  4 17:54:02 2022
From: ali at notatether.com (Ali Sherief)
Date: Thu, 04 Aug 2022 17:54:02 +0000
Subject: [bitcoin-dev] BIP-notatether-signedmessage
In-Reply-To: <20220804121851.7e4zoqxaaolseazn@artanis>
References: <4Lz70s3l79z4x2h7@mail-41103.protonmail.ch>
 <20220804121851.7e4zoqxaaolseazn@artanis>
Message-ID: <92xA8EvymL-T7scNgL9H7o7QMDO7P0q8yEl8aPk4v3KpdXiPUr4-h22-RskqnLTiQE_hD0BEvpLZFMTysTy9laszpC9t6PJDR5jBUQy_J8U=@notatether.com>

My sincere apologies, the link returns a 404 (trailing dot). The correct link to the BIP is https://github.com/ZenulAbidin/bips/blob/master/bip-notatether-signedmessage.mediawiki

-Ali

------- Original Message -------
On Thursday, August 4th, 2022 at 3:18 PM, Ali Sherief <ali at notatether.com> wrote:


> Hi,
>
> I have created a new BIP, called notatether-signedmessage. It can be viewed at https://github.com/ZenulAbidin/bips/blob/master/bip-notatether-signedmessage.mediawiki.
>
> For those who want a quick summary, it defines a step-by-step process for signing and verifying messages from legacy, native/nested segwit, and taproot addresses. It does not define a new signature format itself, except in the case of Taproot. For those addresses, I have defined a signature format that has 1 byte header/recID, 64 bytes signature, and 32 bytes x coordinate of a public key. This is required to run the BIP340 Schnorr verify algorithm using only the signature - and the header byte is added for backwards compatibility. Otherwise, it completely integrates BIP137 signatures.
>
> I am planning to move that format to its own BIP as soon as possible, in lieu that it is unacceptable to define formats in an Informational BIP.
>
> Please leave your comments in this mailing list. CC'ing BIP editors.
>
> - Ali

From peter at coinkite.com  Thu Aug  4 18:36:06 2022
From: peter at coinkite.com (Peter (Coinkite Inc))
Date: Thu, 4 Aug 2022 14:36:06 -0400
Subject: [bitcoin-dev] BIP-notatether-signedmessage
In-Reply-To: <20220804121851.7e4zoqxaaolseazn@artanis>
References: <4Lz70s3l79z4x2h7@mail-41103.protonmail.ch>
 <20220804121851.7e4zoqxaaolseazn@artanis>
Message-ID: <YuwRlqLOkb0/RySq@coinkite.com>

Thanks for doing this, it looks great Ali!

COLDCARD and other Coinkite products will conform to this spec, if we don't already.

On Thu, Aug 04, 2022 at 12:18:56PM +0000, Ali Sherief wrote:
> Hi,
> 
> I have created a new BIP, called notatether-signedmessage. It can be viewed at https://github.com/ZenulAbidin/bips/blob/master/bip-notatether-signedmessage.mediawiki.
> 
...

---
@DocHEX  ||  Coinkite  ||  PGP: A3A31BAD 5A2A5B10

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220804/f034fec4/attachment.sig>

From luke at dashjr.org  Thu Aug  4 19:35:13 2022
From: luke at dashjr.org (Luke Dashjr)
Date: Thu, 4 Aug 2022 19:35:13 +0000
Subject: [bitcoin-dev] RBF rules,
	setting policy defaults in Bitcoin Core and the role of BIPs
In-Reply-To: <zl3fWujFF4mSjfXz_d1gA73ALTnN_LaaGKyidRR6azX9toY2-j7cUkfVcU1ggIhJ0cjK9oA4q1jF5mDob6bdlDp4yaWHZKxxev-zjUQBqTk=@protonmail.com>
References: <zl3fWujFF4mSjfXz_d1gA73ALTnN_LaaGKyidRR6azX9toY2-j7cUkfVcU1ggIhJ0cjK9oA4q1jF5mDob6bdlDp4yaWHZKxxev-zjUQBqTk=@protonmail.com>
Message-ID: <202208041935.14223.luke@dashjr.org>

Policy is a subjective per-node, not systemic, not enforcable or expectable, 
and generally not eligible for standardization.

The reason BIP125 is an exception, is because it is more than just policy.
It is a way for wallets and nodes to communicate. The wallet is saying "this 
is the policy I would like you to apply to potential replacements of these 
transactions". Whether the nodes abide this request or not, the purpose and 
justification of the BIP is to standardize the communication of it.

Since BIP125 is widely implemented, it should not be changed except for 
corrections to things which are errors deviating from the original intent.
If there is merely a new policy intended to be conveyed, a new BIP should be 
written that is distinguishable from BIP125 (perhaps drop the sequence number 
by 1 more). However, unless nodes are going to honour both the BIP125-request 
policy *and* a new policy, it might be simpler for them to just not honour 
the requested BIP125 policy exactly.

Also note that security should NEVER depend on assumptions of node policies. 
Doing so would be a serious security vulnerability, regardless of what actual 
network policies are. It's fine to blame nodes/miners if they single out your 
transactions, but if it's just a matter of a general policy your transactions 
are failing to meet, that's on the sender/L2 to adapt.

Luke


On Thursday 04 August 2022 14:54:54 Michael Folkson via bitcoin-dev wrote:
> A short history of RBF and BIP125
>
> The history of BIP125 is as far as I?m aware this. RBF rules were merged
> into Bitcoin Core in November 2015 [0]. Following that merge David Harding
> and Peter Todd drafted a BIP (BIP125 [1]) outlining the RBF rules that had
> been implemented in Bitcoin Core. The rationales for the rules in the BIP
> was a bit lacking (in my opinion) but recall this is 2015 (7 years ago!)
> when L2 protocols were in their infancy. Certainly the research on the
> security of L2 protocols has come a long way since and we have a much
> better idea of some of the possible attacks on L2 protocols that to some
> extent are impacted by policy rules.
>
> In addition it was discovered [2] in May 2021 that the Bitcoin Core
> implementation of the RBF rules had never matched the RBF rules outlined in
> BIP125. Clearly this isn?t ideal but mistakes happen and will continue to
> happen. I certainly do not intend any criticism whatsoever to any of the
> individuals involved. Thankfully this discrepancy doesn?t seem to have
> resulted in any loss of funds or disruption. However, cross checking a
> specification with an implementation presumably led to the discovery and
> allowed for a post mortem on why the implementation didn?t match the
> specification.
>
> There seems to be two views on what to do next given that the RBF rules
> need to be updated. One is to ditch the idea of a specification for RBF
> rules and just document them in the Core repo instead. The other is to have
> a new specification for the RBF rules in Core and attempt to correct the
> mistakes made with BIP125 by having a BIP that does correctly outline the
> RBF rules implemented in Core and includes detailed rationales for why
> those RBF rules have been implemented.
>
> Should anyone care about where things are documented?
>
> Perhaps not but I think if you are a stakeholder in L2 protocol security
> you should. Suppose in the long term future an attacker exploits a L2
> vulnerability that is based on the default policy set by the dominant
> implementation on the network (Bitcoin Core). Which would you prefer the
> norm to be? A detailed static, well reviewed BIP standard that lays out the
> updated RBF rules and the rationales for those new rules that is reviewed
> outside the Core repo and hence not just by Core reviewers? Or cross
> checking Bitcoin Core code with non-standardized Core documentation
> typically reviewed only by Core reviewers?
>
> For the same reason the norm for consensus changes is a specification (BIP)
> and a reference implementation (Bitcoin Core) I think the norm for material
> step change policy changes should be a specification (BIP) and a reference
> implementation (Bitcoin Core). Policy is of course less risky than
> consensus for various reasons including there being no chain split risk if
> the user changes the default policy of their node. Alternative
> implementations are free to set entirely different policy rules too. But
> with L2 protocol security to some extent relying on policy whether we like
> it or not I think we should aspire to similar standards where possible for
> policy too.
>
> Specifications and implementations
>
> The Bitcoin Core review process generally requires Concept ACKs, Approach
> ACKs and then code review, testing ACKs in that order. The reason for this
> is even if the code is perfect if it is implementing a concept or an
> approach that informed reviewers oppose then it doesn?t matter that the
> code is perfect. Documentation is generally done post merge if at all. For
> most PRs e.g. refactors this makes sense. There is no point documenting
> something in advance if it is still under review or may not get merged. For
> consensus PRs this clearly doesn?t make sense. Many of us have and continue
> to cross check the Taproot BIPs with the Taproot reference implementation
> in Bitcoin Core. Having two points of reference released simultaneously is
> treating consensus changes with the highest possible standards we can. I
> think we should strive towards the highest possible standards for step
> change default policy changes in Core too given L2 protocol security is
> (unfortunately, ideally this wouldn?t be the case) relying on them.
>
> What are the new RBF rules replacing the BIP125 rules?
>
> The new RBF rules as implemented in Core today are documented here [3] in
> the Core repo (thanks for the link glozow). To the extent that these are a
> work in progress or close to final (i.e. intended to be static) I don?t
> know. The devs who work on policy will have a much better idea on these
> questions than me. Will the new RBF rules continue to be iterated upon as
> new research on L2 security comes to light? Will this iteration make it
> impossible to maintain a static set of rules that the broader ecosystem can
> get comfortable with? Or is a new static set of RBF rules close to being
> finalized and there is just an aversion to using BIPs and a specification?
>
> Generally, as time passes, the ecosystem grows, layers on top of the base
> layer get built out I get uncomfortable with what I perceive (correctly or
> incorrectly) as a slip in standards. If anything it should be going in the
> opposite direction. Standards should be improving and we should be striving
> to do better and be more rigorous than whatever the standard was in 2015.
> But I don?t work on policy in Core full time and it is very possible that
> there are subtleties that I?m entirely missing here. I think this is the
> right forum to ask about those subtleties though. Thanks to those who work
> on this important area.
>
> [0]: https://github.com/bitcoin/bitcoin/pull/6871
>
> [1]: https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki
>
> [2]:
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-May/018893.htm
>l
>
> [3]:
> https://github.com/bitcoin/bitcoin/blob/master/doc/policy/mempool-replaceme
>nts.md
>
> --
> Michael Folkson
> Email: michaelfolkson at [protonmail.com](http://protonmail.com/)
> Keybase: michaelfolkson
> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3


From michaelfolkson at protonmail.com  Thu Aug  4 21:47:08 2022
From: michaelfolkson at protonmail.com (Michael Folkson)
Date: Thu, 04 Aug 2022 21:47:08 +0000
Subject: [bitcoin-dev] RBF rules,
	setting policy defaults in Bitcoin Core and the role of BIPs
In-Reply-To: <202208041935.14223.luke@dashjr.org>
References: <zl3fWujFF4mSjfXz_d1gA73ALTnN_LaaGKyidRR6azX9toY2-j7cUkfVcU1ggIhJ0cjK9oA4q1jF5mDob6bdlDp4yaWHZKxxev-zjUQBqTk=@protonmail.com>
 <202208041935.14223.luke@dashjr.org>
Message-ID: <WpuGECly2HymYFQCo_0Ahoyfv0osOpoMLZS-TkNLyg9iC4cLdHiP-ULm7QkSRlL4Xvg3UUq5FAkTBkcihHb0fHZc3im9EQNRumGNY40XJ68=@protonmail.com>

Thanks for this Luke.

> Since BIP125 is widely implemented, it should not be changed except for corrections to things which are errors deviating from the original intent.

In this example the BIP125/RBF rules implemented in Core are (and always have been) different to the rules as described in BIP125. As far as I know other implementations have also followed how it is implemented in Core rather than as described in BIP125. So we have the BIP125 rules, BIP125/RBF as implemented in Core and future intended changes to how RBF rules are implemented in Core which may or may not also be in a state of flux. I take the view that once those new RBF rules are "finalized" there should be a new BIP but others disagree.

> Also note that security should NEVER depend on assumptions of node policies. Doing so would be a serious security vulnerability, regardless of what actual network policies are.

You regularly state this and of course you're right. I tried to allude that it is far from ideal that L2 security is impacted by default policy rules to any extent in my post. But if it is a matter of fact that default policy rules impact the viability of some L2 protocol attacks today what should one do when setting default policy rules in the dominant implementation on the network? I think you lean towards not factoring that in whatsoever to decisions on default policy rules whereas (perhaps mistakenly) I lean towards factoring that in to default policy rule decisions especially when there don't seem to be many other factors to consider. In the case of Lightning Network I think we both want it to succeed and hopefully in the long term default policy rules will have no impact on its security whatsoever. But today that seems to not be the case.

--
Michael Folkson
Email: michaelfolkson at protonmail.com
Keybase: michaelfolkson
PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3


------- Original Message -------
On Thursday, August 4th, 2022 at 20:35, Luke Dashjr <luke at dashjr.org> wrote:


> Policy is a subjective per-node, not systemic, not enforcable or expectable,
> and generally not eligible for standardization.
>
> The reason BIP125 is an exception, is because it is more than just policy.
> It is a way for wallets and nodes to communicate. The wallet is saying "this
> is the policy I would like you to apply to potential replacements of these
> transactions". Whether the nodes abide this request or not, the purpose and
> justification of the BIP is to standardize the communication of it.
>
> Since BIP125 is widely implemented, it should not be changed except for
> corrections to things which are errors deviating from the original intent.
> If there is merely a new policy intended to be conveyed, a new BIP should be
> written that is distinguishable from BIP125 (perhaps drop the sequence number
> by 1 more). However, unless nodes are going to honour both the BIP125-request
> policy and a new policy, it might be simpler for them to just not honour
> the requested BIP125 policy exactly.
>
> Also note that security should NEVER depend on assumptions of node policies.
> Doing so would be a serious security vulnerability, regardless of what actual
> network policies are. It's fine to blame nodes/miners if they single out your
> transactions, but if it's just a matter of a general policy your transactions
> are failing to meet, that's on the sender/L2 to adapt.
>
> Luke
>
>
> On Thursday 04 August 2022 14:54:54 Michael Folkson via bitcoin-dev wrote:
>
> > A short history of RBF and BIP125
> >
> > The history of BIP125 is as far as I?m aware this. RBF rules were merged
> > into Bitcoin Core in November 2015 0. Following that merge David Harding
> > and Peter Todd drafted a BIP (BIP125 1) outlining the RBF rules that had
> > been implemented in Bitcoin Core. The rationales for the rules in the BIP
> > was a bit lacking (in my opinion) but recall this is 2015 (7 years ago!)
> > when L2 protocols were in their infancy. Certainly the research on the
> > security of L2 protocols has come a long way since and we have a much
> > better idea of some of the possible attacks on L2 protocols that to some
> > extent are impacted by policy rules.
> >
> > In addition it was discovered 2 in May 2021 that the Bitcoin Core
> > implementation of the RBF rules had never matched the RBF rules outlined in
> > BIP125. Clearly this isn?t ideal but mistakes happen and will continue to
> > happen. I certainly do not intend any criticism whatsoever to any of the
> > individuals involved. Thankfully this discrepancy doesn?t seem to have
> > resulted in any loss of funds or disruption. However, cross checking a
> > specification with an implementation presumably led to the discovery and
> > allowed for a post mortem on why the implementation didn?t match the
> > specification.
> >
> > There seems to be two views on what to do next given that the RBF rules
> > need to be updated. One is to ditch the idea of a specification for RBF
> > rules and just document them in the Core repo instead. The other is to have
> > a new specification for the RBF rules in Core and attempt to correct the
> > mistakes made with BIP125 by having a BIP that does correctly outline the
> > RBF rules implemented in Core and includes detailed rationales for why
> > those RBF rules have been implemented.
> >
> > Should anyone care about where things are documented?
> >
> > Perhaps not but I think if you are a stakeholder in L2 protocol security
> > you should. Suppose in the long term future an attacker exploits a L2
> > vulnerability that is based on the default policy set by the dominant
> > implementation on the network (Bitcoin Core). Which would you prefer the
> > norm to be? A detailed static, well reviewed BIP standard that lays out the
> > updated RBF rules and the rationales for those new rules that is reviewed
> > outside the Core repo and hence not just by Core reviewers? Or cross
> > checking Bitcoin Core code with non-standardized Core documentation
> > typically reviewed only by Core reviewers?
> >
> > For the same reason the norm for consensus changes is a specification (BIP)
> > and a reference implementation (Bitcoin Core) I think the norm for material
> > step change policy changes should be a specification (BIP) and a reference
> > implementation (Bitcoin Core). Policy is of course less risky than
> > consensus for various reasons including there being no chain split risk if
> > the user changes the default policy of their node. Alternative
> > implementations are free to set entirely different policy rules too. But
> > with L2 protocol security to some extent relying on policy whether we like
> > it or not I think we should aspire to similar standards where possible for
> > policy too.
> >
> > Specifications and implementations
> >
> > The Bitcoin Core review process generally requires Concept ACKs, Approach
> > ACKs and then code review, testing ACKs in that order. The reason for this
> > is even if the code is perfect if it is implementing a concept or an
> > approach that informed reviewers oppose then it doesn?t matter that the
> > code is perfect. Documentation is generally done post merge if at all. For
> > most PRs e.g. refactors this makes sense. There is no point documenting
> > something in advance if it is still under review or may not get merged. For
> > consensus PRs this clearly doesn?t make sense. Many of us have and continue
> > to cross check the Taproot BIPs with the Taproot reference implementation
> > in Bitcoin Core. Having two points of reference released simultaneously is
> > treating consensus changes with the highest possible standards we can. I
> > think we should strive towards the highest possible standards for step
> > change default policy changes in Core too given L2 protocol security is
> > (unfortunately, ideally this wouldn?t be the case) relying on them.
> >
> > What are the new RBF rules replacing the BIP125 rules?
> >
> > The new RBF rules as implemented in Core today are documented here 3 in
> > the Core repo (thanks for the link glozow). To the extent that these are a
> > work in progress or close to final (i.e. intended to be static) I don?t
> > know. The devs who work on policy will have a much better idea on these
> > questions than me. Will the new RBF rules continue to be iterated upon as
> > new research on L2 security comes to light? Will this iteration make it
> > impossible to maintain a static set of rules that the broader ecosystem can
> > get comfortable with? Or is a new static set of RBF rules close to being
> > finalized and there is just an aversion to using BIPs and a specification?
> >
> > Generally, as time passes, the ecosystem grows, layers on top of the base
> > layer get built out I get uncomfortable with what I perceive (correctly or
> > incorrectly) as a slip in standards. If anything it should be going in the
> > opposite direction. Standards should be improving and we should be striving
> > to do better and be more rigorous than whatever the standard was in 2015.
> > But I don?t work on policy in Core full time and it is very possible that
> > there are subtleties that I?m entirely missing here. I think this is the
> > right forum to ask about those subtleties though. Thanks to those who work
> > on this important area.
> >
> > l
> >
> > nts.md
> >
> > --
> > Michael Folkson
> > Email: michaelfolkson at protonmail.com
> > Keybase: michaelfolkson
> > PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3

From luke at dashjr.org  Fri Aug  5 06:51:52 2022
From: luke at dashjr.org (Luke Dashjr)
Date: Fri, 5 Aug 2022 06:51:52 +0000
Subject: [bitcoin-dev] BIP-notatether-signedmessage
In-Reply-To: <oqwpWAHa9lo-RuyC8iwnUDDMmMmQjM3i3a2wuXkN0t3GeoGdTnHoHPH90_KkaVsogyrn2hTFbUN6XKR364K3jOnplsBoKW2AaWJZfBKBqz4=@notatether.com>
References: <4Lz70s3l79z4x2h7@mail-41103.protonmail.ch>
 <202208041926.37309.luke@dashjr.org>
 <oqwpWAHa9lo-RuyC8iwnUDDMmMmQjM3i3a2wuXkN0t3GeoGdTnHoHPH90_KkaVsogyrn2hTFbUN6XKR364K3jOnplsBoKW2AaWJZfBKBqz4=@notatether.com>
Message-ID: <202208050651.54991.luke@dashjr.org>

On Friday 05 August 2022 04:05:56 Ali Sherief wrote:
> Yeah, I have a specific reason to advance this first (emphasis on the word
> first).
>
> I briefly mentioned in the BIP that BIP322 has superior message
> verification capabilities. This is true, but it suffers from the drawback
> that wallets are not using it.

Likely because it is a draft and incomplete.

> Message signatures are highly relied upon in some places (just to name a
> few, at many mining pools e.g. Slushpool, and the Bitcointalk forum), 

I'm not aware of any using the current message signatures _correctly_.
Note they are not useful for proving that you sent a transaction, nor have the 
ability to send a transaction or access to bitcoins.

> This BIP is kind of like a "bumper car", in that it forces compliance with
> previous BIPs that extend the message signing format, in particular BIP137.

BIPs can't force anything, they're just documentation.

IMO, there is no benefit to an additional message signing standard, especially 
one that doesn't address the problems with the current standard or (at 
present) BIP322.

Luke

From ali at notatether.com  Fri Aug  5 04:05:56 2022
From: ali at notatether.com (Ali Sherief)
Date: Fri, 05 Aug 2022 04:05:56 +0000
Subject: [bitcoin-dev] BIP-notatether-signedmessage
In-Reply-To: <202208041926.37309.luke@dashjr.org>
References: <4Lz70s3l79z4x2h7@mail-41103.protonmail.ch>
 <20220804121851.7e4zoqxaaolseazn@artanis>
 <202208041926.37309.luke@dashjr.org>
Message-ID: <oqwpWAHa9lo-RuyC8iwnUDDMmMmQjM3i3a2wuXkN0t3GeoGdTnHoHPH90_KkaVsogyrn2hTFbUN6XKR364K3jOnplsBoKW2AaWJZfBKBqz4=@notatether.com>

Yeah, I have a specific reason to advance this first (emphasis on the word first).

I briefly mentioned in the BIP that BIP322 has superior message verification capabilities. This is true, but it suffers from the drawback that wallets are not using it. What they are using right now is a chaotic mixture of legacy address sign/verify and nonstandard segwit sign/verify. Attempting to enforce BIP322 on them in this stage will just create an N+1 problem, so an effort has to be made first to transfer these N signing implementations to a common ground, with as little as possible developer effort - it takes much less time to code the point-by-point steps than designing a class for BIP322 signatures, since the teams behind these wallets have to *agree* on how to code such a change. This ultimately decides whether or not the wallets implement such features as BIP322 or this BIP. [this paragraph is the meat of the reasoning.]

That is to say, BIP322 is more complex than this BIP (which in no way replaces BIP322), hence it requires a larger design effort on the part of wallet developers to implement. Considering that the vast majority of them already sign messages using the current format, it makes complete sense to make them all conform to this BIP first, then we finish BIP322, and then make wallets use that.

Message signatures are highly relied upon in some places (just to name a few, at many mining pools e.g. Slushpool, and the Bitcointalk forum), and it is unreasonable to expect users to cling on to an old address format, or use a specific wallet (Electrum) that provides nonstandard signature verification (it does *not* follow BIP137 despite supporting segwit messages, so their signatures are non-portable).

That is why it is necessary at the present moment to ensure as many wallets are possible are not only using the specification in my BIP to perform message signing and verification, but also implement, at a bare minimum, the legacy and segwit address parts. And the reason I did not mandate this requirement is the BIP is that wallets do not provide legacy addresses, then it makes no sense for them to add the sign/verify code for legacy addresses as well.

This BIP is kind of like a "bumper car", in that it forces compliance with previous BIPs that extend the message signing format, in particular BIP137. I admit that the Taproot signature format should not be located inside this BIP - I want to keep it strictly Informational, but rather, it should be contained in a newer Standards Track BIP that supersedes BIP137 - it's only task is to define everything BIP137 already defines, and  also add the Taproot signing format.

Like I said in the BIP, just making a proposal will not solve all these problems. It will only solve half of them, and the other half has to be solved by getting the other wallet implementations (Armory, Wasabi, BitcoinJ, Samourai, Mycelium, Electrum, and Trezor/Ledger among others) to implement this standard. It is not a difficult task but it's a non-trivial one, and we ought to be at least half-way to the finish line by assigning a number to this.

- Ali

------- Original Message -------
On Thursday, August 4th, 2022 at 10:26 PM, Luke Dashjr <luke at dashjr.org> wrote:


> Any reason not to just help Kalle out with BIP 322?
>
> https://github.com/bitcoin/bips/pull/1347
>
>
> On Thursday 04 August 2022 12:18:56 Ali Sherief via bitcoin-dev wrote:
>
> > Hi,
> >
> > I have created a new BIP, called notatether-signedmessage. It can be viewed
> > at
> > https://github.com/ZenulAbidin/bips/blob/master/bip-notatether-signedmessag
> > e.mediawiki.
> >
> > For those who want a quick summary, it defines a step-by-step process for
> > signing and verifying messages from legacy, native/nested segwit, and
> > taproot addresses. It does not define a new signature format itself, except
> > in the case of Taproot. For those addresses, I have defined a signature
> > format that has 1 byte header/recID, 64 bytes signature, and 32 bytes x
> > coordinate of a public key. This is required to run the BIP340 Schnorr
> > verify algorithm using only the signature - and the header byte is added
> > for backwards compatibility. Otherwise, it completely integrates BIP137
> > signatures.
> >
> > I am planning to move that format to its own BIP as soon as possible, in
> > lieu that it is unacceptable to define formats in an Informational BIP.
> >
> > Please leave your comments in this mailing list. CC'ing BIP editors.
> >
> > - Ali
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From ali at notatether.com  Fri Aug  5 07:39:38 2022
From: ali at notatether.com (Ali Sherief)
Date: Fri, 05 Aug 2022 07:39:38 +0000
Subject: [bitcoin-dev] BIP-notatether-signedmessage
In-Reply-To: <202208050651.54991.luke@dashjr.org>
References: <4Lz70s3l79z4x2h7@mail-41103.protonmail.ch>
 <202208041926.37309.luke@dashjr.org>
 <oqwpWAHa9lo-RuyC8iwnUDDMmMmQjM3i3a2wuXkN0t3GeoGdTnHoHPH90_KkaVsogyrn2hTFbUN6XKR364K3jOnplsBoKW2AaWJZfBKBqz4=@notatether.com>
 <202208050651.54991.luke@dashjr.org>
Message-ID: <Kooyh1Wd0qc2Z5wXutB6dZqImcZN2WiZJHVxKbby3x1_glXfppmpDwW7Q8ON44yrznIVdQHlWpmM0Kh32PzyiHyRtcVlBBtJWfrk0PW3e9Y=@notatether.com>

> IMO, there is no benefit to an additional message signing standard, especially
> one that doesn't address the problems with the current standard or (at
> present) BIP322.

In that case, I propose the following:

- I scrap the Taproot/Schorr and the two extensions inside the BIP, which will leave it with only parts and formats which have already been standardized (effectively, the legacy and segwit addresses).

Because here's the thing: The reason why wallets are not implementing sign/verify correctly is because there is no reference manual for doing so. This informational BIP is supposed to solve that problem by providing only a list of instructions for computing ECSDA sign/verify correctly.

Also, it is not visible right now, but there will also be a reference implementation so that wallet developers can actually code them correctly, as you've stated.

- Ali

On Fri, Aug 5, 2022 at 9:51 AM, Luke Dashjr <luke at dashjr.org> wrote:

> On Friday 05 August 2022 04:05:56 Ali Sherief wrote:
>> Yeah, I have a specific reason to advance this first (emphasis on the word
>> first).
>>
>> I briefly mentioned in the BIP that BIP322 has superior message
>> verification capabilities. This is true, but it suffers from the drawback
>> that wallets are not using it.
>
> Likely because it is a draft and incomplete.
>
>> Message signatures are highly relied upon in some places (just to name a
>> few, at many mining pools e.g. Slushpool, and the Bitcointalk forum),
>
> I'm not aware of any using the current message signatures _correctly_.
> Note they are not useful for proving that you sent a transaction, nor have the
> ability to send a transaction or access to bitcoins.
>
>> This BIP is kind of like a "bumper car", in that it forces compliance with
>> previous BIPs that extend the message signing format, in particular BIP137.
>
> BIPs can't force anything, they're just documentation.
>
> IMO, there is no benefit to an additional message signing standard, especially
> one that doesn't address the problems with the current standard or (at
> present) BIP322.
>
> Luke
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220805/bc680629/attachment.html>

From ali at notatether.com  Fri Aug  5 07:50:17 2022
From: ali at notatether.com (Ali Sherief)
Date: Fri, 05 Aug 2022 07:50:17 +0000
Subject: [bitcoin-dev] BIP-notatether-signedmessage (appendix)
Message-ID: <q-wyD4WemLRDZ1-QWcqtJoYnuqJFLMnxKRYgAjqAMoMpI2S6h2S5LB1oVIxw9tTAJrX3wvzYAH0dJCHxhUVrFK9DiVoOV86l7sOR7O2WLb0=@notatether.com>

Also, I forgot to write in the previous message, that this BIP is not a standard - that's the reason I raised the N+1 problem in the first place. As mentioned previously, it's strictly limited to a reference manual - which could've been hosted anywhere else (such as my own website), but these instructions ought to be made official.

- Ali
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220805/e37472b7/attachment.html>

From stick at satoshilabs.com  Fri Aug  5 09:12:20 2022
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Fri, 5 Aug 2022 11:12:20 +0200
Subject: [bitcoin-dev] BIP-notatether-signedmessage
In-Reply-To: <20220804121851.7e4zoqxaaolseazn@artanis>
References: <4Lz70s3l79z4x2h7@mail-41103.protonmail.ch>
 <20220804121851.7e4zoqxaaolseazn@artanis>
Message-ID: <CAF90AvmxH-fr1qnL7McdvBs56N5G-q8OYLj+dmBGSVm38F=Urg@mail.gmail.com>

Hi Ali!

Nice work. Since it seems this is a strict superset of BIP137, why not just
focus on things that you are adding (Taproot) while saying your BIP is an
expansion of BIP137?

Your approach make it unnecessarily hard to figure out whether you are
changing anything in handling of ECDSA signature types or not. If it was
clearly stated you are just expanding BIP137 and removes everything that?s
already described in BIP137, it would be much more obvious to everyone.


On Thu 4. 8. 2022 at 17:49, Ali Sherief via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi,
>
> I have created a new BIP, called notatether-signedmessage. It can be
> viewed at
> https://github.com/ZenulAbidin/bips/blob/master/bip-notatether-signedmessage.mediawiki
> .
>
> For those who want a quick summary, it defines a step-by-step process for
> signing and verifying messages from legacy, native/nested segwit, and
> taproot addresses. It does not define a new signature format itself, except
> in the case of Taproot. For those addresses, I have defined a signature
> format that has 1 byte header/recID, 64 bytes signature, and 32 bytes x
> coordinate of a public key. This is required to run the BIP340 Schnorr
> verify algorithm using only the signature - and the header byte is added
> for backwards compatibility. Otherwise, it completely integrates BIP137
> signatures.
>
> I am planning to move that format to its own BIP as soon as possible, in
> lieu that it is unacceptable to define formats in an Informational BIP.
>
> Please leave your comments in this mailing list. CC'ing BIP editors.
>
> - Ali
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-- 
Best Regards / S pozdravom,

Pavol "stick" Rusnak
Co-Founder, SatoshiLabs
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220805/a38c1a1d/attachment-0001.html>

From ali at notatether.com  Fri Aug  5 10:52:41 2022
From: ali at notatether.com (Ali Sherief)
Date: Fri, 05 Aug 2022 10:52:41 +0000
Subject: [bitcoin-dev] BIP-notatether-signedmessage
In-Reply-To: <CAF90AvmxH-fr1qnL7McdvBs56N5G-q8OYLj+dmBGSVm38F=Urg@mail.gmail.com>
References: <4Lz70s3l79z4x2h7@mail-41103.protonmail.ch>
 <20220804121851.7e4zoqxaaolseazn@artanis>
 <CAF90AvmxH-fr1qnL7McdvBs56N5G-q8OYLj+dmBGSVm38F=Urg@mail.gmail.com>
Message-ID: <9vqLLpbcv5ONaeH7cpgqtYgyC7fvWYGH45UYUyaWm0lNwfpkomeadfv2rBP4Wa44hBSxWp3OtBfIbY2On0Y9O9mIp3tV0PaCUetA2hg03W0=@notatether.com>

That's actually a good idea. Perhaps I can move the algorithms (of BIP137) and stuff to Bitcoin Wiki, and then convert the BIP to strictly a "Taproot message signing BIP".

Even though I already know the chances of such a BIP being numbered is low, at least the most important part will be accomplished already (get everybody to use BIP137, and later once BIP322 is finished make people use that).

I ultimately prefer that everyone should use BIP322 eventually, though it should have some kind of RFC2440-like format for maximum user-friendliness. Perhaps bit by bit, the message sanitization can be introduced as well.

- Ali

On Fri, Aug 5, 2022 at 12:12 PM, Pavol Rusnak <stick at satoshilabs.com> wrote:

> Hi Ali!
>
> Nice work. Since it seems this is a strict superset of BIP137, why not just focus on things that you are adding (Taproot) while saying your BIP is an expansion of BIP137?
>
> Your approach make it unnecessarily hard to figure out whether you are changing anything in handling of ECDSA signature types or not. If it was clearly stated you are just expanding BIP137 and removes everything that?s already described in BIP137, it would be much more obvious to everyone.
>
> On Thu 4. 8. 2022 at 17:49, Ali Sherief via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Hi,
>>
>> I have created a new BIP, called notatether-signedmessage. It can be viewed at https://github.com/ZenulAbidin/bips/blob/master/bip-notatether-signedmessage.mediawiki.
>>
>> For those who want a quick summary, it defines a step-by-step process for signing and verifying messages from legacy, native/nested segwit, and taproot addresses. It does not define a new signature format itself, except in the case of Taproot. For those addresses, I have defined a signature format that has 1 byte header/recID, 64 bytes signature, and 32 bytes x coordinate of a public key. This is required to run the BIP340 Schnorr verify algorithm using only the signature - and the header byte is added for backwards compatibility. Otherwise, it completely integrates BIP137 signatures.
>>
>> I am planning to move that format to its own BIP as soon as possible, in lieu that it is unacceptable to define formats in an Informational BIP.
>>
>> Please leave your comments in this mailing list. CC'ing BIP editors.
>>
>> - Ali
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> --
>
> Best Regards / S pozdravom,
>
> Pavol "stick" Rusnak
> Co-Founder, SatoshiLabs
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220805/328ff3cb/attachment.html>

From alicexbt at protonmail.com  Fri Aug  5 14:44:52 2022
From: alicexbt at protonmail.com (alicexbt)
Date: Fri, 05 Aug 2022 14:44:52 +0000
Subject: [bitcoin-dev] P2P trading replacement transactions
Message-ID: <AnStgXF197_nYPr6hRYS8w4aAHnBLqxhxJdQTFk_wtJmxlnqv0AJMdHtKuuYCXFMfvcTOyTDvbg75q7aq45NVMLbRKUOb_5DW87wv8Aw5q8=@protonmail.com>

Hi Bitcoin Developers,

Does it make sense to trade replacement transactions for privacy? I have shared basic details to implement this and would love to read opinions about it or ways to improve it:

=============================
alice
=============================

tx1: input a (0.01) -> output b1 (0.008)
-> change c1 (0.001)

tx2: input a (0.01) -> output e2 (0.007)
-> output f2 (0.001)

=============================

bob
=============================

tx1: input d (0.011) -> output e1 (0.007)
-> change f1 (0.003)

tx2: input d (0.011) -> output b2 (0.008)
-> output c2 (0.001)

=============================

carol
=============================

- creates an API to manage trades that will use 2 of 3 multisig
- alice and bob create orders for replacement
- either they could be matched automatically using some algorithm or bob manually accepts the offer
- 2 of 3 multisig is created with Alice, Bob and Carol keys
- bob locks 0.01 BTC in it and shares outputs e2,f2 with alice
- alice signs tx2 and shares tx with bob
- alice locks 0.011 BTC in it and shares outputs b2,c2 with bob
- bob signs tx2 and shares with alice
- both replacement txs can be broadcasted
- funds are released from 2 of 3 multisig with a tx having 3 outputs (one to pay fee which goes to carol)

positives:

- privacy

negatives:

- extra fees
- will take some time although everything will be managed by wallet with API provided by carol
- need to lock bitcoin with same amount as used in tx1
- amounts could still be used to link txs in some cases- carol and other peer knows the details

/dev/fd0

Sent with [Proton Mail](https://proton.me/) secure email.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220805/f3f782bd/attachment.html>

From michaelfolkson at protonmail.com  Sat Aug  6 12:55:49 2022
From: michaelfolkson at protonmail.com (Michael Folkson)
Date: Sat, 06 Aug 2022 12:55:49 +0000
Subject: [bitcoin-dev] P2P trading replacement transactions
In-Reply-To: <AnStgXF197_nYPr6hRYS8w4aAHnBLqxhxJdQTFk_wtJmxlnqv0AJMdHtKuuYCXFMfvcTOyTDvbg75q7aq45NVMLbRKUOb_5DW87wv8Aw5q8=@protonmail.com>
References: <AnStgXF197_nYPr6hRYS8w4aAHnBLqxhxJdQTFk_wtJmxlnqv0AJMdHtKuuYCXFMfvcTOyTDvbg75q7aq45NVMLbRKUOb_5DW87wv8Aw5q8=@protonmail.com>
Message-ID: <0wIl0PIW3Ah3Dg2_oRxpyQx6hJdGm9DbtSMJtePJ--_sKql5u17M4nxQmYfxqT_r1ztlvU5jH2jdpA15STtwFAsdkFnKRgpxuHDa9rqtcig=@protonmail.com>

Hi alicexbt

What do you mean by "replacement transaction"? Replacing or swapping outputs with a counterparty's?

I guess I'm struggling to understand exactly what you are attempting to achieve here with regards to privacy and if this additional protocol complexity is worth it. Recall a 2 (or n) party coinjoin would get you an output where it isn't clear to blockchain observers which output you control and a coinswap [0] would have you taking the coin history of your counterparty. What does this scheme offer with regards to privacy that those don't? This seems to have more complexity too though I maybe misunderstanding something.

Thanks
Michael

[0]: https://bitcoinops.org/en/topics/coinswap/

--
Michael Folkson
Email: michaelfolkson at [protonmail.com](http://protonmail.com/)
Keybase: michaelfolkson
PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3

------- Original Message -------
On Friday, August 5th, 2022 at 15:44, alicexbt via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi Bitcoin Developers,
>
> Does it make sense to trade replacement transactions for privacy? I have shared basic details to implement this and would love to read opinions about it or ways to improve it:
>
> =============================
> alice
> =============================
>
> tx1: input a (0.01) -> output b1 (0.008)
> -> change c1 (0.001)
>
> tx2: input a (0.01) -> output e2 (0.007)
> -> output f2 (0.001)
>
> =============================
>
> bob
> =============================
>
> tx1: input d (0.011) -> output e1 (0.007)
> -> change f1 (0.003)
>
> tx2: input d (0.011) -> output b2 (0.008)
> -> output c2 (0.001)
>
> =============================
>
> carol
> =============================
>
> - creates an API to manage trades that will use 2 of 3 multisig
> - alice and bob create orders for replacement
> - either they could be matched automatically using some algorithm or bob manually accepts the offer
> - 2 of 3 multisig is created with Alice, Bob and Carol keys
> - bob locks 0.01 BTC in it and shares outputs e2,f2 with alice
> - alice signs tx2 and shares tx with bob
> - alice locks 0.011 BTC in it and shares outputs b2,c2 with bob
> - bob signs tx2 and shares with alice
> - both replacement txs can be broadcasted
> - funds are released from 2 of 3 multisig with a tx having 3 outputs (one to pay fee which goes to carol)
>
> positives:
>
> - privacy
>
> negatives:
>
> - extra fees
> - will take some time although everything will be managed by wallet with API provided by carol
> - need to lock bitcoin with same amount as used in tx1
> - amounts could still be used to link txs in some cases- carol and other peer knows the details
>
> /dev/fd0
>
> Sent with [Proton Mail](https://proton.me/) secure email.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220806/efb828d3/attachment.html>

From pete at petertodd.org  Thu Aug  4 18:06:34 2022
From: pete at petertodd.org (Peter Todd)
Date: Thu, 4 Aug 2022 14:06:34 -0400
Subject: [bitcoin-dev] RBF rules,
 setting policy defaults in Bitcoin Core and the role of BIPs
In-Reply-To: <zl3fWujFF4mSjfXz_d1gA73ALTnN_LaaGKyidRR6azX9toY2-j7cUkfVcU1ggIhJ0cjK9oA4q1jF5mDob6bdlDp4yaWHZKxxev-zjUQBqTk=@protonmail.com>
References: <zl3fWujFF4mSjfXz_d1gA73ALTnN_LaaGKyidRR6azX9toY2-j7cUkfVcU1ggIhJ0cjK9oA4q1jF5mDob6bdlDp4yaWHZKxxev-zjUQBqTk=@protonmail.com>
Message-ID: <YuwKqnfj0MyXhbE6@petertodd.org>

On Thu, Aug 04, 2022 at 02:54:54PM +0000, Michael Folkson via bitcoin-dev wrote:
> A short history of RBF and BIP125
> 
> The history of BIP125 is as far as I?m aware this. RBF rules were merged into Bitcoin Core in November 2015 [0]. Following that merge David Harding and Peter Todd drafted a BIP (BIP125 [1]) outlining the RBF rules that had been implemented in Bitcoin Core. The rationales for the rules in the BIP was a bit lacking (in my opinion) but recall this is 2015 (7 years ago!) when L2 protocols were in their infancy. Certainly the research on the security of L2 protocols has come a long way since and we have a much better idea of some of the possible attacks on L2 protocols that to some extent are impacted by policy rules.
> 
> In addition it was discovered [2] in May 2021 that the Bitcoin Core implementation of the RBF rules had never matched the RBF rules outlined in BIP125. Clearly this isn?t ideal but mistakes happen and will continue to happen. I certainly do not intend any criticism whatsoever to any of the individuals involved. Thankfully this discrepancy doesn?t seem to have resulted in any loss of funds or disruption. However, cross checking a specification with an implementation presumably led to the discovery and allowed for a post mortem on why the implementation didn?t match the specification.
> 
> There seems to be two views on what to do next given that the RBF rules need to be updated. One is to ditch the idea of a specification for RBF rules and just document them in the Core repo instead. The other is to have a new specification for the RBF rules in Core and attempt to correct the mistakes made with BIP125 by having a BIP that does correctly outline the RBF rules implemented in Core and includes detailed rationales for why those RBF rules have been implemented.
> 
> Should anyone care about where things are documented?

They really shouldn't.

The nature of L2 punishment protocols is that transaction relay schemes are
additive security: every different way that a punishment tx could get broadcast
and mined is a different way that the punishment scheme could succeed. We
should be thinking about how to add diversity and robustness to this in the
form of different schemes, rather than trying to specify exactly how we expect
these txs to be broadcast. In particular, you have to accept that different
schemes will exist, and an adversary could use those schems.

For the near-term, an important part of this is to get package relay and
package replacements implemented, to avoid edge-cases in multiple-tx schemes.
It'd also be good to specify something entirely different, like a hashcase
based broadcast scheme.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220804/20f1b1fa/attachment.sig>

From alicexbt at protonmail.com  Sat Aug  6 14:11:34 2022
From: alicexbt at protonmail.com (alicexbt)
Date: Sat, 06 Aug 2022 14:11:34 +0000
Subject: [bitcoin-dev] P2P trading replacement transactions
In-Reply-To: <0wIl0PIW3Ah3Dg2_oRxpyQx6hJdGm9DbtSMJtePJ--_sKql5u17M4nxQmYfxqT_r1ztlvU5jH2jdpA15STtwFAsdkFnKRgpxuHDa9rqtcig=@protonmail.com>
References: <AnStgXF197_nYPr6hRYS8w4aAHnBLqxhxJdQTFk_wtJmxlnqv0AJMdHtKuuYCXFMfvcTOyTDvbg75q7aq45NVMLbRKUOb_5DW87wv8Aw5q8=@protonmail.com>
 <0wIl0PIW3Ah3Dg2_oRxpyQx6hJdGm9DbtSMJtePJ--_sKql5u17M4nxQmYfxqT_r1ztlvU5jH2jdpA15STtwFAsdkFnKRgpxuHDa9rqtcig=@protonmail.com>
Message-ID: <iVoLUAO7oCaStdF9B8PGaGBdi75bFM2AyxSFKP8mkTzYDqxu22wrzcI7OWH8n-6KEhD7PQqDwg89pkfbyxkzLfaTiHK67dvDzFRlo6CjP68=@protonmail.com>

Hi Michael,


> What do you mean by "replacement transaction"? Replacing or swapping outputs with a counterparty's?

User broadcasts tx1 which is in mempool, wants to replace transaction with higher fee rate however changes outputs and they are replaced with counterparty's outputs in tx2.


> I guess I'm struggling to understand exactly what you are attempting to achieve here with regards to privacy and if this additional protocol complexity is worth it. Recall a 2 (or n) party coinjoin would get you an output where it isn't clear to blockchain observers which output you control and a coinswap [0] would have you taking the coin history of your counterparty. What does this scheme offer with regards to privacy that those don't? This seems to have more complexity too though I maybe misunderstanding something.

Coinjoin and Coinswap offer different levels of privacy. This method just aims to break the assumption that tx2 (replacement transaction) is done to use a higher fee rate with same sender and recipient. It looks complex in the way I wrote in the last email or maybe because of implementation details although UX will be simple and something like this:

- user sends bitcoin in tx1 which is unconfirmed
- tries to bump fee
- wallet offer an extra privacy option
- if user selects it, everything happens in the background and user just needs to approve in between
- user broadcasts tx2 to replace tx1 which has outputs shared by counterparty
- counterparty does the same for this user

If this method makes sense or we have a similar market to trade replacements in future, it could be helpful in creating a process in which a chain of replacements happen before bitcoin reaches the destination similar to tor circuit.

Example:

- tx1 enters a pool
- gets replaced by tx2 (different outputs)
- tx3 replaces tx2 (different outputs)

We could look at the logs and see tx3 originated at tx1 but no clue if original recipient received it in the end. There would be normal replacements done by other users so it would make analysis difficult.


/dev/fd0

Sent with Proton Mail secure email.

------- Original Message -------
On Saturday, August 6th, 2022 at 6:25 PM, Michael Folkson <michaelfolkson at protonmail.com> wrote:


> Hi alicexbt
>
> What do you mean by "replacement transaction"? Replacing or swapping outputs with a counterparty's?
>
> I guess I'm struggling to understand exactly what you are attempting to achieve here with regards to privacy and if this additional protocol complexity is worth it. Recall a 2 (or n) party coinjoin would get you an output where it isn't clear to blockchain observers which output you control and a coinswap [0] would have you taking the coin history of your counterparty. What does this scheme offer with regards to privacy that those don't? This seems to have more complexity too though I maybe misunderstanding something.
>
> Thanks
> Michael
>
> [0]:?https://bitcoinops.org/en/topics/coinswap/
>
> --
> Michael Folkson
> Email: michaelfolkson at protonmail.com
> Keybase: michaelfolkson
> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3
>
>
> ------- Original Message -------
> On Friday, August 5th, 2022 at 15:44, alicexbt via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>
> > Hi Bitcoin Developers,
> >
> >
> > Does it make sense to trade replacement transactions for privacy? I have shared basic details to implement this and would love to read opinions about it or ways to improve it:
> >
> >
> > =============================
> > alice=============================
> >
> > tx1: input a (0.01) -> output b1 (0.008)
> > ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?-> change c1 (0.001)
> >
> > tx2: input a (0.01) -> output e2 (0.007)
> > ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?-> output f2 (0.001)
> >
> >
> > =============================
> >
> > bob
> > =============================
> >
> >
> > tx1: input d (0.011) -> output e1 (0.007)
> > ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? -> change f1 (0.003)
> >
> > tx2: input d (0.011) -> output b2 (0.008)
> > ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?-> output c2 (0.001)
> >
> >
> > =============================
> >
> > carol
> > =============================
> >
> >
> > - creates an API to manage trades that will use 2 of 3 multisig
> > - alice and bob create orders for replacement
> > - either they could be matched automatically using some algorithm or bob manually accepts the offer
> > - 2 of 3 multisig is created with Alice, Bob and Carol keys
> > - bob locks 0.01 BTC in it and shares outputs e2,f2 with alice
> > - alice signs tx2 and shares tx with bob
> > - alice locks 0.011 BTC in it and shares outputs b2,c2 with bob
> > - bob signs tx2 and shares with alice
> > - both replacement txs can be broadcasted
> > - funds are released from 2 of 3 multisig with a tx having 3 outputs (one to pay fee which goes to carol)
> >
> >
> >
> > positives:
> >
> > - privacy
> >
> > negatives:
> >
> > - extra fees
> > - will take some time although everything will be managed by wallet with API provided by carol
> > - need to lock bitcoin with same amount as used in tx1
> > - amounts could still be used to link txs in some cases
> > - carol and other peer knows the details
> >
> >
> >
> >
> > /dev/fd0
> >
> >
> >
> >
> > Sent with Proton Mail secure email.

From ali at notatether.com  Sat Aug  6 14:16:08 2022
From: ali at notatether.com (Ali Sherief)
Date: Sat, 06 Aug 2022 14:16:08 +0000
Subject: [bitcoin-dev] P2P trading replacement transactions
Message-ID: <cCBE17DWdE1SwIRUAqPqloBufMQXlsUyVbHFiNsPfD2CTDI0RLJ2MboLNp2-BisB8BvEk8-lcIhnPJ7x8yazg55qFh0dLT6grisXGpS7iMI=@notatether.com>

It would probably only work out if each output got their own private keys, since otherwise Alice can't share any outputs with Bob and vice versa.

The whole thing sounds like an HTLC with an additional trading of private keys for the actual trades instead of in the HLTC. How are they going to share their private keys securely, with PGP?

Perhaps Taproot with its selective revealing of certain script branches can help here, but I'm not sure about details.

- Ali

> Hi Bitcoin Developers,
>
> Does it make sense to trade replacement transactions for privacy? I have shared basic details to implement this and would love to read opinions about it or ways to improve it:
>
> =============================
> alice
> =============================
>
> tx1: input a (0.01) -> output b1 (0.008)
> -> change c1 (0.001)
>
> tx2: input a (0.01) -> output e2 (0.007)
> -> output f2 (0.001)
>
> =============================
>
> bob
> =============================
>
> tx1: input d (0.011) -> output e1 (0.007)
> -> change f1 (0.003)
>
> tx2: input d (0.011) -> output b2 (0.008)
> -> output c2 (0.001)
>
> =============================
>
> carol
> =============================
>
> - creates an API to manage trades that will use 2 of 3 multisig
> - alice and bob create orders for replacement
> - either they could be matched automatically using some algorithm or bob manually accepts the offer
> - 2 of 3 multisig is created with Alice, Bob and Carol keys
> - bob locks 0.01 BTC in it and shares outputs e2,f2 with alice
> - alice signs tx2 and shares tx with bob
> - alice locks 0.011 BTC in it and shares outputs b2,c2 with bob
> - bob signs tx2 and shares with alice
> - both replacement txs can be broadcasted
> - funds are released from 2 of 3 multisig with a tx having 3 outputs (one to pay fee which goes to carol)
>
> positives:
>
> - privacy
>
> negatives:
>
> - extra fees
> - will take some time although everything will be managed by wallet with API provided by carol
> - need to lock bitcoin with same amount as used in tx1
> - amounts could still be used to link txs in some cases- carol and other peer knows the details
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220806/40970fa9/attachment.html>

From alicexbt at protonmail.com  Mon Aug  8 13:12:44 2022
From: alicexbt at protonmail.com (alicexbt)
Date: Mon, 08 Aug 2022 13:12:44 +0000
Subject: [bitcoin-dev] P2P trading replacement transactions
In-Reply-To: <cCBE17DWdE1SwIRUAqPqloBufMQXlsUyVbHFiNsPfD2CTDI0RLJ2MboLNp2-BisB8BvEk8-lcIhnPJ7x8yazg55qFh0dLT6grisXGpS7iMI=@notatether.com>
References: <cCBE17DWdE1SwIRUAqPqloBufMQXlsUyVbHFiNsPfD2CTDI0RLJ2MboLNp2-BisB8BvEk8-lcIhnPJ7x8yazg55qFh0dLT6grisXGpS7iMI=@notatether.com>
Message-ID: <LgC5GTzL4kUdL6migemWihshdRiJyE5ReckkvDLv2EoKb0LN1agDYeyF9yHHFbzVwHUcONNUn2OIiF-nMHmHhOCGHHUlbuHrbkJJE8fCooY=@protonmail.com>

Hi Ali,

> It would probably only work out if each output got their own private keys, since otherwise Alice can't share any outputs with Bob and vice versa.
> The whole thing sounds like an HTLC with an additional trading of private keys for the actual trades instead of in the HLTC. How are they going to share their private keys securely, with PGP?

Alice and Bob can share outputs and these are swapped in the replacement transactions. A 2of3 multisig and Carol is required so that nobody cheats. Trading of private keys is not required. I have explained things in a different way in my [last email][1] sent to Michael Folkson.

[1]: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-August/020841.html

/dev/fd0

Sent with Proton Mail secure email.

------- Original Message -------
On Saturday, August 6th, 2022 at 7:46 PM, Ali Sherief <ali at notatether.com> wrote:


> It would probably only work out if each output got their own private keys, since otherwise Alice can't share any outputs with Bob and vice versa.
>
> The whole thing sounds like an HTLC with an additional trading of private keys for the actual trades instead of in the HLTC. How are they going to share their private keys securely, with PGP?
> Perhaps Taproot with its selective revealing of certain script branches can help here, but I'm not sure about details.
> - Ali
>
>
> > Hi Bitcoin Developers,
> >
> > Does it make sense to trade replacement transactions for privacy? I have shared basic details to implement this and would love to read opinions about it or ways to improve it:
> >
> > =============================
> > alice
> > =============================
> >
> > tx1: input a (0.01) -> output b1 (0.008)
> > -> change c1 (0.001)
> >
> > tx2: input a (0.01) -> output e2 (0.007)
> > -> output f2 (0.001)
> >
> > =============================
> >
> > bob
> > =============================
> >
> > tx1: input d (0.011) -> output e1 (0.007)
> > -> change f1 (0.003)
> >
> > tx2: input d (0.011) -> output b2 (0.008)
> > -> output c2 (0.001)
> >
> > =============================
> >
> > carol
> > =============================
> >
> > - creates an API to manage trades that will use 2 of 3 multisig
> > - alice and bob create orders for replacement
> > - either they could be matched automatically using some algorithm or bob manually accepts the offer
> > - 2 of 3 multisig is created with Alice, Bob and Carol keys
> > - bob locks 0.01 BTC in it and shares outputs e2,f2 with alice
> > - alice signs tx2 and shares tx with bob
> > - alice locks 0.011 BTC in it and shares outputs b2,c2 with bob
> > - bob signs tx2 and shares with alice
> > - both replacement txs can be broadcasted
> > - funds are released from 2 of 3 multisig with a tx having 3 outputs (one to pay fee which goes to carol)
> >
> > positives:
> >
> > - privacy
> >
> > negatives:
> >
> > - extra fees
> > - will take some time although everything will be managed by wallet with API provided by carol
> > - need to lock bitcoin with same amount as used in tx1
> > - amounts could still be used to link txs in some cases- carol and other peer knows the details
>
>
>

From ali at notatether.com  Tue Aug  9 13:09:13 2022
From: ali at notatether.com (Ali Sherief)
Date: Tue, 09 Aug 2022 13:09:13 +0000
Subject: [bitcoin-dev] Regarding BIP322 edge cases
Message-ID: <20220809130908.yykum37tre7um4j3@artanis>

Although there is a Github issue/PR at https://github.com/bitcoin/bips/pull/1347 for addressing all the TODO items of BIP322, I decided to throw it in the mailing list again to see if anyone else has suggestions for dealing with them.

So in an older copy of the draft at https://github.com/bitcoin/bips/blob/b6b0126e2d04793ba52a40f05d24538fa3f2c9ad/bip-0322.mediawiki , I found the some TODO items, and I will copy-paste the ones in the Specification section (for full proofs) here:

> TODO: How does this interact with as-of-yet-unspecified "Silent Transactions"?
> TODO: Some invalid opcode to allow only in various proof types?
> TODO: A way for the initial signer to delegate to another scriptPubKey; needed for better privacy and CoinJoin/Lightning compatibility

So to start with, I believe it will be very helpful to limit what opcodes scriptPubKeys to be elligible to sign from them. The specification already does so to a point, but in order for these to be recognizable, it's my opinion that one of the NOPs should be placed at the beginning of the script to activate proof parsing mode.

Of course, an opcode is not necessary at all, if the program is able to infer from context where the proof is coming from. After all, since they cannot be broadcasted, they can't be mined in blocks, so will never be encountered in a full node's usual verifier. I'm not sure what is to be gained from adding an opcode - the only source for real transactions is from P2P-obtained blocks, so when a human inputs a signature to be verified, it can check that a real transaction is not being inserted by looking for the invalid input.

For Silent Transactions, I have already given my suggestion in the PR, that some subsection can be made saying that it can operate with them by using its scriptPubKey (and other stuff that may be necessary - I am not excatly sure what goes inside the Witness stack of message_signature).

In the case of the last TODO, related to delegation to another scriptPubKey, I am not quite sure at the moment what to do about it - perhaps you guys can place a MAST (two Merkle branches, to be specific) - the first branch has the original signer's scriptPubKey, the second branch contains the delegated signer's scriptPubKey.

- Ali


From antoine.riard at gmail.com  Tue Aug  9 20:15:35 2022
From: antoine.riard at gmail.com (Antoine Riard)
Date: Tue, 9 Aug 2022 16:15:35 -0400
Subject: [bitcoin-dev] On a new community process to specify covenants
In-Reply-To: <CAGpPWDbbZ7PEpr4iwYwBn+5QcjjCx8qmTZVB98i2Z=UwDfwaTQ@mail.gmail.com>
References: <CALZpt+FhpZETHP8UpDGgw-Wg=m4Hxm8y9XZ9kXYgmt90_6Zt6w@mail.gmail.com>
 <CAHUJnBDu+PNvER-FmpT8593vX-wAZ1oPWJjQaJ=d7Y4pso_Txw@mail.gmail.com>
 <CALZpt+E4Ej3KJ4WqkUDTF3DRhPTbUT5mw2c_eHLuxH7w1BbWGg@mail.gmail.com>
 <CAHUJnBB1wExgJhHUeU88ZMD28s6+9UT3Cfc43_UpK40hJwUFSg@mail.gmail.com>
 <CAGpPWDbbZ7PEpr4iwYwBn+5QcjjCx8qmTZVB98i2Z=UwDfwaTQ@mail.gmail.com>
Message-ID: <CALZpt+HWzZdwMrtX=8rMpZ+e5dWcmbMeEx3jhTB_XnWz1n7RJQ@mail.gmail.com>

Hi Billy,

Thanks for your interest in a covenant working group.

> place for this kind of thing to happen. I also agree with Ryan Grant's
> comment about in-person cut-through (ie cut through the BS and resolve
> misunderstandings). Perhaps every 3 IRC meetings or so, an in-person
meetup
> can be organized in various locations to facilitate that kind of cut
> through.

I really appreciate in-person cut-through to resolve misunderstandings and
accelerate the information synchronization across the stakeholders of a
problem space. However, I would like to note it's real work for the
organizers in terms of time and energy: finding a common date making
consensus, an acceptable host country (i.e respecting the travel policy of
the widest, e.g organizing Scaling in Israel in 2019 was an issue for some
passport holders), a standard meeting location, seeking event sponsors,
communicating all those infos well ahead to ease everyone travels, ensuring
coffees & foods suiting many different diets, collecting topics of
discussions, etc. Further, even assuming travel support, it can still be a
prohibitive cost for a lot of participants, e.g if you have to request
months ahead to the host country authorities a dedicated visa for the
opportunity. I did a bit of in-person meetings organizing in the past, I'm
clearly not interested in doing it anymore, though it would be cool if
someone would like to do it for covenants in the future.

> I would imagine the phases the group could go through is:
> 1. Define the phases (these phases). This list of 6 phases could be a
> starting point, but its probably best to open the floor to whether this
> feels like a reasonable approach and if more phases are needed or if some
> aren't.
> 2. Define and prioritize the motivations (ie the various features and
> functionality we want out of covenants, like the ones you listed). By
> prioritize, I mostly mean figure out which motivations are most motivating
> to people and rate them by strength of motivation (rather than a ranked
> list).
> 3. Define and prioritize the relevant constraints. These are things to
> avoid in any covenant implementation. Constraints that have been brought
up
> in the past are things like preventing the possibility of infinite
covenant
> recursion, full enumeration, preventing dynamic state, etc. By prioritize
> here, it might be useful to categorize them into categories like "no
> tolerance", "some tolerance", "no reservations". Eg it might turn out most
> people don't have any tolerance for infinite recursion, but don't mind
> non-full enumeration.
> 4. Other criteria? These are other criteria we might want to evaluate
> proposals according to. And some kind of way to prioritize them / evaluate
> them against each other as trade offs.
> 5. Evaluate the proposals based on motivations, constraints, and other
> criteria. This phase shouldn't involve comparing them to each other.
> 6. Produce a set of conclusions/opinions on which proposals are worth
> pursuing further. This would be the phase where proposals are compared.

Yes, I think overall a lot is making sense. Though it's good to keep things
as loose and see how it evaluates with time and new information showing up.

About 2., I think one more thing to define is the list of use-cases, I
would abstract out features and functionality from use-cases. E.g, I think
with the TLUV proposal, the taproot output editing feature enables both
"dynamic-amount" vault and scaling payment pools.

About 3., I think this is going to be the hard part. Collecting all the
constraints and evaluating the risk tolerance of as-much-as-we-can
community stakeholders in face of known and plausible risks. E.g, again
with TLUV, I think it would make from now on the taproot internal pubkey
and tree of alternative scripts a kind of "dynamic state".

About 4. I've quickly come to mind as additional criterias economic
simulations of any feature, privacy advantages, toolchain implementations
complexity, evolvability and composability with future features.

About 6. I agree I think it's good to withhold comparison further down in
the pipe we can, even if there is I would say some criteria-learning
heuristics by mirroring features against another.

> Each phase would probably span over more than one meeting. I imagine each
> phase basically consisting of discussing each individual nominated item
(ie
> motivations, constraints, other criteria, or proposals) sequentially. The
> consensus reached at the end of each phase would be considered of course a
> group consensus of those who participated, not a global consensus, not a
> "bitcoin community consensus". After each phase, the results of that phase
> would be published more widely to get broader community feedback. These
> results would include what the major opinions are, what level of consensus
> each major opinion has, what the reasons/justifications behind each
opinion
> are, and various detailed opinions from individuals. It would be
especially
> great to have detailed evaluations of each proposal published by various
> people so anyone can go back and understand their thought process (as
> opposed to a list of names attached to basically a thumbs up or thumbs
> down). Think like a supreme court decision kind of thing.

Yeah, again I don't see meetings as bounded in time rather happening
regularly as we have with LN ones. I guess it's going to take at least a
good year for working group participants to take habits and familiarity
with the problem space and reach consensus on the process itself. Further,
I would be even cautious about something restrained like "group consensus"
in Bitcoin FOSS. At best, it's just a snapshot of people's understanding of
the technical issues in state X at time T, and that can evaluate quickly in
function of new findings or issues arising. I think it's more interesting
to seek a lack of consensus in the sense of opposite opinions or blocking
arguments. I wouldn't disqualify thumbs up or thumbs down per se, there are
marks of interest in a specific proposal, though I lean to agree that I
find more interesting too laid-out evaluations and thought processes.

> The process doesn't need to be complete after phase 6. Any previous phase
> could be revisited, but after a phase is revisited, the phases after it
> should probably be also revisited in order - or at least until its decided
> a previous phase needs to be revisited again. Each iteration would
solidify
> consensus more about each phase. I would imagine the group might loop
> through phases 2, 3, and 4 a couple times (since constraints might
conflict
> with motivating features). It might be likely that in phase 5 while
> evaluating proposals, people realize that there are additional criteria
> that should be added and can propose going back to step 4 to do that.
> Hopefully we would get to the point where the motivations and constraints
> and relatively solid consensuses and iterations can loop through phases 5
> and 6 until the set of proposals the group thinks is worth pursuing  is
> narrowed down (ideally to 1 or 2).

For sure, in the function of new feedback arising it's good to constantly
reevaluate proposals. Hopefully, I think any looping should make proposals
more formalized and accurate. We might also have the "easy" covenants
moving faster than the "hard" ones across the phases. I believe the
covenant problem space might be solved in an evolutionary way, layer by
layer akin to how LN moves forward.

Le mer. 3 ao?t 2022 ? 11:37, Billy Tetrud <billy.tetrud at gmail.com> a ?crit :

> @Antoine
> I very much like your proposal of an open decentralized process for
> investigating the problem and solution spaces. IRC sounds like a reasonable
> place for this kind of thing to happen. I also agree with Ryan Grant's
> comment about in-person cut-through (ie cut through the BS and resolve
> misunderstandings). Perhaps every 3 IRC meetings or so, an in-person meetup
> can be organized in various locations to facilitate that kind of cut
> through.
>
> I would imagine the phases the group could go through is:
> 1. Define the phases (these phases). This list of 6 phases could be a
> starting point, but its probably best to open the floor to whether this
> feels like a reasonable approach and if more phases are needed or if some
> aren't.
> 2. Define and prioritize the motivations (ie the various features and
> functionality we want out of covenants, like the ones you listed). By
> prioritize, I mostly mean figure out which motivations are most motivating
> to people and rate them by strength of motivation (rather than a ranked
> list).
> 3. Define and prioritize the relevant constraints. These are things to
> avoid in any covenant implementation. Constraints that have been brought up
> in the past are things like preventing the possibility of infinite covenant
> recursion, full enumeration, preventing dynamic state, etc. By prioritize
> here, it might be useful to categorize them into categories like "no
> tolerance", "some tolerance", "no reservations". Eg it might turn out most
> people don't have any tolerance for infinite recursion, but don't mind
> non-full enumeration.
> 4. Other criteria? These are other criteria we might want to evaluate
> proposals according to. And some kind of way to prioritize them / evaluate
> them against each other as trade offs.
> 5. Evaluate the proposals based on motivations, constraints, and other
> criteria. This phase shouldn't involve comparing them to each other.
> 6. Produce a set of conclusions/opinions on which proposals are worth
> pursuing further. This would be the phase where proposals are compared.
>
> Each phase would probably span over more than one meeting. I imagine each
> phase basically consisting of discussing each individual nominated item (ie
> motivations, constraints, other criteria, or proposals) sequentially. The
> consensus reached at the end of each phase would be considered of course a
> group consensus of those who participated, not a global consensus, not a
> "bitcoin community consensus". After each phase, the results of that phase
> would be published more widely to get broader community feedback. These
> results would include what the major opinions are, what level of consensus
> each major opinion has, what the reasons/justifications behind each opinion
> are, and various detailed opinions from individuals. It would be especially
> great to have detailed evaluations of each proposal published by various
> people so anyone can go back and understand their thought process (as
> opposed to a list of names attached to basically a thumbs up or thumbs
> down). Think like a supreme court decision kind of thing.
>
> The process doesn't need to be complete after phase 6. Any previous phase
> could be revisited, but after a phase is revisited, the phases after it
> should probably be also revisited in order - or at least until its decided
> a previous phase needs to be revisited again. Each iteration would solidify
> consensus more about each phase. I would imagine the group might loop
> through phases 2, 3, and 4 a couple times (since constraints might conflict
> with motivating features). It might be likely that in phase 5 while
> evaluating proposals, people realize that there are additional criteria
> that should be added and can propose going back to step 4 to do that.
> Hopefully we would get to the point where the motivations and constraints
> and relatively solid consensuses and iterations can loop through phases 5
> and 6 until the set of proposals the group thinks is worth pursuing  is
> narrowed down (ideally to 1 or 2).
>
>
>
>
>
>
> On Tue, Jul 26, 2022 at 11:47 AM Bram Cohen via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> On Mon, Jul 25, 2022 at 8:21 PM Antoine Riard <antoine.riard at gmail.com>
>> wrote:
>>
>>> What would be the canonical definition and examples of capabilities in
>>> the Bitcoin context ?
>>>
>>
>> Payments into vaults which can only be accepted by that vault and are
>> guaranteed to be subject to the vault's restrictions (the vault has a
>> capability)
>>
>> Oracles whose validity can be verified on chain (so transactions can
>> depend on what they say. The oracle has a capability)
>>
>> Colored coins whose validity can be verified on chain (the colored coins
>> have a capability)
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220809/23ff7dea/attachment-0001.html>

From vjudeu at gazeta.pl  Wed Aug 10 02:59:46 2022
From: vjudeu at gazeta.pl (vjudeu at gazeta.pl)
Date: Wed, 10 Aug 2022 04:59:46 +0200
Subject: [bitcoin-dev] Regarding BIP322 edge cases
In-Reply-To: <20220809130908.yykum37tre7um4j3@artanis>
Message-ID: <165836641-bc7ec98411dacebd3de15c1b1f7c5cf4@pmq5v.m5r2.onet>

> I'm not sure what is to be gained from adding an opcode

Backward compatibility. If we don't have OP_CHECKDATASIG, then it has to be somehow introduced to make it compatible with "Bitcoin Message". And we have opcodes like OP_RESERVED, that can be wrapped in OP_IF, then it is "conditionally valid transaction". It is also possible to assign some unused opcode, but then it will be more complex, because in Script, those opcodes make transaction invalid, but inside TapScript, those opcodes are defined as OP_SUCCESS, and make things automatically valid.


On 2022-08-09 22:53:34 user Ali Sherief via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> Although there is a Github issue/PR at https://github.com/bitcoin/bips/pull/1347 for addressing all the TODO items of BIP322, I decided to throw it in the mailing list again to see if anyone else has suggestions for dealing with them.

So in an older copy of the draft at https://github.com/bitcoin/bips/blob/b6b0126e2d04793ba52a40f05d24538fa3f2c9ad/bip-0322.mediawiki , I found the some TODO items, and I will copy-paste the ones in the Specification section (for full proofs) here:

> TODO: How does this interact with as-of-yet-unspecified "Silent Transactions"?
> TODO: Some invalid opcode to allow only in various proof types?
> TODO: A way for the initial signer to delegate to another scriptPubKey; needed for better privacy and CoinJoin/Lightning compatibility

So to start with, I believe it will be very helpful to limit what opcodes scriptPubKeys to be elligible to sign from them. The specification already does so to a point, but in order for these to be recognizable, it's my opinion that one of the NOPs should be placed at the beginning of the script to activate proof parsing mode.

Of course, an opcode is not necessary at all, if the program is able to infer from context where the proof is coming from. After all, since they cannot be broadcasted, they can't be mined in blocks, so will never be encountered in a full node's usual verifier. I'm not sure what is to be gained from adding an opcode - the only source for real transactions is from P2P-obtained blocks, so when a human inputs a signature to be verified, it can check that a real transaction is not being inserted by looking for the invalid input.

For Silent Transactions, I have already given my suggestion in the PR, that some subsection can be made saying that it can operate with them by using its scriptPubKey (and other stuff that may be necessary - I am not excatly sure what goes inside the Witness stack of message_signature).

In the case of the last TODO, related to delegation to another scriptPubKey, I am not quite sure at the moment what to do about it - perhaps you guys can place a MAST (two Merkle branches, to be specific) - the first branch has the original signer's scriptPubKey, the second branch contains the delegated signer's scriptPubKey.

- Ali

_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From ali at notatether.com  Wed Aug 10 13:53:19 2022
From: ali at notatether.com (Ali Sherief)
Date: Wed, 10 Aug 2022 13:53:19 +0000
Subject: [bitcoin-dev] Regarding BIP322 edge cases
In-Reply-To: <mailman.5.1660132803.3395.bitcoin-dev@lists.linuxfoundation.org>
References: <mailman.5.1660132803.3395.bitcoin-dev@lists.linuxfoundation.org>
Message-ID: <20220810135313.qxhshtuq3wx64osz@artanis>

> Backward compatibility. If we don't have OP_CHECKDATASIG, then it has to be somehow introduced to make it compatible with "Bitcoin Message".

I suppose in the case of legacy P2PKH signing, a hypothetical OP_CHECKDATASIG can take <signature> <pubkeyhash> off the stack and perform an ECDSA public key recovery, followed by SHA256/RIPEMD160, kind of like a hybrid between OP_DUP/OP_HASH160/OP_EQUALVERIFY and OP_CHECKSIG.

But the implementations would have to decode the Base58 address into "0x00" plus the address hash. As the only supported invoice type for the Legacy signing methods, this should be straight forward to do.

> And we have opcodes like OP_RESERVED, that can be wrapped in OP_IF, then it is "conditionally valid transaction".

I'm not sure how an OP_RESERVED in an unexcuted OP_IF is going to help implement an ECDSA pubkey recovery + DUP/HASH160/EQUALVERIFY hybrid instruction.

- Ali

On Wed, 10 Aug 2022 04:59:46 +0200, vjudeu at gazeta.pl wrote:
> > I'm not sure what is to be gained from adding an opcode
>
> Backward compatibility. If we don't have OP_CHECKDATASIG, then it has to be somehow introduced to make it compatible with "Bitcoin Message". And we have opcodes like OP_RESERVED, that can be wrapped in OP_IF, then it is "conditionally valid transaction". It is also possible to assign some unused opcode, but then it will be more complex, because in Script, those opcodes make transaction invalid, but inside TapScript, those opcodes are defined as OP_SUCCESS, and make things automatically valid.
>
>
> On 2022-08-09 22:53:34 user Ali Sherief via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > Although there is a Github issue/PR at https://github.com/bitcoin/bips/pull/1347 for addressing all the TODO items of BIP322, I decided to throw it in the mailing list again to see if anyone else has suggestions for dealing with them.
>
> So in an older copy of the draft at https://github.com/bitcoin/bips/blob/b6b0126e2d04793ba52a40f05d24538fa3f2c9ad/bip-0322.mediawiki , I found the some TODO items, and I will copy-paste the ones in the Specification section (for full proofs) here:
>
> > TODO: How does this interact with as-of-yet-unspecified "Silent Transactions"?
> > TODO: Some invalid opcode to allow only in various proof types?
> > TODO: A way for the initial signer to delegate to another scriptPubKey; needed for better privacy and CoinJoin/Lightning compatibility
>
> So to start with, I believe it will be very helpful to limit what opcodes scriptPubKeys to be elligible to sign from them. The specification already does so to a point, but in order for these to be recognizable, it's my opinion that one of the NOPs should be placed at the beginning of the script to activate proof parsing mode.
>
> Of course, an opcode is not necessary at all, if the program is able to infer from context where the proof is coming from. After all, since they cannot be broadcasted, they can't be mined in blocks, so will never be encountered in a full node's usual verifier. I'm not sure what is to be gained from adding an opcode - the only source for real transactions is from P2P-obtained blocks, so when a human inputs a signature to be verified, it can check that a real transaction is not being inserted by looking for the invalid input.
>
> For Silent Transactions, I have already given my suggestion in the PR, that some subsection can be made saying that it can operate with them by using its scriptPubKey (and other stuff that may be necessary - I am not excatly sure what goes inside the Witness stack of message_signature).
>
> In the case of the last TODO, related to delegation to another scriptPubKey, I am not quite sure at the moment what to do about it - perhaps you guys can place a MAST (two Merkle branches, to be specific) - the first branch has the original signer's scriptPubKey, the second branch contains the delegated signer's scriptPubKey.
>
> - Ali


From vjudeu at gazeta.pl  Wed Aug 10 15:05:59 2022
From: vjudeu at gazeta.pl (vjudeu at gazeta.pl)
Date: Wed, 10 Aug 2022 17:05:59 +0200
Subject: [bitcoin-dev] Regarding BIP322 edge cases
Message-ID: <166373835-fcb0adc6e7c70aa2d37a60a977c1af89@pmq4v.m5r2.onet>

> I suppose in the case of legacy P2PKH signing, a hypothetical OP_CHECKDATASIG can take <signature> <pubkeyhash> off the stack and perform an ECDSA public key recovery

You can always perform key recovery for legacy ECDSA: "<signature> OP_SWAP OP_CHECKSIG" is always spendable, for any valid <r,s> DER-encoded pair. Here, if "<signature> <messageHash> <pubkey> OP_CHECKDATASIG" works for signature verification BIP, then you only need to provide "<signature>" as an input, the rest could be placed in some output, and your program could easily compute that. Or you can use "OP_DUP OP_HASH160 <address> OP_EQUALVERIFY <messageHash> OP_SWAP OP_CHECKDATASIG" as your output script, then the signer has to provide a valid signature, and a valid public key explicitly, but if you only have some signature, then you can always recover that key by yourself.

Because if OP_CHECKDATASIG is not handled, then still, signing by scripts can handle that, but the Script would be unnecessarily complex. And because there is no need to introduce OP_CHECKDATASIG on-chain, it can be safely done inside this BIP.

> I'm not sure how an OP_RESERVED in an unexcuted OP_IF is going to help implement an ECDSA pubkey recovery + DUP/HASH160/EQUALVERIFY hybrid instruction.

Because if you want to support any script, and you want to add a new opcode, you have to make it somehow compatible with existing schemes. You have to assign some byte for OP_CHECKDATASIG or for any new opcodes you want to add. And you don't want to assign just the next free opcode, because you will get OP_CHECKSIGADD or other opcodes from TapScript, so your script decoder will no longer handle two script versions at once. Unless you want to make it also compatible with altcoins like BCH, but I guess it is not needed.


On 2022-08-10 15:53:31 user Ali Sherief <ali at notatether.com> wrote:
> > Backward compatibility. If we don't have OP_CHECKDATASIG, then it has to be somehow introduced to make it compatible with "Bitcoin Message".

I suppose in the case of legacy P2PKH signing, a hypothetical OP_CHECKDATASIG can take <signature> <pubkeyhash> off the stack and perform an ECDSA public key recovery, followed by SHA256/RIPEMD160, kind of like a hybrid between OP_DUP/OP_HASH160/OP_EQUALVERIFY and OP_CHECKSIG.

But the implementations would have to decode the Base58 address into "0x00" plus the address hash. As the only supported invoice type for the Legacy signing methods, this should be straight forward to do.

> And we have opcodes like OP_RESERVED, that can be wrapped in OP_IF, then it is "conditionally valid transaction".

I'm not sure how an OP_RESERVED in an unexcuted OP_IF is going to help implement an ECDSA pubkey recovery + DUP/HASH160/EQUALVERIFY hybrid instruction.

- Ali

On Wed, 10 Aug 2022 04:59:46 +0200, vjudeu at gazeta.pl wrote:
> > I'm not sure what is to be gained from adding an opcode
>
> Backward compatibility. If we don't have OP_CHECKDATASIG, then it has to be somehow introduced to make it compatible with "Bitcoin Message". And we have opcodes like OP_RESERVED, that can be wrapped in OP_IF, then it is "conditionally valid transaction". It is also possible to assign some unused opcode, but then it will be more complex, because in Script, those opcodes make transaction invalid, but inside TapScript, those opcodes are defined as OP_SUCCESS, and make things automatically valid.
>
>
> On 2022-08-09 22:53:34 user Ali Sherief via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > Although there is a Github issue/PR at https://github.com/bitcoin/bips/pull/1347 for addressing all the TODO items of BIP322, I decided to throw it in the mailing list again to see if anyone else has suggestions for dealing with them.
>
> So in an older copy of the draft at https://github.com/bitcoin/bips/blob/b6b0126e2d04793ba52a40f05d24538fa3f2c9ad/bip-0322.mediawiki , I found the some TODO items, and I will copy-paste the ones in the Specification section (for full proofs) here:
>
> > TODO: How does this interact with as-of-yet-unspecified "Silent Transactions"?
> > TODO: Some invalid opcode to allow only in various proof types?
> > TODO: A way for the initial signer to delegate to another scriptPubKey; needed for better privacy and CoinJoin/Lightning compatibility
>
> So to start with, I believe it will be very helpful to limit what opcodes scriptPubKeys to be elligible to sign from them. The specification already does so to a point, but in order for these to be recognizable, it's my opinion that one of the NOPs should be placed at the beginning of the script to activate proof parsing mode.
>
> Of course, an opcode is not necessary at all, if the program is able to infer from context where the proof is coming from. After all, since they cannot be broadcasted, they can't be mined in blocks, so will never be encountered in a full node's usual verifier. I'm not sure what is to be gained from adding an opcode - the only source for real transactions is from P2P-obtained blocks, so when a human inputs a signature to be verified, it can check that a real transaction is not being inserted by looking for the invalid input.
>
> For Silent Transactions, I have already given my suggestion in the PR, that some subsection can be made saying that it can operate with them by using its scriptPubKey (and other stuff that may be necessary - I am not excatly sure what goes inside the Witness stack of message_signature).
>
> In the case of the last TODO, related to delegation to another scriptPubKey, I am not quite sure at the moment what to do about it - perhaps you guys can place a MAST (two Merkle branches, to be specific) - the first branch has the original signer's scriptPubKey, the second branch contains the delegated signer's scriptPubKey.
>
> - Ali




From ali at notatether.com  Wed Aug 10 16:42:10 2022
From: ali at notatether.com (Ali Sherief)
Date: Wed, 10 Aug 2022 16:42:10 +0000
Subject: [bitcoin-dev] Regarding BIP322 edge cases
In-Reply-To: <166373835-fcb0adc6e7c70aa2d37a60a977c1af89@pmq4v.m5r2.onet>
References: <166373835-fcb0adc6e7c70aa2d37a60a977c1af89@pmq4v.m5r2.onet>
Message-ID: <20220810164204.5toj4tph52lehpvv@artanis>

Wait a minute. I did some lookup on OP_CHECKDATASIG to see if it's in some btc BIP draft somewhere, and it is actually an opcode in Bitcoin Cash since some years ago - https://mengerian.medium.com/the-story-of-op-checkdatasig-c2b1b38e801a

I think we can safely assume that Kalle and the other major BIP322 proponents do not have BCH script compatibility on a high prioirty, perhaps not even medium prioity, so we should be able to make an opcode called OP_CHECKDATASIG for this BIP's internal purposes.

However, a new opcode cannot be created without a lengthy soft-fork (which requires miner signalling - but for what use here, this BIP does not directly impact miners?) with an activation height. If we want to redefine an existing opcode, we must also make a similar soft-fork. Because consensus rules are being modified here.

At the same time, a message signing/verifying algorithm using Script must implement some way to verify a *single* ECDSA or Schnorr signature that is on the stack. The existing opcodes such as OP_CHECKSIG verify all of the inputs and outputs, and this won't work here since there's a deliberate invalid iput in "to_spend".

I tried to research if there is any known use of OP_RESERVED in a script, even if it's only of academic origin, but I unfortunately could not find any references except for https://bitcoin.stackexchange.com/questions/105778/why-were-op-reserved-op-reserved1-and-op-reserved2-originally-reserved .

So this is now an open problem: How should Script verify a single signature that is on the stack without touching any of the inputs or outputs?

- Ali

On Wed, Aug 10, 2022 at 05:05:59PM +0200, vjudeu at gazeta.pl wrote:
> > I suppose in the case of legacy P2PKH signing, a hypothetical OP_CHECKDATASIG can take <signature> <pubkeyhash> off the stack and perform an ECDSA public key recovery
>
> You can always perform key recovery for legacy ECDSA: "<signature> OP_SWAP OP_CHECKSIG" is always spendable, for any valid <r,s> DER-encoded pair. Here, if "<signature> <messageHash> <pubkey> OP_CHECKDATASIG" works for signature verification BIP, then you only need to provide "<signature>" as an input, the rest could be placed in some output, and your program could easily compute that. Or you can use "OP_DUP OP_HASH160 <address> OP_EQUALVERIFY <messageHash> OP_SWAP OP_CHECKDATASIG" as your output script, then the signer has to provide a valid signature, and a valid public key explicitly, but if you only have some signature, then you can always recover that key by yourself.
>
> Because if OP_CHECKDATASIG is not handled, then still, signing by scripts can handle that, but the Script would be unnecessarily complex. And because there is no need to introduce OP_CHECKDATASIG on-chain, it can be safely done inside this BIP.
>
> > I'm not sure how an OP_RESERVED in an unexcuted OP_IF is going to help implement an ECDSA pubkey recovery + DUP/HASH160/EQUALVERIFY hybrid instruction.
>
> Because if you want to support any script, and you want to add a new opcode, you have to make it somehow compatible with existing schemes. You have to assign some byte for OP_CHECKDATASIG or for any new opcodes you want to add. And you don't want to assign just the next free opcode, because you will get OP_CHECKSIGADD or other opcodes from TapScript, so your script decoder will no longer handle two script versions at once. Unless you want to make it also compatible with altcoins like BCH, but I guess it is not needed.
>
>
> On 2022-08-10 15:53:31 user Ali Sherief <ali at notatether.com> wrote:
> > > Backward compatibility. If we don't have OP_CHECKDATASIG, then it has to be somehow introduced to make it compatible with "Bitcoin Message".
>
> I suppose in the case of legacy P2PKH signing, a hypothetical OP_CHECKDATASIG can take <signature> <pubkeyhash> off the stack and perform an ECDSA public key recovery, followed by SHA256/RIPEMD160, kind of like a hybrid between OP_DUP/OP_HASH160/OP_EQUALVERIFY and OP_CHECKSIG.
>
> But the implementations would have to decode the Base58 address into "0x00" plus the address hash. As the only supported invoice type for the Legacy signing methods, this should be straight forward to do.
>
> > And we have opcodes like OP_RESERVED, that can be wrapped in OP_IF, then it is "conditionally valid transaction".
>
> I'm not sure how an OP_RESERVED in an unexcuted OP_IF is going to help implement an ECDSA pubkey recovery + DUP/HASH160/EQUALVERIFY hybrid instruction.
>
> - Ali
>
> On Wed, 10 Aug 2022 04:59:46 +0200, vjudeu at gazeta.pl wrote:
> > > I'm not sure what is to be gained from adding an opcode
> >
> > Backward compatibility. If we don't have OP_CHECKDATASIG, then it has to be somehow introduced to make it compatible with "Bitcoin Message". And we have opcodes like OP_RESERVED, that can be wrapped in OP_IF, then it is "conditionally valid transaction". It is also possible to assign some unused opcode, but then it will be more complex, because in Script, those opcodes make transaction invalid, but inside TapScript, those opcodes are defined as OP_SUCCESS, and make things automatically valid.
> >
> >


From bitcoin-dev at rgrant.org  Wed Aug 10 23:11:10 2022
From: bitcoin-dev at rgrant.org (Ryan Grant)
Date: Wed, 10 Aug 2022 23:11:10 +0000
Subject: [bitcoin-dev] Regarding BIP322 edge cases
In-Reply-To: <20220809130908.yykum37tre7um4j3@artanis>
References: <20220809130908.yykum37tre7um4j3@artanis>
Message-ID: <CAMnpzfpy=jpf+VncX6jUZnWEJV1dgwpQRSxzydMHoXoOZfRdbA@mail.gmail.com>

>> TODO: A way for the initial signer to delegate to another
>> scriptPubKey; needed for better privacy and CoinJoin/Lightning
>> compatibility

I need more documentation to understand this motivation.

On Tue, Aug 9, 2022 at 8:46 PM Ali Sherief via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> In the case of the last TODO, related to delegation to another
> scriptPubKey, I am not quite sure at the moment what to do about
> it - perhaps you guys can place a MAST (two Merkle branches, to be
> specific) - the first branch has the original signer's scriptPubKey,
> the second branch contains the delegated signer's scriptPubKey.

I don't understand this requirement, but it seems that whatever
parties are involved can make signatures on the delegating and
delegated keys.

From AdamISZ at protonmail.com  Thu Aug 11 15:31:48 2022
From: AdamISZ at protonmail.com (AdamISZ)
Date: Thu, 11 Aug 2022 15:31:48 +0000
Subject: [bitcoin-dev] RIDDLE: Lightweight anti-Sybil with anonymity in
	Bitcoin
In-Reply-To: <HT3SgKh3WjJhJz9ozfy8E0MuGveya8Grb3SYrmYShZcHTQOPKpIBfArFupyAVV44k3XHNjSaKHmimqX_BCrUsXm5QvadXK5Z_24uGL60KWg=@protonmail.com>
References: <Kq8x6RTAGitSLOir_j1JcWHxTODreQpRTtqfW0NCTrrwTJBHQ9smptiZA1rIbh6aJl9wc_Ca6DvQr7xrMSate62s4r9nmQSypugYYKJXEZY=@protonmail.com>
 <HT3SgKh3WjJhJz9ozfy8E0MuGveya8Grb3SYrmYShZcHTQOPKpIBfArFupyAVV44k3XHNjSaKHmimqX_BCrUsXm5QvadXK5Z_24uGL60KWg=@protonmail.com>
Message-ID: <utryS1r9tVYCguFAvdt-laVEsHtSPPqaGEuwDMJlptuU9HRVCdLMNlHOiz0Flr7oPxYvsMQQdw858r_7FQ32t5cO3s9lbDx0fYQKRplUh_M=@protonmail.com>

A quick summary on a lot of study I've done recently on this topic.
My last blog [1] was showing that you could concretely make logarithmic sized ring sigs on taproot keys (and built on the explanation and code of Groth/Kohlweiss [2] in the previous blog [5]).
I left as an outstanding question, how to get one/N time usage of these ring signatures, with key images.

So this can definitely be addressed using something like Noether & Goodall's Triptych [3].

The right context for Triptych:
The GK paper [2] just referenced is the core idea: bit decomposition of index. Then, Bootle et al. in "Short Accountable Ring Signatures Based on DDH" in 2015 [4] found a significant further efficiency/compaction by generalising the concept a bit: using an n-ary decomposition and delta-functions as a way to identify the index with the correct digits in n-ary. They used this to form a new "accountable" ring sig based on El Gamal ciphertexts.
Then in 2020 we have Triptych: it takes the n-ary decomposition as above, and adds one more element: a key image, as in the basic cryptonote , LWW, LSAG design.
Of note is that Bootle et al. claim their construction is "2.8 times smaller" than the GK [2] design (which is ~ 7log_2 N + 1 size, so in practice maybe 2.5kB for 2000 keys for example). I mention this because although I *believe* the same key image appending idea would work with GK [2] design, there's no point trying to do that, because Bootle et al. is just more compact and already achieves the same thing.

Adding in the key image needs more space in the proof of course, but only by less than a factor of 2 (just some commitment and response duplication in the sigma protocol).

So the endpoint of the research, for now, is that Triptych [3] seems to give both things we need: first, a key image, which is absolutely needed for something like RIDDLE, along with a very compact size for high anon sets.

I'll probably add some code for this at some point to go along with the GK [2] toy code at [6]

Regards,
AdamISZ/waxwing

[1] https://reyify.com/blog/bragging-with-brevity
[2] https://eprint.iacr.org/2014/764.pdf
[3] https://eprint.iacr.org/2020/018
[4] https://eprint.iacr.org/2015/643.pdf
[5] https://reyify.com/blog/leaking-secrets-logarithmically
[6] https://gist.github.com/AdamISZ/77651979025d16b778494047c86c3a7c

Sent with Proton Mail secure email.

------- Original Message -------
On Thursday, June 30th, 2022 at 22:50, AdamISZ via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:


> Just a small update to those interested:
> I migrated the gist due to failures of github's new equation formatting feature (which unfortunately started just when I published this gist!), to [1](but comments still on the gist please, or here).
>
> Secondly, I did some research (including toy code) into sublinear ring signatures and Groth/Kohlweiss 2014 can give logarithmic scaled ring signatures, whose security is reducible to that of the Pedersen commitments (essentially ECDLP). I made a note on what this looks like concretely here [2], TLDR 1 o 2 KB for 256-1024 keys. Open question how much the computational load matters. (Ring sig + key image I think is effected via ring sig + "spend a coin" part of "how to leak a secret and spend a coin", in the language of the paper).
>
> The above paragraph is mentioned of course to address the question of how practical it might be to get genuinely big anonymity sets. In short, it might be practical. Again to mention: though bilinear pairings crypto could give substantially more efficient constructions, that would not work on 'bare' secp256k1, though there might be a sensible way of 'transferring' over to other curves (I'll leave that to others to figure out!).
>
> [1] https://reyify.com/blog/riddle
> [2] https://gist.github.com/AdamISZ/51349418be08be22aa2b4b469e3be92f?permalink_comment_id=4210892#gistcomment-4210892
>
> Cheers,
> AdamISZ/waxwing
>
>
>
>
> Sent with Proton Mail secure email.
>
>
> ------- Original Message -------
> On Sunday, June 12th, 2022 at 18:04, AdamISZ via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:
>
>
>
> > List denizens,
> >
> > As per the title, a suggested protocol for doing anti-Sybil that isn't too demanding for the users, but actually keeps a decent level of privacy.
> >
> > Notice how it's mostly focused on a user/customer of a service/product/website, but it could conceivably useful in e.g. anti-Sybil in things like Lightning.
> >
> > Sorry that as usual I write rather long but there are several conveniently arranged sections you can click on :)
> >
> > https://gist.github.com/AdamISZ/51349418be08be22aa2b4b469e3be92f
> >
> > (with apologies for my backronym-ing sins)
> >
> > Cheers,
> > waxwing/AdamISZ
> >
> > Sent with Proton Mail secure email.
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From ali at notatether.com  Thu Aug 11 16:56:29 2022
From: ali at notatether.com (Ali Sherief)
Date: Thu, 11 Aug 2022 16:56:29 +0000
Subject: [bitcoin-dev] Regarding BIP322 edge cases
In-Reply-To: <CAMnpzfpy=jpf+VncX6jUZnWEJV1dgwpQRSxzydMHoXoOZfRdbA@mail.gmail.com>
References: <20220809130908.yykum37tre7um4j3@artanis>
 <CAMnpzfpy=jpf+VncX6jUZnWEJV1dgwpQRSxzydMHoXoOZfRdbA@mail.gmail.com>
Message-ID: <20220811165622.etfdfiiawsdpljmy@artanis>

Earlier last year on March, there was a post here by Jeremy Rubin that explains how a person could delegate its UTXO to some script, by (AFAICT) creating a new transaction using that UTXO, with whatever script you want it to have.

It was written in terms of normal transactions, but can be extended to message signing transactions too.

https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-March/018615.html

Only the beginning of the post is relevant here.

- Ali

On Wed, Aug 10, 2022 at 11:11:10PM +0000, Ryan Grant wrote:
> >> TODO: A way for the initial signer to delegate to another
> >> scriptPubKey; needed for better privacy and CoinJoin/Lightning
> >> compatibility
>
> I need more documentation to understand this motivation.
>
> On Tue, Aug 9, 2022 at 8:46 PM Ali Sherief via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > In the case of the last TODO, related to delegation to another
> > scriptPubKey, I am not quite sure at the moment what to do about
> > it - perhaps you guys can place a MAST (two Merkle branches, to be
> > specific) - the first branch has the original signer's scriptPubKey,
> > the second branch contains the delegated signer's scriptPubKey.
>
> I don't understand this requirement, but it seems that whatever
> parties are involved can make signatures on the delegating and
> delegated keys.


From ali at notatether.com  Sun Aug 14 04:25:33 2022
From: ali at notatether.com (Ali Sherief)
Date: Sun, 14 Aug 2022 04:25:33 +0000
Subject: [bitcoin-dev] A method for BIP322 signing delegation
Message-ID: <20220814042526.n7osmg5n7pfssauh@artanis>

[A similar message was posted in the Bitcointalk BIP322 thread.]

OK, I just figured out how to solve the delegation problem. It builds on Jeremy Rubin's transaction delegation post which I linked to a few days ago.

In BIP322, there is a [planned] provision for some person to delegate signing to another person. That means the second person can do all the signing stuff that the first person could do, and the signature is as if the first person signed it.

What this could be useful for?

- L2/Lightning Network, a channel is just 2-of-2 multisig, so a prospective channel co-creator "delegate" signing to the channel itself, by signing a UTXO inside the multisig - signing along with the other party, creating a dummy output (see below), which can be signed to prove liquidity on behalf of the channel, while keeping the channel itself anonymous.
- CoinJoin, To prove that some CoinJoin coordinator is liquid without violating its anonymity by revealing public keys, the person managing the CoinJoins delegates signing from all UTXOs to be used in the CJ, at once, delegating signing to another dummy output.
- By the same token, Mixers can prove their liquidity without revealing their UTXO set.
- Silent Payments, where the public key is not even known in the first place, the address of a silent payment can delegate signing to another dummy output which only the sender and receiver know about.

So how does this delegation work? It's very simple:

1. All UTXOs that want to delegate signing to a different party must sign a preliminary transaction of this format:
- All input/output amounts are zero.
- input 1 is an invalid input of the kind in BIP322
- the rest of the inputs are the UTXOs wanting to delegate signing to a different party, with valid signatures/witness stacks.
- there is only one output, and it is a P2WSH output with the following script:
OP_PUSH <hash-of-address-hash> OP_SWAP OP_HASH160 OP_EQUALVERIFY
- And the witness stack that will "spend" the transaction in the "to_spend" tx is simply:
<address-hash>
- Likewise, the "to_spend" tx has only one input, refering to the txid of the delegating transaction with output point 0 i.e. the UTXO <delegation-txid>:0. Outputs of "to_spend" remain the same.
-- Contrary to the use of Hash160, we are NOT hashing a public key or script. We are hashing an address hash, implying that we are using addresses.

Do you know why I said "delegating to a different party"? Because it could be a functionally different entity, just like how CEO is diffferent from LLC company even if it has only 1 employee. The "address" here represents a kind of company <but is not a smart contract> - it can represent a channel, it can represent a coinjoin, it can represent a silent payment. The channel/CJ/etc. only has to hash the decoded RIPEMD160 of an address, with another SHA256-RIPEMD160, to make an "address" that can be used to sign messages from.

This "address" aka. LLC company can even be encoded with Bech32 to make it look like a real address - obviously don't send any funds directly to that address because they will be lost - and in fact, it *should* be Bech32-encoded when transmitting the Signed Message.

A signed message has these three parts:

Message
Address
Signature

BIP322 specifies the signature is just the raw transaction format of "to_sign". Normally, the address would simply be the address you are signing from, but in the case of delegation, it is desireable for the original addresses to remain anonymous. So since an address must be filled in somewhere, the Bech32 "hash-of-address-hash" created above can be used as a P2WSH address.

Advantages of this scheme:

- The real addresses/UTXOs signing the transaction are only known to each other and whoever is managing the "to_delegate" transaction.
- Only the real signers and the person who is in charge of the P2WSH output can sign the "to_delegate" output and thus sign a message from it (note that they could be the same person).
- There can be an arbitrary number of delegations before the transaction is actually signed (the new person who is in charge of signing, i.e. has the P2WSH output of the "to_delegate" transaction can simply generate another address hash, and delegate to that "address" in another transaction, giving some other person that "address" if they want to)
- Delegated signatures can wrap Full and Full with UTXOs signing formats, so Light clients do not have to directly support those two formats, either for complexity reasons, or because they have no UTXO set.
- And crucially: **There is no on-chain transaction, so the delegation is private and cannot be traced back by the public**.

And there are virtually no disadvantages to this.

I should emphasize that you don't delegate signing to another person, you delegate signing to another party that may just be comprised by one person. I say this because the delegation does not make any new on-chain UTXOs that someone could posess, but it simply creates a hash160 of some address hash that was generated by the delegators, and the hash-of-address-hash does not necessarily have to represent a person, it can also represent a service.

FAQ:

Q: Does this utilize the Full format?
A: Yes.

Q: How to represent the delegation in a signed transaction?
A: Just encode the hash-of-address-hash in Bech32 version 0 and put it in the Address field.

Q: If the delegation is private, then how can the address-hash be known and the transaction signed?
A: The UTXO signers take a random address associated with them <could be one of their own address, could be the address of a multisig that is being used elsewhere etc.> and then make the hash160 of that address. Whoever they give this to, can sign a BIP322 transaction.

Q: How can the public verify a delegated BIP322 transaction if the address-hash is private?
A: The hash-of-address-hash is revealed in the Address, not in the Signature. BIP322 states that the signature only contains the "to_sign" transaction, which does not contain the witness stack of "to_spend" that has the hash-of-address-hash (because THAT was already spent in "to_spend") therefore the address hash is Bech32 (version 0) encoded and can be decoded to re-construct "to_spend" transaction and from there "to_sign".

Q: How to differentiate between non-delegated and delegated signatures?
A: You can't. But then again, BIP322 doesn't differentiate between "message signatures from an address" and a signature from a set of UTXOs so it wouldn't be able to identify a delegated transaction anyway.
Rather, a full-blown verification software should present a list-box or a set of radio buttons, that toggles between "Legacy", "Simple", "Full", "Full with UTXOs" and "Full with Delegation" - Each of these controls the content in the Address field - this would already be required to support validating Legacy signatures anyway, which are otherwise incompatible with the transaction-based signing (and this is the workaround BIP322 specifies to support that).

Q: What if the verifier does not have a UTXO set (light clients)?
A: Then present three toggles or radio buttons: "Legacy", "Simple", and "Delegated" - each of these options only require a single encoded address to be specified in the field, and Full, and Full With UTXOs signatures can be wrapped with a delegation to support a single address. Consequentially, these control how the signed transaction is [re]constructed for sign/verify.

CC'ing Kalle as he might be interested in this.

- Ali


From jk_14 at op.pl  Mon Aug 15 21:46:52 2022
From: jk_14 at op.pl (jk_14 at op.pl)
Date: Mon, 15 Aug 2022 23:46:52 +0200
Subject: [bitcoin-dev] Surprisingly, Tail Emission Is Not Inflationary
Message-ID: <166771656-fdf60b77a66e05a55a2e75479a31e5f7@pmq1v.m5r2.onet>


> New blog post:
> https://petertodd.org/2022/surprisingly-tail-emission-is-not-inflationary


Tail emission is inevitable, Milton Friedman says...


The key thing here in my opinion is to properly understand the seriousness of the situation.
"There is no such thing as a free lunch" - is definitely helpful quote here.

There are two edge cases.

1. while starting given cryptocurrency
- the annual inflation is huge, nobody (in developed/mature monetary system) would like to keep such kind of money with e.g. 100% annual inflation rate, but from the other side there is no problem for transaction fee to be free of charge here

2. while given cryptocurrency is switching off the block reward, in supposed "mature phase":
- the annual inflation is zero, everyone want to hoard such money, transaction fees must carry the whole security of the system


In the first edge case: active users have got "free lunches" and passive users (i.e. holders) are paying for it (by "inflation tax")
In the second edge case: passive users have got "free lunches" and active users should pay for it (by "transactional tax")

So far I only highlighted some maybe not very well recognized, but pure facts (it's not comfortable to contradict the facts...)


The reason people do pay in the first phase - is a hope/promise of system growth (future coin price appreciation = profit)
The problem in the second phase is that there is no real incentive for people to pay for other's free lunches.


Any wishful thinking that most (or even: any significant part) of holders will resign from a free lunch and will buy and run ASIC mining equipment at loss - is just a delusional perspective. It's well proven by game theory and what says us the Prisoner's Dilemma about it. For better understanding - here is my modified version of Prisoner's Dilemma short description:

"The Prisoner's Dilemma is a standard example of a game analyzed in game theory that shows why completely rational large holders might not cooperate, even if it appears that it is in their best interests to do so."

I'm pretty sure we will have a textbook case of Prisoner's Dilemma here.

As a useful example - let's assume that fees don't compensate low block reward. Btw, right now a single transaction fee need to be $60 to compensate that (and it will only get worse in time). System is not inclusive with $60 per transaction fee. Only rich people will use it. Another possible scenario is a x100 drop of network hashrate to catch a previous fee levels. The network is x100 less secure, then. It really doesn't matter if this process is spread over the long run...

So, for example - let every 10 BTC holding needs to be secured by one Antminer S19 running.

In an ideal world every large bitcoin holder will run proper amount of ASICs and run it at loss.
The holders of less than 10 BTC - will organize "group pays", this time for sharing loss (electricity costs)
Exactly the same way like people made "group buys" of ASIC hardware in 2013.

I hope it's clear that in the real world it WILL NOT work. People will simply think, that there is only a tiny punishment for betrayal.
Noone will waste his renewable energy on unprofitable Antminer while he/she can sell this energy for the market price. Even Bitcoin can't beat the human nature.


Thanks to Milton Friedman - we can easily say that situation with "free lunches" (at least for some part of users) - is an unhealthy state of financial system.
And may last only exceptionally for short period of time, and definitely not as a default state. System must be sustainable and time to accept that there is a real problem here (or: an elephant in the room - but maybe not such invisible like was before).

The good news is a natural solution exists. Bitcoin can solve this issue natural way.

While decreasing block reward and moving from the first edge case to the second one - the system naturally cross the Area of Balance.
And healthy system should stay somewhere in such area. And that's exactly what Monero did. But they did it arbitrally, at 0.9% level.
Bitcoin is able to do it much better - because empirically.

There is a simple trigger if the system is leaving an Area of Balance and cross the line of Phase 2 with "free lunches". The network difficulty / global network hashrate chart.
Four years after some particular halving (in 2028, 2032 or later - no matter when in fact) - we will (definitely) see difficulty is not recovered during four long years.
This is a big red light. It means that halvings starts to be destructive to the network security. 

Something what became destructive to the network - must be removed. Halving must be removed in such moment. Moment determined empirically - what is good thing. Satoshi Nakamoto wasn't able to properly predict when this moment may appear, but we are in better situation.

"Bitcoin to the moon" (and any other pro-21M hardcap shortsighted slogans) - must have a lower priority than network security/health.
I'm sure Satoshi would agree with it. Of course, someone may set up such environment, where holders (i.e. passive users) have got a free lunches
and security of network is based on active users' shoulders only. Someone could even insist that it is quite fair...
But please don't expect a lack of impact for the network security where not all, but only a part of users - participate in supporting network health.
Many people don't realise a simple fact: keeping destructive halvings in such situation above, just for maximising appreciation of already hoarded coins
- is counterproductive. Because the network security is decreasing.


We have a lot of time yet to educate people about it - for reaching common consensus for halvings removal with "ease".
We should probably use Milton Friedman's quote and highlight that balanced system with 0.45% / 0.225% / 0.1125% (?) annual inflation rate (and slowly decreasing)
- is still enormously better than any surrounding fiat system. But system still balanced and stable - and not in spiral of death...


?Bitcoin should have had a 0.1% or 1% monetary inflation tax to pay for security,? Peter said long time ago, further arguing bitcoin will die if it doesn?t change the limit.

I fully agree with Peter. The halvings should be removed in case it starts to be destructive to the network security (lack of hashrate recovery during long 4 years after given halving). Because that means bitcoin system has reached equilibrium / saturation on a globe scale level. The evolutionary path is the best path.
The worst path is: overcomplicated constructs, completely unclear for Average Joe. Additional merge-mining coins, whatever etc. - just to achieve the same final goal.
KISS = Keep It Simple. Halving removal is the most honest, simplest and most understandable way to make every bitcoin pasive user to participate in keeping Bitcoin network secure. It just force the rule, that someone pay proportionally to amount of bitcoins he/she hold, and all participants are sure that everybody participate (no Prisoner's Dilemma, what is crucial matter)


Yes, that means: hard fork. But as written above - Bitcoin will die without the solution.

Bitcoin may be also out of sudden in a deadly risk from quantum computers. In such circumstances everyone (or: almost, i.e. everyone who cares) - would immediately download a quantum resistant, freshly released bitcoin wallet, no doubt. And these two dangers are similar at least in one aspect: both will cause the spiral of death.
Widespread consensus would be the best scenario, but from the other side: a fork always shows retrospectively, who was right (BCH turmoil in 2017)


Regards
Jaroslaw


P.S  some other resources yet:

"Friedman originally proposed a fixed monetary rule, called Friedman's k-percent rule, where the money supply would be automatically increased by a fixed percentage per year. Under this rule, there would be no leeway for the central reserve bank, as money supply increases could be determined "by a computer", and business could anticipate all money supply changes. With other monetarists he believed that the active manipulation of the money supply or its growth rate is more likely to destabilise than stabilise the economy.

Most monetarists oppose the gold standard. Friedman, for example, viewed a pure gold standard as impractical.[9] For example, whereas one of the benefits of the gold standard is that the intrinsic limitations to the growth of the money supply by the use of gold would prevent inflation, if the growth of population or increase in trade outpaces the money supply, there would be no way to counteract deflation and reduced liquidity (and any attendant recession) except for the mining of more gold"

no block reward  => reduced liquidity (reduced number of transactions) => network security in spiral of death

https://en.wikipedia.org/wiki/Monetarism
https://en.wikipedia.org/wiki/Friedman%27s_k-percent_rule
https://twitter.com/hasufl/status/1511470668457652224



_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From ali at notatether.com  Tue Aug 16 04:38:47 2022
From: ali at notatether.com (Ali Sherief)
Date: Tue, 16 Aug 2022 04:38:47 +0000
Subject: [bitcoin-dev] A method for BIP322 signing delegation
Message-ID: <20220816043842.a2rbh7cugztle56p@artanis>

(Note: I'm going to stick with this thread for all proposals for BIP322 polishing, not just delegation - unless the subject matter changes radically as other people discuss it.)

Instead of the admittingly complicated scheme using transactions, I've created one that utilizes multisig to make the possible delegatees known at signing time. I had a discussion with vjudeu, garlonicon, and aliashraf about this over the past week or so, and while we did not reach a consensus about the solution to use, I feel that this scheme requires the least amount of modifications to BIP322 draft.

The problem being solved is how to delegate signatures to other scriptPubKeys* [sic] for privacy purposes.

*Here, I use P2WPKH addresses, under the assumption that the delegatees are people. If the delegatees are just some automated scripts or processes [as was mentioned in the BIP], then this scheme is equally valid with P2WSH multisignatures with appropriately constructed scriptPubKeys.

What's about to follow was copied almost word-for-word from my forum post with extraneous paragraphs removed:

---

It is extremely simple and doesn't require any additional transactions:

- Replace the message challenge of "to_spend" with a 1-of-N standard P2WPKH multisig. N is the number of people you want to be able to create the signature, and their respective pubkeys are included in the script.
-- In this way the possible delegatees are fixed at signature creation time and cannot be extended by creating more transactions.
- Replace the challenge solution in "to_sign" (it's the input that spends the output we made in "to_spend") with a witness stack containing: n <pub1> <pub2> ... <pubn> 1 <a-signature> 0
-- The signature is generated as if it were for a real P2WPKH-multisig transaction. [the zero at the end is due to a bug in OP_CHECKMULTISIG that pops an extra element].

appendix - don't mix up this delegation and Full with UTXOs together - it increases the numebr of permutations that implementations have to verify.

Pros:

- No recursive transactions.
- If Alice and Bob are the two delegates of a signature (and one of them sign it), Carol does not know any of the private keys or challenge solutions and thus cannot claim the script was signed by her [besides the public keys of Alice and Bob are already in the signature]. Required, to avoid signature fraud.
- The Address field is not used when delegating, so the engine can actually print which (compressed) public key it is signed against - i.e. the address verification is provable, as opposed to reactive Legacy signatures.
-- Additionally, they will all be Segwit Bech32 addresses so it can just derive and print the corresponding bc1 address instead.
- There is no opcode or new algorithm introduced, so no soft-fork is required.

Cons:

- Everyone knows the public keys of the delegators, so there is no privacy [then again, in light of the signature fraud problem, this is possibly a non-issue].

---

I'd like to hear everyone's opinions about this.

I don't know who suggested the idea of delegation in the first place, but CCing luke-jr because he participated in that Github discussion, so his opinion about this scheme will clarify a lot of things about this problem.

- Ali


From dizzle at pointbiz.com  Tue Aug 16 16:05:32 2022
From: dizzle at pointbiz.com (Peter)
Date: Tue, 16 Aug 2022 16:05:32 +0000
Subject: [bitcoin-dev] Surprisingly, Tail Emission Is Not Inflationary
Message-ID: <abd33vsLrsQ7z5vJjz9h1V-3iEHJW1os1HyiO6QO5PNA8kahcPZ_2BUNuU7i4gyFRT2peLu0NXNrWv5X3RGGR6cvqijishTcb1qvo3YPeSU=@pointbiz.com>

Hi Jaroslaw,

In the Prisoner's Dilemma the prisoners cannot communicate. In Bitcoin large holders are able to communicate with each other. Also, prisoners need not make an all or nothing decision in Bitcoin. Miners can join and leave the network freely over time. You can change your decision based on the decision of others.

The Bitcoin design is such that security is volatile but the issuance of blocks is timely and evened out to a 10 minutes average even after the reward is exhausted.

The existing incentive that miners earn money for including transactions is enough to motivate human nature. Transaction initiators have an incentive to mine and run full nodes for personal interest.

>Noone will waste his renewable energy on unprofitable Antminer while he/she can sell this energy for the market price.

The law in most jurisdictions prevents the resale of spare electricity unless an expensive license is obtained (and in most cases no license is available as the government maintains a monopoly). Mining with waste electricity is reducing losses. Another incentive to motivate human nature.

Bitcoin holders can be enfranchised into any new system. So, no need for bike shedding the original design which is a Schelling Point.

Regards

Peter Kroll

pointbiz/ BTCCuracao
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220816/7446c044/attachment.html>

From woltx at protonmail.com  Wed Aug 17 00:08:11 2022
From: woltx at protonmail.com (woltx)
Date: Wed, 17 Aug 2022 00:08:11 +0000
Subject: [bitcoin-dev] New Silent Payment version
Message-ID: <p3J90rsvbXPQnI7AtPXq1dLllvkiKmzccP-hbGd_NL7XTYM8O6ckjT3ocsixjebylnFDNKPP9XT9w0YFzY0OiW2Gvw_69SybOSOhhgio1wY=@protonmail.com>

PR #24897 (https://github.com/bitcoin/bitcoin/pull/24897) has been updated with a new silent payment version, which eliminates some manual steps from the previous version (such as the need to set the `keypool` to avoid costly multi-key scan).

This is achieved by using a new descriptor type ("sp()") that has no range and contains exactly one key.

Example: "sp(cQq73sG9....JD51uaRD)#9llg6xjm"

This descriptor introduces a new type of output: "silent-payment". This output type returns a standard Taproot script (Segwit V1), but with HRP changed from "bc" to "sp" on the mainnet (or "tsp" on testnet and signet).
This output type will always generate the same address (unless another "sp" descriptor is enabled on the same wallet).

$ ./src/bitcoin-cli -signet getnewaddress '' 'silent-payment'
tsp1pfmjyl7ecpmx8yf8cu6g3ez36jy7s9mzuh5pdnal3k0n588uzgmfs4s4fws

To create a silent transaction, simply use the silent payment address as one of the outputs.
The "send" RPC will automatically identify and tweak it.

The transaction can contain multiple outputs, combining silent and standard addresses.

I have written a step by step signet tutorial so reviewers can test this new version easily.

https://gist.github.com/w0xlt/a7b498ac1ff14b8c292a22be789bd93f
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220817/97c45a02/attachment.html>

From jk_14 at op.pl  Wed Aug 17 08:54:11 2022
From: jk_14 at op.pl (jk_14 at op.pl)
Date: Wed, 17 Aug 2022 10:54:11 +0200
Subject: [bitcoin-dev] Surprisingly, Tail Emission Is Not Inflationary
Message-ID: <165909427-fcabd7e2d86a7077513853cede692955@pmq7v.m5r2.onet>


Hi, Peter

Thanks to human nature, still:

1. Bitcoin large holders are able to communicate with each other...
- and as a large bitcoin holder someone will very well understand that he should run his Antminers at loss for goodness of Bitcoin network security.
But he won't communicate that - due to his greed - he just betrayed it. Maybe someone will communicate that he is running Anminers... But it doesn't change a lot.
We can assume this additional possibility of communication (especially taking into account big number of large holders and their anonimity) - doesn't change this Prisoner's Dilemma into a "not textbook case enough".

2. The existing incentive that miners earn money for including transactions is enough to motivate human nature...
- but paying $50 usd per such transaction (the amount necessary to compensate lack of block reward right now) - is "no way" to motivate a human nature, just due to: personal interest (as you correctly highlighted). It really doesn't matter that the process of disappearance of block reward is spreaded over the long run.
(the same, but more terse: https://twitter.com/hasufl/status/1511470668457652224 )

3. In many jurisdictions you can take back from grid for free - the amount you have produced and uploaded earlier (I'm in one of such). So I won't invest and oversize my solar panels by additional ~24kW of power for additional Antminer runing 24h/day - if I know it will be running at loss. (side note: it's not a good idea to be dependant with future health of bitcoin -  on what type of jurisdiction is the most popular one in given moment)


There are two statements to repeat then, but more precisely:

A. Bitcoiners (me too) are proud the bitcoin system is designed so clever, that from the beginning till now - is able to run without the trust to anyone. And utilise even people's greed - for system goodness/expansion. But when I wrote the FIRST edge case is behind us, but the SECOND one - with no doubt with pathological Friedman's "free lunches" for part of participants - is only some years ahead (like in a Titanic scene) - then most of them suddenly say:

"Ok, then... Bitcoin idea is so brilliant that maybe the game theory won't apply anymore. Let's TRUST the large holders they will run Antminers at loss."

It's not The Satoshi's Vision anymore.


B. Bitcoiners (me too) want to remove or neutralise all destructive things to Bitcoin, like for example: unfriendly government regulations, etc. But when I wrote there will be in the future (and the only question is: when) an alarm siren that halvings start to be destructive to the Bitcoin network, while start to cause consecutive network security/hashrate regressions - then most of them suddenly say:

"Ok, then... I'm to greed to resign from it."



It's not The Satoshi's Vision anymore.

Regards
Jaroslaw




W dniu 2022-08-16 23:21:30 u?ytkownik Peter via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> napisa?:
Hi Jaroslaw,

In the Prisoner's Dilemma the prisoners cannot communicate. In Bitcoin large holders are able to communicate with each other. Also, prisoners need not make an all or nothing decision in Bitcoin. Miners can join and leave the network freely over time. You can change your decision based on the decision of others.

The Bitcoin design is such that security is volatile but the issuance of blocks is timely and evened out to a 10 minutes average even after the reward is exhausted.

The existing incentive that miners earn money for including transactions is enough to motivate human nature. Transaction initiators have an incentive to mine and run full nodes for personal interest.

>Noone will waste his renewable energy on unprofitable Antminer while he/she can sell this energy for the market price.

The law in most jurisdictions prevents the resale of spare electricity unless an expensive license is obtained (and in most cases no license is available as the government maintains a monopoly). Mining with waste electricity is reducing losses. Another incentive to motivate human nature.

Bitcoin holders can be enfranchised into any new system. So, no need for bike shedding the original design which is a Schelling Point.

Regards

Peter Kroll

pointbiz/ BTCCuracao





From erik at q32.com  Wed Aug 17 11:10:24 2022
From: erik at q32.com (Erik Aronesty)
Date: Wed, 17 Aug 2022 07:10:24 -0400
Subject: [bitcoin-dev] Surprisingly, Tail Emission Is Not Inflationary
In-Reply-To: <166771656-fdf60b77a66e05a55a2e75479a31e5f7@pmq1v.m5r2.onet>
References: <166771656-fdf60b77a66e05a55a2e75479a31e5f7@pmq1v.m5r2.onet>
Message-ID: <CAJowKgKuo_TjYfGV1XL-MLGYF20k5nf4iTNWi97YvuP8Ahbq3A@mail.gmail.com>

you can stop talking about  the "security of the system" as meaningful

this has been discussed enough

if fees are not sufficient, clearance times increase and large stakeholders
are incentivised to mine

in the best case, fees are sufficient

in the worst case, it degrades to proof of stake

i'm sure you can see how that's fine either way


On Mon, Aug 15, 2022 at 9:59 PM Jaroslaw via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> > New blog post:
> >
> https://petertodd.org/2022/surprisingly-tail-emission-is-not-inflationary
>
>
> Tail emission is inevitable, Milton Friedman says...
>
>
> The key thing here in my opinion is to properly understand the seriousness
> of the situation.
> "There is no such thing as a free lunch" - is definitely helpful quote
> here.
>
> There are two edge cases.
>
> 1. while starting given cryptocurrency
> - the annual inflation is huge, nobody (in developed/mature monetary
> system) would like to keep such kind of money with e.g. 100% annual
> inflation rate, but from the other side there is no problem for transaction
> fee to be free of charge here
>
> 2. while given cryptocurrency is switching off the block reward, in
> supposed "mature phase":
> - the annual inflation is zero, everyone want to hoard such money,
> transaction fees must carry the whole security of the system
>
>
> In the first edge case: active users have got "free lunches" and passive
> users (i.e. holders) are paying for it (by "inflation tax")
> In the second edge case: passive users have got "free lunches" and active
> users should pay for it (by "transactional tax")
>
> So far I only highlighted some maybe not very well recognized, but pure
> facts (it's not comfortable to contradict the facts...)
>
>
> The reason people do pay in the first phase - is a hope/promise of system
> growth (future coin price appreciation = profit)
> The problem in the second phase is that there is no real incentive for
> people to pay for other's free lunches.
>
>
> Any wishful thinking that most (or even: any significant part) of holders
> will resign from a free lunch and will buy and run ASIC mining equipment at
> loss - is just a delusional perspective. It's well proven by game theory
> and what says us the Prisoner's Dilemma about it. For better understanding
> - here is my modified version of Prisoner's Dilemma short description:
>
> "The Prisoner's Dilemma is a standard example of a game analyzed in game
> theory that shows why completely rational large holders might not
> cooperate, even if it appears that it is in their best interests to do so."
>
> I'm pretty sure we will have a textbook case of Prisoner's Dilemma here.
>
> As a useful example - let's assume that fees don't compensate low block
> reward. Btw, right now a single transaction fee need to be $60 to
> compensate that (and it will only get worse in time). System is not
> inclusive with $60 per transaction fee. Only rich people will use it.
> Another possible scenario is a x100 drop of network hashrate to catch a
> previous fee levels. The network is x100 less secure, then. It really
> doesn't matter if this process is spread over the long run...
>
> So, for example - let every 10 BTC holding needs to be secured by one
> Antminer S19 running.
>
> In an ideal world every large bitcoin holder will run proper amount of
> ASICs and run it at loss.
> The holders of less than 10 BTC - will organize "group pays", this time
> for sharing loss (electricity costs)
> Exactly the same way like people made "group buys" of ASIC hardware in
> 2013.
>
> I hope it's clear that in the real world it WILL NOT work. People will
> simply think, that there is only a tiny punishment for betrayal.
> Noone will waste his renewable energy on unprofitable Antminer while
> he/she can sell this energy for the market price. Even Bitcoin can't beat
> the human nature.
>
>
> Thanks to Milton Friedman - we can easily say that situation with "free
> lunches" (at least for some part of users) - is an unhealthy state of
> financial system.
> And may last only exceptionally for short period of time, and definitely
> not as a default state. System must be sustainable and time to accept that
> there is a real problem here (or: an elephant in the room - but maybe not
> such invisible like was before).
>
> The good news is a natural solution exists. Bitcoin can solve this issue
> natural way.
>
> While decreasing block reward and moving from the first edge case to the
> second one - the system naturally cross the Area of Balance.
> And healthy system should stay somewhere in such area. And that's exactly
> what Monero did. But they did it arbitrally, at 0.9% level.
> Bitcoin is able to do it much better - because empirically.
>
> There is a simple trigger if the system is leaving an Area of Balance and
> cross the line of Phase 2 with "free lunches". The network difficulty /
> global network hashrate chart.
> Four years after some particular halving (in 2028, 2032 or later - no
> matter when in fact) - we will (definitely) see difficulty is not recovered
> during four long years.
> This is a big red light. It means that halvings starts to be destructive
> to the network security.
>
> Something what became destructive to the network - must be removed.
> Halving must be removed in such moment. Moment determined empirically -
> what is good thing. Satoshi Nakamoto wasn't able to properly predict when
> this moment may appear, but we are in better situation.
>
> "Bitcoin to the moon" (and any other pro-21M hardcap shortsighted slogans)
> - must have a lower priority than network security/health.
> I'm sure Satoshi would agree with it. Of course, someone may set up such
> environment, where holders (i.e. passive users) have got a free lunches
> and security of network is based on active users' shoulders only. Someone
> could even insist that it is quite fair...
> But please don't expect a lack of impact for the network security where
> not all, but only a part of users - participate in supporting network
> health.
> Many people don't realise a simple fact: keeping destructive halvings in
> such situation above, just for maximising appreciation of already hoarded
> coins
> - is counterproductive. Because the network security is decreasing.
>
>
> We have a lot of time yet to educate people about it - for reaching common
> consensus for halvings removal with "ease".
> We should probably use Milton Friedman's quote and highlight that balanced
> system with 0.45% / 0.225% / 0.1125% (?) annual inflation rate (and slowly
> decreasing)
> - is still enormously better than any surrounding fiat system. But system
> still balanced and stable - and not in spiral of death...
>
>
> ?Bitcoin should have had a 0.1% or 1% monetary inflation tax to pay for
> security,? Peter said long time ago, further arguing bitcoin will die if it
> doesn?t change the limit.
>
> I fully agree with Peter. The halvings should be removed in case it starts
> to be destructive to the network security (lack of hashrate recovery during
> long 4 years after given halving). Because that means bitcoin system has
> reached equilibrium / saturation on a globe scale level. The evolutionary
> path is the best path.
> The worst path is: overcomplicated constructs, completely unclear for
> Average Joe. Additional merge-mining coins, whatever etc. - just to achieve
> the same final goal.
> KISS = Keep It Simple. Halving removal is the most honest, simplest and
> most understandable way to make every bitcoin pasive user to participate in
> keeping Bitcoin network secure. It just force the rule, that someone pay
> proportionally to amount of bitcoins he/she hold, and all participants are
> sure that everybody participate (no Prisoner's Dilemma, what is crucial
> matter)
>
>
> Yes, that means: hard fork. But as written above - Bitcoin will die
> without the solution.
>
> Bitcoin may be also out of sudden in a deadly risk from quantum computers.
> In such circumstances everyone (or: almost, i.e. everyone who cares) -
> would immediately download a quantum resistant, freshly released bitcoin
> wallet, no doubt. And these two dangers are similar at least in one aspect:
> both will cause the spiral of death.
> Widespread consensus would be the best scenario, but from the other side:
> a fork always shows retrospectively, who was right (BCH turmoil in 2017)
>
>
> Regards
> Jaroslaw
>
>
> P.S  some other resources yet:
>
> "Friedman originally proposed a fixed monetary rule, called Friedman's
> k-percent rule, where the money supply would be automatically increased by
> a fixed percentage per year. Under this rule, there would be no leeway for
> the central reserve bank, as money supply increases could be determined "by
> a computer", and business could anticipate all money supply changes. With
> other monetarists he believed that the active manipulation of the money
> supply or its growth rate is more likely to destabilise than stabilise the
> economy.
>
> Most monetarists oppose the gold standard. Friedman, for example, viewed a
> pure gold standard as impractical.[9] For example, whereas one of the
> benefits of the gold standard is that the intrinsic limitations to the
> growth of the money supply by the use of gold would prevent inflation, if
> the growth of population or increase in trade outpaces the money supply,
> there would be no way to counteract deflation and reduced liquidity (and
> any attendant recession) except for the mining of more gold"
>
> no block reward  => reduced liquidity (reduced number of transactions) =>
> network security in spiral of death
>
> https://en.wikipedia.org/wiki/Monetarism
> https://en.wikipedia.org/wiki/Friedman%27s_k-percent_rule
> https://twitter.com/hasufl/status/1511470668457652224
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220817/5fef26c6/attachment-0001.html>

From jk_14 at op.pl  Wed Aug 17 13:43:16 2022
From: jk_14 at op.pl (jk_14 at op.pl)
Date: Wed, 17 Aug 2022 15:43:16 +0200
Subject: [bitcoin-dev] Surprisingly, Tail Emission Is Not Inflationary
Message-ID: <73828407-38b211dc3a9d78d44c9b9fb6c2b60b85@pmq6v.m5r2.onet>


On one scale you puts the Trust to the large stakeholders (why we avoid plenty of small stakeholders, btw),
and on the other side I put game theory and well defined Prisoner's Dilemma.

Again: large stakeholders WILL NOT incentivised to mine, they will have the hundreds excuses why not to switch-on Antminers back.
That's how it simply works.  Bitcoin would fail miserably if Satoshi was based his concept mainly on existence of idealists.

If we will observe lack of hashrate recovery four years after some halving and still unprepared like today
- means the trust in large stakeholders was a very costly mistake.


Superiority of Proof of Work against Proof of Stake has been discussed enough either
The overall conclusion with what I fully agree  is: swapping PoW to PoS - would be a degradation.
You can stop talking about degradation to proof of stake, but just: degradation.

Degradation of Bitcoin, due to human greed.

Now you mine and you have an INSTANT gratification.
Then you will mine and it will cost you real money, but simple switch - and you have a DELAYED, maybe some day in the future, maybe only a tiny - punishment.
And The Punishment Won't Be Tiny.


"If the pain after hitting the hand with a hammer would appear after a month - people would notoriously walk with swollen fingers"
100% (^2)

Regards
Jaroslaw



W dniu 2022-08-17 13:10:38 u?ytkownik Erik Aronesty <erik at q32.com> napisa?:

> you can stop talking about? the "security of the system" as meaningful
> this has been discussed enough
> if fees are not sufficient, clearance times increase and large stakeholders are incentivised to mine?
> in the best case, fees are sufficient
> in the worst case, it degrades to proof of stake
> i'm sure you can see how that's fine either?way



_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From ZaidanK at proton.me  Wed Aug 17 21:02:33 2022
From: ZaidanK at proton.me (Zaidan)
Date: Wed, 17 Aug 2022 21:02:33 +0000
Subject: [bitcoin-dev] New User experience with the Bitcoin-Cli
Message-ID: <9inVCADZPkjUs5LKcfoMfrbaMNADGfTlVz1xYLi3722jNUC-vyoiEHYF21FFwut1DMiPHroGy7nQTww_hwb6OCi__IN7WL__9Bb4ZYCmUyg=@proton.me>

I recently started running a node and learning how to be effective with it from The Blockchain Commons project here.

https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line

Granted, I am new at this, I may have tied my shoe laces together and wanted to get feedback on what I experienced and perhaps suggest some fixes.

With chain=<chain> set in the bitcoin.conf and then mistakenly combined with a network argument such as -testnet it provides the error message "

EXCEPTION: St13runtime_error
Invalid combination of -regtest, -signet, -testnet and -chain. Can use at most one."

As a novice, I didn't quite understand where this collision was coming from or why as I copied the conf file from an old setup. I got some help from the bitcoin-dev irc and worked it out. I was told there is currently no way of notifying where the arguments are coming from a config file or client arguments. Would an new argument options category being applied to arguments being set when the .conf file is being ingested by ArgsManager.ReadConfigFiles help? I see an enum class called Source which is used with MergeSettings. Perhaps that could be of help for generating a more descriptive warning in ArgsManager::GetChainName?

My second novice mistake was the mix naming of test and testnet. The command 'bitcoin-cli -chain=testnet' was failing me. having 'bitcoin-cli -testnet' be the equivalent of 'bitcoin-cli -chain=test' caused confusion leading to my opinion that it would be beneficial for the names to match CBaseChainParams network names.

argsman.AddArg("-chain=<chain>", "Use the chain <chain> (default: main). Allowed values: main, test, signet, regtest", ArgsManager::ALLOW_ANY, OptionsCategory::CHAINPARAMS);
argsman.AddArg("-testnet", "Use the test chain. Equivalent to -chain=test.", ArgsManager::ALLOW_ANY, OptionsCategory::CHAINPARAMS);

Would SetupChainParamsBaseOptions benefit from changing the added argument -testnet to -test to match the CBaseChainParams or add the argument of -test to maintain backwards capability.

Last, this is the first time I'm dipping my toe into contributing to this software. I've read a fair amount of guides before I got started online and through Chaincode's educational endeavors. I hope this doesn't seem like bike-shedding, but a novices attempt to contribute in good faith.

Any feedback of how this issue is presented will be warmly welcomed. I am looking forward to improving my effectiveness at engaging with this community.

Thank you for your time,
Zaidan

Sent with [Proton Mail](https://proton.me/) secure email. ?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220817/7a6ebd47/attachment.html>

From brenorb at gmail.com  Thu Aug 18 15:29:01 2022
From: brenorb at gmail.com (Breno Brito)
Date: Thu, 18 Aug 2022 12:29:01 -0300
Subject: [bitcoin-dev] Surprisingly, Tail Emission Is Not Inflationary
In-Reply-To: <73828407-38b211dc3a9d78d44c9b9fb6c2b60b85@pmq6v.m5r2.onet>
References: <73828407-38b211dc3a9d78d44c9b9fb6c2b60b85@pmq6v.m5r2.onet>
Message-ID: <CA+NC=6zpBtkzmYvGf1b72=okO1tBBoqesCxFskCzgVqTh_2-9w@mail.gmail.com>

Since we are talking about inflation and Milton Friedman, this Friedman's
interview seems relevant.
[image: image.png]
Source:
https://www.econlib.org/library/Columns/y2006/Friedmantranscript.html

Regards,
Breno Brito


On Wed, Aug 17, 2022 at 11:31 AM Jaroslaw via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> On one scale you puts the Trust to the large stakeholders (why we avoid
> plenty of small stakeholders, btw),
> and on the other side I put game theory and well defined Prisoner's
> Dilemma.
>
> Again: large stakeholders WILL NOT incentivised to mine, they will have
> the hundreds excuses why not to switch-on Antminers back.
> That's how it simply works.  Bitcoin would fail miserably if Satoshi was
> based his concept mainly on existence of idealists.
>
> If we will observe lack of hashrate recovery four years after some halving
> and still unprepared like today
> - means the trust in large stakeholders was a very costly mistake.
>
>
> Superiority of Proof of Work against Proof of Stake has been discussed
> enough either
> The overall conclusion with what I fully agree  is: swapping PoW to PoS -
> would be a degradation.
> You can stop talking about degradation to proof of stake, but just:
> degradation.
>
> Degradation of Bitcoin, due to human greed.
>
> Now you mine and you have an INSTANT gratification.
> Then you will mine and it will cost you real money, but simple switch -
> and you have a DELAYED, maybe some day in the future, maybe only a tiny -
> punishment.
> And The Punishment Won't Be Tiny.
>
>
> "If the pain after hitting the hand with a hammer would appear after a
> month - people would notoriously walk with swollen fingers"
> 100% (^2)
>
> Regards
> Jaroslaw
>
>
>
> W dniu 2022-08-17 13:10:38 u?ytkownik Erik Aronesty <erik at q32.com>
> napisa?:
>
> > you can stop talking about  the "security of the system" as meaningful
> > this has been discussed enough
> > if fees are not sufficient, clearance times increase and large
> stakeholders are incentivised to mine
> > in the best case, fees are sufficient
> > in the worst case, it degrades to proof of stake
> > i'm sure you can see how that's fine either way
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220818/02c2e796/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: image.png
Type: image/png
Size: 121588 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220818/02c2e796/attachment-0001.png>

From billy.tetrud at gmail.com  Thu Aug 18 15:44:11 2022
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Thu, 18 Aug 2022 10:44:11 -0500
Subject: [bitcoin-dev] Surprisingly, Tail Emission Is Not Inflationary
In-Reply-To: <73828407-38b211dc3a9d78d44c9b9fb6c2b60b85@pmq6v.m5r2.onet>
References: <73828407-38b211dc3a9d78d44c9b9fb6c2b60b85@pmq6v.m5r2.onet>
Message-ID: <CAGpPWDbD5WQD2Nr6ngiSYtodTkij2N+1Aft5dn5yYePdQ1NC7w@mail.gmail.com>

While constant tail emission does in fact converge to 0 inflation over time
(which bitcoin's halvings do as well mind you), tail emission does *not*
solve the potential problem of mining rewards, it only delays it. A tail
emission of 200,000 btc/year (~1% of the current supply) would be
equivalent to halvings every ~50 years rather than every 4 years. Were we
to implement this kind of thing right after the last non-" destructive"
halving, it would buy us 46 years of extra time. Nothing more, nothing less.

While its mildly interesting to know that tail emission converges to a
stable point, while no inflation implies monetary deflation at the rate of
loss, this feels very likely to be an insignificant problem. I think 1%
loss rate per year is an absurdly high estimate these days, and the loss
rate is likely to decrease as methods of storing bitcoin mature. Imagine
bitcoin was worth $1 trillion (not so hard, since it was not too long ago),
then try imagining people losing $10 billion of bitcoin every year. Highly
unlikely IMO. A rate of loss of 0.01%/year might be more realistic for a
near-future mature bitcoin. That's not going to be enough to make a
significant difference even over 100s of years.

If we actually wanted to solve the potential problem of not-enough-fees to
upkeep mining security, there are less temporary ways to solve that. For
example, if fees end up not being able to support sufficient mining, we
could add emission based on a constant fraction of fees in the block. For
example, every block could emit new bitcoin amounting to 10% of the fees
collected in that block. This would tie coinbase rewards to the real world
(since the fee market is tied to the real economy) and ensure higher block
revenue indefinitely - ie not just for another 50 years.

But its also worth saying that blockchain security (which mining revenue
correlates with) does *not* need to increase indefinitely. There is some
amount of security (and therefore some amount of mining revenue) that is
sufficient, beyond which additional security is simply unnecessary,
unwarranted, and wasteful (you wouldn't buy a $1000 safe to store $1000 of
valuables). Do we, as the bitcoin community, have some good idea how much
security we need? Do we have some idea how costly a 51% attack must be
where we can be comfortable it will never happen? I'm curious to hear what
people think about that. Because without having some kind of estimates of
what "enough security" is, there's absolutely no way of evaluating whether
or not its likely that bitcoin fees alone will be able to sustain enough
security.



On Wed, Aug 17, 2022 at 9:31 AM Jaroslaw via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> On one scale you puts the Trust to the large stakeholders (why we avoid
> plenty of small stakeholders, btw),
> and on the other side I put game theory and well defined Prisoner's
> Dilemma.
>
> Again: large stakeholders WILL NOT incentivised to mine, they will have
> the hundreds excuses why not to switch-on Antminers back.
> That's how it simply works.  Bitcoin would fail miserably if Satoshi was
> based his concept mainly on existence of idealists.
>
> If we will observe lack of hashrate recovery four years after some halving
> and still unprepared like today
> - means the trust in large stakeholders was a very costly mistake.
>
>
> Superiority of Proof of Work against Proof of Stake has been discussed
> enough either
> The overall conclusion with what I fully agree  is: swapping PoW to PoS -
> would be a degradation.
> You can stop talking about degradation to proof of stake, but just:
> degradation.
>
> Degradation of Bitcoin, due to human greed.
>
> Now you mine and you have an INSTANT gratification.
> Then you will mine and it will cost you real money, but simple switch -
> and you have a DELAYED, maybe some day in the future, maybe only a tiny -
> punishment.
> And The Punishment Won't Be Tiny.
>
>
> "If the pain after hitting the hand with a hammer would appear after a
> month - people would notoriously walk with swollen fingers"
> 100% (^2)
>
> Regards
> Jaroslaw
>
>
>
> W dniu 2022-08-17 13:10:38 u?ytkownik Erik Aronesty <erik at q32.com>
> napisa?:
>
> > you can stop talking about  the "security of the system" as meaningful
> > this has been discussed enough
> > if fees are not sufficient, clearance times increase and large
> stakeholders are incentivised to mine
> > in the best case, fees are sufficient
> > in the worst case, it degrades to proof of stake
> > i'm sure you can see how that's fine either way
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220818/bc7a359b/attachment.html>

From jk_14 at op.pl  Thu Aug 18 20:22:30 2022
From: jk_14 at op.pl (jk_14 at op.pl)
Date: Thu, 18 Aug 2022 22:22:30 +0200
Subject: [bitcoin-dev] Surprisingly, Tail Emission Is Not Inflationary
Message-ID: <73900259-c5361e151c592be1534bf37720d1ebcf@pmq6v.m5r2.onet>


Fortunately halving in 2020 will be non destructive because it looks like we will have higher difficulty in 2024 than in 2020.

Let's assume the worst case scenario: after halving in 2024, we have regression of difficulty in 2028. Annual inflation rate in 2028 is 0.81%. Removal of halvings in this year means that in year 2100 (72 years later) we will have 0.51% annual inflation rate, still. And that is Monero concept in fact: constant annual supply, thus very slowly decreasing of inflation.

Yes, you are right. Better that that - would be to wait for bitcoin ecosystem to show us what is the equilibrium/saturation level at globe scale - I hope it will be several years later and "the annual inflation to keep" - will be 0.40% in 2032 or even 0.20% only in 2036.

And then instead of halving every 210k blocks - just to adjust the block reward (i.e. slightly increase). To keep the annual inflation rate constant. Constant forever. On most proper level - because determined empirically. I didn't propose it, because of certain, immediate backlash :)

And for the same reason, as an answer how much security we need. Empirically reached security level is - the most accurate one. In military terminology: the protection of already conquered land. Regression is sign of weakness and we probably don't want to see it in Bitcoin.

Anyway, keeping Bitcoin in the middle of ultra-obvious Edge Case, with pathological Friedman's "free lunches" for stakeholders, due to this overtaxing (punish) people which are simply want to use Bitcoin, additionally with pure form of Prisoner's Dilemma here, and with Trust to "large" stakeholders, while almost every of them will convince himself he is not really a large one and "let Microstrategy run Antminers" (and burn money)

- and all above only because we are too greed to pay miners as low as only few tenths of a percent per year for their real service as keeping network secure, pay in most honest way, because with no exceptions and proportionally to holdings - and instead of it we rather prefer to take the high risk of spiral of death - is madness.


Pure madness. This is what almost 50y old cynic may assure you.

Regards
Jaroslaw




W dniu 2022-08-18 17:44:29 u?ytkownik Billy Tetrud <billy.tetrud at gmail.com> napisa?:
While constant tail emission does in fact converge to 0 inflation over time (which bitcoin's halvings do as well mind you), tail emission does *not* solve the potential problem of mining rewards, it only delays it. A tail emission of 200,000 btc/year (~1% of the?current supply) would be equivalent to halvings every ~50 years rather than every 4 years. Were we to implement this kind of thing right after the last non-" destructive" halving, it would buy us 46 years of extra time. Nothing more, nothing less.

While its mildly interesting to know that tail emission converges to a stable point, while no inflation implies monetary deflation at the rate of loss, this feels very likely to be an insignificant problem. I think 1% loss rate per year is an absurdly high estimate these days, and the loss rate is likely to decrease as methods of storing bitcoin mature. Imagine bitcoin was worth $1 trillion (not so hard, since it was not too long ago), then try imagining people losing $10 billion of bitcoin every year. Highly unlikely IMO. A rate of loss of 0.01%/year might be more realistic for a near-future mature bitcoin. That's not going to be enough to make a significant difference?even over 100s of years.?

If we actually wanted to solve the potential problem of not-enough-fees to upkeep mining security, there are less temporary ways to solve that. For example, if fees end up not being able to support sufficient mining, we could add emission based on a constant fraction of fees in the block. For example, every block could emit new bitcoin amounting to 10% of the fees collected in that block. This would tie coinbase rewards to the real world (since the fee market is tied to the real economy) and ensure higher block revenue indefinitely - ie not just for another?50 years.?

But its also worth saying that blockchain security (which mining revenue correlates with) does *not* need to increase indefinitely. There is some amount of security (and therefore some amount of mining revenue) that is sufficient, beyond which additional security is simply unnecessary, unwarranted, and wasteful (you wouldn't buy a $1000 safe to store $1000 of valuables). Do we, as the bitcoin community, have some good idea how much security we need? Do we have some idea how costly a 51% attack must be where we can be comfortable it will never happen? I'm curious to hear what people think about that. Because without having some kind of estimates of what "enough security" is, there's absolutely no way of evaluating whether or not its likely that bitcoin fees alone will be able to sustain enough security.?


_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From erik at q32.com  Thu Aug 18 20:49:55 2022
From: erik at q32.com (Erik Aronesty)
Date: Thu, 18 Aug 2022 16:49:55 -0400
Subject: [bitcoin-dev] Surprisingly, Tail Emission Is Not Inflationary
In-Reply-To: <73828407-38b211dc3a9d78d44c9b9fb6c2b60b85@pmq6v.m5r2.onet>
References: <73828407-38b211dc3a9d78d44c9b9fb6c2b60b85@pmq6v.m5r2.onet>
Message-ID: <CAJowKgJKjPS6q_VdgmVsHRZfh5G0S-7qAHqVAT6n_t-nTBM34g@mail.gmail.com>

1...
>  Degradation

Remember, if hash rate declines (no sign that it will so far), the
net-effect is longer clearance times for large transactions.

It's not "failure" or "breaking"

2...
Certainly, if demand for blockspace isn't high enough to support clearance
then the *first *thing to do would be to improve the utility of the chain
so that demand for blockspace is high.

This is one of the strong reasons to support research like covenants and
rgb and taro.   If those tools become popular, we will see rising fees.
 Indeed, large miners should be *paying* researchers to advance these
tools.   It's in their own best interests.

3...
> and on the other side I put game theory and well defined Prisoner's
Dilemma.

The prisoner's dilemma does not state that zero stakeholders will
mine, just far fewer.   Real world experiments with actual prisoners and
students show cooperation rates of 33%.  Plus there are incentives.
Stakeholders who want to move large amounts in a reasonable amount of time
are incentivised to mine.

4...
Changing issuance is a non-starter, forte very game-theoretic reasons you
refer to

it would destroy the value proposition of the chain, fork the coin and i
have every confidence that the surviving fork would be the one without the
new issuance


On Wed, Aug 17, 2022 at 9:43 AM <jk_14 at op.pl> wrote:

>
> On one scale you puts the Trust to the large stakeholders (why we avoid
> plenty of small stakeholders, btw),
> and on the other side I put game theory and well defined Prisoner's
> Dilemma.
>
> Again: large stakeholders WILL NOT incentivised to mine, they will have
> the hundreds excuses why not to switch-on Antminers back.
> That's how it simply works.  Bitcoin would fail miserably if Satoshi was
> based his concept mainly on existence of idealists.
>
> If we will observe lack of hashrate recovery four years after some halving
> and still unprepared like today
> - means the trust in large stakeholders was a very costly mistake.
>
>
> Superiority of Proof of Work against Proof of Stake has been discussed
> enough either
> The overall conclusion with what I fully agree  is: swapping PoW to PoS -
> would be a degradation.
> You can stop talking about degradation to proof of stake, but just:
> degradation.
>
> Degradation of Bitcoin, due to human greed.
>
> Now you mine and you have an INSTANT gratification.
> Then you will mine and it will cost you real money, but simple switch -
> and you have a DELAYED, maybe some day in the future, maybe only a tiny -
> punishment.
> And The Punishment Won't Be Tiny.
>
>
> "If the pain after hitting the hand with a hammer would appear after a
> month - people would notoriously walk with swollen fingers"
> 100% (^2)
>
> Regards
> Jaroslaw
>
>
>
> W dniu 2022-08-17 13:10:38 u?ytkownik Erik Aronesty <erik at q32.com>
> napisa?:
>
> > you can stop talking about  the "security of the system" as meaningful
> > this has been discussed enough
> > if fees are not sufficient, clearance times increase and large
> stakeholders are incentivised to mine
> > in the best case, fees are sufficient
> > in the worst case, it degrades to proof of stake
> > i'm sure you can see how that's fine either way
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220818/8f313bd8/attachment-0001.html>

From aj at erisian.com.au  Fri Aug 19 03:09:46 2022
From: aj at erisian.com.au (Anthony Towns)
Date: Fri, 19 Aug 2022 13:09:46 +1000
Subject: [bitcoin-dev] Mock introducing vulnerability in important
 Bitcoin projects
In-Reply-To: <MoojKWD--3-2@tutanota.de>
References: <CAPv7TjbvRE-b33MeYucUfr6CTooCRSH42hwSn5dMiJ4LODATRQ@mail.gmail.com>
 <MktnWM7--3-2@tutanota.de>
 <qNjz-H23x07OJjnf5Try4Qp8l5s23SQxhEE8yAfNbrniN34u2vM72FVFSDJxHg4HNTL8tdcm-KKT8h6XVRwOwN0ZmckxzWiMlNFmLbMNuHc=@protonmail.com>
 <MkwZGYl--7-2@tutanota.de>
 <CAMnpzfrNZ0vpiMVoH=0KW9jy1-vppudX3D7Z+aXpSp4h_7s=zw@mail.gmail.com>
 <Ml-IIuL--3-2@tutanota.de>
 <CAAxiurb1_-p2yO8183MvB2x_i9H+WAo9t0RH85faRrrKz9YxGg@mail.gmail.com>
 <202110032133.44726.luke@dashjr.org>
 <sez9AuvBEnKKkLkJ4aivnaLJz5M5VFz3yTOdreTGmFb6RzwMv7h0dRFbEiB1_aup4Daw7t9YwlZKp2YvbgCu1fzym28cHhlzRVC3efmfBpE=@protonmail.com>
 <MoojKWD--3-2@tutanota.de>
Message-ID: <Yv7++q6o+dtR01gT@erisian.com.au>

On Thu, Nov 18, 2021 at 09:29:24PM +0100, Prayank via bitcoin-dev wrote:
> After reading all the emails, personally experiencing review process especially on important issues like privacy and security, re-evaluating everything and considering the time I can spend on this, I have decided to do this exercise for 3 projects with just 1 account. I have created a salted hash for the username as you had mentioned in the first email:
> f40bcb13dbcbf7b6245becb757777586c22798ed7360cd9853572152ddf07a39
> 3 Bitcoin projects are Bitcoin Core (full node implementation), LND (LN implementation) and Bisq (DEX).
> Pull requests will be created in next 6 months. If vulnerability gets caught during review, will publicly announce here that the project caught the PR and reveal the de-commitment publicly. If not caught during review, will privately reveal both the inserted vulnerability and the review failure via the normal private vulnerability-reporting channels. A summary with all the details will be shared later.

It's now been nine months since this email, but I don't believe
there's been any public report on this exercise. Does this mean that a
vulnerability has been introduced in one or all of the named projects?

Cheers,
aj


From vjudeu at gazeta.pl  Fri Aug 19 05:34:25 2022
From: vjudeu at gazeta.pl (vjudeu at gazeta.pl)
Date: Fri, 19 Aug 2022 07:34:25 +0200
Subject: [bitcoin-dev] Surprisingly, Tail Emission Is Not Inflationary
Message-ID: <73904836-123affd52a139f11587a4971b0df5f07@pmq6v.m5r2.onet>

> If we actually wanted to solve the potential problem of not-enough-fees to upkeep mining security, there are less temporary ways to solve that. For example, if fees end up not being able to support sufficient mining, we could add emission based on a constant fraction of fees in the block. For example, every block could emit new bitcoin amounting to 10% of the fees collected in that block. This would tie coinbase rewards to the real world (since the fee market is tied to the real economy) and ensure higher block revenue indefinitely - ie not just for another 50 years.

Miners can game this system by moving their own coins in 100% fees transactions, just to produce more coins. You have one million BTC? No problem, just move them as fees, and you just created 100k BTC out of thin air, just because you are a wealthy miner. And even if that amount will be stolen, when some other miner will reorg your block, then still, miners will keep creating coins by moving them as fees, and the strongest miner will get the whole pot. And guess what: 100 blocks later you can reuse newly created 100k BTC to make another 10k BTC, so it will exponentially explode as (amountOfCoins*(1+0.1))^n function. And guess what: (1.1)^8 is 2.14358881. That means, after eight moves, you can double your coins, if you are a wealthy miner. And you can start with smaller amounts, to play it safe, but eventually, this system will degrade into "coin doubler after 800 blocks" or something similar.


On 2022-08-18 18:45:43 user Billy Tetrud via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
While constant tail emission does in fact converge to 0 inflation over time (which bitcoin's halvings do as well mind you), tail emission does *not* solve the potential problem of mining rewards, it only delays it. A tail emission of 200,000 btc/year (~1% of the?current supply) would be equivalent to halvings every ~50 years rather than every 4 years. Were we to implement this kind of thing right after the last non-" destructive" halving, it would buy us 46 years of extra time. Nothing more, nothing less.


While its mildly interesting to know that tail emission converges to a stable point, while no inflation implies monetary deflation at the rate of loss, this feels very likely to be an insignificant problem. I think 1% loss rate per year is an absurdly high estimate these days, and the loss rate is likely to decrease as methods of storing bitcoin mature. Imagine bitcoin was worth $1 trillion (not so hard, since it was not too long ago), then try imagining people losing $10 billion of bitcoin every year. Highly unlikely IMO. A rate of loss of 0.01%/year might be more realistic for a near-future mature bitcoin. That's not going to be enough to make a significant difference?even over 100s of years.?


If we actually wanted to solve the potential problem of not-enough-fees to upkeep mining security, there are less temporary ways to solve that. For example, if fees end up not being able to support sufficient mining, we could add emission based on a constant fraction of fees in the block. For example, every block could emit new bitcoin amounting to 10% of the fees collected in that block. This would tie coinbase rewards to the real world (since the fee market is tied to the real economy) and ensure higher block revenue indefinitely - ie not just for another?50 years.?


But its also worth saying that blockchain security (which mining revenue correlates with) does *not* need to increase indefinitely. There is some amount of security (and therefore some amount of mining revenue) that is sufficient, beyond which additional security is simply unnecessary, unwarranted, and wasteful (you wouldn't buy a $1000 safe to store $1000 of valuables). Do we, as the bitcoin community, have some good idea how much security we need? Do we have some idea how costly a 51% attack must be where we can be comfortable it will never happen? I'm curious to hear what people think about that. Because without having some kind of estimates of what "enough security" is, there's absolutely no way of evaluating whether or not its likely that bitcoin fees alone will be able to sustain enough security.?






On Wed, Aug 17, 2022 at 9:31 AM Jaroslaw via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

On one scale you puts the Trust to the large stakeholders (why we avoid plenty of small stakeholders, btw),
and on the other side I put game theory and well defined Prisoner's Dilemma.

Again: large stakeholders WILL NOT incentivised to mine, they will have the hundreds excuses why not to switch-on Antminers back.
That's how it simply works.? Bitcoin would fail miserably if Satoshi was based his concept mainly on existence of idealists.

If we will observe lack of hashrate recovery four years after some halving and still unprepared like today
- means the trust in large stakeholders was a very costly mistake.


Superiority of Proof of Work against Proof of Stake has been discussed enough either
The overall conclusion with what I fully agree? is: swapping PoW to PoS - would be a degradation.
You can stop talking about degradation to proof of stake, but just: degradation.

Degradation of Bitcoin, due to human greed.

Now you mine and you have an INSTANT gratification.
Then you will mine and it will cost you real money, but simple switch - and you have a DELAYED, maybe some day in the future, maybe only a tiny - punishment.
And The Punishment Won't Be Tiny.


"If the pain after hitting the hand with a hammer would appear after a month - people would notoriously walk with swollen fingers"
100% (^2)

Regards
Jaroslaw



W dniu 2022-08-17 13:10:38 u?ytkownik Erik Aronesty <erik at q32.com> napisa?:

> you can stop talking about? the "security of the system" as meaningful
> this has been discussed enough
> if fees are not sufficient, clearance times increase and large stakeholders are incentivised to mine?
> in the best case, fees are sufficient
> in the worst case, it degrades to proof of stake
> i'm sure you can see how that's fine either?way



_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From ali at notatether.com  Fri Aug 19 06:23:38 2022
From: ali at notatether.com (Ali Sherief)
Date: Fri, 19 Aug 2022 06:23:38 +0000
Subject: [bitcoin-dev] A method for BIP322 signing delegation
Message-ID: <20220819062332.ua6kwrx5a36kw7zm@artanis>

Since I mailed the original scheme, some people have suggested to me that this delegation scheme can be written in TapScript, to avoid revealing the unspent public keys. I think that is a good idea.

Here is a very helpful slideshow about implementing Multisig scripts in Taproot by Jimmy Song[1] - specifically, I have looked into "Single leaf k-of-n multisig" and "Multi-leaf k-of-k multisig". I have not considered the approach with MuSig, considering there is not even a BIP for that.

To my understanding, Single leaf k-of-n multisig is functionally identical to "Using a single OP_CHECKSIGADD-based script" described in BIP 0342, footnote 5, which itself has nearly all of the properties of the original CHECKMULTISIG opcode[2]. In other words, it won't hide the non-signing public keys (the TapScript is literally "<PubKey 1> OP_CHECKSIG ... <PubKey N> OP_CHECKSIGADD OP_<N> OP_NUMEQUAL", so it doesn't solve the privacy problem.

That leaves Multi-leaf k-of-k multisig. Now to my understanding, in every TapLeaf/Branch, there is going to be a K-of-K TapScript similar to the one constructed above. In each leaf there will be a combination of K public keys, so the number of leaves is going to be equal to nCr(n,k).

No wonder why BIP 342 says that it's only cost-effective for small values of k, because the number of leaves and thus the transaction size swells as k increases.

Fortuantely, for the purposes of delegation, K will always be 1, because we only utilize 1-n multisig signatures as per my previous message. Thus the fee rate will be economical for all values of N i.e. number of delegatees. This enables this scheme to have a wider use case than just BIP322 (even here though, decreasing the raw transaction size of 'to_sign' is a net positive for space reasons).

In other words, every TapScript is just <PubKey> OP_CHECKSIG OP_1 OP_NUMEQUAL, which can be simplified to just <PubKey> OP_CHECKSIG since OP_CHECKSIG failure in a TapScript returns the empty vector (false) on failure, and 1 (true) on success. I wrote the longer script merely because it's consistent with the script format in [2], but since it's by no means a standardness requirement, we can save 2*N bytes in the entire transaction.

So, for small numbers of delegates, these savings are not very eye-watering, but if fees become larger then every byte will matter. After all, I envision uses for delegation beyond BIP 322 anyway.

At this point, the witness stack of 'to_sign' will have one of these TapScripts, and an appropriately constructed BIP 341 control block. Obviously 'to_spend''s output scriptPubKey will push the SHA256 hash of the witness program.

Use cases:
- BIP 322 (obviously)
- Any L2 protocol where participants' funds must be delegated to a comittee e.g. LN channels - which, in fact, are still using OP_CHECKMULTISIG.
-- Where such a protocol requires the joint consensus of all participants, such as an LN channel closing gracefully, K can be modified appropriately, but this is beyond the scope of this scheme. Make a BOLT or the appropriate standard proposal if this affects your L2 network.

Advantages where they are relevant for BIP 322 :

- Signature fraud is still impossible to carry out (the entire to_sign transaction still has to be verified, but now Address can be empty since the public key is in the control block which is in the 'to_sign' witness, and the spent TapScript is also in the 'to_sign' witness).
- Delegated signers still use standard address type (Bech32m Taproot addresses).
- No new opcodes are introduced, and no existing ones are redefined so no soft-forks are necessary.

Advantages for all applications of this BIP :

- Only the delegatee who actually signs the message has a revealed public key, the others' are hidden - a major privacy advantage.
- Signers must be determined beforehand. Jimmy Song actually lists this as a disadvantage, but I disagree. For L2 delegation, it is necessary to know the other parties to avoid a MITM attack where one of the signers is replaced by a rogue signer - through non-cryptographic methods of course (e.g. a computer hack).

Disadvantages :

- Taproot is not widely deployed in applications yet?
- I can't think of any others, unless you consider the signer's public key being revealed a disadvantage [I wouldn't, because if it were hidden, it would defeat the whole purpose of signing by making it vulnerable to the aforementioned "signature fraud"].

My grasp on Taproot constructs is not 100%. So feel free to point out any errors in my reasoning for this scheme if you spot any.

- Ali

[1] - https://jimmysong.github.io/taproot-multisig
[2] - https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#cite_ref-5-0

On Tue Aug 16 04:38:47 UTC 2022, ali at notatether.com wrote:
>(Note: I'm going to stick with this thread for all proposals for BIP322 polishing, not just delegation - unless the subject matter changes radically as other people discuss it.)
>
>Instead of the admittingly complicated scheme using transactions, I've created one that utilizes multisig to make the possible delegatees known at signing time. I had a discussion with vjudeu, garlonicon, and aliashraf about this over the past week or so, and while we did not reach a consensus about the solution to use, I feel that this scheme requires the least amount of modifications to BIP322 draft.
>
>The problem being solved is how to delegate signatures to other scriptPubKeys* [sic] for privacy purposes.
>
>*Here, I use P2WPKH addresses, under the assumption that the delegatees are people. If the delegatees are just some automated scripts or processes [as was mentioned in the BIP], then this scheme is equally valid with P2WSH multisignatures with appropriately constructed scriptPubKeys.
>
>What's about to follow was copied almost word-for-word from my forum post with extraneous paragraphs removed:
>
>---
>
>It is extremely simple and doesn't require any additional transactions:
>
>- Replace the message challenge of "to_spend" with a 1-of-N standard P2WPKH multisig. N is the number of people you want to be able to create the signature, and their respective pubkeys are included in the script.
>-- In this way the possible delegatees are fixed at signature creation time and cannot be extended by creating more transactions.
>- Replace the challenge solution in "to_sign" (it's the input that spends the output we made in "to_spend") with a witness stack containing: n <pub1> <pub2> ... <pubn> 1 <a-signature> 0
>-- The signature is generated as if it were for a real P2WPKH-multisig transaction. [the zero at the end is due to a bug in OP_CHECKMULTISIG that pops an extra element].
>
>appendix - don't mix up this delegation and Full with UTXOs together - it increases the numebr of permutations that implementations have to verify.
>
>Pros:
>
>- No recursive transactions.
>- If Alice and Bob are the two delegates of a signature (and one of them sign it), Carol does not know any of the private keys or challenge solutions and thus cannot claim the script was signed by her [besides the public keys of Alice and Bob are already in the signature]. Required, to avoid signature fraud.
>- The Address field is not used when delegating, so the engine can actually print which (compressed) public key it is signed against - i.e. the address verification is provable, as opposed to reactive Legacy signatures.
>-- Additionally, they will all be Segwit Bech32 addresses so it can just derive and print the corresponding bc1 address instead.
>- There is no opcode or new algorithm introduced, so no soft-fork is required.
>
>Cons:
>
>- Everyone knows the public keys of the delegators, so there is no privacy [then again, in light of the signature fraud problem, this is possibly a non-issue].
>
>---
>
>I'd like to hear everyone's opinions about this.
>
>I don't know who suggested the idea of delegation in the first place, but CCing luke-jr because he participated in that Github discussion, so his opinion about this scheme will clarify a lot of things about this problem.
>
>- Ali


From james.obeirne at gmail.com  Fri Aug 19 16:33:37 2022
From: james.obeirne at gmail.com (James O'Beirne)
Date: Fri, 19 Aug 2022 12:33:37 -0400
Subject: [bitcoin-dev] More uses for CTV
Message-ID: <CAPfvXfLvYbKWSWatkunwdcOYN_YTCayr=B_Rm90R+1nUW_zFCg@mail.gmail.com>

Over the past few months there have been a few potential uses of
OP_CHECKTEMPLATEVERIFY (BIP-119)
(https://github.com/bitcoin/bitcoin/pull/21702) that I've found
interesting.

# Congestion control redux

When I first heard of CTV, a presentation Jeremy did at Chaincode back
in 2018 or '19, he cited congestion control as one of its main use
cases.

The pitch went something like

> When there is a high demand for blockspace it becomes very expensive
> to make transactions. By using OP_CHECKTEMPLATEVERIFY, a large volume
> payment processor may aggregate all their payments into a single O(1)
> transaction for purposes of confirmation. Then, some time later, the
> payments can be expanded out of that UTXO when the demand for
> blockspace is decreased.

(from https://utxos.org/uses/scaling/)

At the time that didn't particularly grab me; the idea of smoothing fee
rates seemed nice but marginal.

But recently, two particular cases have made me reassess the value of
congestion control.

The first stems from the necessity of L2 protocols (payment channels,
vaults, etc.) to, under certain circumstances, settle to the chain in a
timely way in order to prevent abuse of the protocol. If some
unexpected condition (a protocol exploit, large network disconnect, en
masse vault breach, etc.) creates a situation where a large number of
contracts need to settle to the chain in short order, mempools could
fill up and protocol failures could happen for want of mempool/block
space
(
https://github.com/jamesob/mempool.work#failure-one-mempool-to-rule-them-all
).

In such a case, CTV could be used effectively to "compress" settlement
commitments, get them on-chain, and then facilitate later unpacking of
the CTV ouputs into the contract's true end state.

This amounts to `n` contract-control outputs (e.g. a lightning funding
transaction outputs) being spent into a single CTV output, which
commits to the final settlement state. Multiple parties could
trustlessly collaborate to settle into a single CTV output using
SIGHASH_ALL | ANYONECANPAY. This requires a level of interaction
similar to coinjoins.

Put simply, CTV allows deferring the chainspace required for the final
settlement outputs, but still immediately requires space for the
inputs. This might sound like a temporary reprieve from half-ish of the
space required to settle, but in many (most?) cases the outputs require
substantially more space than the inputs, given that often we're
settling a single UTXO into multiple payouts per party. A 2, 3, or
4-fold increase (depending on the contracting pattern) in capacity
isn't a silver bullet, but it could ameliorate the damage of unexpected
settlement "tidal waves."

Conceptually, CTV is the most parsimonious way to do such a scheme,
since you can't really get smaller than a SHA256 commitment, and that's
essentially all CTV is.

The second congestion control case is related to a recent post Bram
made about stability under a no-block-subsidy regime. He posted

> If transaction fees came in at an even rate over time all at the
> exact same level then they work fine for security, acting similarly
> to fixed block rewards. Unfortunately that isn't how it works in the
> real world. There's a very well established day/night cycle with fees
> going to zero overnight and even longer gaps on weekends and
> holidays. If in the future Bitcoin is entirely dependent on fees for
> security (scheduled very strongly) and this pattern keeps up
> (overwhelmingly likely) then this is going to become a serious
> problem.

(from
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-July/020702.html
)

Ryan Grant points out that CTV's congestion control use could help to
smooth fees, creating a less spiky incentive to mine
(
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-July/020702.html
).

Admittedly the original concern is speculative and a ways off from now,
as others in the thread pointed out. But having CTV-based fee smoothing
as an option certainly doesn't seem like a bad thing.


# Atomic mining pool payouts

Laurentia is a mining pool design that pays participants out directly
from the coinbase of found blocks.

> Block solve reward is distributed directly from the block to each
> user, meaning each user gets a 'mined' transaction directly into
> their wallet as soon as the block is solved so there is no wait to
> get paid and no pool wallet storing user's rewards.

(from
https://laurentiapool.org/wp-content/uploads/2020/05/laurentiapool_whitepaper.pdf
)

I'm not a mining expert and so I can't speak to the efficacy of the
paper as a whole, but direct-from-coinbase payouts seem like a
desirable feature which avoids some trust in pools. One limitation is
the size of the coinbase outputs owed to constituent miners; this
limits the number of participants in the pool.

If the payout was instead a single OP_CTV output, an arbitrary number
of pool participants could be paid out "atomically" within a single
coinbase.

---

CTV both in concept and implementation is very simple, and I think it
is likely to continue to yield potential applications.
"Settlement compression" seems like a useful thing, especially in light
of a possible increase in L2 usage, and CTV seems like the simplest
means to enable it.

Interestingly, an analogue for this pattern going the other direction
is possible, e.g. non-interactive channel openings
(https://utxos.org/uses/non-interactive-channels/), which would allow
e.g. opening a lightning channel with a merchant who doesn't want to
have their spending keys constantly accessible from a point-of-sale,
but can still parse/verify CTV commitments.

Regards,
James
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220819/9af239a2/attachment.html>

From gsanders87 at gmail.com  Fri Aug 19 17:20:41 2022
From: gsanders87 at gmail.com (Greg Sanders)
Date: Fri, 19 Aug 2022 13:20:41 -0400
Subject: [bitcoin-dev] More uses for CTV
In-Reply-To: <CAPfvXfLvYbKWSWatkunwdcOYN_YTCayr=B_Rm90R+1nUW_zFCg@mail.gmail.com>
References: <CAPfvXfLvYbKWSWatkunwdcOYN_YTCayr=B_Rm90R+1nUW_zFCg@mail.gmail.com>
Message-ID: <CAB3F3DvMMjfV0eS4DvEzXdKLNa+549-ctLNHON8JQBzxWjKD-A@mail.gmail.com>

Hi James,

Could you elaborate on a L2 contract where speedy
settlement of the "first part" can be done, while having the rest
take their time? I'm more thinking about time-out based protocols.

Naturally my mind drifts to LN, where getting the proper commitment
transaction confirmed in a timely fashion is required to get the proper
balances back. The one hitch is that for HTLCs you still need speedy
resolution otherwise theft can occur. And given today's "layered
commitment" style transaction where HTLCs are decoupled from
the balance output timeouts, I'm not sure this can save much.

I don't know enough about vault designs to judge.

CTV style commitments have popped up in a couple places in my
work on eltoo(emulated via APO sig-in-script), but mostly in the
context of reducing interactivity in protocols, not in byte savings per se.

Thanks!

Greg

On Fri, Aug 19, 2022 at 12:34 PM James O'Beirne via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Over the past few months there have been a few potential uses of
> OP_CHECKTEMPLATEVERIFY (BIP-119)
> (https://github.com/bitcoin/bitcoin/pull/21702) that I've found
> interesting.
>
> # Congestion control redux
>
> When I first heard of CTV, a presentation Jeremy did at Chaincode back
> in 2018 or '19, he cited congestion control as one of its main use
> cases.
>
> The pitch went something like
>
> > When there is a high demand for blockspace it becomes very expensive
> > to make transactions. By using OP_CHECKTEMPLATEVERIFY, a large volume
> > payment processor may aggregate all their payments into a single O(1)
> > transaction for purposes of confirmation. Then, some time later, the
> > payments can be expanded out of that UTXO when the demand for
> > blockspace is decreased.
>
> (from https://utxos.org/uses/scaling/)
>
> At the time that didn't particularly grab me; the idea of smoothing fee
> rates seemed nice but marginal.
>
> But recently, two particular cases have made me reassess the value of
> congestion control.
>
> The first stems from the necessity of L2 protocols (payment channels,
> vaults, etc.) to, under certain circumstances, settle to the chain in a
> timely way in order to prevent abuse of the protocol. If some
> unexpected condition (a protocol exploit, large network disconnect, en
> masse vault breach, etc.) creates a situation where a large number of
> contracts need to settle to the chain in short order, mempools could
> fill up and protocol failures could happen for want of mempool/block
> space
> (
> https://github.com/jamesob/mempool.work#failure-one-mempool-to-rule-them-all
> ).
>
> In such a case, CTV could be used effectively to "compress" settlement
> commitments, get them on-chain, and then facilitate later unpacking of
> the CTV ouputs into the contract's true end state.
>
> This amounts to `n` contract-control outputs (e.g. a lightning funding
> transaction outputs) being spent into a single CTV output, which
> commits to the final settlement state. Multiple parties could
> trustlessly collaborate to settle into a single CTV output using
> SIGHASH_ALL | ANYONECANPAY. This requires a level of interaction
> similar to coinjoins.
>
> Put simply, CTV allows deferring the chainspace required for the final
> settlement outputs, but still immediately requires space for the
> inputs. This might sound like a temporary reprieve from half-ish of the
> space required to settle, but in many (most?) cases the outputs require
> substantially more space than the inputs, given that often we're
> settling a single UTXO into multiple payouts per party. A 2, 3, or
> 4-fold increase (depending on the contracting pattern) in capacity
> isn't a silver bullet, but it could ameliorate the damage of unexpected
> settlement "tidal waves."
>
> Conceptually, CTV is the most parsimonious way to do such a scheme,
> since you can't really get smaller than a SHA256 commitment, and that's
> essentially all CTV is.
>
> The second congestion control case is related to a recent post Bram
> made about stability under a no-block-subsidy regime. He posted
>
> > If transaction fees came in at an even rate over time all at the
> > exact same level then they work fine for security, acting similarly
> > to fixed block rewards. Unfortunately that isn't how it works in the
> > real world. There's a very well established day/night cycle with fees
> > going to zero overnight and even longer gaps on weekends and
> > holidays. If in the future Bitcoin is entirely dependent on fees for
> > security (scheduled very strongly) and this pattern keeps up
> > (overwhelmingly likely) then this is going to become a serious
> > problem.
>
> (from
>
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-July/020702.html
> )
>
> Ryan Grant points out that CTV's congestion control use could help to
> smooth fees, creating a less spiky incentive to mine
> (
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-July/020702.html
> ).
>
> Admittedly the original concern is speculative and a ways off from now,
> as others in the thread pointed out. But having CTV-based fee smoothing
> as an option certainly doesn't seem like a bad thing.
>
>
> # Atomic mining pool payouts
>
> Laurentia is a mining pool design that pays participants out directly
> from the coinbase of found blocks.
>
> > Block solve reward is distributed directly from the block to each
> > user, meaning each user gets a 'mined' transaction directly into
> > their wallet as soon as the block is solved so there is no wait to
> > get paid and no pool wallet storing user's rewards.
>
> (from
>
> https://laurentiapool.org/wp-content/uploads/2020/05/laurentiapool_whitepaper.pdf
> )
>
> I'm not a mining expert and so I can't speak to the efficacy of the
> paper as a whole, but direct-from-coinbase payouts seem like a
> desirable feature which avoids some trust in pools. One limitation is
> the size of the coinbase outputs owed to constituent miners; this
> limits the number of participants in the pool.
>
> If the payout was instead a single OP_CTV output, an arbitrary number
> of pool participants could be paid out "atomically" within a single
> coinbase.
>
> ---
>
> CTV both in concept and implementation is very simple, and I think it
> is likely to continue to yield potential applications.
> "Settlement compression" seems like a useful thing, especially in light
> of a possible increase in L2 usage, and CTV seems like the simplest
> means to enable it.
>
> Interestingly, an analogue for this pattern going the other direction
> is possible, e.g. non-interactive channel openings
> (https://utxos.org/uses/non-interactive-channels/), which would allow
> e.g. opening a lightning channel with a merchant who doesn't want to
> have their spending keys constantly accessible from a point-of-sale,
> but can still parse/verify CTV commitments.
>
> Regards,
> James
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220819/5b1465f3/attachment-0001.html>

From aliashraf.btc at protonmail.com  Fri Aug 19 17:21:03 2022
From: aliashraf.btc at protonmail.com (aliashraf.btc At protonmail)
Date: Fri, 19 Aug 2022 17:21:03 +0000
Subject: [bitcoin-dev] Surprisingly, Tail Emission Is Not Inflationary
In-Reply-To: <abd33vsLrsQ7z5vJjz9h1V-3iEHJW1os1HyiO6QO5PNA8kahcPZ_2BUNuU7i4gyFRT2peLu0NXNrWv5X3RGGR6cvqijishTcb1qvo3YPeSU=@pointbiz.com>
References: <abd33vsLrsQ7z5vJjz9h1V-3iEHJW1os1HyiO6QO5PNA8kahcPZ_2BUNuU7i4gyFRT2peLu0NXNrWv5X3RGGR6cvqijishTcb1qvo3YPeSU=@pointbiz.com>
Message-ID: <xcXwPxo9HRhMxQw9KIiDEfb6f4p6rY-24v3JUVHH2fkS7IcTK1Qe_7Hw4nJbGwdf6Guh0kS_nlPF-kzCVeS2MAioQmdjzpkGJibzyMj2JY0=@protonmail.com>

Hi Peter, everyone
This issue has been discussed thoroughly in bitcointalk, general discussions are more suited to forums, I believe, still ....

First and foremost, it is more than obvious that bitcoin block subsidy algorithm is a total disaster, not just for the zero subsidy security consequences, but also for the overly rewarding scheme that favors (few) first-runners against (masses of) people who join later, a policy that looks to be a cheap marketing trick rather than a decent strategic monetary, system design, no matter how natural it is presumed nowadays, after being implemented by Bitcoin.

For now, the brilliance of the idea behind Bitcoin and the enthusiasm have compensated for its bizzar, upside-down inflation policy, in practice as newcomers have been paying the price to lucky first-runners and adopting anyway.
Is it happening for low block subsidy? Is it going to be solved somehow? I don't think so.

With subsidy still being the major (like 90%) portion of the block reward, there is an equalizer factor pushing equilibrium by paying security costs on behalf of current coin owners.Note that every single new bitcoin paid as subsidy is actually paid by the rest of the wallets proportional to their balance.
Other than its direct contribution to security, once understood as a ballance-based taxing scheme, it is a crucial mechanism for re-distribution of wealth because to compensate for their costs, unlike speculators (who are among the worst adopters of Bitcoin, and unfortunately the most influencers), miners are used to dumping their coins, providing more fair opportunities for people to join.
So, halving and the hard cap, put both adoption and security as risk, It is why, unlike "believers", I'm deeply concerned about a future with low block subsidy because it puts both security and adoption in an awkward situation.

Additionally, It is not considered an engineering practice by any measure to speculate about the security of a system that we abundantly recommend to friends, family for joining.
We need proofs, security proof, ease of adaptation proof, etc.,
Fantasies are not proofs, having faith in a magical incentive mechanism that fixes everything is not an argument, let alone being a proof.
Incentives are irrelevant, rules, schemes, projects, and so fort, matter. There are always incentives in games, but rules are in charge of determining the fate.
Without rules, there is no game, flawed schemes and rules move the game behind its equilibrium to fail eventually.

I've not to mention the unfeasibility of tempering Bitcoin's basic consensus rules, Bitcoin rules are not subject to change specially when it comes to something that is widely considered a basic characteristic, a Schelling point, and so forth.

So, it is the paradoxical situation: we are exposed to, on one hand, it is a deficiency and on the other hand it is inevitable because is critically hard-code to Bitcoin, advertised more than any feature as its identity.
But it is our job, isn't it? Dealing with the impossible and taking care of it, but I think before reaching to that point we have to settle the basics.:

- There is a problem with long term security and adoption consequences.
- It is built deeply to bitcoin consensus rules, and considered a critical
- It is not going to disappear magically, neither it will be addressed by whales, etc.
- The 21M cap, halving, and generally, Bitcoin consensus, is not subject to change.

Don't panic, it is not exactly a catch-22 situation. Tip:
It is always possible to help a system without aggressive intervention, either by smart tweaks or by supporting it using other system(s).

Cheers, Ali Ashraf

------- Original Message -------
On Tuesday, August 16th, 2022 at 8:35 PM, Peter via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi Jaroslaw,

> In the Prisoner's Dilemma the prisoners cannot communicate. In Bitcoin large holders are able to communicate with each other. Also, prisoners need not make an all or nothing decision in Bitcoin. Miners can join and leave the network freely over time. You can change your decision based on the decision of others.
>
> The Bitcoin design is such that security is volatile but the issuance of blocks is timely and evened out to a 10 minutes average even after the reward is exhausted.
>
> The existing incentive that miners earn money for including transactions is enough to motivate human nature. Transaction initiators have an incentive to mine and run full nodes for personal interest.
>
>>Noone will waste his renewable energy on unprofitable Antminer while he/she can sell this energy for the market price.
>
> The law in most jurisdictions prevents the resale of spare electricity unless an expensive license is obtained (and in most cases no license is available as the government maintains a monopoly). Mining with waste electricity is reducing losses. Another incentive to motivate human nature.
>
> Bitcoin holders can be enfranchised into any new system. So, no need for bike shedding the original design which is a Schelling Point.
>
> Regards
>
> Peter Kroll
>
> pointbiz/ BTCCuracao
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220819/5d3300ef/attachment.html>

From dave at dtrt.org  Fri Aug 19 18:53:39 2022
From: dave at dtrt.org (David A. Harding)
Date: Fri, 19 Aug 2022 08:53:39 -1000
Subject: [bitcoin-dev] More uses for CTV
In-Reply-To: <CAPfvXfLvYbKWSWatkunwdcOYN_YTCayr=B_Rm90R+1nUW_zFCg@mail.gmail.com>
References: <CAPfvXfLvYbKWSWatkunwdcOYN_YTCayr=B_Rm90R+1nUW_zFCg@mail.gmail.com>
Message-ID: <813858beca9d1d033fbb0a26921162d6@dtrt.org>

On 2022-08-19 06:33, James O'Beirne via bitcoin-dev wrote:
> Multiple parties could
> trustlessly collaborate to settle into a single CTV output using
> SIGHASH_ALL | ANYONECANPAY. This requires a level of interaction
> similar to coinjoins.

Just to make sure I understand, is the reason for SH_ALL|SH_ACP so that 
any of the parties can subsequently RBF fee bump the transaction?

> Conceptually, CTV is the most parsimonious way to do such a scheme,
> since you can't really get smaller than a SHA256 commitment

What's the advantage of CTV here compared to presigned transactions?  If 
multiple parties need to interact to cooperatively sign a transaction, 
no significant overhead is added by having them simultaneously sign a 
second transaction that spends from the output of the first transaction. 
  Presigned transactions actually have two small benefits I can think of:

1. The payment from the first transaction (containing the spends from 
the channel setup transactions) can be sent to a P2WPKH output, which is 
actually smaller than a SHA256 commitment.  Though this probably does 
require an extra round of communication for commit-and-reveal to prevent 
a collision attack on the P2WPKH address.[1]

2. Having the first transaction pay a either a P2WPKH or bech32m output 
and the second transaction spend from that UTXO may blend in better with 
other transactions, enhancing privacy.  This advantage probably isn't 
compatible with SH_ALL|SH_ACP, though, and it would require other 
privacy upgrades to LN.

> direct-from-coinbase payouts seem like a
> desirable feature which avoids some trust in pools.
> [...]
> If the payout was instead a single OP_CTV output, an arbitrary number
> of pool participants could be paid out "atomically" within a single
> coinbase.  One limitation is
> the size of the coinbase outputs owed to constituent miners; this
> limits the number of participants in the pool.

I'm confused by this.  What is the size limitation on coinbase outputs, 
how does it limit the number of participants in a pool, and how does CTV 
fix that?

Thanks,

-Dave

[1] 
https://bitcoinops.org/en/newsletters/2020/06/24/#reminder-about-collision-attack-risks-on-two-party-ecdsa

From jeremy.l.rubin at gmail.com  Fri Aug 19 21:01:25 2022
From: jeremy.l.rubin at gmail.com (Jeremy Rubin)
Date: Fri, 19 Aug 2022 14:01:25 -0700
Subject: [bitcoin-dev] More uses for CTV
In-Reply-To: <813858beca9d1d033fbb0a26921162d6@dtrt.org>
References: <CAPfvXfLvYbKWSWatkunwdcOYN_YTCayr=B_Rm90R+1nUW_zFCg@mail.gmail.com>
 <813858beca9d1d033fbb0a26921162d6@dtrt.org>
Message-ID: <CAD5xwhhE=wt+XUJsUdMrSR+GpuEHpYoig=-Nk+mux6=bh1FrEA@mail.gmail.com>

Presigned transactions have to use a N-of-N (2-2 for ln, more for pools)
multisignature which is computed over the network whereas in-script
commitments can be done 1 key that is a non-secret point (e.g., just the
generator I think works).

For large protocol trees (e.g., of size N) the savings can be substantial!
It also reduces the amount of state that needs to be stored since the
in-script sigs can be deterministic.

Rene has some nice work demonstrating that latency in generating state
transitions has a very substantial cost to the efficiency of routing, maybe
he can chime in further.


You can also do a "back-filling" where you get the best of both, by (after
you commit to the quick to generate in-script version) lazily backfilling
with an equivalent p2wpkh version. If you have a channel, when you are in
"burst mode", you can cancel the longer to generate p2wpkh version when
newer states come in. (data hazard/ bypass).


With respect to mining pools and size constraints,
https://rubin.io/bitcoin/2021/12/12/advent-15/ shows how paying into
batches of channels can be used to trustlessly compress payouts without
custodial relationship.


--
@JeremyRubin <https://twitter.com/JeremyRubin>

On Fri, Aug 19, 2022 at 11:53 AM David A. Harding via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On 2022-08-19 06:33, James O'Beirne via bitcoin-dev wrote:
> > Multiple parties could
> > trustlessly collaborate to settle into a single CTV output using
> > SIGHASH_ALL | ANYONECANPAY. This requires a level of interaction
> > similar to coinjoins.
>
> Just to make sure I understand, is the reason for SH_ALL|SH_ACP so that
> any of the parties can subsequently RBF fee bump the transaction?
>
> > Conceptually, CTV is the most parsimonious way to do such a scheme,
> > since you can't really get smaller than a SHA256 commitment
>
> What's the advantage of CTV here compared to presigned transactions?  If
> multiple parties need to interact to cooperatively sign a transaction,
> no significant overhead is added by having them simultaneously sign a
> second transaction that spends from the output of the first transaction.
>   Presigned transactions actually have two small benefits I can think of:
>
> 1. The payment from the first transaction (containing the spends from
> the channel setup transactions) can be sent to a P2WPKH output, which is
> actually smaller than a SHA256 commitment.  Though this probably does
> require an extra round of communication for commit-and-reveal to prevent
> a collision attack on the P2WPKH address.[1]
>
> 2. Having the first transaction pay a either a P2WPKH or bech32m output
> and the second transaction spend from that UTXO may blend in better with
> other transactions, enhancing privacy.  This advantage probably isn't
> compatible with SH_ALL|SH_ACP, though, and it would require other
> privacy upgrades to LN.
>
> > direct-from-coinbase payouts seem like a
> > desirable feature which avoids some trust in pools.
> > [...]
> > If the payout was instead a single OP_CTV output, an arbitrary number
> > of pool participants could be paid out "atomically" within a single
> > coinbase.  One limitation is
> > the size of the coinbase outputs owed to constituent miners; this
> > limits the number of participants in the pool.
>
> I'm confused by this.  What is the size limitation on coinbase outputs,
> how does it limit the number of participants in a pool, and how does CTV
> fix that?
>
> Thanks,
>
> -Dave
>
> [1]
>
> https://bitcoinops.org/en/newsletters/2020/06/24/#reminder-about-collision-attack-risks-on-two-party-ecdsa
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220819/3a8aa2ca/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Sat Aug 20 03:03:52 2022
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 20 Aug 2022 03:03:52 +0000
Subject: [bitcoin-dev] More uses for CTV
In-Reply-To: <CAB3F3DvMMjfV0eS4DvEzXdKLNa+549-ctLNHON8JQBzxWjKD-A@mail.gmail.com>
References: <CAPfvXfLvYbKWSWatkunwdcOYN_YTCayr=B_Rm90R+1nUW_zFCg@mail.gmail.com>
 <CAB3F3DvMMjfV0eS4DvEzXdKLNa+549-ctLNHON8JQBzxWjKD-A@mail.gmail.com>
Message-ID: <h7uL5jH1cnGVVpA7k_F0O7aHQALl2ICqAlISd2gdvf3XKQiSjTFlEvIqqysvyhmQ3O52HbVoox2WZYTyjZDaWfTdvRx3Ef4YJVqty5MEaXI=@protonmail.com>


Good morning Greg,


> Hi James,
> Could you elaborate on a L2 contract where speedy
> settlement of the "first part" can be done, while having the rest
> take their time? I'm more thinking about time-out based protocols.
> 
> Naturally my mind drifts to LN, where getting the proper commitment
> transaction confirmed in a timely fashion is required to get the proper
> balances back. The one hitch is that for HTLCs you still need speedy
> resolution otherwise theft can occur. And given today's "layered
> commitment" style transaction where HTLCs are decoupled from
> the balance output timeouts, I'm not sure this can save much.

As I understand it, layered commitments can be modified to use `OP_CTV`, which would be slightly smaller (need only to reveal a 32-byte `OP_CTV` hash on the witness instead of a 64-byte Taproot signature, or 73-byte classical pre-Taproot ECDSA signature), and is in fact precisely an example of the speedy settlement style.

> CTV style commitments have popped up in a couple places in my
> work on eltoo(emulated via APO sig-in-script), but mostly in the
> context of reducing interactivity in protocols, not in byte savings per se.

In many offchain cases, all channel participants would agree to some pre-determined set of UTXOs, which would be implemented as a transaction spending some single UTXO and outputting the pre-determined set of UTXOs.

The single UTXO can be an n-of-n of all participants, so that all agree by contributing their signatures:

* Assuming Taproot, the output address itself is 33 bytes (x4 weight).
* The n-of-n multisignature is 64 witness bytes (x1 weight). 

Alternatly the single UTXO can be a P2WSH that reveals an `OP_CTV`:

* The P2WSH is 33 bytes (x4 weight) --- no savings here.
* The revelation of the `<hash> OP_CTV` is 33 witness bytes (x1 weight).

Thus, as I understand it, `OP_CTV` can (almost?) always translate to a small weight reduction for such "everyone agrees to this set of UTXOs" for all offchain protocols that would require it.


Regards,
ZmnSCPxj

From alicexbt at protonmail.com  Sat Aug 20 08:20:00 2022
From: alicexbt at protonmail.com (alicexbt)
Date: Sat, 20 Aug 2022 08:20:00 +0000
Subject: [bitcoin-dev] joinstr: coinjoin implementation using nostr
Message-ID: <7gXWd6OVJjiW7aCeon8q-xlWfCMJkIEVCaeokjSVI16OvQPkPmEsSeGY0cGu4yVveimNUYsyG18Ro7JgUutfqXv5wKMMgJZD2c8ftAMFcbQ=@protonmail.com>

Hi Bitcoin Developers,

I have written a python script as proof of concept for the [coinjoin implementation][1] using [nostr][2]. I used a lot of Python scripts created by others in school, so it feels nice to offer something that could be useful to others.

The implementation uses Bitcoin Core wallet and RPCs: `listunspent`, `getnewaddress`, `scantxoutset`, `createpsbt`, `combinepsbt`, `finalizepsbt` and `sendrawtransaction`. It requires python-nostr library because nostr is used for coordination between peers. Nostr is a decentralized network based on cryptographic keypairs. It is not peer-to-peer however simple and scalable.

Every step is published as an event using a nostr relay and 5 peers coordinate to create, sign and broadcast a coinjoin transaction.  I need to write a NIP that would be an alternative to blind signatures. Relay will share a random secret with clients for one round which should be present in output registration request although never gets published. If someone tries to register an output without registering any inputs, request would not have the number initially shared with inputs so request would get rejected or published as unverified. Relay would not be able to link inputs and outputs as the number is same for all inputs in a round and they get registered at different times with new keys and IP address. Clients can use multiple relays at the same time to avoid trusting one relay. This would result in different shared secret number but same process. If a relay tries to cheat, users will not sign the transaction and avoid using it in future.

Usage:

 1)Run `python coinjoin.py` and enter descriptor for one of the inputs.
 2)Script will check inputs for this round in every 30 seconds and register a new adddress for output once 5 inputs are registered.
 3)Similar check happens every 30 seconds for outputs. Last peer should create a PSBT.
 4)Unsigned PSBT will be printed and signed by wallet with `walletprocesspsbt` RPC.
 5)Script will check signed PSBTs and last peer to sign should finalize coinjoin transaction once 5 signed PSBTs are received.
 6)Coinjoin transaction will be broadcasted and txid will printed.

Example:

```
List of utxos in wallet:

wpkh([53830dca/84'/1'/0'/0/0]02449be5fb74725255eeeb50eba930fa87705f21e99d13cd710cf2c1f21153c808)#x2hyyeg5

Enter descriptor for the input registration: wpkh([53830dca/84'/1'/0'/0/0]02449be5fb74725255eeeb50eba930fa87705f21e99d13cd710cf2c1f21153c808)#x2hyyeg5

event id:  bcbbe62d75d99fed73f1e50ac58a38d1840b658951893e63c0322b378d7d56f0

```
```
tb1qhxrp4zl54ul0twtyz0gury5399q7z0kvqqrl6m registered for output

event id: 9449c9065bef356d21507a98f88b028b17fc1c49eb195c8d4420604fcaaef041
```
```
Unsigned PSBT: cHNidP8BAP1yAQIAAAAFtMaoJYcXvOG5L3Yaz3YyS7gIt4h5/zzOrRRS3hrVvwoAAAAAAP////+o83geaSm4L76KToIUl5MiZqLAUbIDJLq6DWrjP/3b8AEAAAAA/////zEF3CXIvVHpIa7No1s1yg+KtyOfXTRSyWnOdXMfzcDwAQAAAAD/////wMa4XAgnU+39Ien+KG9rYtv8bLMNYakmZyY/QFfwLRcAAAAAAP/////5M42ID6uLmQTb2tnFHnN7UMpnDD25uN8ZX7A+GNSM3QEAAAAA/////wV4xwEAAAAAABYAFLmGGov0rz71uWQT0cGSkSlB4T7MeMcBAAAAAAAWABSc0/FM6Hdbdxh10IJkYOklVFWqjnjHAQAAAAAAFgAUPSZKe/w6PT6qIF+WhL4wHaFymjd4xwEAAAAAABYAFMx0rxYlpPWB3NFry4Ctk2eVi/UNeMcBAAAAAAAWABSzc4xK0VTfvjK0MHXrAUFLYgYnOgAAAAAAAAAAAAAAAAAAAA==

event id: 976744b38fa9343fb79e1b5215512ead6ee08e5890d79a201fc5b872f6de4eba
```
```
Signed PSBT: cHNidP8BAP1yAQIAAAAFtMaoJYcXvOG5L3Yaz3YyS7gIt4h5/zzOrRRS3hrVvwoAAAAAAP////+o83geaSm4L76KToIUl5MiZqLAUbIDJLq6DWrjP/3b8AEAAAAA/////zEF3CXIvVHpIa7No1s1yg+KtyOfXTRSyWnOdXMfzcDwAQAAAAD/////wMa4XAgnU+39Ien+KG9rYtv8bLMNYakmZyY/QFfwLRcAAAAAAP/////5M42ID6uLmQTb2tnFHnN7UMpnDD25uN8ZX7A+GNSM3QEAAAAA/////wV4xwEAAAAAABYAFLmGGov0rz71uWQT0cGSkSlB4T7MeMcBAAAAAAAWABSc0/FM6Hdbdxh10IJkYOklVFWqjnjHAQAAAAAAFgAUPSZKe/w6PT6qIF+WhL4wHaFymjd4xwEAAAAAABYAFMx0rxYlpPWB3NFry4Ctk2eVi/UNeMcBAAAAAAAWABSzc4xK0VTfvjK0MHXrAUFLYgYnOgAAAAAAAQBxAgAAAAG+qpMXZCy6tBuUlgo8JD0GVXKp60FkhwDeg2sF1fkFkwMAAAAA/f///wLo9wEAAAAAABYAFFfLA5xarC/w/SxeMDQ5tuXrYJLUWwMAAAAAAAAWABRfPf//hwMjHB4OKj87cU19XOSh7yOWAQABAR/o9wEAAAAAABYAFFfLA5xarC/w/SxeMDQ5tuXrYJLUAQhrAkcwRAIgOIhLoC5348U8YkEr4GU1K4yWskIOEXgW4Wsk/W2cR7ICIEJXqtOuDJ5CkwrSuwJLWtzab4dslbN3KuL/pyooMnOCASECRJvl+3RyUlXu61DrqTD6h3BfIemdE81xDPLB8hFTyAgAAAAAACICA77Cnd6o3kr0yc+91eabpOn5igs/MUMbudNYSS6oyMWMGFODDcpUAACAAQAAgAAAAIAAAAAAFAAAAAAAAAAA

event id: 5846b6e6902f3c5a43496d7d9785ed62444aa74963f03c33d637d8b09ee7a139
```
```
Coinjoin tx: 75e490b10b15a6a0422f25ff66ad98ef70390c8fecaac02712705dce8cc3564b

event id: 9b5d4bf279b59e2b6e539e683fba83da72dce2b640360aa95db1b1400be93190
```

There are lot of things that could be improved and a few suggestions are in the gist that described the [idea][3]. I would love read to any opinions about this experiment and will start working on creating an Android app for joinstr next week.

Credits:

- fiatjaf (Nostr)
- Andrew Chow (PSBT)
- Jeff Thibault (python-nostr)
- Existing coinjoin implmentations

[1]: https://github.com/1440000bytes/joinstr
[2]: https://github.com/nostr-protocol/nostr
[3]: https://gist.github.com/1440000bytes/1c305097b070c8374cc3b91f50314a45

/dev/fd0

Sent with Proton Mail secure email.

From max at towardsliberty.com  Sat Aug 20 10:04:11 2022
From: max at towardsliberty.com (Max Hillebrand)
Date: Sat, 20 Aug 2022 12:04:11 +0200
Subject: [bitcoin-dev] joinstr: coinjoin implementation using	nostr
In-Reply-To: <7gXWd6OVJjiW7aCeon8q-xlWfCMJkIEVCaeokjSVI16OvQPkPmEsSeGY0cGu4yVveimNUYsyG18Ro7JgUutfqXv5wKMMgJZD2c8ftAMFcbQ=@protonmail.com>
References: <7gXWd6OVJjiW7aCeon8q-xlWfCMJkIEVCaeokjSVI16OvQPkPmEsSeGY0cGu4yVveimNUYsyG18Ro7JgUutfqXv5wKMMgJZD2c8ftAMFcbQ=@protonmail.com>
Message-ID: <11A4C398-8CEA-4FDF-B450-55649E6CA1FF@pretty.Easy.privacy>

Great to see an implementation of the idea.

Maybe I misunderstand, but isn't there a vulnerability of denial of service here?

A user who registers one input will receive the round secret identifier, and this is all the information required for output registration. However, that malicious user can now register multiple outputs, providing the same secret, and nobody can link the malicious outputs to any specific input. Therefor there cannot be a blame round where the malicious input is removed, and thus there can be a ongoing free denial of service attack without attribution or defense.

Skol
Max
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220820/ed6040a1/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: sender_key.asc
Type: application/pgp-keys
Size: 3910 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220820/ed6040a1/attachment.bin>

From ali at notatether.com  Sat Aug 20 13:49:05 2022
From: ali at notatether.com (Ali Sherief)
Date: Sat, 20 Aug 2022 13:49:05 +0000
Subject: [bitcoin-dev] [BIP] Implementing Multisig Using Taproot
Message-ID: <20220820134850.ofvz7225zwcyffit@artanis>

Greetings list.

Following the discussions I made about BIP322 delegation on this mailing list and in other places, I have decided that that delegation depends on a very similar problem that arises when writing contracts and commitments. That problem is how to implement private Multisig.

Of course, this can already be done using Taproot. But I doubt that many people know how to do it using script paths. BIP342 briefly touches on the subject but leaves it open. So I wrote a BIP to plug this hole, that precisely follows the guidelines hinted by BIPs 341 and 342, for creating and spending Multisig outputs.

I also managed to figure out the formula that BIP342 vaguely hinted at for figuring out "cost-effective multisignatures" (hint: it's not quadratic).

As far as I can tell, such a BIP hasn't been advanced before, so there should be no problem of "try working on the other BIP".

Use cases:

- Layer 2 protocols that use multisig (e.g. LN, Discrete Log Contracts)
- BIP322 message signatures, if it is decided that UTXO delegation is desireable.

I'm pasting the draft of the BIP below, with the metadata shaved off, but references are left intact. I haven't uploaded it to Github yet.

--------

== Summary ==

This document defines the proper way to construct Multisig outputs and spends that utilize the privacy provided by Taproot script paths.

== Copyright ==

This document is licensed under the 2-clause BSD license.

== Abstract ==

A Multisignature (also called Multisig) unspent transaction output (UTXO) attached to an address allows two or more parties to restrict the spending of the UTXO inside the address until a specified number of parties sign the output spending it. Multisig UTXOs are extremely useful for creating contracts, and is therefore used in many applications where delegation of funds to a committee is required, such as in Lightning Network channels, in DLCs (Discrete Log Contracts), and in other kinds of contracts.

== Motivation ==

OP_CHECKMULTISIG has the disadvantage of revealing all co-signer public keys involved in a transaction. This compromises the privacy of those signers. Additionally, this construct is not compatible with Taproot because OP_CHECKMULTISIG is disabled in TapScript, thus those applications are unable to make use of Pay-to-Taproot (P2TR) addresses.

Constructing a Multisig output on Taproot is technically possible, but its implementation has not been specified by any existing BIP, to the author's knowledge. Additionally, most developers of Bitcoin applications do not know how to construct Multisig Taproot outputs.

== Design ==

Taproot gives us three different options for implementing Multisig, each with their own advantages and disadvantages<ref>'''Multisig implementation options reference''' The options were originally enumerated in [https://jimmysong.github.io/taproot-multisig Jimmy Song's slideshow] in a more detailed manner.</ref>:
# Single-leaf with a TapScript implementing K-of-N Multisig. This is functionally equivalent to legacy OP_CHECKMULTISIG, and shares all its advantages and disadvantages. In particular, all public keys of signers are revealed in the TapScript embedded in the first element of the witness program, so the privacy advantages of Taproot are compromised.
# Multiple leaves, each with a TapScript implementing K-of-K Multisig.
# Multiple leaves, each with a TapScript implementing MuSig of K keys (i.e. aggregate of K public keys).

This document uses the second option for implementing Multisig, because it only reveals the public keys of those who sign the transaction.<ref>'''Why wasn't MuSig considered?''' Although MuSig provides even more privacy by not revealing any original public keys all together, it is a cumbersome process to create since K parties must be online not only at one point to create the aggregated keys, but also at another point to create a signature. There is the problem of who will be the trustee of the MuSigs themselves, as opposed to just the delegated UTXOs. Also, There is no BIP that implements MuSig, to the author's knowledge.</ref>

== Specification ==

Notations used here are specified in [[bip-0340.mediawiki#design|BIP340]].

''taproot_output_script'' and ''taproot_sign_script'' refers to the Python functions of [[bip-0341.mediawiki|BIP341]] with the same name.

=== Constructing K-of-N Multisig outputs ===

All of the participating TapScripts must be collected together at construction-time. This implies that all signers must know each other beforehand<ref>'''Why should all signers know each other beforehand?''' Knowing all possible signers of a multisignature is required for many instances of delegation, so that an unknown party cannot insert a rogue signature at spending-time.</ref>.

The algorithm takes as inputs:
* An integer value  ''m'', greater than 0
* An array ''scripts'' of ''m'' TapScripts as byte-arrays.
** The scripts must be written in the following format: "[PubKey p<sub>1</sub>] OP_CHECKSIG [PubKey p<sub>2</sub>] OP_CHECKSIGADD ... [PubKey p<sub>K</sub>] OP_CHECKSIGADD OP_[K] OP_NUMEQUAL"<ref>'''1-of-N Multisig TapScripts''', it is possible to save two bytes in each script by dropping "OP_[K] OP_NUMEQUAL" from the end of each script. Since OP_CHECKSIG will return 1 on success and the empty array on failure, and the script interpreter considers a final stack of truthy values such as 1 as the script succeeding, and likewise for falsy values such as the empty array, the additional OP_NUMEQUAL comparison and associated number push is redundant.</ref>
Where the list p<sub>1</sub> ... p<sub>K</sub> represents a unique combination of K public keys from the total set of N public keys. In this way, each TapScript is a K-of-K multisig, requiring the signatures of all parties participating in the TapLeaf.

And returns as the outputs:
* The scriptPubKey, including the hash of the generated withness program and the push bytes.

Algorithm steps:
# Generate a random private key ''p'', in the range ''[0, n-1]''.
# Set the internal key ''internal_pubkey'' to ''lift_x(0x0250929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0) + p*G''<ref>'''Why is an arbitrary public key used for signing and spending?''' All possible combinations of multisignature spends are already enumerated in the script path, so the internal public key is not only redundant, but a security hazard since it must be specified. Values that will make Taproot validation fail cannot be used. BIP341 advises that in such cases, an internal public key with unknown discrete logarithm should be used.</ref>, where ''G'' is the secp256k1 generator point.
# Set ''script_tree'' to the empty list.
# For each script (''i'' in the range ''[0,m-1]'', convert it into a tuple with first element a byte 0xc0 and second element the script itself, and append it to ''script_tree''.
# Return the result of ''taproot_output_script(internal_pubkey, script_tree)''.


=== Spending K-of-N Multisig outputs ===

Only one of the multisignature TapScripts will be spent in a K-of-N Taproot Multisig.

The algorithm takes as inputs:
* An integer value  ''m'', greater than 0
* An array ''scripts'' of ''m'' TapScripts as byte-arrays, in the format taken by the Multisig Construction algorithm
* An integer value ''j'', greater than 0 and less than ''m'', that indicates which multisignature TapScript will be used to spend the output.
* The witness stack ''inputs'' of the script ''scripts[i]'', as an array of byte-arrays.
** The witness stack must be written in the following format: "[Signature s<sub>K</sub>] [Signature s<sub>K-1</sub>] ... [Signature s<sub>0</sub>]"
Where the list s<sub>1</sub> ... s<sub>K</sub> are the Schnorr signatures corresponding to the public keys p<sub>1</sub> ... p<sub>K</sub>. Note that the list of signatures is coded in the reverse order, because the script interpreter will pop the left-most byte-array as the first stack element, the second-left-most byte array as the second stack element, and so on.

And returns as the outputs:
* The witness, that can spend the scriptPubKey returned by the Multisig Construction algorithm.

Algorithm steps:
# Generate a random private key ''p'', in the range ''[0, n-1]''.
# Set the internal key ''internal_pubkey'' to ''lift_x(0x0250929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0) + p*G''<ref>'''Why is an arbitrary public key used for signing and spending?''' All possible combinations of multisignature spends are already enumerated in the TapLeaves, so the internal public key is not only redundant, but a security hazard since it must be specified. Values that will make Taproot validation fail cannot be used. BIP341 advises that in such cases, an internal public key with unknown discrete logarithm should be used.</ref>.
# Set the internal key ''internal_pubkey'' to ''lift_x(0x0250929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0) + p*G'', where ''G'' is the secp256k1 generator point.
# Set ''script_tree'' to the empty list.
# For each script (''i'' in the range ''[0,m-1]'', convert it into a tuple with first element a byte 0xc0 and second element the script itself, and append it to ''script_tree''.
# Return the result of ''taproot_sign_script(internal_pubkey, script_tree, j, inputs)''.

== Notes ==

[[bip342.mediawiki|BIP342]] mentions that a complete TapBranch of ''k-of-k'' multisignature leaves are "only more cost effective for small values of ''k'' (1-of-''n'' for any ''n'', 2-of-''n'' for ''n &ge; 6'', 3-of-''n'' for ''n &ge; 9'', ...)". Since the scripts are all of fixed size, and the number of TapLeaves can similarly be calculated, it is possible to derive a formula for the relative size in (v)bytes of a spent Multisig Taproot output.
* The size of each script is ''33*K + 2''.
* The size of the control block is ''33 + 32 * ceil(log2(nCr(N,K)))'', where ''nCr'' computes the binomial coefficient of ''N'' and ''K''.
* Therefore, the size of the witness inside the output is ''32*ceil(log2(nCr(N,K))) + 33*K + 35''. A table of output sizes is provided for the first few values of N and K.

N,K,Size (vbytes)
1,1,68
2,1,100
2,2,101
3,1,132
3,2,165
3,3,134
4,1,132
4,2,197
4,3,198
4,4,167
5,1,164
5,2,229
5,3,262
5,4,263
5,5,200
6,1,164
6,2,229
6,3,294
6,4,295
6,5,296
6,6,233

The data shows that 1-of-N Multisig TapScripts have the smallest witness output, and K-of-N Multisig Tapscripts with ''K &gt; 1'' and progressively increasing to ''N-1'' have increasingly larger sizes. Where the K-of-N combination has a smaller size than the equivalent N-of-N combination, it is deemed to be cost-efficient. Hence, since 2 cosigners out of a maximum of 6 makes a transaction size smaller than 6-of-6, 2-of-6 multisig is the largest cost-effective combination for ''N = 6''. If the data is extended, it can similary be proven that 3-of-9 multisig is the largest cost-effective combination for ''N = 9''.<ref>'''Cost-effective delegations''' Several delegation schemes such as Lightning Network channels use only a combination of 1-of-N and N-of-N multisig transactions, with small N &gt; 1.</ref>

The following Python 3.8 code an be used to calculate transaction sizes for ''K &gt; 0'', ''N &gt; 0'', and ''N &ge; K'':

<source lang="python">
>>> import math
>>> txsize = lambda n,k : 32*math.ceil(math.log2(math.comb(n, k))) + 33*k + 35
>>> txsize(1,1)
68
# ...
</source>


== Rationale ==

<references />

== Acknowledgements ==

Thanks to garlonicon, vjudeu, and Ali Ashraf for providing feedback about multisignatures while this document was being written.

--------

I appreciate any comments about this, especially from the BIP editors.

- Ali


From micaroni at gmail.com  Sat Aug 20 14:16:53 2022
From: micaroni at gmail.com (micaroni at gmail.com)
Date: Sat, 20 Aug 2022 11:16:53 -0300
Subject: [bitcoin-dev] Huge wallets make Bitcoin Core unusable (Daemon+CLI &
	Qt)
Message-ID: <CAHvMVPSKbG6s236uUsLmn6+i4bjRV4rDBPd4nJy3qR0ih+aTFg@mail.gmail.com>

Hi dear devs,


1. THE ISSUE - DAEMON+CLI
========================
I had a wallet in a server production since 2017 (5 years old) and when it
reached about 273 MB, 2.079.337 transactions and 446.503 generated
addresses, the performance started to degrade exponentially.

Most of the commands, e.g. "getbalance", "walletpassphrase" and
"getreceivedbyaddress" started to timeout (more than 15 minutes delay -
default timeout). The CPU was 100% used (all 32 cores - with 150 load avg)
and the machine became almost unusable breaking everything else, with the
default config of 16 RPC threads and 15 min timeout and some attempt calls
per mi

Increasing the timeout and/or the RPC threads in the config file turns
things even worse.

Putting the wallet.dat in a very fast SSD disk and increasing the size of
the cache (I tried with 8GB) have improved but I'm not sure if it is enough.


2. TEST ON BITCOIN QT
====================
If you try to load the wallet in the "bitcoin-qt" everything gets stuck,
even the system (OS/UI) doesn't respond anymore. You click on a button and
receive the message "window doesn't respond, wait or terminate?" - if you
wait it releases after a while but it is slow and hard to use the wallet
anyway.


3. WHY IS THIS SO BAD?
=====================
This is bad because the standard client becomes almost useless for the
wallet feature:

3.1) the wallet Qt already is not so popular among end users. It doesn't
look modern, slow to first sync and hard to use. That's why people prefer
to use Electrum or Wasabi - I personally don't care but it's the sad truth;

3.2) it becomes useless now also for servers in production, forcing them to
use third party solutions for huge wallets. Even if you split in 10 wallets
it will just delay 10 times more each to degrade, postponing the problem
but not eliminating it. Not to mention the slow and daily degradation.


4. SHOULD WE GIVE UP THE WALLET FEATURE?
========================================
Then, Bitcoin Core becomes just a reference implementation and blocks
relayers, but as an application wallet itself turns into a really bad
choice. --- It leads me to the following question: if we won't invest time
on improving this, shouldn't we remove the wallet feature at all? Why keep
a wallet feature that is not useful for the end user nor the production
server? Is it useful for what then?


5. THE CURRENT "SOLUTION" IS BAD
===============================
Currently, the only "solution" for huge wallets is shameful: create a new
one and send the funds there from time to time. But when is the right time
exactly? The performance degrades suddenly or gets worse slowly for each
new address and/or tx?. And besides not being an elegant solution and "not
in the handbook", it also can break a lot of things like monitoring old
addresses and also can lead to privacy concerns unifying lots of inputs in
a big and expensive tx.


6. OTHER USER CASES?
====================
I think this could also become an issue if we have LN nodes that use the
Bitcoin Core wallet infrastructure behind to open / close many channels for
a long time.


7. FINAL THOUGHTS
=================
If moving the wallet from a HDD to a SSD improved a lot, maybe just caching
the entire wallet in memory could improve even more, but I'm afraid some
code optimization is also necessary.


8. SOME QUESTIONS
==================
8.1) Can we "optimize" a huge wallet without moving the funds to a new one?
Like a "fsck" or eqv?

8.2) Can we improve the cache usage somehow? Putting the entire wallet in
memory, for example?

8.3) Is it possible to reduce the wallet size (273 MB is too much for a HD
wallet)?

8.4) Can we tell the CLI to ignore old addresses? What if I need to watch
only the last 30 days?

8.5) How to improve the I/O treatment and/or CPU usage in the main thread
on Bitcoin-Qt to avoid window freezing on big and huge wallets?

8.6) In the last case (if it was not possible to optimize the wallet or the
CLI & Qt), can the CLI just warn the user like: "the wallet is becoming too
big and slow, execute the command 'archive'". And then, the command
"archive" could rename the current wallet to something like
"wallet.dat.archive_until_20220818", create a new "wallet.dat" and move the
funds automatically? Also, would it be nice to have an
"autoarchivehugewallets=1" in the file config?


9. POSSIBLE RELATED AND TESTS
=============================

[1] https://github.com/bitcoin/bitcoin/issues/15015
[2] https://github.com/bitcoin/bitcoin/issues/15148
[3] https://github.com/bitcoin/bitcoin/issues/16874
[4] https://github.com/bitcoin/bitcoin/pull/17135
[5] https://github.com/bitcoin/bitcoin/pull/18160
[6] https://github.com/bitpay/bitcore-node/issues/463
[7] https://github.com/RavenProject/Ravencoin/issues/499
[8] https://github.com/sugarchain-project/sugarchain/issues/106
[9]
https://bitcoin.stackexchange.com/questions/111844/loadwallet-takes-too-much-and-times-out
[10] https://bitcoin.stackexchange.com/a/45713/1761


ANOTHER POSSIBLE BUG
======================

Even if my node is 100% sync:
2022-08-20T13:11:43Z UpdateTip: new
best=00000000000000000005bba0593c2be0f1d322223501591d2b31b544e3af3d0b
height=750300 version=0x2fffe000 log2_work=93.687081 tx=758181489
date='2022-08-20T13:11:16Z' progress=1.000000 cache=4.6MiB(34964txo)

After a "loadwallet" command I am getting an old / wrong balance. The
wallet is already empty because I had moved the funds to a new one 3 or 4
days ago but it is still showing the old  balance. I didn't receive any
warning message saying the need for a rescan or something like that.

I am trying the "rescanblockchain" command but it is running and it taking
a looooooooooooooong time.




Best regards,

Felipe.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220820/07f9887b/attachment.html>

From rhavar at protonmail.com  Sat Aug 20 15:06:27 2022
From: rhavar at protonmail.com (rhavar at protonmail.com)
Date: Sat, 20 Aug 2022 15:06:27 +0000
Subject: [bitcoin-dev] Huge wallets make Bitcoin Core unusable
	(Daemon+CLI & Qt)
In-Reply-To: <CAHvMVPSKbG6s236uUsLmn6+i4bjRV4rDBPd4nJy3qR0ih+aTFg@mail.gmail.com>
References: <CAHvMVPSKbG6s236uUsLmn6+i4bjRV4rDBPd4nJy3qR0ih+aTFg@mail.gmail.com>
Message-ID: <gHZbqt5MrBG2QoKf8wpGp4vD-IdgffrznSLudfuCkdcbAX0KeduW_wfyo55SfHVXz-DY_2qroPSnVDoRZJOVgLjeXUsqJriMB62d4ALTP4c=@protonmail.com>

Of all wallets I've tried, by a huge margin, bitcoin core performs the best with large wallets. I know several massive casinos like bustabit (which has a lot more transactions than your wallet) have been using bitcoin core for large wallets, so it can work.

The reason I don't recommend normal people use core, is because of the initial-block-download and not defaulting to a pruned mode.

The thing that makes your wallet slow is the large amount of wallet transactions. So the secret to running a large bitcoin core wallet is to just call `RemovePrunedFunds` on old transactions. Its actually a little tricky though, because you need to make sure the transaction is "safe to remove". The first, most obvious, reason a transaction would not be safe to remove is if it has a wallet utxo that you have not spent or have recently spent. The second, less obvious reason is if transaction B spends from transaction A, and you remove transaction B your wallet will think transaction A is unspent (but it's not!). So you have to prune "Depth first".

-Ryan

------- Original Message -------
On Saturday, August 20th, 2022 at 7:16 AM, Felipe Micaroni Lalli via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi dear devs,
>
> 1. THE ISSUE - DAEMON+CLI
> ========================
> I had a wallet in a server production since 2017 (5 years old) and when it reached about 273 MB, 2.079.337 transactions and 446.503 generated addresses, the performance started to degrade exponentially.
>
> Most of the commands, e.g. "getbalance", "walletpassphrase" and "getreceivedbyaddress" started to timeout (more than 15 minutes delay - default timeout). The CPU was 100% used (all 32 cores - with 150 load avg) and the machine became almost unusable breaking everything else, with the default config of 16 RPC threads and 15 min timeout and some attempt calls per mi
>
> Increasing the timeout and/or the RPC threads in the config file turns things even worse.
>
> Putting the wallet.dat in a very fast SSD disk and increasing the size of the cache (I tried with 8GB) have improved but I'm not sure if it is enough.
>
> 2. TEST ON BITCOIN QT
> ====================
> If you try to load the wallet in the "bitcoin-qt" everything gets stuck, even the system (OS/UI) doesn't respond anymore. You click on a button and receive the message "window doesn't respond, wait or terminate?" - if you wait it releases after a while but it is slow and hard to use the wallet anyway.
>
> 3. WHY IS THIS SO BAD?
> =====================
> This is bad because the standard client becomes almost useless for the wallet feature:
>
> 3.1) the wallet Qt already is not so popular among end users. It doesn't look modern, slow to first sync and hard to use. That's why people prefer to use Electrum or Wasabi - I personally don't care but it's the sad truth;
>
> 3.2) it becomes useless now also for servers in production, forcing them to use third party solutions for huge wallets. Even if you split in 10 wallets it will just delay 10 times more each to degrade, postponing the problem but not eliminating it. Not to mention the slow and daily degradation.
>
> 4. SHOULD WE GIVE UP THE WALLET FEATURE?
> ========================================
> Then, Bitcoin Core becomes just a reference implementation and blocks relayers, but as an application wallet itself turns into a really bad choice. --- It leads me to the following question: if we won't invest time on improving this, shouldn't we remove the wallet feature at all? Why keep a wallet feature that is not useful for the end user nor the production server? Is it useful for what then?
>
> 5. THE CURRENT "SOLUTION" IS BAD
> ===============================
> Currently, the only "solution" for huge wallets is shameful: create a new one and send the funds there from time to time. But when is the right time exactly? The performance degrades suddenly or gets worse slowly for each new address and/or tx?. And besides not being an elegant solution and "not in the handbook", it also can break a lot of things like monitoring old addresses and also can lead to privacy concerns unifying lots of inputs in a big and expensive tx.
>
> 6. OTHER USER CASES?
> ====================
> I think this could also become an issue if we have LN nodes that use the Bitcoin Core wallet infrastructure behind to open / close many channels for a long time.
>
> 7. FINAL THOUGHTS
> =================
> If moving the wallet from a HDD to a SSD improved a lot, maybe just caching the entire wallet in memory could improve even more, but I'm afraid some code optimization is also necessary.
>
> 8. SOME QUESTIONS
> ==================
> 8.1) Can we "optimize" a huge wallet without moving the funds to a new one? Like a "fsck" or eqv?
>
> 8.2) Can we improve the cache usage somehow? Putting the entire wallet in memory, for example?
>
> 8.3) Is it possible to reduce the wallet size (273 MB is too much for a HD wallet)?
>
> 8.4) Can we tell the CLI to ignore old addresses? What if I need to watch only the last 30 days?
>
> 8.5) How to improve the I/O treatment and/or CPU usage in the main thread on Bitcoin-Qt to avoid window freezing on big and huge wallets?
>
> 8.6) In the last case (if it was not possible to optimize the wallet or the CLI & Qt), can the CLI just warn the user like: "the wallet is becoming too big and slow, execute the command 'archive'". And then, the command "archive" could rename the current wallet to something like "wallet.dat.archive_until_20220818", create a new "wallet.dat" and move the funds automatically? Also, would it be nice to have an "autoarchivehugewallets=1" in the file config?
>
> 9. POSSIBLE RELATED AND TESTS
> =============================
>
> [1] https://github.com/bitcoin/bitcoin/issues/15015
> [2] https://github.com/bitcoin/bitcoin/issues/15148
> [3] https://github.com/bitcoin/bitcoin/issues/16874
> [4] https://github.com/bitcoin/bitcoin/pull/17135
> [5] https://github.com/bitcoin/bitcoin/pull/18160
> [6] https://github.com/bitpay/bitcore-node/issues/463
> [7] https://github.com/RavenProject/Ravencoin/issues/499
> [8] https://github.com/sugarchain-project/sugarchain/issues/106
> [9] https://bitcoin.stackexchange.com/questions/111844/loadwallet-takes-too-much-and-times-out
> [10] https://bitcoin.stackexchange.com/a/45713/1761
>
> ANOTHER POSSIBLE BUG
> ======================
>
> Even if my node is 100% sync:
> 2022-08-20T13:11:43Z UpdateTip: new best=00000000000000000005bba0593c2be0f1d322223501591d2b31b544e3af3d0b height=750300 version=0x2fffe000 log2_work=93.687081 tx=758181489 date='2022-08-20T13:11:16Z' progress=1.000000 cache=4.6MiB(34964txo)
>
> After a "loadwallet" command I am getting an old / wrong balance. The wallet is already empty because I had moved the funds to a new one 3 or 4 days ago but it is still showing the old balance. I didn't receive any warning message saying the need for a rescan or something like that.
>
> I am trying the "rescanblockchain" command but it is running and it taking a looooooooooooooong time.
>
> Best regards,
>
> Felipe.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220820/e45141bc/attachment-0001.html>

From lists at achow101.com  Sat Aug 20 15:10:57 2022
From: lists at achow101.com (Andrew Chow)
Date: Sat, 20 Aug 2022 15:10:57 +0000
Subject: [bitcoin-dev] Huge wallets make Bitcoin Core unusable
	(Daemon+CLI & Qt)
Message-ID: <89f3e708-8096-e0eb-458c-0d0b4d844934@achow101.com>

This is a known issue that I've been working on. The wallet is a large module in Bitcoin Core and changing it takes quite a bit of time.

On 08/20/2022 10:16 AM, Felipe Micaroni Lalli via bitcoin-dev wrote:

> 8.1) Can we "optimize" a huge wallet without moving the funds to a new one? Like a "fsck" or eqv?

You can remove old transactions using the removeprunedfunds RPC. That should greatly speed up balance calculations and transaction creation.

> 8.2) Can we improve the cache usage somehow? Putting the entire wallet in memory, for example?

It's already entirely in memory.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220820/3b217e52/attachment.html>

From billy.tetrud at gmail.com  Sat Aug 20 15:30:26 2022
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Sat, 20 Aug 2022 10:30:26 -0500
Subject: [bitcoin-dev] Surprisingly, Tail Emission Is Not Inflationary
In-Reply-To: <xcXwPxo9HRhMxQw9KIiDEfb6f4p6rY-24v3JUVHH2fkS7IcTK1Qe_7Hw4nJbGwdf6Guh0kS_nlPF-kzCVeS2MAioQmdjzpkGJibzyMj2JY0=@protonmail.com>
References: <abd33vsLrsQ7z5vJjz9h1V-3iEHJW1os1HyiO6QO5PNA8kahcPZ_2BUNuU7i4gyFRT2peLu0NXNrWv5X3RGGR6cvqijishTcb1qvo3YPeSU=@pointbiz.com>
 <xcXwPxo9HRhMxQw9KIiDEfb6f4p6rY-24v3JUVHH2fkS7IcTK1Qe_7Hw4nJbGwdf6Guh0kS_nlPF-kzCVeS2MAioQmdjzpkGJibzyMj2JY0=@protonmail.com>
Message-ID: <CAGpPWDZ2HDiDvGviPf+AW5yJbkFore0w0-CiRtHC3WU0QuWv9w@mail.gmail.com>

@vjudeu
> Miners can game this system by moving their own coins in 100% fees
transactions, just to produce more coins. You have one million BTC? No
problem, just move them as fees, and you just created 100k BTC out of thin
air, just because you are a wealthy miner.

Hmm, I believe you're right about that. If a miner can make 1 BTC of fees
by honestly mining + 0.1 BTC of inflation, they could instead make 2 BTC by
mining their own transactions with 20 BTC of fees. That does sound very
gameable. I rescind my suggestion.

One could imagine modifications to that suggestion that attempts to make it
more difficult to game directly. For example, if an average sum of
fees/block was calculated over a window (eg 2 weeks, 2 months, etc) and 10%
of that was released in coinbase rewards, you would eliminate the
possibility for individual miners to game the system. However, you would
then have to consider the group of miners as a whole - since they all have
an interest in increasing their revenues, it certainly seems like a
dangerous incentive that could lead to runaway inflation. So perhaps even
extensions of my suggestion are too gameable to be safe.

But my point still stands that tail emission is not a permanent solution.
One permanent solution would be some constant inflation *rate *(eg
0.1%/year). Given that the necessary security is a function of the total
value of the currency, perhaps that would be a reasonable natural way to
scale security as needed.

Again tho, I haven't seen any convincing evidence that any solution like
this will likely be necessary at all. Total collected fees will also scale
up as bitcoin grows, probably quadratically (since the value of the network
grows quadratically). I'm rather more inclined to think collected fees will
get far *too* high - ie substantially higher than needed to pay for
sufficient blockchain security.




On Fri, Aug 19, 2022 at 1:48 PM aliashraf.btc At protonmail via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi Peter, everyone
> This issue has been discussed thoroughly in bitcointalk, general
> discussions are more suited to forums, I believe, still ....
>
> First and foremost, it is more than obvious that bitcoin block subsidy
> algorithm is a total disaster, not just for the zero subsidy security
> consequences, but also for the overly rewarding scheme that favors (few)
> first-runners against (masses of) people who join later, a policy that
> looks to be a cheap marketing trick rather than a decent strategic
> monetary, system design, no matter how natural it is presumed nowadays,
> after being implemented by Bitcoin.
>
> For now, the brilliance of the idea behind Bitcoin and the enthusiasm have
> compensated for its bizzar, upside-down inflation policy, in practice as
> newcomers have been paying the price to lucky first-runners and adopting
> anyway.
> Is it happening for low block subsidy? Is it going to be solved somehow? I
> don't think so.
>
> With subsidy still being the major (like 90%) portion of the block reward,
> there is an equalizer factor pushing equilibrium by paying security costs
> on behalf of current coin owners.Note that every single new bitcoin paid as
> subsidy is actually paid by the rest of the wallets proportional to their
> balance.
> Other than its direct contribution to security, once understood as a
> ballance-based taxing scheme, it is a crucial mechanism for re-distribution
> of wealth because to compensate for their costs, unlike speculators (who
> are among the worst adopters of Bitcoin, and unfortunately the most
> influencers), miners are used to dumping their coins, providing more fair
> opportunities for people to join.
> So, halving and the hard cap, put both adoption and security as risk, It
> is why, unlike  "believers", I'm deeply concerned about a future with low
> block subsidy because it puts both security and adoption in an awkward
> situation.
>
> Additionally, It is not considered an engineering practice by any measure
> to speculate about the security of a system that we abundantly recommend to
> friends, family for joining.
> We need proofs, security proof, ease of adaptation proof, etc.,
> Fantasies are not proofs, having faith in a magical incentive mechanism
> that fixes everything is not an argument, let alone being a proof.
> Incentives are irrelevant, rules, schemes, projects, and so fort, matter.
> There are always incentives in games, but rules are in charge of
> determining the fate.
> Without rules, there is no game, flawed schemes and rules move the game
> behind its equilibrium to fail eventually.
>
> I've not to mention the unfeasibility of tempering Bitcoin's basic
> consensus rules, Bitcoin rules are not subject to change specially when it
> comes to something that is widely considered a basic characteristic, a
> Schelling point, and so forth.
>
> So, it is the paradoxical situation: we are exposed to, on one hand, it is
> a deficiency and on the other hand it is inevitable because is critically
> hard-code to Bitcoin, advertised more than any feature as its identity.
> But it is our job, isn't it? Dealing with the impossible and taking care
> of it, but I think before reaching to that point we have to settle the
> basics.:
>
>
>    1. There is a problem with long term security and adoption
>    consequences.
>    2. It is built deeply to bitcoin consensus rules, and considered a
>    critical
>    3. It is not going to disappear magically, neither it will be
>    addressed by whales, etc.
>    4. The 21M cap, halving, and generally, Bitcoin consensus, is not
>    subject to change.
>
>
> Don't panic, it is not exactly a catch-22 situation. Tip:
> It is always possible to help a system without aggressive intervention,
> either by smart tweaks or by supporting it using other system(s).
>
> Cheers, Ali Ashraf
>
>
>
> ------- Original Message -------
> On Tuesday, August 16th, 2022 at 8:35 PM, Peter via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Hi Jaroslaw,
>
>
>
> In the Prisoner's Dilemma the prisoners cannot communicate. In Bitcoin
> large holders are able to communicate with each other. Also, prisoners need
> not make an all or nothing decision in Bitcoin. Miners can join and leave
> the network freely over time. You can change your decision based on the
> decision of others.
>
>
> The Bitcoin design is such that security is volatile but the issuance of
> blocks is timely and evened out to a 10 minutes average even after the
> reward is exhausted.
>
>
> The existing incentive that miners earn money for including transactions
> is enough to motivate human nature. Transaction initiators have an
> incentive to mine and run full nodes for personal interest.
>
>
> >Noone will waste his renewable energy on unprofitable Antminer while
> he/she can sell this energy for the market price.
>
>
> The law in most jurisdictions prevents the resale of spare electricity
> unless an expensive license is obtained (and in most cases no license is
> available as the government maintains a monopoly). Mining with waste
> electricity is reducing losses. Another incentive to motivate human nature.
>
>
> Bitcoin holders can be enfranchised into any new system. So, no need for
> bike shedding the original design which is a Schelling Point.
>
>
> Regards
>
> Peter Kroll
>
> pointbiz/ BTCCuracao
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220820/84699ddb/attachment-0001.html>

From alicexbt at protonmail.com  Sat Aug 20 16:52:56 2022
From: alicexbt at protonmail.com (alicexbt)
Date: Sat, 20 Aug 2022 16:52:56 +0000
Subject: [bitcoin-dev] joinstr: coinjoin implementation using nostr
Message-ID: <GDi7LdVsoIcf4DyylHYn9L24lNn6cE47Vo7DWE4GNmkHi-OePqMkqrx5VYisPG28nv4ih4763vKSS_Yul1BvxjXQn4Sr4zF62kQpL_5nzYY=@protonmail.com>

Hi Max,

There a few DoS vectors that need to be fixed. Its just a proof of concept that I wanted to share with everyone to get feedback which could be improved over time. There is also a warning at the bottom of README to not use this on mainnet as it might have bugs.

I will continue the development with coinjoin transactions on signet for a few weeks until there is a stable release with no bugs. 

I have a few ideas in mind for various relay types that might be used concurrently to prevent numerous problems. Custom relays are supported by Nostr. Examples include paying a fee to register for a round, subscribing with a time limit, or using invite-only relays. I will run a free and open nostr relay for this project and try to fix the Dos issues before a mainnet version is released for python script(for nerds) and android app (for all users).

Related links: 

https://github.com/fiatjaf/relayer
https://github.com/fiatjaf/expensive-relay
https://github.com/fiatjaf/relayer/tree/master/whitelisted

/dev/fd0


Sent with Proton Mail secure email.

------- Original Message -------
On Saturday, August 20th, 2022 at 10:04 AM, Max Hillebrand <max at towardsliberty.com> wrote:


> Great to see an implementation of the idea.
> 
> Maybe I misunderstand, but isn't there a vulnerability of denial of service here?
> 
> A user who registers one input will receive the round secret identifier, and this is all the information required for output registration. However, that malicious user can now register multiple outputs, providing the same secret, and nobody can link the malicious outputs to any specific input. Therefor there cannot be a blame round where the malicious input is removed, and thus there can be a ongoing free denial of service attack without attribution or defense.
> 
> Skol
> Max
> 
> 
> On August 20, 2022 10:20:00 AM GMT+02:00, alicexbt via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> > Hi Bitcoin Developers,
> > 
> > I have written a python script as proof of concept for the [coinjoin implementation][1] using [nostr][2]. I used a lot of Python scripts created by others in school, so it feels nice to offer something that could be useful to others.
> > 
> > The implementation uses Bitcoin Core wallet and RPCs: `listunspent`, `getnewaddress`, `scantxoutset`, `createpsbt`, `combinepsbt`, `finalizepsbt` and `sendrawtransaction`. It requires python-nostr library because nostr is used for coordination between peers. Nostr is a decentralized network based on cryptographic keypairs. It is not peer-to-peer however simple and scalable.
> > 
> > Every step is published as an event using a nostr relay and 5 peers coordinate to create, sign and broadcast a coinjoin transaction.  I need to write a NIP that would be an alternative to blind signatures. Relay will share a random secret with clients for one round which should be present in output registration request although never gets published. If someone tries to register an output without registering any inputs, request would not have the number initially shared with inputs so request would get rejected or published as unverified. Relay would not be able to link inputs and outputs as the number is same for all inputs in a round and they get registered at different times with new keys and IP address. Clients can use multiple relays at the same time to avoid trusting one relay. This would result in different shared secret number but same process. If a relay tries to cheat, users will not sign the transaction and avoid using it in future.
> > 
> > Usage:
> > 
> >  1)Run `python coinjoin.py` and enter descriptor for one of the inputs.
> >  2)Script will check inputs for this round in every 30 seconds and register a new adddress for output once 5 inputs are registered.
> >  3)Similar check happens every 30 seconds for outputs. Last peer should create a PSBT.
> >  4)Unsigned PSBT will be printed and signed by wallet with `walletprocesspsbt` RPC.
> >  5)Script will check signed PSBTs and last peer to sign should finalize coinjoin transaction once 5 signed PSBTs are received.
> >  6)Coinjoin transaction will be broadcasted and txid will printed.
> > 
> > Example:
> > 
> > ```
> > List of utxos in wallet:
> > 
> > wpkh([53830dca/84'/1'/0'/0/0]02449be5fb74725255eeeb50eba930fa87705f21e99d13cd710cf2c1f21153c808)#x2hyyeg5
> > 
> > Enter descriptor for the input registration: wpkh([53830dca/84'/1'/0'/0/0]02449be5fb74725255eeeb50eba930fa87705f21e99d13cd710cf2c1f21153c808)#x2hyyeg5
> > 
> > event id:  bcbbe62d75d99fed73f1e50ac58a38d1840b658951893e63c0322b378d7d56f0
> > 
> > ```
> > ```
> > tb1qhxrp4zl54ul0twtyz0gury5399q7z0kvqqrl6m registered for output
> > 
> > event id: 9449c9065bef356d21507a98f88b028b17fc1c49eb195c8d4420604fcaaef041
> > ```
> > ```
> > Unsigned PSBT: cHNidP8BAP1yAQIAAAAFtMaoJYcXvOG5L3Yaz3YyS7gIt4h5/zzOrRRS3hrVvwoAAAAAAP////+o83geaSm4L76KToIUl5MiZqLAUbIDJLq6DWrjP/3b8AEAAAAA/////zEF3CXIvVHpIa7No1s1yg+KtyOfXTRSyWnOdXMfzcDwAQAAAAD/////wMa4XAgnU+39Ien+KG9rYtv8bLMNYakmZyY/QFfwLRcAAAAAAP/////5M42ID6uLmQTb2tnFHnN7UMpnDD25uN8ZX7A+GNSM3QEAAAAA/////wV4xwEAAAAAABYAFLmGGov0rz71uWQT0cGSkSlB4T7MeMcBAAAAAAAWABSc0/FM6Hdbdxh10IJkYOklVFWqjnjHAQAAAAAAFgAUPSZKe/w6PT6qIF+WhL4wHaFymjd4xwEAAAAAABYAFMx0rxYlpPWB3NFry4Ctk2eVi/UNeMcBAAAAAAAWABSzc4xK0VTfvjK0MHXrAUFLYgYnOgAAAAAAAAAAAAAAAAAAAA==
> > 
> > event id: 976744b38fa9343fb79e1b5215512ead6ee08e5890d79a201fc5b872f6de4eba
> > ```
> > ```
> > Signed PSBT: cHNidP8BAP1yAQIAAAAFtMaoJYcXvOG5L3Yaz3YyS7gIt4h5/zzOrRRS3hrVvwoAAAAAAP////+o83geaSm4L76KToIUl5MiZqLAUbIDJLq6DWrjP/3b8AEAAAAA/////zEF3CXIvVHpIa7No1s1yg+KtyOfXTRSyWnOdXMfzcDwAQAAAAD/////wMa4XAgnU+39Ien+KG9rYtv8bLMNYakmZyY/QFfwLRcAAAAAAP/////5M42ID6uLmQTb2tnFHnN7UMpnDD25uN8ZX7A+GNSM3QEAAAAA/////wV4xwEAAAAAABYAFLmGGov0rz71uWQT0cGSkSlB4T7MeMcBAAAAAAAWABSc0/FM6Hdbdxh10IJkYOklVFWqjnjHAQAAAAAAFgAUPSZKe/w6PT6qIF+WhL4wHaFymjd4xwEAAAAAABYAFMx0rxYlpPWB3NFry4Ctk2eVi/UNeMcBAAAAAAAWABSzc4xK0VTfvjK0MHXrAUFLYgYnOgAAAAAAAQBxAgAAAAG+qpMXZCy6tBuUlgo8JD0GVXKp60FkhwDeg2sF1fkFkwMAAAAA/f///wLo9wEAAAAAABYAFFfLA5xarC/w/SxeMDQ5tuXrYJLUWwMAAAAAAAAWABRfPf//hwMjHB4OKj87cU19XOSh7yOWAQABAR/o9wEAAAAAABYAFFfLA5xarC/w/SxeMDQ5tuXrYJLUAQhrAkcwRAIgOIhLoC5348U8YkEr4GU1K4yWskIOEXgW4Wsk/W2cR7ICIEJXqtOuDJ5CkwrSuwJLWtzab4dslbN3KuL/pyooMnOCASECRJvl+3RyUlXu61DrqTD6h3BfIemdE81xDPLB8hFTyAgAAAAAACICA77Cnd6o3kr0yc+91eabpOn5igs/MUMbudNYSS6oyMWMGFODDcpUAACAAQAAgAAAAIAAAAAAFAAAAAAAAAAA
> > 
> > event id: 5846b6e6902f3c5a43496d7d9785ed62444aa74963f03c33d637d8b09ee7a139
> > ```
> > ```
> > Coinjoin tx: 75e490b10b15a6a0422f25ff66ad98ef70390c8fecaac02712705dce8cc3564b
> > 
> > event id: 9b5d4bf279b59e2b6e539e683fba83da72dce2b640360aa95db1b1400be93190
> > ```
> > 
> > There are lot of things that could be improved and a few suggestions are in the gist that described the [idea][3]. I would love read to any opinions about this experiment and will start working on creating an Android app for joinstr next week.
> > 
> > Credits:
> > 
> > - fiatjaf (Nostr)
> > - Andrew Chow (PSBT)
> > - Jeff Thibault (python-nostr)
> > - Existing coinjoin implmentations
> > 
> > [1]: https://github.com/1440000bytes/joinstr
> > [2]: https://github.com/nostr-protocol/nostr
> > [3]: https://gist.github.com/1440000bytes/1c305097b070c8374cc3b91f50314a45
> > 
> > /dev/fd0
> > 
> > Sent with Proton Mail secure email.
> > 
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From woltx at protonmail.com  Sun Aug 21 22:01:34 2022
From: woltx at protonmail.com (woltx)
Date: Sun, 21 Aug 2022 22:01:34 +0000
Subject: [bitcoin-dev] New Silent Payment version
In-Reply-To: <22205257d1c57f97303cda85c814ef64@willtech.com.au>
References: <p3J90rsvbXPQnI7AtPXq1dLllvkiKmzccP-hbGd_NL7XTYM8O6ckjT3ocsixjebylnFDNKPP9XT9w0YFzY0OiW2Gvw_69SybOSOhhgio1wY=@protonmail.com>
 <22205257d1c57f97303cda85c814ef64@willtech.com.au>
Message-ID: <NWDS_i-nquA-Oe3hvZZ2Tmbw9AYXMBjpGCVpTKWuiyvk9nh2ZpQ8QBlZ11LZo-kdKzk3E2gBfz7ee_K1rGK1I3R1-LVgUwxHWfIOjmOgCPA=@protonmail.com>

The current Silent Payment implementation uses the standard Taproot script (Segwit V1).

This does not in any way affect the consensus or auditability rules.




Sent with Proton Mail secure email.

------- Original Message -------
On Wednesday, August 17th, 2022 at 11:21 PM, <damian at willtech.com.au> wrote:


> Let's be clear, if Bitcoin allows secret payments that cannot be
> publicly audited then they have exceeded the original consensus that
> gave Bitcoin fungibility and I will be publicly disavowing Bitcoin and
> advocating for a full sell down. Why don't you resurrect Monero. -DA.
> 
> On 2022-08-17 10:08, woltx via bitcoin-dev wrote:
> 
> > PR #24897 (https://github.com/bitcoin/bitcoin/pull/24897) has been
> > updated with a new silent payment version, which eliminates some
> > manual steps from the previous version (such as the need to set the
> > `keypool` to avoid costly multi-key scan).
> > 
> > This is achieved by using a new descriptor type ("sp()") that has no
> > range and contains exactly one key.
> > 
> > Example: "sp(cQq73sG9....JD51uaRD)#9llg6xjm"
> > 
> > This descriptor introduces a new type of output: "silent-payment".
> > This output type returns a standard Taproot script (Segwit V1), but
> > with HRP changed from "bc" to "sp" on the mainnet (or "tsp" on
> > testnet and signet).
> > 
> > This output type will always generate the same address (unless another
> > "sp" descriptor is enabled on the same wallet).
> > 
> > $ ./src/bitcoin-cli -signet getnewaddress '' 'silent-payment'
> > tsp1pfmjyl7ecpmx8yf8cu6g3ez36jy7s9mzuh5pdnal3k0n588uzgmfs4s4fws
> > 
> > To create a silent transaction, simply use the silent payment address
> > as one of the outputs.
> > 
> > The "send" RPC will automatically identify and tweak it.
> > 
> > The transaction can contain multiple outputs, combining silent and
> > standard addresses.
> > 
> > I have written a step by step signet tutorial so reviewers can test
> > this new version easily.
> > 
> > https://gist.github.com/w0xlt/a7b498ac1ff14b8c292a22be789bd93f
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From ali at notatether.com  Mon Aug 22 07:56:12 2022
From: ali at notatether.com (Ali Sherief)
Date: Mon, 22 Aug 2022 07:56:12 +0000
Subject: [bitcoin-dev] A method for BIP322 signing delegation
Message-ID: <20220822075606.6d2lsemmg7h26xqg@artanis>

This message relates to an edge case which BIP322 only partially solves, and that is Proof of Payment.

When you make a transaction to any business, it keeps the transaction in its records and generates an invoice so anyone can verify the transaction took place.

When you do a P2P transaction, whether on the blockchain or with paper money, there is always the risk that the other party will be dishonest, act in their own interest to convince people that they did not receive the transaction. Nobody has been able to completely get rid of this.

But in cryptocurrencies, this type of dispute is rampant, because it's also a scam attempt, to extract more money from the buyer. Legacy signed message isn't even enough to prove the transction took place - they can just claim (falsely) the address in the transaction is not theirs.

It usually happens like this:

1. Alice wants to buy something from Bob and sends bitcoins.
2. Bob denies receiving payment.
3. Alice publishes the txid of the transaction.
4. Bob denies that the address in the transaction belongs to him.

BIP322 signed messages only go half-way there: They can prove that the UTXO(s) belong to the buyer, and any good block explorer will show you the UTXOs that are being spent. So it can be independently established that Alice sent money, but not *who* it was sent to. That is where BIP322 falls short - there is no mechanism that forces Bob to sign a BIP322 message from the UTXO(s) he has just received, before the transaction is complete.

---

What should be done about this situation?

I propose using P2WSH 2-of-2 multisig to solve this problem. The script challenge will consist of something like OP_SHA256 <sha256 hash> OP_EQUAL[1][2]

[1]I don't even know if there is a standalone SHA256 opcode.
[2]OP_CHECKMULTISIG and OP_CHECKSIG both take public keys from the stack in addition to signatures, but we have arbitrary byte arrays and their SHA256 hashes, not public keys and signatures. How can we make this work?

Now on the witness stack, is pushed the BIP322 signature. Both of the signatures are then published on the blockchain. The catch is that both of the signatures are requires to be supplied

We don't want the signatures to be hidden using Taproot script paths or anything because whole point of this scheme is to make it verifiable to the public.

But I think that this idea can seriously work out in practice:

- Alice starts a P2P payment with Bob (let's just call this whole scheme "P2P payments")
- Alice sends bitcoin to the 2-of-2 multisig address generated by the P2P payment.
- Alice signs a BIP322 message from a UTXO (or address, but preferably a UTXO) and provides one of the signatures.
- Bob is forced to sign another BIP322 message from his address if he wants his money, and provides another signature.
- One of them broadcasts the multisig transaction, and Bob gets his money.

Advantages:
- The signatures in the Multisig transaction are two BIP322 signatures, which prove who has control of which inputs.
-- Consequentially, it can be proven who paid who. It is like an invoice, but it cannot be doctored like company invoices and databases.

Disadvantages:
- If Bob chickens out at this point, the money in the P2P payment is lost forever.
-- So, it is in the buyer's best interest to cooperate, and also in the seller's interest, but not particularly the best one - Until Bob provides a service, he doesn't lose anything except for time.

What do you guys think about this scheme?

- Ali


From ali at notatether.com  Mon Aug 22 12:55:58 2022
From: ali at notatether.com (Ali Sherief)
Date: Mon, 22 Aug 2022 12:55:58 +0000
Subject: [bitcoin-dev] New Silent Payment version
In-Reply-To: <mailman.11.1661169603.9362.bitcoin-dev@lists.linuxfoundation.org>
References: <mailman.11.1661169603.9362.bitcoin-dev@lists.linuxfoundation.org>
Message-ID: <20220822125550.knnhyue4it7n7ccs@artanis>

Besides, all silent payments are mined at the end of the day, so they are still transactions that are included in publicly auditable blocks.

The only thing that changes from the user's point of view is that these addresses cannot be heirarchically derived with BIP44 (or any other path for that matter). Nobody else can find out the HD paths of an address anyway.

- Ali

On Sun, 21 Aug 2022 22:01:34 +0000, woltx at protonmail.com wrote:
> The current Silent Payment implementation uses the standard Taproot script (Segwit V1).
>
> This does not in any way affect the consensus or auditability rules.
>
>
>
>
> Sent with Proton Mail secure email.
>
> ------- Original Message -------
> On Wednesday, August 17th, 2022 at 11:21 PM, <damian at willtech.com.au> wrote:
>
>
> > Let's be clear, if Bitcoin allows secret payments that cannot be
> > publicly audited then they have exceeded the original consensus that
> > gave Bitcoin fungibility and I will be publicly disavowing Bitcoin and
> > advocating for a full sell down. Why don't you resurrect Monero. -DA.
> >
> > On 2022-08-17 10:08, woltx via bitcoin-dev wrote:
> >
> > > PR #24897 (https://github.com/bitcoin/bitcoin/pull/24897) has been
> > > updated with a new silent payment version, which eliminates some
> > > manual steps from the previous version (such as the need to set the
> > > `keypool` to avoid costly multi-key scan).
> > >
> > > This is achieved by using a new descriptor type ("sp()") that has no
> > > range and contains exactly one key.
> > >
> > > Example: "sp(cQq73sG9....JD51uaRD)#9llg6xjm"
> > >
> > > This descriptor introduces a new type of output: "silent-payment".
> > > This output type returns a standard Taproot script (Segwit V1), but
> > > with HRP changed from "bc" to "sp" on the mainnet (or "tsp" on
> > > testnet and signet).
> > >
> > > This output type will always generate the same address (unless another
> > > "sp" descriptor is enabled on the same wallet).
> > >
> > > $ ./src/bitcoin-cli -signet getnewaddress '' 'silent-payment'
> > > tsp1pfmjyl7ecpmx8yf8cu6g3ez36jy7s9mzuh5pdnal3k0n588uzgmfs4s4fws
> > >
> > > To create a silent transaction, simply use the silent payment address
> > > as one of the outputs.
> > >
> > > The "send" RPC will automatically identify and tweak it.
> > >
> > > The transaction can contain multiple outputs, combining silent and
> > > standard addresses.
> > >
> > > I have written a step by step signet tutorial so reviewers can test
> > > this new version easily.
> > >
> > > https://gist.github.com/w0xlt/a7b498ac1ff14b8c292a22be789bd93f


From antoine.riard at gmail.com  Wed Aug 24 01:56:14 2022
From: antoine.riard at gmail.com (Antoine Riard)
Date: Wed, 24 Aug 2022 02:56:14 +0100
Subject: [bitcoin-dev] Playing with full-rbf peers for fun and L2s
	security
In-Reply-To: <YrS7a0E7xLswLD92@petertodd.org>
References: <CALZpt+GOh-7weEypT9JrzcwthZJqHOfj7sf9FMuqi5_FZv0g7w@mail.gmail.com>
 <YrEHo+3XLDNgIOnz@petertodd.org>
 <CALZpt+EL=k_6iE5B950oz3EdLaQbRvgCNYZ8Lko4fcONcACvfw@mail.gmail.com>
 <YrS7a0E7xLswLD92@petertodd.org>
Message-ID: <CALZpt+Hppw+5cRtjkxvmf94h+AvfthnfeeZGyxVKLq7EM9UHhA@mail.gmail.com>

> I'd suggest doing that right now, without waiting for the patch to get
merged,
> as it improves the politics of getting the patch merged. Miners tend to
run
> customized bitcoind's anyway.

Philosophically, I think we're better off arguing code patches free from a
political framework and rather reasoning from scientific or engineering
principles. If a change is adopted it should be in the name of making the
whole system better, making the new situation a win-win game.

That said, and more pragmatically, now that the full-rbf patch is merged in
Core there is the pedagogical work of explaining the fee upsides of turning
on full-rbf setting to enough miners. AFAIK, we don't have public,
broadcast-all communication channels between developers and mining
operators to exchange on software upgrades (e.g Stratum V2). I think I'm
left with the process of reaching out to miner one by one.

Le jeu. 23 juin 2022 ? 20:13, Peter Todd <pete at petertodd.org> a ?crit :

> On Tue, Jun 21, 2022 at 07:45:48PM -0400, Antoine Riard wrote:
> > > BTW I changed one of my OTS calendars to issue fee-bumping txs without
> the
> > > opt-in RBF flag set as an experiment. I also made sure txs would
> > propagate to
> > > the above node. As of right now, it's up to 32 replacements (once per
> > block),
> > > without any of them mined; the calendars use the strategy of starting
> at
> > the
> > > minimum possible fee, and bumping the fee up every time a new block
> > arrives
> > > without the tx getting mined. So that's evidence we don't have much
> > full-rbf
> > > hash power at this moment.
> > >
> > > You can see the current status at:
> > https://alice.btc.calendar.opentimestamps.org/
> >
> > That's interesting. I'm not sure if we can conclude of the absence of
> > full-rbf hash power at this moment, as it could also be a lack of
> full-rbf
> > propagation path towards such potential hash power. I think the day we
> see
> > an opt-out replacement transaction mined, it would constitute a good hint
> > of full-rbf hash power (assuming the tx-relay topology stays relatively
> > stable across the transaction issuance...)
>
> Fees are relatively low right now, so there could be 1% or so of full-rbf
> hash
> power and I wouldn't notice with this particular technique as the initial
> tx
> gets mined within 10-20 blocks; a few years back similar experiments were
> finding a few percentage points of hashing power running full-rbf.
>
> > Anyway, if/when the `fullrbf` patch lands in Bitcoin Core, including
> > automatic outbound connections to few `NODE_REPLACE_BY_FEE` peers, I'm
> > thinking of reaching out to a few mining node operators to advocate them
> > with the new policy setting.
>
> I'd suggest doing that right now, without waiting for the patch to get
> merged,
> as it improves the politics of getting the patch merged. Miners tend to run
> customized bitcoind's anyway.
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220824/f3ca52eb/attachment.html>

From craigraw at gmail.com  Wed Aug 24 09:18:43 2022
From: craigraw at gmail.com (Craig Raw)
Date: Wed, 24 Aug 2022 11:18:43 +0200
Subject: [bitcoin-dev] BIP Proposal: Wallet Labels Export Format
Message-ID: <CAPR5oBNKQEPCAXcMoneGv2vLVmOLZGyxNEoZ4_=tyQT_mkAkmw@mail.gmail.com>

Hi all,

I would like to propose a BIP that specifies a format for the export and
import of labels from a wallet. While transferring access to funds across
wallet applications has been made simple through standards such as BIP39,
wallet labels remain siloed and difficult to extract despite their value,
particularly in a privacy context.

The proposed format is a simple two column CSV file, with the reference to
a transaction, address, input or output in the first column, and the label
in the second column. CSV was chosen for its wide accessibility, especially
to users without specific technical expertise. Similarly, the CSV file may
be compressed using the ZIP format, and optionally encrypted using AES.

The full text of the BIP can be found at
https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki
and also copied below.

Feedback is appreciated.

Thanks,
Craig Raw

---

<pre>
  BIP: wallet-labels
  Layer: Applications
  Title: Wallet Labels Export Format
  Author: Craig Raw <craig at sparrowwallet.com>
  Comments-Summary: No comments yet.
  Comments-URI:
https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels
  Status: Draft
  Type: Informational
  Created: 2022-08-23
  License: BSD-2-Clause
</pre>

==Abstract==

This document specifies a format for the export of labels that may be
attached to the transactions, addresses, input and outputs in a wallet.

==Copyright==

This BIP is licensed under the BSD 2-clause license.

==Motivation==

The export and import of funds across different Bitcoin wallet applications
is well defined through standards such as BIP39, BIP32, BIP44 etc.
These standards are well supported and allow users to move easily between
different wallets.
There is, however, no defined standard to transfer any labels the user may
have applied to the transactions, addresses, inputs or outputs in their
wallet.
The UTXO model that Bitcoin uses makes these labels particularly valuable
as they may indicate the source of funds, whether received externally or as
a result of change from a prior transaction.
In both cases, care must be taken when spending to avoid undesirable leaks
of private information.
Labels provide valuable guidance in this regard, and have even become
mandatory when spending in several Bitcoin wallets.
Allowing users to export their labels in a standardized way ensures that
they do not experience lock-in to a particular wallet application.
In addition, by using common formats, this BIP seeks to make manual or bulk
management of labels accessible to users without specific technical
expertise.

==Specification==

In order to make the import and export of labels as widely accessible as
possible, this BIP uses the comma separated values (CSV) format, which is
widely supported by consumer, business, and scientific applications.
Although the technical specification of CSV in RFC4180 is not always
followed, the application of the format in this BIP is simple enough that
compatibility should not present a problem.
Moreover, the simplicity and forgiving nature of CSV (over for example
JSON) lends itself well to bulk label editing using spreadsheet and text
editing tools.

A CSV export of labels from a wallet must be a UTF-8 encoded text file,
containing one record per line, with records containing two fields
delimited by a comma.
The fields may be quoted, but this is unnecessary, as the first comma in
the line will always be the delimiter.
The first line in the file is a header, and should be ignored on import.
Thereafter, each line represents a record that refers to a label applied in
the wallet.
The order in which these records appear is not defined.

The first field in the record contains a reference to the transaction,
address, input or output in the wallet.
This is specified as one of the following:
* Transaction ID (<tt>txid</tt>)
* Address
* Input (rendered as <tt>txid<index</tt>)
* Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)

The second field contains the label applied to the reference.
Exporting applications may omit records with no labels or labels of zero
length.
Files exported should use the <tt>.csv</tt> file extension.

In order to reduce file size while retaining wide accessibility, the CSV
file may be compressed using the ZIP file format, using the <tt>.zip</tt>
file extension.
This <tt>.zip</tt> file may optionally be encrypted using either AES-128 or
AES-256 encryption, which is supported by numerous applications including
Winzip and 7-zip.
In order to ensure that weak encryption does not proliferate, importers
following this standard must refuse to import <tt>.zip</tt> files encrypted
with the weaker Zip 2.0 standard.
The textual representation of the wallet's extended public key (as defined
by BIP32, with an <tt>xpub</tt> header) should be used as the password.

==Importing==

When importing, a naive algorithm may simply match against any reference,
but it is possible to disambiguate between transactions, addresses, inputs
and outputs.
For example in the following pseudocode:
<pre>
  if reference length < 64
    Set address label
  else if reference length == 64
    Set transaction label
  else if reference contains '<'
    Set input label
  else
    Set output label
</pre>

Importing applications may truncate labels if necessary.

==Test Vectors==

The following fragment represents a wallet label export:
<pre>
Reference,Label
c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?,Transaction
1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address
c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?<0,Input
c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?>0,Output
c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?:0,Output
(alternative)
</pre>

==Reference Implementation==

TBD
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220824/025a538b/attachment.html>

From clark at clarkmoody.com  Wed Aug 24 13:53:27 2022
From: clark at clarkmoody.com (Clark Moody)
Date: Wed, 24 Aug 2022 13:53:27 +0000
Subject: [bitcoin-dev] BIP Proposal: Wallet Labels Export Format
In-Reply-To: <CAPR5oBNKQEPCAXcMoneGv2vLVmOLZGyxNEoZ4_=tyQT_mkAkmw@mail.gmail.com>
References: <CAPR5oBNKQEPCAXcMoneGv2vLVmOLZGyxNEoZ4_=tyQT_mkAkmw@mail.gmail.com>
Message-ID: <VtNrPzpaNh8DFSFOR9fvaWaxoJBmNn7mEnTnsIx5AJD1YhU-VR9TmUELZvVaSS1K1TclB7jitPM3Gc5zTz0bIFOw1bjil49VPwNRxVy4G14=@clarkmoody.com>

Craig,

Thanks for the proposal.

How does this proposal compare with SLIP-0015, which provides encryption by default? Would it be worth exploring a merge of the two approaches?

https://github.com/satoshilabs/slips/blob/master/slip-0015.md

Clark

------- Original Message -------
On Wednesday, August 24th, 2022 at 4:18 AM, Craig Raw via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi all,
>
> I would like to propose a BIP that specifies a format for the export and import of labels from a wallet. While transferring access to funds across wallet applications has been made simple through standards such as BIP39, wallet labels remain siloed and difficult to extract despite their value, particularly in a privacy context.
>
> The proposed format is a simple two column CSV file, with the reference to a transaction, address, input or output in the first column, and the label in the second column. CSV was chosen for its wide accessibility, especially to users without specific technical expertise. Similarly, the CSV file may be compressed using the ZIP format, and optionally encrypted using AES.
>
> The full text of the BIP can be found at https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki and also copied below.
>
> Feedback is appreciated.
>
> Thanks,
> Craig Raw
>
> ---
>
> <pre>
> BIP: wallet-labels
> Layer: Applications
> Title: Wallet Labels Export Format
> Author: Craig Raw <craig at sparrowwallet.com>
> Comments-Summary: No comments yet.
> Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels
> Status: Draft
> Type: Informational
> Created: 2022-08-23
> License: BSD-2-Clause
> </pre>
>
> ==Abstract==
>
> This document specifies a format for the export of labels that may be attached to the transactions, addresses, input and outputs in a wallet.
>
> ==Copyright==
>
> This BIP is licensed under the BSD 2-clause license.
>
> ==Motivation==
>
> The export and import of funds across different Bitcoin wallet applications is well defined through standards such as BIP39, BIP32, BIP44 etc.
> These standards are well supported and allow users to move easily between different wallets.
> There is, however, no defined standard to transfer any labels the user may have applied to the transactions, addresses, inputs or outputs in their wallet.
> The UTXO model that Bitcoin uses makes these labels particularly valuable as they may indicate the source of funds, whether received externally or as a result of change from a prior transaction.
> In both cases, care must be taken when spending to avoid undesirable leaks of private information.
> Labels provide valuable guidance in this regard, and have even become mandatory when spending in several Bitcoin wallets.
> Allowing users to export their labels in a standardized way ensures that they do not experience lock-in to a particular wallet application.
> In addition, by using common formats, this BIP seeks to make manual or bulk management of labels accessible to users without specific technical expertise.
>
> ==Specification==
>
> In order to make the import and export of labels as widely accessible as possible, this BIP uses the comma separated values (CSV) format, which is widely supported by consumer, business, and scientific applications.
> Although the technical specification of CSV in RFC4180 is not always followed, the application of the format in this BIP is simple enough that compatibility should not present a problem.
> Moreover, the simplicity and forgiving nature of CSV (over for example JSON) lends itself well to bulk label editing using spreadsheet and text editing tools.
>
> A CSV export of labels from a wallet must be a UTF-8 encoded text file, containing one record per line, with records containing two fields delimited by a comma.
> The fields may be quoted, but this is unnecessary, as the first comma in the line will always be the delimiter.
> The first line in the file is a header, and should be ignored on import.
> Thereafter, each line represents a record that refers to a label applied in the wallet.
> The order in which these records appear is not defined.
>
> The first field in the record contains a reference to the transaction, address, input or output in the wallet.
> This is specified as one of the following:
> * Transaction ID (<tt>txid</tt>)
> * Address
> * Input (rendered as <tt>txid<index</tt>)
> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)
>
> The second field contains the label applied to the reference.
> Exporting applications may omit records with no labels or labels of zero length.
> Files exported should use the <tt>.csv</tt> file extension.
>
> In order to reduce file size while retaining wide accessibility, the CSV file may be compressed using the ZIP file format, using the <tt>.zip</tt> file extension.
> This <tt>.zip</tt> file may optionally be encrypted using either AES-128 or AES-256 encryption, which is supported by numerous applications including Winzip and 7-zip.
> In order to ensure that weak encryption does not proliferate, importers following this standard must refuse to import <tt>.zip</tt> files encrypted with the weaker Zip 2.0 standard.
> The textual representation of the wallet's extended public key (as defined by BIP32, with an <tt>xpub</tt> header) should be used as the password.
>
> ==Importing==
>
> When importing, a naive algorithm may simply match against any reference, but it is possible to disambiguate between transactions, addresses, inputs and outputs.
> For example in the following pseudocode:
> <pre>
> if reference length < 64
> Set address label
> else if reference length == 64
> Set transaction label
> else if reference contains '<'
> Set input label
> else
> Set output label
> </pre>
>
> Importing applications may truncate labels if necessary.
>
> ==Test Vectors==
>
> The following fragment represents a wallet label export:
> <pre>
> Reference,Label
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?,Transaction
> 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?<0,Input
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?>0,Output
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?:0,Output (alternative)
> </pre>
>
> ==Reference Implementation==
>
> TBD
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220824/2c3e56ea/attachment.html>

From freedom at reardencode.com  Wed Aug 24 15:57:41 2022
From: freedom at reardencode.com (Brandon Black)
Date: Wed, 24 Aug 2022 08:57:41 -0700
Subject: [bitcoin-dev] BIP Proposal: Wallet Labels Export Format
In-Reply-To: <CAPR5oBNKQEPCAXcMoneGv2vLVmOLZGyxNEoZ4_=tyQT_mkAkmw@mail.gmail.com>
References: <CAPR5oBNKQEPCAXcMoneGv2vLVmOLZGyxNEoZ4_=tyQT_mkAkmw@mail.gmail.com>
Message-ID: <YwZKdVhhA2iTpHsn@console>

On 2022-08-24 (Wed) at 11:18:43 +0200, Craig Raw via bitcoin-dev wrote:
> I would like to propose a BIP that specifies a format for the export and
> import of labels from a wallet. While transferring access to funds across
> wallet applications has been made simple through standards such as BIP39,
> wallet labels remain siloed and difficult to extract despite their value,
> particularly in a privacy context.

I like the idea of standardizing the transfer of this valuable
information.

> The proposed format is a simple two column CSV file, with the reference to
> a transaction, address, input or output in the first column, and the label
> in the second column. CSV was chosen for its wide accessibility, especially
> to users without specific technical expertise. Similarly, the CSV file may
> be compressed using the ZIP format, and optionally encrypted using AES.

It seems like the format would be more useful if it also included
descriptors so that a single file could be used to transfer a wallet. I
think such an addition would improve usability for advanced users who
might have many such CSVs to manage, and would then be able to more
easily select between them. Descriptor,Label pairs could also be useful
in the format for the transfer of a wallet with several sub accounts.

Thanks,

--Brandon

From rhavar at protonmail.com  Wed Aug 24 19:01:17 2022
From: rhavar at protonmail.com (rhavar at protonmail.com)
Date: Wed, 24 Aug 2022 19:01:17 +0000
Subject: [bitcoin-dev] BIP Proposal: Wallet Labels Export Format
In-Reply-To: <CAPR5oBNKQEPCAXcMoneGv2vLVmOLZGyxNEoZ4_=tyQT_mkAkmw@mail.gmail.com>
References: <CAPR5oBNKQEPCAXcMoneGv2vLVmOLZGyxNEoZ4_=tyQT_mkAkmw@mail.gmail.com>
Message-ID: <1UV4d_Y74sQ_C8l5s6_gwZOOaFcB0hWnWYWl8TJ_PFs9bQ-fb_w_CYZjZOom2JJ0CSC6-w-Xi999ocafkWa7Mkz0MzsCs2Vg91M5to2fafA=@protonmail.com>

I'd strongly suggest not using CSV. Especially for a standard. I've worked with it as an interchange format many a times, and it's always been a clusterfuck.

Right off the bat, you have stuff like "The fields may be quoted, but this is unnecessary as the first comma in the line will always be the delimiter" which invariably leads to some implementations doing it, some implementations not doing it, and others that are intolerant of the other way.

And you have also made the classic mistake of not strictly defining escape rules. So everyone will pick their own (e.g. some will \, escape commas, others will not cause it's quoted and escape quotes, and others will assume no escaping is required since its the last column in a csv).

Over time it morphs into its own mini-monster that introduces so much pain.

On a similar note, allowing alternatives (like: txid>index vs txid:index) provides no benefit, but creates additional work for implementations (who quite likely only test formats they produce) and future incompatibilities.

I know everyone loves to hate on it, but really (line-separated?) json is the way to go.

{ "tx": "c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?", "label": "wow, such label" }
{ "tx: "c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b", "txout": 4, "label": "omg this is so easy to parse" }
{ "tx: "c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b", "txin": 0, "label": "wow this is going to be extensible as well" }

-Ryan

------- Original Message -------
On Wednesday, August 24th, 2022 at 2:18 AM, Craig Raw via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi all,
>
> I would like to propose a BIP that specifies a format for the export and import of labels from a wallet. While transferring access to funds across wallet applications has been made simple through standards such as BIP39, wallet labels remain siloed and difficult to extract despite their value, particularly in a privacy context.
>
> The proposed format is a simple two column CSV file, with the reference to a transaction, address, input or output in the first column, and the label in the second column. CSV was chosen for its wide accessibility, especially to users without specific technical expertise. Similarly, the CSV file may be compressed using the ZIP format, and optionally encrypted using AES.
>
> The full text of the BIP can be found at https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki and also copied below.
>
> Feedback is appreciated.
>
> Thanks,
> Craig Raw
>
> ---
>
> <pre>
> BIP: wallet-labels
> Layer: Applications
> Title: Wallet Labels Export Format
> Author: Craig Raw <craig at sparrowwallet.com>
> Comments-Summary: No comments yet.
> Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels
> Status: Draft
> Type: Informational
> Created: 2022-08-23
> License: BSD-2-Clause
> </pre>
>
> ==Abstract==
>
> This document specifies a format for the export of labels that may be attached to the transactions, addresses, input and outputs in a wallet.
>
> ==Copyright==
>
> This BIP is licensed under the BSD 2-clause license.
>
> ==Motivation==
>
> The export and import of funds across different Bitcoin wallet applications is well defined through standards such as BIP39, BIP32, BIP44 etc.
> These standards are well supported and allow users to move easily between different wallets.
> There is, however, no defined standard to transfer any labels the user may have applied to the transactions, addresses, inputs or outputs in their wallet.
> The UTXO model that Bitcoin uses makes these labels particularly valuable as they may indicate the source of funds, whether received externally or as a result of change from a prior transaction.
> In both cases, care must be taken when spending to avoid undesirable leaks of private information.
> Labels provide valuable guidance in this regard, and have even become mandatory when spending in several Bitcoin wallets.
> Allowing users to export their labels in a standardized way ensures that they do not experience lock-in to a particular wallet application.
> In addition, by using common formats, this BIP seeks to make manual or bulk management of labels accessible to users without specific technical expertise.
>
> ==Specification==
>
> In order to make the import and export of labels as widely accessible as possible, this BIP uses the comma separated values (CSV) format, which is widely supported by consumer, business, and scientific applications.
> Although the technical specification of CSV in RFC4180 is not always followed, the application of the format in this BIP is simple enough that compatibility should not present a problem.
> Moreover, the simplicity and forgiving nature of CSV (over for example JSON) lends itself well to bulk label editing using spreadsheet and text editing tools.
>
> A CSV export of labels from a wallet must be a UTF-8 encoded text file, containing one record per line, with records containing two fields delimited by a comma.
> The fields may be quoted, but this is unnecessary, as the first comma in the line will always be the delimiter.
> The first line in the file is a header, and should be ignored on import.
> Thereafter, each line represents a record that refers to a label applied in the wallet.
> The order in which these records appear is not defined.
>
> The first field in the record contains a reference to the transaction, address, input or output in the wallet.
> This is specified as one of the following:
> * Transaction ID (<tt>txid</tt>)
> * Address
> * Input (rendered as <tt>txid<index</tt>)
> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)
>
> The second field contains the label applied to the reference.
> Exporting applications may omit records with no labels or labels of zero length.
> Files exported should use the <tt>.csv</tt> file extension.
>
> In order to reduce file size while retaining wide accessibility, the CSV file may be compressed using the ZIP file format, using the <tt>.zip</tt> file extension.
> This <tt>.zip</tt> file may optionally be encrypted using either AES-128 or AES-256 encryption, which is supported by numerous applications including Winzip and 7-zip.
> In order to ensure that weak encryption does not proliferate, importers following this standard must refuse to import <tt>.zip</tt> files encrypted with the weaker Zip 2.0 standard.
> The textual representation of the wallet's extended public key (as defined by BIP32, with an <tt>xpub</tt> header) should be used as the password.
>
> ==Importing==
>
> When importing, a naive algorithm may simply match against any reference, but it is possible to disambiguate between transactions, addresses, inputs and outputs.
> For example in the following pseudocode:
> <pre>
> if reference length < 64
> Set address label
> else if reference length == 64
> Set transaction label
> else if reference contains '<'
> Set input label
> else
> Set output label
> </pre>
>
> Importing applications may truncate labels if necessary.
>
> ==Test Vectors==
>
> The following fragment represents a wallet label export:
> <pre>
> Reference,Label
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?,Transaction
> 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?<0,Input
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?>0,Output
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?:0,Output (alternative)
> </pre>
>
> ==Reference Implementation==
>
> TBD
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220824/f1fcaed1/attachment-0001.html>

From ali at notatether.com  Wed Aug 24 19:10:04 2022
From: ali at notatether.com (Ali Sherief)
Date: Wed, 24 Aug 2022 19:10:04 +0000
Subject: [bitcoin-dev] BIP Proposal: Wallet Labels Export Format
In-Reply-To: <mailman.9.1661342403.3868.bitcoin-dev@lists.linuxfoundation.org>
References: <mailman.9.1661342403.3868.bitcoin-dev@lists.linuxfoundation.org>
Message-ID: <20220824190958.gklg3riadci3ttgm@artanis>

Hi Craig,

This a really good proposal. I studied your BIP and I have some feedback on some parts of it.

> The first line in the file is a header, and should be ignored on import.

>From past experience and lessons, most notably BIP39, it is important that a version byte is defined somewhere in case someone wants to extend it in the future, currently there is no version byte which someone can increment if somebody wants to extend it. In the unique case of CSV files, you should make the header line mandatory (I see you have already implied this, but you should make it explicit in the BIP), but instead of a line with columns in it, I suggest instead of Reference,Label, you make the format like this:

BIP-wallet-labels,<version>

Since there are two columns per record, this works out nicely. The first column can be the name of the BIP - BIPxxxx where the x's are numbers, and the second column can be an unsigned 32-bit integer (most significant 8 bits reserved for version, the remaining for flags, or perhaps the entirety for version - but I recommend leaving at least some bits for flags, even if they all end up being just "reserved").

You should make importing fail if the header line is not exactly as specified - or appropriate, should you decide a different format for the header.

> Files exported should use the <tt>.csv</tt> file extension.
Don't mandate the file extension (read below for why):

> In order to reduce file size while retaining wide accessibility, the CSV
> file may be compressed using the ZIP file format, using the <tt>.zip</tt>
> file extension.
I see three problems with this. The first is more important than the later two because it makes them moot points, but I'll mention them anyway so you get a background of the situation:
- The BIP is trying to specify in what file format the export format can be written in onto the filesystem. There is no way to enforce this on a BIP level (besides, Unix operating systems don't even consider the file extension, they use its mimetype). Also specifying this in the BIP will prevent modular "Layer 2" protocols and schemes from encoding the Export labels into another format - for example Base64 or with their own compression algorithm.

Now for the two "moot problems":
- ZIP does not have good performance or compression ratio, there are better algorithms out there like gzip (which also happens to be more ubiquitous; nearly all websites are serving HTML compressed with gzip compression).
- ZIP is an archiving format, that happens to have its own compression format. Archiving format parsers can have serious vulnerabilities in their implementation that can allow malware to swipe private keys and passwords, since the primary target for this BIP is wallets. For example, there was Zip Slip[1] in 2018, which allows for remote code execution. So the malware can even hide in memory until private keys or passwords are written to memory, then send them accros the network. Assuming it's targeting a specific wallet software it's not hard to carry out at all.

There's two solutions for all this:
1. The duck-tape solution: Use some compression algorithm like gzip instead of ZIP archive format.
2. The "throw it out and buy a new one" solution: Get rid of the optional compression specs altogether, because users are responsible for supplying the export labels in the first place, so all the compression stuff is redundant and should be left up to the user use if they desire to.

I prefer the second solution because it hits the nail at the problem directly instead of putting duck tape on it like the first one.

> This <tt>.zip</tt> file may optionally be encrypted using either AES-128 or
> AES-256 encryption, which is supported by numerous applications including
> Winzip and 7-zip.
> The textual representation of the wallet's extended public key (as defined
> by BIP32, with an <tt>xpub</tt> header) should be used as the password.
Not specific to AES, but I don't see the benefit of encrypting addresses and labels together. Can you please elaborate why this would be desireable?

Like I said though, it's better to leave it up to users to decide how to store their exports, since BIPs can't enforce that anyway (additionally, the password you propose is insecure - anybody with access to the wallet can unlock it, which is not desireable to some users who want their own security).

> * Transaction ID (<tt>txid</tt>)
> * Address
> * Input (rendered as <tt>txid<index</tt>)
> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)
Why the need for input and output formats? There is no difference between them on the wallet level, because they are always identified with a txid and output index. To distinguish between them and hence write them with the correct format would require a UTXO set and thus access to a full node, otherwise the CSV cannot be verified to be completely well-formed.

Another important point is that practically nobody labels inputs or outputs because most people do not know that those things even exist, and the rest don't bother to label them.

But the biggest downside to including them is related to the problem of information leaking which you make reference to here:
> In both cases, care must be taken when spending to avoid undesirable leaks
> of private information.
A CSV dump that has inputs/outputs and addresses mixed together can infer the owner of all those items. In fact, A CVS label dump is basically a personal information store so everything in it can be correlated as coming from the same wallet, so it's important that unnecessary types are kept out of the format. People are known to leave files lying around on their computer that they don't need anymore, so these files can find their way via telemetry to surveillence entities. While we can't specify what users can do with their exports, we can control the information leak by preventing certain types of items that we know most users will never use from being exported in the first place.

> The order in which these records appear is not defined.
Again, since the primary use case for this BIP is wallets, which likely use heirarchical derivation schemes like BIP44, there is a net benefit for the addresses to be exported in ascending order of their `address_type`. It means that wallets can import them in O(n) time as opposed to O(n^2) time spent serially checking in which index the address appears at. Of course, this implies that all addresses up to a certain index have to be exported into the CSV as well, but most wallets I know of like Core, Electrum already store addresses like that.

Also if you do this, you will need to group all the transaction records before the address records or vice versa - you can use lexigraphical sorting if you want (ie. Addresses before Transactions). The benefit of this separation of parts is that wallets can split the imported address records from the transaction records internally, and feed them to separate functions which set these labels internally.

If you decide on doing it this way, then you need a 3rd column to identify the item type, and also you should quote the label (see below). I strongly recommend using numbers for identification as opposed to character strings, so you don't have to worry about localization or character case issues. There is always one unique number, but there could be multiple strings that reference the same type. This will complicate importing functions.

If you insist on include Input and Output types then they can both be specified as <txid>:<index> if you do this change. They won't be used to determine the type anyway.

> The fields may be quoted, but this is unnecessary, as the first comma in
> the line will always be the delimiter.
Don't implement it like that, because that will break CSV parsers which expect a fixed amount of rows in each record (2 in the header, and some rows have >2 rows). It's better to mandate that they should always be double-quoted, since only wallets will generate label exports anyway. If you plan to use headers then the 3rd column can be blank for it (or you can split the version and flags from each other).

> ==Importing==
>
> When importing, a naive algorithm may simply match against any reference,
> but it is possible to disambiguate between transactions, addresses, inputs
> and outputs.
> For example in the following pseudocode:
> <pre>
>   if reference length < 64
>     Set address label
>   else if reference length == 64
>     Set transaction label
>   else if reference contains '<'
>     Set input label
>   else
>     Set output label
> </pre>
The importing code is too naive and in its current form will prevent the BIP from getting a number. It is perhaps the single most important part of a BIP. When implementing an importer, it should utilize a dedicate item type field that unambiguously identifies the item. So the naive importer is not good, you need use a 3rd column for that like I explained above, so that the importer becomes robust.

In summary (exclamation marks indicate severity - one means low, two means medium, and three means high):

1. Convert the header into a version line with optional flags, otherwise nobody can extend this format without compatibility issues (!)
2. Get rid of the specs related to file compression (!!!)
3. Add a 3rd column for item type (address, transaction etc.) preferably as numeric constants and grouping items of one type after items of another type, or if you insist on strings, then only recognize their Titlecase ASCII versions <spreadsheet software like Excel always tries to titlecase the words> (!!)
4. Require double quotes around the label (or single quotes if you prefer, as long as spreadsheet software doesn't choke on them) (!!)
5. Require sorting the records according to the order they are stored in the wallet implementation. (!)
6. Consider getting rid of Input and Output item types. (!)
7. And last and most importantly, please write a more robust importer algorithm in the example given by the BIP, because code in BIPs are frequently used as references for software. (!!!)

I hope you will consider these points in future revisions of your BIP.

- Ali

[1] https://github.com/snyk/zip-slip-vulnerability

On Wed, 24 Aug 2022 11:18:43 +0200, craigraw at gmail.com wrote:
> Hi all,
>
> I would like to propose a BIP that specifies a format for the export and
> import of labels from a wallet. While transferring access to funds across
> wallet applications has been made simple through standards such as BIP39,
> wallet labels remain siloed and difficult to extract despite their value,
> particularly in a privacy context.
>
> The proposed format is a simple two column CSV file, with the reference to
> a transaction, address, input or output in the first column, and the label
> in the second column. CSV was chosen for its wide accessibility, especially
> to users without specific technical expertise. Similarly, the CSV file may
> be compressed using the ZIP format, and optionally encrypted using AES.
>
> The full text of the BIP can be found at
> https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki
> and also copied below.
>
> Feedback is appreciated.
>
> Thanks,
> Craig Raw
>
> ---
>
> <pre>
>   BIP: wallet-labels
>   Layer: Applications
>   Title: Wallet Labels Export Format
>   Author: Craig Raw <craig at sparrowwallet.com>
>   Comments-Summary: No comments yet.
>   Comments-URI:
> https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels
>   Status: Draft
>   Type: Informational
>   Created: 2022-08-23
>   License: BSD-2-Clause
> </pre>
>
> ==Abstract==
>
> This document specifies a format for the export of labels that may be
> attached to the transactions, addresses, input and outputs in a wallet.
>
> ==Copyright==
>
> This BIP is licensed under the BSD 2-clause license.
>
> ==Motivation==
>
> The export and import of funds across different Bitcoin wallet applications
> is well defined through standards such as BIP39, BIP32, BIP44 etc.
> These standards are well supported and allow users to move easily between
> different wallets.
> There is, however, no defined standard to transfer any labels the user may
> have applied to the transactions, addresses, inputs or outputs in their
> wallet.
> The UTXO model that Bitcoin uses makes these labels particularly valuable
> as they may indicate the source of funds, whether received externally or as
> a result of change from a prior transaction.
> In both cases, care must be taken when spending to avoid undesirable leaks
> of private information.
> Labels provide valuable guidance in this regard, and have even become
> mandatory when spending in several Bitcoin wallets.
> Allowing users to export their labels in a standardized way ensures that
> they do not experience lock-in to a particular wallet application.
> In addition, by using common formats, this BIP seeks to make manual or bulk
> management of labels accessible to users without specific technical
> expertise.
>
> ==Specification==
>
> In order to make the import and export of labels as widely accessible as
> possible, this BIP uses the comma separated values (CSV) format, which is
> widely supported by consumer, business, and scientific applications.
> Although the technical specification of CSV in RFC4180 is not always
> followed, the application of the format in this BIP is simple enough that
> compatibility should not present a problem.
> Moreover, the simplicity and forgiving nature of CSV (over for example
> JSON) lends itself well to bulk label editing using spreadsheet and text
> editing tools.
>
> A CSV export of labels from a wallet must be a UTF-8 encoded text file,
> containing one record per line, with records containing two fields
> delimited by a comma.
> The fields may be quoted, but this is unnecessary, as the first comma in
> the line will always be the delimiter.
> The first line in the file is a header, and should be ignored on import.
> Thereafter, each line represents a record that refers to a label applied in
> the wallet.
> The order in which these records appear is not defined.
>
> The first field in the record contains a reference to the transaction,
> address, input or output in the wallet.
> This is specified as one of the following:
> * Transaction ID (<tt>txid</tt>)
> * Address
> * Input (rendered as <tt>txid<index</tt>)
> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)
>
> The second field contains the label applied to the reference.
> Exporting applications may omit records with no labels or labels of zero
> length.
> Files exported should use the <tt>.csv</tt> file extension.
>
> In order to reduce file size while retaining wide accessibility, the CSV
> file may be compressed using the ZIP file format, using the <tt>.zip</tt>
> file extension.
> This <tt>.zip</tt> file may optionally be encrypted using either AES-128 or
> AES-256 encryption, which is supported by numerous applications including
> Winzip and 7-zip.
> In order to ensure that weak encryption does not proliferate, importers
> following this standard must refuse to import <tt>.zip</tt> files encrypted
> with the weaker Zip 2.0 standard.
> The textual representation of the wallet's extended public key (as defined
> by BIP32, with an <tt>xpub</tt> header) should be used as the password.
>
> ==Importing==
>
> When importing, a naive algorithm may simply match against any reference,
> but it is possible to disambiguate between transactions, addresses, inputs
> and outputs.
> For example in the following pseudocode:
> <pre>
>   if reference length < 64
>     Set address label
>   else if reference length == 64
>     Set transaction label
>   else if reference contains '<'
>     Set input label
>   else
>     Set output label
> </pre>
>
> Importing applications may truncate labels if necessary.
>
> ==Test Vectors==
>
> The following fragment represents a wallet label export:
> <pre>
> Reference,Label
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?,Transaction
> 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?<0,Input
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?>0,Output
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?:0,Output
> (alternative)
> </pre>
>
> ==Reference Implementation==
>
> TBD


From stick at satoshilabs.com  Wed Aug 24 20:18:27 2022
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Wed, 24 Aug 2022 22:18:27 +0200
Subject: [bitcoin-dev] BIP Proposal: Wallet Labels Export Format
In-Reply-To: <1UV4d_Y74sQ_C8l5s6_gwZOOaFcB0hWnWYWl8TJ_PFs9bQ-fb_w_CYZjZOom2JJ0CSC6-w-Xi999ocafkWa7Mkz0MzsCs2Vg91M5to2fafA=@protonmail.com>
References: <CAPR5oBNKQEPCAXcMoneGv2vLVmOLZGyxNEoZ4_=tyQT_mkAkmw@mail.gmail.com>
 <1UV4d_Y74sQ_C8l5s6_gwZOOaFcB0hWnWYWl8TJ_PFs9bQ-fb_w_CYZjZOom2JJ0CSC6-w-Xi999ocafkWa7Mkz0MzsCs2Vg91M5to2fafA=@protonmail.com>
Message-ID: <CAF90AvknWwhtP01x2xJxeqkVd7zge4dv6DD0yR3+pSvTPWPJPQ@mail.gmail.com>

There is already a JSON standard that has been already used in the wild for
the last 7 years described in SLIP-0015 (mentioned by Clark in this
thread). No need to reinventing the wheel again.

On Wed 24. 8. 2022 at 21:44, Ryan Havar via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I'd strongly suggest not using CSV. Especially for a standard. I've worked
> with it as an interchange format many a times, and it's always been a
> clusterfuck.
>
> Right off the bat, you have stuff like "The fields may be quoted, but this
> is unnecessary as the first comma in the line will always be the delimiter"
> which invariably leads to some implementations doing it, some
> implementations not doing it, and others that are intolerant of the other
> way.
>
> And you have also made the classic mistake of not strictly defining escape
> rules. So everyone will pick their own (e.g. some will \, escape commas,
> others will not cause it's quoted and escape quotes, and others will assume
> no escaping is required since its the last column in a csv).
>
> Over time it morphs into its own mini-monster that introduces so much pain.
>
> On a similar note, allowing alternatives (like: txid>index vs txid:index)
> provides no benefit, but creates additional work for implementations (who
> quite likely only test formats they produce) and future incompatibilities.
>
> I know everyone loves to hate on it, but really (line-separated?) json is
> the way to go.
>
> { "tx": "c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?",
> "label": "wow, such label" }
> { "tx: "c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b",
> "txout": 4, "label": "omg this is so easy to parse" }
> { "tx: "c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b",
> "txin": 0, "label": "wow this is going to be extensible as well" }
>
>
>
>
> -Ryan
>
> ------- Original Message -------
>
> On Wednesday, August 24th, 2022 at 2:18 AM, Craig Raw via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Hi all,
>
> I would like to propose a BIP that specifies a format for the export and
> import of labels from a wallet. While transferring access to funds across
> wallet applications has been made simple through standards such as BIP39,
> wallet labels remain siloed and difficult to extract despite their value,
> particularly in a privacy context.
>
> The proposed format is a simple two column CSV file, with the reference to
> a transaction, address, input or output in the first column, and the label
> in the second column. CSV was chosen for its wide accessibility, especially
> to users without specific technical expertise. Similarly, the CSV file may
> be compressed using the ZIP format, and optionally encrypted using AES.
>
> The full text of the BIP can be found at
> https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki
> and also copied below.
>
> Feedback is appreciated.
>
> Thanks,
> Craig Raw
>
> ---
>
> <pre>
> BIP: wallet-labels
> Layer: Applications
> Title: Wallet Labels Export Format
> Author: Craig Raw <craig at sparrowwallet.com>
> Comments-Summary: No comments yet.
> Comments-URI:
> https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels
> Status: Draft
> Type: Informational
> Created: 2022-08-23
> License: BSD-2-Clause
> </pre>
>
> ==Abstract==
>
> This document specifies a format for the export of labels that may be
> attached to the transactions, addresses, input and outputs in a wallet.
>
> ==Copyright==
>
> This BIP is licensed under the BSD 2-clause license.
>
> ==Motivation==
>
> The export and import of funds across different Bitcoin wallet
> applications is well defined through standards such as BIP39, BIP32, BIP44
> etc.
> These standards are well supported and allow users to move easily between
> different wallets.
> There is, however, no defined standard to transfer any labels the user may
> have applied to the transactions, addresses, inputs or outputs in their
> wallet.
> The UTXO model that Bitcoin uses makes these labels particularly valuable
> as they may indicate the source of funds, whether received externally or as
> a result of change from a prior transaction.
> In both cases, care must be taken when spending to avoid undesirable leaks
> of private information.
> Labels provide valuable guidance in this regard, and have even become
> mandatory when spending in several Bitcoin wallets.
> Allowing users to export their labels in a standardized way ensures that
> they do not experience lock-in to a particular wallet application.
> In addition, by using common formats, this BIP seeks to make manual or
> bulk management of labels accessible to users without specific technical
> expertise.
>
> ==Specification==
>
> In order to make the import and export of labels as widely accessible as
> possible, this BIP uses the comma separated values (CSV) format, which is
> widely supported by consumer, business, and scientific applications.
> Although the technical specification of CSV in RFC4180 is not always
> followed, the application of the format in this BIP is simple enough that
> compatibility should not present a problem.
> Moreover, the simplicity and forgiving nature of CSV (over for example
> JSON) lends itself well to bulk label editing using spreadsheet and text
> editing tools.
>
> A CSV export of labels from a wallet must be a UTF-8 encoded text file,
> containing one record per line, with records containing two fields
> delimited by a comma.
> The fields may be quoted, but this is unnecessary, as the first comma in
> the line will always be the delimiter.
> The first line in the file is a header, and should be ignored on import.
> Thereafter, each line represents a record that refers to a label applied
> in the wallet.
> The order in which these records appear is not defined.
>
> The first field in the record contains a reference to the transaction,
> address, input or output in the wallet.
> This is specified as one of the following:
> * Transaction ID (<tt>txid</tt>)
> * Address
> * Input (rendered as <tt>txid<index</tt>)
> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)
>
> The second field contains the label applied to the reference.
> Exporting applications may omit records with no labels or labels of zero
> length.
> Files exported should use the <tt>.csv</tt> file extension.
>
> In order to reduce file size while retaining wide accessibility, the CSV
> file may be compressed using the ZIP file format, using the <tt>.zip</tt>
> file extension.
> This <tt>.zip</tt> file may optionally be encrypted using either AES-128
> or AES-256 encryption, which is supported by numerous applications
> including Winzip and 7-zip.
> In order to ensure that weak encryption does not proliferate, importers
> following this standard must refuse to import <tt>.zip</tt> files encrypted
> with the weaker Zip 2.0 standard.
> The textual representation of the wallet's extended public key (as defined
> by BIP32, with an <tt>xpub</tt> header) should be used as the password.
>
> ==Importing==
>
> When importing, a naive algorithm may simply match against any reference,
> but it is possible to disambiguate between transactions, addresses, inputs
> and outputs.
> For example in the following pseudocode:
> <pre>
> if reference length < 64
> Set address label
> else if reference length == 64
> Set transaction label
> else if reference contains '<'
> Set input label
> else
> Set output label
> </pre>
>
> Importing applications may truncate labels if necessary.
>
> ==Test Vectors==
>
> The following fragment represents a wallet label export:
> <pre>
> Reference,Label
>
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?,Transaction
> 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?<0,Input
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?>0,Output
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?:0,Output
> (alternative)
> </pre>
>
> ==Reference Implementation==
>
> TBD
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-- 
Best Regards / S pozdravom,

Pavol "stick" Rusnak
Co-Founder, SatoshiLabs
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220824/36ce85ba/attachment-0001.html>

From craigraw at gmail.com  Thu Aug 25 08:59:08 2022
From: craigraw at gmail.com (Craig Raw)
Date: Thu, 25 Aug 2022 10:59:08 +0200
Subject: [bitcoin-dev] BIP Proposal: Wallet Labels Export Format
In-Reply-To: <VtNrPzpaNh8DFSFOR9fvaWaxoJBmNn7mEnTnsIx5AJD1YhU-VR9TmUELZvVaSS1K1TclB7jitPM3Gc5zTz0bIFOw1bjil49VPwNRxVy4G14=@clarkmoody.com>
References: <CAPR5oBNKQEPCAXcMoneGv2vLVmOLZGyxNEoZ4_=tyQT_mkAkmw@mail.gmail.com>
 <VtNrPzpaNh8DFSFOR9fvaWaxoJBmNn7mEnTnsIx5AJD1YhU-VR9TmUELZvVaSS1K1TclB7jitPM3Gc5zTz0bIFOw1bjil49VPwNRxVy4G14=@clarkmoody.com>
Message-ID: <CAPR5oBMccmn9PB4gT=XiGcMvy-7KrbK_yBDngS1JJKiZhzRUzA@mail.gmail.com>

Thanks Clark - despite having worked in the Bitcoin wallet space for a
number of years I have not come across SLIP-0015. I did try to find prior
work on this - this one escaped me.

That said, having reviewed SLIP-0015, I think it has different design
goals. For example, it requires private key derivation from seed, which
means wallets functioning as coordinators cannot use the format without
access to the devices storing the private keys. It seems to me that wallet
labels are more privacy rather than security sensitive, and coordinators
should be able to import and export a wallet label format independently.

Secondly, it uses JSON as a data format, which I wanted to avoid for
reasons I'll describe in a separate reply in this thread. Finally (and this
is minor as it could easily be extended) SLIP-0015 does not currently
support transaction labels.

Craig

On Wed, Aug 24, 2022 at 3:53 PM Clark Moody <clark at clarkmoody.com> wrote:

> Craig,
>
> Thanks for the proposal.
>
> How does this proposal compare with SLIP-0015, which provides encryption
> by default? Would it be worth exploring a merge of the two approaches?
>
> https://github.com/satoshilabs/slips/blob/master/slip-0015.md
>
> Clark
>
> ------- Original Message -------
> On Wednesday, August 24th, 2022 at 4:18 AM, Craig Raw via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Hi all,
>
> I would like to propose a BIP that specifies a format for the export and
> import of labels from a wallet. While transferring access to funds across
> wallet applications has been made simple through standards such as BIP39,
> wallet labels remain siloed and difficult to extract despite their value,
> particularly in a privacy context.
>
> The proposed format is a simple two column CSV file, with the reference to
> a transaction, address, input or output in the first column, and the label
> in the second column. CSV was chosen for its wide accessibility, especially
> to users without specific technical expertise. Similarly, the CSV file may
> be compressed using the ZIP format, and optionally encrypted using AES.
>
> The full text of the BIP can be found at
> https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki
> and also copied below.
>
> Feedback is appreciated.
>
> Thanks,
> Craig Raw
>
> ---
>
> <pre>
> BIP: wallet-labels
> Layer: Applications
> Title: Wallet Labels Export Format
> Author: Craig Raw <craig at sparrowwallet.com>
> Comments-Summary: No comments yet.
> Comments-URI:
> https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels
> Status: Draft
> Type: Informational
> Created: 2022-08-23
> License: BSD-2-Clause
> </pre>
>
> ==Abstract==
>
> This document specifies a format for the export of labels that may be
> attached to the transactions, addresses, input and outputs in a wallet.
>
> ==Copyright==
>
> This BIP is licensed under the BSD 2-clause license.
>
> ==Motivation==
>
> The export and import of funds across different Bitcoin wallet
> applications is well defined through standards such as BIP39, BIP32, BIP44
> etc.
> These standards are well supported and allow users to move easily between
> different wallets.
> There is, however, no defined standard to transfer any labels the user may
> have applied to the transactions, addresses, inputs or outputs in their
> wallet.
> The UTXO model that Bitcoin uses makes these labels particularly valuable
> as they may indicate the source of funds, whether received externally or as
> a result of change from a prior transaction.
> In both cases, care must be taken when spending to avoid undesirable leaks
> of private information.
> Labels provide valuable guidance in this regard, and have even become
> mandatory when spending in several Bitcoin wallets.
> Allowing users to export their labels in a standardized way ensures that
> they do not experience lock-in to a particular wallet application.
> In addition, by using common formats, this BIP seeks to make manual or
> bulk management of labels accessible to users without specific technical
> expertise.
>
> ==Specification==
>
> In order to make the import and export of labels as widely accessible as
> possible, this BIP uses the comma separated values (CSV) format, which is
> widely supported by consumer, business, and scientific applications.
> Although the technical specification of CSV in RFC4180 is not always
> followed, the application of the format in this BIP is simple enough that
> compatibility should not present a problem.
> Moreover, the simplicity and forgiving nature of CSV (over for example
> JSON) lends itself well to bulk label editing using spreadsheet and text
> editing tools.
>
> A CSV export of labels from a wallet must be a UTF-8 encoded text file,
> containing one record per line, with records containing two fields
> delimited by a comma.
> The fields may be quoted, but this is unnecessary, as the first comma in
> the line will always be the delimiter.
> The first line in the file is a header, and should be ignored on import.
> Thereafter, each line represents a record that refers to a label applied
> in the wallet.
> The order in which these records appear is not defined.
>
> The first field in the record contains a reference to the transaction,
> address, input or output in the wallet.
> This is specified as one of the following:
> * Transaction ID (<tt>txid</tt>)
> * Address
> * Input (rendered as <tt>txid<index</tt>)
> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)
>
> The second field contains the label applied to the reference.
> Exporting applications may omit records with no labels or labels of zero
> length.
> Files exported should use the <tt>.csv</tt> file extension.
>
> In order to reduce file size while retaining wide accessibility, the CSV
> file may be compressed using the ZIP file format, using the <tt>.zip</tt>
> file extension.
> This <tt>.zip</tt> file may optionally be encrypted using either AES-128
> or AES-256 encryption, which is supported by numerous applications
> including Winzip and 7-zip.
> In order to ensure that weak encryption does not proliferate, importers
> following this standard must refuse to import <tt>.zip</tt> files encrypted
> with the weaker Zip 2.0 standard.
> The textual representation of the wallet's extended public key (as defined
> by BIP32, with an <tt>xpub</tt> header) should be used as the password.
>
> ==Importing==
>
> When importing, a naive algorithm may simply match against any reference,
> but it is possible to disambiguate between transactions, addresses, inputs
> and outputs.
> For example in the following pseudocode:
> <pre>
> if reference length < 64
> Set address label
> else if reference length == 64
> Set transaction label
> else if reference contains '<'
> Set input label
> else
> Set output label
> </pre>
>
> Importing applications may truncate labels if necessary.
>
> ==Test Vectors==
>
> The following fragment represents a wallet label export:
> <pre>
> Reference,Label
>
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?,Transaction
> 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?<0,Input
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?>0,Output
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?:0,Output
> (alternative)
> </pre>
>
> ==Reference Implementation==
>
> TBD
>
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220825/acdd8972/attachment-0001.html>

From craigraw at gmail.com  Thu Aug 25 08:59:13 2022
From: craigraw at gmail.com (Craig Raw)
Date: Thu, 25 Aug 2022 10:59:13 +0200
Subject: [bitcoin-dev] BIP Proposal: Wallet Labels Export Format
In-Reply-To: <1UV4d_Y74sQ_C8l5s6_gwZOOaFcB0hWnWYWl8TJ_PFs9bQ-fb_w_CYZjZOom2JJ0CSC6-w-Xi999ocafkWa7Mkz0MzsCs2Vg91M5to2fafA=@protonmail.com>
References: <CAPR5oBNKQEPCAXcMoneGv2vLVmOLZGyxNEoZ4_=tyQT_mkAkmw@mail.gmail.com>
 <1UV4d_Y74sQ_C8l5s6_gwZOOaFcB0hWnWYWl8TJ_PFs9bQ-fb_w_CYZjZOom2JJ0CSC6-w-Xi999ocafkWa7Mkz0MzsCs2Vg91M5to2fafA=@protonmail.com>
Message-ID: <CAPR5oBORj5pzuBvksCfpT8V_6D=s21TVQHyCET4+GdcxLuHPUw@mail.gmail.com>

Thanks for your thoughts Ryan.

Without reference to the quality feedback on this proposal, I was aware
when submitting it for review that it provides an excellent opportunity for
bike shedding. As developers, we have all experienced frustration with data
formats. One thing that I did not perhaps make clear enough is that this
format is not solely intended for developers, but general users who are
probably not well represented on this list.

While doing research for this proposal I spoke to several professional
users of Sparrow Wallet (who are not developers). They all expressed a
desire for the format to integrate with their business processes, which are
driven by business tools such as Excel. Labelling provides an important
function in UTXO and address management in these scenarios, and needs to be
accessible and manageable outside of wallet software.

If this is to be achieved, it immediately rules out JSON as a data format.
Not only is JSON limited to editing only through specific software or text
editors, but (in the latter case) it is fragile enough that a single
missing character can cause an entire file to fail parsing. CSV is more
forgiving in this regard. With respect to your comments on escaping, my
expectation would be that developers will be using a mature CSV library
rather than handling character escaping themselves. I would rather propose
a format that is generally usable, even if occasionally a label is escaped
incorrectly.

Finally, I'll note that CSV files are already common and uncontroversial in
Bitcoin wallet software. Bitcoin Core, Electrum, Sparrow (and no doubt many
others) already export addresses and/or transactions with their labels as
CSV files. This proposal simply attempts to create a standard for importing
and exporting all the labels in a wallet.

Craig

On Wed, Aug 24, 2022 at 9:01 PM <rhavar at protonmail.com> wrote:

> I'd strongly suggest not using CSV. Especially for a standard. I've worked
> with it as an interchange format many a times, and it's always been a
> clusterfuck.
>
> Right off the bat, you have stuff like "The fields may be quoted, but this
> is unnecessary as the first comma in the line will always be the delimiter"
> which invariably leads to some implementations doing it, some
> implementations not doing it, and others that are intolerant of the other
> way.
>
> And you have also made the classic mistake of not strictly defining escape
> rules. So everyone will pick their own (e.g. some will \, escape commas,
> others will not cause it's quoted and escape quotes, and others will assume
> no escaping is required since its the last column in a csv).
>
> Over time it morphs into its own mini-monster that introduces so much pain.
>
> On a similar note, allowing alternatives (like: txid>index vs txid:index)
> provides no benefit, but creates additional work for implementations (who
> quite likely only test formats they produce) and future incompatibilities.
>
> I know everyone loves to hate on it, but really (line-separated?) json is
> the way to go.
>
> { "tx": "c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?",
> "label": "wow, such label" }
> { "tx: "c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b",
> "txout": 4, "label": "omg this is so easy to parse" }
> { "tx: "c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b",
> "txin": 0, "label": "wow this is going to be extensible as well" }
>
>
>
>
> -Ryan
>
> ------- Original Message -------
> On Wednesday, August 24th, 2022 at 2:18 AM, Craig Raw via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Hi all,
>
> I would like to propose a BIP that specifies a format for the export and
> import of labels from a wallet. While transferring access to funds across
> wallet applications has been made simple through standards such as BIP39,
> wallet labels remain siloed and difficult to extract despite their value,
> particularly in a privacy context.
>
> The proposed format is a simple two column CSV file, with the reference to
> a transaction, address, input or output in the first column, and the label
> in the second column. CSV was chosen for its wide accessibility, especially
> to users without specific technical expertise. Similarly, the CSV file may
> be compressed using the ZIP format, and optionally encrypted using AES.
>
> The full text of the BIP can be found at
> https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki
> and also copied below.
>
> Feedback is appreciated.
>
> Thanks,
> Craig Raw
>
> ---
>
> <pre>
> BIP: wallet-labels
> Layer: Applications
> Title: Wallet Labels Export Format
> Author: Craig Raw <craig at sparrowwallet.com>
> Comments-Summary: No comments yet.
> Comments-URI:
> https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels
> Status: Draft
> Type: Informational
> Created: 2022-08-23
> License: BSD-2-Clause
> </pre>
>
> ==Abstract==
>
> This document specifies a format for the export of labels that may be
> attached to the transactions, addresses, input and outputs in a wallet.
>
> ==Copyright==
>
> This BIP is licensed under the BSD 2-clause license.
>
> ==Motivation==
>
> The export and import of funds across different Bitcoin wallet
> applications is well defined through standards such as BIP39, BIP32, BIP44
> etc.
> These standards are well supported and allow users to move easily between
> different wallets.
> There is, however, no defined standard to transfer any labels the user may
> have applied to the transactions, addresses, inputs or outputs in their
> wallet.
> The UTXO model that Bitcoin uses makes these labels particularly valuable
> as they may indicate the source of funds, whether received externally or as
> a result of change from a prior transaction.
> In both cases, care must be taken when spending to avoid undesirable leaks
> of private information.
> Labels provide valuable guidance in this regard, and have even become
> mandatory when spending in several Bitcoin wallets.
> Allowing users to export their labels in a standardized way ensures that
> they do not experience lock-in to a particular wallet application.
> In addition, by using common formats, this BIP seeks to make manual or
> bulk management of labels accessible to users without specific technical
> expertise.
>
> ==Specification==
>
> In order to make the import and export of labels as widely accessible as
> possible, this BIP uses the comma separated values (CSV) format, which is
> widely supported by consumer, business, and scientific applications.
> Although the technical specification of CSV in RFC4180 is not always
> followed, the application of the format in this BIP is simple enough that
> compatibility should not present a problem.
> Moreover, the simplicity and forgiving nature of CSV (over for example
> JSON) lends itself well to bulk label editing using spreadsheet and text
> editing tools.
>
> A CSV export of labels from a wallet must be a UTF-8 encoded text file,
> containing one record per line, with records containing two fields
> delimited by a comma.
> The fields may be quoted, but this is unnecessary, as the first comma in
> the line will always be the delimiter.
> The first line in the file is a header, and should be ignored on import.
> Thereafter, each line represents a record that refers to a label applied
> in the wallet.
> The order in which these records appear is not defined.
>
> The first field in the record contains a reference to the transaction,
> address, input or output in the wallet.
> This is specified as one of the following:
> * Transaction ID (<tt>txid</tt>)
> * Address
> * Input (rendered as <tt>txid<index</tt>)
> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)
>
> The second field contains the label applied to the reference.
> Exporting applications may omit records with no labels or labels of zero
> length.
> Files exported should use the <tt>.csv</tt> file extension.
>
> In order to reduce file size while retaining wide accessibility, the CSV
> file may be compressed using the ZIP file format, using the <tt>.zip</tt>
> file extension.
> This <tt>.zip</tt> file may optionally be encrypted using either AES-128
> or AES-256 encryption, which is supported by numerous applications
> including Winzip and 7-zip.
> In order to ensure that weak encryption does not proliferate, importers
> following this standard must refuse to import <tt>.zip</tt> files encrypted
> with the weaker Zip 2.0 standard.
> The textual representation of the wallet's extended public key (as defined
> by BIP32, with an <tt>xpub</tt> header) should be used as the password.
>
> ==Importing==
>
> When importing, a naive algorithm may simply match against any reference,
> but it is possible to disambiguate between transactions, addresses, inputs
> and outputs.
> For example in the following pseudocode:
> <pre>
> if reference length < 64
> Set address label
> else if reference length == 64
> Set transaction label
> else if reference contains '<'
> Set input label
> else
> Set output label
> </pre>
>
> Importing applications may truncate labels if necessary.
>
> ==Test Vectors==
>
> The following fragment represents a wallet label export:
> <pre>
> Reference,Label
>
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?,Transaction
> 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?<0,Input
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?>0,Output
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?:0,Output
> (alternative)
> </pre>
>
> ==Reference Implementation==
>
> TBD
>
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220825/0b1b7bed/attachment-0001.html>

From rhavar at protonmail.com  Thu Aug 25 13:48:36 2022
From: rhavar at protonmail.com (rhavar at protonmail.com)
Date: Thu, 25 Aug 2022 13:48:36 +0000
Subject: [bitcoin-dev] BIP Proposal: Wallet Labels Export Format
In-Reply-To: <CAPR5oBORj5pzuBvksCfpT8V_6D=s21TVQHyCET4+GdcxLuHPUw@mail.gmail.com>
References: <CAPR5oBNKQEPCAXcMoneGv2vLVmOLZGyxNEoZ4_=tyQT_mkAkmw@mail.gmail.com>
 <1UV4d_Y74sQ_C8l5s6_gwZOOaFcB0hWnWYWl8TJ_PFs9bQ-fb_w_CYZjZOom2JJ0CSC6-w-Xi999ocafkWa7Mkz0MzsCs2Vg91M5to2fafA=@protonmail.com>
 <CAPR5oBORj5pzuBvksCfpT8V_6D=s21TVQHyCET4+GdcxLuHPUw@mail.gmail.com>
Message-ID: <LMvWbzoPn_REUHn7yMxjbdhTeGzK9Oh6cYI87cisHe8OK3ya5SnUg_gd0CqjS0vLYM6cq0BU1ljFGBu1VjrkW0VAvbKIFYvmJtMG2BYK5Eo=@protonmail.com>

> Not only is JSON limited to editing only through specific software or text editors, but (in the latter case) it is fragile enough that a single missing character can cause an entire file to fail parsing. CSV is more forgiving in this regard.

I think quite simply: A forgiving format is not appropriate for a standard.

It'd be hard to understate how much extra and pointless effort it creates for everyone, and every implementation ends up creating its own defacto standard for what it produces and accepts. Even doing something as simple as adding an extra column will not be possible in the future because it'll break comparability with previous parsers.

I've literally worked on projects where the csv parser has evolved into scan-ahead to use heuristics to understand "rules" of a csv file, and then do line-by-line heuristics to override those rules in pathological cases. Makes a bit of sense when you're trying to achieve 30 years of backwards compatibility. Doesn't make sense for much else..

If your application users really like csv, then introduce an application-specific import-from-csv and export-to-csv with your own rules.
-Ryan

------- Original Message -------
On Thursday, August 25th, 2022 at 1:59 AM, Craig Raw <craigraw at gmail.com> wrote:

> Thanks for your thoughts Ryan.
>
> Without reference to the quality feedback on this proposal, I was aware when submitting it for review that it provides an excellent opportunity for bike shedding. As developers, we have all experienced frustration with data formats. One thing that I did not perhaps make clear enough is that this format is not solely intended for developers, but general users who are probably not well represented on this list.
>
> While doing research for this proposal I spoke to several professional users of Sparrow Wallet (who are not developers). They all expressed a desire for the format to integrate with their business processes, which are driven by business tools such as Excel. Labelling provides an important function in UTXO and address management in these scenarios, and needs to be accessible and manageable outside of wallet software.
>
> If this is to be achieved, it immediately rules out JSON as a data format. Not only is JSON limited to editing only through specific software or text editors, but (in the latter case) it is fragile enough that a single missing character can cause an entire file to fail parsing. CSV is more forgiving in this regard. With respect to your comments on escaping, my expectation would be that developers will be using a mature CSV library rather than handling character escaping themselves. I would rather propose a format that is generally usable, even if occasionally a label is escaped incorrectly.
>
> Finally, I'll note that CSV files are already common and uncontroversial in Bitcoin wallet software. Bitcoin Core, Electrum, Sparrow (and no doubt many others) already export addresses and/or transactions with their labels as CSV files. This proposal simply attempts to create a standard for importing and exporting all the labels in a wallet.
>
> Craig
>
> On Wed, Aug 24, 2022 at 9:01 PM <rhavar at protonmail.com> wrote:
>
>> I'd strongly suggest not using CSV. Especially for a standard. I've worked with it as an interchange format many a times, and it's always been a clusterfuck.
>>
>> Right off the bat, you have stuff like "The fields may be quoted, but this is unnecessary as the first comma in the line will always be the delimiter" which invariably leads to some implementations doing it, some implementations not doing it, and others that are intolerant of the other way.
>>
>> And you have also made the classic mistake of not strictly defining escape rules. So everyone will pick their own (e.g. some will \, escape commas, others will not cause it's quoted and escape quotes, and others will assume no escaping is required since its the last column in a csv).
>>
>> Over time it morphs into its own mini-monster that introduces so much pain.
>>
>> On a similar note, allowing alternatives (like: txid>index vs txid:index) provides no benefit, but creates additional work for implementations (who quite likely only test formats they produce) and future incompatibilities.
>>
>> I know everyone loves to hate on it, but really (line-separated?) json is the way to go.
>>
>> { "tx": "c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?", "label": "wow, such label" }
>> { "tx: "c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b", "txout": 4, "label": "omg this is so easy to parse" }
>> { "tx: "c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b", "txin": 0, "label": "wow this is going to be extensible as well" }
>>
>> -Ryan
>>
>> ------- Original Message -------
>> On Wednesday, August 24th, 2022 at 2:18 AM, Craig Raw via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> Hi all,
>>>
>>> I would like to propose a BIP that specifies a format for the export and import of labels from a wallet. While transferring access to funds across wallet applications has been made simple through standards such as BIP39, wallet labels remain siloed and difficult to extract despite their value, particularly in a privacy context.
>>>
>>> The proposed format is a simple two column CSV file, with the reference to a transaction, address, input or output in the first column, and the label in the second column. CSV was chosen for its wide accessibility, especially to users without specific technical expertise. Similarly, the CSV file may be compressed using the ZIP format, and optionally encrypted using AES.
>>>
>>> The full text of the BIP can be found at https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki and also copied below.
>>>
>>> Feedback is appreciated.
>>>
>>> Thanks,
>>> Craig Raw
>>>
>>> ---
>>>
>>> <pre>
>>> BIP: wallet-labels
>>> Layer: Applications
>>> Title: Wallet Labels Export Format
>>> Author: Craig Raw <craig at sparrowwallet.com>
>>> Comments-Summary: No comments yet.
>>> Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels
>>> Status: Draft
>>> Type: Informational
>>> Created: 2022-08-23
>>> License: BSD-2-Clause
>>> </pre>
>>>
>>> ==Abstract==
>>>
>>> This document specifies a format for the export of labels that may be attached to the transactions, addresses, input and outputs in a wallet.
>>>
>>> ==Copyright==
>>>
>>> This BIP is licensed under the BSD 2-clause license.
>>>
>>> ==Motivation==
>>>
>>> The export and import of funds across different Bitcoin wallet applications is well defined through standards such as BIP39, BIP32, BIP44 etc.
>>> These standards are well supported and allow users to move easily between different wallets.
>>> There is, however, no defined standard to transfer any labels the user may have applied to the transactions, addresses, inputs or outputs in their wallet.
>>> The UTXO model that Bitcoin uses makes these labels particularly valuable as they may indicate the source of funds, whether received externally or as a result of change from a prior transaction.
>>> In both cases, care must be taken when spending to avoid undesirable leaks of private information.
>>> Labels provide valuable guidance in this regard, and have even become mandatory when spending in several Bitcoin wallets.
>>> Allowing users to export their labels in a standardized way ensures that they do not experience lock-in to a particular wallet application.
>>> In addition, by using common formats, this BIP seeks to make manual or bulk management of labels accessible to users without specific technical expertise.
>>>
>>> ==Specification==
>>>
>>> In order to make the import and export of labels as widely accessible as possible, this BIP uses the comma separated values (CSV) format, which is widely supported by consumer, business, and scientific applications.
>>> Although the technical specification of CSV in RFC4180 is not always followed, the application of the format in this BIP is simple enough that compatibility should not present a problem.
>>> Moreover, the simplicity and forgiving nature of CSV (over for example JSON) lends itself well to bulk label editing using spreadsheet and text editing tools.
>>>
>>> A CSV export of labels from a wallet must be a UTF-8 encoded text file, containing one record per line, with records containing two fields delimited by a comma.
>>> The fields may be quoted, but this is unnecessary, as the first comma in the line will always be the delimiter.
>>> The first line in the file is a header, and should be ignored on import.
>>> Thereafter, each line represents a record that refers to a label applied in the wallet.
>>> The order in which these records appear is not defined.
>>>
>>> The first field in the record contains a reference to the transaction, address, input or output in the wallet.
>>> This is specified as one of the following:
>>> * Transaction ID (<tt>txid</tt>)
>>> * Address
>>> * Input (rendered as <tt>txid<index</tt>)
>>> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)
>>>
>>> The second field contains the label applied to the reference.
>>> Exporting applications may omit records with no labels or labels of zero length.
>>> Files exported should use the <tt>.csv</tt> file extension.
>>>
>>> In order to reduce file size while retaining wide accessibility, the CSV file may be compressed using the ZIP file format, using the <tt>.zip</tt> file extension.
>>> This <tt>.zip</tt> file may optionally be encrypted using either AES-128 or AES-256 encryption, which is supported by numerous applications including Winzip and 7-zip.
>>> In order to ensure that weak encryption does not proliferate, importers following this standard must refuse to import <tt>.zip</tt> files encrypted with the weaker Zip 2.0 standard.
>>> The textual representation of the wallet's extended public key (as defined by BIP32, with an <tt>xpub</tt> header) should be used as the password.
>>>
>>> ==Importing==
>>>
>>> When importing, a naive algorithm may simply match against any reference, but it is possible to disambiguate between transactions, addresses, inputs and outputs.
>>> For example in the following pseudocode:
>>> <pre>
>>> if reference length < 64
>>> Set address label
>>> else if reference length == 64
>>> Set transaction label
>>> else if reference contains '<'
>>> Set input label
>>> else
>>> Set output label
>>> </pre>
>>>
>>> Importing applications may truncate labels if necessary.
>>>
>>> ==Test Vectors==
>>>
>>> The following fragment represents a wallet label export:
>>> <pre>
>>> Reference,Label
>>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?,Transaction
>>> 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address
>>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?<0,Input
>>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?>0,Output
>>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?:0,Output (alternative)
>>> </pre>
>>>
>>> ==Reference Implementation==
>>>
>>> TBD
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220825/b57b0503/attachment-0001.html>

From veleslav.bips at protonmail.com  Thu Aug 25 19:24:16 2022
From: veleslav.bips at protonmail.com (=?utf-8?B?0JLQtdC70LXRgdC70LDQsg==?=)
Date: Thu, 25 Aug 2022 19:24:16 +0000
Subject: [bitcoin-dev] BIP Draft: Revocable Proof-of-Burn Transaction
	Template
Message-ID: <emmQNdTtCoPOwRQ7xjUN937V30qIsadPo2a0LW_QdAgKwFTSRWhYLHAfrDsa6ow2Yw08HPRH0cPDEq5zgHhVJEz6n0XVP_hDNcJzTEvtrv0=@protonmail.com>

Dear Bitcoin Development Mailing List,

I would like to present for initial comment a new draft BIP that we have been working on.

This BIP provides a new standard template for creating revocable proof-of-burn transactions that can be easily and cheaply verified by nodes running under SPV assumptions.

We would very much appreciate further peer-feedback and critical comment so that this proposal may be improved as it continues through the formal standardisation process.

Please find the full draft-proposal appended, you may also use the link provided to view the online rendered copy.

Yours sincerely,
Veleslav


PS. Upon being assigned a BIP-Number, I will write to the list with the updated URL.

https://github.com/veleslavs/bips/blob/bip-rpob-tx-template/bip-rpob-tx-template.mediawiki


<pre>
  BIP: bip-rpob-tx-template
  Layer: Applications
  Title: Revocable Proof-of-Burn Transaction Template
  Author: Veleslav <veleslav.bips at protonmail.com>
  Comments-Summary: No comments yet.
  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-bip-rpob-tx-template
  Status: Draft
  Type: Standards Track
  Created: 2022-08-18
  License: BSD-3-Clause
           CC0-1.0
</pre>

==Introduction==

===Abstract===
This BIP proposes an application-layer template for revocable proof-of-burn, or ''"RPoB"'', transactions.

* This proposal uses a new transaction version number to allow for future extensions.
* This proposal recommends that implementations who mine and relay transaction to update their standard transaction templates as defined by this document.

This proposal aims to support decentralised systems, allowing the use ''RPoB'' assertions in a consistent, efficient, reliable, and interoperable way.

''The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.''

===Copyright===
This document is dual licensed as BSD 3-clause and Creative Commons CC0 1.0 Universal.

===Motivation===
In signalling theory<ref group="Note">Evolutionary biology theory of communication, or ''"signalling theory"'', where creatures make honest signals that are hard to cheat, for mutual evolutionary advantage.</ref>, proof of burn<ref group="Note">In Bitcoin, ''proof of burn'' places bitcoin value into outputs that provably unspendable. This dose not reduce the wealthy of the network, but instead reduces the velocity of these coins to zero. Transferring the network wealth onto the remaining coins that have a non-zero velocity.</ref> is a costly signal,<ref group="Note">A ''"costly signal"'' indicates dedication, an observer expects that such a signal is not made flippantly because the high cost.</ref> allowing the network to assign a default trust.<ref group="Note">An entity is assigned a ''"default trust"'' value when they are not connected to the trust graph. Without a default source trust, growing a decentralised web-of-trust network is impossible. New users face a catch-22 problem: they are disconnected from the trust graph and don't have a possibility to prove themselves.</ref> Bitcoin naturally provides an implementation of proof of burn without feedback loops,<ref group="Note">A ''"feedback loop"'' is when a trust signal can be amplified by a privileged subset of the network by feeding the creation-cost of this signal back into the process of making the signal.</ref> allowing for default trust to be assigned fairly in decentralised networks.<ref group="Note">New users are able to use a proof-of-burn to bootstrap themselves into new trust networks. 'New-user-with-burn-proofs' can be welcomed-in with basic services and focused attention, as the network knows that it was costly to generate the burn-proof.</ref>

The ability to revoke<ref group="Note">To ''"revoke", is'' publicly asserting that a previous statement should not be valued as originally intended.</ref> past assertions is important for many applications,<ref group="Note">Unexpected things happen, for example, the loss or compromise of private keys.</ref> therefore proposal couples bitcoin proof-of-burn with a revocation mechanic.

In choosing to standardise via the BIP peer-reviewed process, we hope to give the community greater confidence in making use of bitcoin-based revocable proof of burn technology.

====Notes:====
<references group="Note" />

==Design==

===Conceptual===
''"Proof-of-Burn"'' transactions have long exited in Bitcoin, ''"OP_RETURN"'' transactions, (named after the op-code ''"return"'', that causes the public key script to return in failure, hence making the output unspendable and "burning" any value allocated to that output), these transactions have been actively mined since the release of Bitcoin-Core 0.9.

Since OP_RETURN doesn't allow the public key script to be spent (as is it's design), there hasn't been any built-in solution addressing the requirements a application-useable proof-of-burn transaction, in particular:

*A standard association with a public key in for transaction.
*A standard protocol to publicly revoke a proof-of-burn transaction.

In this proposal we satisfy these requirements by specifying a taproot public key in the op_return payload and an another output for revocation.

===Other Requirements===
Operation under <abbr title="Simple Payment Verification">SPV</abbr> assumptions:
*Transactions are small: ''RPoB transactions (non-witness-part) are fixed to two possible sizes, depending if there is a change output, or not.''
*Revocations are quickly and cheaply indexed: ''RPoB revocations only require obtaining the preimage to a double-sha256 hash. This is easily indexed and propagated in a gossip network.''

Ease of implementation:
*Use of only Taproot and Schnorr: ''To reduce the scope of the transaction, we use only Taproot for inputs and Outputs, and Schnorr for the signature that covers the funding outpoint.''

Transaction funded by 3rd party:
* It should be secure for an untrusted 3rd party fund the proof-of-burn transaction. ''Allowing for services to fund these transactions and be compensated with some sort of off-chain payment.''

Future extendability:
*Making use of the transaction version feature of bitcoin. ''This allows for easier indexing strategies in the future, (with a simple consensus change: to include in the coinbase the number of the transactions in the block by their transaction version).''
* Including a byte for 8 version flag bits. ''This allows for a reliable way to upgrade in the future in a forward-comparable way.''

===Transaction Design Overview:===
[[File:bip-rpob-tx-template/rpob-template-summary-table.svg]]

==Specification==
This section specifies our RPoB transaction template.

===Transaction===
General form:
<pre>
version:      0x3
marker:       0x0
flag:         0x1
txin_count:   0x1
txout_count:  0x2 (without change) or 0x3 (with change)
lock_time:    (any)
</pre>

*RPoB transactions MUST use the transaction version (nVersion) 0x03.

*RPoB transactions MUST have only one input and either two or three outputs.

===Input 1: Funding===
General form:
<pre>
signature_script:  (empty)
witness_script:    <taproot_witness>
</pre>

*The RPoB transaction input MUST be P2TR (Pay to Tap Root).

===Output 1: Burn and Data===
General form:

<pre>
value:              (any)
public_key_script:  RETURN < 1-byte-rpob_version_flag>
                           <32-byte-rpob_secp256k1_public_key>
                           <64-byte-rpob_schnorr_signature>
</pre>

The public key script fields are:

<pre>
rpob_version_flag:           1-byte , 0x00 (initial version).
rpob_secp256k1_public_key:  32-bytes, SECP256K1 compact public key.
rpob_schnorr_signature:     64-bytes, bip-340 Schnorr Signature.
</pre>

*The first RPoB transaction contains the burn value, that is made unspendable by the 'OP_RETURN' in the public key script.

===Output 2: Revocation Puzzle===
General form:

<pre>
value:              0
public_key_script:  SIZE 32 EQUALVERIFY HASH256
                    <32-byte-rpob_revocation_puzzle>
                    EQUAL
</pre>

*The Value of the Revocation Puzzle Output MUST be zero.

<code>HASH256</code> is defined by ''double sha256'':

<pre>
rpob_revocation_puzzle:    32-bytes, public, SHA256(SHA256(
                                     <32-byte-rpob_revocation_solution>
                                     ))

rpob_revocation_solution:  32-bytes, secret, publicly reveal this value to revoke the proof-of-burn.
</pre>

*It is RECOMMENDED that implementations use a value for the <code>rpob_revocation_solution</code> that is derived from the secret key used to generate the  <code>rpob_secp256k1_public_key</code> .

===Output 3, Optional: Change===
<pre>
value:              (any)
public_key_script:  1 <32-byte-taproot_witness_program>
</pre>

*This output MAY have any value.
*The public key MUST be a standard P2TW output.

===Signature: Included in Output 1===
<pre>
rpob_schnorr_signature:       64-bytes, bip-340, signature (
                                        <32-byte-rpob_signature_message_hash>,
                                        <32-byte-secp256k1_private_key>
                                        )

rpob_signature_message_hash:  32-bytes, bip-340, sha256_taged_hash (
                                        <77-byte-rpob_signature_message>,
                                        <16-byte-rpob_hash_tag>
                                        )

rpob_hash_tag:                16-bytes, utf-8-hash_tag ("rpob/BTC/MAINNET")
                                    or, utf-8-hash_tag ("rpob/BTC/TESTNET")

rpob_signature_message:       77-bytes, < 1-byte-version_flags>
                                        <32-byte-input_txid_hash>
                                        < 4-byte-input_index>
                                        < 8-byte-burn_output_value>
                                        <32-byte-rpob_revocation_puzzle>
</pre>

*The <code>rpob_schnorr_signature</code> uses the [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP-340] algorithm.

==Deployment==

While the ''IsStandard'' rules are quite restricting, it is quite possible to submit transactions directly to miners, or co-operate with miners who would enjoy to have some addition fee-revenue. So the initial process of testing on the main-network should be possible.

If this standard gains significant attention, we are happy to write a supplementary BIP to define a new service bit to allow nodes to signal that this new type of standard transaction is accepted.

==Rationale==
===Why require RPoB transactions to use a new transaction version?===

This allows for future indexing and enforcement strategies at the consensus layer.

===Why use a hash puzzle for the revocation?===

The hash-puzzle allows for easy indexing of the revocation, in the format:

<code><32-byte-revocation-puzzle> (if revoked: <32-byte-revocation-puzzle-preimage>)</code>

*Since the digest algorithm is double sha256, even for a very large number of revocation, this index would be very cheap to verify.

*We envision nodes keeping track of all the revocation-puzzles listed in the blockchain, as 32-byte each, a million RPoB is only 32mb. This can be further optimised.

Additionally, we do not want to confuse a public key, (that can sign), and a revocation-puzzle (that may only revoke).

===Why must the revocation output be of zero value?===

Revocation can be spent by anyone once the revocation pre-image has been published.

===Why does a RPoB need a signature at all?===

The primary purpose of the signature is to stop replay-attacks. (Somebody takes your public-key and makes transaction where you don't control the revocation).

The secondary purpose is to allow for untrusted parties to create transactions on your behalf. i.e. a 'RPoB' transaction creation service.
===Why waste precious block space?===

Consuming block-space is a of secondary proof-of-burn that this proposal takes advantage of, as itself is limited and contested for (blocks are almost full on average). There is an opportunity cost of the next best transaction when a miner chooses to include a RPoB transaction their block.

Additionally, transaction fees are important for the long-term health of the bitcoin-network, this proposal increases the demand for the blockchain.

===What do you want to make these RPoB transactions if there is insufficient block-space?===

This isn't our problem. Those who have the economic purpose and resources to make RPoB transactions will outcompete those who do not.

==Backwards Compatibility==

As this is an application layer structure without any preexisting deployment, we foresee no compatibility issues.

==Reference Implementation==

To be made.

==Acknowledgements==

While we have somewhat independently come up with the concept of RPoB, the idea of having a public record of public key enrolments has been around for a long time. None of the ideas in this BIP are new.

We would like to thank Jonas Schnelli, 'M', and 'P', for their past contributions.

==Appendixes==

===Appendix 1: Some alternatives to blockchain-based proof-of-burn:===
Blockchains provide the our first opportunity to have deterministic and decentralised trust networks. Before blockchains we had proof-of-work and proof-of-payments as the two main gate-keepers for boot-scraping new members into a exclusive group:

==== Proof-of-Work: ====
For example,

* In games it could be to grind your character up to a certain level.
* Or it could be to make and present hand-drawn artworks.
* Or it could be to solve a CAPTCHA.

With proof-of-work blockchains provides a way to quantises an abstract an amount of work into a value. Providing a solution "how much dose this work cost?" problem: your work can be traded for bitcoin, and the bitcoin value is set efficiently in the market.

==== Proof-of-Payment: ====
For example,

* Buying an expensive uniform item required for the clan.
* Paying membership dues.
* Proving a donation to a charity.

With proof-of-payment the problem is the feedback loops, who gets the payment is placed into a privileged position of responsibly. The blockchain solves this with proof-of-burn outputs, the 'payment' goes back to the network, distributed indirectly and proportionally the holders of bitcoin.

==== None: ====
For example,

* Pretty-Good-Privacy (PGP).

PGP provided the basic cryptographic infrastructure for secure communication, including a basic web-of-trust where users can cross-sign each others keys, to make man-in-the-middle attacks harder to carry out. The primary problem with PGP is that any infrastructure that uses it is open to denial-of-service attack, as making new pgp-key identities is extremely cheap.

The trust network also is open to sybil attack, as huge numbers of keys can all cross-trust each other making it appear that they belong to a large-genuine trust network.

==== Other: ====

* Blockchain Timestamping, i.e. Open-Timestamps.

One of the most simple ways of assiging value to something is to prove that it is old. Timestamping with a blockchain allows users to assert that they didn't just create this account just now. -  However the problem is that timestamps are cheap to make, and if the need for timestamps is predictable, then adversaries can pre-generate many to misuse and attack a network at a later date.

* Blockchain space Use.

Simply putting a statement into a blockchain itself, if there is any free-pressure is indirect form of burn by via the miner.  By out-competing the next-best-transaction set, this has burnt the value in the difference between the fees of the two set.

Thus, it can be shown that if the blocks are full, a RPoB transaction with zero-burn-amount is still a proof-of-bun transaction!

=== Appendix 2: Some notes on blockchain-based proof-of-burn and decentralised networks: ===
Using a blockchain the relative value of a proof-of-burn is deterministically calculable:

* Trust calculations transferring a proof-of-burn into a "default trust" value are possible. Leading to the creation of trust graphs that can operate reliably without human intervention.
* Networks using such default trust calculations become inherently resistant to distributed denial of service attacks.

All this cannot easily be achieved without leveraging the functionally of a blockchain such as Bitcoin.

==Footnotes==

<references />


From clark at clarkmoody.com  Thu Aug 25 22:54:14 2022
From: clark at clarkmoody.com (Clark Moody)
Date: Thu, 25 Aug 2022 22:54:14 +0000
Subject: [bitcoin-dev] BIP Proposal: Wallet Labels Export Format
In-Reply-To: <CAPR5oBORj5pzuBvksCfpT8V_6D=s21TVQHyCET4+GdcxLuHPUw@mail.gmail.com>
References: <CAPR5oBNKQEPCAXcMoneGv2vLVmOLZGyxNEoZ4_=tyQT_mkAkmw@mail.gmail.com>
 <1UV4d_Y74sQ_C8l5s6_gwZOOaFcB0hWnWYWl8TJ_PFs9bQ-fb_w_CYZjZOom2JJ0CSC6-w-Xi999ocafkWa7Mkz0MzsCs2Vg91M5to2fafA=@protonmail.com>
 <CAPR5oBORj5pzuBvksCfpT8V_6D=s21TVQHyCET4+GdcxLuHPUw@mail.gmail.com>
Message-ID: <9LXjLLr8ItwnB6bLt8Ozm21J0m11yiTghdXAAzpEzVKP3l5a9jtRRzJ90SFFbPwmyAV2yuzn5Y9r1wSiEWqbt7evbx9sSLF-EG1ZS__D0yM=@clarkmoody.com>

Having previously developed an export format[1] for general cryptocurrency transaction information, I can attest to the value of the human-readable CSV. I was careful to mention the RFC 4180 spec so that implementations could avoid the pitfalls of incorrect CSV encoding.

[1]: https://github.com/harmony-csv/harmony

Clark

------- Original Message -------
On Thursday, August 25th, 2022 at 3:59 AM, Craig Raw via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Thanks for your thoughts Ryan.
>
> Without reference to the quality feedback on this proposal, I was aware when submitting it for review that it provides an excellent opportunity for bike shedding. As developers, we have all experienced frustration with data formats. One thing that I did not perhaps make clear enough is that this format is not solely intended for developers, but general users who are probably not well represented on this list.
>
> While doing research for this proposal I spoke to several professional users of Sparrow Wallet (who are not developers). They all expressed a desire for the format to integrate with their business processes, which are driven by business tools such as Excel. Labelling provides an important function in UTXO and address management in these scenarios, and needs to be accessible and manageable outside of wallet software.
>
> If this is to be achieved, it immediately rules out JSON as a data format. Not only is JSON limited to editing only through specific software or text editors, but (in the latter case) it is fragile enough that a single missing character can cause an entire file to fail parsing. CSV is more forgiving in this regard. With respect to your comments on escaping, my expectation would be that developers will be using a mature CSV library rather than handling character escaping themselves. I would rather propose a format that is generally usable, even if occasionally a label is escaped incorrectly.
>
> Finally, I'll note that CSV files are already common and uncontroversial in Bitcoin wallet software. Bitcoin Core, Electrum, Sparrow (and no doubt many others) already export addresses and/or transactions with their labels as CSV files. This proposal simply attempts to create a standard for importing and exporting all the labels in a wallet.
>
> Craig
>
> On Wed, Aug 24, 2022 at 9:01 PM <rhavar at protonmail.com> wrote:
>
>> I'd strongly suggest not using CSV. Especially for a standard. I've worked with it as an interchange format many a times, and it's always been a clusterfuck.
>>
>> Right off the bat, you have stuff like "The fields may be quoted, but this is unnecessary as the first comma in the line will always be the delimiter" which invariably leads to some implementations doing it, some implementations not doing it, and others that are intolerant of the other way.
>>
>> And you have also made the classic mistake of not strictly defining escape rules. So everyone will pick their own (e.g. some will \, escape commas, others will not cause it's quoted and escape quotes, and others will assume no escaping is required since its the last column in a csv).
>>
>> Over time it morphs into its own mini-monster that introduces so much pain.
>>
>> On a similar note, allowing alternatives (like: txid>index vs txid:index) provides no benefit, but creates additional work for implementations (who quite likely only test formats they produce) and future incompatibilities.
>>
>> I know everyone loves to hate on it, but really (line-separated?) json is the way to go.
>>
>> { "tx": "c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?", "label": "wow, such label" }
>> { "tx: "c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b", "txout": 4, "label": "omg this is so easy to parse" }
>> { "tx: "c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b", "txin": 0, "label": "wow this is going to be extensible as well" }
>>
>> -Ryan
>>
>> ------- Original Message -------
>> On Wednesday, August 24th, 2022 at 2:18 AM, Craig Raw via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> Hi all,
>>>
>>> I would like to propose a BIP that specifies a format for the export and import of labels from a wallet. While transferring access to funds across wallet applications has been made simple through standards such as BIP39, wallet labels remain siloed and difficult to extract despite their value, particularly in a privacy context.
>>>
>>> The proposed format is a simple two column CSV file, with the reference to a transaction, address, input or output in the first column, and the label in the second column. CSV was chosen for its wide accessibility, especially to users without specific technical expertise. Similarly, the CSV file may be compressed using the ZIP format, and optionally encrypted using AES.
>>>
>>> The full text of the BIP can be found at https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki and also copied below.
>>>
>>> Feedback is appreciated.
>>>
>>> Thanks,
>>> Craig Raw
>>>
>>> ---
>>>
>>> <pre>
>>> BIP: wallet-labels
>>> Layer: Applications
>>> Title: Wallet Labels Export Format
>>> Author: Craig Raw <craig at sparrowwallet.com>
>>> Comments-Summary: No comments yet.
>>> Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels
>>> Status: Draft
>>> Type: Informational
>>> Created: 2022-08-23
>>> License: BSD-2-Clause
>>> </pre>
>>>
>>> ==Abstract==
>>>
>>> This document specifies a format for the export of labels that may be attached to the transactions, addresses, input and outputs in a wallet.
>>>
>>> ==Copyright==
>>>
>>> This BIP is licensed under the BSD 2-clause license.
>>>
>>> ==Motivation==
>>>
>>> The export and import of funds across different Bitcoin wallet applications is well defined through standards such as BIP39, BIP32, BIP44 etc.
>>> These standards are well supported and allow users to move easily between different wallets.
>>> There is, however, no defined standard to transfer any labels the user may have applied to the transactions, addresses, inputs or outputs in their wallet.
>>> The UTXO model that Bitcoin uses makes these labels particularly valuable as they may indicate the source of funds, whether received externally or as a result of change from a prior transaction.
>>> In both cases, care must be taken when spending to avoid undesirable leaks of private information.
>>> Labels provide valuable guidance in this regard, and have even become mandatory when spending in several Bitcoin wallets.
>>> Allowing users to export their labels in a standardized way ensures that they do not experience lock-in to a particular wallet application.
>>> In addition, by using common formats, this BIP seeks to make manual or bulk management of labels accessible to users without specific technical expertise.
>>>
>>> ==Specification==
>>>
>>> In order to make the import and export of labels as widely accessible as possible, this BIP uses the comma separated values (CSV) format, which is widely supported by consumer, business, and scientific applications.
>>> Although the technical specification of CSV in RFC4180 is not always followed, the application of the format in this BIP is simple enough that compatibility should not present a problem.
>>> Moreover, the simplicity and forgiving nature of CSV (over for example JSON) lends itself well to bulk label editing using spreadsheet and text editing tools.
>>>
>>> A CSV export of labels from a wallet must be a UTF-8 encoded text file, containing one record per line, with records containing two fields delimited by a comma.
>>> The fields may be quoted, but this is unnecessary, as the first comma in the line will always be the delimiter.
>>> The first line in the file is a header, and should be ignored on import.
>>> Thereafter, each line represents a record that refers to a label applied in the wallet.
>>> The order in which these records appear is not defined.
>>>
>>> The first field in the record contains a reference to the transaction, address, input or output in the wallet.
>>> This is specified as one of the following:
>>> * Transaction ID (<tt>txid</tt>)
>>> * Address
>>> * Input (rendered as <tt>txid<index</tt>)
>>> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)
>>>
>>> The second field contains the label applied to the reference.
>>> Exporting applications may omit records with no labels or labels of zero length.
>>> Files exported should use the <tt>.csv</tt> file extension.
>>>
>>> In order to reduce file size while retaining wide accessibility, the CSV file may be compressed using the ZIP file format, using the <tt>.zip</tt> file extension.
>>> This <tt>.zip</tt> file may optionally be encrypted using either AES-128 or AES-256 encryption, which is supported by numerous applications including Winzip and 7-zip.
>>> In order to ensure that weak encryption does not proliferate, importers following this standard must refuse to import <tt>.zip</tt> files encrypted with the weaker Zip 2.0 standard.
>>> The textual representation of the wallet's extended public key (as defined by BIP32, with an <tt>xpub</tt> header) should be used as the password.
>>>
>>> ==Importing==
>>>
>>> When importing, a naive algorithm may simply match against any reference, but it is possible to disambiguate between transactions, addresses, inputs and outputs.
>>> For example in the following pseudocode:
>>> <pre>
>>> if reference length < 64
>>> Set address label
>>> else if reference length == 64
>>> Set transaction label
>>> else if reference contains '<'
>>> Set input label
>>> else
>>> Set output label
>>> </pre>
>>>
>>> Importing applications may truncate labels if necessary.
>>>
>>> ==Test Vectors==
>>>
>>> The following fragment represents a wallet label export:
>>> <pre>
>>> Reference,Label
>>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?,Transaction
>>> 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address
>>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?<0,Input
>>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?>0,Output
>>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?:0,Output (alternative)
>>> </pre>
>>>
>>> ==Reference Implementation==
>>>
>>> TBD
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220825/20dfb197/attachment-0001.html>

From ali at notatether.com  Fri Aug 26 06:06:30 2022
From: ali at notatether.com (Ali Sherief)
Date: Fri, 26 Aug 2022 06:06:30 +0000
Subject: [bitcoin-dev] BIP Proposal: Wallet Labels Export Format
In-Reply-To: <mailman.11604.1661435396.956.bitcoin-dev@lists.linuxfoundation.org>
References: <mailman.11604.1661435396.956.bitcoin-dev@lists.linuxfoundation.org>
Message-ID: <20220826060620.mgpbmnpw7cwea3az@artanis>

I think these problems can be mitigated if the CSV format is strictly defined, such as how I specified it in my previous message.

In particular, the parser has to recognize only one specific header line that has a version number somewhere, or abort - and I still insist on quoting the labels with double-quote and introducing a 3rd column with specific string or numeric types and then replacing all the special characters in the input/output with ":".

Strictly defining CSV version and consequentially, the fields, and then specifying on what kind of data the import is supposed to fail at will limit the complexity of importers to N different switch cases - where N is the number of circulating versions of the format (for now 1).

- Ali

On Thu, Thu, 25 Aug 2022 13:48:36 +0000, rhavar at protonmail.com wrote:
> > Not only is JSON limited to editing only through specific software or text editors, but (in the latter case) it is fragile enough that a single missing character can cause an entire file to fail parsing. CSV is more forgiving in this regard.
>
> I think quite simply: A forgiving format is not appropriate for a standard.
>
> It'd be hard to understate how much extra and pointless effort it creates for everyone, and every implementation ends up creating its own defacto standard for what it produces and accepts. Even doing something as simple as adding an extra column will not be possible in the future because it'll break comparability with previous parsers.
>
> I've literally worked on projects where the csv parser has evolved into scan-ahead to use heuristics to understand "rules" of a csv file, and then do line-by-line heuristics to override those rules in pathological cases. Makes a bit of sense when you're trying to achieve 30 years of backwards compatibility. Doesn't make sense for much else..
>
> If your application users really like csv, then introduce an application-specific import-from-csv and export-to-csv with your own rules.
> -Ryan
>
> ------- Original Message -------
> On Thursday, August 25th, 2022 at 1:59 AM, Craig Raw <craigraw at gmail.com> wrote:
>
> > Thanks for your thoughts Ryan.
> >
> > Without reference to the quality feedback on this proposal, I was aware when submitting it for review that it provides an excellent opportunity for bike shedding. As developers, we have all experienced frustration with data formats. One thing that I did not perhaps make clear enough is that this format is not solely intended for developers, but general users who are probably not well represented on this list.
> >
> > While doing research for this proposal I spoke to several professional users of Sparrow Wallet (who are not developers). They all expressed a desire for the format to integrate with their business processes, which are driven by business tools such as Excel. Labelling provides an important function in UTXO and address management in these scenarios, and needs to be accessible and manageable outside of wallet software.
> >
> > If this is to be achieved, it immediately rules out JSON as a data format. Not only is JSON limited to editing only through specific software or text editors, but (in the latter case) it is fragile enough that a single missing character can cause an entire file to fail parsing. CSV is more forgiving in this regard. With respect to your comments on escaping, my expectation would be that developers will be using a mature CSV library rather than handling character escaping themselves. I would rather propose a format that is generally usable, even if occasionally a label is escaped incorrectly.
> >
> > Finally, I'll note that CSV files are already common and uncontroversial in Bitcoin wallet software. Bitcoin Core, Electrum, Sparrow (and no doubt many others) already export addresses and/or transactions with their labels as CSV files. This proposal simply attempts to create a standard for importing and exporting all the labels in a wallet.
> >
> > Craig
> >
> > On Wed, Aug 24, 2022 at 9:01 PM <rhavar at protonmail.com> wrote:
> >
> >> I'd strongly suggest not using CSV. Especially for a standard. I've worked with it as an interchange format many a times, and it's always been a clusterfuck.
> >>
> >> Right off the bat, you have stuff like "The fields may be quoted, but this is unnecessary as the first comma in the line will always be the delimiter" which invariably leads to some implementations doing it, some implementations not doing it, and others that are intolerant of the other way.
> >>
> >> And you have also made the classic mistake of not strictly defining escape rules. So everyone will pick their own (e.g. some will \, escape commas, others will not cause it's quoted and escape quotes, and others will assume no escaping is required since its the last column in a csv).
> >>
> >> Over time it morphs into its own mini-monster that introduces so much pain.
> >>
> >> On a similar note, allowing alternatives (like: txid>index vs txid:index) provides no benefit, but creates additional work for implementations (who quite likely only test formats they produce) and future incompatibilities.
> >>
> >> I know everyone loves to hate on it, but really (line-separated?) json is the way to go.
> >>
> >> { "tx": "c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?", "label": "wow, such label" }
> >> { "tx: "c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b", "txout": 4, "label": "omg this is so easy to parse" }
> >> { "tx: "c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b", "txin": 0, "label": "wow this is going to be extensible as well" }
> >>
> >> -Ryan
> >>
> >> ------- Original Message -------
> >> On Wednesday, August 24th, 2022 at 2:18 AM, Craig Raw via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>
> >>> Hi all,
> >>>
> >>> I would like to propose a BIP that specifies a format for the export and import of labels from a wallet. While transferring access to funds across wallet applications has been made simple through standards such as BIP39, wallet labels remain siloed and difficult to extract despite their value, particularly in a privacy context.
> >>>
> >>> The proposed format is a simple two column CSV file, with the reference to a transaction, address, input or output in the first column, and the label in the second column. CSV was chosen for its wide accessibility, especially to users without specific technical expertise. Similarly, the CSV file may be compressed using the ZIP format, and optionally encrypted using AES.
> >>>
> >>> The full text of the BIP can be found at https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki and also copied below.
> >>>
> >>> Feedback is appreciated.
> >>>
> >>> Thanks,
> >>> Craig Raw
> >>>
> >>> ---
> >>>
> >>> <pre>
> >>> BIP: wallet-labels
> >>> Layer: Applications
> >>> Title: Wallet Labels Export Format
> >>> Author: Craig Raw <craig at sparrowwallet.com>
> >>> Comments-Summary: No comments yet.
> >>> Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels
> >>> Status: Draft
> >>> Type: Informational
> >>> Created: 2022-08-23
> >>> License: BSD-2-Clause
> >>> </pre>
> >>>
> >>> ==Abstract==
> >>>
> >>> This document specifies a format for the export of labels that may be attached to the transactions, addresses, input and outputs in a wallet.
> >>>
> >>> ==Copyright==
> >>>
> >>> This BIP is licensed under the BSD 2-clause license.
> >>>
> >>> ==Motivation==
> >>>
> >>> The export and import of funds across different Bitcoin wallet applications is well defined through standards such as BIP39, BIP32, BIP44 etc.
> >>> These standards are well supported and allow users to move easily between different wallets.
> >>> There is, however, no defined standard to transfer any labels the user may have applied to the transactions, addresses, inputs or outputs in their wallet.
> >>> The UTXO model that Bitcoin uses makes these labels particularly valuable as they may indicate the source of funds, whether received externally or as a result of change from a prior transaction.
> >>> In both cases, care must be taken when spending to avoid undesirable leaks of private information.
> >>> Labels provide valuable guidance in this regard, and have even become mandatory when spending in several Bitcoin wallets.
> >>> Allowing users to export their labels in a standardized way ensures that they do not experience lock-in to a particular wallet application.
> >>> In addition, by using common formats, this BIP seeks to make manual or bulk management of labels accessible to users without specific technical expertise.
> >>>
> >>> ==Specification==
> >>>
> >>> In order to make the import and export of labels as widely accessible as possible, this BIP uses the comma separated values (CSV) format, which is widely supported by consumer, business, and scientific applications.
> >>> Although the technical specification of CSV in RFC4180 is not always followed, the application of the format in this BIP is simple enough that compatibility should not present a problem.
> >>> Moreover, the simplicity and forgiving nature of CSV (over for example JSON) lends itself well to bulk label editing using spreadsheet and text editing tools.
> >>>
> >>> A CSV export of labels from a wallet must be a UTF-8 encoded text file, containing one record per line, with records containing two fields delimited by a comma.
> >>> The fields may be quoted, but this is unnecessary, as the first comma in the line will always be the delimiter.
> >>> The first line in the file is a header, and should be ignored on import.
> >>> Thereafter, each line represents a record that refers to a label applied in the wallet.
> >>> The order in which these records appear is not defined.
> >>>
> >>> The first field in the record contains a reference to the transaction, address, input or output in the wallet.
> >>> This is specified as one of the following:
> >>> * Transaction ID (<tt>txid</tt>)
> >>> * Address
> >>> * Input (rendered as <tt>txid<index</tt>)
> >>> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)
> >>>
> >>> The second field contains the label applied to the reference.
> >>> Exporting applications may omit records with no labels or labels of zero length.
> >>> Files exported should use the <tt>.csv</tt> file extension.
> >>>
> >>> In order to reduce file size while retaining wide accessibility, the CSV file may be compressed using the ZIP file format, using the <tt>.zip</tt> file extension.
> >>> This <tt>.zip</tt> file may optionally be encrypted using either AES-128 or AES-256 encryption, which is supported by numerous applications including Winzip and 7-zip.
> >>> In order to ensure that weak encryption does not proliferate, importers following this standard must refuse to import <tt>.zip</tt> files encrypted with the weaker Zip 2.0 standard.
> >>> The textual representation of the wallet's extended public key (as defined by BIP32, with an <tt>xpub</tt> header) should be used as the password.
> >>>
> >>> ==Importing==
> >>>
> >>> When importing, a naive algorithm may simply match against any reference, but it is possible to disambiguate between transactions, addresses, inputs and outputs.
> >>> For example in the following pseudocode:
> >>> <pre>
> >>> if reference length < 64
> >>> Set address label
> >>> else if reference length == 64
> >>> Set transaction label
> >>> else if reference contains '<'
> >>> Set input label
> >>> else
> >>> Set output label
> >>> </pre>
> >>>
> >>> Importing applications may truncate labels if necessary.
> >>>
> >>> ==Test Vectors==
> >>>
> >>> The following fragment represents a wallet label export:
> >>> <pre>
> >>> Reference,Label
> >>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?,Transaction
> >>> 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address
> >>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?<0,Input
> >>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?>0,Output
> >>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?:0,Output (alternative)
> >>> </pre>
> >>>
> >>> ==Reference Implementation==
> >>>
> >>> TBD


From billy.tetrud at gmail.com  Sat Aug 27 21:01:21 2022
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Sat, 27 Aug 2022 16:01:21 -0500
Subject: [bitcoin-dev] On a new community process to specify covenants
In-Reply-To: <CALZpt+HWzZdwMrtX=8rMpZ+e5dWcmbMeEx3jhTB_XnWz1n7RJQ@mail.gmail.com>
References: <CALZpt+FhpZETHP8UpDGgw-Wg=m4Hxm8y9XZ9kXYgmt90_6Zt6w@mail.gmail.com>
 <CAHUJnBDu+PNvER-FmpT8593vX-wAZ1oPWJjQaJ=d7Y4pso_Txw@mail.gmail.com>
 <CALZpt+E4Ej3KJ4WqkUDTF3DRhPTbUT5mw2c_eHLuxH7w1BbWGg@mail.gmail.com>
 <CAHUJnBB1wExgJhHUeU88ZMD28s6+9UT3Cfc43_UpK40hJwUFSg@mail.gmail.com>
 <CAGpPWDbbZ7PEpr4iwYwBn+5QcjjCx8qmTZVB98i2Z=UwDfwaTQ@mail.gmail.com>
 <CALZpt+HWzZdwMrtX=8rMpZ+e5dWcmbMeEx3jhTB_XnWz1n7RJQ@mail.gmail.com>
Message-ID: <CAGpPWDY0WV0dzRx2mD7kd-48+wrF=BJBf=ZB5R6+owPrdHTp+w@mail.gmail.com>

>  I would like to note it's real work for the organizers in terms of time
and energy: finding a common date making consensus, an acceptable host
country (i.e respecting the travel policy of the widest...

I was actually not thinking one large central in-person meeting, but many
smaller decentralized in-person meetings where no one has to travel far.
The meetings can be used to foster communication that can then be
summarized and/or brought online and discussed with the larger group. Would
certainly make all those date/visa/etc issues a lot easier.

>  I would be even cautious about something restrained like "group
consensus" in Bitcoin FOSS. At best, it's just a snapshot of people's
understanding of the technical issues in state X at time T

Fair enough. But I think part of the point here would be to use such a
snapshot as an indicator that helps convince others that a particular idea
has been discussed, thought through, and has actual well-reasoned support.
Whatever you call it, it would be a useful set of data points.

>  I believe the covenant problem space might be solved in an evolutionary
way, layer by layer akin to how LN moves forward.

Definitely.


On Tue, Aug 9, 2022 at 3:15 PM Antoine Riard <antoine.riard at gmail.com>
wrote:

> Hi Billy,
>
> Thanks for your interest in a covenant working group.
>
> > place for this kind of thing to happen. I also agree with Ryan Grant's
> > comment about in-person cut-through (ie cut through the BS and resolve
> > misunderstandings). Perhaps every 3 IRC meetings or so, an in-person
> meetup
> > can be organized in various locations to facilitate that kind of cut
> > through.
>
> I really appreciate in-person cut-through to resolve misunderstandings and
> accelerate the information synchronization across the stakeholders of a
> problem space. However, I would like to note it's real work for the
> organizers in terms of time and energy: finding a common date making
> consensus, an acceptable host country (i.e respecting the travel policy of
> the widest, e.g organizing Scaling in Israel in 2019 was an issue for some
> passport holders), a standard meeting location, seeking event sponsors,
> communicating all those infos well ahead to ease everyone travels, ensuring
> coffees & foods suiting many different diets, collecting topics of
> discussions, etc. Further, even assuming travel support, it can still be a
> prohibitive cost for a lot of participants, e.g if you have to request
> months ahead to the host country authorities a dedicated visa for the
> opportunity. I did a bit of in-person meetings organizing in the past, I'm
> clearly not interested in doing it anymore, though it would be cool if
> someone would like to do it for covenants in the future.
>
> > I would imagine the phases the group could go through is:
> > 1. Define the phases (these phases). This list of 6 phases could be a
> > starting point, but its probably best to open the floor to whether this
> > feels like a reasonable approach and if more phases are needed or if some
> > aren't.
> > 2. Define and prioritize the motivations (ie the various features and
> > functionality we want out of covenants, like the ones you listed). By
> > prioritize, I mostly mean figure out which motivations are most
> motivating
> > to people and rate them by strength of motivation (rather than a ranked
> > list).
> > 3. Define and prioritize the relevant constraints. These are things to
> > avoid in any covenant implementation. Constraints that have been brought
> up
> > in the past are things like preventing the possibility of infinite
> covenant
> > recursion, full enumeration, preventing dynamic state, etc. By prioritize
> > here, it might be useful to categorize them into categories like "no
> > tolerance", "some tolerance", "no reservations". Eg it might turn out
> most
> > people don't have any tolerance for infinite recursion, but don't mind
> > non-full enumeration.
> > 4. Other criteria? These are other criteria we might want to evaluate
> > proposals according to. And some kind of way to prioritize them /
> evaluate
> > them against each other as trade offs.
> > 5. Evaluate the proposals based on motivations, constraints, and other
> > criteria. This phase shouldn't involve comparing them to each other.
> > 6. Produce a set of conclusions/opinions on which proposals are worth
> > pursuing further. This would be the phase where proposals are compared.
>
> Yes, I think overall a lot is making sense. Though it's good to keep
> things as loose and see how it evaluates with time and new information
> showing up.
>
> About 2., I think one more thing to define is the list of use-cases, I
> would abstract out features and functionality from use-cases. E.g, I think
> with the TLUV proposal, the taproot output editing feature enables both
> "dynamic-amount" vault and scaling payment pools.
>
> About 3., I think this is going to be the hard part. Collecting all the
> constraints and evaluating the risk tolerance of as-much-as-we-can
> community stakeholders in face of known and plausible risks. E.g, again
> with TLUV, I think it would make from now on the taproot internal pubkey
> and tree of alternative scripts a kind of "dynamic state".
>
> About 4. I've quickly come to mind as additional criterias economic
> simulations of any feature, privacy advantages, toolchain implementations
> complexity, evolvability and composability with future features.
>
> About 6. I agree I think it's good to withhold comparison further down in
> the pipe we can, even if there is I would say some criteria-learning
> heuristics by mirroring features against another.
>
> > Each phase would probably span over more than one meeting. I imagine each
> > phase basically consisting of discussing each individual nominated item
> (ie
> > motivations, constraints, other criteria, or proposals) sequentially. The
> > consensus reached at the end of each phase would be considered of course
> a
> > group consensus of those who participated, not a global consensus, not a
> > "bitcoin community consensus". After each phase, the results of that
> phase
> > would be published more widely to get broader community feedback. These
> > results would include what the major opinions are, what level of
> consensus
> > each major opinion has, what the reasons/justifications behind each
> opinion
> > are, and various detailed opinions from individuals. It would be
> especially
> > great to have detailed evaluations of each proposal published by various
> > people so anyone can go back and understand their thought process (as
> > opposed to a list of names attached to basically a thumbs up or thumbs
> > down). Think like a supreme court decision kind of thing.
>
> Yeah, again I don't see meetings as bounded in time rather happening
> regularly as we have with LN ones. I guess it's going to take at least a
> good year for working group participants to take habits and familiarity
> with the problem space and reach consensus on the process itself. Further,
> I would be even cautious about something restrained like "group consensus"
> in Bitcoin FOSS. At best, it's just a snapshot of people's understanding of
> the technical issues in state X at time T, and that can evaluate quickly in
> function of new findings or issues arising. I think it's more interesting
> to seek a lack of consensus in the sense of opposite opinions or blocking
> arguments. I wouldn't disqualify thumbs up or thumbs down per se, there are
> marks of interest in a specific proposal, though I lean to agree that I
> find more interesting too laid-out evaluations and thought processes.
>
> > The process doesn't need to be complete after phase 6. Any previous phase
> > could be revisited, but after a phase is revisited, the phases after it
> > should probably be also revisited in order - or at least until its
> decided
> > a previous phase needs to be revisited again. Each iteration would
> solidify
> > consensus more about each phase. I would imagine the group might loop
> > through phases 2, 3, and 4 a couple times (since constraints might
> conflict
> > with motivating features). It might be likely that in phase 5 while
> > evaluating proposals, people realize that there are additional criteria
> > that should be added and can propose going back to step 4 to do that.
> > Hopefully we would get to the point where the motivations and constraints
> > and relatively solid consensuses and iterations can loop through phases 5
> > and 6 until the set of proposals the group thinks is worth pursuing  is
> > narrowed down (ideally to 1 or 2).
>
> For sure, in the function of new feedback arising it's good to constantly
> reevaluate proposals. Hopefully, I think any looping should make proposals
> more formalized and accurate. We might also have the "easy" covenants
> moving faster than the "hard" ones across the phases. I believe the
> covenant problem space might be solved in an evolutionary way, layer by
> layer akin to how LN moves forward.
>
> Le mer. 3 ao?t 2022 ? 11:37, Billy Tetrud <billy.tetrud at gmail.com> a
> ?crit :
>
>> @Antoine
>> I very much like your proposal of an open decentralized process for
>> investigating the problem and solution spaces. IRC sounds like a reasonable
>> place for this kind of thing to happen. I also agree with Ryan Grant's
>> comment about in-person cut-through (ie cut through the BS and resolve
>> misunderstandings). Perhaps every 3 IRC meetings or so, an in-person meetup
>> can be organized in various locations to facilitate that kind of cut
>> through.
>>
>> I would imagine the phases the group could go through is:
>> 1. Define the phases (these phases). This list of 6 phases could be a
>> starting point, but its probably best to open the floor to whether this
>> feels like a reasonable approach and if more phases are needed or if some
>> aren't.
>> 2. Define and prioritize the motivations (ie the various features and
>> functionality we want out of covenants, like the ones you listed). By
>> prioritize, I mostly mean figure out which motivations are most motivating
>> to people and rate them by strength of motivation (rather than a ranked
>> list).
>> 3. Define and prioritize the relevant constraints. These are things to
>> avoid in any covenant implementation. Constraints that have been brought up
>> in the past are things like preventing the possibility of infinite covenant
>> recursion, full enumeration, preventing dynamic state, etc. By prioritize
>> here, it might be useful to categorize them into categories like "no
>> tolerance", "some tolerance", "no reservations". Eg it might turn out most
>> people don't have any tolerance for infinite recursion, but don't mind
>> non-full enumeration.
>> 4. Other criteria? These are other criteria we might want to evaluate
>> proposals according to. And some kind of way to prioritize them / evaluate
>> them against each other as trade offs.
>> 5. Evaluate the proposals based on motivations, constraints, and other
>> criteria. This phase shouldn't involve comparing them to each other.
>> 6. Produce a set of conclusions/opinions on which proposals are worth
>> pursuing further. This would be the phase where proposals are compared.
>>
>> Each phase would probably span over more than one meeting. I imagine each
>> phase basically consisting of discussing each individual nominated item (ie
>> motivations, constraints, other criteria, or proposals) sequentially. The
>> consensus reached at the end of each phase would be considered of course a
>> group consensus of those who participated, not a global consensus, not a
>> "bitcoin community consensus". After each phase, the results of that phase
>> would be published more widely to get broader community feedback. These
>> results would include what the major opinions are, what level of consensus
>> each major opinion has, what the reasons/justifications behind each opinion
>> are, and various detailed opinions from individuals. It would be especially
>> great to have detailed evaluations of each proposal published by various
>> people so anyone can go back and understand their thought process (as
>> opposed to a list of names attached to basically a thumbs up or thumbs
>> down). Think like a supreme court decision kind of thing.
>>
>> The process doesn't need to be complete after phase 6. Any previous phase
>> could be revisited, but after a phase is revisited, the phases after it
>> should probably be also revisited in order - or at least until its decided
>> a previous phase needs to be revisited again. Each iteration would solidify
>> consensus more about each phase. I would imagine the group might loop
>> through phases 2, 3, and 4 a couple times (since constraints might conflict
>> with motivating features). It might be likely that in phase 5 while
>> evaluating proposals, people realize that there are additional criteria
>> that should be added and can propose going back to step 4 to do that.
>> Hopefully we would get to the point where the motivations and constraints
>> and relatively solid consensuses and iterations can loop through phases 5
>> and 6 until the set of proposals the group thinks is worth pursuing  is
>> narrowed down (ideally to 1 or 2).
>>
>>
>>
>>
>>
>>
>> On Tue, Jul 26, 2022 at 11:47 AM Bram Cohen via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> On Mon, Jul 25, 2022 at 8:21 PM Antoine Riard <antoine.riard at gmail.com>
>>> wrote:
>>>
>>>> What would be the canonical definition and examples of capabilities in
>>>> the Bitcoin context ?
>>>>
>>>
>>> Payments into vaults which can only be accepted by that vault and are
>>> guaranteed to be subject to the vault's restrictions (the vault has a
>>> capability)
>>>
>>> Oracles whose validity can be verified on chain (so transactions can
>>> depend on what they say. The oracle has a capability)
>>>
>>> Colored coins whose validity can be verified on chain (the colored coins
>>> have a capability)
>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220827/651cda91/attachment-0001.html>

From billy.tetrud at gmail.com  Sat Aug 27 21:03:01 2022
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Sat, 27 Aug 2022 16:03:01 -0500
Subject: [bitcoin-dev] BIP Proposal: Wallet Labels Export Format
In-Reply-To: <20220824190958.gklg3riadci3ttgm@artanis>
References: <mailman.9.1661342403.3868.bitcoin-dev@lists.linuxfoundation.org>
 <20220824190958.gklg3riadci3ttgm@artanis>
Message-ID: <CAGpPWDb9jPxcZcQ_u+H+K0mbpYdyRU_FAJ6usQy0iJKXn+RPpQ@mail.gmail.com>

@Ali Thats some good well thought through and well articulated feedback. I
have one point of contention

> it's important that unnecessary types are kept out of the format. People
are known to leave files lying around on their computer that they don't
need anymore, so these files can find their way via telemetry to
surveillence entities. While we can't specify what users can do with their
exports, we can control the information leak by preventing certain types of
items that we know most users will never use from being exported in the
first place.

This seems to run contrary with your point about letting users be in
control of how they store this. Given that you can always connect together
an output and its address or find the outputs at any address, it doesn't
seem like it would actually leak any more information than just including
addresses. Am I missing something?

On Wed, Aug 24, 2022, 14:44 Ali Sherief via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi Craig,
>
> This a really good proposal. I studied your BIP and I have some feedback
> on some parts of it.
>
> > The first line in the file is a header, and should be ignored on import.
>
> From past experience and lessons, most notably BIP39, it is important that
> a version byte is defined somewhere in case someone wants to extend it in
> the future, currently there is no version byte which someone can increment
> if somebody wants to extend it. In the unique case of CSV files, you should
> make the header line mandatory (I see you have already implied this, but
> you should make it explicit in the BIP), but instead of a line with columns
> in it, I suggest instead of Reference,Label, you make the format like this:
>
> BIP-wallet-labels,<version>
>
> Since there are two columns per record, this works out nicely. The first
> column can be the name of the BIP - BIPxxxx where the x's are numbers, and
> the second column can be an unsigned 32-bit integer (most significant 8
> bits reserved for version, the remaining for flags, or perhaps the entirety
> for version - but I recommend leaving at least some bits for flags, even if
> they all end up being just "reserved").
>
> You should make importing fail if the header line is not exactly as
> specified - or appropriate, should you decide a different format for the
> header.
>
> > Files exported should use the <tt>.csv</tt> file extension.
> Don't mandate the file extension (read below for why):
>
> > In order to reduce file size while retaining wide accessibility, the CSV
> > file may be compressed using the ZIP file format, using the <tt>.zip</tt>
> > file extension.
> I see three problems with this. The first is more important than the later
> two because it makes them moot points, but I'll mention them anyway so you
> get a background of the situation:
> - The BIP is trying to specify in what file format the export format can
> be written in onto the filesystem. There is no way to enforce this on a BIP
> level (besides, Unix operating systems don't even consider the file
> extension, they use its mimetype). Also specifying this in the BIP will
> prevent modular "Layer 2" protocols and schemes from encoding the Export
> labels into another format - for example Base64 or with their own
> compression algorithm.
>
> Now for the two "moot problems":
> - ZIP does not have good performance or compression ratio, there are
> better algorithms out there like gzip (which also happens to be more
> ubiquitous; nearly all websites are serving HTML compressed with gzip
> compression).
> - ZIP is an archiving format, that happens to have its own compression
> format. Archiving format parsers can have serious vulnerabilities in their
> implementation that can allow malware to swipe private keys and passwords,
> since the primary target for this BIP is wallets. For example, there was
> Zip Slip[1] in 2018, which allows for remote code execution. So the malware
> can even hide in memory until private keys or passwords are written to
> memory, then send them accros the network. Assuming it's targeting a
> specific wallet software it's not hard to carry out at all.
>
> There's two solutions for all this:
> 1. The duck-tape solution: Use some compression algorithm like gzip
> instead of ZIP archive format.
> 2. The "throw it out and buy a new one" solution: Get rid of the optional
> compression specs altogether, because users are responsible for supplying
> the export labels in the first place, so all the compression stuff is
> redundant and should be left up to the user use if they desire to.
>
> I prefer the second solution because it hits the nail at the problem
> directly instead of putting duck tape on it like the first one.
>
> > This <tt>.zip</tt> file may optionally be encrypted using either AES-128
> or
> > AES-256 encryption, which is supported by numerous applications including
> > Winzip and 7-zip.
> > The textual representation of the wallet's extended public key (as
> defined
> > by BIP32, with an <tt>xpub</tt> header) should be used as the password.
> Not specific to AES, but I don't see the benefit of encrypting addresses
> and labels together. Can you please elaborate why this would be desireable?
>
> Like I said though, it's better to leave it up to users to decide how to
> store their exports, since BIPs can't enforce that anyway (additionally,
> the password you propose is insecure - anybody with access to the wallet
> can unlock it, which is not desireable to some users who want their own
> security).
>
> > * Transaction ID (<tt>txid</tt>)
> > * Address
> > * Input (rendered as <tt>txid<index</tt>)
> > * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)
> Why the need for input and output formats? There is no difference between
> them on the wallet level, because they are always identified with a txid
> and output index. To distinguish between them and hence write them with the
> correct format would require a UTXO set and thus access to a full node,
> otherwise the CSV cannot be verified to be completely well-formed.
>
> Another important point is that practically nobody labels inputs or
> outputs because most people do not know that those things even exist, and
> the rest don't bother to label them.
>
> But the biggest downside to including them is related to the problem of
> information leaking which you make reference to here:
> > In both cases, care must be taken when spending to avoid undesirable
> leaks
> > of private information.
> A CSV dump that has inputs/outputs and addresses mixed together can infer
> the owner of all those items. In fact, A CVS label dump is basically a
> personal information store so everything in it can be correlated as coming
> from the same wallet, so it's important that unnecessary types are kept out
> of the format. People are known to leave files lying around on their
> computer that they don't need anymore, so these files can find their way
> via telemetry to surveillence entities. While we can't specify what users
> can do with their exports, we can control the information leak by
> preventing certain types of items that we know most users will never use
> from being exported in the first place.
>
> > The order in which these records appear is not defined.
> Again, since the primary use case for this BIP is wallets, which likely
> use heirarchical derivation schemes like BIP44, there is a net benefit for
> the addresses to be exported in ascending order of their `address_type`. It
> means that wallets can import them in O(n) time as opposed to O(n^2) time
> spent serially checking in which index the address appears at. Of course,
> this implies that all addresses up to a certain index have to be exported
> into the CSV as well, but most wallets I know of like Core, Electrum
> already store addresses like that.
>
> Also if you do this, you will need to group all the transaction records
> before the address records or vice versa - you can use lexigraphical
> sorting if you want (ie. Addresses before Transactions). The benefit of
> this separation of parts is that wallets can split the imported address
> records from the transaction records internally, and feed them to separate
> functions which set these labels internally.
>
> If you decide on doing it this way, then you need a 3rd column to identify
> the item type, and also you should quote the label (see below). I strongly
> recommend using numbers for identification as opposed to character strings,
> so you don't have to worry about localization or character case issues.
> There is always one unique number, but there could be multiple strings that
> reference the same type. This will complicate importing functions.
>
> If you insist on include Input and Output types then they can both be
> specified as <txid>:<index> if you do this change. They won't be used to
> determine the type anyway.
>
> > The fields may be quoted, but this is unnecessary, as the first comma in
> > the line will always be the delimiter.
> Don't implement it like that, because that will break CSV parsers which
> expect a fixed amount of rows in each record (2 in the header, and some
> rows have >2 rows). It's better to mandate that they should always be
> double-quoted, since only wallets will generate label exports anyway. If
> you plan to use headers then the 3rd column can be blank for it (or you can
> split the version and flags from each other).
>
> > ==Importing==
> >
> > When importing, a naive algorithm may simply match against any reference,
> > but it is possible to disambiguate between transactions, addresses,
> inputs
> > and outputs.
> > For example in the following pseudocode:
> > <pre>
> >   if reference length < 64
> >     Set address label
> >   else if reference length == 64
> >     Set transaction label
> >   else if reference contains '<'
> >     Set input label
> >   else
> >     Set output label
> > </pre>
> The importing code is too naive and in its current form will prevent the
> BIP from getting a number. It is perhaps the single most important part of
> a BIP. When implementing an importer, it should utilize a dedicate item
> type field that unambiguously identifies the item. So the naive importer is
> not good, you need use a 3rd column for that like I explained above, so
> that the importer becomes robust.
>
> In summary (exclamation marks indicate severity - one means low, two means
> medium, and three means high):
>
> 1. Convert the header into a version line with optional flags, otherwise
> nobody can extend this format without compatibility issues (!)
> 2. Get rid of the specs related to file compression (!!!)
> 3. Add a 3rd column for item type (address, transaction etc.) preferably
> as numeric constants and grouping items of one type after items of another
> type, or if you insist on strings, then only recognize their Titlecase
> ASCII versions <spreadsheet software like Excel always tries to titlecase
> the words> (!!)
> 4. Require double quotes around the label (or single quotes if you prefer,
> as long as spreadsheet software doesn't choke on them) (!!)
> 5. Require sorting the records according to the order they are stored in
> the wallet implementation. (!)
> 6. Consider getting rid of Input and Output item types. (!)
> 7. And last and most importantly, please write a more robust importer
> algorithm in the example given by the BIP, because code in BIPs are
> frequently used as references for software. (!!!)
>
> I hope you will consider these points in future revisions of your BIP.
>
> - Ali
>
> [1] https://github.com/snyk/zip-slip-vulnerability
>
> On Wed, 24 Aug 2022 11:18:43 +0200, craigraw at gmail.com wrote:
> > Hi all,
> >
> > I would like to propose a BIP that specifies a format for the export and
> > import of labels from a wallet. While transferring access to funds across
> > wallet applications has been made simple through standards such as BIP39,
> > wallet labels remain siloed and difficult to extract despite their value,
> > particularly in a privacy context.
> >
> > The proposed format is a simple two column CSV file, with the reference
> to
> > a transaction, address, input or output in the first column, and the
> label
> > in the second column. CSV was chosen for its wide accessibility,
> especially
> > to users without specific technical expertise. Similarly, the CSV file
> may
> > be compressed using the ZIP format, and optionally encrypted using AES.
> >
> > The full text of the BIP can be found at
> > https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki
> > and also copied below.
> >
> > Feedback is appreciated.
> >
> > Thanks,
> > Craig Raw
> >
> > ---
> >
> > <pre>
> >   BIP: wallet-labels
> >   Layer: Applications
> >   Title: Wallet Labels Export Format
> >   Author: Craig Raw <craig at sparrowwallet.com>
> >   Comments-Summary: No comments yet.
> >   Comments-URI:
> > https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels
> >   Status: Draft
> >   Type: Informational
> >   Created: 2022-08-23
> >   License: BSD-2-Clause
> > </pre>
> >
> > ==Abstract==
> >
> > This document specifies a format for the export of labels that may be
> > attached to the transactions, addresses, input and outputs in a wallet.
> >
> > ==Copyright==
> >
> > This BIP is licensed under the BSD 2-clause license.
> >
> > ==Motivation==
> >
> > The export and import of funds across different Bitcoin wallet
> applications
> > is well defined through standards such as BIP39, BIP32, BIP44 etc.
> > These standards are well supported and allow users to move easily between
> > different wallets.
> > There is, however, no defined standard to transfer any labels the user
> may
> > have applied to the transactions, addresses, inputs or outputs in their
> > wallet.
> > The UTXO model that Bitcoin uses makes these labels particularly valuable
> > as they may indicate the source of funds, whether received externally or
> as
> > a result of change from a prior transaction.
> > In both cases, care must be taken when spending to avoid undesirable
> leaks
> > of private information.
> > Labels provide valuable guidance in this regard, and have even become
> > mandatory when spending in several Bitcoin wallets.
> > Allowing users to export their labels in a standardized way ensures that
> > they do not experience lock-in to a particular wallet application.
> > In addition, by using common formats, this BIP seeks to make manual or
> bulk
> > management of labels accessible to users without specific technical
> > expertise.
> >
> > ==Specification==
> >
> > In order to make the import and export of labels as widely accessible as
> > possible, this BIP uses the comma separated values (CSV) format, which is
> > widely supported by consumer, business, and scientific applications.
> > Although the technical specification of CSV in RFC4180 is not always
> > followed, the application of the format in this BIP is simple enough that
> > compatibility should not present a problem.
> > Moreover, the simplicity and forgiving nature of CSV (over for example
> > JSON) lends itself well to bulk label editing using spreadsheet and text
> > editing tools.
> >
> > A CSV export of labels from a wallet must be a UTF-8 encoded text file,
> > containing one record per line, with records containing two fields
> > delimited by a comma.
> > The fields may be quoted, but this is unnecessary, as the first comma in
> > the line will always be the delimiter.
> > The first line in the file is a header, and should be ignored on import.
> > Thereafter, each line represents a record that refers to a label applied
> in
> > the wallet.
> > The order in which these records appear is not defined.
> >
> > The first field in the record contains a reference to the transaction,
> > address, input or output in the wallet.
> > This is specified as one of the following:
> > * Transaction ID (<tt>txid</tt>)
> > * Address
> > * Input (rendered as <tt>txid<index</tt>)
> > * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)
> >
> > The second field contains the label applied to the reference.
> > Exporting applications may omit records with no labels or labels of zero
> > length.
> > Files exported should use the <tt>.csv</tt> file extension.
> >
> > In order to reduce file size while retaining wide accessibility, the CSV
> > file may be compressed using the ZIP file format, using the <tt>.zip</tt>
> > file extension.
> > This <tt>.zip</tt> file may optionally be encrypted using either AES-128
> or
> > AES-256 encryption, which is supported by numerous applications including
> > Winzip and 7-zip.
> > In order to ensure that weak encryption does not proliferate, importers
> > following this standard must refuse to import <tt>.zip</tt> files
> encrypted
> > with the weaker Zip 2.0 standard.
> > The textual representation of the wallet's extended public key (as
> defined
> > by BIP32, with an <tt>xpub</tt> header) should be used as the password.
> >
> > ==Importing==
> >
> > When importing, a naive algorithm may simply match against any reference,
> > but it is possible to disambiguate between transactions, addresses,
> inputs
> > and outputs.
> > For example in the following pseudocode:
> > <pre>
> >   if reference length < 64
> >     Set address label
> >   else if reference length == 64
> >     Set transaction label
> >   else if reference contains '<'
> >     Set input label
> >   else
> >     Set output label
> > </pre>
> >
> > Importing applications may truncate labels if necessary.
> >
> > ==Test Vectors==
> >
> > The following fragment represents a wallet label export:
> > <pre>
> > Reference,Label
> >
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?,Transaction
> > 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address
> > c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?<0,Input
> >
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?>0,Output
> >
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?:0,Output
> > (alternative)
> > </pre>
> >
> > ==Reference Implementation==
> >
> > TBD
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220827/656c893a/attachment-0001.html>

From ali at notatether.com  Sat Aug 27 21:26:58 2022
From: ali at notatether.com (Ali Sherief)
Date: Sat, 27 Aug 2022 21:26:58 +0000
Subject: [bitcoin-dev] BIP Proposal: Wallet Labels Export Format
In-Reply-To: <mailman.12565.1661634459.956.bitcoin-dev@lists.linuxfoundation.org>
References: <mailman.12565.1661634459.956.bitcoin-dev@lists.linuxfoundation.org>
Message-ID: <20220827212652.nup7pscunyxnsnwv@artanis>

> This seems to run contrary with your point about letting users be in
> control of how they store this. Given that you can always connect together
> an output and its address or find the outputs at any address, it doesn't
> seem like it would actually leak any more information than just including
> addresses. Am I missing something?

That's actually true, and coming back to it now it feels more like a security-through-obscurity suggestion. It's still valid that the export files will be valuable telemetry, but now I'm starting to feel more concerned about how inputs and outputs would be represented in the first place.

Some folks have suggested writing them as descriptors for that purpose[1]. But I see problems with that approach; there are only descriptors for things like addresses, outputs, derivation paths and so on. I know of no descriptors for transaction IDs or inputs.

I am actually starting to contemplate whether it's wise to merge Inputs and Outputs to one classification conveniently called just "Outputs", because it's impossible to distinguish between them by looking at them (any input is also an output, but not vice versa). Wise, because I do not know of any wallet software that labels outputs.

- Ali

[1]: https://bitcointalk.org/index.php?topic=5411159.0

On Sat, Sat, 27 Aug 2022 16:03:01 -0500, billy.tetrud at gmail.com wrote:
> @Ali Thats some good well thought through and well articulated feedback. I
> have one point of contention
>
> > it's important that unnecessary types are kept out of the format. People
> are known to leave files lying around on their computer that they don't
> need anymore, so these files can find their way via telemetry to
> surveillence entities. While we can't specify what users can do with their
> exports, we can control the information leak by preventing certain types of
> items that we know most users will never use from being exported in the
> first place.
>
> This seems to run contrary with your point about letting users be in
> control of how they store this. Given that you can always connect together
> an output and its address or find the outputs at any address, it doesn't
> seem like it would actually leak any more information than just including
> addresses. Am I missing something?
>
> On Wed, Aug 24, 2022, 14:44 Ali Sherief via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > Hi Craig,
> >
> > This a really good proposal. I studied your BIP and I have some feedback
> > on some parts of it.
> >
> > > The first line in the file is a header, and should be ignored on import.
> >
> > From past experience and lessons, most notably BIP39, it is important that
> > a version byte is defined somewhere in case someone wants to extend it in
> > the future, currently there is no version byte which someone can increment
> > if somebody wants to extend it. In the unique case of CSV files, you should
> > make the header line mandatory (I see you have already implied this, but
> > you should make it explicit in the BIP), but instead of a line with columns
> > in it, I suggest instead of Reference,Label, you make the format like this:
> >
> > BIP-wallet-labels,<version>
> >
> > Since there are two columns per record, this works out nicely. The first
> > column can be the name of the BIP - BIPxxxx where the x's are numbers, and
> > the second column can be an unsigned 32-bit integer (most significant 8
> > bits reserved for version, the remaining for flags, or perhaps the entirety
> > for version - but I recommend leaving at least some bits for flags, even if
> > they all end up being just "reserved").
> >
> > You should make importing fail if the header line is not exactly as
> > specified - or appropriate, should you decide a different format for the
> > header.
> >
> > > Files exported should use the <tt>.csv</tt> file extension.
> > Don't mandate the file extension (read below for why):
> >
> > > In order to reduce file size while retaining wide accessibility, the CSV
> > > file may be compressed using the ZIP file format, using the <tt>.zip</tt>
> > > file extension.
> > I see three problems with this. The first is more important than the later
> > two because it makes them moot points, but I'll mention them anyway so you
> > get a background of the situation:
> > - The BIP is trying to specify in what file format the export format can
> > be written in onto the filesystem. There is no way to enforce this on a BIP
> > level (besides, Unix operating systems don't even consider the file
> > extension, they use its mimetype). Also specifying this in the BIP will
> > prevent modular "Layer 2" protocols and schemes from encoding the Export
> > labels into another format - for example Base64 or with their own
> > compression algorithm.
> >
> > Now for the two "moot problems":
> > - ZIP does not have good performance or compression ratio, there are
> > better algorithms out there like gzip (which also happens to be more
> > ubiquitous; nearly all websites are serving HTML compressed with gzip
> > compression).
> > - ZIP is an archiving format, that happens to have its own compression
> > format. Archiving format parsers can have serious vulnerabilities in their
> > implementation that can allow malware to swipe private keys and passwords,
> > since the primary target for this BIP is wallets. For example, there was
> > Zip Slip[1] in 2018, which allows for remote code execution. So the malware
> > can even hide in memory until private keys or passwords are written to
> > memory, then send them accros the network. Assuming it's targeting a
> > specific wallet software it's not hard to carry out at all.
> >
> > There's two solutions for all this:
> > 1. The duck-tape solution: Use some compression algorithm like gzip
> > instead of ZIP archive format.
> > 2. The "throw it out and buy a new one" solution: Get rid of the optional
> > compression specs altogether, because users are responsible for supplying
> > the export labels in the first place, so all the compression stuff is
> > redundant and should be left up to the user use if they desire to.
> >
> > I prefer the second solution because it hits the nail at the problem
> > directly instead of putting duck tape on it like the first one.
> >
> > > This <tt>.zip</tt> file may optionally be encrypted using either AES-128
> > or
> > > AES-256 encryption, which is supported by numerous applications including
> > > Winzip and 7-zip.
> > > The textual representation of the wallet's extended public key (as
> > defined
> > > by BIP32, with an <tt>xpub</tt> header) should be used as the password.
> > Not specific to AES, but I don't see the benefit of encrypting addresses
> > and labels together. Can you please elaborate why this would be desireable?
> >
> > Like I said though, it's better to leave it up to users to decide how to
> > store their exports, since BIPs can't enforce that anyway (additionally,
> > the password you propose is insecure - anybody with access to the wallet
> > can unlock it, which is not desireable to some users who want their own
> > security).
> >
> > > * Transaction ID (<tt>txid</tt>)
> > > * Address
> > > * Input (rendered as <tt>txid<index</tt>)
> > > * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)
> > Why the need for input and output formats? There is no difference between
> > them on the wallet level, because they are always identified with a txid
> > and output index. To distinguish between them and hence write them with the
> > correct format would require a UTXO set and thus access to a full node,
> > otherwise the CSV cannot be verified to be completely well-formed.
> >
> > Another important point is that practically nobody labels inputs or
> > outputs because most people do not know that those things even exist, and
> > the rest don't bother to label them.
> >
> > But the biggest downside to including them is related to the problem of
> > information leaking which you make reference to here:
> > > In both cases, care must be taken when spending to avoid undesirable
> > leaks
> > > of private information.
> > A CSV dump that has inputs/outputs and addresses mixed together can infer
> > the owner of all those items. In fact, A CVS label dump is basically a
> > personal information store so everything in it can be correlated as coming
> > from the same wallet, so it's important that unnecessary types are kept out
> > of the format. People are known to leave files lying around on their
> > computer that they don't need anymore, so these files can find their way
> > via telemetry to surveillence entities. While we can't specify what users
> > can do with their exports, we can control the information leak by
> > preventing certain types of items that we know most users will never use
> > from being exported in the first place.
> >
> > > The order in which these records appear is not defined.
> > Again, since the primary use case for this BIP is wallets, which likely
> > use heirarchical derivation schemes like BIP44, there is a net benefit for
> > the addresses to be exported in ascending order of their `address_type`. It
> > means that wallets can import them in O(n) time as opposed to O(n^2) time
> > spent serially checking in which index the address appears at. Of course,
> > this implies that all addresses up to a certain index have to be exported
> > into the CSV as well, but most wallets I know of like Core, Electrum
> > already store addresses like that.
> >
> > Also if you do this, you will need to group all the transaction records
> > before the address records or vice versa - you can use lexigraphical
> > sorting if you want (ie. Addresses before Transactions). The benefit of
> > this separation of parts is that wallets can split the imported address
> > records from the transaction records internally, and feed them to separate
> > functions which set these labels internally.
> >
> > If you decide on doing it this way, then you need a 3rd column to identify
> > the item type, and also you should quote the label (see below). I strongly
> > recommend using numbers for identification as opposed to character strings,
> > so you don't have to worry about localization or character case issues.
> > There is always one unique number, but there could be multiple strings that
> > reference the same type. This will complicate importing functions.
> >
> > If you insist on include Input and Output types then they can both be
> > specified as <txid>:<index> if you do this change. They won't be used to
> > determine the type anyway.
> >
> > > The fields may be quoted, but this is unnecessary, as the first comma in
> > > the line will always be the delimiter.
> > Don't implement it like that, because that will break CSV parsers which
> > expect a fixed amount of rows in each record (2 in the header, and some
> > rows have >2 rows). It's better to mandate that they should always be
> > double-quoted, since only wallets will generate label exports anyway. If
> > you plan to use headers then the 3rd column can be blank for it (or you can
> > split the version and flags from each other).
> >
> > > ==Importing==
> > >
> > > When importing, a naive algorithm may simply match against any reference,
> > > but it is possible to disambiguate between transactions, addresses,
> > inputs
> > > and outputs.
> > > For example in the following pseudocode:
> > > <pre>
> > >   if reference length < 64
> > >     Set address label
> > >   else if reference length == 64
> > >     Set transaction label
> > >   else if reference contains '<'
> > >     Set input label
> > >   else
> > >     Set output label
> > > </pre>
> > The importing code is too naive and in its current form will prevent the
> > BIP from getting a number. It is perhaps the single most important part of
> > a BIP. When implementing an importer, it should utilize a dedicate item
> > type field that unambiguously identifies the item. So the naive importer is
> > not good, you need use a 3rd column for that like I explained above, so
> > that the importer becomes robust.
> >
> > In summary (exclamation marks indicate severity - one means low, two means
> > medium, and three means high):
> >
> > 1. Convert the header into a version line with optional flags, otherwise
> > nobody can extend this format without compatibility issues (!)
> > 2. Get rid of the specs related to file compression (!!!)
> > 3. Add a 3rd column for item type (address, transaction etc.) preferably
> > as numeric constants and grouping items of one type after items of another
> > type, or if you insist on strings, then only recognize their Titlecase
> > ASCII versions <spreadsheet software like Excel always tries to titlecase
> > the words> (!!)
> > 4. Require double quotes around the label (or single quotes if you prefer,
> > as long as spreadsheet software doesn't choke on them) (!!)
> > 5. Require sorting the records according to the order they are stored in
> > the wallet implementation. (!)
> > 6. Consider getting rid of Input and Output item types. (!)
> > 7. And last and most importantly, please write a more robust importer
> > algorithm in the example given by the BIP, because code in BIPs are
> > frequently used as references for software. (!!!)
> >
> > I hope you will consider these points in future revisions of your BIP.
> >
> > - Ali
> >
> > [1] https://github.com/snyk/zip-slip-vulnerability
> >
> > On Wed, 24 Aug 2022 11:18:43 +0200, craigraw at gmail.com wrote:
> > > Hi all,
> > >
> > > I would like to propose a BIP that specifies a format for the export and
> > > import of labels from a wallet. While transferring access to funds across
> > > wallet applications has been made simple through standards such as BIP39,
> > > wallet labels remain siloed and difficult to extract despite their value,
> > > particularly in a privacy context.
> > >
> > > The proposed format is a simple two column CSV file, with the reference
> > to
> > > a transaction, address, input or output in the first column, and the
> > label
> > > in the second column. CSV was chosen for its wide accessibility,
> > especially
> > > to users without specific technical expertise. Similarly, the CSV file
> > may
> > > be compressed using the ZIP format, and optionally encrypted using AES.
> > >
> > > The full text of the BIP can be found at
> > > https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki
> > > and also copied below.
> > >
> > > Feedback is appreciated.
> > >
> > > Thanks,
> > > Craig Raw
> > >
> > > ---
> > >
> > > <pre>
> > >   BIP: wallet-labels
> > >   Layer: Applications
> > >   Title: Wallet Labels Export Format
> > >   Author: Craig Raw <craig at sparrowwallet.com>
> > >   Comments-Summary: No comments yet.
> > >   Comments-URI:
> > > https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels
> > >   Status: Draft
> > >   Type: Informational
> > >   Created: 2022-08-23
> > >   License: BSD-2-Clause
> > > </pre>
> > >
> > > ==Abstract==
> > >
> > > This document specifies a format for the export of labels that may be
> > > attached to the transactions, addresses, input and outputs in a wallet.
> > >
> > > ==Copyright==
> > >
> > > This BIP is licensed under the BSD 2-clause license.
> > >
> > > ==Motivation==
> > >
> > > The export and import of funds across different Bitcoin wallet
> > applications
> > > is well defined through standards such as BIP39, BIP32, BIP44 etc.
> > > These standards are well supported and allow users to move easily between
> > > different wallets.
> > > There is, however, no defined standard to transfer any labels the user
> > may
> > > have applied to the transactions, addresses, inputs or outputs in their
> > > wallet.
> > > The UTXO model that Bitcoin uses makes these labels particularly valuable
> > > as they may indicate the source of funds, whether received externally or
> > as
> > > a result of change from a prior transaction.
> > > In both cases, care must be taken when spending to avoid undesirable
> > leaks
> > > of private information.
> > > Labels provide valuable guidance in this regard, and have even become
> > > mandatory when spending in several Bitcoin wallets.
> > > Allowing users to export their labels in a standardized way ensures that
> > > they do not experience lock-in to a particular wallet application.
> > > In addition, by using common formats, this BIP seeks to make manual or
> > bulk
> > > management of labels accessible to users without specific technical
> > > expertise.
> > >
> > > ==Specification==
> > >
> > > In order to make the import and export of labels as widely accessible as
> > > possible, this BIP uses the comma separated values (CSV) format, which is
> > > widely supported by consumer, business, and scientific applications.
> > > Although the technical specification of CSV in RFC4180 is not always
> > > followed, the application of the format in this BIP is simple enough that
> > > compatibility should not present a problem.
> > > Moreover, the simplicity and forgiving nature of CSV (over for example
> > > JSON) lends itself well to bulk label editing using spreadsheet and text
> > > editing tools.
> > >
> > > A CSV export of labels from a wallet must be a UTF-8 encoded text file,
> > > containing one record per line, with records containing two fields
> > > delimited by a comma.
> > > The fields may be quoted, but this is unnecessary, as the first comma in
> > > the line will always be the delimiter.
> > > The first line in the file is a header, and should be ignored on import.
> > > Thereafter, each line represents a record that refers to a label applied
> > in
> > > the wallet.
> > > The order in which these records appear is not defined.
> > >
> > > The first field in the record contains a reference to the transaction,
> > > address, input or output in the wallet.
> > > This is specified as one of the following:
> > > * Transaction ID (<tt>txid</tt>)
> > > * Address
> > > * Input (rendered as <tt>txid<index</tt>)
> > > * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)
> > >
> > > The second field contains the label applied to the reference.
> > > Exporting applications may omit records with no labels or labels of zero
> > > length.
> > > Files exported should use the <tt>.csv</tt> file extension.
> > >
> > > In order to reduce file size while retaining wide accessibility, the CSV
> > > file may be compressed using the ZIP file format, using the <tt>.zip</tt>
> > > file extension.
> > > This <tt>.zip</tt> file may optionally be encrypted using either AES-128
> > or
> > > AES-256 encryption, which is supported by numerous applications including
> > > Winzip and 7-zip.
> > > In order to ensure that weak encryption does not proliferate, importers
> > > following this standard must refuse to import <tt>.zip</tt> files
> > encrypted
> > > with the weaker Zip 2.0 standard.
> > > The textual representation of the wallet's extended public key (as
> > defined
> > > by BIP32, with an <tt>xpub</tt> header) should be used as the password.
> > >
> > > ==Importing==
> > >
> > > When importing, a naive algorithm may simply match against any reference,
> > > but it is possible to disambiguate between transactions, addresses,
> > inputs
> > > and outputs.
> > > For example in the following pseudocode:
> > > <pre>
> > >   if reference length < 64
> > >     Set address label
> > >   else if reference length == 64
> > >     Set transaction label
> > >   else if reference contains '<'
> > >     Set input label
> > >   else
> > >     Set output label
> > > </pre>
> > >
> > > Importing applications may truncate labels if necessary.
> > >
> > > ==Test Vectors==
> > >
> > > The following fragment represents a wallet label export:
> > > <pre>
> > > Reference,Label
> > >
> > c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?,Transaction
> > > 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address
> > > c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?<0,Input
> > >
> > c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?>0,Output
> > >
> > c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?:0,Output
> > > (alternative)
> > > </pre>
> > >
> > > ==Reference Implementation==
> > >
> > > TBD


From billy.tetrud at gmail.com  Sat Aug 27 22:20:31 2022
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Sat, 27 Aug 2022 17:20:31 -0500
Subject: [bitcoin-dev] BIP Proposal: Wallet Labels Export Format
In-Reply-To: <9LXjLLr8ItwnB6bLt8Ozm21J0m11yiTghdXAAzpEzVKP3l5a9jtRRzJ90SFFbPwmyAV2yuzn5Y9r1wSiEWqbt7evbx9sSLF-EG1ZS__D0yM=@clarkmoody.com>
References: <CAPR5oBNKQEPCAXcMoneGv2vLVmOLZGyxNEoZ4_=tyQT_mkAkmw@mail.gmail.com>
 <1UV4d_Y74sQ_C8l5s6_gwZOOaFcB0hWnWYWl8TJ_PFs9bQ-fb_w_CYZjZOom2JJ0CSC6-w-Xi999ocafkWa7Mkz0MzsCs2Vg91M5to2fafA=@protonmail.com>
 <CAPR5oBORj5pzuBvksCfpT8V_6D=s21TVQHyCET4+GdcxLuHPUw@mail.gmail.com>
 <9LXjLLr8ItwnB6bLt8Ozm21J0m11yiTghdXAAzpEzVKP3l5a9jtRRzJ90SFFbPwmyAV2yuzn5Y9r1wSiEWqbt7evbx9sSLF-EG1ZS__D0yM=@clarkmoody.com>
Message-ID: <CAGpPWDbni6oCUjPoJYdeGTOKw6A_ow6s-fQfVdt14mhQE+9ipQ@mail.gmail.com>

I think it might be a good idea to record something that can directly
connect the list of labels with the correct wallet. Imagine someone backs
up a bunch of label files and then forgets which wallet they apply to. Sure
you could probably look through the list of transactions, addresses, etc
and compare against those contained in the actual wallet, but this would be
sort of messy and potentially inefficient. It might be useful to include a
hash of the wallet descriptor (hash for privacy) that can be compared
against potential matching wallet descriptors.

On Fri, Aug 26, 2022 at 2:46 AM Clark Moody via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Having previously developed an export format[1] for general cryptocurrency
> transaction information, I can attest to the value of the human-readable
> CSV. I was careful to mention the RFC 4180 spec so that implementations
> could avoid the pitfalls of incorrect CSV encoding.
>
> [1]: https://github.com/harmony-csv/harmony
>
> Clark
>
> ------- Original Message -------
> On Thursday, August 25th, 2022 at 3:59 AM, Craig Raw via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Thanks for your thoughts Ryan.
>
> Without reference to the quality feedback on this proposal, I was aware
> when submitting it for review that it provides an excellent opportunity for
> bike shedding. As developers, we have all experienced frustration with data
> formats. One thing that I did not perhaps make clear enough is that this
> format is not solely intended for developers, but general users who are
> probably not well represented on this list.
>
> While doing research for this proposal I spoke to several professional
> users of Sparrow Wallet (who are not developers). They all expressed a
> desire for the format to integrate with their business processes, which are
> driven by business tools such as Excel. Labelling provides an important
> function in UTXO and address management in these scenarios, and needs to be
> accessible and manageable outside of wallet software.
>
> If this is to be achieved, it immediately rules out JSON as a data format.
> Not only is JSON limited to editing only through specific software or text
> editors, but (in the latter case) it is fragile enough that a single
> missing character can cause an entire file to fail parsing. CSV is more
> forgiving in this regard. With respect to your comments on escaping, my
> expectation would be that developers will be using a mature CSV library
> rather than handling character escaping themselves. I would rather propose
> a format that is generally usable, even if occasionally a label is escaped
> incorrectly.
>
> Finally, I'll note that CSV files are already common and uncontroversial
> in Bitcoin wallet software. Bitcoin Core, Electrum, Sparrow (and no doubt
> many others) already export addresses and/or transactions with their labels
> as CSV files. This proposal simply attempts to create a standard for
> importing and exporting all the labels in a wallet.
>
> Craig
>
> On Wed, Aug 24, 2022 at 9:01 PM <rhavar at protonmail.com> wrote:
>
>> I'd strongly suggest not using CSV. Especially for a standard. I've
>> worked with it as an interchange format many a times, and it's always been
>> a clusterfuck.
>>
>> Right off the bat, you have stuff like "The fields may be quoted, but
>> this is unnecessary as the first comma in the line will always be the
>> delimiter" which invariably leads to some implementations doing it, some
>> implementations not doing it, and others that are intolerant of the other
>> way.
>>
>> And you have also made the classic mistake of not strictly defining
>> escape rules. So everyone will pick their own (e.g. some will \, escape
>> commas, others will not cause it's quoted and escape quotes, and others
>> will assume no escaping is required since its the last column in a csv).
>>
>> Over time it morphs into its own mini-monster that introduces so much
>> pain.
>>
>> On a similar note, allowing alternatives (like: txid>index vs
>> txid:index) provides no benefit, but creates additional work for
>> implementations (who quite likely only test formats they produce) and
>> future incompatibilities.
>>
>> I know everyone loves to hate on it, but really (line-separated?) json is
>> the way to go.
>>
>> { "tx": "c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?",
>> "label": "wow, such label" }
>> { "tx: "c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b",
>> "txout": 4, "label": "omg this is so easy to parse" }
>> { "tx: "c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b",
>> "txin": 0, "label": "wow this is going to be extensible as well" }
>>
>>
>>
>>
>> -Ryan
>>
>> ------- Original Message -------
>> On Wednesday, August 24th, 2022 at 2:18 AM, Craig Raw via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> Hi all,
>>
>> I would like to propose a BIP that specifies a format for the export and
>> import of labels from a wallet. While transferring access to funds across
>> wallet applications has been made simple through standards such as BIP39,
>> wallet labels remain siloed and difficult to extract despite their value,
>> particularly in a privacy context.
>>
>> The proposed format is a simple two column CSV file, with the reference
>> to a transaction, address, input or output in the first column, and the
>> label in the second column. CSV was chosen for its wide accessibility,
>> especially to users without specific technical expertise. Similarly, the
>> CSV file may be compressed using the ZIP format, and optionally encrypted
>> using AES.
>>
>> The full text of the BIP can be found at
>> https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki
>> and also copied below.
>>
>> Feedback is appreciated.
>>
>> Thanks,
>> Craig Raw
>>
>> ---
>>
>> <pre>
>> BIP: wallet-labels
>> Layer: Applications
>> Title: Wallet Labels Export Format
>> Author: Craig Raw <craig at sparrowwallet.com>
>> Comments-Summary: No comments yet.
>> Comments-URI:
>> https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels
>> Status: Draft
>> Type: Informational
>> Created: 2022-08-23
>> License: BSD-2-Clause
>> </pre>
>>
>> ==Abstract==
>>
>> This document specifies a format for the export of labels that may be
>> attached to the transactions, addresses, input and outputs in a wallet.
>>
>> ==Copyright==
>>
>> This BIP is licensed under the BSD 2-clause license.
>>
>> ==Motivation==
>>
>> The export and import of funds across different Bitcoin wallet
>> applications is well defined through standards such as BIP39, BIP32, BIP44
>> etc.
>> These standards are well supported and allow users to move easily between
>> different wallets.
>> There is, however, no defined standard to transfer any labels the user
>> may have applied to the transactions, addresses, inputs or outputs in their
>> wallet.
>> The UTXO model that Bitcoin uses makes these labels particularly valuable
>> as they may indicate the source of funds, whether received externally or as
>> a result of change from a prior transaction.
>> In both cases, care must be taken when spending to avoid undesirable
>> leaks of private information.
>> Labels provide valuable guidance in this regard, and have even become
>> mandatory when spending in several Bitcoin wallets.
>> Allowing users to export their labels in a standardized way ensures that
>> they do not experience lock-in to a particular wallet application.
>> In addition, by using common formats, this BIP seeks to make manual or
>> bulk management of labels accessible to users without specific technical
>> expertise.
>>
>> ==Specification==
>>
>> In order to make the import and export of labels as widely accessible as
>> possible, this BIP uses the comma separated values (CSV) format, which is
>> widely supported by consumer, business, and scientific applications.
>> Although the technical specification of CSV in RFC4180 is not always
>> followed, the application of the format in this BIP is simple enough that
>> compatibility should not present a problem.
>> Moreover, the simplicity and forgiving nature of CSV (over for example
>> JSON) lends itself well to bulk label editing using spreadsheet and text
>> editing tools.
>>
>> A CSV export of labels from a wallet must be a UTF-8 encoded text file,
>> containing one record per line, with records containing two fields
>> delimited by a comma.
>> The fields may be quoted, but this is unnecessary, as the first comma in
>> the line will always be the delimiter.
>> The first line in the file is a header, and should be ignored on import.
>> Thereafter, each line represents a record that refers to a label applied
>> in the wallet.
>> The order in which these records appear is not defined.
>>
>> The first field in the record contains a reference to the transaction,
>> address, input or output in the wallet.
>> This is specified as one of the following:
>> * Transaction ID (<tt>txid</tt>)
>> * Address
>> * Input (rendered as <tt>txid<index</tt>)
>> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)
>>
>> The second field contains the label applied to the reference.
>> Exporting applications may omit records with no labels or labels of zero
>> length.
>> Files exported should use the <tt>.csv</tt> file extension.
>>
>> In order to reduce file size while retaining wide accessibility, the CSV
>> file may be compressed using the ZIP file format, using the <tt>.zip</tt>
>> file extension.
>> This <tt>.zip</tt> file may optionally be encrypted using either AES-128
>> or AES-256 encryption, which is supported by numerous applications
>> including Winzip and 7-zip.
>> In order to ensure that weak encryption does not proliferate, importers
>> following this standard must refuse to import <tt>.zip</tt> files encrypted
>> with the weaker Zip 2.0 standard.
>> The textual representation of the wallet's extended public key (as
>> defined by BIP32, with an <tt>xpub</tt> header) should be used as the
>> password.
>>
>> ==Importing==
>>
>> When importing, a naive algorithm may simply match against any reference,
>> but it is possible to disambiguate between transactions, addresses, inputs
>> and outputs.
>> For example in the following pseudocode:
>> <pre>
>> if reference length < 64
>> Set address label
>> else if reference length == 64
>> Set transaction label
>> else if reference contains '<'
>> Set input label
>> else
>> Set output label
>> </pre>
>>
>> Importing applications may truncate labels if necessary.
>>
>> ==Test Vectors==
>>
>> The following fragment represents a wallet label export:
>> <pre>
>> Reference,Label
>>
>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?,Transaction
>> 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address
>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?<0,Input
>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?>0,Output
>> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?:0,Output
>> (alternative)
>> </pre>
>>
>> ==Reference Implementation==
>>
>> TBD
>>
>>
>>
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220827/d9a86c1b/attachment-0001.html>

From craigraw at gmail.com  Mon Aug 29 11:25:13 2022
From: craigraw at gmail.com (Craig Raw)
Date: Mon, 29 Aug 2022 13:25:13 +0200
Subject: [bitcoin-dev] BIP Proposal: Wallet Labels Export Format
In-Reply-To: <20220824190958.gklg3riadci3ttgm@artanis>
References: <mailman.9.1661342403.3868.bitcoin-dev@lists.linuxfoundation.org>
 <20220824190958.gklg3riadci3ttgm@artanis>
Message-ID: <CAPR5oBPER9-WHdpzJ3MW2hjPJxj3ZuEouFUsu89Lb=8m5h2t-w@mail.gmail.com>

Thanks for your feedback @Ali.

I am attempting to achieve two goals with this proposal, primarily for the
benefit of wallet users:

Goal #1. Transfer labels between different wallet implementations
Goal #2. Manage labels in applications outside of Bitcoin wallets (such as
Excel)

Much of the feedback so far has indicated the tension between these two
goals - it may be that it is too difficult to achieve both, in which case
Goal #1 is the most important. That said, I think further exploration is
still necessary before abandoning Goal #2, because removing it would
significantly reduce the value of this proposal and mean users need to rely
on application-specific workarounds.

> it is important that a version byte is defined
If Goal #2 is to be achieved it's difficult to mandate this, particularly
if one requires bit flags to be set. Should an importing wallet fail to
import if the version byte is not present, even if all the data is
otherwise correct? Although it is difficult to know in advance how a format
may be extended, it is certainly possible to extend this format with
additional types where the nature of hashes serve as unique identifiers
(more on this below).

 > Don't mandate the file extension... There is no way to enforce this on a
BIP level.
I'm not quite sure what you mean here - for example BIP174, which is widely
used, states "Binary PSBT files should use the .psbt file extension." Also,
this contradicts Goal #2 - Excel and Numbers register as handlers for .csv,
and so make it clear that the file is editable outside of a wallet.

> ZIP does not have good performance or compression ratio
Indeed, but it is very widely available. That said, gzip is supported
widely too these days. Unfortunately, gzip does not offer encryption (see
next answer).

> ZIP is an archiving format, that happens to have its own compression
format.
I agree this is not ideal. My main reason for choosing ZIP was that it
supports encryption. It seems to me that without considering encryption, an
application must create label export files that allow privacy-sensitive
wallet information to be readable in plain text. Being able to transfer
labels without risking privacy is IMO valuable. I considered other
encryption formats such as PGP, but they are much more niche and so again
contradict Goal #2.

> I don't see the benefit of encrypting addresses and labels together...
additionally, the password you propose is insecure - anybody with access to
the wallet can unlock it
I'm not sure I understand your question, but both wallet addresses and
wallet labels contain privacy-sensitive information that should be
protected. Wrt to the password, there is actually a more fundamental
problem with using the wallet xpub - there is no equivalent for multisig
wallets. For this reason I'll remove that requirement in future iterations.

> Why the need for input and output formats? There is no difference between
them on the wallet level, because they are always identified with a txid
and output index.
The input refers to the txid and the input index (in the set of vin), so
the difference is the context in which they are displayed. A wallet will
not necessarily store the spent outputs for a funding transaction
containing a UTXO coming into the wallet, but it will contain references to
the inputs as part of that transaction.

> Another important point is that practically nobody labels inputs or
outputs
To the contrary, UTXOs are very frequently labelled, as they link and
reveal information when spent. Inputs are much less frequently labelled,
but there is no particular reason to exclude them.

> there is a net benefit for the addresses to be exported in ascending order
Indeed, but it makes achieving Goal #2 much more difficult for marginal
benefit.

> It's better to mandate that they should always be double-quoted, since
only wallets will generate label exports anyway.
Rather I think it's better to mandate RFC4180 is followed, as per
recommendations in other feedback.

> The importing code is too naive... it should utilize a dedicate item type
field that unambiguously identifies the item
It's unclear to me what you mean here. As I've indicated it is currently
possible to disambiguate between addresses/transactions/etc without the
need for a 3rd column, but in any case the hash functions used ensure that
labels will not be associated incorrectly. Even in the unlikely event of
some future address type being indistinguishable from a txid, it will
simply not match any txids in the wallet.

Craig



On Wed, Aug 24, 2022 at 9:10 PM Ali Sherief <ali at notatether.com> wrote:

> Hi Craig,
>
> This a really good proposal. I studied your BIP and I have some feedback
> on some parts of it.
>
> > The first line in the file is a header, and should be ignored on import.
>
> From past experience and lessons, most notably BIP39, it is important that
> a version byte is defined somewhere in case someone wants to extend it in
> the future, currently there is no version byte which someone can increment
> if somebody wants to extend it. In the unique case of CSV files, you should
> make the header line mandatory (I see you have already implied this, but
> you should make it explicit in the BIP), but instead of a line with columns
> in it, I suggest instead of Reference,Label, you make the format like this:
>
> BIP-wallet-labels,<version>
>
> Since there are two columns per record, this works out nicely. The first
> column can be the name of the BIP - BIPxxxx where the x's are numbers, and
> the second column can be an unsigned 32-bit integer (most significant 8
> bits reserved for version, the remaining for flags, or perhaps the entirety
> for version - but I recommend leaving at least some bits for flags, even if
> they all end up being just "reserved").
>
> You should make importing fail if the header line is not exactly as
> specified - or appropriate, should you decide a different format for the
> header.
>
> > Files exported should use the <tt>.csv</tt> file extension.
> Don't mandate the file extension (read below for why):
>
> > In order to reduce file size while retaining wide accessibility, the CSV
> > file may be compressed using the ZIP file format, using the <tt>.zip</tt>
> > file extension.
> I see three problems with this. The first is more important than the later
> two because it makes them moot points, but I'll mention them anyway so you
> get a background of the situation:
> - The BIP is trying to specify in what file format the export format can
> be written in onto the filesystem. There is no way to enforce this on a BIP
> level (besides, Unix operating systems don't even consider the file
> extension, they use its mimetype). Also specifying this in the BIP will
> prevent modular "Layer 2" protocols and schemes from encoding the Export
> labels into another format - for example Base64 or with their own
> compression algorithm.
>
> Now for the two "moot problems":
> - ZIP does not have good performance or compression ratio, there are
> better algorithms out there like gzip (which also happens to be more
> ubiquitous; nearly all websites are serving HTML compressed with gzip
> compression).
> - ZIP is an archiving format, that happens to have its own compression
> format. Archiving format parsers can have serious vulnerabilities in their
> implementation that can allow malware to swipe private keys and passwords,
> since the primary target for this BIP is wallets. For example, there was
> Zip Slip[1] in 2018, which allows for remote code execution. So the malware
> can even hide in memory until private keys or passwords are written to
> memory, then send them accros the network. Assuming it's targeting a
> specific wallet software it's not hard to carry out at all.
>
> There's two solutions for all this:
> 1. The duck-tape solution: Use some compression algorithm like gzip
> instead of ZIP archive format.
> 2. The "throw it out and buy a new one" solution: Get rid of the optional
> compression specs altogether, because users are responsible for supplying
> the export labels in the first place, so all the compression stuff is
> redundant and should be left up to the user use if they desire to.
>
> I prefer the second solution because it hits the nail at the problem
> directly instead of putting duck tape on it like the first one.
>
> > This <tt>.zip</tt> file may optionally be encrypted using either AES-128
> or
> > AES-256 encryption, which is supported by numerous applications including
> > Winzip and 7-zip.
> > The textual representation of the wallet's extended public key (as
> defined
> > by BIP32, with an <tt>xpub</tt> header) should be used as the password.
> Not specific to AES, but I don't see the benefit of encrypting addresses
> and labels together. Can you please elaborate why this would be desireable?
>
> Like I said though, it's better to leave it up to users to decide how to
> store their exports, since BIPs can't enforce that anyway (additionally,
> the password you propose is insecure - anybody with access to the wallet
> can unlock it, which is not desireable to some users who want their own
> security).
>
> > * Transaction ID (<tt>txid</tt>)
> > * Address
> > * Input (rendered as <tt>txid<index</tt>)
> > * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)
> Why the need for input and output formats? There is no difference between
> them on the wallet level, because they are always identified with a txid
> and output index. To distinguish between them and hence write them with the
> correct format would require a UTXO set and thus access to a full node,
> otherwise the CSV cannot be verified to be completely well-formed.
>
> Another important point is that practically nobody labels inputs or
> outputs because most people do not know that those things even exist, and
> the rest don't bother to label them.
>
> But the biggest downside to including them is related to the problem of
> information leaking which you make reference to here:
> > In both cases, care must be taken when spending to avoid undesirable
> leaks
> > of private information.
> A CSV dump that has inputs/outputs and addresses mixed together can infer
> the owner of all those items. In fact, A CVS label dump is basically a
> personal information store so everything in it can be correlated as coming
> from the same wallet, so it's important that unnecessary types are kept out
> of the format. People are known to leave files lying around on their
> computer that they don't need anymore, so these files can find their way
> via telemetry to surveillence entities. While we can't specify what users
> can do with their exports, we can control the information leak by
> preventing certain types of items that we know most users will never use
> from being exported in the first place.
>
> > The order in which these records appear is not defined.
> Again, since the primary use case for this BIP is wallets, which likely
> use heirarchical derivation schemes like BIP44, there is a net benefit for
> the addresses to be exported in ascending order of their `address_type`. It
> means that wallets can import them in O(n) time as opposed to O(n^2) time
> spent serially checking in which index the address appears at. Of course,
> this implies that all addresses up to a certain index have to be exported
> into the CSV as well, but most wallets I know of like Core, Electrum
> already store addresses like that.
>
> Also if you do this, you will need to group all the transaction records
> before the address records or vice versa - you can use lexigraphical
> sorting if you want (ie. Addresses before Transactions). The benefit of
> this separation of parts is that wallets can split the imported address
> records from the transaction records internally, and feed them to separate
> functions which set these labels internally.
>
> If you decide on doing it this way, then you need a 3rd column to identify
> the item type, and also you should quote the label (see below). I strongly
> recommend using numbers for identification as opposed to character strings,
> so you don't have to worry about localization or character case issues.
> There is always one unique number, but there could be multiple strings that
> reference the same type. This will complicate importing functions.
>
> If you insist on include Input and Output types then they can both be
> specified as <txid>:<index> if you do this change. They won't be used to
> determine the type anyway.
>
> > The fields may be quoted, but this is unnecessary, as the first comma in
> > the line will always be the delimiter.
> Don't implement it like that, because that will break CSV parsers which
> expect a fixed amount of rows in each record (2 in the header, and some
> rows have >2 rows). It's better to mandate that they should always be
> double-quoted, since only wallets will generate label exports anyway. If
> you plan to use headers then the 3rd column can be blank for it (or you can
> split the version and flags from each other).
>
> > ==Importing==
> >
> > When importing, a naive algorithm may simply match against any reference,
> > but it is possible to disambiguate between transactions, addresses,
> inputs
> > and outputs.
> > For example in the following pseudocode:
> > <pre>
> >   if reference length < 64
> >     Set address label
> >   else if reference length == 64
> >     Set transaction label
> >   else if reference contains '<'
> >     Set input label
> >   else
> >     Set output label
> > </pre>
> The importing code is too naive and in its current form will prevent the
> BIP from getting a number. It is perhaps the single most important part of
> a BIP. When implementing an importer, it should utilize a dedicate item
> type field that unambiguously identifies the item. So the naive importer is
> not good, you need use a 3rd column for that like I explained above, so
> that the importer becomes robust.
>
> In summary (exclamation marks indicate severity - one means low, two means
> medium, and three means high):
>
> 1. Convert the header into a version line with optional flags, otherwise
> nobody can extend this format without compatibility issues (!)
> 2. Get rid of the specs related to file compression (!!!)
> 3. Add a 3rd column for item type (address, transaction etc.) preferably
> as numeric constants and grouping items of one type after items of another
> type, or if you insist on strings, then only recognize their Titlecase
> ASCII versions <spreadsheet software like Excel always tries to titlecase
> the words> (!!)
> 4. Require double quotes around the label (or single quotes if you prefer,
> as long as spreadsheet software doesn't choke on them) (!!)
> 5. Require sorting the records according to the order they are stored in
> the wallet implementation. (!)
> 6. Consider getting rid of Input and Output item types. (!)
> 7. And last and most importantly, please write a more robust importer
> algorithm in the example given by the BIP, because code in BIPs are
> frequently used as references for software. (!!!)
>
> I hope you will consider these points in future revisions of your BIP.
>
> - Ali
>
> [1] https://github.com/snyk/zip-slip-vulnerability
>
> On Wed, 24 Aug 2022 11:18:43 +0200, craigraw at gmail.com wrote:
> > Hi all,
> >
> > I would like to propose a BIP that specifies a format for the export and
> > import of labels from a wallet. While transferring access to funds across
> > wallet applications has been made simple through standards such as BIP39,
> > wallet labels remain siloed and difficult to extract despite their value,
> > particularly in a privacy context.
> >
> > The proposed format is a simple two column CSV file, with the reference
> to
> > a transaction, address, input or output in the first column, and the
> label
> > in the second column. CSV was chosen for its wide accessibility,
> especially
> > to users without specific technical expertise. Similarly, the CSV file
> may
> > be compressed using the ZIP format, and optionally encrypted using AES.
> >
> > The full text of the BIP can be found at
> > https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki
> > and also copied below.
> >
> > Feedback is appreciated.
> >
> > Thanks,
> > Craig Raw
> >
> > ---
> >
> > <pre>
> >   BIP: wallet-labels
> >   Layer: Applications
> >   Title: Wallet Labels Export Format
> >   Author: Craig Raw <craig at sparrowwallet.com>
> >   Comments-Summary: No comments yet.
> >   Comments-URI:
> > https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels
> >   Status: Draft
> >   Type: Informational
> >   Created: 2022-08-23
> >   License: BSD-2-Clause
> > </pre>
> >
> > ==Abstract==
> >
> > This document specifies a format for the export of labels that may be
> > attached to the transactions, addresses, input and outputs in a wallet.
> >
> > ==Copyright==
> >
> > This BIP is licensed under the BSD 2-clause license.
> >
> > ==Motivation==
> >
> > The export and import of funds across different Bitcoin wallet
> applications
> > is well defined through standards such as BIP39, BIP32, BIP44 etc.
> > These standards are well supported and allow users to move easily between
> > different wallets.
> > There is, however, no defined standard to transfer any labels the user
> may
> > have applied to the transactions, addresses, inputs or outputs in their
> > wallet.
> > The UTXO model that Bitcoin uses makes these labels particularly valuable
> > as they may indicate the source of funds, whether received externally or
> as
> > a result of change from a prior transaction.
> > In both cases, care must be taken when spending to avoid undesirable
> leaks
> > of private information.
> > Labels provide valuable guidance in this regard, and have even become
> > mandatory when spending in several Bitcoin wallets.
> > Allowing users to export their labels in a standardized way ensures that
> > they do not experience lock-in to a particular wallet application.
> > In addition, by using common formats, this BIP seeks to make manual or
> bulk
> > management of labels accessible to users without specific technical
> > expertise.
> >
> > ==Specification==
> >
> > In order to make the import and export of labels as widely accessible as
> > possible, this BIP uses the comma separated values (CSV) format, which is
> > widely supported by consumer, business, and scientific applications.
> > Although the technical specification of CSV in RFC4180 is not always
> > followed, the application of the format in this BIP is simple enough that
> > compatibility should not present a problem.
> > Moreover, the simplicity and forgiving nature of CSV (over for example
> > JSON) lends itself well to bulk label editing using spreadsheet and text
> > editing tools.
> >
> > A CSV export of labels from a wallet must be a UTF-8 encoded text file,
> > containing one record per line, with records containing two fields
> > delimited by a comma.
> > The fields may be quoted, but this is unnecessary, as the first comma in
> > the line will always be the delimiter.
> > The first line in the file is a header, and should be ignored on import.
> > Thereafter, each line represents a record that refers to a label applied
> in
> > the wallet.
> > The order in which these records appear is not defined.
> >
> > The first field in the record contains a reference to the transaction,
> > address, input or output in the wallet.
> > This is specified as one of the following:
> > * Transaction ID (<tt>txid</tt>)
> > * Address
> > * Input (rendered as <tt>txid<index</tt>)
> > * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)
> >
> > The second field contains the label applied to the reference.
> > Exporting applications may omit records with no labels or labels of zero
> > length.
> > Files exported should use the <tt>.csv</tt> file extension.
> >
> > In order to reduce file size while retaining wide accessibility, the CSV
> > file may be compressed using the ZIP file format, using the <tt>.zip</tt>
> > file extension.
> > This <tt>.zip</tt> file may optionally be encrypted using either AES-128
> or
> > AES-256 encryption, which is supported by numerous applications including
> > Winzip and 7-zip.
> > In order to ensure that weak encryption does not proliferate, importers
> > following this standard must refuse to import <tt>.zip</tt> files
> encrypted
> > with the weaker Zip 2.0 standard.
> > The textual representation of the wallet's extended public key (as
> defined
> > by BIP32, with an <tt>xpub</tt> header) should be used as the password.
> >
> > ==Importing==
> >
> > When importing, a naive algorithm may simply match against any reference,
> > but it is possible to disambiguate between transactions, addresses,
> inputs
> > and outputs.
> > For example in the following pseudocode:
> > <pre>
> >   if reference length < 64
> >     Set address label
> >   else if reference length == 64
> >     Set transaction label
> >   else if reference contains '<'
> >     Set input label
> >   else
> >     Set output label
> > </pre>
> >
> > Importing applications may truncate labels if necessary.
> >
> > ==Test Vectors==
> >
> > The following fragment represents a wallet label export:
> > <pre>
> > Reference,Label
> >
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?,Transaction
> > 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address
> > c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?<0,Input
> >
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?>0,Output
> >
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?:0,Output
> > (alternative)
> > </pre>
> >
> > ==Reference Implementation==
> >
> > TBD
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220829/cefd5c3b/attachment-0001.html>

From ali at notatether.com  Mon Aug 29 15:46:09 2022
From: ali at notatether.com (Ali Sherief)
Date: Mon, 29 Aug 2022 15:46:09 +0000
Subject: [bitcoin-dev] BIP Proposal: Wallet Labels Export Format
In-Reply-To: <mailman.13106.1661772392.956.bitcoin-dev@lists.linuxfoundation.org>
References: <mailman.13106.1661772392.956.bitcoin-dev@lists.linuxfoundation.org>
Message-ID: <20220829154603.fec7mlm526vdfo2i@artanis>

> I am attempting to achieve two goals with this proposal, primarily for the
> benefit of wallet users:
>
> Goal #1. Transfer labels between different wallet implementations
> Goal #2. Manage labels in applications outside of Bitcoin wallets (such as
> Excel)
>
> Much of the feedback so far has indicated the tension between these two
> goals - it may be that it is too difficult to achieve both, in which case
> Goal #1 is the most important. That said, I think further exploration is
> still necessary before abandoning Goal #2, because removing it would
> significantly reduce the value of this proposal and mean users need to rely
> on application-specific workarounds.
In my opinion, it would be best if these two goals were split into two separate BIPs where the BIP for Goal 2 requires Goal 1's BIP, gut Goal 1's BIP is independent. This is because wallet software and business spreadsheet processes have different and in some cases divergent needs.

A BIP shouldn't try to address too many things at once, that's why technologies like Segwit and Taproot were split into four or five BIPs each.

>  > Don't mandate the file extension... There is no way to enforce this on a
> BIP level.
> I'm not quite sure what you mean here - for example BIP174, which is widely
> used, states "Binary PSBT files should use the .psbt file extension." Also,
> this contradicts Goal #2 - Excel and Numbers register as handlers for .csv,
> and so make it clear that the file is editable outside of a wallet.
BIP174's assignment is a specification but not a hard requirement, becase if you have a file whose extension implies one type, but its MIME type (obtained from inspecting the file contents) indicates another type, then the extension should be disregarded by the parser.

I am aware that business processes are mostly CSV file oriented so you can make a statement akin to BIP174 in the Goal 2 BIP, that expects the medium of exchange to be in files ending in .csv. I wouldn't mind if you require .csv file extension in a BIP for Goal 2. But such a statement is not appropriate in the Goal 1 BIP which is only concerned with the wallet label format itself.

> > ZIP does not have good performance or compression ratio
> Indeed, but it is very widely available. That said, gzip is supported
> widely too these days. Unfortunately, gzip does not offer encryption (see
> next answer).
>
> > ZIP is an archiving format, that happens to have its own compression
> format.
> I agree this is not ideal. My main reason for choosing ZIP was that it
> supports encryption. It seems to me that without considering encryption, an
> application must create label export files that allow privacy-sensitive
> wallet information to be readable in plain text. Being able to transfer
> labels without risking privacy is IMO valuable. I considered other
> encryption formats such as PGP, but they are much more niche and so again
> contradict Goal #2.
Both of these look like parts of the spec that should be in the Goal 2 BIP. Because Goal 1, which is only concerned with wallet label importing, does not need to interact with compression or encryption.

I don't mind if you make Goal 2 BIP utilize ZIP compression with optional encryption, it's just that specifying this in the same place in the Goal 1 BIP stuff forces wallets to check for that stuff too to be compliant. It's important to make compliance as easy as possible.

Regardless, I still believe that making the xpub the ZIP password is a bad design, because some wallets that are made from a random list of private keys do not have xpubs at all. If the purpose of a password is to make label sharing between two parties secure, then why not simply let them agree on a password for their own use?

> > I don't see the benefit of encrypting addresses and labels together...
> additionally, the password you propose is insecure - anybody with access to
> the wallet can unlock it
> I'm not sure I understand your question, but both wallet addresses and
> wallet labels contain privacy-sensitive information that should be
> protected. Wrt to the password, there is actually a more fundamental
> problem with using the wallet xpub - there is no equivalent for multisig
> wallets. For this reason I'll remove that requirement in future iterations.
Let me explain.

Before you partitioned the BIP into two goals, I was under the impression that wallets would have to read an encrypted export file, which seemed very overkill to me (for one, all wallets would now need to bundle a ZIP or AES dependency module with their program).

But now I see why a password and encryption would be desireable for Goal 2 BIP applications. Like I said though, Goal 1 BIP applications (i.e. wallets) do not need any of that.

> > Why the need for input and output formats? There is no difference between
> them on the wallet level, because they are always identified with a txid
> and output index.
> The input refers to the txid and the input index (in the set of vin), so
> the difference is the context in which they are displayed. A wallet will
> not necessarily store the spent outputs for a funding transaction
> containing a UTXO coming into the wallet, but it will contain references to
> the inputs as part of that transaction.
>
> > Another important point is that practically nobody labels inputs or
> outputs
> To the contrary, UTXOs are very frequently labelled, as they link and
> reveal information when spent. Inputs are much less frequently labelled,
> but there is no particular reason to exclude them.
>
> > there is a net benefit for the addresses to be exported in ascending order
> Indeed, but it makes achieving Goal #2 much more difficult for marginal
> benefit.
Fair enough.

> > It's better to mandate that they should always be double-quoted, since
> only wallets will generate label exports anyway.
> Rather I think it's better to mandate RFC4180 is followed, as per
> recommendations in other feedback.
I agree with this.

> > The importing code is too naive... it should utilize a dedicate item type
> field that unambiguously identifies the item
> It's unclear to me what you mean here. As I've indicated it is currently
> possible to disambiguate between addresses/transactions/etc without the
> need for a 3rd column, but in any case the hash functions used ensure that
> labels will not be associated incorrectly. Even in the unlikely event of
> some future address type being indistinguishable from a txid, it will
> simply not match any txids in the wallet.
You already have a custom format proposed here, but this importer relies on heuristics of the data like how long it is, what characters it has, and so on. It is better for the importer to have the same kind of conditions.

You can make parsing vastly simpler by prefixing the items with some text. Similar to how we have "bitcoin:" for indicating a bitcoin address, you can have "address:", "transaction:", "input:", and "output:" at the beginning of each entity.

This has a major advantage: You can add new formats in a backward-compatible way without breaking parsers, since the parsers never depended on the text heuristics in the first place, therefore you don't have to clutter the BIP(s) with even more test vectors for these cases. You won't even need a version byte, since the only revision that will ever be made (that doesn't modify any existing format to preserve backward-compatibility) are adding new formats.

Take a look at your sample:

> > >   if reference length < 64
> > >     Set address label
> > >   else if reference length == 64
> > >     Set transaction label
> > >   else if reference contains '<'
> > >     Set input label
> > >   else
> > >     Set output label

versus how mine would look:

> if reference.startsWith("address:")
>   Set address label
> else if reference.startsWith("transaction:")
>   Set transaction label
> else if reference.startsWith("input:")
>   Set input label
> else if reference.startsWith("output:")
>   Set output label
> # No else case: allows for future extensions

See how simpler it is to understand?

The truth is, a format has to be defined that developers find it easy to implement. If the implementation is such that a developer could misunderstand at a first glance, they will implement it wrongly, creating bugs.

Looking at your sample, a developer would think as such: "anything less than 64 chars is an address, anything 64 chars long is a transaction, anything that contains a '<' is an input (and is also greater than 64 chars), and everything else is an output (>64 chars and has no  '<')."

In light of all this, is it not much easier to simply introduce a prefix at the beginning of each entity? It has a negligible space cost. The "else" case can be ommitted hypothetically (although that's not strictly necessary), so developers can just add more "else if"'s when a BIP revision is made.

A good way to see if a reference implementation has a good design is by asking yourself the following question: Imagine you are committing your reference into Bitcoin Core. Based on the code quality, would a pull request for that be merged, or not?


So to summarize, I strongly suggest you do the following:
- Split the BIP into two, one defines the CSV format for label import/export between wallets, and the other defines workflows for distributing and sharing label CSVs in a universal and safe way.
- Add prefixes before each entity, so in other words: "adddress:bc1q23456...", "transaction:432abd874d...", "input:432abd874d...<DELIMITER>1", "output:432abd874d...<DELIMITER>1". Replace <DELIMITER> with any delimiter you want, it doesn't have to be consistent. This will make it much simpler to implement an importer, without applications doing any of the hacks that RHavar wrote about (IMO this is what people mean when they say that implementing a CSV importer will be complex work).

- Ali

On Mon, Aug 29, 2022 at 11:26:32AM +0000, craigraw at gmail.com wrote:
> Thanks for your feedback @Ali.
>
>
> > it is important that a version byte is defined
> If Goal #2 is to be achieved it's difficult to mandate this, particularly
> if one requires bit flags to be set. Should an importing wallet fail to
> import if the version byte is not present, even if all the data is
> otherwise correct? Although it is difficult to know in advance how a format
> may be extended, it is certainly possible to extend this format with
> additional types where the nature of hashes serve as unique identifiers
> (more on this below).
>
>  > Don't mandate the file extension... There is no way to enforce this on a
> BIP level.
> I'm not quite sure what you mean here - for example BIP174, which is widely
> used, states "Binary PSBT files should use the .psbt file extension." Also,
> this contradicts Goal #2 - Excel and Numbers register as handlers for .csv,
> and so make it clear that the file is editable outside of a wallet.
>
> > ZIP does not have good performance or compression ratio
> Indeed, but it is very widely available. That said, gzip is supported
> widely too these days. Unfortunately, gzip does not offer encryption (see
> next answer).
>
> > ZIP is an archiving format, that happens to have its own compression
> format.
> I agree this is not ideal. My main reason for choosing ZIP was that it
> supports encryption. It seems to me that without considering encryption, an
> application must create label export files that allow privacy-sensitive
> wallet information to be readable in plain text. Being able to transfer
> labels without risking privacy is IMO valuable. I considered other
> encryption formats such as PGP, but they are much more niche and so again
> contradict Goal #2.
>
> > I don't see the benefit of encrypting addresses and labels together...
> additionally, the password you propose is insecure - anybody with access to
> the wallet can unlock it
> I'm not sure I understand your question, but both wallet addresses and
> wallet labels contain privacy-sensitive information that should be
> protected. Wrt to the password, there is actually a more fundamental
> problem with using the wallet xpub - there is no equivalent for multisig
> wallets. For this reason I'll remove that requirement in future iterations.
>
> > Why the need for input and output formats? There is no difference between
> them on the wallet level, because they are always identified with a txid
> and output index.
> The input refers to the txid and the input index (in the set of vin), so
> the difference is the context in which they are displayed. A wallet will
> not necessarily store the spent outputs for a funding transaction
> containing a UTXO coming into the wallet, but it will contain references to
> the inputs as part of that transaction.
>
> > Another important point is that practically nobody labels inputs or
> outputs
> To the contrary, UTXOs are very frequently labelled, as they link and
> reveal information when spent. Inputs are much less frequently labelled,
> but there is no particular reason to exclude them.
>
> > there is a net benefit for the addresses to be exported in ascending order
> Indeed, but it makes achieving Goal #2 much more difficult for marginal
> benefit.
>
> > It's better to mandate that they should always be double-quoted, since
> only wallets will generate label exports anyway.
> Rather I think it's better to mandate RFC4180 is followed, as per
> recommendations in other feedback.
>
> > The importing code is too naive... it should utilize a dedicate item type
> field that unambiguously identifies the item
> It's unclear to me what you mean here. As I've indicated it is currently
> possible to disambiguate between addresses/transactions/etc without the
> need for a 3rd column, but in any case the hash functions used ensure that
> labels will not be associated incorrectly. Even in the unlikely event of
> some future address type being indistinguishable from a txid, it will
> simply not match any txids in the wallet.
>
> Craig
>
>
>
> On Wed, Aug 24, 2022 at 9:10 PM Ali Sherief <ali at notatether.com> wrote:
>
> > Hi Craig,
> >
> > This a really good proposal. I studied your BIP and I have some feedback
> > on some parts of it.
> >
> > > The first line in the file is a header, and should be ignored on import.
> >
> > From past experience and lessons, most notably BIP39, it is important that
> > a version byte is defined somewhere in case someone wants to extend it in
> > the future, currently there is no version byte which someone can increment
> > if somebody wants to extend it. In the unique case of CSV files, you should
> > make the header line mandatory (I see you have already implied this, but
> > you should make it explicit in the BIP), but instead of a line with columns
> > in it, I suggest instead of Reference,Label, you make the format like this:
> >
> > BIP-wallet-labels,<version>
> >
> > Since there are two columns per record, this works out nicely. The first
> > column can be the name of the BIP - BIPxxxx where the x's are numbers, and
> > the second column can be an unsigned 32-bit integer (most significant 8
> > bits reserved for version, the remaining for flags, or perhaps the entirety
> > for version - but I recommend leaving at least some bits for flags, even if
> > they all end up being just "reserved").
> >
> > You should make importing fail if the header line is not exactly as
> > specified - or appropriate, should you decide a different format for the
> > header.
> >
> > > Files exported should use the <tt>.csv</tt> file extension.
> > Don't mandate the file extension (read below for why):
> >
> > > In order to reduce file size while retaining wide accessibility, the CSV
> > > file may be compressed using the ZIP file format, using the <tt>.zip</tt>
> > > file extension.
> > I see three problems with this. The first is more important than the later
> > two because it makes them moot points, but I'll mention them anyway so you
> > get a background of the situation:
> > - The BIP is trying to specify in what file format the export format can
> > be written in onto the filesystem. There is no way to enforce this on a BIP
> > level (besides, Unix operating systems don't even consider the file
> > extension, they use its mimetype). Also specifying this in the BIP will
> > prevent modular "Layer 2" protocols and schemes from encoding the Export
> > labels into another format - for example Base64 or with their own
> > compression algorithm.
> >
> > Now for the two "moot problems":
> > - ZIP does not have good performance or compression ratio, there are
> > better algorithms out there like gzip (which also happens to be more
> > ubiquitous; nearly all websites are serving HTML compressed with gzip
> > compression).
> > - ZIP is an archiving format, that happens to have its own compression
> > format. Archiving format parsers can have serious vulnerabilities in their
> > implementation that can allow malware to swipe private keys and passwords,
> > since the primary target for this BIP is wallets. For example, there was
> > Zip Slip[1] in 2018, which allows for remote code execution. So the malware
> > can even hide in memory until private keys or passwords are written to
> > memory, then send them accros the network. Assuming it's targeting a
> > specific wallet software it's not hard to carry out at all.
> >
> > There's two solutions for all this:
> > 1. The duck-tape solution: Use some compression algorithm like gzip
> > instead of ZIP archive format.
> > 2. The "throw it out and buy a new one" solution: Get rid of the optional
> > compression specs altogether, because users are responsible for supplying
> > the export labels in the first place, so all the compression stuff is
> > redundant and should be left up to the user use if they desire to.
> >
> > I prefer the second solution because it hits the nail at the problem
> > directly instead of putting duck tape on it like the first one.
> >
> > > This <tt>.zip</tt> file may optionally be encrypted using either AES-128
> > or
> > > AES-256 encryption, which is supported by numerous applications including
> > > Winzip and 7-zip.
> > > The textual representation of the wallet's extended public key (as
> > defined
> > > by BIP32, with an <tt>xpub</tt> header) should be used as the password.
> > Not specific to AES, but I don't see the benefit of encrypting addresses
> > and labels together. Can you please elaborate why this would be desireable?
> >
> > Like I said though, it's better to leave it up to users to decide how to
> > store their exports, since BIPs can't enforce that anyway (additionally,
> > the password you propose is insecure - anybody with access to the wallet
> > can unlock it, which is not desireable to some users who want their own
> > security).
> >
> > > * Transaction ID (<tt>txid</tt>)
> > > * Address
> > > * Input (rendered as <tt>txid<index</tt>)
> > > * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)
> > Why the need for input and output formats? There is no difference between
> > them on the wallet level, because they are always identified with a txid
> > and output index. To distinguish between them and hence write them with the
> > correct format would require a UTXO set and thus access to a full node,
> > otherwise the CSV cannot be verified to be completely well-formed.
> >
> > Another important point is that practically nobody labels inputs or
> > outputs because most people do not know that those things even exist, and
> > the rest don't bother to label them.
> >
> > But the biggest downside to including them is related to the problem of
> > information leaking which you make reference to here:
> > > In both cases, care must be taken when spending to avoid undesirable
> > leaks
> > > of private information.
> > A CSV dump that has inputs/outputs and addresses mixed together can infer
> > the owner of all those items. In fact, A CVS label dump is basically a
> > personal information store so everything in it can be correlated as coming
> > from the same wallet, so it's important that unnecessary types are kept out
> > of the format. People are known to leave files lying around on their
> > computer that they don't need anymore, so these files can find their way
> > via telemetry to surveillence entities. While we can't specify what users
> > can do with their exports, we can control the information leak by
> > preventing certain types of items that we know most users will never use
> > from being exported in the first place.
> >
> > > The order in which these records appear is not defined.
> > Again, since the primary use case for this BIP is wallets, which likely
> > use heirarchical derivation schemes like BIP44, there is a net benefit for
> > the addresses to be exported in ascending order of their `address_type`. It
> > means that wallets can import them in O(n) time as opposed to O(n^2) time
> > spent serially checking in which index the address appears at. Of course,
> > this implies that all addresses up to a certain index have to be exported
> > into the CSV as well, but most wallets I know of like Core, Electrum
> > already store addresses like that.
> >
> > Also if you do this, you will need to group all the transaction records
> > before the address records or vice versa - you can use lexigraphical
> > sorting if you want (ie. Addresses before Transactions). The benefit of
> > this separation of parts is that wallets can split the imported address
> > records from the transaction records internally, and feed them to separate
> > functions which set these labels internally.
> >
> > If you decide on doing it this way, then you need a 3rd column to identify
> > the item type, and also you should quote the label (see below). I strongly
> > recommend using numbers for identification as opposed to character strings,
> > so you don't have to worry about localization or character case issues.
> > There is always one unique number, but there could be multiple strings that
> > reference the same type. This will complicate importing functions.
> >
> > If you insist on include Input and Output types then they can both be
> > specified as <txid>:<index> if you do this change. They won't be used to
> > determine the type anyway.
> >
> > > The fields may be quoted, but this is unnecessary, as the first comma in
> > > the line will always be the delimiter.
> > Don't implement it like that, because that will break CSV parsers which
> > expect a fixed amount of rows in each record (2 in the header, and some
> > rows have >2 rows). It's better to mandate that they should always be
> > double-quoted, since only wallets will generate label exports anyway. If
> > you plan to use headers then the 3rd column can be blank for it (or you can
> > split the version and flags from each other).
> >
> > > ==Importing==
> > >
> > > When importing, a naive algorithm may simply match against any reference,
> > > but it is possible to disambiguate between transactions, addresses,
> > inputs
> > > and outputs.
> > > For example in the following pseudocode:
> > > <pre>
> > >   if reference length < 64
> > >     Set address label
> > >   else if reference length == 64
> > >     Set transaction label
> > >   else if reference contains '<'
> > >     Set input label
> > >   else
> > >     Set output label
> > > </pre>
> > The importing code is too naive and in its current form will prevent the
> > BIP from getting a number. It is perhaps the single most important part of
> > a BIP. When implementing an importer, it should utilize a dedicate item
> > type field that unambiguously identifies the item. So the naive importer is
> > not good, you need use a 3rd column for that like I explained above, so
> > that the importer becomes robust.
> >
> > In summary (exclamation marks indicate severity - one means low, two means
> > medium, and three means high):
> >
> > 1. Convert the header into a version line with optional flags, otherwise
> > nobody can extend this format without compatibility issues (!)
> > 2. Get rid of the specs related to file compression (!!!)
> > 3. Add a 3rd column for item type (address, transaction etc.) preferably
> > as numeric constants and grouping items of one type after items of another
> > type, or if you insist on strings, then only recognize their Titlecase
> > ASCII versions <spreadsheet software like Excel always tries to titlecase
> > the words> (!!)
> > 4. Require double quotes around the label (or single quotes if you prefer,
> > as long as spreadsheet software doesn't choke on them) (!!)
> > 5. Require sorting the records according to the order they are stored in
> > the wallet implementation. (!)
> > 6. Consider getting rid of Input and Output item types. (!)
> > 7. And last and most importantly, please write a more robust importer
> > algorithm in the example given by the BIP, because code in BIPs are
> > frequently used as references for software. (!!!)
> >
> > I hope you will consider these points in future revisions of your BIP.
> >
> > - Ali
> >
> > [1] https://github.com/snyk/zip-slip-vulnerability
> >
> > On Wed, 24 Aug 2022 11:18:43 +0200, craigraw at gmail.com wrote:
> > > Hi all,
> > >
> > > I would like to propose a BIP that specifies a format for the export and
> > > import of labels from a wallet. While transferring access to funds across
> > > wallet applications has been made simple through standards such as BIP39,
> > > wallet labels remain siloed and difficult to extract despite their value,
> > > particularly in a privacy context.
> > >
> > > The proposed format is a simple two column CSV file, with the reference
> > to
> > > a transaction, address, input or output in the first column, and the
> > label
> > > in the second column. CSV was chosen for its wide accessibility,
> > especially
> > > to users without specific technical expertise. Similarly, the CSV file
> > may
> > > be compressed using the ZIP format, and optionally encrypted using AES.
> > >
> > > The full text of the BIP can be found at
> > > https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki
> > > and also copied below.
> > >
> > > Feedback is appreciated.
> > >
> > > Thanks,
> > > Craig Raw
> > >
> > > ---
> > >
> > > <pre>
> > >   BIP: wallet-labels
> > >   Layer: Applications
> > >   Title: Wallet Labels Export Format
> > >   Author: Craig Raw <craig at sparrowwallet.com>
> > >   Comments-Summary: No comments yet.
> > >   Comments-URI:
> > > https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels
> > >   Status: Draft
> > >   Type: Informational
> > >   Created: 2022-08-23
> > >   License: BSD-2-Clause
> > > </pre>
> > >
> > > ==Abstract==
> > >
> > > This document specifies a format for the export of labels that may be
> > > attached to the transactions, addresses, input and outputs in a wallet.
> > >
> > > ==Copyright==
> > >
> > > This BIP is licensed under the BSD 2-clause license.
> > >
> > > ==Motivation==
> > >
> > > The export and import of funds across different Bitcoin wallet
> > applications
> > > is well defined through standards such as BIP39, BIP32, BIP44 etc.
> > > These standards are well supported and allow users to move easily between
> > > different wallets.
> > > There is, however, no defined standard to transfer any labels the user
> > may
> > > have applied to the transactions, addresses, inputs or outputs in their
> > > wallet.
> > > The UTXO model that Bitcoin uses makes these labels particularly valuable
> > > as they may indicate the source of funds, whether received externally or
> > as
> > > a result of change from a prior transaction.
> > > In both cases, care must be taken when spending to avoid undesirable
> > leaks
> > > of private information.
> > > Labels provide valuable guidance in this regard, and have even become
> > > mandatory when spending in several Bitcoin wallets.
> > > Allowing users to export their labels in a standardized way ensures that
> > > they do not experience lock-in to a particular wallet application.
> > > In addition, by using common formats, this BIP seeks to make manual or
> > bulk
> > > management of labels accessible to users without specific technical
> > > expertise.
> > >
> > > ==Specification==
> > >
> > > In order to make the import and export of labels as widely accessible as
> > > possible, this BIP uses the comma separated values (CSV) format, which is
> > > widely supported by consumer, business, and scientific applications.
> > > Although the technical specification of CSV in RFC4180 is not always
> > > followed, the application of the format in this BIP is simple enough that
> > > compatibility should not present a problem.
> > > Moreover, the simplicity and forgiving nature of CSV (over for example
> > > JSON) lends itself well to bulk label editing using spreadsheet and text
> > > editing tools.
> > >
> > > A CSV export of labels from a wallet must be a UTF-8 encoded text file,
> > > containing one record per line, with records containing two fields
> > > delimited by a comma.
> > > The fields may be quoted, but this is unnecessary, as the first comma in
> > > the line will always be the delimiter.
> > > The first line in the file is a header, and should be ignored on import.
> > > Thereafter, each line represents a record that refers to a label applied
> > in
> > > the wallet.
> > > The order in which these records appear is not defined.
> > >
> > > The first field in the record contains a reference to the transaction,
> > > address, input or output in the wallet.
> > > This is specified as one of the following:
> > > * Transaction ID (<tt>txid</tt>)
> > > * Address
> > > * Input (rendered as <tt>txid<index</tt>)
> > > * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)
> > >
> > > The second field contains the label applied to the reference.
> > > Exporting applications may omit records with no labels or labels of zero
> > > length.
> > > Files exported should use the <tt>.csv</tt> file extension.
> > >
> > > In order to reduce file size while retaining wide accessibility, the CSV
> > > file may be compressed using the ZIP file format, using the <tt>.zip</tt>
> > > file extension.
> > > This <tt>.zip</tt> file may optionally be encrypted using either AES-128
> > or
> > > AES-256 encryption, which is supported by numerous applications including
> > > Winzip and 7-zip.
> > > In order to ensure that weak encryption does not proliferate, importers
> > > following this standard must refuse to import <tt>.zip</tt> files
> > encrypted
> > > with the weaker Zip 2.0 standard.
> > > The textual representation of the wallet's extended public key (as
> > defined
> > > by BIP32, with an <tt>xpub</tt> header) should be used as the password.
> > >
> > > ==Importing==
> > >
> > > When importing, a naive algorithm may simply match against any reference,
> > > but it is possible to disambiguate between transactions, addresses,
> > inputs
> > > and outputs.
> > > For example in the following pseudocode:
> > > <pre>
> > >   if reference length < 64
> > >     Set address label
> > >   else if reference length == 64
> > >     Set transaction label
> > >   else if reference contains '<'
> > >     Set input label
> > >   else
> > >     Set output label
> > > </pre>
> > >
> > > Importing applications may truncate labels if necessary.
> > >
> > > ==Test Vectors==
> > >
> > > The following fragment represents a wallet label export:
> > > <pre>
> > > Reference,Label
> > >
> > c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?,Transaction
> > > 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address
> > > c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?<0,Input
> > >
> > c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?>0,Output
> > >
> > c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?:0,Output
> > > (alternative)
> > > </pre>
> > >
> > > ==Reference Implementation==
> > >
> > > TBD


From ChristopherA at lifewithalacrity.com  Mon Aug 29 18:19:07 2022
From: ChristopherA at lifewithalacrity.com (Christopher Allen)
Date: Mon, 29 Aug 2022 11:19:07 -0700
Subject: [bitcoin-dev] BIP Proposal: Wallet Labels Export Format
In-Reply-To: <20220829154603.fec7mlm526vdfo2i@artanis>
References: <mailman.13106.1661772392.956.bitcoin-dev@lists.linuxfoundation.org>
 <20220829154603.fec7mlm526vdfo2i@artanis>
Message-ID: <CACrqygDR4sGX8oY=BT9K_RSYCjsG0P-YBpi-sY5cuM8LBvsQtQ@mail.gmail.com>

On Mon, Aug 29, 2022 at 9:12 AM Ali Sherief via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I am aware that business processes are mostly CSV file oriented


I disagree that business processes are mostly CSV.  Amateur processes
maybe, but professional accounting, no. Trying to do my business accounting
with CSV files from various exchanges is PITA.


> so you can make a statement akin to BIP174 in the Goal 2 BIP, that expects
> the medium of exchange to be in files ending in .csv. I wouldn't mind if
> you require .csv file extension in a BIP for Goal 2. But such a statement
> is not appropriate in the Goal 1 BIP which is only concerned with the
> wallet label format itself.


I too would like to see some separation of layers here, as there are other
possible output formats. Maybe expanding on another use case for this data
would help.

I've been working with @nochiel <https://github.com/nochiel> on export
to a Plain-Text
Accounting <https://plaintextaccounting.org> friendly format,
initially the beancount
python app <https://github.com/beancount/beancount/>: (our prototype is
current at /beancounter.py but it is being refactored into new repo).

Basically what the final tool will do is: given a descriptor, get any
transactions for that descriptor from a random explora via Tor (initially
ours and Blockstream's), and then get price information from a random
Spotbit price server via Tor (initially just ours, but seeking more hosts),
and export a beancount compatible file.

```

python app.py beancount
"wpkh(tpubD9hudZxy8Uj3453QrsEbr8KiyXTYC5ExHjJ5sNDVW7yKJ8wc7acKQcpdbvZX6dFerHK6MfVvs78VvGfotjN28yC4ij6nr4uSVhX2qorUV8V/0/*)"
Outputs: spotbit.beancount

2008-10-31 commodity BTC
  name: "Bitcoin"
  asset-class: "cryptocurrency"

2018-04-02 open Assets:BTC BTC
2018-04-02 open Liabilities:Cash:USDT USDT

2018-04-02 * "tb1qcrekknrspx28t9vl53ltsag5gqgqdj066ydf75" "Transaction
hash: 2a2f7f24761fa54cb6e559efea5678415d9cbbabc42e6a4e2ce463ee3c446230"
Assets:BTC 1.00000000 BTC { 6935.16 USDT }
Liabilities:Cash:USDT - 6935.16 USDT

2018-04-02 * "tb1q45whzx3emntntnpzjdx3gzj6z5cgxakkg7s3sa" "Transaction
hash: 387123efcaa707759a4af8159cb1309fae86b793d26b5fd8bba42637852dde89"
Assets:BTC - 0.36300616 BTC @  6935.16 USDT
Liabilities:Cash:USDT 2517.51 USDT

2018-04-02 * "tb1qgv5484m83e2mzz3n8tf4snvnwj5qgqgampnhvv" "Transaction
hash: 387123efcaa707759a4af8159cb1309fae86b793d26b5fd8bba42637852dde89"
Assets:BTC - 0.63699243 BTC @  6935.16 USDT
Liabilities:Cash:USDT 4417.64 USDT

2018-04-02 * "tb1q45whzx3emntntnpzjdx3gzj6z5cgxakkg7s3sa" "Transaction
hash: 387123efcaa707759a4af8159cb1309fae86b793d26b5fd8bba42637852dde89"
Assets:BTC 0.36300616 BTC { 6935.16 USDT }
Liabilities:Cash:USDT - 2517.51 USDT
```

I can then use the beancount cli app (or it's fava webapp) to easily add
other details to this file to do my bitcoin accounting (and any other
accounting I need). In particular, as beancount support lots, it solves a
problem for me with US taxes which is unrealized capital gain (I get 1 BTC
from donor at $20K, the price goes up to $30K and I pay it to an engineer,
my BTC balance is 0 but my unrealized capital gain for US tax purposes  is
$10K).

More ideally, if there were additional details that I could merge in from
my wallet export, such as payer and payee, notes, etc. it would make my
accounting much easier.

Thus I'd like to see an easier and interoperable way to merge these details
(my account details from an Esplora and price details from Spotbit), with
what my different wallets may (or may not) have available.

I hope that this might inspire some ideas from the people working on this
wallet export format.

-- Christopher Allen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220829/21fd9830/attachment.html>

From rodolfo at coinkite.com  Mon Aug 29 19:52:17 2022
From: rodolfo at coinkite.com (NVK)
Date: Mon, 29 Aug 2022 15:52:17 -0400
Subject: [bitcoin-dev] BIP Proposal: Wallet Labels Export Format
In-Reply-To: <CAPR5oBNKQEPCAXcMoneGv2vLVmOLZGyxNEoZ4_=tyQT_mkAkmw@mail.gmail.com>
References: <CAPR5oBNKQEPCAXcMoneGv2vLVmOLZGyxNEoZ4_=tyQT_mkAkmw@mail.gmail.com>
Message-ID: <E6BFAF8D-9FD7-4C9D-813C-62C73E9FE26C@coinkite.com>

Hello,

Thanks for this proposal.

I was trying to avoid adding more opinions / bike-shdding to the discussion and didn?t want to particularly pick at any of the threads.

But, I think I?d like to at least voice at how important having a human readable format for this is. CSV is indeed a format with many shortcomings, but so are most cross applications open formats that are human readable. I go through this every month for business and personal.

If contention is too high for CSV as cross application for import/export then maybe the route of two file formats maybe awkward but necessary. JSON maybe used as the choice for bitcoin clients for label syncing and CSV as the export for other purposes. I believe CSV is importable by most accounting software, old and new. JSON is not.

In regards to encryption, AES on 7z is a great, wide os native support.

Best,

NVK

> On Aug 24, 2022, at 05:46, Craig Raw via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> ?
> Hi all,
> 
> I would like to propose a BIP that specifies a format for the export and import of labels from a wallet. While transferring access to funds across wallet applications has been made simple through standards such as BIP39, wallet labels remain siloed and difficult to extract despite their value, particularly in a privacy context.
> 
> The proposed format is a simple two column CSV file, with the reference to a transaction, address, input or output in the first column, and the label in the second column. CSV was chosen for its wide accessibility, especially to users without specific technical expertise. Similarly, the CSV file may be compressed using the ZIP format, and optionally encrypted using AES.
> 
> The full text of the BIP can be found at https://github.com/craigraw/bips/blob/master/bip-wallet-labels.mediawiki and also copied below.
> 
> Feedback is appreciated.
> 
> Thanks,
> Craig Raw
> 
> ---
> 
> <pre>
>   BIP: wallet-labels
>   Layer: Applications
>   Title: Wallet Labels Export Format
>   Author: Craig Raw <craig at sparrowwallet.com>
>   Comments-Summary: No comments yet.
>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-labels
>   Status: Draft
>   Type: Informational
>   Created: 2022-08-23
>   License: BSD-2-Clause
> </pre>
> 
> ==Abstract==
> 
> This document specifies a format for the export of labels that may be attached to the transactions, addresses, input and outputs in a wallet.
> 
> ==Copyright==
> 
> This BIP is licensed under the BSD 2-clause license.
> 
> ==Motivation==
> 
> The export and import of funds across different Bitcoin wallet applications is well defined through standards such as BIP39, BIP32, BIP44 etc.
> These standards are well supported and allow users to move easily between different wallets.
> There is, however, no defined standard to transfer any labels the user may have applied to the transactions, addresses, inputs or outputs in their wallet.
> The UTXO model that Bitcoin uses makes these labels particularly valuable as they may indicate the source of funds, whether received externally or as a result of change from a prior transaction.
> In both cases, care must be taken when spending to avoid undesirable leaks of private information.
> Labels provide valuable guidance in this regard, and have even become mandatory when spending in several Bitcoin wallets.
> Allowing users to export their labels in a standardized way ensures that they do not experience lock-in to a particular wallet application.
> In addition, by using common formats, this BIP seeks to make manual or bulk management of labels accessible to users without specific technical expertise.
> 
> ==Specification==
> 
> In order to make the import and export of labels as widely accessible as possible, this BIP uses the comma separated values (CSV) format, which is widely supported by consumer, business, and scientific applications.
> Although the technical specification of CSV in RFC4180 is not always followed, the application of the format in this BIP is simple enough that compatibility should not present a problem.
> Moreover, the simplicity and forgiving nature of CSV (over for example JSON) lends itself well to bulk label editing using spreadsheet and text editing tools. 
> 
> A CSV export of labels from a wallet must be a UTF-8 encoded text file, containing one record per line, with records containing two fields delimited by a comma.
> The fields may be quoted, but this is unnecessary, as the first comma in the line will always be the delimiter.
> The first line in the file is a header, and should be ignored on import.
> Thereafter, each line represents a record that refers to a label applied in the wallet.
> The order in which these records appear is not defined.
> 
> The first field in the record contains a reference to the transaction, address, input or output in the wallet.
> This is specified as one of the following:
> * Transaction ID (<tt>txid</tt>)
> * Address
> * Input (rendered as <tt>txid<index</tt>)
> * Output (rendered as <tt>txid>index</tt> or <tt>txid:index</tt>)
> 
> The second field contains the label applied to the reference. 
> Exporting applications may omit records with no labels or labels of zero length.
> Files exported should use the <tt>.csv</tt> file extension.
> 
> In order to reduce file size while retaining wide accessibility, the CSV file may be compressed using the ZIP file format, using the <tt>.zip</tt> file extension.
> This <tt>.zip</tt> file may optionally be encrypted using either AES-128 or AES-256 encryption, which is supported by numerous applications including Winzip and 7-zip. 
> In order to ensure that weak encryption does not proliferate, importers following this standard must refuse to import <tt>.zip</tt> files encrypted with the weaker Zip 2.0 standard.
> The textual representation of the wallet's extended public key (as defined by BIP32, with an <tt>xpub</tt> header) should be used as the password.
> 
> ==Importing==
> 
> When importing, a naive algorithm may simply match against any reference, but it is possible to disambiguate between transactions, addresses, inputs and outputs. 
> For example in the following pseudocode:
> <pre>
>   if reference length < 64
>     Set address label
>   else if reference length == 64
>     Set transaction label
>   else if reference contains '<'
>     Set input label
>   else
>     Set output label
> </pre>
> 
> Importing applications may truncate labels if necessary.
> 
> ==Test Vectors==
> 
> The following fragment represents a wallet label export:
> <pre>
> Reference,Label
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?,Transaction
> 1A69TXnEM2ms9fMaY9UuiJ7415X7xZaUSg,Address
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?<0,Input
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?>0,Output
> c3bdad6e7dcd7997e16a5b7b7cf4d8f6079820ff2eedd5fcbb2ad088f767b37b?:0,Output (alternative)
> </pre>
> 
> ==Reference Implementation==
> 
> TBD
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220829/58fd4d21/attachment-0001.html>

From antoine.riard at gmail.com  Tue Aug 30 15:46:23 2022
From: antoine.riard at gmail.com (Antoine Riard)
Date: Tue, 30 Aug 2022 16:46:23 +0100
Subject: [bitcoin-dev] On a new community process to specify covenants
In-Reply-To: <CAGpPWDY0WV0dzRx2mD7kd-48+wrF=BJBf=ZB5R6+owPrdHTp+w@mail.gmail.com>
References: <CALZpt+FhpZETHP8UpDGgw-Wg=m4Hxm8y9XZ9kXYgmt90_6Zt6w@mail.gmail.com>
 <CAHUJnBDu+PNvER-FmpT8593vX-wAZ1oPWJjQaJ=d7Y4pso_Txw@mail.gmail.com>
 <CALZpt+E4Ej3KJ4WqkUDTF3DRhPTbUT5mw2c_eHLuxH7w1BbWGg@mail.gmail.com>
 <CAHUJnBB1wExgJhHUeU88ZMD28s6+9UT3Cfc43_UpK40hJwUFSg@mail.gmail.com>
 <CAGpPWDbbZ7PEpr4iwYwBn+5QcjjCx8qmTZVB98i2Z=UwDfwaTQ@mail.gmail.com>
 <CALZpt+HWzZdwMrtX=8rMpZ+e5dWcmbMeEx3jhTB_XnWz1n7RJQ@mail.gmail.com>
 <CAGpPWDY0WV0dzRx2mD7kd-48+wrF=BJBf=ZB5R6+owPrdHTp+w@mail.gmail.com>
Message-ID: <CALZpt+FViEy=2zABg-XXt_NVMTS4ss7s+2zKbUGQq9xpQr13_w@mail.gmail.com>

Hi Billy,

> I was actually not thinking one large central in-person meeting, but many
smaller decentralized in-person meetings where no one has to travel far.
The meetings can be used to foster communication that can then be
summarized and/or brought online and discussed with the larger group. Would
certainly make all those date/visa/etc issues a lot easier.

Minimizing travel hurdles for everyone sounds wise. About decentralized
in-person meetings we already have a wide network of BitDev all around the
world that can be opportunities to foster communication on covenant R&D
advances. Staying interested in participating in in-person covenant-focus
meetings though I won't volunteer to organize them, from my experience it's
a real trade different from Bitcoin research engineering!

> Fair enough. But I think part of the point here would be to use such a
snapshot as an indicator that helps convince others that a particular idea
has been discussed, thought through, and has actual well-reasoned support.
Whatever you call it, it would be a useful set of data points.

Yeah, collecting, building and maintaining a set of strong data points that
would improve the community covenant information-gathering process.
However, I think observing consensus is better left to everyone's personal
judgement rather than proclaiming it. At best, we can monitor the lack of
consensus.

There is already an ongoing effort to document primitives :
https://github.com/bitcoinops/bitcoinops.github.io/pull/806 and making
progress on the use-cases collection soon.


Le sam. 27 ao?t 2022 ? 22:01, Billy Tetrud <billy.tetrud at gmail.com> a
?crit :

> >  I would like to note it's real work for the organizers in terms of time
> and energy: finding a common date making consensus, an acceptable host
> country (i.e respecting the travel policy of the widest...
>
> I was actually not thinking one large central in-person meeting, but many
> smaller decentralized in-person meetings where no one has to travel far.
> The meetings can be used to foster communication that can then be
> summarized and/or brought online and discussed with the larger group. Would
> certainly make all those date/visa/etc issues a lot easier.
>
> >  I would be even cautious about something restrained like "group
> consensus" in Bitcoin FOSS. At best, it's just a snapshot of people's
> understanding of the technical issues in state X at time T
>
> Fair enough. But I think part of the point here would be to use such a
> snapshot as an indicator that helps convince others that a particular idea
> has been discussed, thought through, and has actual well-reasoned support.
> Whatever you call it, it would be a useful set of data points.
>
> >  I believe the covenant problem space might be solved in an evolutionary
> way, layer by layer akin to how LN moves forward.
>
> Definitely.
>
>
> On Tue, Aug 9, 2022 at 3:15 PM Antoine Riard <antoine.riard at gmail.com>
> wrote:
>
>> Hi Billy,
>>
>> Thanks for your interest in a covenant working group.
>>
>> > place for this kind of thing to happen. I also agree with Ryan Grant's
>> > comment about in-person cut-through (ie cut through the BS and resolve
>> > misunderstandings). Perhaps every 3 IRC meetings or so, an in-person
>> meetup
>> > can be organized in various locations to facilitate that kind of cut
>> > through.
>>
>> I really appreciate in-person cut-through to resolve misunderstandings
>> and accelerate the information synchronization across the stakeholders of a
>> problem space. However, I would like to note it's real work for the
>> organizers in terms of time and energy: finding a common date making
>> consensus, an acceptable host country (i.e respecting the travel policy of
>> the widest, e.g organizing Scaling in Israel in 2019 was an issue for some
>> passport holders), a standard meeting location, seeking event sponsors,
>> communicating all those infos well ahead to ease everyone travels, ensuring
>> coffees & foods suiting many different diets, collecting topics of
>> discussions, etc. Further, even assuming travel support, it can still be a
>> prohibitive cost for a lot of participants, e.g if you have to request
>> months ahead to the host country authorities a dedicated visa for the
>> opportunity. I did a bit of in-person meetings organizing in the past, I'm
>> clearly not interested in doing it anymore, though it would be cool if
>> someone would like to do it for covenants in the future.
>>
>> > I would imagine the phases the group could go through is:
>> > 1. Define the phases (these phases). This list of 6 phases could be a
>> > starting point, but its probably best to open the floor to whether this
>> > feels like a reasonable approach and if more phases are needed or if
>> some
>> > aren't.
>> > 2. Define and prioritize the motivations (ie the various features and
>> > functionality we want out of covenants, like the ones you listed). By
>> > prioritize, I mostly mean figure out which motivations are most
>> motivating
>> > to people and rate them by strength of motivation (rather than a ranked
>> > list).
>> > 3. Define and prioritize the relevant constraints. These are things to
>> > avoid in any covenant implementation. Constraints that have been
>> brought up
>> > in the past are things like preventing the possibility of infinite
>> covenant
>> > recursion, full enumeration, preventing dynamic state, etc. By
>> prioritize
>> > here, it might be useful to categorize them into categories like "no
>> > tolerance", "some tolerance", "no reservations". Eg it might turn out
>> most
>> > people don't have any tolerance for infinite recursion, but don't mind
>> > non-full enumeration.
>> > 4. Other criteria? These are other criteria we might want to evaluate
>> > proposals according to. And some kind of way to prioritize them /
>> evaluate
>> > them against each other as trade offs.
>> > 5. Evaluate the proposals based on motivations, constraints, and other
>> > criteria. This phase shouldn't involve comparing them to each other.
>> > 6. Produce a set of conclusions/opinions on which proposals are worth
>> > pursuing further. This would be the phase where proposals are compared.
>>
>> Yes, I think overall a lot is making sense. Though it's good to keep
>> things as loose and see how it evaluates with time and new information
>> showing up.
>>
>> About 2., I think one more thing to define is the list of use-cases, I
>> would abstract out features and functionality from use-cases. E.g, I think
>> with the TLUV proposal, the taproot output editing feature enables both
>> "dynamic-amount" vault and scaling payment pools.
>>
>> About 3., I think this is going to be the hard part. Collecting all the
>> constraints and evaluating the risk tolerance of as-much-as-we-can
>> community stakeholders in face of known and plausible risks. E.g, again
>> with TLUV, I think it would make from now on the taproot internal pubkey
>> and tree of alternative scripts a kind of "dynamic state".
>>
>> About 4. I've quickly come to mind as additional criterias economic
>> simulations of any feature, privacy advantages, toolchain implementations
>> complexity, evolvability and composability with future features.
>>
>> About 6. I agree I think it's good to withhold comparison further down in
>> the pipe we can, even if there is I would say some criteria-learning
>> heuristics by mirroring features against another.
>>
>> > Each phase would probably span over more than one meeting. I imagine
>> each
>> > phase basically consisting of discussing each individual nominated item
>> (ie
>> > motivations, constraints, other criteria, or proposals) sequentially.
>> The
>> > consensus reached at the end of each phase would be considered of
>> course a
>> > group consensus of those who participated, not a global consensus, not a
>> > "bitcoin community consensus". After each phase, the results of that
>> phase
>> > would be published more widely to get broader community feedback. These
>> > results would include what the major opinions are, what level of
>> consensus
>> > each major opinion has, what the reasons/justifications behind each
>> opinion
>> > are, and various detailed opinions from individuals. It would be
>> especially
>> > great to have detailed evaluations of each proposal published by various
>> > people so anyone can go back and understand their thought process (as
>> > opposed to a list of names attached to basically a thumbs up or thumbs
>> > down). Think like a supreme court decision kind of thing.
>>
>> Yeah, again I don't see meetings as bounded in time rather happening
>> regularly as we have with LN ones. I guess it's going to take at least a
>> good year for working group participants to take habits and familiarity
>> with the problem space and reach consensus on the process itself. Further,
>> I would be even cautious about something restrained like "group consensus"
>> in Bitcoin FOSS. At best, it's just a snapshot of people's understanding of
>> the technical issues in state X at time T, and that can evaluate quickly in
>> function of new findings or issues arising. I think it's more interesting
>> to seek a lack of consensus in the sense of opposite opinions or blocking
>> arguments. I wouldn't disqualify thumbs up or thumbs down per se, there are
>> marks of interest in a specific proposal, though I lean to agree that I
>> find more interesting too laid-out evaluations and thought processes.
>>
>> > The process doesn't need to be complete after phase 6. Any previous
>> phase
>> > could be revisited, but after a phase is revisited, the phases after it
>> > should probably be also revisited in order - or at least until its
>> decided
>> > a previous phase needs to be revisited again. Each iteration would
>> solidify
>> > consensus more about each phase. I would imagine the group might loop
>> > through phases 2, 3, and 4 a couple times (since constraints might
>> conflict
>> > with motivating features). It might be likely that in phase 5 while
>> > evaluating proposals, people realize that there are additional criteria
>> > that should be added and can propose going back to step 4 to do that.
>> > Hopefully we would get to the point where the motivations and
>> constraints
>> > and relatively solid consensuses and iterations can loop through phases
>> 5
>> > and 6 until the set of proposals the group thinks is worth pursuing  is
>> > narrowed down (ideally to 1 or 2).
>>
>> For sure, in the function of new feedback arising it's good to constantly
>> reevaluate proposals. Hopefully, I think any looping should make proposals
>> more formalized and accurate. We might also have the "easy" covenants
>> moving faster than the "hard" ones across the phases. I believe the
>> covenant problem space might be solved in an evolutionary way, layer by
>> layer akin to how LN moves forward.
>>
>> Le mer. 3 ao?t 2022 ? 11:37, Billy Tetrud <billy.tetrud at gmail.com> a
>> ?crit :
>>
>>> @Antoine
>>> I very much like your proposal of an open decentralized process for
>>> investigating the problem and solution spaces. IRC sounds like a reasonable
>>> place for this kind of thing to happen. I also agree with Ryan Grant's
>>> comment about in-person cut-through (ie cut through the BS and resolve
>>> misunderstandings). Perhaps every 3 IRC meetings or so, an in-person meetup
>>> can be organized in various locations to facilitate that kind of cut
>>> through.
>>>
>>> I would imagine the phases the group could go through is:
>>> 1. Define the phases (these phases). This list of 6 phases could be a
>>> starting point, but its probably best to open the floor to whether this
>>> feels like a reasonable approach and if more phases are needed or if some
>>> aren't.
>>> 2. Define and prioritize the motivations (ie the various features and
>>> functionality we want out of covenants, like the ones you listed). By
>>> prioritize, I mostly mean figure out which motivations are most motivating
>>> to people and rate them by strength of motivation (rather than a ranked
>>> list).
>>> 3. Define and prioritize the relevant constraints. These are things to
>>> avoid in any covenant implementation. Constraints that have been brought up
>>> in the past are things like preventing the possibility of infinite covenant
>>> recursion, full enumeration, preventing dynamic state, etc. By prioritize
>>> here, it might be useful to categorize them into categories like "no
>>> tolerance", "some tolerance", "no reservations". Eg it might turn out most
>>> people don't have any tolerance for infinite recursion, but don't mind
>>> non-full enumeration.
>>> 4. Other criteria? These are other criteria we might want to evaluate
>>> proposals according to. And some kind of way to prioritize them / evaluate
>>> them against each other as trade offs.
>>> 5. Evaluate the proposals based on motivations, constraints, and other
>>> criteria. This phase shouldn't involve comparing them to each other.
>>> 6. Produce a set of conclusions/opinions on which proposals are worth
>>> pursuing further. This would be the phase where proposals are compared.
>>>
>>> Each phase would probably span over more than one meeting. I imagine
>>> each phase basically consisting of discussing each individual nominated
>>> item (ie motivations, constraints, other criteria, or proposals)
>>> sequentially. The consensus reached at the end of each phase would be
>>> considered of course a group consensus of those who participated, not a
>>> global consensus, not a "bitcoin community consensus". After each phase,
>>> the results of that phase would be published more widely to get broader
>>> community feedback. These results would include what the major opinions
>>> are, what level of consensus each major opinion has, what the
>>> reasons/justifications behind each opinion are, and various detailed
>>> opinions from individuals. It would be especially great to have detailed
>>> evaluations of each proposal published by various people so anyone can go
>>> back and understand their thought process (as opposed to a list of names
>>> attached to basically a thumbs up or thumbs down). Think like a supreme
>>> court decision kind of thing.
>>>
>>> The process doesn't need to be complete after phase 6. Any previous
>>> phase could be revisited, but after a phase is revisited, the phases after
>>> it should probably be also revisited in order - or at least until its
>>> decided a previous phase needs to be revisited again. Each iteration would
>>> solidify consensus more about each phase. I would imagine the group might
>>> loop through phases 2, 3, and 4 a couple times (since constraints might
>>> conflict with motivating features). It might be likely that in phase 5
>>> while evaluating proposals, people realize that there are additional
>>> criteria that should be added and can propose going back to step 4 to do
>>> that. Hopefully we would get to the point where the motivations and
>>> constraints and relatively solid consensuses and iterations can loop
>>> through phases 5 and 6 until the set of proposals the group thinks is worth
>>> pursuing  is narrowed down (ideally to 1 or 2).
>>>
>>>
>>>
>>>
>>>
>>>
>>> On Tue, Jul 26, 2022 at 11:47 AM Bram Cohen via bitcoin-dev <
>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>>> On Mon, Jul 25, 2022 at 8:21 PM Antoine Riard <antoine.riard at gmail.com>
>>>> wrote:
>>>>
>>>>> What would be the canonical definition and examples of capabilities in
>>>>> the Bitcoin context ?
>>>>>
>>>>
>>>> Payments into vaults which can only be accepted by that vault and are
>>>> guaranteed to be subject to the vault's restrictions (the vault has a
>>>> capability)
>>>>
>>>> Oracles whose validity can be verified on chain (so transactions can
>>>> depend on what they say. The oracle has a capability)
>>>>
>>>> Colored coins whose validity can be verified on chain (the colored
>>>> coins have a capability)
>>>>
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>
>>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220830/aa31a93d/attachment-0001.html>

