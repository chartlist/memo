From gsanders87 at gmail.com  Wed Feb  1 00:37:06 2023
From: gsanders87 at gmail.com (Greg Sanders)
Date: Tue, 31 Jan 2023 19:37:06 -0500
Subject: [bitcoin-dev] Reference example bech32m address for future
	segwit versions
In-Reply-To: <c9ddddce1ad797671431335fe95cf2b7@dtrt.org>
References: <e6da74da025355472a81e613fe7683b9@dtrt.org>
 <CAB3F3Dtfu+kaJ8jgi-qRiZBXvuYaEVEa32q_UPkwA5MLAP9RSg@mail.gmail.com>
 <c9ddddce1ad797671431335fe95cf2b7@dtrt.org>
Message-ID: <CAB3F3Dtz7Sq8SCYjFn9yx_92bStJRBy0rLu_o3bHndKG9HwdrA@mail.gmail.com>

David,

I'm merely speaking in a descriptive sense. I predict that most custodians
are reluctant to whitelist
a witness version they know is insecure.

I'm not sure what's best for not colliding with future versions, I'll let
other wiser folks weigh in.

Cheers,
Greg

On Tue, Jan 31, 2023 at 6:33 PM David A. Harding <dave at dtrt.org> wrote:

> On 2023-01-31 04:30, Greg Sanders wrote:
> > Hi David,
> >
> > From practical experience, I think you'll find that most exchanges
> > will not enable sends to future segwit versions,
> > as from a risk perspective it's likely a mistake to send funds there.
>
> Hi Greg!,
>
> I thought the best practice[1] was that wallets would spend to the
> output indicated by any valid bech32m address.  You seem to implying
> that the best practice is the opposite: that wallets should only send to
> outputs they know can be secured (i.e., which are not currently
> anyone-can-spend).  The more restrictive approach seems kind of sad to
> me since any problem which can result in a user accidentally withdrawing
> to a future segwit version could even more easily result in them
> withdrawing to a witness program for which there is no solution (i.e.,
> no key or script is known to spend).
>
> If it is a best practice, then I think there's a benefit to being able
> to test it even when other people's proprietary software is involved.  A
> wallet or service likely to follow that best practice may be more likely
> to follow other best practices which cannot be as easily tested for.
> But, if it's going to be tested, I want the testing to use the address
> least likely to cause problems for protocol developers in the future.
> Do you (and others on this list) have any reason to believe OP_16
> OP_PUSH2 0000 would be a problematic script, or can you think of a
> better script?
>
> Thanks!,
>
> -Dave
>
> [1] BIP350, emphasis in original: "[...] we emphatically recommend [...]
> ensuring that your implementation supports sending to v1 **and higher
> versions.**"
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230131/bcb8b5a9/attachment.html>

From aj at erisian.com.au  Wed Feb  1 01:13:49 2023
From: aj at erisian.com.au (Anthony Towns)
Date: Wed, 1 Feb 2023 11:13:49 +1000
Subject: [bitcoin-dev] Reference example bech32m address for future
 segwit versions
In-Reply-To: <c9ddddce1ad797671431335fe95cf2b7@dtrt.org>
References: <e6da74da025355472a81e613fe7683b9@dtrt.org>
 <CAB3F3Dtfu+kaJ8jgi-qRiZBXvuYaEVEa32q_UPkwA5MLAP9RSg@mail.gmail.com>
 <c9ddddce1ad797671431335fe95cf2b7@dtrt.org>
Message-ID: <Y9m8zcsC2LxtptDf@erisian.com.au>

On Tue, Jan 31, 2023 at 01:33:13PM -1000, David A. Harding via bitcoin-dev wrote:
> I thought the best practice[1] was that wallets would spend to the output
> indicated by any valid bech32m address.  

I think it depends -- if the wallet in question is non-custodial and
might not be upgraded by the time witness v2 addresses are in use, then
being able to send to such addresses now makes sense. 

If it's a custodial wallet where the nominal owner of the coins isn't
the one signing the tx, then I could see a pretty strong argument to not
allowing sending to such addresses until they're in use: (a) nobody will
be running the old software, since the custodian can just force everyone
to upgrade (eg, by deploying a new version of their own website), and (b)
signing a tx to send the bitcoins you're holding on Bob's behalf to an
address that will just get them stolen could be considered as negligence,
and you might end up forced to make Bob whole again.

So maybe the argument is:

 * is this a custodial wallet? then what's the point of testing a
   scenario that's likely years away -- the custodian will probably have
   changed their system entirely by then anyway

 * is it a non-custodial wallet? then it's worth testing -- you might
   not be able to find compatible software in future to move your
   private keys and have to dig up the current software and use it. will
   it still work? but in that case, you ought to be able to capture the
   tx it generates before broadcasting it, and don't need to publish it
   on chain, and then it doesn't matter what script you use?

(For libraries and non-wallet software like block explorers or alternate
node implementations, it's a different matter)

Cheers,
aj

From ChristopherA at lifewithalacrity.com  Wed Feb  1 00:46:32 2023
From: ChristopherA at lifewithalacrity.com (Christopher Allen)
Date: Tue, 31 Jan 2023 16:46:32 -0800
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
	OP_IF OP_PUSH
Message-ID: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>

All other things being equal, which is better if you need to place a
64-bytes into the Bitcoin blockchain? A traditional OP_RETURN or a spent
taproot transaction such as:

OP_FALSE
OP_IF
OP_PUSH my64bytes
OP_ENDIF

I know that the anti-OP_RETURN folk would say ?neither.? But if there was
no other choice for a particular protocol, such as a timestamp or a
commitment, which is better? Or is there a safer place to put 64 bytes that
is more uncensorable but also does not clog UTXO space, only spent
transaction `-txindex` space?

My best guess was that the taproot method is better, but I suspect there
might be some who disagree. I'd love to hear all sides.

-- Christopher Allen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230131/cac8f8b3/attachment.html>

From pete at petertodd.org  Wed Feb  1 02:07:16 2023
From: pete at petertodd.org (Peter Todd)
Date: Tue, 31 Jan 2023 21:07:16 -0500
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot
	OP_FALSE	OP_IF OP_PUSH
In-Reply-To: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
Message-ID: <764E460B-C0C6-47B8-A97E-F7CBC81FD645@petertodd.org>



On January 31, 2023 7:46:32 PM EST, Christopher Allen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>All other things being equal, which is better if you need to place a
>64-bytes into the Bitcoin blockchain? A traditional OP_RETURN or a spent
>taproot transaction such as:
>
>OP_FALSE
>OP_IF
>OP_PUSH my64bytes
>OP_ENDIF

What's wrong with OpPush <data> OpDrop?

>I know that the anti-OP_RETURN folk would say ?neither.? But if there was
>no other choice for a particular protocol, such as a timestamp or a
>commitment, which is better? Or is there a safer place to put 64 bytes that
>is more uncensorable but also does not clog UTXO space, only spent
>transaction `-txindex` space?
>
>My best guess was that the taproot method is better, but I suspect there
>might be some who disagree. I'd love to hear all sides.

An important consideration with using taproot is that you need to have the data you are committing too to be able to to spend the txout in the future. OpReturn doesn't have that problem, meaning that in a situation like a hard drive failure, you can still recover the funds from a wallet seed.

Also, it is incorrect to say that OpReturn outputs "clog UTXO space". The whole point of OpReturn is to standardize a way to keep such outputs out of the UTXO set. There is the 75% discount to using witness space. But considering the size of a transaction as a whole using taproot instead of OpReturn doesn't save much.

Finally, _64_ bytes is more than a mere 32 byte commitment. What specific use case do you actually have in mind here? Are you actually publishing data, or simply committing to data? If the latter, you can use ECC commitments and have no extra space at all.

From ChristopherA at lifewithalacrity.com  Wed Feb  1 02:22:29 2023
From: ChristopherA at lifewithalacrity.com (Christopher Allen)
Date: Tue, 31 Jan 2023 18:22:29 -0800
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <764E460B-C0C6-47B8-A97E-F7CBC81FD645@petertodd.org>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <764E460B-C0C6-47B8-A97E-F7CBC81FD645@petertodd.org>
Message-ID: <CACrqygD8ZF-PqKuFK7-SgiPdZQ9ewt+9QGXytpf8+NYjjNjyfA@mail.gmail.com>

I don't have a concrete proposal in mind, I'm just trying to understand
various tradeoffs in post-taproot bitcoin in more detail.

On Tue, Jan 31, 2023 at 6:07 PM Peter Todd <pete at petertodd.org> wrote:

>
> >OP_FALSE
> >OP_IF
> >OP_PUSH my64bytes
> >OP_ENDIF
>
> What's wrong with OpPush <data> OpDrop?
>

I'm not sure pro or con of either. I just saw that proposal above recently.


> Also, it is incorrect to say that OpReturn outputs "clog UTXO space". The
> whole point of OpReturn is to standardize a way to keep such outputs out of
> the UTXO set. There is the 75% discount to using witness space. But
> considering the size of a transaction as a whole using taproot instead of
> OpReturn doesn't save much.
>

There are OP_RETURN tricks in production that do clog UTXO space. I was
trying to avoid consideration of those by just saying to compare apples vs.
apples, by presuming that any form of these transactions holding the 64
bytes is a spent transaction.

Finally, _64_ bytes is more than a mere 32 byte commitment. What specific
> use case do you actually have in mind here? Are you actually publishing
> data, or simply committing to data? If the latter, you can use ECC
> commitments and have no extra space at all.
>

I chose 64 bytes for this exercise, as I know there are tricks hiding 32
bytes as keys. As almost every op_return live out there is >32 bytes, I
wanted an example that could be a signature, two hashes, a hash plus some
metadata, etc. I also considered 96 bytes (for instance a hash and a
signature), but as that doesn't fit into OP_RETURN's 80 bytes, that choice
prohibits comparing the different approaches side-by-side.

To come back to my question another way, if you ignore the people who say
"never put anything except data facilitating coin transactions into the
bitcoin blockchain", but if you also are not trying to use the bitcoin
blockchain as a world database (ala ETH), what is the most pragmatic way to
do so that minimizes any potential harm? The answer pre-taproot was
OP_RETURN. What is it now?

-- Christopher Allen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230131/60e5928e/attachment.html>

From pete at petertodd.org  Wed Feb  1 12:51:38 2023
From: pete at petertodd.org (Peter Todd)
Date: Wed, 01 Feb 2023 12:51:38 +0000
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
	OP_IF OP_PUSH
In-Reply-To: <CABE6yHtbgD_5kCHMu9P9ThbqRHnzXMERRZsu7_6H20CAcQuEww@mail.gmail.com>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <764E460B-C0C6-47B8-A97E-F7CBC81FD645@petertodd.org>
 <CACrqygD8ZF-PqKuFK7-SgiPdZQ9ewt+9QGXytpf8+NYjjNjyfA@mail.gmail.com>
 <CABE6yHtbgD_5kCHMu9P9ThbqRHnzXMERRZsu7_6H20CAcQuEww@mail.gmail.com>
Message-ID: <BF0364BD-E25A-444D-91AE-DAAB44C82B76@petertodd.org>



On February 1, 2023 8:36:52 AM GMT, Kostas Karasavvas <kkarasavvas at gmail.com> wrote:
>With OP_RETURN you publish some data that are immediately visible in the
>blockchain. I would consider this better (more straightforward) for things
>like time-stamping.

You are incorrect. Time-stamps merely prove that data existed prior to some point in time. There is absolutely no need for anything to be published in the blockchain to create a timestamp. Indeed, efficient timestamps don't actually publish any meaningful data: for efficiency you always combine many timestamps into a single merkle tree; a merkle tree tip digest is meaningless data by itself.

OpenTimestamps does in fact use OpReturn rather than something more efficient. But it does this only because the efficiency gain isn't significant enough for me to have gotten around to improving it. Reducing fee costs by ~10% isn't a good use of my time.

>With Taproot you need to spend the utxo to make the script visible. This
>seems better when you don't want the data public but you need to be able to
>reveal the data when the time comes.

If your concern is the data being public due to OpReturn vs Taproot, you are confused and need to think more carefully about what exactly you are doing.

From apoelstra at wpsoftware.net  Wed Feb  1 14:02:41 2023
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Wed, 1 Feb 2023 14:02:41 +0000
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <764E460B-C0C6-47B8-A97E-F7CBC81FD645@petertodd.org>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <764E460B-C0C6-47B8-A97E-F7CBC81FD645@petertodd.org>
Message-ID: <Y9pxAdm3kO1rr2kU@camus>

On Tue, Jan 31, 2023 at 09:07:16PM -0500, Peter Todd via bitcoin-dev wrote:
> 
> 
> On January 31, 2023 7:46:32 PM EST, Christopher Allen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >All other things being equal, which is better if you need to place a
> >64-bytes into the Bitcoin blockchain? A traditional OP_RETURN or a spent
> >taproot transaction such as:
> >
> >OP_FALSE
> >OP_IF
> >OP_PUSH my64bytes
> >OP_ENDIF
> 
> What's wrong with OpPush <data> OpDrop?
>

This is a technical nit, but the reason is that <data> is limited to 520
bytes (and I believe, 80 bytes by standardness in Taproot), so if you
are pushing a ton of data and need multiple pushes, it's more efficient
to use FALSE IF ... ENDIF since you avoid the repeated DROPs.

-- 
Andrew Poelstra
Director of Research, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

The sun is always shining in space
    -Justin Lewis-Webster

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230201/4ed63515/attachment.sig>

From kkarasavvas at gmail.com  Wed Feb  1 08:36:52 2023
From: kkarasavvas at gmail.com (Kostas Karasavvas)
Date: Wed, 1 Feb 2023 10:36:52 +0200
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <CACrqygD8ZF-PqKuFK7-SgiPdZQ9ewt+9QGXytpf8+NYjjNjyfA@mail.gmail.com>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <764E460B-C0C6-47B8-A97E-F7CBC81FD645@petertodd.org>
 <CACrqygD8ZF-PqKuFK7-SgiPdZQ9ewt+9QGXytpf8+NYjjNjyfA@mail.gmail.com>
Message-ID: <CABE6yHtbgD_5kCHMu9P9ThbqRHnzXMERRZsu7_6H20CAcQuEww@mail.gmail.com>

With OP_RETURN you publish some data that are immediately visible in the
blockchain. I would consider this better (more straightforward) for things
like time-stamping.

With Taproot you need to spend the utxo to make the script visible. This
seems better when you don't want the data public but you need to be able to
reveal the data when the time comes.

Unless it is important to reveal later, it seems to me that for 80 bytes or
less OP_RETURN is still the way to go post-taproot.



On Wed, 1 Feb 2023, 04:30 Christopher Allen via bitcoin-dev, <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I don't have a concrete proposal in mind, I'm just trying to understand
> various tradeoffs in post-taproot bitcoin in more detail.
>
> On Tue, Jan 31, 2023 at 6:07 PM Peter Todd <pete at petertodd.org> wrote:
>
>>
>> >OP_FALSE
>> >OP_IF
>> >OP_PUSH my64bytes
>> >OP_ENDIF
>>
>> What's wrong with OpPush <data> OpDrop?
>>
>
> I'm not sure pro or con of either. I just saw that proposal above recently.
>
>
>> Also, it is incorrect to say that OpReturn outputs "clog UTXO space". The
>> whole point of OpReturn is to standardize a way to keep such outputs out of
>> the UTXO set. There is the 75% discount to using witness space. But
>> considering the size of a transaction as a whole using taproot instead of
>> OpReturn doesn't save much.
>>
>
> There are OP_RETURN tricks in production that do clog UTXO space. I was
> trying to avoid consideration of those by just saying to compare apples vs.
> apples, by presuming that any form of these transactions holding the 64
> bytes is a spent transaction.
>
> Finally, _64_ bytes is more than a mere 32 byte commitment. What specific
>> use case do you actually have in mind here? Are you actually publishing
>> data, or simply committing to data? If the latter, you can use ECC
>> commitments and have no extra space at all.
>>
>
> I chose 64 bytes for this exercise, as I know there are tricks hiding 32
> bytes as keys. As almost every op_return live out there is >32 bytes, I
> wanted an example that could be a signature, two hashes, a hash plus some
> metadata, etc. I also considered 96 bytes (for instance a hash and a
> signature), but as that doesn't fit into OP_RETURN's 80 bytes, that choice
> prohibits comparing the different approaches side-by-side.
>
> To come back to my question another way, if you ignore the people who say
> "never put anything except data facilitating coin transactions into the
> bitcoin blockchain", but if you also are not trying to use the bitcoin
> blockchain as a world database (ala ETH), what is the most pragmatic way to
> do so that minimizes any potential harm? The answer pre-taproot was
> OP_RETURN. What is it now?
>
> -- Christopher Allen
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230201/22b11f78/attachment-0001.html>

From aymeric at peersm.com  Wed Feb  1 12:59:40 2023
From: aymeric at peersm.com (Aymeric Vitte)
Date: Wed, 1 Feb 2023 13:59:40 +0100
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
Message-ID: <3e649ce0-f468-f4b4-d774-bc8d5a6ee0f8@peersm.com>

Could someone clarify what is the standard for OP_RETURN? As far as I
understand the data is limited to 80B and only one OP_RETURN is allowed
in one transaction, if not the tx is non standard, correct?

Then the debate can be to store in witness indeed

Or you can store in output addresses (with super big size), then you
will never be able to spend the dust and we have a utxo forever

In any case there is a storage workaround, probably others exist, not
sure why people are so opposed to a OP_RETURN bitcoin storage (I thought
the max size was 512B, but apparently I am wrong, 80B is ridiculous,
can't do anything with this, except bypassing this limit by other worse
means)

Storage is the main difference between bitcoin and other systems
(ethereum), without it, repeating myself here again the future of
bitcoin is very limited

PS: I saw the answer of Peter, I am proposing something else for
timestamp proofs

Le 01/02/2023 ? 01:46, Christopher Allen via bitcoin-dev a ?crit :
> All other things being equal, which is better if you need to place a
> 64-bytes into the Bitcoin blockchain? A traditional OP_RETURN or a
> spent taproot transaction such as:
>
> OP_FALSE
> OP_IF 
> OP_PUSH my64bytes
> OP_ENDIF
>
> I know that the anti-OP_RETURN folk would say ?neither.? But if there
> was no other choice for a particular protocol, such as a timestamp or
> a commitment, which is better? Or is there a safer place to put 64
> bytes that is more uncensorable but also does not clog UTXO space,
> only spent transaction `-txindex` space?
>
> My best guess was that the taproot method is better, but I suspect
> there might be some who disagree. I'd love to hear all sides.
>
> -- Christopher Allen
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Sophia-Antipolis, France
CV: https://www.peersm.com/CVAV.pdf
LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26
GitHub : https://www.github.com/Ayms
A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7
A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com
Peersm : http://www.peersm.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230201/0fed77e3/attachment-0001.html>

From jk_14 at op.pl  Wed Feb  1 22:04:11 2023
From: jk_14 at op.pl (jk_14 at op.pl)
Date: Wed, 01 Feb 2023 23:04:11 +0100
Subject: [bitcoin-dev] Pseudocode for robust tail emission
Message-ID: <176758349-19c366f8766ab77ad9e44ac64153e0d5@pmq1v.m5r2.onet>


'only' in this sentence: "only two orders of magnitude higher"
- is just like in this one:

"We're raising $100,000 for the Tesla S and we're not short of $99,900, we're only short of $99,000..."




W dniu 2023-01-22 16:13:42 u?ytkownik John Tromp via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> napisa?:
> > Right now the total reward per transaction is $63, three orders of magnitude
> higher than typical fees.

No need to exaggerate; this is only two orders of magnitude higher
than current fees, which are typically over $0.50
_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From naumenko.gs at gmail.com  Thu Feb  2 08:40:04 2023
From: naumenko.gs at gmail.com (Gleb Naumenko)
Date: Thu, 2 Feb 2023 10:40:04 +0200
Subject: [bitcoin-dev] Costless bribes against time-sensitive protocols
In-Reply-To: <a0898fd1-88db-41b0-97b3-a1c7a1640b39@Spark>
References: <a0898fd1-88db-41b0-97b3-a1c7a1640b39@Spark>
Message-ID: <f594c2f8-d712-48e4-a010-778dd4d0cadb@Spark>

## Intro

Most of it feels like implicit knowledge, but I couldn't find anything written so here it is. The ideas towards anchor outputs and the conclusions probably have some new perspectives.

This post is about the game-theoretic security of time-sensitive protocols if miners are open to censorship for a reward. To become practical, the following has to happen.

1) a substantial hashrate has to be willing to participate in this behaviour, according to the known formula from the Whitepaper. The more blocks it takes to attack (defined by a particular protocol configuration and could be tuned), the exponentially higher % hashrate is required.

2) a communication layer is required to send bribes to these miners. This could be a private transaction relay network, or a mempool allowing still-time-locked transactions. It could be even an announcement board (e.g., submitting raw txs under a Twitter hashtag and inviting miners to monitor it).

3) a bribe transaction construction (will be explained later).

In this post, I talk about the case when:
1. a significant hashrate (e.g., 95%+) is open to take these bribes;
2. but miners don't trust each other;
3. and there is no reorgs.

Assumption \*(2) is more nuanced. What I mean here is roughly "miner X would rather take an immediate gain than commit to a lenghty scenario where many miners coordinate to take reward on behalf of each other and then distribute it accordingly to the hashrate". The game theory of this assumption should be better defined in the future.

We will see, how widely known tweaks lift the bar for (2) and (3) and how this could be further improved.

*A special case of this scenario is miners withholding Alice's transaction to force her to bump fees, even if Bob hasn't submitted a bribe. Here I assume miners won't do it unless there is an external incentive (Bob's bribe), although this issue is also interesting.*

## Simple opcode-based construction

The simplest time-sensitive two-party contract is PowSwap (a bet on the future block issuance rate), a single on-chain UTXO with the following spending conditions:
- Alice?s key can spend if height=H is reached;
- Bob?s key can spend if Time=T is reached.

Say H is approaching quickly, and T is far behind. Bob now uses a private mining relay to submit his non-mineable transaction paying e.g. half of the UTXO value towards fees.

Alice has two problems: 1) she can?t figure out why her transaction isn?t mined and how much fee to overpay; 2) the attack is free for Bob (he has nothing to lose), while Alice loses everything up to the full UTXO value.

## Simple nLockTime-based construction

If parties use pre-signed transactions with nLockTime (instead of the opcodes), Bob?s fee can be pre-signed to a rather low value, so that Alice can reasonably overbid it without much loss (she probably doesn't even need to take any action).

Bob can, however, bump the fee by creating a CPFP transaction with super-high fee. All it requires now is submitting twice as much data to the private mining relay (and burning slightly more in fees).

## nLockTime-based construction with OP_CSV output

If Bob?s output can?t be spent right away, but is forced to be deterred to even one block in the future, it makes taking this bribe not rational: a censoring miner can?t be sure about the deferred reward (remember, miners don't trust each other). At the same time, mining the honest transaction and taking its fee is always available earlier.

Smart contracts could possibly make it rational for miners (see [1]), e.g. by allowing Bob to allocate the bribe based on the historic hashrate distribution linked to coinbase pubkeys.

At the same time, this approach makes dynamic fee management impossible.

## Anchor outputs

Anchor outputs allow bringing external capital for fee management while locking internal capital. Bob can use this capital for a bribe. If the attack fails, Bob's external capital remains safe, so this is not so bad for Bob.

The attack can be more costly if this external capital was claimable:
- by Alice: e.g., Alice can steal a (covenanted) anchor output if it's revealed before Bob's nLockTime makes it mineable (requires her to monitor the private relay);
- or by miners, e.g. if Alice forces Bob, at contract setup, to use a reverse time-lock (the anchor can be stolen by miner if seen before time=T); or if mining Alice's honest transaction also allows miners to take Bob's fee output (e.g., Alice's honest transaction *could* act as a parent/preimage, conditionally, although this may require reverse time-locking Alice to protect Bob...)

*Ephemeral anchors doesn?t do much w.r.t. our trade-off, as it is a mempool-oriented thing.*

## Lightning

Lightning is different from the described protocol in two things:
1) It relies on intermediate transactions (e.g., Commitment in Poon-Dryja);
2) Usually both parties have some balance in the channel.

I believe that (1) doesn?t change the situation much, it just makes it more nuanced.
(2) is irrelevant because an attacker can just spend the entire channel before the attack.
Thus, most of these concerns apply to lightning equally.

## Related work

The LN paper briefly mentioned this problem, although it was claimed impractical due to a high degree of required collusion. We already see private mining relay in?mevwatch.info?(ethereum), and we had FIBRE (I think it was neutral).

[2] discussed constructions and economics for bribing miners. [1] suggests more practical considerations for achieving this. Both don?t focus on the risks of particular time-sensitive protocol constructions.

[3] highlighted a similar protocol risk, but the proposed solution seems to work only if an attacker has funds to lose locked in the contract (e.g., collateral, lightning balance, powswap payout).

## Conclusions

To increase the attack bar w.r.t the configuration described in the intro, we should either:
- stick to the *nLockTime-based construction with OP_CSV output*, forget about dynamic fee management, and hope that bribe allocation smart contracts doesn't work out;
- use anchor outputs (or another external fee scheme), but enforce a way to steal/burn the external fee if it's an attack;
- design new fee/channel constructions.

These ideas may also be helpful for alternative payment channels designs as well (v3+ephemeral anchors, SIGHASH_GROUP, etc.), or in the future to protect against more powerful covenants allowing stronger bribes (see [1]).

Thanks to Antoine Riard and Greg Sanders for initial discussion.

-------------------------

## References

1. TxWithhold Smart Contracts by Gleb Naumenko | BitMEX Blog (https://blog.bitmex.com/txwithhold-smart-contracts/)
2. Temporary Censorship Attacks in the Presence of Rational Miners (https://eprint.iacr.org/2019/748.pdf)
3. MAD-HTLC: Because HTLC is Crazy-Cheap to Attack (https://arxiv.org/pdf/2006.12031.pdf)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/275a0387/attachment.html>

From aj at erisian.com.au  Thu Feb  2 09:15:33 2023
From: aj at erisian.com.au (Anthony Towns)
Date: Thu, 2 Feb 2023 19:15:33 +1000
Subject: [bitcoin-dev] Purely off-chain coin colouring
Message-ID: <Y9t/NcgRzv1w//Fx@erisian.com.au>

Hi *,

Casey Rodarmor's ordinals use the technique of tracking the identity of
individual satoshis throughout their lifetime:

On Tue, Feb 22, 2022 at 04:43:52PM -0800, Casey Rodarmor via bitcoin-dev wrote:
> Briefly, newly mined satoshis are sequentially numbered in the order in
> which they are mined. These numbers are called "ordinal numbers" or
> "ordinals". When satoshis are spent in a transaction, the input satoshi
> ordinal numbers are assigned to output satoshis using a simple
> first-in-first-out algorithm.

This is proposed as a BIP at https://github.com/bitcoin/bips/pull/1408

When accompanied by a standard for associating some data or right with
such an identity, this allows the creation of non-fungible tokens (or
semi-fungible tokens) whose ownership can be transferred by a bitcoin
transaction.

The proposed BIP doesn't document any method for associating data or a
right with an ordinal, but the "ord" tool defines "inscriptions" to fill
this gap [0], providing a way of including mime-encoded data in a taproot
witness. To make such an inscription, two transactions are required:
one paying some sats to a special scriptPubKey that commits to the
inscribed data, and a second that spends those sats to the owner of the
newly inscribed ordinal, and in so doing revealing the full inscription.

[0] https://docs.ordinals.com/inscriptions.html

I think, however, that you can move inscriptions entirely off-chain. I
wrote a little on this idea on twitter already [1], but after a bit more
thought, I think pushing things even further off-chain would be plausible.

[1] https://twitter.com/ajtowns/status/1619554871166013441

In particular, rather than looking at it as being the owner of the sats
that inscribes some content on those sats (analogously to signing a $100
bill [2]), you could look at it as saying "the owner of this thing is
whoever owns this particular sat" (eg instead of "whoever owns this
share certificate is a shareholder", it's "whoever owns the $1 bill with
serial number X is a shareholder").

[2] https://www.espn.com/nfl/story/_/id/14375536/owner-100-bill-autograph-cleveland-browns-qb-johnny-manziel-getting-offers

Implementing that is fairly straightforward: you just need a protocol
for creating an asset offchain and associating it with an ordinal --
nothing needs to happen on-chain at all. That is, you can do something
as simple as posting a single nostr message:

  {
    "pubkey": <creator's pubkey>
    "kind": 0,
    "tags": [
      ["ord", "txid:vout:sat"]
    ],
    "content": [jpeg goes here],
    "id": <hash of the above>
    "sig": <signature of id by creator's pubkey>
  }

You can prove current ownership of the message by showing a custody
chain, that is the transaction specified by "txid" in the "ord" tag,
then every transaction that spent the given sat, until you get to one
that's still in the utxo set [3]. You don't need to provide witness
data or validate any of these tx's signatures, as that is already
implicit in that you end up at a tx in the utxo set. Just calculating
the txids and comparing against the output containing the sat you're
interested in is sufficient.

[3] If the satoshi was lost to fees at some point, you could continue to
    follow ownership by including an entire block in the custody chain.
    But seems better to just consider it as "abandoned" or "lost to the
    public domain" at that point.

This approach allows all the "inscription" data to be entirely off-chain,
the only thing that requires a transaction on-chain is transferring
ownership to someone else. That allows the NFT's existance can be kept
entirely private if desired; it also makes it cheap to create a new NFT
(you don't need to pay any on-chain fees at all); and it doesn't impose
an outsized overhead on people who aren't interested in your inscriptions,
but may be interested either in bitcoin per se, or in other inscriptions.

For things that have real intrinsic value -- equity rights in a company,
bragging rights for supporting an artist, etc -- this seems like it's
probably a viable approach: owners can "self-custody" all the information
about the things they own without having to rely on third parties,
transfers are no more censorable than any other bitcoin transaction
(especially if the association of the NFT with some particular sat is
not widely known), etc.

The "inscription" approach might still be desirable for broadcasting
information that might otherwise be subject to heavy censorship; presuming
that the censoring entity isn't also willing and able to censor bitcoin
itself. It's not clear that there's any "rights" to be owned for such a
case -- you can't buy the right to be the person that first published
it, and the point of widely broadcasting the information is so it's
not a secret only known to a few anymore. Also, claiming ownership of
such information would presumably make you a target for the censor,
even if just as an example for others. So I'm dubious of the value of
associating an inscription with an ordinal for that use case.

It's also possible that the perceived value of the NFT isn't due to
the inscription, but rather due to the scarcity of the blockspace it
was inscribed in (eg [4]). This is different from Bitcoin's scarcity
-- by 2100 or so there'll be a total of 2100T satoshis available,
but in that same time there will only have been about 4T vbytes of
blockspace available, and perhaps it could make sense to value spent
vbytes proportionally, so 4 spent vbytes is worth 2100 sats. In that
case if you spent 50kvb inscribing a jpeg, perhaps the "rights" to that
jpeg should be worth the same as 50k/4*2100 sats or 0.26 BTC. Doesn't
seem like a sound argument to me -- there's always more blockspace being
created, by fewer and fewer sats being created, and ordinals are far more
awkward to deal with, but I suppose it's still conceivable, and people
at least claim to believe it. If it were true, this argument suggests
the price for blockspace today should be around 2488sat/vB (19.28MBTC /
774700 MvB), rather than 1sat/vB.

[4] https://twitter.com/vnprc/status/1619876888687820801

Anyway, comparisons to ordinal inscriptions aside, I think there's
another interesting point from all this.

Presume you have a tool that implements the nostr ordinal assignment
suggested above: that is, a small modification of the "ord" tool that
can track a chain of custody for an ordinal specified in a nostr event
like the above. That allows you to do NFTs completely unobservably --
you don't have to publish anything to the blockchain apart from ordinary
looking transactions to transfer ownership of your NFT. To your benefit,
that makes it hard for anyone to censor you; but to bitcoin more broadly,
I think it means that the possibility of coloured bitcoins is largely
unavoidable and simply something that must be dealt with, rather than
something we should spend time trying to prevent/avoid. Compare with:

> My personal, and possibly controversial, opinion is that colored coin
> protocols have no business being on the Bitcoin chain, possibly beyond
> committing to an occasional batched state update or so. Both because
> there is little benefit for tokens with a trusted issuer already, and
> because it competes with using Bitcoin for BTC - the token that pays
> for its security (at least as long as the subsidy doesn't run out).
>
> Of course, personal opinions are no reason to dictate what people should
> or can use the chain for, but I do think it's reason to voice hesitancy
> to worsening the system's scalability properties only to benefit what
> I consider misguided use.

 -- https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019500.html

I don't think this actually results in majorly misaligned incentives
though: in the nostr-nfts-on-btc world, everyone is still optimising
bitcoin transactions for the same thing -- transfer of value. It's just
that in some cases some sats are valued differently than others --
perhaps my uninscribed sats are worth 0.025 cents each, but you have
a particular inscribed sat that's worth $100k. But we're both dealing
just spending utxos and creating new utxos, doing signatures and maybe
some timelocks or hash reveals. And it's always been possible that
your transaction transferring $100k won't get charged higher fees than
my transfer of $50 -- we care about transaction size, not value after
all. How much does it matter if your tx matters more to your because
someone wants your particular sat, rather than what could happen today
where you have a utxo with 4 BTC while my utxo only has 0.002 BTC?

I think the only way to prevent that sort of NFT structure would be
to have every transaction use fancy zero-knowledge proofs that make it
impossible to associate who received bitcoin with who spent it -- *even
if* both the sender and recipient were willing to cooperate to reveal
that information. I think it would be hard to achieve that while still
making it easy to audit bitcoin's total supply, but I might be wrong.

Note that off-chain colouring here means that someone can create an NFT
that you don't want it, and just assign it to a sat that's already in your
wallet. However, they can do this anyway, by first creating the NFT, then
sending it to your wallet address. A difference though is that they could
create an NFT and assign it to the same ordinal/sat as some existing NFT
that you do value, at which point it's (presumably) impossible to discard
one without discarding both. But again, this is simply something they
can do, just be writing a patch to ord and composing a nostr message;
it's not something you can actually prevent even if you dislike it.

Particularly for semi-fungible tokens, this is perhaps inferior to
Liquid's multi-asset model -- here if you have a utxo with 1M sats, 500
of which are inscribed to each represent rights to $1 worth of USDT,
then rather than acting like a stable coin and being worth $500; it's
actually worth $500+0.01BTC, which is more like $750, and changes as
the value of bitcoin changes.

Cheers,
aj

From pete at petertodd.org  Thu Feb  2 11:22:23 2023
From: pete at petertodd.org (Peter Todd)
Date: Thu, 2 Feb 2023 06:22:23 -0500
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <Y9pxAdm3kO1rr2kU@camus>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <764E460B-C0C6-47B8-A97E-F7CBC81FD645@petertodd.org>
 <Y9pxAdm3kO1rr2kU@camus>
Message-ID: <Y9uc72RSs6LQojG4@petertodd.org>

On Wed, Feb 01, 2023 at 02:02:41PM +0000, Andrew Poelstra wrote:
> On Tue, Jan 31, 2023 at 09:07:16PM -0500, Peter Todd via bitcoin-dev wrote:
> > 
> > 
> > On January 31, 2023 7:46:32 PM EST, Christopher Allen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > >All other things being equal, which is better if you need to place a
> > >64-bytes into the Bitcoin blockchain? A traditional OP_RETURN or a spent
> > >taproot transaction such as:
> > >
> > >OP_FALSE
> > >OP_IF
> > >OP_PUSH my64bytes
> > >OP_ENDIF
> > 
> > What's wrong with OpPush <data> OpDrop?
> >
> 
> This is a technical nit, but the reason is that <data> is limited to 520
> bytes (and I believe, 80 bytes by standardness in Taproot), so if you
> are pushing a ton of data and need multiple pushes, it's more efficient
> to use FALSE IF ... ENDIF since you avoid the repeated DROPs.

Yes, for more than 520 bytes you need to wrap the push in an IF/ENDIF so it's
not executed. But in this example we're just talking about 64 bytes, so that
limit isn't relevant and OpPush <data> OpDrop should be sufficient.

Specifically for more than 520 bytes you run into the the
MAX_SCRIPT_ELEMENT_SIZE check in script/interpreter.cpp, which applies to all
scripts regardless of standardness at script execution:

           //
           // Read instruction
           //
           if (!script.GetOp(pc, opcode, vchPushValue))
               return set_error(serror, SCRIPT_ERR_BAD_OPCODE);
           if (vchPushValue.size() > MAX_SCRIPT_ELEMENT_SIZE)
               return set_error(serror, SCRIPT_ERR_PUSH_SIZE);

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/aa281e02/attachment.sig>

From pete at petertodd.org  Thu Feb  2 11:49:32 2023
From: pete at petertodd.org (Peter Todd)
Date: Thu, 2 Feb 2023 06:49:32 -0500
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <16446c77-c9de-7b11-8e66-7f8e20421cba@peersm.com>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <764E460B-C0C6-47B8-A97E-F7CBC81FD645@petertodd.org>
 <Y9pxAdm3kO1rr2kU@camus> <Y9uc72RSs6LQojG4@petertodd.org>
 <16446c77-c9de-7b11-8e66-7f8e20421cba@peersm.com>
Message-ID: <Y9ujTCAv+/du+zNU@petertodd.org>

On Thu, Feb 02, 2023 at 12:45:42PM +0100, Aymeric Vitte wrote:
> As far as I can read nobody replied to the initial question: what is
> considered as good/best practice to store in Bitcoin?

Your answer is beyond not putting unspendable data in the UTXO set, the exact
details don't really matter. Do what makes sense for your specific application.

> Reiterating my question: what are the current rules for OP_RETURN, max
> size and number of OP_RETURN per tx

Max 80 bytes, one OpReturn output per tx.

This of course is the standardness rule. With a miner willing to mine non-std
transactions anything goes.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/e757e764/attachment.sig>

From aymeric at peersm.com  Thu Feb  2 11:45:42 2023
From: aymeric at peersm.com (Aymeric Vitte)
Date: Thu, 2 Feb 2023 12:45:42 +0100
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <Y9uc72RSs6LQojG4@petertodd.org>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <764E460B-C0C6-47B8-A97E-F7CBC81FD645@petertodd.org> <Y9pxAdm3kO1rr2kU@camus>
 <Y9uc72RSs6LQojG4@petertodd.org>
Message-ID: <16446c77-c9de-7b11-8e66-7f8e20421cba@peersm.com>

As far as I can read nobody replied to the initial question: what is
considered as good/best practice to store in Bitcoin?

Reiterating my question: what are the current rules for OP_RETURN, max
size and number of OP_RETURN per tx


Le 02/02/2023 ? 12:22, Peter Todd via bitcoin-dev a ?crit :
> On Wed, Feb 01, 2023 at 02:02:41PM +0000, Andrew Poelstra wrote:
>> On Tue, Jan 31, 2023 at 09:07:16PM -0500, Peter Todd via bitcoin-dev wrote:
>>>
>>> On January 31, 2023 7:46:32 PM EST, Christopher Allen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>> All other things being equal, which is better if you need to place a
>>>> 64-bytes into the Bitcoin blockchain? A traditional OP_RETURN or a spent
>>>> taproot transaction such as:
>>>>
>>>> OP_FALSE
>>>> OP_IF
>>>> OP_PUSH my64bytes
>>>> OP_ENDIF
>>> What's wrong with OpPush <data> OpDrop?
>>>
>> This is a technical nit, but the reason is that <data> is limited to 520
>> bytes (and I believe, 80 bytes by standardness in Taproot), so if you
>> are pushing a ton of data and need multiple pushes, it's more efficient
>> to use FALSE IF ... ENDIF since you avoid the repeated DROPs.
> Yes, for more than 520 bytes you need to wrap the push in an IF/ENDIF so it's
> not executed. But in this example we're just talking about 64 bytes, so that
> limit isn't relevant and OpPush <data> OpDrop should be sufficient.
>
> Specifically for more than 520 bytes you run into the the
> MAX_SCRIPT_ELEMENT_SIZE check in script/interpreter.cpp, which applies to all
> scripts regardless of standardness at script execution:
>
>            //
>            // Read instruction
>            //
>            if (!script.GetOp(pc, opcode, vchPushValue))
>                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);
>            if (vchPushValue.size() > MAX_SCRIPT_ELEMENT_SIZE)
>                return set_error(serror, SCRIPT_ERR_PUSH_SIZE);
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Sophia-Antipolis, France
CV: https://www.peersm.com/CVAV.pdf
LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26
GitHub : https://www.github.com/Ayms
A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7
A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com
Peersm : http://www.peersm.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/13100de1/attachment.html>

From aymeric at peersm.com  Thu Feb  2 12:19:28 2023
From: aymeric at peersm.com (Aymeric Vitte)
Date: Thu, 2 Feb 2023 13:19:28 +0100
Subject: [bitcoin-dev] Purely off-chain coin colouring
In-Reply-To: <Y9t/NcgRzv1w//Fx@erisian.com.au>
References: <Y9t/NcgRzv1w//Fx@erisian.com.au>
Message-ID: <b20268b5-839c-1939-528c-0504b64860b1@peersm.com>

In your system what is the off-chain mechanism? And what prevent a thief
to steal your NFT?

I have submitted several time "A Bitcoin NFT system"
https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7

It's more simple, the NFT (whether real or electronic) is referenced by
a initial hash (which is not the hash for example of your jpeg file
because easy to fake) and then get a final reference which is the hash
of the initial hash

The idea is that the real owner must prove that he has the knowledge of
the initial hash (for example luxury bag, you print the double hash on
it, and give the initial hash to the buyer, if the owner/seller can't
prove that he knows the inital hash, the bag is stolen or counterfeit
(with the double hash))

The NFT owner references the NFT signed by him in some trusted third
party allowing a timestanp (wayback machine for example), it proves that
he is the first one to have the knowledge of the double hash, so a thief
cannot intercept the "minting" transaction (if any because not really
necessary since the public key of the owner is known from the third
party) and steal the NFT for himself or do/replay a transaction with
this NFT, minting it or selling it several time

A third party is involved but it remains decentralized

Then the NFT owner and buyer exchange some information like for
lightning and do one transaction on Bitcoin storing the deal, see the
details in the proposals depending on what kind of deal occur between
the buyer and the seller, like lightning, if someone cheats, then he
loses his bitcoin

It's minimal, understandable, secured, decentralized and not expensive,
that's why I don't see very well why to complicate with ordinals

The proposal envisions the concept of "secret" NFTs also


The continuation of this proposal is "A Universal Coin Swap system based
on Bitcoin" https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7

It's simple also, you go from Decentraland to the Sandbox but don't have
SAND and want to pay with MANA, you agree on a MANA/SAND deal with the
seller which is stored in Bitcoin signed by both, then you pay with
MANA, other use cases are described in the proposal

Note: both proposals need to be modified since I thought OP_RETURN max
size was 512B and it is in fact 80B, which does not work for all cases


Le 02/02/2023 ? 10:15, Anthony Towns via bitcoin-dev a ?crit :
> Hi *,
>
> Casey Rodarmor's ordinals use the technique of tracking the identity of
> individual satoshis throughout their lifetime:
>
> On Tue, Feb 22, 2022 at 04:43:52PM -0800, Casey Rodarmor via bitcoin-dev wrote:
>> Briefly, newly mined satoshis are sequentially numbered in the order in
>> which they are mined. These numbers are called "ordinal numbers" or
>> "ordinals". When satoshis are spent in a transaction, the input satoshi
>> ordinal numbers are assigned to output satoshis using a simple
>> first-in-first-out algorithm.
> This is proposed as a BIP at https://github.com/bitcoin/bips/pull/1408
>
> When accompanied by a standard for associating some data or right with
> such an identity, this allows the creation of non-fungible tokens (or
> semi-fungible tokens) whose ownership can be transferred by a bitcoin
> transaction.
>
> The proposed BIP doesn't document any method for associating data or a
> right with an ordinal, but the "ord" tool defines "inscriptions" to fill
> this gap [0], providing a way of including mime-encoded data in a taproot
> witness. To make such an inscription, two transactions are required:
> one paying some sats to a special scriptPubKey that commits to the
> inscribed data, and a second that spends those sats to the owner of the
> newly inscribed ordinal, and in so doing revealing the full inscription.
>
> [0] https://docs.ordinals.com/inscriptions.html
>
> I think, however, that you can move inscriptions entirely off-chain. I
> wrote a little on this idea on twitter already [1], but after a bit more
> thought, I think pushing things even further off-chain would be plausible.
>
> [1] https://twitter.com/ajtowns/status/1619554871166013441
>
> In particular, rather than looking at it as being the owner of the sats
> that inscribes some content on those sats (analogously to signing a $100
> bill [2]), you could look at it as saying "the owner of this thing is
> whoever owns this particular sat" (eg instead of "whoever owns this
> share certificate is a shareholder", it's "whoever owns the $1 bill with
> serial number X is a shareholder").
>
> [2] https://www.espn.com/nfl/story/_/id/14375536/owner-100-bill-autograph-cleveland-browns-qb-johnny-manziel-getting-offers
>
> Implementing that is fairly straightforward: you just need a protocol
> for creating an asset offchain and associating it with an ordinal --
> nothing needs to happen on-chain at all. That is, you can do something
> as simple as posting a single nostr message:
>
>   {
>     "pubkey": <creator's pubkey>
>     "kind": 0,
>     "tags": [
>       ["ord", "txid:vout:sat"]
>     ],
>     "content": [jpeg goes here],
>     "id": <hash of the above>
>     "sig": <signature of id by creator's pubkey>
>   }
>
> You can prove current ownership of the message by showing a custody
> chain, that is the transaction specified by "txid" in the "ord" tag,
> then every transaction that spent the given sat, until you get to one
> that's still in the utxo set [3]. You don't need to provide witness
> data or validate any of these tx's signatures, as that is already
> implicit in that you end up at a tx in the utxo set. Just calculating
> the txids and comparing against the output containing the sat you're
> interested in is sufficient.
>
> [3] If the satoshi was lost to fees at some point, you could continue to
>     follow ownership by including an entire block in the custody chain.
>     But seems better to just consider it as "abandoned" or "lost to the
>     public domain" at that point.
>
> This approach allows all the "inscription" data to be entirely off-chain,
> the only thing that requires a transaction on-chain is transferring
> ownership to someone else. That allows the NFT's existance can be kept
> entirely private if desired; it also makes it cheap to create a new NFT
> (you don't need to pay any on-chain fees at all); and it doesn't impose
> an outsized overhead on people who aren't interested in your inscriptions,
> but may be interested either in bitcoin per se, or in other inscriptions.
>
> For things that have real intrinsic value -- equity rights in a company,
> bragging rights for supporting an artist, etc -- this seems like it's
> probably a viable approach: owners can "self-custody" all the information
> about the things they own without having to rely on third parties,
> transfers are no more censorable than any other bitcoin transaction
> (especially if the association of the NFT with some particular sat is
> not widely known), etc.
>
> The "inscription" approach might still be desirable for broadcasting
> information that might otherwise be subject to heavy censorship; presuming
> that the censoring entity isn't also willing and able to censor bitcoin
> itself. It's not clear that there's any "rights" to be owned for such a
> case -- you can't buy the right to be the person that first published
> it, and the point of widely broadcasting the information is so it's
> not a secret only known to a few anymore. Also, claiming ownership of
> such information would presumably make you a target for the censor,
> even if just as an example for others. So I'm dubious of the value of
> associating an inscription with an ordinal for that use case.
>
> It's also possible that the perceived value of the NFT isn't due to
> the inscription, but rather due to the scarcity of the blockspace it
> was inscribed in (eg [4]). This is different from Bitcoin's scarcity
> -- by 2100 or so there'll be a total of 2100T satoshis available,
> but in that same time there will only have been about 4T vbytes of
> blockspace available, and perhaps it could make sense to value spent
> vbytes proportionally, so 4 spent vbytes is worth 2100 sats. In that
> case if you spent 50kvb inscribing a jpeg, perhaps the "rights" to that
> jpeg should be worth the same as 50k/4*2100 sats or 0.26 BTC. Doesn't
> seem like a sound argument to me -- there's always more blockspace being
> created, by fewer and fewer sats being created, and ordinals are far more
> awkward to deal with, but I suppose it's still conceivable, and people
> at least claim to believe it. If it were true, this argument suggests
> the price for blockspace today should be around 2488sat/vB (19.28MBTC /
> 774700 MvB), rather than 1sat/vB.
>
> [4] https://twitter.com/vnprc/status/1619876888687820801
>
> Anyway, comparisons to ordinal inscriptions aside, I think there's
> another interesting point from all this.
>
> Presume you have a tool that implements the nostr ordinal assignment
> suggested above: that is, a small modification of the "ord" tool that
> can track a chain of custody for an ordinal specified in a nostr event
> like the above. That allows you to do NFTs completely unobservably --
> you don't have to publish anything to the blockchain apart from ordinary
> looking transactions to transfer ownership of your NFT. To your benefit,
> that makes it hard for anyone to censor you; but to bitcoin more broadly,
> I think it means that the possibility of coloured bitcoins is largely
> unavoidable and simply something that must be dealt with, rather than
> something we should spend time trying to prevent/avoid. Compare with:
>
>> My personal, and possibly controversial, opinion is that colored coin
>> protocols have no business being on the Bitcoin chain, possibly beyond
>> committing to an occasional batched state update or so. Both because
>> there is little benefit for tokens with a trusted issuer already, and
>> because it competes with using Bitcoin for BTC - the token that pays
>> for its security (at least as long as the subsidy doesn't run out).
>>
>> Of course, personal opinions are no reason to dictate what people should
>> or can use the chain for, but I do think it's reason to voice hesitancy
>> to worsening the system's scalability properties only to benefit what
>> I consider misguided use.
>  -- https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019500.html
>
> I don't think this actually results in majorly misaligned incentives
> though: in the nostr-nfts-on-btc world, everyone is still optimising
> bitcoin transactions for the same thing -- transfer of value. It's just
> that in some cases some sats are valued differently than others --
> perhaps my uninscribed sats are worth 0.025 cents each, but you have
> a particular inscribed sat that's worth $100k. But we're both dealing
> just spending utxos and creating new utxos, doing signatures and maybe
> some timelocks or hash reveals. And it's always been possible that
> your transaction transferring $100k won't get charged higher fees than
> my transfer of $50 -- we care about transaction size, not value after
> all. How much does it matter if your tx matters more to your because
> someone wants your particular sat, rather than what could happen today
> where you have a utxo with 4 BTC while my utxo only has 0.002 BTC?
>
> I think the only way to prevent that sort of NFT structure would be
> to have every transaction use fancy zero-knowledge proofs that make it
> impossible to associate who received bitcoin with who spent it -- *even
> if* both the sender and recipient were willing to cooperate to reveal
> that information. I think it would be hard to achieve that while still
> making it easy to audit bitcoin's total supply, but I might be wrong.
>
> Note that off-chain colouring here means that someone can create an NFT
> that you don't want it, and just assign it to a sat that's already in your
> wallet. However, they can do this anyway, by first creating the NFT, then
> sending it to your wallet address. A difference though is that they could
> create an NFT and assign it to the same ordinal/sat as some existing NFT
> that you do value, at which point it's (presumably) impossible to discard
> one without discarding both. But again, this is simply something they
> can do, just be writing a patch to ord and composing a nostr message;
> it's not something you can actually prevent even if you dislike it.
>
> Particularly for semi-fungible tokens, this is perhaps inferior to
> Liquid's multi-asset model -- here if you have a utxo with 1M sats, 500
> of which are inscribed to each represent rights to $1 worth of USDT,
> then rather than acting like a stable coin and being worth $500; it's
> actually worth $500+0.01BTC, which is more like $750, and changes as
> the value of bitcoin changes.
>
> Cheers,
> aj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Sophia-Antipolis, France
CV: https://www.peersm.com/CVAV.pdf
LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26
GitHub : https://www.github.com/Ayms
A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7
A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com
Peersm : http://www.peersm.com


From aymeric at peersm.com  Thu Feb  2 12:24:12 2023
From: aymeric at peersm.com (Aymeric Vitte)
Date: Thu, 2 Feb 2023 13:24:12 +0100
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <Y9ujTCAv+/du+zNU@petertodd.org>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <764E460B-C0C6-47B8-A97E-F7CBC81FD645@petertodd.org> <Y9pxAdm3kO1rr2kU@camus>
 <Y9uc72RSs6LQojG4@petertodd.org>
 <16446c77-c9de-7b11-8e66-7f8e20421cba@peersm.com>
 <Y9ujTCAv+/du+zNU@petertodd.org>
Message-ID: <67fd09e8-f70b-c1be-78c3-f3ec936dfee8@peersm.com>

Thanks, then this limitation should be rethought I think (see the email
I just sent replying to the coloured thread)

Because it forces people to store in witness (less easy to track/show I
believe) or adopt some deviant behavior (like storing in addresses where
the utxo will remain unspendable forever)


Le 02/02/2023 ? 12:49, Peter Todd a ?crit :
> On Thu, Feb 02, 2023 at 12:45:42PM +0100, Aymeric Vitte wrote:
>> As far as I can read nobody replied to the initial question: what is
>> considered as good/best practice to store in Bitcoin?
> Your answer is beyond not putting unspendable data in the UTXO set, the exact
> details don't really matter. Do what makes sense for your specific application.
>
>> Reiterating my question: what are the current rules for OP_RETURN, max
>> size and number of OP_RETURN per tx
> Max 80 bytes, one OpReturn output per tx.
>
> This of course is the standardness rule. With a miner willing to mine non-std
> transactions anything goes.
>

-- 
Sophia-Antipolis, France
CV: https://www.peersm.com/CVAV.pdf
LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26
GitHub : https://www.github.com/Ayms
A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7
A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com
Peersm : http://www.peersm.com


From rot13maxi at protonmail.com  Thu Feb  2 13:25:41 2023
From: rot13maxi at protonmail.com (Rijndael)
Date: Thu, 02 Feb 2023 13:25:41 +0000
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
	OP_IF OP_PUSH
In-Reply-To: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
Message-ID: <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>

Hello Christopher,

I think if the protocol that you were designing always had <80 bytes,
I'd prefer the OP_RETURN. I think the "witness envelope" has two major
disadvantages compared to the OP_RETURN method:

1. You need to first spend to he address that commits to the script that
encodes your data payload. So you have a two step process of first
spending to a "commitment" address and then a second spend to "reveal"
your payload. You can CPFP to get them both into the same block, but its
still two transactions, so more cost, etc.

2. Because of the two step process in (1), if for some reason you were
unable to get the "reveal" transaction into a block (for example there's
widespread censorship of transactions that match the format of the
"reveal" script), then you might have money that's stuck in the "commit"
stage of the protocol. The way out of this would be to get your money
out via the keypath or another tapleaf, but then you need to spend money
to cancel a step in your protocol. Of course there could be widespread
censorship of your OP_RETURNs too, but you don't have to spend funds on
the cancellation spends.

I think (2) is actually a pretty weak argument because as we saw in the
full-rbf discussion, as long as there's some threshold number of nodes
in the network that relay transactions to miners, you can probably find
a path to a miner (IIRC the number was on the order of 15% of the
network?). So I think the big reason to pick OP_RETURN over the witness
embedding is that you save a transaction and possibly some
failure-recovery/cancellation logic.

Obviously if your data is larger than 80 bytes, then you probably want
to do the witness-embedding method. If your data smaller, then a
pay-to-contract tweak probably the best thing from a space and
fingerprinting perspective.

- rijndael


On 1/31/23 7:46 PM, Christopher Allen via bitcoin-dev wrote:
> All other things being equal, which is better if you need to place a
> 64-bytes into the Bitcoin blockchain? A traditional?OP_RETURN?or a
> spent taproot transaction such as:
>
> OP_FALSE
> OP_IF
> OP_PUSH my64bytes
> OP_ENDIF
>
> I know that the anti-OP_RETURN folk would say ?neither.? But if there
> was no other choice for a particular protocol, such as a timestamp or
> a commitment, which is better? Or is there a safer place to put 64
> bytes that is more uncensorable but also does not clog UTXO space,
> only spent transaction `-txindex` space?
>
> My best guess was that the taproot method is better, but I suspect
> there might be some who disagree. I'd love to hear all sides.
>
> -- Christopher Allen
>


From rot13maxi at protonmail.com  Thu Feb  2 13:46:35 2023
From: rot13maxi at protonmail.com (Rijndael)
Date: Thu, 02 Feb 2023 13:46:35 +0000
Subject: [bitcoin-dev] Purely off-chain coin colouring
In-Reply-To: <Y9t/NcgRzv1w//Fx@erisian.com.au>
References: <Y9t/NcgRzv1w//Fx@erisian.com.au>
Message-ID: <72f76cbc-c62f-743f-71e9-3ae61f3fdc33@protonmail.com>

Hi AJ and List,

This reminds me of a series of blog posts Peter Todd wrote a few years
ago about using "single use seals" for tracking (fungible) assets
anchored to Bitcoin[0]. I believe that the RBG Protocol Project and Taro
are both using the same underlying principle.

Having the actual application data offchain, but with a commitment to a
UTXO and then using Bitcoin only as a proof-of-publication system to
prevent double-spends seems like a really good idea. As you point out,
in addition to being cheaper and more scalable, it means that not
everyone on the network has to know that there's an asset involved. It
just looks like plain old bitcoin transfers.

A lot of people have written about or are (I think) working on
implementations of this idea. I really like your suggestion of using
nostr. Clients can keep the asset metadata chains locally in their
client and (re)broadcast them to application-specific nostr relays, or
to general public relays depending on application needs. Maybe there's a
marketplace application that has its own relays and also broadcasts
asset metadata to relays used by popular gallery systems. Or maybe your
client just sends to any relay it sees that doesnt have the event. Big
design space there.

- rijndael

0: https://petertodd.org/2017/scalable-single-use-seal-asset-transfer


On 2/2/23 4:15 AM, Anthony Towns via bitcoin-dev wrote:
> Hi *,
>
> Casey Rodarmor's ordinals use the technique of tracking the identity of
> individual satoshis throughout their lifetime:
>
> On Tue, Feb 22, 2022 at 04:43:52PM -0800, Casey Rodarmor via bitcoin-dev wrote:
>> Briefly, newly mined satoshis are sequentially numbered in the order in
>> which they are mined. These numbers are called "ordinal numbers" or
>> "ordinals". When satoshis are spent in a transaction, the input satoshi
>> ordinal numbers are assigned to output satoshis using a simple
>> first-in-first-out algorithm.
> This is proposed as a BIP at https://github.com/bitcoin/bips/pull/1408
>
> When accompanied by a standard for associating some data or right with
> such an identity, this allows the creation of non-fungible tokens (or
> semi-fungible tokens) whose ownership can be transferred by a bitcoin
> transaction.
>
> The proposed BIP doesn't document any method for associating data or a
> right with an ordinal, but the "ord" tool defines "inscriptions" to fill
> this gap [0], providing a way of including mime-encoded data in a taproot
> witness. To make such an inscription, two transactions are required:
> one paying some sats to a special scriptPubKey that commits to the
> inscribed data, and a second that spends those sats to the owner of the
> newly inscribed ordinal, and in so doing revealing the full inscription.
>
> [0] https://docs.ordinals.com/inscriptions.html
>
> I think, however, that you can move inscriptions entirely off-chain. I
> wrote a little on this idea on twitter already [1], but after a bit more
> thought, I think pushing things even further off-chain would be plausible.
>
> [1] https://twitter.com/ajtowns/status/1619554871166013441
>
> In particular, rather than looking at it as being the owner of the sats
> that inscribes some content on those sats (analogously to signing a $100
> bill [2]), you could look at it as saying "the owner of this thing is
> whoever owns this particular sat" (eg instead of "whoever owns this
> share certificate is a shareholder", it's "whoever owns the $1 bill with
> serial number X is a shareholder").
>
> [2] https://www.espn.com/nfl/story/_/id/14375536/owner-100-bill-autograph-cleveland-browns-qb-johnny-manziel-getting-offers
>
> Implementing that is fairly straightforward: you just need a protocol
> for creating an asset offchain and associating it with an ordinal --
> nothing needs to happen on-chain at all. That is, you can do something
> as simple as posting a single nostr message:
>
>    {
>      "pubkey": <creator's pubkey>
>      "kind": 0,
>      "tags": [
>        ["ord", "txid:vout:sat"]
>      ],
>      "content": [jpeg goes here],
>      "id": <hash of the above>
>      "sig": <signature of id by creator's pubkey>
>    }
>
> You can prove current ownership of the message by showing a custody
> chain, that is the transaction specified by "txid" in the "ord" tag,
> then every transaction that spent the given sat, until you get to one
> that's still in the utxo set [3]. You don't need to provide witness
> data or validate any of these tx's signatures, as that is already
> implicit in that you end up at a tx in the utxo set. Just calculating
> the txids and comparing against the output containing the sat you're
> interested in is sufficient.
>
> [3] If the satoshi was lost to fees at some point, you could continue to
>      follow ownership by including an entire block in the custody chain.
>      But seems better to just consider it as "abandoned" or "lost to the
>      public domain" at that point.
>
> This approach allows all the "inscription" data to be entirely off-chain,
> the only thing that requires a transaction on-chain is transferring
> ownership to someone else. That allows the NFT's existance can be kept
> entirely private if desired; it also makes it cheap to create a new NFT
> (you don't need to pay any on-chain fees at all); and it doesn't impose
> an outsized overhead on people who aren't interested in your inscriptions,
> but may be interested either in bitcoin per se, or in other inscriptions.
>
> For things that have real intrinsic value -- equity rights in a company,
> bragging rights for supporting an artist, etc -- this seems like it's
> probably a viable approach: owners can "self-custody" all the information
> about the things they own without having to rely on third parties,
> transfers are no more censorable than any other bitcoin transaction
> (especially if the association of the NFT with some particular sat is
> not widely known), etc.
>
> The "inscription" approach might still be desirable for broadcasting
> information that might otherwise be subject to heavy censorship; presuming
> that the censoring entity isn't also willing and able to censor bitcoin
> itself. It's not clear that there's any "rights" to be owned for such a
> case -- you can't buy the right to be the person that first published
> it, and the point of widely broadcasting the information is so it's
> not a secret only known to a few anymore. Also, claiming ownership of
> such information would presumably make you a target for the censor,
> even if just as an example for others. So I'm dubious of the value of
> associating an inscription with an ordinal for that use case.
>
> It's also possible that the perceived value of the NFT isn't due to
> the inscription, but rather due to the scarcity of the blockspace it
> was inscribed in (eg [4]). This is different from Bitcoin's scarcity
> -- by 2100 or so there'll be a total of 2100T satoshis available,
> but in that same time there will only have been about 4T vbytes of
> blockspace available, and perhaps it could make sense to value spent
> vbytes proportionally, so 4 spent vbytes is worth 2100 sats. In that
> case if you spent 50kvb inscribing a jpeg, perhaps the "rights" to that
> jpeg should be worth the same as 50k/4*2100 sats or 0.26 BTC. Doesn't
> seem like a sound argument to me -- there's always more blockspace being
> created, by fewer and fewer sats being created, and ordinals are far more
> awkward to deal with, but I suppose it's still conceivable, and people
> at least claim to believe it. If it were true, this argument suggests
> the price for blockspace today should be around 2488sat/vB (19.28MBTC /
> 774700 MvB), rather than 1sat/vB.
>
> [4] https://twitter.com/vnprc/status/1619876888687820801
>
> Anyway, comparisons to ordinal inscriptions aside, I think there's
> another interesting point from all this.
>
> Presume you have a tool that implements the nostr ordinal assignment
> suggested above: that is, a small modification of the "ord" tool that
> can track a chain of custody for an ordinal specified in a nostr event
> like the above. That allows you to do NFTs completely unobservably --
> you don't have to publish anything to the blockchain apart from ordinary
> looking transactions to transfer ownership of your NFT. To your benefit,
> that makes it hard for anyone to censor you; but to bitcoin more broadly,
> I think it means that the possibility of coloured bitcoins is largely
> unavoidable and simply something that must be dealt with, rather than
> something we should spend time trying to prevent/avoid. Compare with:
>
>> My personal, and possibly controversial, opinion is that colored coin
>> protocols have no business being on the Bitcoin chain, possibly beyond
>> committing to an occasional batched state update or so. Both because
>> there is little benefit for tokens with a trusted issuer already, and
>> because it competes with using Bitcoin for BTC - the token that pays
>> for its security (at least as long as the subsidy doesn't run out).
>>
>> Of course, personal opinions are no reason to dictate what people should
>> or can use the chain for, but I do think it's reason to voice hesitancy
>> to worsening the system's scalability properties only to benefit what
>> I consider misguided use.
>   -- https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019500.html
>
> I don't think this actually results in majorly misaligned incentives
> though: in the nostr-nfts-on-btc world, everyone is still optimising
> bitcoin transactions for the same thing -- transfer of value. It's just
> that in some cases some sats are valued differently than others --
> perhaps my uninscribed sats are worth 0.025 cents each, but you have
> a particular inscribed sat that's worth $100k. But we're both dealing
> just spending utxos and creating new utxos, doing signatures and maybe
> some timelocks or hash reveals. And it's always been possible that
> your transaction transferring $100k won't get charged higher fees than
> my transfer of $50 -- we care about transaction size, not value after
> all. How much does it matter if your tx matters more to your because
> someone wants your particular sat, rather than what could happen today
> where you have a utxo with 4 BTC while my utxo only has 0.002 BTC?
>
> I think the only way to prevent that sort of NFT structure would be
> to have every transaction use fancy zero-knowledge proofs that make it
> impossible to associate who received bitcoin with who spent it -- *even
> if* both the sender and recipient were willing to cooperate to reveal
> that information. I think it would be hard to achieve that while still
> making it easy to audit bitcoin's total supply, but I might be wrong.
>
> Note that off-chain colouring here means that someone can create an NFT
> that you don't want it, and just assign it to a sat that's already in your
> wallet. However, they can do this anyway, by first creating the NFT, then
> sending it to your wallet address. A difference though is that they could
> create an NFT and assign it to the same ordinal/sat as some existing NFT
> that you do value, at which point it's (presumably) impossible to discard
> one without discarding both. But again, this is simply something they
> can do, just be writing a patch to ord and composing a nostr message;
> it's not something you can actually prevent even if you dislike it.
>
> Particularly for semi-fungible tokens, this is perhaps inferior to
> Liquid's multi-asset model -- here if you have a utxo with 1M sats, 500
> of which are inscribed to each represent rights to $1 worth of USDT,
> then rather than acting like a stable coin and being worth $500; it's
> actually worth $500+0.01BTC, which is more like $750, and changes as
> the value of bitcoin changes.
>
> Cheers,
> aj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From alicexbt at protonmail.com  Thu Feb  2 14:22:10 2023
From: alicexbt at protonmail.com (alicexbt)
Date: Thu, 02 Feb 2023 14:22:10 +0000
Subject: [bitcoin-dev] Purely off-chain coin colouring
In-Reply-To: <Y9t/NcgRzv1w//Fx@erisian.com.au>
References: <Y9t/NcgRzv1w//Fx@erisian.com.au>
Message-ID: <M7uxv9uqWUhcUJ4bLo-b8x0OrmUEfh-KOe2RXYdSJLkqcu2spT4vtU_2okLezW_BlbJTHn1OsgKbK1I1kjY8-MHjuzYraWZChn8LyRn4w1o=@protonmail.com>

Hi Anthony,

> I think, however, that you can move inscriptions entirely off-chain. I
wrote a little on this idea on twitter already [1], but after a bit more
thought, I think pushing things even further off-chain would be plausible.

Whole point of inscriptions is to keep something on-chain associated with your sats so this approach goes against the concept and what makes them interesting in the first place.

> Implementing that is fairly straightforward: you just need a protocol
for creating an asset offchain and associating it with an ordinal --
nothing needs to happen on-chain at all. That is, you can do something
as simple as posting a single nostr message:

All events may not be permanently stored by Nostr relays. In addition to rendering inscriptions meaningless, this creates a dependency.

> The "inscription" approach might still be desirable for broadcasting
information that might otherwise be subject to heavy censorship; presuming
that the censoring entity isn't also willing and able to censor bitcoin
itself.

If bitcoin transactions can be censored then we have bigger problems to care about as bitcoin will have no value without censorship resistance.

Lastly, I would add that inscriptions involve "financial" transactions, associating sats with image is freedom and got historical reasons for it. Writing something on paper or drawing an image on copper is not same as doing it on gold.

Disclaimer: My opinion on inscriptions can be biased because I am working on a startup that will use inscriptions and satscard(coinkite)


/dev/fd0
floppy disc guy

Sent with Proton Mail secure email.

------- Original Message -------
On Thursday, February 2nd, 2023 at 2:45 PM, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:


> Hi *,
> 
> Casey Rodarmor's ordinals use the technique of tracking the identity of
> individual satoshis throughout their lifetime:
> 
> On Tue, Feb 22, 2022 at 04:43:52PM -0800, Casey Rodarmor via bitcoin-dev wrote:
> 
> > Briefly, newly mined satoshis are sequentially numbered in the order in
> > which they are mined. These numbers are called "ordinal numbers" or
> > "ordinals". When satoshis are spent in a transaction, the input satoshi
> > ordinal numbers are assigned to output satoshis using a simple
> > first-in-first-out algorithm.
> 
> 
> This is proposed as a BIP at https://github.com/bitcoin/bips/pull/1408
> 
> When accompanied by a standard for associating some data or right with
> such an identity, this allows the creation of non-fungible tokens (or
> semi-fungible tokens) whose ownership can be transferred by a bitcoin
> transaction.
> 
> The proposed BIP doesn't document any method for associating data or a
> right with an ordinal, but the "ord" tool defines "inscriptions" to fill
> this gap [0], providing a way of including mime-encoded data in a taproot
> witness. To make such an inscription, two transactions are required:
> one paying some sats to a special scriptPubKey that commits to the
> inscribed data, and a second that spends those sats to the owner of the
> newly inscribed ordinal, and in so doing revealing the full inscription.
> 
> [0] https://docs.ordinals.com/inscriptions.html
> 
> I think, however, that you can move inscriptions entirely off-chain. I
> wrote a little on this idea on twitter already [1], but after a bit more
> thought, I think pushing things even further off-chain would be plausible.
> 
> [1] https://twitter.com/ajtowns/status/1619554871166013441
> 
> In particular, rather than looking at it as being the owner of the sats
> that inscribes some content on those sats (analogously to signing a $100
> bill [2]), you could look at it as saying "the owner of this thing is
> whoever owns this particular sat" (eg instead of "whoever owns this
> share certificate is a shareholder", it's "whoever owns the $1 bill with
> serial number X is a shareholder").
> 
> [2] https://www.espn.com/nfl/story/_/id/14375536/owner-100-bill-autograph-cleveland-browns-qb-johnny-manziel-getting-offers
> 
> Implementing that is fairly straightforward: you just need a protocol
> for creating an asset offchain and associating it with an ordinal --
> nothing needs to happen on-chain at all. That is, you can do something
> as simple as posting a single nostr message:
> 
> {
> "pubkey": <creator's pubkey>
> 
> "kind": 0,
> "tags": [
> ["ord", "txid:vout:sat"]
> ],
> "content": [jpeg goes here],
> "id": <hash of the above>
> 
> "sig": <signature of id by creator's pubkey>
> 
> }
> 
> You can prove current ownership of the message by showing a custody
> chain, that is the transaction specified by "txid" in the "ord" tag,
> then every transaction that spent the given sat, until you get to one
> that's still in the utxo set [3]. You don't need to provide witness
> data or validate any of these tx's signatures, as that is already
> implicit in that you end up at a tx in the utxo set. Just calculating
> the txids and comparing against the output containing the sat you're
> interested in is sufficient.
> 
> [3] If the satoshi was lost to fees at some point, you could continue to
> follow ownership by including an entire block in the custody chain.
> But seems better to just consider it as "abandoned" or "lost to the
> public domain" at that point.
> 
> This approach allows all the "inscription" data to be entirely off-chain,
> the only thing that requires a transaction on-chain is transferring
> ownership to someone else. That allows the NFT's existance can be kept
> entirely private if desired; it also makes it cheap to create a new NFT
> (you don't need to pay any on-chain fees at all); and it doesn't impose
> an outsized overhead on people who aren't interested in your inscriptions,
> but may be interested either in bitcoin per se, or in other inscriptions.
> 
> For things that have real intrinsic value -- equity rights in a company,
> bragging rights for supporting an artist, etc -- this seems like it's
> probably a viable approach: owners can "self-custody" all the information
> about the things they own without having to rely on third parties,
> transfers are no more censorable than any other bitcoin transaction
> (especially if the association of the NFT with some particular sat is
> not widely known), etc.
> 
> The "inscription" approach might still be desirable for broadcasting
> information that might otherwise be subject to heavy censorship; presuming
> that the censoring entity isn't also willing and able to censor bitcoin
> itself. It's not clear that there's any "rights" to be owned for such a
> case -- you can't buy the right to be the person that first published
> it, and the point of widely broadcasting the information is so it's
> not a secret only known to a few anymore. Also, claiming ownership of
> such information would presumably make you a target for the censor,
> even if just as an example for others. So I'm dubious of the value of
> associating an inscription with an ordinal for that use case.
> 
> It's also possible that the perceived value of the NFT isn't due to
> the inscription, but rather due to the scarcity of the blockspace it
> was inscribed in (eg [4]). This is different from Bitcoin's scarcity
> -- by 2100 or so there'll be a total of 2100T satoshis available,
> but in that same time there will only have been about 4T vbytes of
> blockspace available, and perhaps it could make sense to value spent
> vbytes proportionally, so 4 spent vbytes is worth 2100 sats. In that
> case if you spent 50kvb inscribing a jpeg, perhaps the "rights" to that
> jpeg should be worth the same as 50k/4*2100 sats or 0.26 BTC. Doesn't
> seem like a sound argument to me -- there's always more blockspace being
> created, by fewer and fewer sats being created, and ordinals are far more
> awkward to deal with, but I suppose it's still conceivable, and people
> at least claim to believe it. If it were true, this argument suggests
> the price for blockspace today should be around 2488sat/vB (19.28MBTC /
> 774700 MvB), rather than 1sat/vB.
> 
> [4] https://twitter.com/vnprc/status/1619876888687820801
> 
> Anyway, comparisons to ordinal inscriptions aside, I think there's
> another interesting point from all this.
> 
> Presume you have a tool that implements the nostr ordinal assignment
> suggested above: that is, a small modification of the "ord" tool that
> can track a chain of custody for an ordinal specified in a nostr event
> like the above. That allows you to do NFTs completely unobservably --
> you don't have to publish anything to the blockchain apart from ordinary
> looking transactions to transfer ownership of your NFT. To your benefit,
> that makes it hard for anyone to censor you; but to bitcoin more broadly,
> I think it means that the possibility of coloured bitcoins is largely
> unavoidable and simply something that must be dealt with, rather than
> something we should spend time trying to prevent/avoid. Compare with:
> 
> > My personal, and possibly controversial, opinion is that colored coin
> > protocols have no business being on the Bitcoin chain, possibly beyond
> > committing to an occasional batched state update or so. Both because
> > there is little benefit for tokens with a trusted issuer already, and
> > because it competes with using Bitcoin for BTC - the token that pays
> > for its security (at least as long as the subsidy doesn't run out).
> > 
> > Of course, personal opinions are no reason to dictate what people should
> > or can use the chain for, but I do think it's reason to voice hesitancy
> > to worsening the system's scalability properties only to benefit what
> > I consider misguided use.
> 
> 
> -- https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019500.html
> 
> I don't think this actually results in majorly misaligned incentives
> though: in the nostr-nfts-on-btc world, everyone is still optimising
> bitcoin transactions for the same thing -- transfer of value. It's just
> that in some cases some sats are valued differently than others --
> perhaps my uninscribed sats are worth 0.025 cents each, but you have
> a particular inscribed sat that's worth $100k. But we're both dealing
> just spending utxos and creating new utxos, doing signatures and maybe
> some timelocks or hash reveals. And it's always been possible that
> your transaction transferring $100k won't get charged higher fees than
> my transfer of $50 -- we care about transaction size, not value after
> all. How much does it matter if your tx matters more to your because
> someone wants your particular sat, rather than what could happen today
> where you have a utxo with 4 BTC while my utxo only has 0.002 BTC?
> 
> I think the only way to prevent that sort of NFT structure would be
> to have every transaction use fancy zero-knowledge proofs that make it
> impossible to associate who received bitcoin with who spent it -- even
> if both the sender and recipient were willing to cooperate to reveal
> that information. I think it would be hard to achieve that while still
> making it easy to audit bitcoin's total supply, but I might be wrong.
> 
> Note that off-chain colouring here means that someone can create an NFT
> that you don't want it, and just assign it to a sat that's already in your
> wallet. However, they can do this anyway, by first creating the NFT, then
> sending it to your wallet address. A difference though is that they could
> create an NFT and assign it to the same ordinal/sat as some existing NFT
> that you do value, at which point it's (presumably) impossible to discard
> one without discarding both. But again, this is simply something they
> can do, just be writing a patch to ord and composing a nostr message;
> it's not something you can actually prevent even if you dislike it.
> 
> Particularly for semi-fungible tokens, this is perhaps inferior to
> Liquid's multi-asset model -- here if you have a utxo with 1M sats, 500
> of which are inscribed to each represent rights to $1 worth of USDT,
> then rather than acting like a stable coin and being worth $500; it's
> actually worth $500+0.01BTC, which is more like $750, and changes as
> the value of bitcoin changes.
> 
> Cheers,
> aj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From pete at petertodd.org  Thu Feb  2 14:30:11 2023
From: pete at petertodd.org (Peter Todd)
Date: Thu, 2 Feb 2023 09:30:11 -0500
Subject: [bitcoin-dev] Purely off-chain coin colouring
In-Reply-To: <Y9t/NcgRzv1w//Fx@erisian.com.au>
References: <Y9t/NcgRzv1w//Fx@erisian.com.au>
Message-ID: <Y9vI8x6JcqdrvawF@petertodd.org>

On Thu, Feb 02, 2023 at 07:15:33PM +1000, Anthony Towns via bitcoin-dev wrote:
> Hi *,
> 
> Casey Rodarmor's ordinals use the technique of tracking the identity of
> individual satoshis throughout their lifetime:

<snip>

> I think, however, that you can move inscriptions entirely off-chain. I
> wrote a little on this idea on twitter already [1], but after a bit more
> thought, I think pushing things even further off-chain would be plausible.

On the FAQ of the Ordinals website they discuss off-chain data storage and
reject the idea:

    "Some Ethereum NFT content is on-chain, but much is off-chain, and is stored on
    platforms like IPFS or Arweave, or on traditional, fully centralized web
    servers. Content on IPFS is not guaranteed to continue to be available, and
    some NFT content stored on IPFS has already been lost. Platforms like Arweave
    rely on weak economic assumptions, and will likely fail catastrophically when
    these economic assumptions are no longer met. Centralized web servers may
    disappear at any time."
    https://web.archive.org/web/20230130012343/https://docs.ordinals.com/faq.html

That same FAQ also mention RGB and Taro, which already implements an off-chain
data model based on my Proofmarshal work. The Ordinals community is well aware
of the trade-offs and have chosen to publish their data on chain. This is a
collectables market based on artificial scarcity after all, so some conspicuous
consumption isn't going to be a deterrent.

Frankly, I think further discussion of this on the bitcoin-dev mailing list,
with the aim of getting Ordinals and others to do something else, is a waste of
everyones' time. The fact that publishing data on chain lets you take
advantage of the very large network of archival Bitcoin nodes to publish and
store your data indefinitely is a clear benefit that people will always be
willing to pay for. The only realistic thing Bitcoin can do to discourage this
is tweaks to the blocksize and segwit discount, which of course has well-known
downsides.

There's a clear social/economic benefit to the Ordinals community that the
complete set of Ordinalds - and their inscriptions - is easy to extract and
will be available as long as Bitcoin block data itself will be available.
That's not going away and we should acknowledge that benefit honestly.

> Implementing that is fairly straightforward: you just need a protocol
> for creating an asset offchain and associating it with an ordinal --
> nothing needs to happen on-chain at all. That is, you can do something
> as simple as posting a single nostr message:
> 
>   {
>     "pubkey": <creator's pubkey>
>     "kind": 0,
>     "tags": [
>       ["ord", "txid:vout:sat"]
>     ],
>     "content": [jpeg goes here],
>     "id": <hash of the above>
>     "sig": <signature of id by creator's pubkey>
>   }

nostr doesn't even have a clear data persistence model. As you know, nostr
messages are passed around by relays that make no enforceable promise of
actually keeping those messages or making them available. nostr doesn't have
any kind of blockchain, making it diffcult for others to archive messages
completely.  Advocating for its use in a protocol designed to support valuable
collectables expected to be owned for a significant amount of time is reckless.

You know, we've been through all this before, years ago when colored coins were
first being discussed. Bitcoin Core devs who knew better would try to
discourage use of the Bitcoin chain for purposes they didn't approve of, by
suggesting solutions that they knew full well didn't really work. Solutions
like using OpenTimestamps inappropriately, alternative publication methods that
failed to provide the same level of security as Bitcoin, etc. It was dishonest
then, and it's disappointing to see a new generation of Bitcoin devs continue
this pattern of dishonesty.

> You can prove current ownership of the message by showing a custody
> chain, that is the transaction specified by "txid" in the "ord" tag,
> then every transaction that spent the given sat, until you get to one
> that's still in the utxo set [3]. You don't need to provide witness
> data or validate any of these tx's signatures, as that is already
> implicit in that you end up at a tx in the utxo set. Just calculating
> the txids and comparing against the output containing the sat you're
> interested in is sufficient.

The RGB protocol already does off-chain custody proofs, and implements NFTs.
You can already use this for real with Iris Wallet - the ownership chain of a
RGB asset is _not_ visible on the blockchain, as ownership does not follow
satoshis. With more work, digital assets can even be transferred with
O(log_2(n)) scaling allowing billions of transfers per second:

    https://petertodd.org/2017/scalable-single-use-seal-asset-transfer

This of course is irrelevant to Ordinals, which will never have such a large
market.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/661f9b15/attachment.sig>

From pete at petertodd.org  Thu Feb  2 14:52:09 2023
From: pete at petertodd.org (Peter Todd)
Date: Thu, 2 Feb 2023 09:52:09 -0500
Subject: [bitcoin-dev] Ephemeral Anchors: Fixing V3 Package RBF
 againstpackage limit pinning
In-Reply-To: <CAB3F3DvToF_fia+X5SQi-L=BDYGLpzr8nNHqjtFBUjLMbyPE9Q@mail.gmail.com>
References: <CAB3F3Dukoz3P3Ne7tCxMiwwAGm3Fv8r_fUkNbGAtGhAZDYDgCQ@mail.gmail.com>
 <ec952a9c-d810-4996-9ca9-1e9c6f6faca4@app.fastmail.com>
 <CAB3F3DvH3FnK8krykbcRVKc-z8F4yjt9mzYHevpYxaWkH4w9tw@mail.gmail.com>
 <CAD5xwhgFBQ-ScyBU5=WnREGsN-T=Nv=oR6vOsnHJ-ZMzDF8Vqg@mail.gmail.com>
 <CAPfvXf+N8aF+bqjGzpfDrhCYg7ngciSDCpUnCMHD+k5F+m3oWA@mail.gmail.com>
 <CAB3F3DuDODUxB5aK4VFWa8sKFCkZfOj6Vjb+Wp39opyt8MNnEA@mail.gmail.com>
 <CAB3F3DtrSFPmperGJJAUDZj7vt9aHgvkc0b5Pts3+mq5fTuWXA@mail.gmail.com>
 <CAB3F3DvToF_fia+X5SQi-L=BDYGLpzr8nNHqjtFBUjLMbyPE9Q@mail.gmail.com>
Message-ID: <Y9vOGVMJx1b9CPYq@petertodd.org>

On Fri, Jan 27, 2023 at 09:05:20AM -0500, Greg Sanders via bitcoin-dev wrote:
> Hello again dev,
> 
> Due to the interest in the proposal and the prodding of certain folks, I've
> written up a short draft BIP of the Ephemeral Anchors idea here:
> https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki
> 
> The pull request at https://github.com/bitcoin/bitcoin/pull/26403 has been
> refreshed on top of the latest V3 proposal, but the BIP itself is
> unaffected.

The BIP states that:

    Why OP_2 not OP_TRUE? OP_TRUE is often used in test vectors, using OP_2 has
    the same benefits and none of these common collisions.

Why is a "collision" harmful in this case?

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/9ef319d4/attachment.sig>

From gsanders87 at gmail.com  Thu Feb  2 14:59:09 2023
From: gsanders87 at gmail.com (Greg Sanders)
Date: Thu, 2 Feb 2023 09:59:09 -0500
Subject: [bitcoin-dev] Ephemeral Anchors: Fixing V3 Package RBF
 againstpackage limit pinning
In-Reply-To: <Y9vOGVMJx1b9CPYq@petertodd.org>
References: <CAB3F3Dukoz3P3Ne7tCxMiwwAGm3Fv8r_fUkNbGAtGhAZDYDgCQ@mail.gmail.com>
 <ec952a9c-d810-4996-9ca9-1e9c6f6faca4@app.fastmail.com>
 <CAB3F3DvH3FnK8krykbcRVKc-z8F4yjt9mzYHevpYxaWkH4w9tw@mail.gmail.com>
 <CAD5xwhgFBQ-ScyBU5=WnREGsN-T=Nv=oR6vOsnHJ-ZMzDF8Vqg@mail.gmail.com>
 <CAPfvXf+N8aF+bqjGzpfDrhCYg7ngciSDCpUnCMHD+k5F+m3oWA@mail.gmail.com>
 <CAB3F3DuDODUxB5aK4VFWa8sKFCkZfOj6Vjb+Wp39opyt8MNnEA@mail.gmail.com>
 <CAB3F3DtrSFPmperGJJAUDZj7vt9aHgvkc0b5Pts3+mq5fTuWXA@mail.gmail.com>
 <CAB3F3DvToF_fia+X5SQi-L=BDYGLpzr8nNHqjtFBUjLMbyPE9Q@mail.gmail.com>
 <Y9vOGVMJx1b9CPYq@petertodd.org>
Message-ID: <CAB3F3Du2XsHCh5o5S84XKKizTkrTFJJ-j42-qunyuSRkwX7H_Q@mail.gmail.com>

Hi Peter,

For the most principled of reasons:

Because I have to change test vectors everywhere!

Greg

On Thu, Feb 2, 2023 at 9:52 AM Peter Todd <pete at petertodd.org> wrote:

> On Fri, Jan 27, 2023 at 09:05:20AM -0500, Greg Sanders via bitcoin-dev
> wrote:
> > Hello again dev,
> >
> > Due to the interest in the proposal and the prodding of certain folks,
> I've
> > written up a short draft BIP of the Ephemeral Anchors idea here:
> >
> https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki
> >
> > The pull request at https://github.com/bitcoin/bitcoin/pull/26403 has
> been
> > refreshed on top of the latest V3 proposal, but the BIP itself is
> > unaffected.
>
> The BIP states that:
>
>     Why OP_2 not OP_TRUE? OP_TRUE is often used in test vectors, using
> OP_2 has
>     the same benefits and none of these common collisions.
>
> Why is a "collision" harmful in this case?
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/d53025db/attachment.html>

From pete at petertodd.org  Thu Feb  2 15:06:53 2023
From: pete at petertodd.org (Peter Todd)
Date: Thu, 2 Feb 2023 10:06:53 -0500
Subject: [bitcoin-dev] Ephemeral Anchors: Fixing V3 Package RBF
 againstpackage limit pinning
In-Reply-To: <CAB3F3Du2XsHCh5o5S84XKKizTkrTFJJ-j42-qunyuSRkwX7H_Q@mail.gmail.com>
References: <CAB3F3Dukoz3P3Ne7tCxMiwwAGm3Fv8r_fUkNbGAtGhAZDYDgCQ@mail.gmail.com>
 <ec952a9c-d810-4996-9ca9-1e9c6f6faca4@app.fastmail.com>
 <CAB3F3DvH3FnK8krykbcRVKc-z8F4yjt9mzYHevpYxaWkH4w9tw@mail.gmail.com>
 <CAD5xwhgFBQ-ScyBU5=WnREGsN-T=Nv=oR6vOsnHJ-ZMzDF8Vqg@mail.gmail.com>
 <CAPfvXf+N8aF+bqjGzpfDrhCYg7ngciSDCpUnCMHD+k5F+m3oWA@mail.gmail.com>
 <CAB3F3DuDODUxB5aK4VFWa8sKFCkZfOj6Vjb+Wp39opyt8MNnEA@mail.gmail.com>
 <CAB3F3DtrSFPmperGJJAUDZj7vt9aHgvkc0b5Pts3+mq5fTuWXA@mail.gmail.com>
 <CAB3F3DvToF_fia+X5SQi-L=BDYGLpzr8nNHqjtFBUjLMbyPE9Q@mail.gmail.com>
 <Y9vOGVMJx1b9CPYq@petertodd.org>
 <CAB3F3Du2XsHCh5o5S84XKKizTkrTFJJ-j42-qunyuSRkwX7H_Q@mail.gmail.com>
Message-ID: <Y9vRjQVnZzA8Bx/s@petertodd.org>

On Thu, Feb 02, 2023 at 09:59:09AM -0500, Greg Sanders wrote:
> Hi Peter,
> 
> For the most principled of reasons:
> 
> Because I have to change test vectors everywhere!

Specifically, you mean you'd have to change tests that test something is
non-standard?

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/755e81a0/attachment-0001.sig>

From aymeric at peersm.com  Thu Feb  2 16:06:02 2023
From: aymeric at peersm.com (Aymeric Vitte)
Date: Thu, 2 Feb 2023 17:06:02 +0100
Subject: [bitcoin-dev] Purely off-chain coin colouring
In-Reply-To: <Y9vI8x6JcqdrvawF@petertodd.org>
References: <Y9t/NcgRzv1w//Fx@erisian.com.au> <Y9vI8x6JcqdrvawF@petertodd.org>
Message-ID: <43ea2d30-182a-5c8b-4c86-93679659183d@peersm.com>

I am not an expert with RGB, but it looks limited (only bitcoin chains
from the github repo, apparently on hold), distributed over the
"lightning network" or LN nodes (what is it?), or Bifrost extension,
with a dubious token floating around, like ethereum mess as RGB docs
describe Ethereum (and myself also), layer2 or layer3, certainly not
decentralized (like still Bitcoin and Ethereum)

It's of course useless to trust IPFS or Bittorrent to store things
because you cannot control the seeders who have zero incentive to seed
such things

That's why in my much more simple proposals a well known third party is
there, wayback machine, github, twitter, etc, if they disappear then
probably internet has disappeared too, if they get censored you can
still get a snapshot of what you did

The intent is certainly not to store NFTs in Bitcoin, only hashes,
signatures and addresses, same for the third party proof, the NFT
content if not real is stored elsewhere (up to people to decide where)

Additionally you can store in the third party the proof that something
exists (the secret NFT), for example a small copy of the NFT electronic
art, the buyer will get the full version once the deal is done and once
he gets the decryption key, having the NFT for himself only

My proposals are not addressing wider D-stuff topics, supposedly
decentralized, but no

So I don't think that it's a waste of time to change the OP_RETURN max
size, currently it cannot even store <short message and/or hash> +
<signature>, probably it's logical to align it to the script size limit
(520B)

Or as I said previously deviant practices can happen, not expensive and
just burning satoshis, which is not a super idea

I don't get why on bitcoin all proposals must always be super
complicate, mine are simple, then take 5mn to read them


Le 02/02/2023 ? 15:30, Peter Todd via bitcoin-dev a ?crit :
> On Thu, Feb 02, 2023 at 07:15:33PM +1000, Anthony Towns via bitcoin-dev wrote:
>> Hi *,
>>
>> Casey Rodarmor's ordinals use the technique of tracking the identity of
>> individual satoshis throughout their lifetime:
> <snip>
>
>> I think, however, that you can move inscriptions entirely off-chain. I
>> wrote a little on this idea on twitter already [1], but after a bit more
>> thought, I think pushing things even further off-chain would be plausible.
> On the FAQ of the Ordinals website they discuss off-chain data storage and
> reject the idea:
>
>     "Some Ethereum NFT content is on-chain, but much is off-chain, and is stored on
>     platforms like IPFS or Arweave, or on traditional, fully centralized web
>     servers. Content on IPFS is not guaranteed to continue to be available, and
>     some NFT content stored on IPFS has already been lost. Platforms like Arweave
>     rely on weak economic assumptions, and will likely fail catastrophically when
>     these economic assumptions are no longer met. Centralized web servers may
>     disappear at any time."
>     https://web.archive.org/web/20230130012343/https://docs.ordinals.com/faq.html
>
> That same FAQ also mention RGB and Taro, which already implements an off-chain
> data model based on my Proofmarshal work. The Ordinals community is well aware
> of the trade-offs and have chosen to publish their data on chain. This is a
> collectables market based on artificial scarcity after all, so some conspicuous
> consumption isn't going to be a deterrent.
>
> Frankly, I think further discussion of this on the bitcoin-dev mailing list,
> with the aim of getting Ordinals and others to do something else, is a waste of
> everyones' time. The fact that publishing data on chain lets you take
> advantage of the very large network of archival Bitcoin nodes to publish and
> store your data indefinitely is a clear benefit that people will always be
> willing to pay for. The only realistic thing Bitcoin can do to discourage this
> is tweaks to the blocksize and segwit discount, which of course has well-known
> downsides.
>
> There's a clear social/economic benefit to the Ordinals community that the
> complete set of Ordinalds - and their inscriptions - is easy to extract and
> will be available as long as Bitcoin block data itself will be available.
> That's not going away and we should acknowledge that benefit honestly.
>
>> Implementing that is fairly straightforward: you just need a protocol
>> for creating an asset offchain and associating it with an ordinal --
>> nothing needs to happen on-chain at all. That is, you can do something
>> as simple as posting a single nostr message:
>>
>>   {
>>     "pubkey": <creator's pubkey>
>>     "kind": 0,
>>     "tags": [
>>       ["ord", "txid:vout:sat"]
>>     ],
>>     "content": [jpeg goes here],
>>     "id": <hash of the above>
>>     "sig": <signature of id by creator's pubkey>
>>   }
> nostr doesn't even have a clear data persistence model. As you know, nostr
> messages are passed around by relays that make no enforceable promise of
> actually keeping those messages or making them available. nostr doesn't have
> any kind of blockchain, making it diffcult for others to archive messages
> completely.  Advocating for its use in a protocol designed to support valuable
> collectables expected to be owned for a significant amount of time is reckless.
>
> You know, we've been through all this before, years ago when colored coins were
> first being discussed. Bitcoin Core devs who knew better would try to
> discourage use of the Bitcoin chain for purposes they didn't approve of, by
> suggesting solutions that they knew full well didn't really work. Solutions
> like using OpenTimestamps inappropriately, alternative publication methods that
> failed to provide the same level of security as Bitcoin, etc. It was dishonest
> then, and it's disappointing to see a new generation of Bitcoin devs continue
> this pattern of dishonesty.
>
>> You can prove current ownership of the message by showing a custody
>> chain, that is the transaction specified by "txid" in the "ord" tag,
>> then every transaction that spent the given sat, until you get to one
>> that's still in the utxo set [3]. You don't need to provide witness
>> data or validate any of these tx's signatures, as that is already
>> implicit in that you end up at a tx in the utxo set. Just calculating
>> the txids and comparing against the output containing the sat you're
>> interested in is sufficient.
> The RGB protocol already does off-chain custody proofs, and implements NFTs.
> You can already use this for real with Iris Wallet - the ownership chain of a
> RGB asset is _not_ visible on the blockchain, as ownership does not follow
> satoshis. With more work, digital assets can even be transferred with
> O(log_2(n)) scaling allowing billions of transfers per second:
>
>     https://petertodd.org/2017/scalable-single-use-seal-asset-transfer
>
> This of course is irrelevant to Ordinals, which will never have such a large
> market.
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Sophia-Antipolis, France
CV: https://www.peersm.com/CVAV.pdf
LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26
GitHub : https://www.github.com/Ayms
A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7
A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com
Peersm : http://www.peersm.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/bab6d696/attachment.html>

From gsanders87 at gmail.com  Thu Feb  2 18:36:24 2023
From: gsanders87 at gmail.com (Greg Sanders)
Date: Thu, 2 Feb 2023 13:36:24 -0500
Subject: [bitcoin-dev] Ephemeral Anchors: Fixing V3 Package RBF
 againstpackage limit pinning
In-Reply-To: <Y9vRjQVnZzA8Bx/s@petertodd.org>
References: <CAB3F3Dukoz3P3Ne7tCxMiwwAGm3Fv8r_fUkNbGAtGhAZDYDgCQ@mail.gmail.com>
 <ec952a9c-d810-4996-9ca9-1e9c6f6faca4@app.fastmail.com>
 <CAB3F3DvH3FnK8krykbcRVKc-z8F4yjt9mzYHevpYxaWkH4w9tw@mail.gmail.com>
 <CAD5xwhgFBQ-ScyBU5=WnREGsN-T=Nv=oR6vOsnHJ-ZMzDF8Vqg@mail.gmail.com>
 <CAPfvXf+N8aF+bqjGzpfDrhCYg7ngciSDCpUnCMHD+k5F+m3oWA@mail.gmail.com>
 <CAB3F3DuDODUxB5aK4VFWa8sKFCkZfOj6Vjb+Wp39opyt8MNnEA@mail.gmail.com>
 <CAB3F3DtrSFPmperGJJAUDZj7vt9aHgvkc0b5Pts3+mq5fTuWXA@mail.gmail.com>
 <CAB3F3DvToF_fia+X5SQi-L=BDYGLpzr8nNHqjtFBUjLMbyPE9Q@mail.gmail.com>
 <Y9vOGVMJx1b9CPYq@petertodd.org>
 <CAB3F3Du2XsHCh5o5S84XKKizTkrTFJJ-j42-qunyuSRkwX7H_Q@mail.gmail.com>
 <Y9vRjQVnZzA8Bx/s@petertodd.org>
Message-ID: <CAB3F3DvumE-r+LGm8ivooPD9qfzFs-NK9Ve06Ew1EMAifSx8dw@mail.gmail.com>

Quickly checked, it fails a number of standardness tests in unit/functional
tests in Bitcoin Core, at least.

OP_2 was actually Luke Jr's idea circa 2017 for about the same reasons, I
just independently arrived at the same conclusion.

On Thu, Feb 2, 2023 at 10:06 AM Peter Todd <pete at petertodd.org> wrote:

> On Thu, Feb 02, 2023 at 09:59:09AM -0500, Greg Sanders wrote:
> > Hi Peter,
> >
> > For the most principled of reasons:
> >
> > Because I have to change test vectors everywhere!
>
> Specifically, you mean you'd have to change tests that test something is
> non-standard?
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/48dcb48f/attachment-0001.html>

From pete at petertodd.org  Thu Feb  2 20:22:38 2023
From: pete at petertodd.org (Peter Todd)
Date: Thu, 2 Feb 2023 15:22:38 -0500
Subject: [bitcoin-dev] Ephemeral Anchors: Fixing V3 Package RBF
 againstpackage limit pinning
In-Reply-To: <CAB3F3DvumE-r+LGm8ivooPD9qfzFs-NK9Ve06Ew1EMAifSx8dw@mail.gmail.com>
References: <CAB3F3DvH3FnK8krykbcRVKc-z8F4yjt9mzYHevpYxaWkH4w9tw@mail.gmail.com>
 <CAD5xwhgFBQ-ScyBU5=WnREGsN-T=Nv=oR6vOsnHJ-ZMzDF8Vqg@mail.gmail.com>
 <CAPfvXf+N8aF+bqjGzpfDrhCYg7ngciSDCpUnCMHD+k5F+m3oWA@mail.gmail.com>
 <CAB3F3DuDODUxB5aK4VFWa8sKFCkZfOj6Vjb+Wp39opyt8MNnEA@mail.gmail.com>
 <CAB3F3DtrSFPmperGJJAUDZj7vt9aHgvkc0b5Pts3+mq5fTuWXA@mail.gmail.com>
 <CAB3F3DvToF_fia+X5SQi-L=BDYGLpzr8nNHqjtFBUjLMbyPE9Q@mail.gmail.com>
 <Y9vOGVMJx1b9CPYq@petertodd.org>
 <CAB3F3Du2XsHCh5o5S84XKKizTkrTFJJ-j42-qunyuSRkwX7H_Q@mail.gmail.com>
 <Y9vRjQVnZzA8Bx/s@petertodd.org>
 <CAB3F3DvumE-r+LGm8ivooPD9qfzFs-NK9Ve06Ew1EMAifSx8dw@mail.gmail.com>
Message-ID: <Y9wbjsmPO+nyM267@petertodd.org>

On Thu, Feb 02, 2023 at 01:36:24PM -0500, Greg Sanders wrote:
> Quickly checked, it fails a number of standardness tests in unit/functional
> tests in Bitcoin Core, at least.
> 
> OP_2 was actually Luke Jr's idea circa 2017 for about the same reasons, I
> just independently arrived at the same conclusion.

Well, frankly I really don't like the idea of using OP_2 just to avoid changing
some unit tests. We're doing something that many people will use for years to
come, that's unnecessarily obscure just because we don't want to spend a bit of
some modifying some tests to pass.

OP_TRUE is the obvious way to do this, and it results with a 1 on the stack,
which plays better with other standardness rules. OP_2 means we *also* may need
to special case having a 2 on the stack in certain implementations of other
standardness rules.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/e0de4880/attachment.sig>

From gsanders87 at gmail.com  Thu Feb  2 20:47:28 2023
From: gsanders87 at gmail.com (Greg Sanders)
Date: Thu, 2 Feb 2023 15:47:28 -0500
Subject: [bitcoin-dev] Ephemeral Anchors: Fixing V3 Package RBF
 againstpackage limit pinning
In-Reply-To: <Y9wbjsmPO+nyM267@petertodd.org>
References: <CAB3F3DvH3FnK8krykbcRVKc-z8F4yjt9mzYHevpYxaWkH4w9tw@mail.gmail.com>
 <CAD5xwhgFBQ-ScyBU5=WnREGsN-T=Nv=oR6vOsnHJ-ZMzDF8Vqg@mail.gmail.com>
 <CAPfvXf+N8aF+bqjGzpfDrhCYg7ngciSDCpUnCMHD+k5F+m3oWA@mail.gmail.com>
 <CAB3F3DuDODUxB5aK4VFWa8sKFCkZfOj6Vjb+Wp39opyt8MNnEA@mail.gmail.com>
 <CAB3F3DtrSFPmperGJJAUDZj7vt9aHgvkc0b5Pts3+mq5fTuWXA@mail.gmail.com>
 <CAB3F3DvToF_fia+X5SQi-L=BDYGLpzr8nNHqjtFBUjLMbyPE9Q@mail.gmail.com>
 <Y9vOGVMJx1b9CPYq@petertodd.org>
 <CAB3F3Du2XsHCh5o5S84XKKizTkrTFJJ-j42-qunyuSRkwX7H_Q@mail.gmail.com>
 <Y9vRjQVnZzA8Bx/s@petertodd.org>
 <CAB3F3DvumE-r+LGm8ivooPD9qfzFs-NK9Ve06Ew1EMAifSx8dw@mail.gmail.com>
 <Y9wbjsmPO+nyM267@petertodd.org>
Message-ID: <CAB3F3Ds7Ux8MWnY-9Agehpk0hZx_xgeFmZG7hUjMkfe48T5GPA@mail.gmail.com>

> OP_TRUE is the obvious way to do this, and it results with a 1 on the
stack,
which plays better with other standardness rules.

What other standardness rules? MINAMALIF? How does that interact with the
proposal?

On Thu, Feb 2, 2023 at 3:22 PM Peter Todd <pete at petertodd.org> wrote:

> On Thu, Feb 02, 2023 at 01:36:24PM -0500, Greg Sanders wrote:
> > Quickly checked, it fails a number of standardness tests in
> unit/functional
> > tests in Bitcoin Core, at least.
> >
> > OP_2 was actually Luke Jr's idea circa 2017 for about the same reasons, I
> > just independently arrived at the same conclusion.
>
> Well, frankly I really don't like the idea of using OP_2 just to avoid
> changing
> some unit tests. We're doing something that many people will use for years
> to
> come, that's unnecessarily obscure just because we don't want to spend a
> bit of
> some modifying some tests to pass.
>
> OP_TRUE is the obvious way to do this, and it results with a 1 on the
> stack,
> which plays better with other standardness rules. OP_2 means we *also* may
> need
> to special case having a 2 on the stack in certain implementations of other
> standardness rules.
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/b4d28f33/attachment.html>

From casey at rodarmor.com  Fri Feb  3 06:39:21 2023
From: casey at rodarmor.com (Casey Rodarmor)
Date: Thu, 2 Feb 2023 22:39:21 -0800
Subject: [bitcoin-dev] Purely off-chain coin colouring
Message-ID: <CANLPe+Pa-D=JB8N5Qeokoyp=mRA3LLM=mtvvwPkpbHvV_bmEXQ@mail.gmail.com>

Good evening list,

Apologies for posting! I've tried to keep discussion of ordinals and
inscriptions off-list, because I consider it to be of little relevance to
general Bitcoin development. Also, apologies for the HTML mail, but I don't
have my email client configured correctly. And finally, also apologies if
this breaks the thread, I was subscribed but not receiving mail, so I can't
respond to the original message.

AJ Towns writes:

I think, however, that you can move inscriptions entirely off-chain. I
wrote a little on this idea on twitter already [1], but after a bit more
thought, I think pushing things even further off-chain would be plausible.


Actually, my initial sketch for Ordinal NFTs worked in a similar fashion,
with off-chain messages pointing to an ordinal, which could be tracked by
following the chain of custody of that particular sat. I gave a workshop
last year where I handed out paper wallets to participants with a private
key that controlled some sats, which could both be assigned NFTs and used
to sign messages as a form of provenance:

https://www.youtube.com/watch?v=j5V33kV3iqo

Ultimately, I decided against this design, and Peter provided an excellent
explanation of some of the trade-offs of such a design in his mail, but to
at least partially recap and explain my own thinking:

NFT collectors have a strong revealed preference for on-chain content. The
content of high-value NFTs is often stored partially or completely on
chain, even if details of the NFT protocol involved actually prevents that
content from being what you see when you view the NFT on a website or
marketplace.

User protection when off-chain content is involved is fraught. Users are
not equipped, due to lack of technical knowledge, easily available,
user-friendly tools, and education, to protect themselves when they buy a
collectable whose content is stored off-chain. When a user buys an NFT with
off-chain content, they now have the primary economic incentive to preserve
that content, so that their NFT retains value and can be enjoyed or sold.
Many existing NFT marketplaces that sell off-chain content do not explain
this to users, or give users tools that the average, non-technical person
can understand or use, which enables them to protect themselves. Even if
they did give users these tools, there are tricky considerations involved.
IPFS functions much like BitTorrent, so even if users were provided with an
IPFS application that could persist their off-chain NFT content
automatically, they might reveal their IP address, which would then be
linked to ownership of their NFT, which would have privacy and safety
considerations.

Another issue is salience and scarcity, as has been mentioned. Off-chain
content is unbounded, and thus less scarce. Usually, we design for
efficiency, volume, and scale. For NFT designs, which are intended to be
collectable, this is in some ways counterproductive.

The above issues also make the specification and implementation of NFTs
with off-chain content much more difficult. Ordinals is a project largely
written by a single developer, me, with the assistance of two part time
interns. It is very intentionally the simplest thing that could possibly
work, much like Bitcoin itself. Sometimes I refer to it as "cave-man
technology". If I was designing an off-chain NFT protocol, I would likely
have had to raise money and recruit a large team, which I have not done, or
be at risk of never launching anything at all.

I would absolutely love for the ordinals protocol, that is, the numbering
and transfer of individual satoshis, be used as the basis for alternative,
off-chain NFT and colored coin schemes, with proper consideration given to
the issues above.

However, I would request that, to avoid confusion, these alternative
schemes never be called inscriptions.

I'm a dev, not a cop, but fine distinctions are hard to properly explain
and understand. Inscriptions, that is, the NFT protocol which embeds
content in transaction witnesses, has a particular set of trade-offs and
guarantees. I want users to know that if they buy or value something they
or others call an "inscription", they can rely on those trade-offs and
guarantees. Another NFT protocol named "inscriptions" would make this very
difficult.

Additionally, I think the term "inscription" which has a connotation of
permanence, and of an indelible association with a particular satoshi, is
inappropriate for an off-chain NFT protocol.

Sorry to belabor this point! Inscriptions have already proven very popular
for a nascent protocol, beyond my expectations, and the terminology and
naming is still new, so it's a critical phase in terms of understanding and
education.

If others are interested in developing ordinals further, a great first step
would be to provide review and feedback on the BIP PR:

https://github.com/bitcoin/bips/pull/1408

I have never written a BIP, so style and content feedback is especially
welcome.

Inscriptions themselves have no BIP, although at least one alternative
implementation of the inscription parser has been written:

https://ordinals.com/content/6f46a2a830a90e406245b188631cd15ffea31b8be146255ec39d4d46bbe15663i0

I hope to write a BIP for inscriptions as the implementation and protocol
mature.

In general, although I do love the ordinals protocol, it has many
downsides, which I hope people will consider when considering it for
alternative colored coin schemes. These include the fact that divisibility
is limited, both by the use of real sats and the dust limit, that cardinal
satoshis must be used to pay fees, the general insanity of ordinal-aware
transaction construction[0], and difficult in lifting ordinals onto an L2.
I consider ordinals ideal for art projects like inscriptions and
ordinal-theory-powered satoshi numismatics, where aesthetic and technical
considerations are nearly equally important.

Please feel free to contact me privately by email, or on the ordinals
project GitHub[1] if you'd like to respond! My intention with this message
is not to spark debate, since I consider it mostly off-topic for this list.

Best regards,
Casey Rodarmor

[0]
https://github.com/casey/ord/blob/master/src/subcommand/wallet/transaction_builder.rs
[1] https://github.com/casey/ord
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/f969f9f8/attachment-0001.html>

From aymeric at peersm.com  Fri Feb  3 11:15:14 2023
From: aymeric at peersm.com (Aymeric Vitte)
Date: Fri, 3 Feb 2023 12:15:14 +0100
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>
Message-ID: <57f780b1-f262-9394-036c-70084320e9cf@peersm.com>

Indeed the witness envelope is more costly and less easy to use (or
read/track)

But let's take a standard P2PKH or P2WPKH output,  what prevents me from
adding in the beginning of scriptSig or witness while spending it:
OP_PUSH <data> OP_DROP ? Non standard ? This one makes one transaction only

There are probably plenty of ways to store data, another one would be to
use a dummy 1 of N multisig where only 1 corresponds to a pubkey and the
rest is data, but again several transactions...

I think the right way so people don't invent deviant things is to
increase the size of OP_RETURN, I don't get this number of 80B, you can
hardly store a signature (of what?) in there and not the "what" if the
"what" is a hash for example


Le 02/02/2023 ? 14:25, Rijndael via bitcoin-dev a ?crit :
> Hello Christopher,
>
> I think if the protocol that you were designing always had <80 bytes,
> I'd prefer the OP_RETURN. I think the "witness envelope" has two major
> disadvantages compared to the OP_RETURN method:
>
> 1. You need to first spend to he address that commits to the script that
> encodes your data payload. So you have a two step process of first
> spending to a "commitment" address and then a second spend to "reveal"
> your payload. You can CPFP to get them both into the same block, but its
> still two transactions, so more cost, etc.
>
> 2. Because of the two step process in (1), if for some reason you were
> unable to get the "reveal" transaction into a block (for example there's
> widespread censorship of transactions that match the format of the
> "reveal" script), then you might have money that's stuck in the "commit"
> stage of the protocol. The way out of this would be to get your money
> out via the keypath or another tapleaf, but then you need to spend money
> to cancel a step in your protocol. Of course there could be widespread
> censorship of your OP_RETURNs too, but you don't have to spend funds on
> the cancellation spends.
>
> I think (2) is actually a pretty weak argument because as we saw in the
> full-rbf discussion, as long as there's some threshold number of nodes
> in the network that relay transactions to miners, you can probably find
> a path to a miner (IIRC the number was on the order of 15% of the
> network?). So I think the big reason to pick OP_RETURN over the witness
> embedding is that you save a transaction and possibly some
> failure-recovery/cancellation logic.
>
> Obviously if your data is larger than 80 bytes, then you probably want
> to do the witness-embedding method. If your data smaller, then a
> pay-to-contract tweak probably the best thing from a space and
> fingerprinting perspective.
>
> - rijndael
>
>
> On 1/31/23 7:46 PM, Christopher Allen via bitcoin-dev wrote:
>> All other things being equal, which is better if you need to place a
>> 64-bytes into the Bitcoin blockchain? A traditional OP_RETURN or a
>> spent taproot transaction such as:
>>
>> OP_FALSE
>> OP_IF
>> OP_PUSH my64bytes
>> OP_ENDIF
>>
>> I know that the anti-OP_RETURN folk would say ?neither.? But if there
>> was no other choice for a particular protocol, such as a timestamp or
>> a commitment, which is better? Or is there a safer place to put 64
>> bytes that is more uncensorable but also does not clog UTXO space,
>> only spent transaction `-txindex` space?
>>
>> My best guess was that the taproot method is better, but I suspect
>> there might be some who disagree. I'd love to hear all sides.
>>
>> -- Christopher Allen
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Sophia-Antipolis, France
CV: https://www.peersm.com/CVAV.pdf
LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26
GitHub : https://www.github.com/Ayms
A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7
A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com
Peersm : http://www.peersm.com



From ChristopherA at lifewithalacrity.com  Fri Feb  3 18:47:17 2023
From: ChristopherA at lifewithalacrity.com (Christopher Allen)
Date: Fri, 3 Feb 2023 10:47:17 -0800
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <57f780b1-f262-9394-036c-70084320e9cf@peersm.com>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>
 <57f780b1-f262-9394-036c-70084320e9cf@peersm.com>
Message-ID: <CACrqygCNf3Gv8+VjhyqS4GTb3Epo8qXEKGtQB6sqyR6ib44-fA@mail.gmail.com>

On Fri, Feb 3, 2023 at 3:52 AM Aymeric Vitte via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I think the right way so people don't invent deviant things is to
> increase the size of OP_RETURN, I don't get this number of 80B, you can
> hardly store a signature (of what?) in there and not the "what" if the
> "what" is a hash for example
>

Updating the size of OP_RETURN to support a hash (or two), a signature, and
maybe a few more bytes for metadata, would be very helpful in a number of
scenarios. It is still a limit but a reasonable one. Otherwise, I think
we'll have a lot more inscription-style scenarios.

-- Christopher Allen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230203/b21fe300/attachment.html>

From melvincarvalho at gmail.com  Fri Feb  3 19:56:16 2023
From: melvincarvalho at gmail.com (Melvin Carvalho)
Date: Fri, 3 Feb 2023 20:56:16 +0100
Subject: [bitcoin-dev] Ordinal Inscription Size Limits
In-Reply-To: <CABHetKwan91zqm=0y=_84vG7ffveWTPYONZP_hLQx5o40iAnuQ@mail.gmail.com>
References: <CABHetKwan91zqm=0y=_84vG7ffveWTPYONZP_hLQx5o40iAnuQ@mail.gmail.com>
Message-ID: <CAKaEYhJ_8tph3v9n139Ta+3sBaL-TmeOBNr-cCtti9dbdYuhCQ@mail.gmail.com>

p? 27. 1. 2023 v 13:47 odes?latel Robert Dickinson via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> napsal:

> I'm curious what opinions exist and what actions might be taken by core
> developers regarding storing unlimited amounts of NFT (or other?) content
> as witness data (https://docs.ordinals.com/inscriptions.html). The
> ordinal scheme is elegant and genius IMHO, but when I think about the
> future disk use of all unpruned nodes, I question whether unlimited storage
> is wise to allow for such use cases. Wouldn't it be better to find a way to
> impose a size limit similar to OP_RETURN for such inscriptions?
>
> I think it would be useful to link a sat to a deed or other legal
> construct for proof of ownership in the real world, so that real property
> can be transferred on the blockchain using ordinals, but storing the
> property itself on the blockchain seems nonsensical to me.
>

Low tech solution: miners charge a premium for storing images in the block
chain.  Say 2x, 5x, 10x.

This encourages bitcoin to be used as a financial network, while increasing
the security budget.

>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230203/ecd518a8/attachment.html>

From pete at petertodd.org  Fri Feb  3 22:10:43 2023
From: pete at petertodd.org (Peter Todd)
Date: Fri, 3 Feb 2023 17:10:43 -0500
Subject: [bitcoin-dev] Ephemeral Anchors: Fixing V3 Package RBF
 againstpackage limit pinning
In-Reply-To: <CAB3F3Ds7Ux8MWnY-9Agehpk0hZx_xgeFmZG7hUjMkfe48T5GPA@mail.gmail.com>
References: <CAPfvXf+N8aF+bqjGzpfDrhCYg7ngciSDCpUnCMHD+k5F+m3oWA@mail.gmail.com>
 <CAB3F3DuDODUxB5aK4VFWa8sKFCkZfOj6Vjb+Wp39opyt8MNnEA@mail.gmail.com>
 <CAB3F3DtrSFPmperGJJAUDZj7vt9aHgvkc0b5Pts3+mq5fTuWXA@mail.gmail.com>
 <CAB3F3DvToF_fia+X5SQi-L=BDYGLpzr8nNHqjtFBUjLMbyPE9Q@mail.gmail.com>
 <Y9vOGVMJx1b9CPYq@petertodd.org>
 <CAB3F3Du2XsHCh5o5S84XKKizTkrTFJJ-j42-qunyuSRkwX7H_Q@mail.gmail.com>
 <Y9vRjQVnZzA8Bx/s@petertodd.org>
 <CAB3F3DvumE-r+LGm8ivooPD9qfzFs-NK9Ve06Ew1EMAifSx8dw@mail.gmail.com>
 <Y9wbjsmPO+nyM267@petertodd.org>
 <CAB3F3Ds7Ux8MWnY-9Agehpk0hZx_xgeFmZG7hUjMkfe48T5GPA@mail.gmail.com>
Message-ID: <Y92GY7s1U4P9fC/f@petertodd.org>

On Thu, Feb 02, 2023 at 03:47:28PM -0500, Greg Sanders wrote:
> > OP_TRUE is the obvious way to do this, and it results with a 1 on the
> stack,
> which plays better with other standardness rules.
> 
> What other standardness rules? MINAMALIF? How does that interact with the
> proposal?

It makes sense to require scripts to leave just a single OP_TRUE on the stack
at the end of execution, as otherwise that can be a source of malleability in
certain circumstances where the scriptSig ends up providing the OP_TRUE. I
don't believe we actually implement this as a rule right now. But you could
easily imagine that happening in a future upgrade.

Leaving an OP_2 on the stack doesn't achieve that and would require a
special-cased workaround. Spending the time now to do the obvious thing - use
OP_TRUE as the canonical anyone-can-spend output - avoids this issue.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230203/e563fd6c/attachment.sig>

From gsanders87 at gmail.com  Sat Feb  4 02:07:29 2023
From: gsanders87 at gmail.com (Greg Sanders)
Date: Fri, 3 Feb 2023 21:07:29 -0500
Subject: [bitcoin-dev] Ephemeral Anchors: Fixing V3 Package RBF
 againstpackage limit pinning
In-Reply-To: <Y92GY7s1U4P9fC/f@petertodd.org>
References: <CAPfvXf+N8aF+bqjGzpfDrhCYg7ngciSDCpUnCMHD+k5F+m3oWA@mail.gmail.com>
 <CAB3F3DuDODUxB5aK4VFWa8sKFCkZfOj6Vjb+Wp39opyt8MNnEA@mail.gmail.com>
 <CAB3F3DtrSFPmperGJJAUDZj7vt9aHgvkc0b5Pts3+mq5fTuWXA@mail.gmail.com>
 <CAB3F3DvToF_fia+X5SQi-L=BDYGLpzr8nNHqjtFBUjLMbyPE9Q@mail.gmail.com>
 <Y9vOGVMJx1b9CPYq@petertodd.org>
 <CAB3F3Du2XsHCh5o5S84XKKizTkrTFJJ-j42-qunyuSRkwX7H_Q@mail.gmail.com>
 <Y9vRjQVnZzA8Bx/s@petertodd.org>
 <CAB3F3DvumE-r+LGm8ivooPD9qfzFs-NK9Ve06Ew1EMAifSx8dw@mail.gmail.com>
 <Y9wbjsmPO+nyM267@petertodd.org>
 <CAB3F3Ds7Ux8MWnY-9Agehpk0hZx_xgeFmZG7hUjMkfe48T5GPA@mail.gmail.com>
 <Y92GY7s1U4P9fC/f@petertodd.org>
Message-ID: <CAB3F3Dtuxu8m6+pU_xBwh=35MyPF90OSnB4vhaNbKpr_ap2shw@mail.gmail.com>

I'm not particularly persuaded, but also not wedded to either idea.

Fixed up tests for the OP_TRUE case here:
https://github.com/instagibbs/bitcoin/tree/ephemeral-anchors-true

On Fri, Feb 3, 2023 at 5:10 PM Peter Todd <pete at petertodd.org> wrote:

> On Thu, Feb 02, 2023 at 03:47:28PM -0500, Greg Sanders wrote:
> > > OP_TRUE is the obvious way to do this, and it results with a 1 on the
> > stack,
> > which plays better with other standardness rules.
> >
> > What other standardness rules? MINAMALIF? How does that interact with the
> > proposal?
>
> It makes sense to require scripts to leave just a single OP_TRUE on the
> stack
> at the end of execution, as otherwise that can be a source of malleability
> in
> certain circumstances where the scriptSig ends up providing the OP_TRUE. I
> don't believe we actually implement this as a rule right now. But you could
> easily imagine that happening in a future upgrade.
>
> Leaving an OP_2 on the stack doesn't achieve that and would require a
> special-cased workaround. Spending the time now to do the obvious thing -
> use
> OP_TRUE as the canonical anyone-can-spend output - avoids this issue.
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230203/f6d3bb53/attachment-0001.html>

From aj at erisian.com.au  Sat Feb  4 10:38:54 2023
From: aj at erisian.com.au (Anthony Towns)
Date: Sat, 4 Feb 2023 20:38:54 +1000
Subject: [bitcoin-dev] Purely off-chain coin colouring
In-Reply-To: <CANLPe+Pa-D=JB8N5Qeokoyp=mRA3LLM=mtvvwPkpbHvV_bmEXQ@mail.gmail.com>
References: <CANLPe+Pa-D=JB8N5Qeokoyp=mRA3LLM=mtvvwPkpbHvV_bmEXQ@mail.gmail.com>
Message-ID: <Y941vsOOsZJHdnKT@erisian.com.au>

On Thu, Feb 02, 2023 at 10:39:21PM -0800, Casey Rodarmor via bitcoin-dev wrote:
> Apologies for posting! I've tried to keep discussion of ordinals and
> inscriptions off-list, because I consider it to be of little relevance to
> general Bitcoin development.

Anything that potentially uses up a large percentage of blockspace seems
pretty relevant to general Bitcoin development to me...

> AJ Towns writes:
> > I think, however, that you can move inscriptions entirely off-chain. I
> > wrote a little on this idea on twitter already [1], but after a bit more
> > thought, I think pushing things even further off-chain would be plausible.

I guess I should have explained why I think moving things off-chain is
a worthwhile goal. Riffing off:

> Another issue is salience and scarcity, as has been mentioned. Off-chain
> content is unbounded, and thus less scarce. Usually, we design for
> efficiency, volume, and scale. For NFT designs, which are intended to be
> collectable, this is in some ways counterproductive.

"scarce" has two meanings -- one is that there's not much of it, the
other is that it's highly valued (or a third, where it's is consistently
underpriced and unavailable even for people who'd pay more, but that
hopefully doesn't apply).

I think for bitcoin's blockspace, we ideally only want the first of
these to be true. We want small blocks because that makes it cheap to
verify bitcoin, which reduces the need to trust third parties and aids in
decentralisation. But we don't want blockspace to be especially valuable,
as that makes it expensive to use bitcoin, which then limits who can
use it.

Moving things off-chain helps with both these goals: it doesn't make it
harder to validate bitcoin, and it also decreases demand for blockspace,
making it cheaper for those cases where things can't be moved off-chain.

As a result of this approach, bitcoin blockspace is currently quite
cheap -- so inscribing at 100kB jpeg at 25kvB might cost perhaps $60 in
a peak period, or $6 if you wait for 1sat/vb to confirm. Not exactly a
luxury purchase.

If you keep jpegs on-chain, as far as I can see, there's three outcomes:

 * blockspace stays relatively cheap, and there's no "scarcity" benefit to
   minting via on-chain inscriptions; it's cheap enough to just mint
   any random meme, and there's no prestige to doing so

 * blockspace becomes filled with jpegs, driving up costs for everyone,
   making jpeg collectors happy, but transactors sad

 * the amount of blockspace is increased, keeping prices low, and
   reducing "scarcity" in both senses, so also making it harder to
   validate bitcoin. no one really wins.

I'd guess the first of these is the most likely, personally.

As far as salience/notability goes, personally, I'd see ownership of
inscriptions as a negative indicator; "hey, when I was young and foolish I
wasted x-thousand bytes on the bitcoin blockchain, pointlessly creating a
permanent cost for everyone trying to use bitcoin in future". That's not
unforgivable; people do all sorts of foolish things, and bitcoin's meant
to survive attacks, not just foolish pranks. But it doesn't seem like
something to brag about or encourage, either, at least if you want bitcoin
to be a monetary network that's usable in practice by many/most people.

(Even if one day that goes the other way, and there is real (and
transferable) social value in being able to say "I donated x sats to fees
to help secure bitcoin", such a claim is more charitable/admirable/value
with a smaller on-chain footprint, both in that it again keeps
validation easier, but also in that it makes it easier for others to
also simultaneously make the same charitable contribution)

> NFT collectors have a strong revealed preference for on-chain content. The
> content of high-value NFTs is often stored partially or completely on
> chain, 

When you identify an NFT by a url that points at someone else's server,
that's an obvious vulnerability, as Moxie demonstrated pretty well.

But solving that by saying "okay, we'll just externalise the storage
costs to the public, while privatising all the benefits" isn't a good
approach either.

> User protection when off-chain content is involved is fraught.

I mean, that seems trivially solvable? Users already have to store the
private key that controls ownership of these digital assets; storing the
asset as well, which doesn't need to be private, isn't a big ask. And if
a public site like ordinals.net is willing to store all the inscriptions
that might be on the blockchain, they could just as easily store the
same amount of off-chain digital assets.

> When a user buys an NFT with
> off-chain content, they now have the primary economic incentive to preserve
> that content, so that their NFT retains value and can be enjoyed or sold.

Yes -- the people who potentially benefit from the NFT should be the
ones paying the costs of preserving that NFT.

> Many existing NFT marketplaces that sell off-chain content do not explain
> this to users, or give users tools that the average, non-technical person
> can understand or use, which enables them to protect themselves. Even if
> they did give users these tools, there are tricky considerations involved.
> IPFS functions much like BitTorrent,

Externalising the costs to some different network while privatising the
benefits isn't any better than doing it to bitcoin; except in that maybe
you're inconveniencing fewer people.

Going back to this:

> Another issue is salience and scarcity, as has been mentioned. Off-chain
> content is unbounded, and thus less scarce. Usually, we design for
> efficiency, volume, and scale. For NFT designs, which are intended to be
> collectable, this is in some ways counterproductive.

Obviously blockchains aren't the only "scarce" good out there. If scarcity
is your goal, there's two very easy ways to make your own scarcity. 

One is requiring proof of work -- you could have a digital
asset marketplace that only allows works that have a hash with
at least 32 leading zero-bits [0] and use timestamping [1] (or a
certificate-transparency approach) to ensure that as proof-of-work
techonology improves, it can't be used to backdate mints.

[0] https://github.com/nostr-protocol/nips/blob/master/13.md
[1] https://github.com/nostr-protocol/nips/blob/master/03.md

Or the other approach is you just require people to pay you some sats
over lightning to host an NFT. That way you're the one collecting the
fees, not miners; and you're (perhaps) the one incurring an obligation
to preserve the NFT on behalf of its owners, rather than random bitcoin
node operators.

> The above issues also make the specification and implementation of NFTs
> with off-chain content much more difficult.

I'm not meaning to criticise you for doing what you think's interesting,
so if it's coming off that way I apologise in advance. I think it's
interesting, too. I just think that, when possible, off-chain is always
better than on-chain, and it's worth exploring that idea further.

In particular, I don't think it *is* actually much more difficult? Here's
how I'd change what you've done to turn ordinals.net into an off-chain
digital asset site:

 - setup a nostr relay, with submissions gated by proof of work, and
   no expiry. maybe https://github.com/Cameri/nostream ?

 - for any event that includes an "ordinal" tag, treat it as a digital
   asset, and add it to your digital asset database, just like you do now
   for inscriptions. either have your own nostr client that subscribes
   to your relay, or just query your relay's db directly.

 - have a regular proof of work adjustment targeting say 200MB worth of
   events per day (vs the 576MB per day of possible witness data).

 - update the ord tool to be able to encode digital artifacts into a nostr
   event, apply proof of work to it, and send it to (by default)
   your relay.

That would let nostr clients immediately just add your relay and get a
feed of minted digital artifacts, that's already spam-free due to the
proof of work requirement. They could follow all of them, or just follow
a particular artist by pubkey, too. An artist could publish a collection
by publishing an event defining the collection, then linking each artwork
to the collection as a "reply", making it pretty easy for nostr clients
to follow a collection, while still having each artwork linked to its
own ordinal, and I think without requiring any work on your behalf.

You don't need to change the way ordinals are spent at all for any of
this, I think; all you're doing is replacing the initial two transactions
that link the digital artifact with the ordinal with an off-chain message
achieving the same thing.

Then to go beyond what you've got you could:

 - add some support for the current owner of an ordinal to link that
   back to their nostr profile -- eg, sign a message with the pubkey
   based on the current utxo holding the ordinal, referencing the digial
   asset; you could perhaps use NIP-2 "following" messages for this.
   if you've already using an open social network, might as well take
   advantage of it.

 - add some support for the "social legitimacy" aspect -- eg linking
   all the assets created by the same public key as an artist's portfolio;
   make it easy to go from their nft-related pubkey to their regular
   nostr profile or similar.

 - let creators that have already somehow demonstrated "social legitimacy"
   bypass the proof of work requirement, since "great art" is already
   naturally scarce. creators who've demonstrated their quality shouldn't
   need to waste time or money doing proof of work or paying blockchain
   fees

Adding a lightning based patreon-type setup could be awesome there --
content creators post content to a closed relay, patrons pay a fee
over lightning to be able to receive events, and 90%+ of those fees
are passed on to creators. If creators are happy with subscriptions,
they just do that; if they want to auction off NFTs, they can do that;
if they want both, that works too...

> Additionally, I think the term "inscription" which has a connotation of
> permanence, and of an indelible association with a particular satoshi, is
> inappropriate for an off-chain NFT protocol.

No objections about the "inscription" definition, but I'm not sure if the
above means you're misunderstanding what I'm saying. In the off-chain
scheme I'm talking about, the "digital asset" includes the ordinal
that controls ownership, and is identified by the hash of its contents,
including that ordinal's identity -- so there is an indelible association
with a particular satoshi, despite it being an off-chain NFT protocol.

For example if you take two identical digital assets, such as:

  https://ordinals.net/inscription/8ed2594cecbd43e5673168ff160ba00a6d8953fea7ab6b15a112f3bc94adc2f8i0

  https://ordinals.net/inscription/31e9577f9af1d1823bc00539291f061e4ac9ba727162a8e0d8d7b80512966561i0

then in the off-chain world, they would look like two events:

  {
    pubkey: <Alice>
    kind: 0
    tags: [
      ord: "8ed2594cecbd43e5673168ff160ba00a6d8953fea7ab6b15a112f3bc94adc2f8:0:0"
    ]
    content: <av1.jpeg>
    id: <XXXX - hash of the above>
    sig: <sig by alice of XXXX>
  }

and

  {
    pubkey: <Alice>
    kind: 0
    tags: [
      ord: "31e9577f9af1d1823bc00539291f061e4ac9ba727162a8e0d8d7b80512966561:0:0"
    ]
    content: <av1.jpeg>
    id: <YYYY = hash of the above>
    sig: <sig by alice of YYYY>
  }

ie two unique digital assets, with two unique identifiers (XXXX and YYYY)
that are each indelibly linked with particular satoshis.

Obviously there's nothing stopping Alice minting the exact same content
to two different ordinals -- presumably that's what happened with
the two inscriptions above -- nor is there anything stopping Bob from
right-click-save-as and doing the same; but as above, that's obviously
true for inscriptions as well. The only truly unique thing is the specific
hash and the specific content that generated the hash.

The relationship does go the other way compared to inscriptions --
here you keep the association so long as you remember the asset; with
inscriptions you keep the association so long as you have bitcoin's
historical blocks. As I've said above, the off-chain approach seems
much better aligned with incentives to me, with the people who gain the
benefit from that association paying the cost of preserving it.

Cheers,
aj

From pete at petertodd.org  Sat Feb  4 13:06:32 2023
From: pete at petertodd.org (Peter Todd)
Date: Sat, 4 Feb 2023 08:06:32 -0500
Subject: [bitcoin-dev] Purely off-chain coin colouring
In-Reply-To: <Y941vsOOsZJHdnKT@erisian.com.au>
References: <CANLPe+Pa-D=JB8N5Qeokoyp=mRA3LLM=mtvvwPkpbHvV_bmEXQ@mail.gmail.com>
 <Y941vsOOsZJHdnKT@erisian.com.au>
Message-ID: <Y95YWB2ZLmeiknx6@petertodd.org>

On Sat, Feb 04, 2023 at 08:38:54PM +1000, Anthony Towns via bitcoin-dev wrote:
> I think for bitcoin's blockspace, we ideally only want the first of
> these to be true. We want small blocks because that makes it cheap to
> verify bitcoin, which reduces the need to trust third parties and aids in
> decentralisation. But we don't want blockspace to be especially valuable,
> as that makes it expensive to use bitcoin, which then limits who can
> use it.

We certainly do want blockspace to be valuable, as transaction fees have to
both be in constant demand, and rise enough to replace the inflation subsidy if
Bitcoin is to remain secure in the future. In fact at the moment, the inflation
subsidy pays miners about 50x more than fees do. Ordinals and other publication
mechanisms are of course ways that we can drive consistent demand for block
space, keeping Bitcoin secure.

Are you arguing that we should change the inflation subsidy phase-out, eg by
introducing tail emission(1) or demurrage?

1) https://petertodd.org/2022/surprisingly-tail-emission-is-not-inflationary

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230204/a526f596/attachment.sig>

From aymeric at peersm.com  Sat Feb  4 11:36:54 2023
From: aymeric at peersm.com (Aymeric Vitte)
Date: Sat, 4 Feb 2023 12:36:54 +0100
Subject: [bitcoin-dev] Purely off-chain coin colouring
In-Reply-To: <Y941vsOOsZJHdnKT@erisian.com.au>
References: <CANLPe+Pa-D=JB8N5Qeokoyp=mRA3LLM=mtvvwPkpbHvV_bmEXQ@mail.gmail.com>
 <Y941vsOOsZJHdnKT@erisian.com.au>
Message-ID: <1ebd4888-dc24-f423-b97b-fadba922bf00@peersm.com>

I still don't see in both proposals how you avoid that someone steals
your NFT, double mint it or sell it several time, because the thief can
do the very same that what your are describing, a hash of the content is
not enough, you can slightly modify an image or a document and it gives
another hash, as far as I know in all existing systems today there are
zero protection against this, I am quoting also Moxie's experience in my
proposals

That's why I am proposing the third party with a timestamp and a double
hash not related to the content itself, and the secret NFT, I don't see
the point to buy millions some electronic art that everyone can get for free

Anyway, I mostly consider that a NFT is a real good that you buy in the
metaverse, not only an electronic thing


Le 04/02/2023 ? 11:38, Anthony Towns via bitcoin-dev a ?crit :
> On Thu, Feb 02, 2023 at 10:39:21PM -0800, Casey Rodarmor via bitcoin-dev wrote:
>> Apologies for posting! I've tried to keep discussion of ordinals and
>> inscriptions off-list, because I consider it to be of little relevance to
>> general Bitcoin development.
> Anything that potentially uses up a large percentage of blockspace seems
> pretty relevant to general Bitcoin development to me...
>
>> AJ Towns writes:
>>> I think, however, that you can move inscriptions entirely off-chain. I
>>> wrote a little on this idea on twitter already [1], but after a bit more
>>> thought, I think pushing things even further off-chain would be plausible.
> I guess I should have explained why I think moving things off-chain is
> a worthwhile goal. Riffing off:
>
>> Another issue is salience and scarcity, as has been mentioned. Off-chain
>> content is unbounded, and thus less scarce. Usually, we design for
>> efficiency, volume, and scale. For NFT designs, which are intended to be
>> collectable, this is in some ways counterproductive.
> "scarce" has two meanings -- one is that there's not much of it, the
> other is that it's highly valued (or a third, where it's is consistently
> underpriced and unavailable even for people who'd pay more, but that
> hopefully doesn't apply).
>
> I think for bitcoin's blockspace, we ideally only want the first of
> these to be true. We want small blocks because that makes it cheap to
> verify bitcoin, which reduces the need to trust third parties and aids in
> decentralisation. But we don't want blockspace to be especially valuable,
> as that makes it expensive to use bitcoin, which then limits who can
> use it.
>
> Moving things off-chain helps with both these goals: it doesn't make it
> harder to validate bitcoin, and it also decreases demand for blockspace,
> making it cheaper for those cases where things can't be moved off-chain.
>
> As a result of this approach, bitcoin blockspace is currently quite
> cheap -- so inscribing at 100kB jpeg at 25kvB might cost perhaps $60 in
> a peak period, or $6 if you wait for 1sat/vb to confirm. Not exactly a
> luxury purchase.
>
> If you keep jpegs on-chain, as far as I can see, there's three outcomes:
>
>  * blockspace stays relatively cheap, and there's no "scarcity" benefit to
>    minting via on-chain inscriptions; it's cheap enough to just mint
>    any random meme, and there's no prestige to doing so
>
>  * blockspace becomes filled with jpegs, driving up costs for everyone,
>    making jpeg collectors happy, but transactors sad
>
>  * the amount of blockspace is increased, keeping prices low, and
>    reducing "scarcity" in both senses, so also making it harder to
>    validate bitcoin. no one really wins.
>
> I'd guess the first of these is the most likely, personally.
>
> As far as salience/notability goes, personally, I'd see ownership of
> inscriptions as a negative indicator; "hey, when I was young and foolish I
> wasted x-thousand bytes on the bitcoin blockchain, pointlessly creating a
> permanent cost for everyone trying to use bitcoin in future". That's not
> unforgivable; people do all sorts of foolish things, and bitcoin's meant
> to survive attacks, not just foolish pranks. But it doesn't seem like
> something to brag about or encourage, either, at least if you want bitcoin
> to be a monetary network that's usable in practice by many/most people.
>
> (Even if one day that goes the other way, and there is real (and
> transferable) social value in being able to say "I donated x sats to fees
> to help secure bitcoin", such a claim is more charitable/admirable/value
> with a smaller on-chain footprint, both in that it again keeps
> validation easier, but also in that it makes it easier for others to
> also simultaneously make the same charitable contribution)
>
>> NFT collectors have a strong revealed preference for on-chain content. The
>> content of high-value NFTs is often stored partially or completely on
>> chain, 
> When you identify an NFT by a url that points at someone else's server,
> that's an obvious vulnerability, as Moxie demonstrated pretty well.
>
> But solving that by saying "okay, we'll just externalise the storage
> costs to the public, while privatising all the benefits" isn't a good
> approach either.
>
>> User protection when off-chain content is involved is fraught.
> I mean, that seems trivially solvable? Users already have to store the
> private key that controls ownership of these digital assets; storing the
> asset as well, which doesn't need to be private, isn't a big ask. And if
> a public site like ordinals.net is willing to store all the inscriptions
> that might be on the blockchain, they could just as easily store the
> same amount of off-chain digital assets.
>
>> When a user buys an NFT with
>> off-chain content, they now have the primary economic incentive to preserve
>> that content, so that their NFT retains value and can be enjoyed or sold.
> Yes -- the people who potentially benefit from the NFT should be the
> ones paying the costs of preserving that NFT.
>
>> Many existing NFT marketplaces that sell off-chain content do not explain
>> this to users, or give users tools that the average, non-technical person
>> can understand or use, which enables them to protect themselves. Even if
>> they did give users these tools, there are tricky considerations involved.
>> IPFS functions much like BitTorrent,
> Externalising the costs to some different network while privatising the
> benefits isn't any better than doing it to bitcoin; except in that maybe
> you're inconveniencing fewer people.
>
> Going back to this:
>
>> Another issue is salience and scarcity, as has been mentioned. Off-chain
>> content is unbounded, and thus less scarce. Usually, we design for
>> efficiency, volume, and scale. For NFT designs, which are intended to be
>> collectable, this is in some ways counterproductive.
> Obviously blockchains aren't the only "scarce" good out there. If scarcity
> is your goal, there's two very easy ways to make your own scarcity. 
>
> One is requiring proof of work -- you could have a digital
> asset marketplace that only allows works that have a hash with
> at least 32 leading zero-bits [0] and use timestamping [1] (or a
> certificate-transparency approach) to ensure that as proof-of-work
> techonology improves, it can't be used to backdate mints.
>
> [0] https://github.com/nostr-protocol/nips/blob/master/13.md
> [1] https://github.com/nostr-protocol/nips/blob/master/03.md
>
> Or the other approach is you just require people to pay you some sats
> over lightning to host an NFT. That way you're the one collecting the
> fees, not miners; and you're (perhaps) the one incurring an obligation
> to preserve the NFT on behalf of its owners, rather than random bitcoin
> node operators.
>
>> The above issues also make the specification and implementation of NFTs
>> with off-chain content much more difficult.
> I'm not meaning to criticise you for doing what you think's interesting,
> so if it's coming off that way I apologise in advance. I think it's
> interesting, too. I just think that, when possible, off-chain is always
> better than on-chain, and it's worth exploring that idea further.
>
> In particular, I don't think it *is* actually much more difficult? Here's
> how I'd change what you've done to turn ordinals.net into an off-chain
> digital asset site:
>
>  - setup a nostr relay, with submissions gated by proof of work, and
>    no expiry. maybe https://github.com/Cameri/nostream ?
>
>  - for any event that includes an "ordinal" tag, treat it as a digital
>    asset, and add it to your digital asset database, just like you do now
>    for inscriptions. either have your own nostr client that subscribes
>    to your relay, or just query your relay's db directly.
>
>  - have a regular proof of work adjustment targeting say 200MB worth of
>    events per day (vs the 576MB per day of possible witness data).
>
>  - update the ord tool to be able to encode digital artifacts into a nostr
>    event, apply proof of work to it, and send it to (by default)
>    your relay.
>
> That would let nostr clients immediately just add your relay and get a
> feed of minted digital artifacts, that's already spam-free due to the
> proof of work requirement. They could follow all of them, or just follow
> a particular artist by pubkey, too. An artist could publish a collection
> by publishing an event defining the collection, then linking each artwork
> to the collection as a "reply", making it pretty easy for nostr clients
> to follow a collection, while still having each artwork linked to its
> own ordinal, and I think without requiring any work on your behalf.
>
> You don't need to change the way ordinals are spent at all for any of
> this, I think; all you're doing is replacing the initial two transactions
> that link the digital artifact with the ordinal with an off-chain message
> achieving the same thing.
>
> Then to go beyond what you've got you could:
>
>  - add some support for the current owner of an ordinal to link that
>    back to their nostr profile -- eg, sign a message with the pubkey
>    based on the current utxo holding the ordinal, referencing the digial
>    asset; you could perhaps use NIP-2 "following" messages for this.
>    if you've already using an open social network, might as well take
>    advantage of it.
>
>  - add some support for the "social legitimacy" aspect -- eg linking
>    all the assets created by the same public key as an artist's portfolio;
>    make it easy to go from their nft-related pubkey to their regular
>    nostr profile or similar.
>
>  - let creators that have already somehow demonstrated "social legitimacy"
>    bypass the proof of work requirement, since "great art" is already
>    naturally scarce. creators who've demonstrated their quality shouldn't
>    need to waste time or money doing proof of work or paying blockchain
>    fees
>
> Adding a lightning based patreon-type setup could be awesome there --
> content creators post content to a closed relay, patrons pay a fee
> over lightning to be able to receive events, and 90%+ of those fees
> are passed on to creators. If creators are happy with subscriptions,
> they just do that; if they want to auction off NFTs, they can do that;
> if they want both, that works too...
>
>> Additionally, I think the term "inscription" which has a connotation of
>> permanence, and of an indelible association with a particular satoshi, is
>> inappropriate for an off-chain NFT protocol.
> No objections about the "inscription" definition, but I'm not sure if the
> above means you're misunderstanding what I'm saying. In the off-chain
> scheme I'm talking about, the "digital asset" includes the ordinal
> that controls ownership, and is identified by the hash of its contents,
> including that ordinal's identity -- so there is an indelible association
> with a particular satoshi, despite it being an off-chain NFT protocol.
>
> For example if you take two identical digital assets, such as:
>
>   https://ordinals.net/inscription/8ed2594cecbd43e5673168ff160ba00a6d8953fea7ab6b15a112f3bc94adc2f8i0
>
>   https://ordinals.net/inscription/31e9577f9af1d1823bc00539291f061e4ac9ba727162a8e0d8d7b80512966561i0
>
> then in the off-chain world, they would look like two events:
>
>   {
>     pubkey: <Alice>
>     kind: 0
>     tags: [
>       ord: "8ed2594cecbd43e5673168ff160ba00a6d8953fea7ab6b15a112f3bc94adc2f8:0:0"
>     ]
>     content: <av1.jpeg>
>     id: <XXXX - hash of the above>
>     sig: <sig by alice of XXXX>
>   }
>
> and
>
>   {
>     pubkey: <Alice>
>     kind: 0
>     tags: [
>       ord: "31e9577f9af1d1823bc00539291f061e4ac9ba727162a8e0d8d7b80512966561:0:0"
>     ]
>     content: <av1.jpeg>
>     id: <YYYY = hash of the above>
>     sig: <sig by alice of YYYY>
>   }
>
> ie two unique digital assets, with two unique identifiers (XXXX and YYYY)
> that are each indelibly linked with particular satoshis.
>
> Obviously there's nothing stopping Alice minting the exact same content
> to two different ordinals -- presumably that's what happened with
> the two inscriptions above -- nor is there anything stopping Bob from
> right-click-save-as and doing the same; but as above, that's obviously
> true for inscriptions as well. The only truly unique thing is the specific
> hash and the specific content that generated the hash.
>
> The relationship does go the other way compared to inscriptions --
> here you keep the association so long as you remember the asset; with
> inscriptions you keep the association so long as you have bitcoin's
> historical blocks. As I've said above, the off-chain approach seems
> much better aligned with incentives to me, with the people who gain the
> benefit from that association paying the cost of preserving it.
>
> Cheers,
> aj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Sophia-Antipolis, France
CV: https://www.peersm.com/CVAV.pdf
LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26
GitHub : https://www.github.com/Ayms
A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7
A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com
Peersm : http://www.peersm.com



From alicexbt at protonmail.com  Sat Feb  4 13:02:44 2023
From: alicexbt at protonmail.com (alicexbt)
Date: Sat, 04 Feb 2023 13:02:44 +0000
Subject: [bitcoin-dev] Purely off-chain coin colouring
In-Reply-To: <Y941vsOOsZJHdnKT@erisian.com.au>
References: <CANLPe+Pa-D=JB8N5Qeokoyp=mRA3LLM=mtvvwPkpbHvV_bmEXQ@mail.gmail.com>
 <Y941vsOOsZJHdnKT@erisian.com.au>
Message-ID: <Chw5YOIKGnaIB-wcu3CLdNyfT4JoMmrqMmT68jtG4nv75N_SchnB7MPQ_hmRgz2MK-tuIPBqmYp0qA13VQUHevmsjDzKE_2XY0WK2qhlL4c=@protonmail.com>

Hi Anthony,

> As far as salience/notability goes, personally, I'd see ownership of
inscriptions as a negative indicator; "hey, when I was young and foolish I
wasted x-thousand bytes on the bitcoin blockchain, pointlessly creating a
permanent cost for everyone trying to use bitcoin in future". That's not
unforgivable; people do all sorts of foolish things, and bitcoin's meant
to survive attacks, not just foolish pranks. But it doesn't seem like
something to brag about or encourage, either, at least if you want bitcoin
to be a monetary network that's usable in practice by many/most people.

Moving transactions off-chain because of emotions or personal opinions does not make sense. 
Everyone running a bitcoin node is aware of block limits and they could be filled with different type of transactions including [non-inscription txs][0] that use witness for complex scripts.

> And if
a public site like ordinals.net is willing to store all the inscriptions
that might be on the blockchain, they could just as easily store the
same amount of off-chain digital assets.

[Ord explorer][1] is open source and gets inscriptions from blockchain.

> Obviously blockchains aren't the only "scarce" good out there. If scarcity
is your goal, there's two very easy ways to make your own scarcity. 

Using pow doesn't make nostr relays "scarce". Its mainly used to avoid spam but some spammers on nostr have proved it isn't enough. 

> then in the off-chain world, they would look like two events:

Nostr relays do not guarantee that these events will be stored [forever][2].

> As I've said above, the off-chain approach seems
much better aligned with incentives to me, with the people who gain the
benefit from that association paying the cost of preserving it.

Cost for running bitcoin node do not change with inscriptions and do not depend on the content or intent of any bitcoin transaction. It is a permissionless network and users can decide how to use money and blockspace.

Campaigns to censor such transactions or other efforts to move them off-chain are creating a slippery slope that could affect bitcoin more than some inscriptions. If Casey is harassed enough on social media and ord project moves inscriptions off-chain, there would be forks of it doing it on-chain.


[0]: https://twitter.com/mononautical/status/1621663167582437376
[1]: https://github.com/casey/ord
[2]: https://twitter.com/damusapp/status/1621431556048035841


dev/fd0
floppy disc guy

Sent with Proton Mail secure email.

------- Original Message -------
On Saturday, February 4th, 2023 at 4:08 PM, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:


> On Thu, Feb 02, 2023 at 10:39:21PM -0800, Casey Rodarmor via bitcoin-dev wrote:
> 
> > Apologies for posting! I've tried to keep discussion of ordinals and
> > inscriptions off-list, because I consider it to be of little relevance to
> > general Bitcoin development.
> 
> 
> Anything that potentially uses up a large percentage of blockspace seems
> pretty relevant to general Bitcoin development to me...
> 
> > AJ Towns writes:
> > 
> > > I think, however, that you can move inscriptions entirely off-chain. I
> > > wrote a little on this idea on twitter already [1], but after a bit more
> > > thought, I think pushing things even further off-chain would be plausible.
> 
> 
> I guess I should have explained why I think moving things off-chain is
> a worthwhile goal. Riffing off:
> 
> > Another issue is salience and scarcity, as has been mentioned. Off-chain
> > content is unbounded, and thus less scarce. Usually, we design for
> > efficiency, volume, and scale. For NFT designs, which are intended to be
> > collectable, this is in some ways counterproductive.
> 
> 
> "scarce" has two meanings -- one is that there's not much of it, the
> other is that it's highly valued (or a third, where it's is consistently
> underpriced and unavailable even for people who'd pay more, but that
> hopefully doesn't apply).
> 
> I think for bitcoin's blockspace, we ideally only want the first of
> these to be true. We want small blocks because that makes it cheap to
> verify bitcoin, which reduces the need to trust third parties and aids in
> decentralisation. But we don't want blockspace to be especially valuable,
> as that makes it expensive to use bitcoin, which then limits who can
> use it.
> 
> Moving things off-chain helps with both these goals: it doesn't make it
> harder to validate bitcoin, and it also decreases demand for blockspace,
> making it cheaper for those cases where things can't be moved off-chain.
> 
> As a result of this approach, bitcoin blockspace is currently quite
> cheap -- so inscribing at 100kB jpeg at 25kvB might cost perhaps $60 in
> a peak period, or $6 if you wait for 1sat/vb to confirm. Not exactly a
> luxury purchase.
> 
> If you keep jpegs on-chain, as far as I can see, there's three outcomes:
> 
> * blockspace stays relatively cheap, and there's no "scarcity" benefit to
> minting via on-chain inscriptions; it's cheap enough to just mint
> any random meme, and there's no prestige to doing so
> 
> * blockspace becomes filled with jpegs, driving up costs for everyone,
> making jpeg collectors happy, but transactors sad
> 
> * the amount of blockspace is increased, keeping prices low, and
> reducing "scarcity" in both senses, so also making it harder to
> validate bitcoin. no one really wins.
> 
> I'd guess the first of these is the most likely, personally.
> 
> As far as salience/notability goes, personally, I'd see ownership of
> inscriptions as a negative indicator; "hey, when I was young and foolish I
> wasted x-thousand bytes on the bitcoin blockchain, pointlessly creating a
> permanent cost for everyone trying to use bitcoin in future". That's not
> unforgivable; people do all sorts of foolish things, and bitcoin's meant
> to survive attacks, not just foolish pranks. But it doesn't seem like
> something to brag about or encourage, either, at least if you want bitcoin
> to be a monetary network that's usable in practice by many/most people.
> 
> (Even if one day that goes the other way, and there is real (and
> transferable) social value in being able to say "I donated x sats to fees
> to help secure bitcoin", such a claim is more charitable/admirable/value
> with a smaller on-chain footprint, both in that it again keeps
> validation easier, but also in that it makes it easier for others to
> also simultaneously make the same charitable contribution)
> 
> > NFT collectors have a strong revealed preference for on-chain content. The
> > content of high-value NFTs is often stored partially or completely on
> > chain,
> 
> 
> When you identify an NFT by a url that points at someone else's server,
> that's an obvious vulnerability, as Moxie demonstrated pretty well.
> 
> But solving that by saying "okay, we'll just externalise the storage
> costs to the public, while privatising all the benefits" isn't a good
> approach either.
> 
> > User protection when off-chain content is involved is fraught.
> 
> 
> I mean, that seems trivially solvable? Users already have to store the
> private key that controls ownership of these digital assets; storing the
> asset as well, which doesn't need to be private, isn't a big ask. And if
> a public site like ordinals.net is willing to store all the inscriptions
> that might be on the blockchain, they could just as easily store the
> same amount of off-chain digital assets.
> 
> > When a user buys an NFT with
> > off-chain content, they now have the primary economic incentive to preserve
> > that content, so that their NFT retains value and can be enjoyed or sold.
> 
> 
> Yes -- the people who potentially benefit from the NFT should be the
> ones paying the costs of preserving that NFT.
> 
> > Many existing NFT marketplaces that sell off-chain content do not explain
> > this to users, or give users tools that the average, non-technical person
> > can understand or use, which enables them to protect themselves. Even if
> > they did give users these tools, there are tricky considerations involved.
> > IPFS functions much like BitTorrent,
> 
> 
> Externalising the costs to some different network while privatising the
> benefits isn't any better than doing it to bitcoin; except in that maybe
> you're inconveniencing fewer people.
> 
> Going back to this:
> 
> > Another issue is salience and scarcity, as has been mentioned. Off-chain
> > content is unbounded, and thus less scarce. Usually, we design for
> > efficiency, volume, and scale. For NFT designs, which are intended to be
> > collectable, this is in some ways counterproductive.
> 
> 
> Obviously blockchains aren't the only "scarce" good out there. If scarcity
> is your goal, there's two very easy ways to make your own scarcity.
> 
> One is requiring proof of work -- you could have a digital
> asset marketplace that only allows works that have a hash with
> at least 32 leading zero-bits [0] and use timestamping [1] (or a
> certificate-transparency approach) to ensure that as proof-of-work
> techonology improves, it can't be used to backdate mints.
> 
> [0] https://github.com/nostr-protocol/nips/blob/master/13.md
> [1] https://github.com/nostr-protocol/nips/blob/master/03.md
> 
> Or the other approach is you just require people to pay you some sats
> over lightning to host an NFT. That way you're the one collecting the
> fees, not miners; and you're (perhaps) the one incurring an obligation
> to preserve the NFT on behalf of its owners, rather than random bitcoin
> node operators.
> 
> > The above issues also make the specification and implementation of NFTs
> > with off-chain content much more difficult.
> 
> 
> I'm not meaning to criticise you for doing what you think's interesting,
> so if it's coming off that way I apologise in advance. I think it's
> interesting, too. I just think that, when possible, off-chain is always
> better than on-chain, and it's worth exploring that idea further.
> 
> In particular, I don't think it is actually much more difficult? Here's
> how I'd change what you've done to turn ordinals.net into an off-chain
> digital asset site:
> 
> - setup a nostr relay, with submissions gated by proof of work, and
> no expiry. maybe https://github.com/Cameri/nostream ?
> 
> - for any event that includes an "ordinal" tag, treat it as a digital
> asset, and add it to your digital asset database, just like you do now
> for inscriptions. either have your own nostr client that subscribes
> to your relay, or just query your relay's db directly.
> 
> - have a regular proof of work adjustment targeting say 200MB worth of
> events per day (vs the 576MB per day of possible witness data).
> 
> - update the ord tool to be able to encode digital artifacts into a nostr
> event, apply proof of work to it, and send it to (by default)
> your relay.
> 
> That would let nostr clients immediately just add your relay and get a
> feed of minted digital artifacts, that's already spam-free due to the
> proof of work requirement. They could follow all of them, or just follow
> a particular artist by pubkey, too. An artist could publish a collection
> by publishing an event defining the collection, then linking each artwork
> to the collection as a "reply", making it pretty easy for nostr clients
> to follow a collection, while still having each artwork linked to its
> own ordinal, and I think without requiring any work on your behalf.
> 
> You don't need to change the way ordinals are spent at all for any of
> this, I think; all you're doing is replacing the initial two transactions
> that link the digital artifact with the ordinal with an off-chain message
> achieving the same thing.
> 
> Then to go beyond what you've got you could:
> 
> - add some support for the current owner of an ordinal to link that
> back to their nostr profile -- eg, sign a message with the pubkey
> based on the current utxo holding the ordinal, referencing the digial
> asset; you could perhaps use NIP-2 "following" messages for this.
> if you've already using an open social network, might as well take
> advantage of it.
> 
> - add some support for the "social legitimacy" aspect -- eg linking
> all the assets created by the same public key as an artist's portfolio;
> make it easy to go from their nft-related pubkey to their regular
> nostr profile or similar.
> 
> - let creators that have already somehow demonstrated "social legitimacy"
> bypass the proof of work requirement, since "great art" is already
> naturally scarce. creators who've demonstrated their quality shouldn't
> need to waste time or money doing proof of work or paying blockchain
> fees
> 
> Adding a lightning based patreon-type setup could be awesome there --
> content creators post content to a closed relay, patrons pay a fee
> over lightning to be able to receive events, and 90%+ of those fees
> are passed on to creators. If creators are happy with subscriptions,
> they just do that; if they want to auction off NFTs, they can do that;
> if they want both, that works too...
> 
> > Additionally, I think the term "inscription" which has a connotation of
> > permanence, and of an indelible association with a particular satoshi, is
> > inappropriate for an off-chain NFT protocol.
> 
> 
> No objections about the "inscription" definition, but I'm not sure if the
> above means you're misunderstanding what I'm saying. In the off-chain
> scheme I'm talking about, the "digital asset" includes the ordinal
> that controls ownership, and is identified by the hash of its contents,
> including that ordinal's identity -- so there is an indelible association
> with a particular satoshi, despite it being an off-chain NFT protocol.
> 
> For example if you take two identical digital assets, such as:
> 
> https://ordinals.net/inscription/8ed2594cecbd43e5673168ff160ba00a6d8953fea7ab6b15a112f3bc94adc2f8i0
> 
> https://ordinals.net/inscription/31e9577f9af1d1823bc00539291f061e4ac9ba727162a8e0d8d7b80512966561i0
> 
> then in the off-chain world, they would look like two events:
> 
> {
> pubkey: <Alice>
> 
> kind: 0
> tags: [
> ord: "8ed2594cecbd43e5673168ff160ba00a6d8953fea7ab6b15a112f3bc94adc2f8:0:0"
> ]
> content: <av1.jpeg>
> 
> id: <XXXX - hash of the above>
> 
> sig: <sig by alice of XXXX>
> 
> }
> 
> and
> 
> {
> pubkey: <Alice>
> 
> kind: 0
> tags: [
> ord: "31e9577f9af1d1823bc00539291f061e4ac9ba727162a8e0d8d7b80512966561:0:0"
> ]
> content: <av1.jpeg>
> 
> id: <YYYY = hash of the above>
> 
> sig: <sig by alice of YYYY>
> 
> }
> 
> ie two unique digital assets, with two unique identifiers (XXXX and YYYY)
> that are each indelibly linked with particular satoshis.
> 
> Obviously there's nothing stopping Alice minting the exact same content
> to two different ordinals -- presumably that's what happened with
> the two inscriptions above -- nor is there anything stopping Bob from
> right-click-save-as and doing the same; but as above, that's obviously
> true for inscriptions as well. The only truly unique thing is the specific
> hash and the specific content that generated the hash.
> 
> The relationship does go the other way compared to inscriptions --
> here you keep the association so long as you remember the asset; with
> inscriptions you keep the association so long as you have bitcoin's
> historical blocks. As I've said above, the off-chain approach seems
> much better aligned with incentives to me, with the people who gain the
> benefit from that association paying the cost of preserving it.
> 
> Cheers,
> aj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From kkarasavvas at gmail.com  Sat Feb  4 14:11:33 2023
From: kkarasavvas at gmail.com (Kostas Karasavvas)
Date: Sat, 4 Feb 2023 16:11:33 +0200
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <CACrqygCNf3Gv8+VjhyqS4GTb3Epo8qXEKGtQB6sqyR6ib44-fA@mail.gmail.com>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>
 <57f780b1-f262-9394-036c-70084320e9cf@peersm.com>
 <CACrqygCNf3Gv8+VjhyqS4GTb3Epo8qXEKGtQB6sqyR6ib44-fA@mail.gmail.com>
Message-ID: <CABE6yHtM2Dqc63_eURSr7dMirJti5sYnqvHj7vQ_Ab9FC_d04g@mail.gmail.com>

On Fri, Feb 3, 2023 at 10:17 PM Christopher Allen via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Fri, Feb 3, 2023 at 3:52 AM Aymeric Vitte via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> I think the right way so people don't invent deviant things is to
>> increase the size of OP_RETURN, I don't get this number of 80B, you can
>> hardly store a signature (of what?) in there and not the "what" if the
>> "what" is a hash for example
>>
>
> Updating the size of OP_RETURN to support a hash (or two), a signature,
> and maybe a few more bytes for metadata, would be very helpful in a number
> of scenarios. It is still a limit but a reasonable one. Otherwise, I think
> we'll have a lot more inscription-style scenarios.
>

I wouldn't be against an increase in OP_RETURN but I don't think it will
make any difference in how often inscription-style use cases will be used.
They will be used primarily for much larger datasets than, say 120 bytes,
and they also have the segwit discount.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230204/c2c7730d/attachment.html>

From kkarasavvas at gmail.com  Sat Feb  4 14:25:58 2023
From: kkarasavvas at gmail.com (Kostas Karasavvas)
Date: Sat, 4 Feb 2023 16:25:58 +0200
Subject: [bitcoin-dev] Ordinal Inscription Size Limits
In-Reply-To: <CAKaEYhJ_8tph3v9n139Ta+3sBaL-TmeOBNr-cCtti9dbdYuhCQ@mail.gmail.com>
References: <CABHetKwan91zqm=0y=_84vG7ffveWTPYONZP_hLQx5o40iAnuQ@mail.gmail.com>
 <CAKaEYhJ_8tph3v9n139Ta+3sBaL-TmeOBNr-cCtti9dbdYuhCQ@mail.gmail.com>
Message-ID: <CABE6yHvRihAbP3NYOiAiXmRFQu-28Rnz6QBn17bHxBwM-V4wdw@mail.gmail.com>

On Fri, Feb 3, 2023 at 10:17 PM Melvin Carvalho via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
>
> p? 27. 1. 2023 v 13:47 odes?latel Robert Dickinson via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> napsal:
>
>> I'm curious what opinions exist and what actions might be taken by core
>> developers regarding storing unlimited amounts of NFT (or other?) content
>> as witness data (https://docs.ordinals.com/inscriptions.html). The
>> ordinal scheme is elegant and genius IMHO, but when I think about the
>> future disk use of all unpruned nodes, I question whether unlimited storage
>> is wise to allow for such use cases. Wouldn't it be better to find a way to
>> impose a size limit similar to OP_RETURN for such inscriptions?
>>
>>
Personally, I was always considering future disk use at full capacity
anyway (and planning accordingly). Even without inscriptions/ordinals that
would happen. The latter competes for block space and are paying tx fees so
I don't see it as that much harmful (esp.now that it is out there... I
would be more conservative if we were talking about introducing it!).



> I think it would be useful to link a sat to a deed or other legal
>> construct for proof of ownership in the real world, so that real property
>> can be transferred on the blockchain using ordinals, but storing the
>> property itself on the blockchain seems nonsensical to me.
>>
>
> Low tech solution: miners charge a premium for storing images in the block
> chain.  Say 2x, 5x, 10x.
>
> This encourages bitcoin to be used as a financial network, while
> increasing the security budget.
>

How would you enforce this technically?  I only see it feasible if miners
agree by social contract.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230204/864a905e/attachment.html>

From pete at petertodd.org  Sat Feb  4 16:02:45 2023
From: pete at petertodd.org (Peter Todd)
Date: Sat, 4 Feb 2023 11:02:45 -0500
Subject: [bitcoin-dev] Ephemeral Anchors: Fixing V3 Package RBF
 againstpackage limit pinning
In-Reply-To: <CAB3F3Dtuxu8m6+pU_xBwh=35MyPF90OSnB4vhaNbKpr_ap2shw@mail.gmail.com>
References: <CAB3F3DtrSFPmperGJJAUDZj7vt9aHgvkc0b5Pts3+mq5fTuWXA@mail.gmail.com>
 <CAB3F3DvToF_fia+X5SQi-L=BDYGLpzr8nNHqjtFBUjLMbyPE9Q@mail.gmail.com>
 <Y9vOGVMJx1b9CPYq@petertodd.org>
 <CAB3F3Du2XsHCh5o5S84XKKizTkrTFJJ-j42-qunyuSRkwX7H_Q@mail.gmail.com>
 <Y9vRjQVnZzA8Bx/s@petertodd.org>
 <CAB3F3DvumE-r+LGm8ivooPD9qfzFs-NK9Ve06Ew1EMAifSx8dw@mail.gmail.com>
 <Y9wbjsmPO+nyM267@petertodd.org>
 <CAB3F3Ds7Ux8MWnY-9Agehpk0hZx_xgeFmZG7hUjMkfe48T5GPA@mail.gmail.com>
 <Y92GY7s1U4P9fC/f@petertodd.org>
 <CAB3F3Dtuxu8m6+pU_xBwh=35MyPF90OSnB4vhaNbKpr_ap2shw@mail.gmail.com>
Message-ID: <Y96BpabeyHyWphp5@petertodd.org>

On Fri, Feb 03, 2023 at 09:07:29PM -0500, Greg Sanders wrote:
> I'm not particularly persuaded, but also not wedded to either idea.
> 
> Fixed up tests for the OP_TRUE case here:
> https://github.com/instagibbs/bitcoin/tree/ephemeral-anchors-true

Thanks.

Looking through that, I think a lot of those test cases don't actually need to
be changed to OP_2, as they aren't trying to test anything related to
standardness.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230204/f63c63cb/attachment.sig>

From pete at petertodd.org  Sat Feb  4 16:27:47 2023
From: pete at petertodd.org (Peter Todd)
Date: Sat, 4 Feb 2023 11:27:47 -0500
Subject: [bitcoin-dev] A proposal for Full RBF to not exclude Zero Conf
 use case
In-Reply-To: <CACkWPs_Nqm1663c1q8xHX=A0Gpa7m1kV_QX6t0s8uPOEh3WQLA@mail.gmail.com>
References: <CAAQdECAspoRJRz7j1ubAe=Cen==AVF5bm-Q2=0TiKc7NtbU65A@mail.gmail.com>
 <CACkWPs_4pjTo50=S86KPEznBs0PU7rd30rBGHq2Q5=6n6hYMgQ@mail.gmail.com>
 <CAHTn92wH17Z+p5cFOLpzsVUuTf4-nZc7tOjQr+_xjSU5groa0Q@mail.gmail.com>
 <CACkWPs9VawCYt7maiNqzafkFnHTiGJQkXMT4VXQQcG-rE2TTNw@mail.gmail.com>
 <Y5jxmItJIpIUVY+x@petertodd.org>
 <CACkWPs_jSLDg3seON0uu=ri6iR9cytXo2MEPJ5PVeap+iDreeQ@mail.gmail.com>
 <Y5zfuVGpRGaknwaU@petertodd.org>
 <CACkWPs_6z7UyXzejTqjy=i+SkSz-76VdzZ20K1DzcVJxan_HZg@mail.gmail.com>
 <Y8HvCbBd5+pm8Uj2@petertodd.org>
 <CACkWPs_Nqm1663c1q8xHX=A0Gpa7m1kV_QX6t0s8uPOEh3WQLA@mail.gmail.com>
Message-ID: <Y96HgwjLkF6Bd2DV@petertodd.org>

On Sat, Jan 14, 2023 at 10:15:30PM +0200, Daniel Lipshitz wrote:
> We have standard commercial information about the payment processors, non
> custodial liquidity providers and merchants which become our clients - we
> do not have any kyc/aml information or telephone number on who is sending
> our clients the bitcoin for deposit.  For us these are just bitcoin Trx
> which our clients choose to benefit from 0-conf deposit recognition. Our
> service is provided via API with the only information our clients share
> with us, regarding a specific bitcoin transaction, being public bitcoin
> information like trx hash and output address.

You know who your clients are, and thus every request for information on a
transaction is reasonably likely to be a deposit associated with the client who
requested it. Learning what addresses are associated with what entity is a
significant benefit to Chainalysis operations, and there's every reason to
expect that the data you learn will either be sold or leaked to Chainalysis
companies.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230204/cbbcc901/attachment-0001.sig>

From aymeric at peersm.com  Sat Feb  4 17:01:20 2023
From: aymeric at peersm.com (Aymeric Vitte)
Date: Sat, 4 Feb 2023 18:01:20 +0100
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <CABE6yHtM2Dqc63_eURSr7dMirJti5sYnqvHj7vQ_Ab9FC_d04g@mail.gmail.com>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>
 <57f780b1-f262-9394-036c-70084320e9cf@peersm.com>
 <CACrqygCNf3Gv8+VjhyqS4GTb3Epo8qXEKGtQB6sqyR6ib44-fA@mail.gmail.com>
 <CABE6yHtM2Dqc63_eURSr7dMirJti5sYnqvHj7vQ_Ab9FC_d04g@mail.gmail.com>
Message-ID: <3d00aacb-585d-f875-784d-34352860d725@peersm.com>

I don't get very well where all the current (other threats) discussions
are going, storing on-chain is absurd

It's absurd also to flood bitcoin with several useless transactions to
store in witness or others, looks like ethereum messy stuff

What is not absurd is to store the proofs that can be checked using a
notorious third party/sidechain but you need more than 80B

What is the official bitcoin channel to request the OP_RETURN size
change? (press often mentions that ethereum is good to manage changes
and bitcoin a complete zero)

As a very bad solution, I think I would be willing to store data in
addresses, with one single transaction, as people did in the past, then
burning bitcoins but still not expensive, or less than several txs,
because schemes involving several transactions do not work very well

In any case, we see the problem, then people will invent something and
most likely it will not comply at all with bitcoin good practices


Le 04/02/2023 ? 15:11, Kostas Karasavvas via bitcoin-dev a ?crit :
>
>
> On Fri, Feb 3, 2023 at 10:17 PM Christopher Allen via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org
> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>
>     On Fri, Feb 3, 2023 at 3:52 AM Aymeric Vitte via bitcoin-dev
>     <bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>
>         I think the right way so people don't invent deviant things is to
>         increase the size of OP_RETURN, I don't get this number of
>         80B, you can
>         hardly store a signature (of what?) in there and not the
>         "what" if the
>         "what" is a hash for example
>
>
>     Updating the size of OP_RETURN to support a hash (or two), a
>     signature, and maybe a few more bytes for metadata, would be very
>     helpful in a number of scenarios. It is still a limit but a
>     reasonable one. Otherwise, I think we'll have a lot more
>     inscription-style scenarios.
>
>
> I wouldn't be against an increase in OP_RETURN but I don't think it
> will make any difference in how often inscription-style use cases will
> be used. They will be used primarily for much larger datasets than,
> say 120 bytes, and they also have the segwit discount.
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Sophia-Antipolis, France
CV: https://www.peersm.com/CVAV.pdf
LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26
GitHub : https://www.github.com/Ayms
A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7
A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com
Peersm : http://www.peersm.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230204/5dfda935/attachment.html>

From ChristopherA at lifewithalacrity.com  Sat Feb  4 18:54:41 2023
From: ChristopherA at lifewithalacrity.com (Christopher Allen)
Date: Sat, 4 Feb 2023 10:54:41 -0800
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <3d00aacb-585d-f875-784d-34352860d725@peersm.com>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>
 <57f780b1-f262-9394-036c-70084320e9cf@peersm.com>
 <CACrqygCNf3Gv8+VjhyqS4GTb3Epo8qXEKGtQB6sqyR6ib44-fA@mail.gmail.com>
 <CABE6yHtM2Dqc63_eURSr7dMirJti5sYnqvHj7vQ_Ab9FC_d04g@mail.gmail.com>
 <3d00aacb-585d-f875-784d-34352860d725@peersm.com>
Message-ID: <CACrqygB_FbsRGWYPSUEFTnP15y94Hmo4JtAuv6bH1D3YtbAw9Q@mail.gmail.com>

On Sat, Feb 4, 2023 at 9:01 AM Aymeric Vitte <aymeric at peersm.com> wrote:

> What is the official bitcoin channel to request the OP_RETURN size change?
> (press often mentions that ethereum is good to manage changes and bitcoin a
> complete zero.
>
Here is the simplified version:

Most of these changes start with discussions like these, but then are moved
concretely to a PR to bitcoin-core with the code changes (in this case
there is no fork so pretty easy) and an introductory comment pointing to
discussions elsewhere.

The conversation will also move to the PR itself. Part of the challenge now
is getting review of your PRs - you?ll need to evangelize some and/or have
social capital in the bitcoin community to get sufficient ACKs to your PR
(and some NACKs which you will calmly addres), and someone will likely
point something out you missed, so you revise the PR.

At some point hopefully there looks like all reasonable objections have
been addressed.

If there is enough interest and few objections there will be discussions by
the community & maintainers to merge it. It is this last part that isn?t
very transparent, especially for even a good proposal. The maintainers,
based on their sense of the community?s interest and consensus, must choose
when to say it is ready, and then decide when and to which release they
wish to merge it.

They often start by requesting you to revise your changes to be off by
default, and be turned on as an option for a specific release. Often PR
contributors know this is coming and include it.

Even once it is released, this type of change can only happen after
sufficient miners and nodes update to the release and turn it on. If
sufficient do, then the maintainers evaluate when to have the feature on by
default.

These articles offers more perspective:

   -

   https://unchained.com/blog/contributing-bitcoin-core-patience/
   -


   https://jonatack.github.io/articles/how-to-contribute-pull-requests-to-bitcoin-core
   -

   https://medium.com/@amitiu/onboarding-to-bitcoin-core-7c1a83b20365

? Christopher Allen

>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230204/55d4fec8/attachment.html>

From aymeric at peersm.com  Sat Feb  4 20:55:47 2023
From: aymeric at peersm.com (Aymeric Vitte)
Date: Sat, 4 Feb 2023 21:55:47 +0100
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <CACrqygB_FbsRGWYPSUEFTnP15y94Hmo4JtAuv6bH1D3YtbAw9Q@mail.gmail.com>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>
 <57f780b1-f262-9394-036c-70084320e9cf@peersm.com>
 <CACrqygCNf3Gv8+VjhyqS4GTb3Epo8qXEKGtQB6sqyR6ib44-fA@mail.gmail.com>
 <CABE6yHtM2Dqc63_eURSr7dMirJti5sYnqvHj7vQ_Ab9FC_d04g@mail.gmail.com>
 <3d00aacb-585d-f875-784d-34352860d725@peersm.com>
 <CACrqygB_FbsRGWYPSUEFTnP15y94Hmo4JtAuv6bH1D3YtbAw9Q@mail.gmail.com>
Message-ID: <b292d887-cbd5-165c-de01-793df2b5e8f3@peersm.com>

Thanks Christopher, then I understand the process:

- I must issue a PR where I switch 80 to another number, even if I am
not a C/C++ expert it looks easy

- I  must stay calm and answer all outstanding concerns about this
trivial change

- Since I am not as clever as the bitcoin devs I must be ready to revise
my PR at any time

- This could lead for the change to be from 80B to 82.xB where x comes
from a non understandable crypto formula

- I must evangelize the change worldwide

- Once accepted, I must collude (pay) with the nodes/miners so they
update at a subtile block height decided by the community

And then I must pray that the PR does not survive myself

Looks like a pretty straight forward process

I am on this list since quite some time, so, seriously, this change is
needed, or, as I said before, deviant behaviours will happen, because
the "witness trick" or others do not work at all, and are clearly
similar to ethereum messy stuff


Le 04/02/2023 ? 19:54, Christopher Allen a ?crit :
> On Sat, Feb 4, 2023 at 9:01 AM Aymeric Vitte <aymeric at peersm.com
> <mailto:aymeric at peersm.com>> wrote:
>
>     What is the official bitcoin channel to request the OP_RETURN size
>     change? (press often mentions that ethereum is good to manage
>     changes and bitcoin a complete zero.
>
> Here is the simplified version:
>
> Most of these changes start with discussions like these, but then are
> moved concretely to a PR to bitcoin-core with the code changes (in
> this case there is no fork so pretty easy) and an introductory comment
> pointing to discussions elsewhere. 
>
> The conversation will also move to the PR itself. Part of the
> challenge now is getting review of your PRs - you?ll need to
> evangelize some and/or have social capital in the bitcoin community to
> get sufficient ACKs to your PR (and some NACKs which you will calmly
> addres), and someone will likely point something out you missed, so
> you revise the PR. 
>
> At some point hopefully there looks like all reasonable objections
> have been addressed.
>
> If there is enough interest and few objections there will be
> discussions by the community & maintainers to merge it. It is this
> last part that isn?t very transparent, especially for even a good
> proposal. The maintainers, based on their sense of the community?s
> interest and consensus, must choose when to say it is ready, and then
> decide when and to which release they wish to merge it.
>
> They often start by requesting you to revise your changes to be off by
> default, and be turned on as an option for a specific release. Often
> PR contributors know this is coming and include it.
>
> Even once it is released, this type of change can only happen after
> sufficient miners and nodes update to the release and turn it on. If
> sufficient do, then the maintainers evaluate when to have the feature
> on by default.
>
> These articles offers more perspective: 
>
>  *
>
>     https://unchained.com/blog/contributing-bitcoin-core-patience/
>
>  *
>
>     https://jonatack.github.io/articles/how-to-contribute-pull-requests-to-bitcoin-core
>
>  *
>
>     https://medium.com/@amitiu/onboarding-to-bitcoin-core-7c1a83b20365
>
> ? Christopher Allen 
>
>

-- 
Sophia-Antipolis, France
CV: https://www.peersm.com/CVAV.pdf
LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26
GitHub : https://www.github.com/Ayms
A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7
A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com
Peersm : http://www.peersm.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230204/889a52b1/attachment-0001.html>

From ChristopherA at lifewithalacrity.com  Sat Feb  4 22:18:06 2023
From: ChristopherA at lifewithalacrity.com (Christopher Allen)
Date: Sat, 4 Feb 2023 14:18:06 -0800
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <b292d887-cbd5-165c-de01-793df2b5e8f3@peersm.com>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>
 <57f780b1-f262-9394-036c-70084320e9cf@peersm.com>
 <CACrqygCNf3Gv8+VjhyqS4GTb3Epo8qXEKGtQB6sqyR6ib44-fA@mail.gmail.com>
 <CABE6yHtM2Dqc63_eURSr7dMirJti5sYnqvHj7vQ_Ab9FC_d04g@mail.gmail.com>
 <3d00aacb-585d-f875-784d-34352860d725@peersm.com>
 <CACrqygB_FbsRGWYPSUEFTnP15y94Hmo4JtAuv6bH1D3YtbAw9Q@mail.gmail.com>
 <b292d887-cbd5-165c-de01-793df2b5e8f3@peersm.com>
Message-ID: <CACrqygAv842ucN7PLYMENXFiSwAZJy2Y+FziJXrWjyCcOXmL3g@mail.gmail.com>

On Sat, Feb 4, 2023 at 12:55 PM Aymeric Vitte <aymeric at peersm.com> wrote:

> Thanks Christopher, then I understand the process:
>
> - I must issue a PR where I switch 80 to another number, even if I am not
> a C/C++ expert it looks easy
>
Yes, this would be an easy PR, at least to start. I suspect that
longer-term, you'd need to draft some assistance to make it turn on/off
from when the bitcoin daemon is initialized. But that could wait until the
conversation has progressed some.

The harder part will be writing the initial comment, where you should
carefully explain the rationale, link to some existing conversations, try
to point out in advance the obvious objections and rationale despite them,
and explain your particular choice of number ? 520 because that is a
similar limit in taproot? Some multiple of hash+signature+metadata to
satisfy others (that still might not be satisfied by any choice).

> - I  must stay calm and answer all outstanding concerns about this trivial
> change
>
> - Since I am not as clever as the bitcoin devs I must be ready to revise
> my PR at any time
>
> - This could lead for the change to be from 80B to 82.xB where x comes
> from a non understandable crypto formula
>
> - I must evangelize the change worldwide
>
> - Once accepted, I must collude (pay) with the nodes/miners so they update
> at a subtile block height decided by the community
>
That is true for forks, but I don't think this is a fork. It might require
resolving some mempool issues (for instance for mining pools). But for it
to become non-optional, you'll need to demonstrate that miners and full
nodes have turned it on. Thus that is more a conversation than "collusion
(pay)".

> And then I must pray that the PR does not survive myself
>
> Looks like a pretty straight forward process.
>
I've seen worse. I co-authored TLS 1.0 (6 years) and DID 1.0 (5 years).

> I am on this list since quite some time, so, seriously, this change is
> needed, or, as I said before, deviant behaviours will happen, because the
> "witness trick" or others do not work at all, and are clearly similar to
> ethereum messy stuff
>
You have at least Concept ACK from me! ;-)

-- Christopher Allen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230204/00878238/attachment.html>

From aymeric at peersm.com  Sat Feb  4 23:09:02 2023
From: aymeric at peersm.com (Aymeric Vitte)
Date: Sun, 5 Feb 2023 00:09:02 +0100
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <CACrqygAv842ucN7PLYMENXFiSwAZJy2Y+FziJXrWjyCcOXmL3g@mail.gmail.com>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>
 <57f780b1-f262-9394-036c-70084320e9cf@peersm.com>
 <CACrqygCNf3Gv8+VjhyqS4GTb3Epo8qXEKGtQB6sqyR6ib44-fA@mail.gmail.com>
 <CABE6yHtM2Dqc63_eURSr7dMirJti5sYnqvHj7vQ_Ab9FC_d04g@mail.gmail.com>
 <3d00aacb-585d-f875-784d-34352860d725@peersm.com>
 <CACrqygB_FbsRGWYPSUEFTnP15y94Hmo4JtAuv6bH1D3YtbAw9Q@mail.gmail.com>
 <b292d887-cbd5-165c-de01-793df2b5e8f3@peersm.com>
 <CACrqygAv842ucN7PLYMENXFiSwAZJy2Y+FziJXrWjyCcOXmL3g@mail.gmail.com>
Message-ID: <230265ee-c3f8-dff3-9192-f0c8dc4d913c@peersm.com>

I don't know, what number would you advise? When I made the
bitcoin-transactions nodejs module some years ago the limit (from the
specs) was 512B

It's not a fork, super easy to do

And necessary because bitcoin on ground of I don't know what rule
allowing the IF/ENDIF "unlimited" storage just mimics ethereum for the
worse, and is again quite dubious to use


Le 04/02/2023 ? 23:18, Christopher Allen a ?crit :
> 520 because that is a similar limit in taproot? Some multiple of
> hash+signature+metadata to satisfy others (that still might not be
> satisfied by any choice).



From roconnor at blockstream.com  Sun Feb  5 00:11:35 2023
From: roconnor at blockstream.com (Russell O'Connor)
Date: Sat, 4 Feb 2023 19:11:35 -0500
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <230265ee-c3f8-dff3-9192-f0c8dc4d913c@peersm.com>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>
 <57f780b1-f262-9394-036c-70084320e9cf@peersm.com>
 <CACrqygCNf3Gv8+VjhyqS4GTb3Epo8qXEKGtQB6sqyR6ib44-fA@mail.gmail.com>
 <CABE6yHtM2Dqc63_eURSr7dMirJti5sYnqvHj7vQ_Ab9FC_d04g@mail.gmail.com>
 <3d00aacb-585d-f875-784d-34352860d725@peersm.com>
 <CACrqygB_FbsRGWYPSUEFTnP15y94Hmo4JtAuv6bH1D3YtbAw9Q@mail.gmail.com>
 <b292d887-cbd5-165c-de01-793df2b5e8f3@peersm.com>
 <CACrqygAv842ucN7PLYMENXFiSwAZJy2Y+FziJXrWjyCcOXmL3g@mail.gmail.com>
 <230265ee-c3f8-dff3-9192-f0c8dc4d913c@peersm.com>
Message-ID: <CAMZUoKkAdQ9TSMm4vPJOrThu_h6VbqwPhOQQR7-Yr+WZ0DMBYw@mail.gmail.com>

Since bytes in the witness are cheaper than bytes in the script pubkey,
there is a crossover point in data size where it will simply be cheaper to
use witness data.  Where that crossover point is depends on the finer
details of the overhead of the two methods, but you could make some
reasonable assumptions.  Such a calculation could form the basis of a
reasonable OP_RETURN proposal.  I don't know if it would be persuasive, but
it would at least be coherent.

On Sat., Feb. 4, 2023, 18:17 Aymeric Vitte via bitcoin-dev, <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I don't know, what number would you advise? When I made the
> bitcoin-transactions nodejs module some years ago the limit (from the
> specs) was 512B
>
> It's not a fork, super easy to do
>
> And necessary because bitcoin on ground of I don't know what rule
> allowing the IF/ENDIF "unlimited" storage just mimics ethereum for the
> worse, and is again quite dubious to use
>
>
> Le 04/02/2023 ? 23:18, Christopher Allen a ?crit :
> > 520 because that is a similar limit in taproot? Some multiple of
> > hash+signature+metadata to satisfy others (that still might not be
> > satisfied by any choice).
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230204/248ec360/attachment.html>

From pete at petertodd.org  Sun Feb  5 00:04:04 2023
From: pete at petertodd.org (Peter Todd)
Date: Sun, 05 Feb 2023 01:04:04 +0100
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
	OP_IF OP_PUSH
In-Reply-To: <230265ee-c3f8-dff3-9192-f0c8dc4d913c@peersm.com>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>
 <57f780b1-f262-9394-036c-70084320e9cf@peersm.com>
 <CACrqygCNf3Gv8+VjhyqS4GTb3Epo8qXEKGtQB6sqyR6ib44-fA@mail.gmail.com>
 <CABE6yHtM2Dqc63_eURSr7dMirJti5sYnqvHj7vQ_Ab9FC_d04g@mail.gmail.com>
 <3d00aacb-585d-f875-784d-34352860d725@peersm.com>
 <CACrqygB_FbsRGWYPSUEFTnP15y94Hmo4JtAuv6bH1D3YtbAw9Q@mail.gmail.com>
 <b292d887-cbd5-165c-de01-793df2b5e8f3@peersm.com>
 <CACrqygAv842ucN7PLYMENXFiSwAZJy2Y+FziJXrWjyCcOXmL3g@mail.gmail.com>
 <230265ee-c3f8-dff3-9192-f0c8dc4d913c@peersm.com>
Message-ID: <28C74556-8AB4-4E16-AC7D-7F3FAA0A29AC@petertodd.org>



On February 5, 2023 12:09:02 AM GMT+01:00, Aymeric Vitte via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>I don't know, what number would you advise? When I made the
>bitcoin-transactions nodejs module some years ago the limit (from the
>specs) was 512B

1) Allowing only one OpReturn output causes problems trying to compose different uses of OpReturn. We should allow any number of OpReturn outputs.

2) There's no reason to put a size limit given all the other ways people can publish data, including with a 75% discount. Let the fee market deal with it.

From pete at petertodd.org  Sun Feb  5 02:01:08 2023
From: pete at petertodd.org (Peter Todd)
Date: Sun, 05 Feb 2023 03:01:08 +0100
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
	OP_IF OP_PUSH
In-Reply-To: <CAMZUoKkAdQ9TSMm4vPJOrThu_h6VbqwPhOQQR7-Yr+WZ0DMBYw@mail.gmail.com>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>
 <57f780b1-f262-9394-036c-70084320e9cf@peersm.com>
 <CACrqygCNf3Gv8+VjhyqS4GTb3Epo8qXEKGtQB6sqyR6ib44-fA@mail.gmail.com>
 <CABE6yHtM2Dqc63_eURSr7dMirJti5sYnqvHj7vQ_Ab9FC_d04g@mail.gmail.com>
 <3d00aacb-585d-f875-784d-34352860d725@peersm.com>
 <CACrqygB_FbsRGWYPSUEFTnP15y94Hmo4JtAuv6bH1D3YtbAw9Q@mail.gmail.com>
 <b292d887-cbd5-165c-de01-793df2b5e8f3@peersm.com>
 <CACrqygAv842ucN7PLYMENXFiSwAZJy2Y+FziJXrWjyCcOXmL3g@mail.gmail.com>
 <230265ee-c3f8-dff3-9192-f0c8dc4d913c@peersm.com>
 <CAMZUoKkAdQ9TSMm4vPJOrThu_h6VbqwPhOQQR7-Yr+WZ0DMBYw@mail.gmail.com>
Message-ID: <76718304-A8E3-46E6-B2F7-DE86831F15DF@petertodd.org>



On February 5, 2023 1:11:35 AM GMT+01:00, Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>Since bytes in the witness are cheaper than bytes in the script pubkey,
>there is a crossover point in data size where it will simply be cheaper to
>use witness data.  Where that crossover point is depends on the finer
>details of the overhead of the two methods, but you could make some
>reasonable assumptions.  Such a calculation could form the basis of a
>reasonable OP_RETURN proposal.  I don't know if it would be persuasive, but
>it would at least be coherent.

I don't think it's worth the technical complexity trying to carefully argue a specific limit. Let users decide for themselves how they want to use OpReturn.

From pete at petertodd.org  Sun Feb  5 12:06:33 2023
From: pete at petertodd.org (Peter Todd)
Date: Sun, 05 Feb 2023 13:06:33 +0100
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
	OP_IF OP_PUSH
In-Reply-To: <0267d5bb-a54b-894b-3d45-e6cb89eb86a5@peersm.com>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>
 <57f780b1-f262-9394-036c-70084320e9cf@peersm.com>
 <CACrqygCNf3Gv8+VjhyqS4GTb3Epo8qXEKGtQB6sqyR6ib44-fA@mail.gmail.com>
 <CABE6yHtM2Dqc63_eURSr7dMirJti5sYnqvHj7vQ_Ab9FC_d04g@mail.gmail.com>
 <3d00aacb-585d-f875-784d-34352860d725@peersm.com>
 <CACrqygB_FbsRGWYPSUEFTnP15y94Hmo4JtAuv6bH1D3YtbAw9Q@mail.gmail.com>
 <b292d887-cbd5-165c-de01-793df2b5e8f3@peersm.com>
 <CACrqygAv842ucN7PLYMENXFiSwAZJy2Y+FziJXrWjyCcOXmL3g@mail.gmail.com>
 <230265ee-c3f8-dff3-9192-f0c8dc4d913c@peersm.com>
 <28C74556-8AB4-4E16-AC7D-7F3FAA0A29AC@petertodd.org>
 <0267d5bb-a54b-894b-3d45-e6cb89eb86a5@peersm.com>
Message-ID: <B7A37621-AC21-43FE-A60D-7516FFD69FCF@petertodd.org>



On February 5, 2023 12:40:38 PM GMT+01:00, Aymeric Vitte <aymeric at peersm.com> wrote:
>I think logically:
>
>- if you want to store something big and can afford several txs in your
>design, then you use something like witness
>
>- if you want to store small things like signatures, addresses hashes
>and some metadata and your design does not make several txs easy, then
>you use OP_RETURN
>
>Then how can we move forward with several OP_RETURN and no size limit?

Because what matters is the impact on other users. OpReturn isn't in UTXO space and doesn't even take advantage of the witness discount, so it clearly has minimal impact.

Since it has minimal impact, there's no reason to micromanage exactly how people use it. Let them decide for themselves with the fee market. This is exactly the same as how we didn't put artificial limits on Taproot.

From aymeric at peersm.com  Sun Feb  5 11:40:38 2023
From: aymeric at peersm.com (Aymeric Vitte)
Date: Sun, 5 Feb 2023 12:40:38 +0100
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <28C74556-8AB4-4E16-AC7D-7F3FAA0A29AC@petertodd.org>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>
 <57f780b1-f262-9394-036c-70084320e9cf@peersm.com>
 <CACrqygCNf3Gv8+VjhyqS4GTb3Epo8qXEKGtQB6sqyR6ib44-fA@mail.gmail.com>
 <CABE6yHtM2Dqc63_eURSr7dMirJti5sYnqvHj7vQ_Ab9FC_d04g@mail.gmail.com>
 <3d00aacb-585d-f875-784d-34352860d725@peersm.com>
 <CACrqygB_FbsRGWYPSUEFTnP15y94Hmo4JtAuv6bH1D3YtbAw9Q@mail.gmail.com>
 <b292d887-cbd5-165c-de01-793df2b5e8f3@peersm.com>
 <CACrqygAv842ucN7PLYMENXFiSwAZJy2Y+FziJXrWjyCcOXmL3g@mail.gmail.com>
 <230265ee-c3f8-dff3-9192-f0c8dc4d913c@peersm.com>
 <28C74556-8AB4-4E16-AC7D-7F3FAA0A29AC@petertodd.org>
Message-ID: <0267d5bb-a54b-894b-3d45-e6cb89eb86a5@peersm.com>

I think logically:

- if you want to store something big and can afford several txs in your
design, then you use something like witness

- if you want to store small things like signatures, addresses hashes
and some metadata and your design does not make several txs easy, then
you use OP_RETURN

Then how can we move forward with several OP_RETURN and no size limit?

I can start posting a bug/enhancement proposal in bitcoin repo but can't
write the PR


Le 05/02/2023 ? 01:04, Peter Todd a ?crit :
>
> On February 5, 2023 12:09:02 AM GMT+01:00, Aymeric Vitte via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> I don't know, what number would you advise? When I made the
>> bitcoin-transactions nodejs module some years ago the limit (from the
>> specs) was 512B
> 1) Allowing only one OpReturn output causes problems trying to compose different uses of OpReturn. We should allow any number of OpReturn outputs.
>
> 2) There's no reason to put a size limit given all the other ways people can publish data, including with a 75% discount. Let the fee market deal with it.

-- 
Sophia-Antipolis, France
CV: https://www.peersm.com/CVAV.pdf
LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26
GitHub : https://www.github.com/Ayms
A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7
A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com
Peersm : http://www.peersm.com



From aymeric at peersm.com  Sun Feb  5 12:47:38 2023
From: aymeric at peersm.com (Aymeric Vitte)
Date: Sun, 5 Feb 2023 13:47:38 +0100
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <B7A37621-AC21-43FE-A60D-7516FFD69FCF@petertodd.org>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>
 <57f780b1-f262-9394-036c-70084320e9cf@peersm.com>
 <CACrqygCNf3Gv8+VjhyqS4GTb3Epo8qXEKGtQB6sqyR6ib44-fA@mail.gmail.com>
 <CABE6yHtM2Dqc63_eURSr7dMirJti5sYnqvHj7vQ_Ab9FC_d04g@mail.gmail.com>
 <3d00aacb-585d-f875-784d-34352860d725@peersm.com>
 <CACrqygB_FbsRGWYPSUEFTnP15y94Hmo4JtAuv6bH1D3YtbAw9Q@mail.gmail.com>
 <b292d887-cbd5-165c-de01-793df2b5e8f3@peersm.com>
 <CACrqygAv842ucN7PLYMENXFiSwAZJy2Y+FziJXrWjyCcOXmL3g@mail.gmail.com>
 <230265ee-c3f8-dff3-9192-f0c8dc4d913c@peersm.com>
 <28C74556-8AB4-4E16-AC7D-7F3FAA0A29AC@petertodd.org>
 <0267d5bb-a54b-894b-3d45-e6cb89eb86a5@peersm.com>
 <B7A37621-AC21-43FE-A60D-7516FFD69FCF@petertodd.org>
Message-ID: <92f7a26f-293c-b1e6-d9b2-8de44af5e31c@peersm.com>

Yes I agree, let people decide and since taproot has no limits then it
sould be the same for OP_RETURN

I posted https://github.com/bitcoin/bitcoin/issues/27043


Le 05/02/2023 ? 13:06, Peter Todd a ?crit :
>
> On February 5, 2023 12:40:38 PM GMT+01:00, Aymeric Vitte <aymeric at peersm.com> wrote:
>> I think logically:
>>
>> - if you want to store something big and can afford several txs in your
>> design, then you use something like witness
>>
>> - if you want to store small things like signatures, addresses hashes
>> and some metadata and your design does not make several txs easy, then
>> you use OP_RETURN
>>
>> Then how can we move forward with several OP_RETURN and no size limit?
> Because what matters is the impact on other users. OpReturn isn't in UTXO space and doesn't even take advantage of the witness discount, so it clearly has minimal impact.
>
> Since it has minimal impact, there's no reason to micromanage exactly how people use it. Let them decide for themselves with the fee market. This is exactly the same as how we didn't put artificial limits on Taproot.

-- 
Sophia-Antipolis, France
CV: https://www.peersm.com/CVAV.pdf
LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26
GitHub : https://www.github.com/Ayms
A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7
A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com
Peersm : http://www.peersm.com


From apoelstra at wpsoftware.net  Sun Feb  5 18:06:18 2023
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Sun, 5 Feb 2023 18:06:18 +0000
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <CAMZUoKkAdQ9TSMm4vPJOrThu_h6VbqwPhOQQR7-Yr+WZ0DMBYw@mail.gmail.com>
References: <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>
 <57f780b1-f262-9394-036c-70084320e9cf@peersm.com>
 <CACrqygCNf3Gv8+VjhyqS4GTb3Epo8qXEKGtQB6sqyR6ib44-fA@mail.gmail.com>
 <CABE6yHtM2Dqc63_eURSr7dMirJti5sYnqvHj7vQ_Ab9FC_d04g@mail.gmail.com>
 <3d00aacb-585d-f875-784d-34352860d725@peersm.com>
 <CACrqygB_FbsRGWYPSUEFTnP15y94Hmo4JtAuv6bH1D3YtbAw9Q@mail.gmail.com>
 <b292d887-cbd5-165c-de01-793df2b5e8f3@peersm.com>
 <CACrqygAv842ucN7PLYMENXFiSwAZJy2Y+FziJXrWjyCcOXmL3g@mail.gmail.com>
 <230265ee-c3f8-dff3-9192-f0c8dc4d913c@peersm.com>
 <CAMZUoKkAdQ9TSMm4vPJOrThu_h6VbqwPhOQQR7-Yr+WZ0DMBYw@mail.gmail.com>
Message-ID: <Y9/wGqljA/R8a+fU@camus>

On Sat, Feb 04, 2023 at 07:11:35PM -0500, Russell O'Connor via bitcoin-dev wrote:
> Since bytes in the witness are cheaper than bytes in the script pubkey,
> there is a crossover point in data size where it will simply be cheaper to
> use witness data.  Where that crossover point is depends on the finer
> details of the overhead of the two methods, but you could make some
> reasonable assumptions.  Such a calculation could form the basis of a
> reasonable OP_RETURN proposal.  I don't know if it would be persuasive, but
> it would at least be coherent.
>

I agree with Peter that, given that users have found ways to store arbitrary
amounts of data on-chain if they really want, we might as well just make
OP_RETURN a free-for-all.

-- 
Andrew Poelstra
Director of Research, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

The sun is always shining in space
    -Justin Lewis-Webster

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230205/210aac82/attachment.sig>

From roconnor at blockstream.com  Sun Feb  5 18:12:52 2023
From: roconnor at blockstream.com (Russell O'Connor)
Date: Sun, 5 Feb 2023 13:12:52 -0500
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <76718304-A8E3-46E6-B2F7-DE86831F15DF@petertodd.org>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>
 <57f780b1-f262-9394-036c-70084320e9cf@peersm.com>
 <CACrqygCNf3Gv8+VjhyqS4GTb3Epo8qXEKGtQB6sqyR6ib44-fA@mail.gmail.com>
 <CABE6yHtM2Dqc63_eURSr7dMirJti5sYnqvHj7vQ_Ab9FC_d04g@mail.gmail.com>
 <3d00aacb-585d-f875-784d-34352860d725@peersm.com>
 <CACrqygB_FbsRGWYPSUEFTnP15y94Hmo4JtAuv6bH1D3YtbAw9Q@mail.gmail.com>
 <b292d887-cbd5-165c-de01-793df2b5e8f3@peersm.com>
 <CACrqygAv842ucN7PLYMENXFiSwAZJy2Y+FziJXrWjyCcOXmL3g@mail.gmail.com>
 <230265ee-c3f8-dff3-9192-f0c8dc4d913c@peersm.com>
 <CAMZUoKkAdQ9TSMm4vPJOrThu_h6VbqwPhOQQR7-Yr+WZ0DMBYw@mail.gmail.com>
 <76718304-A8E3-46E6-B2F7-DE86831F15DF@petertodd.org>
Message-ID: <CAMZUoKnrs-uxnTqpa96B4H86=gAtafowDi0D5HdnExvBWqTqPQ@mail.gmail.com>

On Sat., Feb. 4, 2023, 21:01 Peter Todd, <pete at petertodd.org> wrote:

>
>
> On February 5, 2023 1:11:35 AM GMT+01:00, Russell O'Connor via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >Since bytes in the witness are cheaper than bytes in the script pubkey,
> >there is a crossover point in data size where it will simply be cheaper to
> >use witness data.  Where that crossover point is depends on the finer
> >details of the overhead of the two methods, but you could make some
> >reasonable assumptions.  Such a calculation could form the basis of a
> >reasonable OP_RETURN proposal.  I don't know if it would be persuasive,
> but
> >it would at least be coherent.
>
> I don't think it's worth the technical complexity trying to carefully
> argue a specific limit. Let users decide for themselves how they want to
> use OpReturn.
>

Even better.

>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230205/bfa453c8/attachment-0001.html>

From daniel at gap600.com  Mon Feb  6 12:08:40 2023
From: daniel at gap600.com (Daniel Lipshitz)
Date: Mon, 6 Feb 2023 14:08:40 +0200
Subject: [bitcoin-dev] A proposal for Full RBF to not exclude Zero Conf
 use case
In-Reply-To: <Y96HgwjLkF6Bd2DV@petertodd.org>
References: <CAAQdECAspoRJRz7j1ubAe=Cen==AVF5bm-Q2=0TiKc7NtbU65A@mail.gmail.com>
 <CACkWPs_4pjTo50=S86KPEznBs0PU7rd30rBGHq2Q5=6n6hYMgQ@mail.gmail.com>
 <CAHTn92wH17Z+p5cFOLpzsVUuTf4-nZc7tOjQr+_xjSU5groa0Q@mail.gmail.com>
 <CACkWPs9VawCYt7maiNqzafkFnHTiGJQkXMT4VXQQcG-rE2TTNw@mail.gmail.com>
 <Y5jxmItJIpIUVY+x@petertodd.org>
 <CACkWPs_jSLDg3seON0uu=ri6iR9cytXo2MEPJ5PVeap+iDreeQ@mail.gmail.com>
 <Y5zfuVGpRGaknwaU@petertodd.org>
 <CACkWPs_6z7UyXzejTqjy=i+SkSz-76VdzZ20K1DzcVJxan_HZg@mail.gmail.com>
 <Y8HvCbBd5+pm8Uj2@petertodd.org>
 <CACkWPs_Nqm1663c1q8xHX=A0Gpa7m1kV_QX6t0s8uPOEh3WQLA@mail.gmail.com>
 <Y96HgwjLkF6Bd2DV@petertodd.org>
Message-ID: <CACkWPs-78Ytv3dVRD_VsXUFpuqWgwapYuDP8Vy5sR4F12e9fdw@mail.gmail.com>

On Sat, Feb 4, 2023 at 6:28 PM Peter Todd <pete at petertodd.org> wrote:

> On Sat, Jan 14, 2023 at 10:15:30PM +0200, Daniel Lipshitz wrote:
> > We have standard commercial information about the payment processors, non
> > custodial liquidity providers and merchants which become our clients - we
> > do not have any kyc/aml information or telephone number on who is sending
> > our clients the bitcoin for deposit.  For us these are just bitcoin Trx
> > which our clients choose to benefit from 0-conf deposit recognition. Our
> > service is provided via API with the only information our clients share
> > with us, regarding a specific bitcoin transaction, being public bitcoin
> > information like trx hash and output address.
>
> You know who your clients are, and thus every request for information on a
> transaction is reasonably likely to be a deposit associated with the
> client who
> requested it. Learning what addresses are associated with what entity is a
> significant benefit to Chainalysis operations, and there's every reason to
> expect that the data you learn will either be sold or leaked to Chainalysis
> companies.
>

I would estimate based on general discussions with clients and open
research more than 90% of our clients use different AML trx analysis
service providers for trx deposited on their platforms -
completely irrelevant to us or 0-conf. So if these clients were to stop
recognising 0-conf this would have no impact on these AML service providers
access to the data. We service payment processors and liquidity providers
and have little or no insight into which wallets or merchants our clients
service.

 Further to this many of the cluster addresses of our clients and just like
other service providers in the bitcoin space are publicly known - just as
Max had no issue sharing the cluster of his deposit address in his email
which I posted to the list.

>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230206/ad228af5/attachment.html>

From erik at q32.com  Mon Feb  6 16:39:14 2023
From: erik at q32.com (Erik Aronesty)
Date: Mon, 6 Feb 2023 11:39:14 -0500
Subject: [bitcoin-dev] Ordinal Inscription Size Limits
In-Reply-To: <CABE6yHvRihAbP3NYOiAiXmRFQu-28Rnz6QBn17bHxBwM-V4wdw@mail.gmail.com>
References: <CABHetKwan91zqm=0y=_84vG7ffveWTPYONZP_hLQx5o40iAnuQ@mail.gmail.com>
 <CAKaEYhJ_8tph3v9n139Ta+3sBaL-TmeOBNr-cCtti9dbdYuhCQ@mail.gmail.com>
 <CABE6yHvRihAbP3NYOiAiXmRFQu-28Rnz6QBn17bHxBwM-V4wdw@mail.gmail.com>
Message-ID: <CAJowKgJ8wm8GgPYXMdfYyzyPZksedCR=cQ7v_ADum=aOzR5r3Q@mail.gmail.com>

its trivial to store images in such a way that they look like legit
transactions.

this was done, in the past, using large numbers of multisig output
addresses that encode the images.

given the goals of the project, introducing this sort of censorship into
bitcoin seems fundamentally undesirable
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230206/54dd7165/attachment.html>

From aubergemediale at gmail.com  Mon Feb  6 17:31:45 2023
From: aubergemediale at gmail.com (Claus Ehrenberg)
Date: Mon, 6 Feb 2023 18:31:45 +0100
Subject: [bitcoin-dev] Ordinal Inscription Size Limits
In-Reply-To: <CABHetKwan91zqm=0y=_84vG7ffveWTPYONZP_hLQx5o40iAnuQ@mail.gmail.com>
References: <CABHetKwan91zqm=0y=_84vG7ffveWTPYONZP_hLQx5o40iAnuQ@mail.gmail.com>
Message-ID: <CANPykMqJ823NcCPxdwHvjOdW2MQPE8oA2JzThFQ2rUa8zHGUvA@mail.gmail.com>

The inscriptions are designed to be easy to use, they even specify that
mime types should be used. I'd say, the way the data is stored is anything
but 'obscure'. UIs will be popping up to make this really easy. The main
chain can't be censored, what's in a block is in a block. I'm predicting a
huge success.

So, are we ready to accept that we'll likely see the first pictures with
insults or worse in the Bitcoin chain? I really like the idea, but the risk
is pretty obvious. I think it would be prudent to have at least an opt-out
feature for the data. So that it's possible to use the chain without the
potentially malicious content. That means the content shouldn't live in the
essential data of the main chain. Better would be something like the
extension blocks in Litecoin.

Best Regards
Claus

On Fri, Jan 27, 2023 at 1:47 PM Robert Dickinson via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I'm curious what opinions exist and what actions might be taken by core
> developers regarding storing unlimited amounts of NFT (or other?) content
> as witness data (https://docs.ordinals.com/inscriptions.html). The
> ordinal scheme is elegant and genius IMHO, but when I think about the
> future disk use of all unpruned nodes, I question whether unlimited storage
> is wise to allow for such use cases. Wouldn't it be better to find a way to
> impose a size limit similar to OP_RETURN for such inscriptions?
>
> I think it would be useful to link a sat to a deed or other legal
> construct for proof of ownership in the real world, so that real property
> can be transferred on the blockchain using ordinals, but storing the
> property itself on the blockchain seems nonsensical to me.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230206/b8d52343/attachment.html>

From erik at q32.com  Mon Feb  6 18:05:05 2023
From: erik at q32.com (Erik Aronesty)
Date: Mon, 6 Feb 2023 13:05:05 -0500
Subject: [bitcoin-dev] Ordinal Inscription Size Limits
In-Reply-To: <CANPykMqJ823NcCPxdwHvjOdW2MQPE8oA2JzThFQ2rUa8zHGUvA@mail.gmail.com>
References: <CABHetKwan91zqm=0y=_84vG7ffveWTPYONZP_hLQx5o40iAnuQ@mail.gmail.com>
 <CANPykMqJ823NcCPxdwHvjOdW2MQPE8oA2JzThFQ2rUa8zHGUvA@mail.gmail.com>
Message-ID: <CAJowKgJv9uMo3x+fNjDyo4SvdxUDAdAUmXzF80580pneK+M2JA@mail.gmail.com>

there are already images encoded in the chain using multisig.  when we
eliminated the max-witness size in 2017, that made it a bit cheaper, that's
all (one tx instead of many)

https://www.righto.com/2014/02/ascii-bernanke-wikileaks-photographs.html

my favorite one is the javascript exploit for people that like to render
untrusted blockchain data in their browser

the script to interpret these is trivial, and it's not much harder to add a
mime type



On Mon, Feb 6, 2023 at 12:34 PM Claus Ehrenberg via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> The inscriptions are designed to be easy to use, they even specify that
> mime types should be used. I'd say, the way the data is stored is anything
> but 'obscure'. UIs will be popping up to make this really easy. The main
> chain can't be censored, what's in a block is in a block. I'm predicting a
> huge success.
>
> So, are we ready to accept that we'll likely see the first pictures with
> insults or worse in the Bitcoin chain? I really like the idea, but the risk
> is pretty obvious. I think it would be prudent to have at least an opt-out
> feature for the data. So that it's possible to use the chain without the
> potentially malicious content. That means the content shouldn't live in the
> essential data of the main chain. Better would be something like the
> extension blocks in Litecoin.
>
> Best Regards
> Claus
>
> On Fri, Jan 27, 2023 at 1:47 PM Robert Dickinson via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> I'm curious what opinions exist and what actions might be taken by core
>> developers regarding storing unlimited amounts of NFT (or other?) content
>> as witness data (https://docs.ordinals.com/inscriptions.html). The
>> ordinal scheme is elegant and genius IMHO, but when I think about the
>> future disk use of all unpruned nodes, I question whether unlimited storage
>> is wise to allow for such use cases. Wouldn't it be better to find a way to
>> impose a size limit similar to OP_RETURN for such inscriptions?
>>
>> I think it would be useful to link a sat to a deed or other legal
>> construct for proof of ownership in the real world, so that real property
>> can be transferred on the blockchain using ordinals, but storing the
>> property itself on the blockchain seems nonsensical to me.
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230206/8b27df91/attachment-0001.html>

From nothingmuch at woobling.org  Tue Feb  7 02:49:28 2023
From: nothingmuch at woobling.org (Yuval Kogman)
Date: Tue, 7 Feb 2023 04:49:28 +0200
Subject: [bitcoin-dev] Unenforceable fee obligations in multiparty protocols
	with Taproot inputs
Message-ID: <CAAQdECCH=YOcu4g6Ku1_G4CnRg6rsaFPFPwbABx9aZin9A8+2A@mail.gmail.com>

## Summary

Since Taproot (more generally any kind of MAST) spends have variable size which
depends on the path being used, the last such input to be signed in a multiparty
transaction can always use a larger than estimated signature to unfairly extract
a fee contribution from the other parties to the transaction (keeping the
absolute fees the same and reducing the feerate for the transaction).

## Attack Scenario

Alice et al wish to perform a multiparty transaction, such as a CoinJoin or
lightning dual funding at a relatively high feerate.

Mallory has a P2TR output with a large script spend path, e.g. an ordinal
inscription commitment transaction output.

Mallory registers this coin as an input into the multiparty transaction with a
fee obligation calculated on the basis of a key spend. When all other
participants have provided signatures, the script spend path can be used.

Since the absolute fee amount is already committed to by the provided
(`SIGHASH_ALL`) signatures but the total transaction weight is not, Mallory can
broadcast any valid signatures up to the maximum standard weight and minimum
relay fees, or in collusion with a miner, up to consensus limits.

This effectively steals a fee from Alice et al, as their signatures do not
commit to a feerate directly or indirectly.

## Mitigations

### RBF

All parties could negotiate a (series of) transaction(s) ahead of time at a
lower feerate, giving a lower bound minimum feerate that Mallory can force.

### Minimum Weight Before Signing

Enforcing a minimal weight for all non-witness data in the transaction before
the transaction is considered fully constructed can limit the effectiveness of
this attack, since the difference between the predicted weight and the maximum
weight decreases.

### Trusted Coordinator

In the centralized setting if BIP-322 ownership proofs are required for
participation and assuming the server can be trusted not to collude with
Mallory, the server can reject signatures that do not exercise the same spend
path as the ownership proof, which makes the ownership proof a commitment to the
spend weight of the input.

### Reputation

Multiparty protocols with publicly verifiable protocol transcripts can be
provided as weak evidence of a history of honest participation in multiparty
transactions.

A ring signature from keys used in the transaction or its transcript committing
to the new proposed transaction can provide weak evidence for the honesty of the
peer.

Such proofs are more compelling to an entity which has participated in (one of)
the transcripts, or proximal transactions. Incentives are theoretically aligned
if public coordinators publish these transcripts as a kind of server reputation.

### Increasing Costliness

A minimum feerate for the previous transaction or a minimum confirmation age
(coindays destroyed implies time value, analogous to fidelity bonds) can be
required for inputs to be added, in order to make such attacks less lucrative
(but there is still a positive payoff for the attacker).

### Signature Ordering

Signatures from potentially exploitative inputs can be required ahead of legacy
or SegWit v0 ones. The prescribed order can be determined based on reputation or
costliness as described in the previous paragraphs.

From lloyd.fourn at gmail.com  Tue Feb  7 04:38:30 2023
From: lloyd.fourn at gmail.com (Lloyd Fournier)
Date: Tue, 7 Feb 2023 15:38:30 +1100
Subject: [bitcoin-dev] Unenforceable fee obligations in multiparty
 protocols with Taproot inputs
In-Reply-To: <CAAQdECCH=YOcu4g6Ku1_G4CnRg6rsaFPFPwbABx9aZin9A8+2A@mail.gmail.com>
References: <CAAQdECCH=YOcu4g6Ku1_G4CnRg6rsaFPFPwbABx9aZin9A8+2A@mail.gmail.com>
Message-ID: <CAH5Bsr3FGakNoGDA2KZXtEJ8t=pMpLqEXDWDbd1sMQtkxY6FJQ@mail.gmail.com>

Hi Yuval,

This is an interesting attack. Usually I think of spending with a big
weight witness in the context of slowing down a confirmation of a
transaction, especially a DLC creation tx. There you can delay its
confirmation past some time (i.e. see if your team won the game, and then
either trying to confirm it by providing the slimmed down witness or double
cancelling it by double spending). In this case you are not trying to delay
it but to dilute your portion of the fee.

Another mitigation is to aggresively RBF double spend your input any time a
counterparty doesn't use the spending path they said they would and don't
deal with them again. Of course, various pinning attacks may prevent this
depending on how your joint tx is structured.

LL

On Tue, 7 Feb 2023 at 13:59, Yuval Kogman via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> ## Summary
>
> Since Taproot (more generally any kind of MAST) spends have variable size
> which
> depends on the path being used, the last such input to be signed in a
> multiparty
> transaction can always use a larger than estimated signature to unfairly
> extract
> a fee contribution from the other parties to the transaction (keeping the
> absolute fees the same and reducing the feerate for the transaction).
>
> ## Attack Scenario
>
> Alice et al wish to perform a multiparty transaction, such as a CoinJoin or
> lightning dual funding at a relatively high feerate.
>
> Mallory has a P2TR output with a large script spend path, e.g. an ordinal
> inscription commitment transaction output.
>
> Mallory registers this coin as an input into the multiparty transaction
> with a
> fee obligation calculated on the basis of a key spend. When all other
> participants have provided signatures, the script spend path can be used.
>
> Since the absolute fee amount is already committed to by the provided
> (`SIGHASH_ALL`) signatures but the total transaction weight is not,
> Mallory can
> broadcast any valid signatures up to the maximum standard weight and
> minimum
> relay fees, or in collusion with a miner, up to consensus limits.
>
> This effectively steals a fee from Alice et al, as their signatures do not
> commit to a feerate directly or indirectly.
>
> ## Mitigations
>
> ### RBF
>
> All parties could negotiate a (series of) transaction(s) ahead of time at a
> lower feerate, giving a lower bound minimum feerate that Mallory can force.
>
> ### Minimum Weight Before Signing
>
> Enforcing a minimal weight for all non-witness data in the transaction
> before
> the transaction is considered fully constructed can limit the
> effectiveness of
> this attack, since the difference between the predicted weight and the
> maximum
> weight decreases.
>
> ### Trusted Coordinator
>
> In the centralized setting if BIP-322 ownership proofs are required for
> participation and assuming the server can be trusted not to collude with
> Mallory, the server can reject signatures that do not exercise the same
> spend
> path as the ownership proof, which makes the ownership proof a commitment
> to the
> spend weight of the input.
>
> ### Reputation
>
> Multiparty protocols with publicly verifiable protocol transcripts can be
> provided as weak evidence of a history of honest participation in
> multiparty
> transactions.
>
> A ring signature from keys used in the transaction or its transcript
> committing
> to the new proposed transaction can provide weak evidence for the honesty
> of the
> peer.
>
> Such proofs are more compelling to an entity which has participated in
> (one of)
> the transcripts, or proximal transactions. Incentives are theoretically
> aligned
> if public coordinators publish these transcripts as a kind of server
> reputation.
>
> ### Increasing Costliness
>
> A minimum feerate for the previous transaction or a minimum confirmation
> age
> (coindays destroyed implies time value, analogous to fidelity bonds) can be
> required for inputs to be added, in order to make such attacks less
> lucrative
> (but there is still a positive payoff for the attacker).
>
> ### Signature Ordering
>
> Signatures from potentially exploitative inputs can be required ahead of
> legacy
> or SegWit v0 ones. The prescribed order can be determined based on
> reputation or
> costliness as described in the previous paragraphs.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230207/95202031/attachment.html>

From nadav at shesek.info  Tue Feb  7 09:36:58 2023
From: nadav at shesek.info (Nadav Ivgi)
Date: Tue, 7 Feb 2023 11:36:58 +0200
Subject: [bitcoin-dev] Unenforceable fee obligations in multiparty
 protocols with Taproot inputs
In-Reply-To: <CAAQdECCH=YOcu4g6Ku1_G4CnRg6rsaFPFPwbABx9aZin9A8+2A@mail.gmail.com>
References: <CAAQdECCH=YOcu4g6Ku1_G4CnRg6rsaFPFPwbABx9aZin9A8+2A@mail.gmail.com>
Message-ID: <CAGXD5f3Bu3+BsbRQNcA=eugW7FDdgR0xQdpn66925b4DjRyJeQ@mail.gmail.com>

> Since Taproot (more generally any kind of MAST) spends have variable size

Isn't this the case with any arbitrary script execution? Non-taproot
P2(W)SH can also have multiple (OP_IF-gated) script branches. For example
with `<pk> CHECKSIG IF SHA256 <hash> EQUALVERIFY ENDIF`, Mallory can
initially demonstrate that she can spend with `FALSE <sig>`, then later
switch to spending with `<some large preimage> TRUE <sig>`. (or I guess
even `DROP <pk> CHECKSIG`, then just switch from DROPing a 0 length item to
a larger one)

It seems that supporting arbitrary scripts would require analyzing them and
verifying that all spend paths are acceptable, with or without Taproot/MAST.

If the goal is to only allow registering simple singlesig-encumbered UTXOs
like P2(W)PKH, the participants could be asked to prove that their P2TR
output commits to an unspendable script path [0].

shesek

[0]
https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_ref-23-0

On Tue, Feb 7, 2023 at 4:59 AM Yuval Kogman via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> ## Summary
>
> Since Taproot (more generally any kind of MAST) spends have variable size
> which
> depends on the path being used, the last such input to be signed in a
> multiparty
> transaction can always use a larger than estimated signature to unfairly
> extract
> a fee contribution from the other parties to the transaction (keeping the
> absolute fees the same and reducing the feerate for the transaction).
>
> ## Attack Scenario
>
> Alice et al wish to perform a multiparty transaction, such as a CoinJoin or
> lightning dual funding at a relatively high feerate.
>
> Mallory has a P2TR output with a large script spend path, e.g. an ordinal
> inscription commitment transaction output.
>
> Mallory registers this coin as an input into the multiparty transaction
> with a
> fee obligation calculated on the basis of a key spend. When all other
> participants have provided signatures, the script spend path can be used.
>
> Since the absolute fee amount is already committed to by the provided
> (`SIGHASH_ALL`) signatures but the total transaction weight is not,
> Mallory can
> broadcast any valid signatures up to the maximum standard weight and
> minimum
> relay fees, or in collusion with a miner, up to consensus limits.
>
> This effectively steals a fee from Alice et al, as their signatures do not
> commit to a feerate directly or indirectly.
>
> ## Mitigations
>
> ### RBF
>
> All parties could negotiate a (series of) transaction(s) ahead of time at a
> lower feerate, giving a lower bound minimum feerate that Mallory can force.
>
> ### Minimum Weight Before Signing
>
> Enforcing a minimal weight for all non-witness data in the transaction
> before
> the transaction is considered fully constructed can limit the
> effectiveness of
> this attack, since the difference between the predicted weight and the
> maximum
> weight decreases.
>
> ### Trusted Coordinator
>
> In the centralized setting if BIP-322 ownership proofs are required for
> participation and assuming the server can be trusted not to collude with
> Mallory, the server can reject signatures that do not exercise the same
> spend
> path as the ownership proof, which makes the ownership proof a commitment
> to the
> spend weight of the input.
>
> ### Reputation
>
> Multiparty protocols with publicly verifiable protocol transcripts can be
> provided as weak evidence of a history of honest participation in
> multiparty
> transactions.
>
> A ring signature from keys used in the transaction or its transcript
> committing
> to the new proposed transaction can provide weak evidence for the honesty
> of the
> peer.
>
> Such proofs are more compelling to an entity which has participated in
> (one of)
> the transcripts, or proximal transactions. Incentives are theoretically
> aligned
> if public coordinators publish these transcripts as a kind of server
> reputation.
>
> ### Increasing Costliness
>
> A minimum feerate for the previous transaction or a minimum confirmation
> age
> (coindays destroyed implies time value, analogous to fidelity bonds) can be
> required for inputs to be added, in order to make such attacks less
> lucrative
> (but there is still a positive payoff for the attacker).
>
> ### Signature Ordering
>
> Signatures from potentially exploitative inputs can be required ahead of
> legacy
> or SegWit v0 ones. The prescribed order can be determined based on
> reputation or
> costliness as described in the previous paragraphs.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230207/85947d66/attachment-0001.html>

From pete at petertodd.org  Tue Feb  7 12:50:13 2023
From: pete at petertodd.org (Peter Todd)
Date: Tue, 7 Feb 2023 07:50:13 -0500
Subject: [bitcoin-dev] Unenforceable fee obligations in multiparty
 protocols with Taproot inputs
In-Reply-To: <CAGXD5f3Bu3+BsbRQNcA=eugW7FDdgR0xQdpn66925b4DjRyJeQ@mail.gmail.com>
References: <CAAQdECCH=YOcu4g6Ku1_G4CnRg6rsaFPFPwbABx9aZin9A8+2A@mail.gmail.com>
 <CAGXD5f3Bu3+BsbRQNcA=eugW7FDdgR0xQdpn66925b4DjRyJeQ@mail.gmail.com>
Message-ID: <Y+JJBXsgJGSRZR29@petertodd.org>

On Tue, Feb 07, 2023 at 11:36:58AM +0200, Nadav Ivgi via bitcoin-dev wrote:
> > Since Taproot (more generally any kind of MAST) spends have variable size
> 
> Isn't this the case with any arbitrary script execution? Non-taproot

This is even been true for P2PKH inputs: you can double the space of your
scriptSigs by using uncompressed pubkeys instead of compressed pubkeys.

> If the goal is to only allow registering simple singlesig-encumbered UTXOs
> like P2(W)PKH, the participants could be asked to prove that their P2TR
> output commits to an unspendable script path [0].

Technically, only the last person to sign needs to prove this in advance.
Everyone else can prove it with their signatures.

This distinction could be useful to support coinjoin participants spending
complex P2TR outputs into coinjoins, a perfectly valid use-case in theory so
long as they're paying appropriate fees. Though due to how difficult it is to
validate scripts reliably outside the consensus code base, allowing this for
arbitrary scripts could lead to DoS attacks where someone takes advantage of a
bug in script execution to create an invalid transaction.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230207/03253ed3/attachment.sig>

From apoelstra at wpsoftware.net  Tue Feb  7 13:46:22 2023
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Tue, 7 Feb 2023 13:46:22 +0000
Subject: [bitcoin-dev] Unenforceable fee obligations in multiparty
 protocols with Taproot inputs
In-Reply-To: <CAAQdECCH=YOcu4g6Ku1_G4CnRg6rsaFPFPwbABx9aZin9A8+2A@mail.gmail.com>
References: <CAAQdECCH=YOcu4g6Ku1_G4CnRg6rsaFPFPwbABx9aZin9A8+2A@mail.gmail.com>
Message-ID: <Y+JWLsc80gxL4kpG@camus>

On Tue, Feb 07, 2023 at 04:49:28AM +0200, Yuval Kogman via bitcoin-dev wrote:
> 
> Since Taproot (more generally any kind of MAST) spends have variable size which
> depends on the path being used, the last such input to be signed in a multiparty
> transaction can always use a larger than estimated signature to unfairly extract
> a fee contribution from the other parties to the transaction (keeping the
> absolute fees the same and reducing the feerate for the transaction).
>

Using Miniscript [1] it is possible for all participants to determine
the maximum witness size of the tree, which can bound the size of this
attack. In fact, they can bound the size *given that their own signature
is used*, or subject to other whatever other conditions they would like,
and only sign under those conditions.

Furthermore, under Taproot individual signatures have a maximum size of
65 bytes; an "attacker" can reduce this to 64 by not including a sighash
flag, but he has one byte of play. (Pre-Taproot signatures could take up
to 73 bytes with significant room to reduce this by using crypto tricks
and/or grinding).

Peter Todd also suggests in this thread that the use of uncompressed
keys can cause "surprise" witness inflation, but (a) since segwit
uncompressed keys are also banned, so keys are a fixed 33 bytes (32 in
Taproot), and (b) we expect users of Miniscript to always know all the
keys used in a script that they're signing. Except perhaps in obscure
cases where, say, the "victim" is a somewhat passive countersigner of
a transaction, e.g. BitGo, ... in which case they're not the one putting
up fees or with an interest in the transaction going through.


With Miniscript, the problem is narrower:

* There is some more-expensive branch that could be taken without
  Alice's signature. In which case Alice is only signing at all to
  optimistically reduce the witness size... but she cannot assume
  that she is going to be successful!

  Notably, in this case Alice does not really have any interest in the
  coins, in the sense that they can move entirely without her consent,
  so it's hard to imagine that she has an interest in the transaction's
  speedy confirmation.

* There is some more-expensive branch that could be taken by moving
  Alice's signature. This is the case that you identify in the thread.

While the attack remains in both cases, fortunately Miniscript gives
Alice the tools to (a) determine which, if any, case applies to the
script under question, and (b) determine what the maximum witness size
might be, and just sign assuming that, treating any savings as "bonus".



[1] https://bitcoin.sipa.be/miniscript/
[2] In Taproot, if you want to prevent signatures migrating to another
    branch or within a branch, you can use the CODESEPARATOR opcode
    which was redisegned in Taproot for exactly this purpose... we
    really did about witness malleation in its design!

    If you want to prevent signatures from moving around *within* a
    branch,

-- 
Andrew Poelstra
Director of Research, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

The sun is always shining in space
    -Justin Lewis-Webster

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230207/bd1c6f4e/attachment.sig>

From aymeric at peersm.com  Tue Feb  7 12:17:24 2023
From: aymeric at peersm.com (Aymeric Vitte)
Date: Tue, 7 Feb 2023 13:17:24 +0100
Subject: [bitcoin-dev] Ordinal Inscription Size Limits
In-Reply-To: <CAJowKgJv9uMo3x+fNjDyo4SvdxUDAdAUmXzF80580pneK+M2JA@mail.gmail.com>
References: <CABHetKwan91zqm=0y=_84vG7ffveWTPYONZP_hLQx5o40iAnuQ@mail.gmail.com>
 <CANPykMqJ823NcCPxdwHvjOdW2MQPE8oA2JzThFQ2rUa8zHGUvA@mail.gmail.com>
 <CAJowKgJv9uMo3x+fNjDyo4SvdxUDAdAUmXzF80580pneK+M2JA@mail.gmail.com>
Message-ID: <fa0d8b93-9dc7-0c19-459f-c095cc151e4c@peersm.com>



Le 06/02/2023 ? 19:05, Erik Aronesty via bitcoin-dev a ?crit :
> my favorite one is the javascript exploit for people that like to
> render untrusted blockchain data in their browser

Taking this example to show that from my standpoint it's not a good idea
to store "big things" in the blockchain, but it's a good idea to store
proofs of something ( then this is the rationale for this change request
https://github.com/bitcoin/bitcoin/issues/27043), we all know that there
are plenty of useless things already stored in the blockchain, now if
people want to pay to store big things, then let them do it

But how can you validate what is stored? Simple answer: you can't, I
take in my NFT proposal the example of js code loading, it's impossible
to be sure of the code loaded (and it is supposed to evolve, then which
version is correct in the blockchain can be mysterious) without using a
third party, that's what I am doing here: https://peersm.com/wallet, the
third party is my github repo, the code self validates that it is the
correct one and the user must check the hash, of course the code could
lie then you should better embed the check in a bookmarklet, the page
can't lie, and of course I could be  a thief then others should check
the code and seed the hash somewhere, even if clearly explained that the
code must be used off line it's not difficult to invent different things
to steal the keys

Same principle applies with my NFT proposal (which can be real things,
so impossible to store in the blockchain): a third party allowing a
timestamp is used to prove that you are the seeder of the NFT (first
owner), minting can't be trusted and then becomes useless with the third
party, so you spare some bitcoin transactions

Using a third party does not mean that the blockchain is of no use,
again the blockchain will validate the life of the NFT and it remains
decentralized like lightning




From apoelstra at wpsoftware.net  Tue Feb  7 18:10:10 2023
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Tue, 7 Feb 2023 18:10:10 +0000
Subject: [bitcoin-dev] Unenforceable fee obligations in multiparty
 protocols with Taproot inputs
In-Reply-To: <Y+JWLsc80gxL4kpG@camus>
References: <CAAQdECCH=YOcu4g6Ku1_G4CnRg6rsaFPFPwbABx9aZin9A8+2A@mail.gmail.com>
 <Y+JWLsc80gxL4kpG@camus>
Message-ID: <Y+KUAlsPc8ohPecb@camus>


Some people highlighted some minor problems with my last email:

On Tue, Feb 07, 2023 at 01:46:22PM +0000, Andrew Poelstra via bitcoin-dev wrote:
> 
> <snip> 
> 
> [1] https://bitcoin.sipa.be/miniscript/
> [2] In Taproot, if you want to prevent signatures migrating to another
>     branch or within a branch, you can use the CODESEPARATOR opcode
>     which was redisegned in Taproot for exactly this purpose... we
>     really did about witness malleation in its design!

In Taproot the tapleaf hash is always covered by the signature (though
not in some ANYONECANPAY proposals) so you can never migrate signatures
between tapbranches.

I had thought this was the case, but then I re-confused myself by
reading BIP 341 .... which has much of the sighash specified, but not
all of it! The tapleaf hash is added in BIP 342.

> 
>     If you want to prevent signatures from moving around *within* a
>     branch,
>

And this sentence I just meant to delete :)


-- 
Andrew Poelstra
Director of Research, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

The sun is always shining in space
    -Justin Lewis-Webster

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230207/8d59f739/attachment.sig>

From pete at petertodd.org  Tue Feb  7 18:12:36 2023
From: pete at petertodd.org (Peter Todd)
Date: Tue, 7 Feb 2023 13:12:36 -0500
Subject: [bitcoin-dev] Unenforceable fee obligations in multiparty
 protocols with Taproot inputs
In-Reply-To: <Y+JWLsc80gxL4kpG@camus>
References: <CAAQdECCH=YOcu4g6Ku1_G4CnRg6rsaFPFPwbABx9aZin9A8+2A@mail.gmail.com>
 <Y+JWLsc80gxL4kpG@camus>
Message-ID: <Y+KUlMU6pyde9kqa@petertodd.org>

On Tue, Feb 07, 2023 at 01:46:22PM +0000, Andrew Poelstra via bitcoin-dev wrote:
> Peter Todd also suggests in this thread that the use of uncompressed
> keys can cause "surprise" witness inflation, but (a) since segwit
> uncompressed keys are also banned, so keys are a fixed 33 bytes (32 in
> Taproot)

To be clear, I was just pointing out that this problem has existed, in theory
at least, since the beginning of Bitcoin (compressed pubkeys were supported in
v0.1.0). P2PKH addresses are the pre-P2SH ones that start with 1.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230207/483ec009/attachment-0001.sig>

From roconnor at blockstream.com  Tue Feb  7 18:35:12 2023
From: roconnor at blockstream.com (Russell O'Connor)
Date: Tue, 7 Feb 2023 13:35:12 -0500
Subject: [bitcoin-dev] Unenforceable fee obligations in multiparty
 protocols with Taproot inputs
In-Reply-To: <Y+KUAlsPc8ohPecb@camus>
References: <CAAQdECCH=YOcu4g6Ku1_G4CnRg6rsaFPFPwbABx9aZin9A8+2A@mail.gmail.com>
 <Y+JWLsc80gxL4kpG@camus> <Y+KUAlsPc8ohPecb@camus>
Message-ID: <CAMZUoK=u2114uv0Uc0u_RVMBv-cq-gJiNxiyOk_T_xxTYO0Ghw@mail.gmail.com>

There is a bug in Taproot that allows the same Tapleaf to be repeated
multiple times in the same Taproot, potentially at different Taplevels
incurring different Tapfee rates.

The countermeasure is that you should always know the entire Taptree when
interacting with someone's Tapspend.


On Tue, Feb 7, 2023 at 1:10 PM Andrew Poelstra via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> Some people highlighted some minor problems with my last email:
>
> On Tue, Feb 07, 2023 at 01:46:22PM +0000, Andrew Poelstra via bitcoin-dev
> wrote:
> >
> > <snip>
> >
> > [1] https://bitcoin.sipa.be/miniscript/
> > [2] In Taproot, if you want to prevent signatures migrating to another
> >     branch or within a branch, you can use the CODESEPARATOR opcode
> >     which was redisegned in Taproot for exactly this purpose... we
> >     really did about witness malleation in its design!
>
> In Taproot the tapleaf hash is always covered by the signature (though
> not in some ANYONECANPAY proposals) so you can never migrate signatures
> between tapbranches.
>
> I had thought this was the case, but then I re-confused myself by
> reading BIP 341 .... which has much of the sighash specified, but not
> all of it! The tapleaf hash is added in BIP 342.
>
> >
> >     If you want to prevent signatures from moving around *within* a
> >     branch,
> >
>
> And this sentence I just meant to delete :)
>
>
> --
> Andrew Poelstra
> Director of Research, Blockstream
> Email: apoelstra at wpsoftware.net
> Web:   https://www.wpsoftware.net/andrew
>
> The sun is always shining in space
>     -Justin Lewis-Webster
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230207/57930553/attachment.html>

From pete at petertodd.org  Tue Feb  7 19:04:00 2023
From: pete at petertodd.org (Peter Todd)
Date: Tue, 7 Feb 2023 14:04:00 -0500
Subject: [bitcoin-dev] Unenforceable fee obligations in multiparty
 protocols with Taproot inputs
In-Reply-To: <CAMZUoK=u2114uv0Uc0u_RVMBv-cq-gJiNxiyOk_T_xxTYO0Ghw@mail.gmail.com>
References: <CAAQdECCH=YOcu4g6Ku1_G4CnRg6rsaFPFPwbABx9aZin9A8+2A@mail.gmail.com>
 <Y+JWLsc80gxL4kpG@camus> <Y+KUAlsPc8ohPecb@camus>
 <CAMZUoK=u2114uv0Uc0u_RVMBv-cq-gJiNxiyOk_T_xxTYO0Ghw@mail.gmail.com>
Message-ID: <Y+KgoLiyAvGhuHCE@petertodd.org>

On Tue, Feb 07, 2023 at 01:35:12PM -0500, Russell O'Connor via bitcoin-dev wrote:
> There is a bug in Taproot that allows the same Tapleaf to be repeated
> multiple times in the same Taproot, potentially at different Taplevels
> incurring different Tapfee rates.
> 
> The countermeasure is that you should always know the entire Taptree when
> interacting with someone's Tapspend.

Another countermeasure could be to implement RBF on taproot witnesses, allowing
transactions with deeper, less efficient, tapleaf scripts to be replaced with
shallower, more efficient, tapleafs. If implemented by giving your peer some
kind of delta encoded update, the bandwidth efficiency may be sufficient to
always allow such updates.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230207/38829718/attachment.sig>

From antoine.riard at gmail.com  Wed Feb  8 00:56:30 2023
From: antoine.riard at gmail.com (Antoine Riard)
Date: Wed, 8 Feb 2023 00:56:30 +0000
Subject: [bitcoin-dev] Unenforceable fee obligations in multiparty
 protocols with Taproot inputs
In-Reply-To: <CAAQdECCH=YOcu4g6Ku1_G4CnRg6rsaFPFPwbABx9aZin9A8+2A@mail.gmail.com>
References: <CAAQdECCH=YOcu4g6Ku1_G4CnRg6rsaFPFPwbABx9aZin9A8+2A@mail.gmail.com>
Message-ID: <CALZpt+E2XKmqAELcedN8-5JkCOwmEH-CN8nwmpwW74xGUZPtbA@mail.gmail.com>

Hi Yuval,


> Since the absolute fee amount is already committed to by the provided

> (`SIGHASH_ALL`) signatures but the total transaction weight is not,
Mallory can

> broadcast any valid signatures up to the maximum standard weight and
minimum

> relay fees, or in collusion with a miner, up to consensus limits.

>

> This effectively steals a fee from Alice et al, as their signatures do not

> commit to a feerate directly or indirectly.


>From what I understand, there are many inputs for the coinjoin transaction,
the latest signer provides an inflated witness downgrading the multi-party
transaction feerate. It doesn't sound to me a fee siphoning as occurring
with loose malleability [0], rather another case of transaction-relay
jamming where the adversary's goal is to slow down the confirmation of the
transaction to waste everyone timevalue.


I think the issue has already been mentioned to advocate updating Core's
mempool acceptance policy, and allows wtxid-replacement [1]. There is also
a description available here [2].


To mitigate, among the peer-to-peer style of mitigations, one is of course a
reputation strategy or monetary strategy, where the asymmetries in
counterparties reputation are compensated with out-of-band
fees/credentials. I don't think increasing adversary costliness is that
efficient as there is a scaling effect (e.g the feerate of the previous
transaction can be used to feed N outputs for N dissociated attack
contexts). Signature ordering supposes also a reputation basis, and it
doesn't exclude giving a transaction construction edge to the reputational
counterparty (e.g a LSP "promising" a dual-funding UTXO to X distinct
participant, picking up the first to yield back a signature).


Best,

Antoine


[0]
https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-September/002796.html

[1] https://github.com/bitcoin/bitcoin/pull/19645

[2]
https://gist.github.com/ariard/7e509bf2c81ea8049fd0c67978c521af#witness-malleability

Le mar. 7 f?vr. 2023 ? 02:59, Yuval Kogman via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> a ?crit :

> ## Summary
>
> Since Taproot (more generally any kind of MAST) spends have variable size
> which
> depends on the path being used, the last such input to be signed in a
> multiparty
> transaction can always use a larger than estimated signature to unfairly
> extract
> a fee contribution from the other parties to the transaction (keeping the
> absolute fees the same and reducing the feerate for the transaction).
>
> ## Attack Scenario
>
> Alice et al wish to perform a multiparty transaction, such as a CoinJoin or
> lightning dual funding at a relatively high feerate.
>
> Mallory has a P2TR output with a large script spend path, e.g. an ordinal
> inscription commitment transaction output.
>
> Mallory registers this coin as an input into the multiparty transaction
> with a
> fee obligation calculated on the basis of a key spend. When all other
> participants have provided signatures, the script spend path can be used.
>
> Since the absolute fee amount is already committed to by the provided
> (`SIGHASH_ALL`) signatures but the total transaction weight is not,
> Mallory can
> broadcast any valid signatures up to the maximum standard weight and
> minimum
> relay fees, or in collusion with a miner, up to consensus limits.
>
> This effectively steals a fee from Alice et al, as their signatures do not
> commit to a feerate directly or indirectly.
>
> ## Mitigations
>
> ### RBF
>
> All parties could negotiate a (series of) transaction(s) ahead of time at a
> lower feerate, giving a lower bound minimum feerate that Mallory can force.
>
> ### Minimum Weight Before Signing
>
> Enforcing a minimal weight for all non-witness data in the transaction
> before
> the transaction is considered fully constructed can limit the
> effectiveness of
> this attack, since the difference between the predicted weight and the
> maximum
> weight decreases.
>
> ### Trusted Coordinator
>
> In the centralized setting if BIP-322 ownership proofs are required for
> participation and assuming the server can be trusted not to collude with
> Mallory, the server can reject signatures that do not exercise the same
> spend
> path as the ownership proof, which makes the ownership proof a commitment
> to the
> spend weight of the input.
>
> ### Reputation
>
> Multiparty protocols with publicly verifiable protocol transcripts can be
> provided as weak evidence of a history of honest participation in
> multiparty
> transactions.
>
> A ring signature from keys used in the transaction or its transcript
> committing
> to the new proposed transaction can provide weak evidence for the honesty
> of the
> peer.
>
> Such proofs are more compelling to an entity which has participated in
> (one of)
> the transcripts, or proximal transactions. Incentives are theoretically
> aligned
> if public coordinators publish these transcripts as a kind of server
> reputation.
>
> ### Increasing Costliness
>
> A minimum feerate for the previous transaction or a minimum confirmation
> age
> (coindays destroyed implies time value, analogous to fidelity bonds) can be
> required for inputs to be added, in order to make such attacks less
> lucrative
> (but there is still a positive payoff for the attacker).
>
> ### Signature Ordering
>
> Signatures from potentially exploitative inputs can be required ahead of
> legacy
> or SegWit v0 ones. The prescribed order can be determined based on
> reputation or
> costliness as described in the previous paragraphs.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230208/2fb22540/attachment-0001.html>

From antoine.riard at gmail.com  Wed Feb  8 01:59:59 2023
From: antoine.riard at gmail.com (Antoine Riard)
Date: Wed, 8 Feb 2023 01:59:59 +0000
Subject: [bitcoin-dev] Bitcoin Contracting Primitives WG 4rd Meeting,
	Tuesday 21 Feb. 18:00 UTC
Message-ID: <CALZpt+Ep+pSkO58eOrzM57EZCGi--iperhyiEtrGP83rLp5atA@mail.gmail.com>

Hi list,

I'm proposing Tuesday 21st February at 18:00, i.e 2 weeks from now for the
4th Bitcoin contracting primitives WG meeting (the third Tuesday of
February month, as done previously).

As mentioned during the previous session, there is an issue if anyone would
like to propose an agenda topic in advance in an open fashion:
https://github.com/ariard/bitcoin-contracting-primitives-wg/issues/34

I would like to propose 2 topics for this upcoming meeting.

Firstly, ANYPREVOUT / "Eltoo", there has been a work in progress during the
last year for eltoo lightning channels [0]. I think there are still few
high-level open questions around fee-bumping and watchtowers, how the
proposal would benefit other off-chain constructions, how the proposal
works compared to other update mechanisms and a bunch of other things.

Secondly, if there is sufficient interest, setting up an open meatspace
event during S2 2023 or S1 2024. Meatspace events can be a great thing to
accelerate the development pace of contracting protocols. From my
experience in-person whiteboard sessions are highly valuable to sync on
complex subjects and it has been already evoked in the context of this
community process. Ideally, the event would piggyback on some existing
bitcoin conference. And I would see this as complementary to the other
bitcoin engineering meetings we've already scheduled, just open contracting
primitives R&D to a large set of people beyond the usual crowd contributing
already to Bitcoin Core [1].

If we have time remaining, we could listen to everyone blockers in their
contracting primitives/covenant research.

Communication venue is #bitcoin-contracting-primitives-wg on Libera Chat
IRC. Logs of the previous session are available here [2].

If you have any questions or feedback, I'm staying responsive.

Cheers,
Antoine

[0]
https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-December/003788.html
[1] In term of janitorial role decentralization, I think it would be
valuable to have the event organization carried on by someone else reliable
other than myself. Contributed to CoreDev Zurich 2021 organisation, so I
can share the operational practices.
[2]
https://github.com/ariard/bitcoin-contracting-primitives-wg/blob/main/meetings/meetings-17-01.md
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230208/bccc5f33/attachment.html>

From michaelfolkson at protonmail.com  Wed Feb  8 09:34:57 2023
From: michaelfolkson at protonmail.com (Michael Folkson)
Date: Wed, 08 Feb 2023 09:34:57 +0000
Subject: [bitcoin-dev] Unenforceable fee obligations in multiparty
	protocols with Taproot inputs
In-Reply-To: <CAMZUoK=u2114uv0Uc0u_RVMBv-cq-gJiNxiyOk_T_xxTYO0Ghw@mail.gmail.com>
References: <CAAQdECCH=YOcu4g6Ku1_G4CnRg6rsaFPFPwbABx9aZin9A8+2A@mail.gmail.com>
 <Y+JWLsc80gxL4kpG@camus> <Y+KUAlsPc8ohPecb@camus>
 <CAMZUoK=u2114uv0Uc0u_RVMBv-cq-gJiNxiyOk_T_xxTYO0Ghw@mail.gmail.com>
Message-ID: <VWZ9Dc2gIe0Y02yY3qSbjQTEPqwCm6YAtRzfNrIANBXCEJzr73SdxZT4LwBKDyriDfmDZyTlkKWtoZmVIUbYqqZUAeTMDLHUNFCBwR6hitQ=@protonmail.com>

Hi Andrew

> There is a bug in Taproot that allows the same Tapleaf to be repeated multiple times in the same Taproot, potentially at different Taplevels incurring different Tapfee rates.
>> The countermeasure is that you should always know the entire Taptree when interacting with someone's Tapspend.

I wouldn't say it is a "bug" unless there is a remedy for the bug that wasn't (and retrospectively should have been) included in the Taproot design. In retrospect and assuming you could redesign the Taproot consensus rules again today would you prevent spending from a valid P2TR address if a repeated Tapleaf hash was used to prove that a spending path was embedded in a Taproot tree? That's the only thing I can think of to attempt to remedy this "bug" and it would only be a partial protection as proving a spending path exists within a Taproot tree only requires a subset of the Tapleaf hashes.

I only point this out because there seems to be a push to find "bugs" and "accidental blowups" in the Taproot design currently. No problem with this if there are any, they should definitely be highlighted and discussed if they do exist. The nearest to a possible inferior design decision thus far that I'm aware of is x-only pubkeys in BIP340 [0].

Thanks
Michael

[0]: https://btctranscripts.com/london-bitcoin-devs/2022-08-11-tim-ruffing-musig2/#a-retrospective-look-at-bip340

--
Michael Folkson
Email: michaelfolkson at [protonmail.com](http://protonmail.com/)
Keybase: michaelfolkson
PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3

------- Original Message -------
On Tuesday, February 7th, 2023 at 18:35, Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> There is a bug in Taproot that allows the same Tapleaf to be repeated multiple times in the same Taproot, potentially at different Taplevels incurring different Tapfee rates.
>
> The countermeasure is that you should always know the entire Taptree when interacting with someone's Tapspend.
>
> On Tue, Feb 7, 2023 at 1:10 PM Andrew Poelstra via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Some people highlighted some minor problems with my last email:
>>
>> On Tue, Feb 07, 2023 at 01:46:22PM +0000, Andrew Poelstra via bitcoin-dev wrote:
>>>
>>> <snip>
>>>
>>> [1] https://bitcoin.sipa.be/miniscript/
>>> [2] In Taproot, if you want to prevent signatures migrating to another
>>> branch or within a branch, you can use the CODESEPARATOR opcode
>>> which was redisegned in Taproot for exactly this purpose... we
>>> really did about witness malleation in its design!
>>
>> In Taproot the tapleaf hash is always covered by the signature (though
>> not in some ANYONECANPAY proposals) so you can never migrate signatures
>> between tapbranches.
>>
>> I had thought this was the case, but then I re-confused myself by
>> reading BIP 341 .... which has much of the sighash specified, but not
>> all of it! The tapleaf hash is added in BIP 342.
>>
>>>
>>> If you want to prevent signatures from moving around *within* a
>>> branch,
>>>
>>
>> And this sentence I just meant to delete :)
>>
>> --
>> Andrew Poelstra
>> Director of Research, Blockstream
>> Email: apoelstra at wpsoftware.net
>> Web: https://www.wpsoftware.net/andrew
>>
>> The sun is always shining in space
>> -Justin Lewis-Webster
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230208/6a71e08e/attachment.html>

From apoelstra at wpsoftware.net  Wed Feb  8 14:00:48 2023
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Wed, 8 Feb 2023 14:00:48 +0000
Subject: [bitcoin-dev] Unenforceable fee obligations in multiparty
 protocols with Taproot inputs
In-Reply-To: <VWZ9Dc2gIe0Y02yY3qSbjQTEPqwCm6YAtRzfNrIANBXCEJzr73SdxZT4LwBKDyriDfmDZyTlkKWtoZmVIUbYqqZUAeTMDLHUNFCBwR6hitQ=@protonmail.com>
References: <CAAQdECCH=YOcu4g6Ku1_G4CnRg6rsaFPFPwbABx9aZin9A8+2A@mail.gmail.com>
 <Y+JWLsc80gxL4kpG@camus> <Y+KUAlsPc8ohPecb@camus>
 <CAMZUoK=u2114uv0Uc0u_RVMBv-cq-gJiNxiyOk_T_xxTYO0Ghw@mail.gmail.com>
 <VWZ9Dc2gIe0Y02yY3qSbjQTEPqwCm6YAtRzfNrIANBXCEJzr73SdxZT4LwBKDyriDfmDZyTlkKWtoZmVIUbYqqZUAeTMDLHUNFCBwR6hitQ=@protonmail.com>
Message-ID: <Y+OrEDooHlijDpJV@camus>

On Wed, Feb 08, 2023 at 09:34:57AM +0000, Michael Folkson wrote:
> Hi Andrew
> 
> > There is a bug in Taproot that allows the same Tapleaf to be repeated multiple times in the same Taproot, potentially at different Taplevels incurring different Tapfee rates.
> >> The countermeasure is that you should always know the entire Taptree when interacting with someone's Tapspend.
> 
> I wouldn't say it is a "bug" unless there is a remedy for the bug that wasn't (and retrospectively should have been) included in the Taproot design. In retrospect and assuming you could redesign the Taproot consensus rules again today would you prevent spending from a valid P2TR address if a repeated Tapleaf hash was used to prove that a spending path was embedded in a Taproot tree? That's the only thing I can think of to attempt to remedy this "bug" and it would only be a partial protection as proving a spending path exists within a Taproot tree only requires a subset of the Tapleaf hashes.
> 
> I only point this out because there seems to be a push to find "bugs" and "accidental blowups" in the Taproot design currently. No problem with this if there are any, they should definitely be highlighted and discussed if they do exist. The nearest to a possible inferior design decision thus far that I'm aware of is x-only pubkeys in BIP340 [0].
> 

I'm actually not certain what Russell's referring to, but if it's indeed
possible to construct TapTrees where the "same" leafhash appears multiple
times at different heights, that's something unintended and which we
could've fixed by changing the Merkle structure. I don't even think
there would've been an efficiency tradeoff.

So I think it's totally reasonable to call such a thing a "bug".

-- 
Andrew Poelstra
Director of Research, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

The sun is always shining in space
    -Justin Lewis-Webster

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230208/81f97b92/attachment.sig>

From roconnor at blockstream.com  Wed Feb  8 14:04:16 2023
From: roconnor at blockstream.com (Russell O'Connor)
Date: Wed, 8 Feb 2023 09:04:16 -0500
Subject: [bitcoin-dev] Unenforceable fee obligations in multiparty
 protocols with Taproot inputs
In-Reply-To: <VWZ9Dc2gIe0Y02yY3qSbjQTEPqwCm6YAtRzfNrIANBXCEJzr73SdxZT4LwBKDyriDfmDZyTlkKWtoZmVIUbYqqZUAeTMDLHUNFCBwR6hitQ=@protonmail.com>
References: <CAAQdECCH=YOcu4g6Ku1_G4CnRg6rsaFPFPwbABx9aZin9A8+2A@mail.gmail.com>
 <Y+JWLsc80gxL4kpG@camus> <Y+KUAlsPc8ohPecb@camus>
 <CAMZUoK=u2114uv0Uc0u_RVMBv-cq-gJiNxiyOk_T_xxTYO0Ghw@mail.gmail.com>
 <VWZ9Dc2gIe0Y02yY3qSbjQTEPqwCm6YAtRzfNrIANBXCEJzr73SdxZT4LwBKDyriDfmDZyTlkKWtoZmVIUbYqqZUAeTMDLHUNFCBwR6hitQ=@protonmail.com>
Message-ID: <CAMZUoKkGCEZ+8zW_8WfE4=q2x+gcC4vR06gxTW3XwgpH5WGXSw@mail.gmail.com>

The fix for the bug is to sign the entire tapbranch instead of the tapleaf.

On Wed., Feb. 8, 2023, 04:35 Michael Folkson, <michaelfolkson at protonmail.com>
wrote:

> Hi Andrew
>
> > There is a bug in Taproot that allows the same Tapleaf to be repeated
> multiple times in the same Taproot, potentially at different Taplevels
> incurring different Tapfee rates.
> >
> > The countermeasure is that you should always know the entire Taptree
> when interacting with someone's Tapspend.
>
> I wouldn't say it is a "bug" unless there is a remedy for the bug that
> wasn't (and retrospectively should have been) included in the Taproot
> design. In retrospect and assuming you could redesign the Taproot consensus
> rules again today would you prevent spending from a valid P2TR address if a
> repeated Tapleaf hash was used to prove that a spending path was embedded
> in a Taproot tree? That's the only thing I can think of to attempt to
> remedy this "bug" and it would only be a partial protection as proving a
> spending path exists within a Taproot tree only requires a subset of the
> Tapleaf hashes.
>
> I only point this out because there seems to be a push to find "bugs" and
> "accidental blowups" in the Taproot design currently. No problem with this
> if there are any, they should definitely be highlighted and discussed if
> they do exist. The nearest to a possible inferior design decision thus far
> that I'm aware of is x-only pubkeys in BIP340 [0].
>
> Thanks
> Michael
>
> [0]:
> https://btctranscripts.com/london-bitcoin-devs/2022-08-11-tim-ruffing-musig2/#a-retrospective-look-at-bip340
>
> --
> Michael Folkson
> Email: michaelfolkson at protonmail.com
> Keybase: michaelfolkson
> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3
>
> ------- Original Message -------
> On Tuesday, February 7th, 2023 at 18:35, Russell O'Connor via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> There is a bug in Taproot that allows the same Tapleaf to be repeated
> multiple times in the same Taproot, potentially at different Taplevels
> incurring different Tapfee rates.
>
> The countermeasure is that you should always know the entire Taptree when
> interacting with someone's Tapspend.
>
>
> On Tue, Feb 7, 2023 at 1:10 PM Andrew Poelstra via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>>
>> Some people highlighted some minor problems with my last email:
>>
>> On Tue, Feb 07, 2023 at 01:46:22PM +0000, Andrew Poelstra via bitcoin-dev
>> wrote:
>> >
>> > <snip>
>> >
>> > [1] https://bitcoin.sipa.be/miniscript/
>> > [2] In Taproot, if you want to prevent signatures migrating to another
>> > branch or within a branch, you can use the CODESEPARATOR opcode
>> > which was redisegned in Taproot for exactly this purpose... we
>> > really did about witness malleation in its design!
>>
>> In Taproot the tapleaf hash is always covered by the signature (though
>> not in some ANYONECANPAY proposals) so you can never migrate signatures
>> between tapbranches.
>>
>> I had thought this was the case, but then I re-confused myself by
>> reading BIP 341 .... which has much of the sighash specified, but not
>> all of it! The tapleaf hash is added in BIP 342.
>>
>> >
>> > If you want to prevent signatures from moving around *within* a
>> > branch,
>> >
>>
>> And this sentence I just meant to delete :)
>>
>>
>> --
>> Andrew Poelstra
>> Director of Research, Blockstream
>> Email: apoelstra at wpsoftware.net
>> Web: https://www.wpsoftware.net/andrew
>>
>> The sun is always shining in space
>> -Justin Lewis-Webster
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230208/d4adc425/attachment-0001.html>

From nothingmuch at woobling.org  Fri Feb 10 19:35:06 2023
From: nothingmuch at woobling.org (Yuval Kogman)
Date: Fri, 10 Feb 2023 21:35:06 +0200
Subject: [bitcoin-dev] Unenforceable fee obligations in multiparty
 protocols with Taproot inputs
In-Reply-To: <CALZpt+E2XKmqAELcedN8-5JkCOwmEH-CN8nwmpwW74xGUZPtbA@mail.gmail.com>
References: <CAAQdECCH=YOcu4g6Ku1_G4CnRg6rsaFPFPwbABx9aZin9A8+2A@mail.gmail.com>
 <CALZpt+E2XKmqAELcedN8-5JkCOwmEH-CN8nwmpwW74xGUZPtbA@mail.gmail.com>
Message-ID: <CAAQdECCDfmAmxvSWfTsiTz_0TecpA8zoryZzHT==mXDU0p-xoA@mail.gmail.com>

On Wed, 8 Feb 2023 at 02:56, Antoine Riard <antoine.riard at gmail.com> wrote:
> From what I understand, there are many inputs for the coinjoin transaction, the latest signer provides an inflated witness downgrading the multi-party transaction feerate.

Yep!

>  It doesn't sound to me a fee siphoning as occurring with loose malleability [0], rather another case of transaction-relay jamming where the adversary's goal is to slow down the confirmation of the transaction to waste everyone timevalue.
>
> I think the issue has already been mentioned to advocate updating Core's mempool acceptance policy, and allows wtxid-replacement [1]. There is also a description available here [2].

Yep, the mechanism is basically the same as witness malleability based jamming.

Apologies for not citing, I think I must have seen that before but
only remembered the pinning variants, and so did not recall it at the
time that I wrote this up, which I did rather hastily.

However, I do think the adversary model should be broadened, as there
is a potential positive externality to a party which simply wishes to
get some witness data confirmed in a block while paying less than the
market rate, without needing to assume time sensitive contracts in the
threat model.

What I had in mind was the estimated witness size messages in the dual
funding proposal and felt they would create a false sense of
validation, specifically in the context of an adversary interested in
having their ordinal inscriptions being paid for by someone else by
subverting the a priori agreed upon feerate. From my point of view
this is primarily an argument for RBF by default (ideally full RBF, as
rule 3 of BIP 125 imposes difficult constraints on multiparty
transaction construction) in such protocols.

> I don't think increasing adversary costliness is that efficient as there is a scaling effect (e.g the feerate of the previous transaction can be used to feed N outputs for N dissociated attack contexts).

Yes, that doesn't make things incentive compatible but allows the
potential victims to have clearer bounds on the potential positive
payoff to the adversary. I think that's mainly useful in conjunction
constraining the order of signature submission, going from smallest to
largest input seems intuitively compelling but it seems to me like
ordering by feerate of creating transaction or perhaps some
combination of the two might provide a stronger deterrent.

Either way the main takeaway in my opinion is not that this is a
serious attack, as it's hard to exploit in theory and as far as I know
none of the currently deployed protocols are in any way vulnerable:

1. dual funding supports RBF and quite amenable to reputation based mitigations
2. in JoinMarket the taker can protect themselves
3. centralized coinjoins, despite misleading claims to the contrary by
both vendors, currently strongly rely on a trusted server for many
other aspects of the protocol and all three protocols are not
currently exploitable as described (the attacker can't broadcast the
transaction with a witness that would otherwise be rejected by the
server)

... but rather that (full) RBF is required for incentive compatible
multiparty transactions (or the closest approximation of incentive
compatibility possible barring future soft forks).

From aj at erisian.com.au  Sat Feb 11 05:14:55 2023
From: aj at erisian.com.au (Anthony Towns)
Date: Sat, 11 Feb 2023 15:14:55 +1000
Subject: [bitcoin-dev] Unenforceable fee obligations in multiparty
	protocols with Taproot inputs
In-Reply-To: <CAMZUoKkGCEZ+8zW_8WfE4=q2x+gcC4vR06gxTW3XwgpH5WGXSw@mail.gmail.com>
References: <CAAQdECCH=YOcu4g6Ku1_G4CnRg6rsaFPFPwbABx9aZin9A8+2A@mail.gmail.com>
 <Y+JWLsc80gxL4kpG@camus> <Y+KUAlsPc8ohPecb@camus>
 <CAMZUoK=u2114uv0Uc0u_RVMBv-cq-gJiNxiyOk_T_xxTYO0Ghw@mail.gmail.com>
 <VWZ9Dc2gIe0Y02yY3qSbjQTEPqwCm6YAtRzfNrIANBXCEJzr73SdxZT4LwBKDyriDfmDZyTlkKWtoZmVIUbYqqZUAeTMDLHUNFCBwR6hitQ=@protonmail.com>
 <CAMZUoKkGCEZ+8zW_8WfE4=q2x+gcC4vR06gxTW3XwgpH5WGXSw@mail.gmail.com>
Message-ID: <6C1009F7-A90A-4B7D-8ED3-C0E9399873B6@erisian.com.au>

On 9 February 2023 12:04:16 am AEST, Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>The fix for the bug is to sign the entire tapbranch instead of the tapleaf.
>
>On Wed., Feb. 8, 2023, 04:35 Michael Folkson, <michaelfolkson at protonmail.com>
>wrote:
>
>> Hi Andrew
>>
>> > There is a bug in Taproot that allows the same Tapleaf to be repeated
>> multiple times in the same Taproot, potentially at different Taplevels
>> incurring different Tapfee rates.
>> >
>> > The countermeasure is that you should always know the entire Taptree
>> when interacting with someone's Tapspend.
>>
>> I wouldn't say it is a "bug" unless there is a remedy for the bug that
>> wasn't (and retrospectively should have been) included in the Taproot
>> design. In retrospect and assuming you could redesign the Taproot consensus
>> rules again today would you prevent spending from a valid P2TR address if a
>> repeated Tapleaf hash was used to prove that a spending path was embedded
>> in a Taproot tree? That's the only thing I can think of to attempt to
>> remedy this "bug" and it would only be a partial protection as proving a
>> spending path exists within a Taproot tree only requires a subset of the
>> Tapleaf hashes.
>>
>> I only point this out because there seems to be a push to find "bugs" and
>> "accidental blowups" in the Taproot design currently. No problem with this
>> if there are any, they should definitely be highlighted and discussed if
>> they do exist. The nearest to a possible inferior design decision thus far
>> that I'm aware of is x-only pubkeys in BIP340 [0].
>>
>> Thanks
>> Michael
>>
>> [0]:
>> https://btctranscripts.com/london-bitcoin-devs/2022-08-11-tim-ruffing-musig2/#a-retrospective-look-at-bip340
>>
>> --
>> Michael Folkson
>> Email: michaelfolkson at protonmail.com
>> Keybase: michaelfolkson
>> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3
>>
>> ------- Original Message -------
>> On Tuesday, February 7th, 2023 at 18:35, Russell O'Connor via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> There is a bug in Taproot that allows the same Tapleaf to be repeated
>> multiple times in the same Taproot, potentially at different Taplevels
>> incurring different Tapfee rates.
>>
>> The countermeasure is that you should always know the entire Taptree when
>> interacting with someone's Tapspend.
>>
>>
>> On Tue, Feb 7, 2023 at 1:10 PM Andrew Poelstra via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>>
>>> Some people highlighted some minor problems with my last email:
>>>
>>> On Tue, Feb 07, 2023 at 01:46:22PM +0000, Andrew Poelstra via bitcoin-dev
>>> wrote:
>>> >
>>> > <snip>
>>> >
>>> > [1] https://bitcoin.sipa.be/miniscript/
>>> > [2] In Taproot, if you want to prevent signatures migrating to another
>>> > branch or within a branch, you can use the CODESEPARATOR opcode
>>> > which was redisegned in Taproot for exactly this purpose... we
>>> > really did about witness malleation in its design!
>>>
>>> In Taproot the tapleaf hash is always covered by the signature (though
>>> not in some ANYONECANPAY proposals) so you can never migrate signatures
>>> between tapbranches.
>>>
>>> I had thought this was the case, but then I re-confused myself by
>>> reading BIP 341 .... which has much of the sighash specified, but not
>>> all of it! The tapleaf hash is added in BIP 342.
>>>
>>> >
>>> > If you want to prevent signatures from moving around *within* a
>>> > branch,
>>> >
>>>
>>> And this sentence I just meant to delete :)
>>>
>>>
>>> --
>>> Andrew Poelstra
>>> Director of Research, Blockstream
>>> Email: apoelstra at wpsoftware.net
>>> Web: https://www.wpsoftware.net/andrew
>>>
>>> The sun is always shining in space
>>> -Justin Lewis-Webster
>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>
>>

Is this something that should be fixed in bip118 signatures then?

Cheers,
aj
-- 
Sent from my phone.

From roconnor at blockstream.com  Sat Feb 11 14:40:38 2023
From: roconnor at blockstream.com (Russell O'Connor)
Date: Sat, 11 Feb 2023 09:40:38 -0500
Subject: [bitcoin-dev] Unenforceable fee obligations in multiparty
 protocols with Taproot inputs
In-Reply-To: <6C1009F7-A90A-4B7D-8ED3-C0E9399873B6@erisian.com.au>
References: <CAAQdECCH=YOcu4g6Ku1_G4CnRg6rsaFPFPwbABx9aZin9A8+2A@mail.gmail.com>
 <Y+JWLsc80gxL4kpG@camus> <Y+KUAlsPc8ohPecb@camus>
 <CAMZUoK=u2114uv0Uc0u_RVMBv-cq-gJiNxiyOk_T_xxTYO0Ghw@mail.gmail.com>
 <VWZ9Dc2gIe0Y02yY3qSbjQTEPqwCm6YAtRzfNrIANBXCEJzr73SdxZT4LwBKDyriDfmDZyTlkKWtoZmVIUbYqqZUAeTMDLHUNFCBwR6hitQ=@protonmail.com>
 <CAMZUoKkGCEZ+8zW_8WfE4=q2x+gcC4vR06gxTW3XwgpH5WGXSw@mail.gmail.com>
 <6C1009F7-A90A-4B7D-8ED3-C0E9399873B6@erisian.com.au>
Message-ID: <CAMZUoKm3OJ4DVCnpGk+CfJGnMMnuJqsqNMr-sJh53Rx99wj9CA@mail.gmail.com>

Yes.  If you would otherwise sign the tapleaf, then I would recommend also
signing the entire tapbranch.



On Sat, Feb 11, 2023 at 12:15 AM Anthony Towns <aj at erisian.com.au> wrote:

> On 9 February 2023 12:04:16 am AEST, Russell O'Connor via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >The fix for the bug is to sign the entire tapbranch instead of the
> tapleaf.
> >
> >On Wed., Feb. 8, 2023, 04:35 Michael Folkson, <
> michaelfolkson at protonmail.com>
> >wrote:
> >
> >> Hi Andrew
> >>
> >> > There is a bug in Taproot that allows the same Tapleaf to be repeated
> >> multiple times in the same Taproot, potentially at different Taplevels
> >> incurring different Tapfee rates.
> >> >
> >> > The countermeasure is that you should always know the entire Taptree
> >> when interacting with someone's Tapspend.
> >>
> >> I wouldn't say it is a "bug" unless there is a remedy for the bug that
> >> wasn't (and retrospectively should have been) included in the Taproot
> >> design. In retrospect and assuming you could redesign the Taproot
> consensus
> >> rules again today would you prevent spending from a valid P2TR address
> if a
> >> repeated Tapleaf hash was used to prove that a spending path was
> embedded
> >> in a Taproot tree? That's the only thing I can think of to attempt to
> >> remedy this "bug" and it would only be a partial protection as proving a
> >> spending path exists within a Taproot tree only requires a subset of the
> >> Tapleaf hashes.
> >>
> >> I only point this out because there seems to be a push to find "bugs"
> and
> >> "accidental blowups" in the Taproot design currently. No problem with
> this
> >> if there are any, they should definitely be highlighted and discussed if
> >> they do exist. The nearest to a possible inferior design decision thus
> far
> >> that I'm aware of is x-only pubkeys in BIP340 [0].
> >>
> >> Thanks
> >> Michael
> >>
> >> [0]:
> >>
> https://btctranscripts.com/london-bitcoin-devs/2022-08-11-tim-ruffing-musig2/#a-retrospective-look-at-bip340
> >>
> >> --
> >> Michael Folkson
> >> Email: michaelfolkson at protonmail.com
> >> Keybase: michaelfolkson
> >> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3
> >>
> >> ------- Original Message -------
> >> On Tuesday, February 7th, 2023 at 18:35, Russell O'Connor via
> bitcoin-dev <
> >> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>
> >> There is a bug in Taproot that allows the same Tapleaf to be repeated
> >> multiple times in the same Taproot, potentially at different Taplevels
> >> incurring different Tapfee rates.
> >>
> >> The countermeasure is that you should always know the entire Taptree
> when
> >> interacting with someone's Tapspend.
> >>
> >>
> >> On Tue, Feb 7, 2023 at 1:10 PM Andrew Poelstra via bitcoin-dev <
> >> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>
> >>>
> >>> Some people highlighted some minor problems with my last email:
> >>>
> >>> On Tue, Feb 07, 2023 at 01:46:22PM +0000, Andrew Poelstra via
> bitcoin-dev
> >>> wrote:
> >>> >
> >>> > <snip>
> >>> >
> >>> > [1] https://bitcoin.sipa.be/miniscript/
> >>> > [2] In Taproot, if you want to prevent signatures migrating to
> another
> >>> > branch or within a branch, you can use the CODESEPARATOR opcode
> >>> > which was redisegned in Taproot for exactly this purpose... we
> >>> > really did about witness malleation in its design!
> >>>
> >>> In Taproot the tapleaf hash is always covered by the signature (though
> >>> not in some ANYONECANPAY proposals) so you can never migrate signatures
> >>> between tapbranches.
> >>>
> >>> I had thought this was the case, but then I re-confused myself by
> >>> reading BIP 341 .... which has much of the sighash specified, but not
> >>> all of it! The tapleaf hash is added in BIP 342.
> >>>
> >>> >
> >>> > If you want to prevent signatures from moving around *within* a
> >>> > branch,
> >>> >
> >>>
> >>> And this sentence I just meant to delete :)
> >>>
> >>>
> >>> --
> >>> Andrew Poelstra
> >>> Director of Research, Blockstream
> >>> Email: apoelstra at wpsoftware.net
> >>> Web: https://www.wpsoftware.net/andrew
> >>>
> >>> The sun is always shining in space
> >>> -Justin Lewis-Webster
> >>>
> >>> _______________________________________________
> >>> bitcoin-dev mailing list
> >>> bitcoin-dev at lists.linuxfoundation.org
> >>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >>>
> >>
> >>
>
> Is this something that should be fixed in bip118 signatures then?
>
> Cheers,
> aj
> --
> Sent from my phone.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230211/40833a03/attachment.html>

From aj at erisian.com.au  Sun Feb 12 06:47:31 2023
From: aj at erisian.com.au (Anthony Towns)
Date: Sun, 12 Feb 2023 16:47:31 +1000
Subject: [bitcoin-dev] Unenforceable fee obligations in multiparty
 protocols with Taproot inputs
In-Reply-To: <CAMZUoKm3OJ4DVCnpGk+CfJGnMMnuJqsqNMr-sJh53Rx99wj9CA@mail.gmail.com>
References: <CAAQdECCH=YOcu4g6Ku1_G4CnRg6rsaFPFPwbABx9aZin9A8+2A@mail.gmail.com>
 <Y+JWLsc80gxL4kpG@camus> <Y+KUAlsPc8ohPecb@camus>
 <CAMZUoK=u2114uv0Uc0u_RVMBv-cq-gJiNxiyOk_T_xxTYO0Ghw@mail.gmail.com>
 <VWZ9Dc2gIe0Y02yY3qSbjQTEPqwCm6YAtRzfNrIANBXCEJzr73SdxZT4LwBKDyriDfmDZyTlkKWtoZmVIUbYqqZUAeTMDLHUNFCBwR6hitQ=@protonmail.com>
 <CAMZUoKkGCEZ+8zW_8WfE4=q2x+gcC4vR06gxTW3XwgpH5WGXSw@mail.gmail.com>
 <6C1009F7-A90A-4B7D-8ED3-C0E9399873B6@erisian.com.au>
 <CAMZUoKm3OJ4DVCnpGk+CfJGnMMnuJqsqNMr-sJh53Rx99wj9CA@mail.gmail.com>
Message-ID: <Y+iLg8m8STaud+ep@erisian.com.au>

On Sat, Feb 11, 2023 at 09:40:38AM -0500, Russell O'Connor via bitcoin-dev wrote:
> Yes.  If you would otherwise sign the tapleaf, then I would recommend also
> signing the entire tapbranch.

Opened https://github.com/bitcoin-inquisition/bitcoin/issues/19 for
this.

(I think it's better to call it the path to the leaf, as "tapbranch"
seems more to refer to each splitting step in the tree)

Cheers,
aj

From aymeric at peersm.com  Sun Feb 12 16:23:59 2023
From: aymeric at peersm.com (Aymeric Vitte)
Date: Sun, 12 Feb 2023 17:23:59 +0100
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <CAMZUoKnrs-uxnTqpa96B4H86=gAtafowDi0D5HdnExvBWqTqPQ@mail.gmail.com>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>
 <57f780b1-f262-9394-036c-70084320e9cf@peersm.com>
 <CACrqygCNf3Gv8+VjhyqS4GTb3Epo8qXEKGtQB6sqyR6ib44-fA@mail.gmail.com>
 <CABE6yHtM2Dqc63_eURSr7dMirJti5sYnqvHj7vQ_Ab9FC_d04g@mail.gmail.com>
 <3d00aacb-585d-f875-784d-34352860d725@peersm.com>
 <CACrqygB_FbsRGWYPSUEFTnP15y94Hmo4JtAuv6bH1D3YtbAw9Q@mail.gmail.com>
 <b292d887-cbd5-165c-de01-793df2b5e8f3@peersm.com>
 <CACrqygAv842ucN7PLYMENXFiSwAZJy2Y+FziJXrWjyCcOXmL3g@mail.gmail.com>
 <230265ee-c3f8-dff3-9192-f0c8dc4d913c@peersm.com>
 <CAMZUoKkAdQ9TSMm4vPJOrThu_h6VbqwPhOQQR7-Yr+WZ0DMBYw@mail.gmail.com>
 <76718304-A8E3-46E6-B2F7-DE86831F15DF@petertodd.org>
 <CAMZUoKnrs-uxnTqpa96B4H86=gAtafowDi0D5HdnExvBWqTqPQ@mail.gmail.com>
Message-ID: <f5c0abc5-e52f-6d41-c050-bb3ecbeb3986@peersm.com>

https://github.com/bitcoin/bitcoin/issues/27043#issuecomment-1427069403

"What is the process to have someone do the PR for this? Or I do it and
most likely it will be a very shxtty one since I am not a C/C++ expert,
then wasting the time of everybody

It's urgently required, I did consider OP_RETURN as a dart in the past
but changed my mind, it's adapted to the current evolutions, not
flooding bitcoin with 2 txs while only 1 is needed

If not the best 1 tx solution is super simple: store in addresses, and
super bad at the end because burning bitcoins, while still not expensive
if you don't need to store big things"


Le 05/02/2023 ? 19:12, Russell O'Connor via bitcoin-dev a ?crit :
>
>
> On Sat., Feb. 4, 2023, 21:01 Peter Todd, <pete at petertodd.org
> <mailto:pete at petertodd.org>> wrote:
>
>
>
>     On February 5, 2023 1:11:35 AM GMT+01:00, Russell O'Connor via
>     bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>     >Since bytes in the witness are cheaper than bytes in the script
>     pubkey,
>     >there is a crossover point in data size where it will simply be
>     cheaper to
>     >use witness data.  Where that crossover point is depends on the finer
>     >details of the overhead of the two methods, but you could make some
>     >reasonable assumptions.  Such a calculation could form the basis of a
>     >reasonable OP_RETURN proposal.  I don't know if it would be
>     persuasive, but
>     >it would at least be coherent.
>
>     I don't think it's worth the technical complexity trying to
>     carefully argue a specific limit. Let users decide for themselves
>     how they want to use OpReturn.
>
>
> Even better.
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Sophia-Antipolis, France
CV: https://www.peersm.com/CVAV.pdf
LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26
GitHub : https://www.github.com/Ayms
A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7
A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com
Peersm : http://www.peersm.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230212/715d4cbc/attachment.html>

From alicexbt at protonmail.com  Mon Feb 13 12:34:30 2023
From: alicexbt at protonmail.com (alicexbt)
Date: Mon, 13 Feb 2023 12:34:30 +0000
Subject: [bitcoin-dev] Testing censorship resistance of bitcoin p2p network
Message-ID: <TG0yVn41L6VFOHFRYqd3iGz7mxHWtjFdaBrz8mlP6Uk8bmog_isDbtq_2QyvdUs9_Q-jStmx7V7l5rAesXDfHlK9Ehft7SkK5EWQ_3mg-eQ=@protonmail.com>

Hi Bitcoin Developers,

There is a famous quote attributed to Evelyn Beatrice Hall in her biography of Voltaire: "I disapprove of what you say, but I will defend to the death your right to say it." I'm curious to know how many Bitcoin developers share this sentiment.

Recently there was a lot of enthusiasm on social media to run bitcoin core with a [patch][0] that would reject some transactions in mempool. Bitcoin Knots already has an option to reject transactions that reuse addresses. What if such practices become common and some projects that provide easy to use node software start censoring transactions? How would government agencies take advantage of this whole drama?

I understand it is difficult to censor different type of transaction because there will be some nodes relaying them and miners including in blocks. It is still important to discuss this and different ways to test censorship resistance.

- Peter Todd had written a [blog post][1] in which counting number of INVs (step 5,6,7 and 8) helps in testing if your transactions are getting relayed by the connected peers. 
- I had tried broadcasting transaction to specific nodes using [libbtc][2]. Based on my understanding it uses GETDATA to confirm your transaction was seen on other nodes after broadcasting.

What would an ideal tool for testing censorship resistance look like?

- Allows user to construct different types of transactions that might be considered "bad" by some people. Example: OFAC address in output, Inscription, OP_RETURN, Address reuse etc.
- Option to broadcast transaction to specific nodes
- Verify if the transaction was relayed successfully or rejected
- Ban such peers using [setban][3] RPC as it would increase the probability of tx getting propagated to miners

There was even some discussion about an [external mempool][4] that could be used for non-standard transactions. It could also help in avoiding censorship in some cases. I welcome your thoughts and feedback on this topic.

[0]: https://gist.github.com/luke-jr/4c022839584020444915c84bdd825831
[1]: https://petertodd.org/2022/bitcoin-core-nodes-running-fullrbf
[2]: https://twitter.com/1440000bytes/status/1574225052240777216
[3]: https://bitcoincore.org/en/doc/24.0.0/rpc/network/setban/
[4]: https://twitter.com/jamesob/status/1623827708168863747

/dev/fd0
floppy disc guy

Sent with Proton Mail secure email.

From james.obeirne at gmail.com  Mon Feb 13 21:09:29 2023
From: james.obeirne at gmail.com (James O'Beirne)
Date: Mon, 13 Feb 2023 16:09:29 -0500
Subject: [bitcoin-dev] BIP for OP_VAULT
Message-ID: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>

Since the last related correspondence on this list [0], a number of
improvements have been made to the OP_VAULT draft [1]:

* There is no longer a hard dependence on package relay/ephemeral
  anchors for fee management. When using "authorized recovery," all
  vault-related transactions can be bundled with unrelated inputs and
  outputs, facilitating fee management that is self contained to the
  transaction. Consequently, the contents of this proposal are in theory
  usable today.

* Specific output locations are no longer hardcoded in any of the
  transaction validation algorithms. This means that the proposal is now
  compatible with future changes like SIGHASH_GROUP, and
  transaction shapes for vault operations are more flexible.

---

I've written a BIP that fully describes the proposal here:


https://github.com/jamesob/bips/blob/jamesob-23-02-opvault/bip-vaults.mediawiki

The corresponding PR is here:

  https://github.com/bitcoin/bips/pull/1421

My next steps will be to try for a merge to the inquisition repo.

Thanks to everyone who has participated so far, but especially to AJ and
Greg for all the advice.

James

[0]:
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html
[1]: https://github.com/bitcoin/bitcoin/pull/26857
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230213/d2e99148/attachment.html>

From antoine.riard at gmail.com  Wed Feb 15 03:33:24 2023
From: antoine.riard at gmail.com (Antoine Riard)
Date: Wed, 15 Feb 2023 03:33:24 +0000
Subject: [bitcoin-dev] Unenforceable fee obligations in multiparty
 protocols with Taproot inputs
In-Reply-To: <CAAQdECCDfmAmxvSWfTsiTz_0TecpA8zoryZzHT==mXDU0p-xoA@mail.gmail.com>
References: <CAAQdECCH=YOcu4g6Ku1_G4CnRg6rsaFPFPwbABx9aZin9A8+2A@mail.gmail.com>
 <CALZpt+E2XKmqAELcedN8-5JkCOwmEH-CN8nwmpwW74xGUZPtbA@mail.gmail.com>
 <CAAQdECCDfmAmxvSWfTsiTz_0TecpA8zoryZzHT==mXDU0p-xoA@mail.gmail.com>
Message-ID: <CALZpt+HYinkSWvy56ky4KJrmLGaN1OxBy+6MOX6VkRgQu-7Y6g@mail.gmail.com>

> Apologies for not citing, I think I must have seen that before but
> only remembered the pinning variants, and so did not recall it at the
> time that I wrote this up, which I did rather hastily.

> However, I do think the adversary model should be broadened, as there
> is a potential positive externality to a party which simply wishes to
> get some witness data confirmed in a block while paying less than the
> market rate, without needing to assume time sensitive contracts in the
> threat model.


Please no apologies - Message matters more than the messenger in

open-source. Yes, on the adversary model I would like to note there is a

potential negative externality in the context of time-sensitive contract,
e.g

for a DLC with short-term maturity you can delay confirmation of the funding

transaction in function of the event outcome progression (e.g a basketball
quarters),

and if the outcome turns in your defavor, you just double-spend a funding
input.


> What I had in mind was the estimated witness size messages in the dual
> funding proposal and felt they would create a false sense of
> validation, specifically in the context of an adversary interested in
> having their ordinal inscriptions being paid for by someone else by
> subverting the a priori agreed upon feerate. From my point of view
> this is primarily an argument for RBF by default (ideally full RBF, as
> rule 3 of BIP 125 imposes difficult constraints on multiparty
> transaction construction) in such protocols.


We could have miniscript embedded in the backend of a Lightning

implementation, to reject any malleable witness (maybe with some tolerance
bounds ?),

to restrain a counterparty downgrading a posteriori its feerate
contribution.

Full rbf effectively would prevent timevalue DoS inflicted to the
most-utxo-value

contributor in dual-funding, however in the present flow, I don't know if it

changes something, the witness downgrading counterparty benefits from

a feerate discount, not lack of confirmation.


> Yes, that doesn't make things incentive compatible but allows the
> potential victims to have clearer bounds on the potential positive
> payoff to the adversary. I think that's mainly useful in conjunction
> constraining the order of signature submission, going from smallest to
> largest input seems intuitively compelling but it seems to me like
> ordering by feerate of creating transaction or perhaps some
> combination of the two might provide a stronger deterrent.


I think some combination of the two can makes sense, as if the feerate

is what you paid, the input value is your "economically subjective"
liquidity

risk, and as such you might pay a better signature submission place for

a feerate contribution increase. Quite sophisticated for the basic
dual-funding flow.


> Either way the main takeaway in my opinion is not that this is a
> serious attack, as it's hard to exploit in theory and as far as I know
> none of the currently deployed protocols are in any way vulnerable:

> 1. dual funding supports RBF and quite amenable to reputation based
mitigations
> 2. in JoinMarket the taker can protect themselves
> 3. centralized coinjoins, despite misleading claims to the contrary by
> both vendors, currently strongly rely on a trusted server for many
> other aspects of the protocol and all three protocols are not
> currently exploitable as described (the attacker can't broadcast the
> transaction with a witness that would otherwise be rejected by the
> server)

> ... but rather that (full) RBF is required for incentive compatible
> multiparty transactions (or the closest approximation of incentive
> compatibility possible barring future soft forks).


Yep yep, all types of DoS are less concerning than "loss of funds"

severity pinning attacks, and doesn't sounds to affect currently

deployed protocols. Still concerned all those DoS once accumulated

might be a "practical" show-stopper, like we have with channel jamming.



Le ven. 10 f?vr. 2023 ? 19:35, Yuval Kogman <nothingmuch at woobling.org> a
?crit :

> On Wed, 8 Feb 2023 at 02:56, Antoine Riard <antoine.riard at gmail.com>
> wrote:
> > From what I understand, there are many inputs for the coinjoin
> transaction, the latest signer provides an inflated witness downgrading the
> multi-party transaction feerate.
>
> Yep!
>
> >  It doesn't sound to me a fee siphoning as occurring with loose
> malleability [0], rather another case of transaction-relay jamming where
> the adversary's goal is to slow down the confirmation of the transaction to
> waste everyone timevalue.
> >
> > I think the issue has already been mentioned to advocate updating Core's
> mempool acceptance policy, and allows wtxid-replacement [1]. There is also
> a description available here [2].
>
> Yep, the mechanism is basically the same as witness malleability based
> jamming.
>
> Apologies for not citing, I think I must have seen that before but
> only remembered the pinning variants, and so did not recall it at the
> time that I wrote this up, which I did rather hastily.
>
> However, I do think the adversary model should be broadened, as there
> is a potential positive externality to a party which simply wishes to
> get some witness data confirmed in a block while paying less than the
> market rate, without needing to assume time sensitive contracts in the
> threat model.
>
> What I had in mind was the estimated witness size messages in the dual
> funding proposal and felt they would create a false sense of
> validation, specifically in the context of an adversary interested in
> having their ordinal inscriptions being paid for by someone else by
> subverting the a priori agreed upon feerate. From my point of view
> this is primarily an argument for RBF by default (ideally full RBF, as
> rule 3 of BIP 125 imposes difficult constraints on multiparty
> transaction construction) in such protocols.
>
> > I don't think increasing adversary costliness is that efficient as there
> is a scaling effect (e.g the feerate of the previous transaction can be
> used to feed N outputs for N dissociated attack contexts).
>
> Yes, that doesn't make things incentive compatible but allows the
> potential victims to have clearer bounds on the potential positive
> payoff to the adversary. I think that's mainly useful in conjunction
> constraining the order of signature submission, going from smallest to
> largest input seems intuitively compelling but it seems to me like
> ordering by feerate of creating transaction or perhaps some
> combination of the two might provide a stronger deterrent.
>
> Either way the main takeaway in my opinion is not that this is a
> serious attack, as it's hard to exploit in theory and as far as I know
> none of the currently deployed protocols are in any way vulnerable:
>
> 1. dual funding supports RBF and quite amenable to reputation based
> mitigations
> 2. in JoinMarket the taker can protect themselves
> 3. centralized coinjoins, despite misleading claims to the contrary by
> both vendors, currently strongly rely on a trusted server for many
> other aspects of the protocol and all three protocols are not
> currently exploitable as described (the attacker can't broadcast the
> transaction with a witness that would otherwise be rejected by the
> server)
>
> ... but rather that (full) RBF is required for incentive compatible
> multiparty transactions (or the closest approximation of incentive
> compatibility possible barring future soft forks).
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230215/d24c50a6/attachment-0001.html>

From xembook81 at gmail.com  Wed Feb 15 14:08:22 2023
From: xembook81 at gmail.com (XEM Book)
Date: Wed, 15 Feb 2023 23:08:22 +0900
Subject: [bitcoin-dev] About the Japanese list defined in BIP39
Message-ID: <CAJ9FwtAZMYjVnDj2awbYgJ1JEuQ43rwVq3jWWc5GUjeKoW7nqA@mail.gmail.com>

Hi , I am XEMBook.
nice to meet you.

The Japanese language list currently defined in BIP39 is not consistent or
uniform, and includes insults to a person's appearance.

??? ???? ??? ???? ?????
??? ???? ??? ??? ??? ?????

https://github.com/bitcoin/bips/blob/master/bip-0039/japanese.txt

Here I would like to make a suggestion about a new Japanese word list.

https://github.com/xembook/bips/blob/master/bip-0039/japanese_seasonal.txt

These beautiful words are from the Saijiki.
The Saijiki is said to have originated in the "Nihon Saijiki" (Japanese
chronicle of the seasons) by Ekiken Kaibara in 1688 (Jokyo 5), published by
Kyoto Nisshindo.
This is a word list with over 300 years of history on word choice.

Please consider including this word list Japanese Seasonal in BIP39.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230215/b61e8eb8/attachment.html>

From aj at erisian.com.au  Thu Feb 16 00:34:26 2023
From: aj at erisian.com.au (Anthony Towns)
Date: Thu, 16 Feb 2023 10:34:26 +1000
Subject: [bitcoin-dev]  bitcoin-inquistion 24.0
Message-ID: <Y+16Ei04n5LVA+N8@erisian.com.au>

Hi *,
 
Bitcoin Inquisition 24.0 is tagged with guix builds available:
 
  https://github.com/bitcoin-inquisition/bitcoin/releases/tag/inq-v24.0

It includes support for BIP 118 (ANYPREVOUT) and BIP 119
(CHECKTEMPLATEVERIFY) on regtest and signet.

The main change since 23.0 is simply the rebase on top of Bitcoin Core
24.0, though the patchsets for both BIPs have been tightened up a little
as well.

Additional soft forks or relay policy changes may be proposed by filing
a pull request, and work in progress is tracked on a project board:

  https://github.com/bitcoin-inquisition/bitcoin/pulls?q=is%3Apr
  https://github.com/orgs/bitcoin-inquisition/projects/2/views/1

For more background, the 23.0 announcement may be worth reading:

  https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-December/021275.html

Cheers,
aj

From roconnor at blockstream.com  Thu Feb 16 02:16:02 2023
From: roconnor at blockstream.com (Russell O'Connor)
Date: Wed, 15 Feb 2023 21:16:02 -0500
Subject: [bitcoin-dev] Codex32
Message-ID: <CAMZUoKmiwXW50F2onqNUZO8HXQa4+Z=z3s3WyN7-rAMV=KiSgw@mail.gmail.com>

I've been asked by Dr. Curr and Professor Snead to forward this message to
this mailing list, as it may be of general interest to Bitcoin users.

Dear Colleague:

In 1967, during excavation for the construction of a new shopping center in
Monroeville, Pennsylvania, workers uncovered a vault containing a cache of
ancient scrolls[1].  Most were severely damaged, but those that could be
recovered confirmed the existence of a secret society long suspected to
have
been active in the region around the year 200 BC.

Based on a translation of these documents, we now know that the society,
the
Cult of the Bound Variable, was devoted to the careful study of
computation,
over two millennia before the invention of the digital computer.

While the Monroeville scrolls make reference to computing machines made of
sandstone, most researchers believed this to be a poetic metaphor and that
the
"computers" were in fact the initiates themselves, carrying out the
unimaginably tedious steps of their computations with reed pens on
parchment.

Within the vault, a collection of sandstone wheels marked in a language
consisting of 32 glyphs was found. After 15 years of study, we have
successfully
completed the translation of what is known as "Codex32," a document that
describes the functions of the wheels. It was discovered that the wheels
operate
a system of cryptographic computations that was used by cult members to
safeguard their most valuable secrets.

The Codex32 system allows secrets to be carved into multiple tablets and
scattered to the far corners of the earth. When a sufficient number of
tablets are
brought together the stone wheels are manipulated in a manner to recover the
secrets. This finding may be of particular interest to the Bitcoin
community.

Below we provide a summary of the cult's secret sharing system, which is
graciously hosted at
<
https://github.com/apoelstra/bips/blob/2023-02--volvelles/bip-0000.mediawiki
>.
We are requesting a record assignment in the Bibliography of Immemorial
Philosophy (BIP) repository.

Thank you for your consideration.

Dr. Leon O. Curr and Professor Pearlwort Snead
Department of Archaeocryptography
Harry Q. Bovik Institute for the Advancement

[1] http://www.boundvariable.org/task.shtml

-----BEGIN BIP-----

<pre>
  BIP: ????
  Layer: Applications
  Title: codex32
  Author: Leon Olsson Curr and Pearlwort Sneed <pearlwort at wpsoftware.net>
  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????
  Status: Draft
  Type: ????
  Created: 2023-02-13
  License: BSD-3-Clause
  Post-History: FIXME
</pre>

==Introduction==

===Abstract===

This document describes a standard for backing up and restoring the master
seed of a
[https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP-0032]
hierarchical deterministic wallet, using Shamir's secret sharing.
It includes an encoding format, a BCH error-correcting checksum, and
algorithms for share generation and secret recovery.
Secret data can be split into up to 31 shares.
A minimum threshold of shares, which can be between 1 and 9, is needed to
recover the secret, whereas without sufficient shares, no information about
the secret is recoverable.

===Copyright===

This document is licensed under the 3-clause BSD license.

===Motivation===

BIP-0032 master seed data is the source entropy used to derive all private
keys in an HD wallet.
Safely storing this secret data is the hardest and most important part of
self-custody.
However, there is a tension between security, which demands limiting the
number of backups, and resilience, which demands widely replicated backups.
Encrypting the seed does not change this fundamental tradeoff, since it
leaves essentially the same problem of how to back up the encryption key(s).

To allow users freedom to make this tradeoff, we use Shamir's secret
sharing, which guarantees that any number of shares less than the threshold
leaks no information about the secret.
This approach allows increasing safety by widely distributing the generated
shares, while also providing security against the compromise of one or more
shares (as long as fewer than the threshold have been compromised).

[https://github.com/satoshilabs/slips/blob/master/slip-0039.md SLIP-0039]
has essentially the same motivations as this standard.
However, unlike SLIP-0039, this standard also aims to be simple enough for
hand computation.
Users who demand a higher level of security for particular secrets, or have
a general distrust in digital electronic devices, have the option of using
hand computation to backup and restore secret data in an interoperable
manner.
Note that hand computation is optional, the particular details of hand
computation are outside the scope of this standard, and implementers do not
need to be concerned with this possibility.

[https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki BIP-0039]
serves the same purpose as this standard: encoding master seeds for storage
by users.
However, BIP-0039 has no error-correcting ability, cannot sensibly be
extended to support secret sharing, has no support for versioning or other
metadata, and has many technical design decisions that make implementation
and interoperability difficult (for example, the use of SHA-512 to derive
seeds, or the use of 11-bit words).

==Specification==

===codex32===

A codex32 string is similar to a Bech32 string defined in [
https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP-0173].
It reuses the base32 character set from BIP-0173, and consists of:

* A human-readable part, which is the string "ms" (or "MS").
* A separator, which is always "1".
* A data part which is in turn subdivided into:
** A threshold parameter, which MUST be a single digit between "2" and "9",
or the digit "0".
*** If the threshold parameter is "0" then the share index, defined below,
MUST have a value of "s" (or "S").
** An identifier consisting of 4 Bech32 characters.
** A share index, which is any Bech32 character. Note that a share index
value of "s" (or "S") is special and denotes the unshared secret (see
section "Unshared Secret").
** A payload which is a sequence of up to 74 Bech32 characters. (However,
see '''Long codex32 Strings''' below for an exception to this limit.)
** A checksum which consists of 13 Bech32 characters as described below.

As with Bech32 strings, a codex32 string MUST be entirely uppercase or
entirely lowercase.
The lowercase form is used when determining a character's value for
checksum purposes.
For presentation, lowercase is usually preferable, but uppercase SHOULD be
used for handwritten codex32 strings.

===Checksum===

The last thirteen characters of the data part form a checksum and contain
no information.
Valid strings MUST pass the criteria for validity specified by the Python3
code snippet below.
The function <code>ms32_verify_checksum</code> must return true when its
argument is the data part as a list of integers representing the characters
converted using the bech32 character table from BIP-0173.

To construct a valid checksum given the data-part characters (excluding the
checksum), the <code>ms32_create_checksum</code> function can be used.

<source lang="python">
MS32_CONST = 0x10ce0795c2fd1e62a

def ms32_polymod(values):
    GEN = [
        0x19dc500ce73fde210,
        0x1bfae00def77fe529,
        0x1fbd920fffe7bee52,
        0x1739640bdeee3fdad,
        0x07729a039cfc75f5a,
    ]
    residue = 0x23181b3
    for v in values:
        b = (residue >> 60)
        residue = (residue & 0x0fffffffffffffff) << 5 ^ v
        for i in range(5):
            residue ^= GEN[i] if ((b >> i) & 1) else 0
    return residue

def ms32_verify_checksum(data):
    if len(data) >= 96:                      # See Long codex32 Strings
        return ms32_verify_long_checksum(data)
    if len(data) <= 93:
        return ms32_polymod(data) == MS32_CONST
    return False

def ms32_create_checksum(data):
    if len(data) > 80:                       # See Long codex32 Strings
        return ms32_create_long_checksum(data)
    values = data
    polymod = ms32_polymod(values + [0] * 13) ^ MS32_CONST
    return [(polymod >> 5 * (12 - i)) & 31 for i in range(13)]
</source>

===Error Correction===

A codex32 string without a valid checksum MUST NOT be used.
The checksum is designed to be an error correcting code that can correct up
to 4 character substitutions, up to 8 unreadable characters (called
erasures), or up to 13 consecutive erasures.
Implementations SHOULD provide the user with a corrected valid codex32
string if possible.
However, implementations SHOULD NOT automatically proceed with a corrected
codex32 string without user confirmation of the corrected string, either by
prompting the user, or returning a corrected string in an error message and
allowing the user to repeat their action.
We do not specify how an implementation should implement error correction.
However, we recommend that:

* Implementations make suggestions to substitute non-bech32 characters with
bech32 characters in some situations, such as replacing "B" with "8", "O"
with "0", "I" with "l", etc.
* Implementations interpret "?" as an erasure.
* Implementations optionally interpret other non-bech32 characters, or
characters with incorrect case, as erasures.
* If a string with 8 or fewer erasures can have those erasures filled in to
make a valid codex32 string, then the implementation suggests such a string
as a correction.
* If a string consisting of valid Bech32 characters in the proper case can
be made valid by substituting 4 or fewer characters, then the
implementation suggests such a string as a correction.

===Unshared Secret===

When the share index of a valid codex32 string (converted to lowercase) is
the letter "s", we call the string a codex32 secret.
The subsequent data characters in a codex32 secret, excluding the final
checksum of 13 characters, is a direct encoding of a BIP-0032 HD master
seed.

The master seed is decoded by converting the data to bytes:

* Translate the characters to 5 bits values using the bech32 character
table from BIP-0173, most significant bit first.
* Re-arrange those bits into groups of 8 bits. Any incomplete group at the
end MUST be 4 bits or less, and is discarded.

Note that unlike the decoding process in BIP-0173, we do NOT require that
the incomplete group be all zeros.

For an unshared secret, the threshold parameter (the first character of the
data part) is ignored (beyond the fact it must be a digit for the codex32
string to be valid).
We recommend using the digit "0" for the threshold parameter in this case.
The 4 character identifier also has no effect beyond aiding users in
distinguishing between multiple different master seeds in cases where they
have more than one.

===Recovering Master Seed===

When the share index of a valid codex32 string (converted to lowercase) is
not the letter "s", we call the string an codex32 share.
The first character of the data part indicates the threshold of the share,
and it is required to be a non-"0" digit.

In order to recover a master seed, one needs a set of valid codex32 shares
such that:

* All shares have the same threshold value, the same identifier, and the
same length.
* All of the share index values are distinct.
* The number of codex32 shares is exactly equal to the (common) threshold
value.

If all the above conditions are satisfied, the <code>ms32_recover</code>
function will return a codex32 secret when its argument is the list of
codex32 shares with each share represented as a list of integers
representing the characters converted using the bech32 character table from
BIP-0173.

<source lang="python">
bech32_inv = [
    0, 1, 20, 24, 10, 8, 12, 29, 5, 11, 4, 9, 6, 28, 26, 31,
    22, 18, 17, 23, 2, 25, 16, 19, 3, 21, 14, 30, 13, 7, 27, 15,
]

def bech32_mul(a, b):
    res = 0
    for i in range(5):
        res ^= a if ((b >> i) & 1) else 0
        a *= 2
        a ^= 41 if (32 <= a) else 0
    return res

def bech32_lagrange(l, x):
    n = 1
    c = []
    for i in l:
        n = bech32_mul(n, i ^ x)
        m = 1
        for j in l:
            m = bech32_mul(m, (x if i == j else i) ^ j)
        c.append(m)
    return [bech32_mul(n, bech32_inv[i]) for i in c]

def ms32_interpolate(l, x):
    w = bech32_lagrange([s[5] for s in l], x)
    res = []
    for i in range(len(l[0])):
        n = 0
        for j in range(len(l)):
            n ^= bech32_mul(w[j], l[j][i])
        res.append(n)
    return res

def ms32_recover(l):
    return ms32_interpolate(l, 16)
</source>

===Generating Shares===

If we already have ''t'' valid codex32 strings such that:

* All strings have the same threshold value ''t'', the same identifier, and
the same length
* All of the share index values are distinct

Then we can derive additional shares with the <code>ms32_interpolate</code>
function by passing it a list of exactly ''t'' of these codex32 strings,
together with a fresh share index distinct from all of the existing share
indexes.
The newly derived share will have the provided share index.

Once a user has generated ''n'' codex32 shares, they may discard the
codex32 secret (if it exists).
The ''n'' shares form a ''t'' of ''n'' Shamir's secret sharing scheme of a
codex32 secret.

There are two ways to create an initial set of ''t'' valid codex32 strings,
depending on whether the user already has an existing master seed to split.

====For an existing master seed====

Before generating shares for an existing master seed, it first must be
converted into a codex32 secret, as described above.
The conversion process consists of:

* Choosing a threshold value ''t'' between 2 and 9, inclusive
* Choosing a 4 bech32 character identifier
** We do not define how to choose the identifier, beyond noting that it
SHOULD be distinct for every master seed the user may need to disambiguate.
* Setting the share index to "s"
* Setting the payload to a Bech32 encoding of the master seed, padded with
arbitrary bits
* Generating a valid checksum in accordance with the Checksum section

Along with the codex32 secret, the user must generate ''t''-1 other codex32
shares, each with the same threshold value, the same identifier, and a
distinct share index.
The set of share indexes may be chosen arbitrarily.
The payload of each of these codex32 shares is chosen uniformly at random
such that it has the same length as the payload of the codex32 secret.
For each share, a valid checksum must be generated in accordance with the
Checksum section.

The codex32 secret and the ''t''-1 codex32 shares form a set of ''t'' valid
codex32 strings from which additional shares can be derived as described
above.

====For a fresh master seed====

In the case that the user wishes to generate a fresh master seed, the user
chooses a threshold value ''t'' and an identifier, then generates ''t''
random codex32 shares, using the generation procedure from the previous
section.
As before, each share must have the same threshold value ''t'', the same
identifier, and a distinct share index.

With this set of ''t'' codex32 shares, new shares can be derived as
discussed above. This process generates a fresh master seed, whose value
can be retrieved by running the recovery process on any ''t'' of these
shares.

===Long codex32 Strings===

The 13 character checksum design only supports up to 80 data characters.
Excluding the threshold, identifier and index characters, this limits the
payload to 74 characters or 46 bytes.
While this is enough to support the 32-byte advised size of BIP-0032 master
seeds, BIP-0032 allows seeds to be up to 64 bytes in size.
We define a long codex32 string format to support these longer seeds by
defining an alternative checksum.

<source lang="python">
MS32_LONG_CONST = 0x43381e570bf4798ab26

def ms32_long_polymod(values):
    GEN = [
        0x3d59d273535ea62d897,
        0x7a9becb6361c6c51507,
        0x543f9b7e6c38d8a2a0e,
        0x0c577eaeccf1990d13c,
        0x1887f74f8dc71b10651,
    ]
    residue = 0x23181b3
    for v in values:
        b = (residue >> 70)
        residue = (residue & 0x3fffffffffffffffff) << 5 ^ v
        for i in range(5):
            residue ^= GEN[i] if ((b >> i) & 1) else 0
    return residue

def ms32_verify_long_checksum(data):
    return ms32_long_polymod(data) == MS32_LONG_CONST

def ms32_create_long_checksum(data):
    values = data
    polymod = ms32_long_polymod(values + [0] * 15) ^ MS32_LONG_CONST
    return [(polymod >> 5 * (14 - i)) & 31 for i in range(15)]
</source>

A long codex32 string follows the same specification as a regular codex32
string with the following changes.

* The payload is a sequence of between 75 and 103 Bech32 characters.
* The checksum consists of 15 Bech32 characters as defined above.

A codex32 string with a data part of 94 or 95 characters is never legal as
a regular codex32 string is limited to 93 data characters and a long
codex32 string is at least 96 characters.

Generation of long shares and recovery of the master seed from long shares
proceeds in exactly the same way as for regular shares with the
<code>ms32_interpolate</code> function.

The long checksum is designed to be an error correcting code that can
correct up to 4 character substitutions, up to 8 unreadable characters
(called erasures), or up to 15 consecutive erasures.
As with regular checksums we do not specify how an implementation should
implement error correction, and all our recommendations for error
correction of regular codex32 strings also apply to long codex32 strings.

==Rationale==

This scheme is based on the observation that the Lagrange interpolation of
valid codewords in a BCH code will always be a valid codeword.
This means that derived shares will always have valid checksum, and a
sufficient threshold of shares with valid checksums will derive a secret
with a valid checksum.

The header system is also compatible with Lagrange interpolation, meaning
all derived shares will have the same identifier and will have the
appropriate share index.
This fact allows the header data to be covered by the checksum.

The checksum size and identifier size have been chosen so that the encoding
of 128-bit seeds and shares fit within 48 characters.
This is a standard size for many common seed storage formats, which has
been popularized by the 12 four-letter word format of the BIP-0039 mnemonic.

The 13 character checksum is adequate to correct 4 errors in up to 93
characters (80 characters of data and 13 characters of the checksum). This
is somewhat better quality than the checksum used in SLIP-0039.

For 256-bit seeds and shares our strings are 74 characters, which fits into
the 96 character format of the 24 four-letter word format of the BIP-0039
mnemonic, with plenty of room to spare.

A longer checksum is needed to support up to 512-bit seeds, the longest
seed length specified in BIP-0032, as the 13 character checksum isn't
adequate for more than 80 data characters.
While we could use the 15 character checksum for both cases, we prefer to
keep the strings as short as possible for the more common cases of 128-bit
and 256-bit master seeds.
We only guarantee to correct 4 characters no matter how long the string is.
Longer strings mean more chances for transcription errors, so shorter
strings are better.

The longest data part using the regular 13 character checksum is 93
characters and corresponds to a 400-bit secret.
At this length, the prefix <code>MS1</code> is not covered by the checksum.
This is acceptable because the checksum scheme itself requires you to know
that the <code>MS1</code> prefix is being used in the first place.
If the prefix is damaged and a user is guessing that the data might be
using this scheme, then the user can enter the available data explicitly
using the suspected <code>MS1</code> prefix.

==Backwards Compatibility==

codex32 is an alternative to BIP-0039 and SLIP-0039.
It is technically possible to derive the BIP32 master seed from seed words
encoded in one of these schemes, and then to encode this seed in codex32.
For BIP-0039 this process is irreversible, since it involves hashing the
original words.
Furthermore, the resulting seed will be 512 bits long, which may be too
large to be safely and conveniently handled.

SLIP-0039 seed words can be reversibly converted to master seeds, so it is
possible to interconvert between SLIP-0039 and codex32.
However, SLIP-0039 '''shares''' cannot be converted to codex32 shares
because the two schemes use a different underlying field.

The authors of this BIP do not recommend interconversion.
Instead, users who wish to switch to codex32 should generate a fresh seed
and sweep their coins.

==Reference Implementation==

* [https://secretcodex32.com/docs/2023-02-14--bw.ps Reference PostScript
Implementation]
* FIXME add Python implementation
* FIXME add Rust implementation

==Test Vectors==

===Test vector 1===

This example shows the codex32 format, when used without splitting the
secret into any shares.
The data part contains 26 Bech32 characters, which corresponds to 130 bits.
We truncate the last two bits in order to obtain a 128-bit master seed.

codex32 secret (Bech32):
<code>ms10testsxxxxxxxxxxxxxxxxxxxxxxxxxx4nzvca9cmczlw</code>

Master secret (hex): <code>318c6318c6318c6318c6318c6318c631</code>

* human-readable part: <code>ms</code>
* separator: <code>1</code>
* k value: <code>0</code> (no secret splitting)
* identifier: <code>test</code>
* share index: <code>s</code> (the secret)
* data: <code>xxxxxxxxxxxxxxxxxxxxxxxxxx</code>
* checksum: <code>4nzvca9cmczlw</code>

===Test vector 2===

This example shows generating a new master seed using "random" codex32
shares, as well as deriving an additional codex32 share, using ''k''=2 and
an identifier of <code>NAME</code>.
Although codex32 strings are canonically all lowercase, it's also valid to
use all uppercase.

Share with index <code>A</code>:
<code>MS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM</code>

Share with index <code>C</code>:
<code>MS12NAMECACDEFGHJKLMNPQRSTUVWXYZ023FTR2GDZMPY6PN</code>

* Derived share with index <code>D</code>:
<code>MS12NAMEDLL4F8JLH4E5VDVULDLFXU2JHDNLSM97XVENRXEG</code>
* Secret share with index <code>S</code>:
<code>MS12NAMES6XQGUZTTXKEQNJSJZV4JV3NZ5K3KWGSPHUH6EVW</code>
* Master secret (hex): <code>d1808e096b35b209ca12132b264662a5</code>

Note that per BIP-0173, the lowercase form is used when determining a
character's value for checksum purposes.
In particular, given an all uppercase codex32 string, we still use
lowercase <code>ms</code> as the human-readable part during checksum
construction.

===Test vector 3===

This example shows splitting an existing 128-bit master seed into "random"
codex32 shares, using ''k''=3 and an identifier of <code>cash</code>.
We appended two zero bits in order to obtain 26 Bech32 characters (130 bits
of data) from the 128-bit master seed.

Master secret (hex): <code>ffeeddccbbaa99887766554433221100</code>

Secret share with index <code>s</code>:
<code>ms13cashsllhdmn9m42vcsamx24zrxgs3qqjzqud4m0d6nln</code>

Share with index <code>a</code>:
<code>ms13casha320zyxwvutsrqpnmlkjhgfedca2a8d0zehn8a0t</code>

Share with index <code>c</code>:
<code>ms13cashcacdefghjklmnpqrstuvwxyz023949xq35my48dr</code>

* Derived share with index <code>d</code>:
<code>ms13cashd0wsedstcdcts64cd7wvy4m90lm28w4ffupqs7rm</code>
* Derived share with index <code>e</code>:
<code>ms13casheekgpemxzshcrmqhaydlp6yhms3ws7320xyxsar9</code>
* Derived share with index <code>f</code>:
<code>ms13cashf8jh6sdrkpyrsp5ut94pj8ktehhw2hfvyrj48704</code>

Any three of the five shares among <code>acdef</code> can be used to
recover the secret.

Note that the choice to append two zero bits was arbitrary, and any of the
following four secret shares would have been valid choices.
However, each choice would have resulted in a different set of derived
shares.

* <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qqjzqud4m0d6nln</code>
* <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qpte35dvzkjpt0r</code>
* <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qzfatvdwq5692k6</code>
* <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qrsx6ydhed97jx2</code>

===Test vector 4===

This example shows converting a 256-bit secret into a codex32 secret,
without splitting the secret into any shares.
We appended four zero bits in order to obtain 52 Bech32 characters (260
bits of data) from the 256-bit secret.

256-bit secret (hex):
<code>ffeeddccbbaa99887766554433221100ffeeddccbbaa99887766554433221100</code>

* codex32 secret:
<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqqtum9pgv99ycma</code>

Note that the choice to append four zero bits was arbitrary, and any of the
following sixteen codex32 secrets would have been valid:

*
<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqqtum9pgv99ycma</code>
*
<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqpj82dp34u6lqtd</code>
*
<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqzsrs4pnh7jmpj5</code>
*
<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqrfcpap2w8dqezy</code>
*
<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqy5tdvphn6znrf0</code>
*
<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq9dsuypw2ragmel</code>
*
<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqx05xupvgp4v6qx</code>
*
<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq8k0h5p43c2hzsk</code>
*
<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqgum7hplmjtr8ks</code>
*
<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqf9q0lpxzt5clxq</code>
*
<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq28y48pyqfuu7le</code>
*
<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqt7ly0paesr8x0f</code>
*
<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqvrvg7pqydv5uyz</code>
*
<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqd6hekpea5n0y5j</code>
*
<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqwcnrwpmlkmt9dt</code>
*
<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq0pgjxpzx0ysaam</code>

===Test vector 5===

This example shows generating a new 512-bit master seed using "random"
codex32 characters and appending a checksum.
The payload contains 103 Bech32 characters, which corresponds to 515 bits.
The last three bits are discarded when converting to a 512-bit master seed.

This is an example of a '''Long codex32 String'''.

* Secret share with index <code>S</code>:
<code>MS100C8VSM32ZXFGUHPCHTLUPZRY9X8GF2TVDW0S3JN54KHCE6MUA7LQPZYGSFJD6AN074RXVCEMLH8WU3TK925ACDEFGHJKLMNPQRSTUVWXY06FHPV80UNDVARHRAK</code>
* Master secret (hex):
<code>dc5423251cb87175ff8110c8531d0952d8d73e1194e95b5f19d6f9df7c01111104c9baecdfea8cccc677fb9ddc8aec5553b86e528bcadfdcc201c17c638c47e9</code>

==Appendix==

===Mathematical Companion===

Below we use the Bech32 character set to denote values in GF[32].
In Bech32, the letter <code>Q</code> denotes zero and the letter
<code>P</code> denotes one.
The digits <code>0</code> and <code>2</code> through <code>9</code> do
''not'' denote their numeric values.
They are simply elements of GF[32].

The generating polynomial for our BCH code is as follows.

We extend GF[32] to GF[1024] by adjoining a primitive cube root of unity,
<code>?</code>, satisfying <code>?^2 = ? + P</code>.

We select <code>? := G ?</code> which has order 93, and construct the
product <code>(x - ?^i)</code> for <code>i</code> in <code>{17, 20, 46, 49,
52, 77, 78, 79, 80, 81, 82, 83, 84}</code>.
The resulting polynomial is our generating polynomial for our 13 character
checksum:

    x^13 + E x^12 + M x^11 + 3 x^10 + G x^9 + Q x^8 + E x^7 + E x^6 + E x^5
+ L x^4 + M x^3 + C x^2 + S x + S

For our long checksum, we select <code>? := E + X ?</code>, which has order
1023, and construct the product <code>(x - ?^i)</code> for <code>i</code>
in <code>{32, 64, 96, 895, 927, 959, 991, 1019, 1020, 1021, 1022, 1023,
1024, 1025, 1026}</code>.
The resulting polynomial is our generating polynomial for our 15 character
checksum for long strings:

    x^15 + 0 x^14 + 2 x^13 + E x^12 + 6 x^11 + F x^10 + E x^9 + 4 x^8 + X
x^7 + H x^6 + 4 x^5 + X x^4 + 9 x^3 + K x^2 + Y x^1 + H

(Reminder: the character <code>0</code> does ''not'' denote the zero of the
field.)

-----END BIP-----
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230215/4ef5f4ec/attachment-0001.html>

From stick at satoshilabs.com  Thu Feb 16 11:50:12 2023
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Thu, 16 Feb 2023 12:50:12 +0100
Subject: [bitcoin-dev] Codex32
In-Reply-To: <CAMZUoKmiwXW50F2onqNUZO8HXQa4+Z=z3s3WyN7-rAMV=KiSgw@mail.gmail.com>
References: <CAMZUoKmiwXW50F2onqNUZO8HXQa4+Z=z3s3WyN7-rAMV=KiSgw@mail.gmail.com>
Message-ID: <CAF90AvmaRYO6HKn9npyfzO6M6FZnN6DRhqopLpeSnHJNK=5i9g@mail.gmail.com>

Hi!

The BIP states that its only advantage over SLIP-0039, which has been used
in production for nearly three years (in at at least 3 SW/HW wallet
implementations), is that it aims to be simple enough for hand computation.
However, the BIP also indicates that "details of hand computation are
outside the scope of this standard, and implementers do not need to be
concerned with this possibility." Therefore, I am curious about how
significant this advantage over SLIP-0039 really is. If hand computation is
not straightforward and there are no other substantial advantages over
SLIP-0039, I cannot help but feel that this BIP is simply a result of
not-invented-here syndrome, but please correct me if I am wrong.

Keep in mind that the encoded shares in SLIP-0039 consist of exactly 200 or
330 bits, both of which are divisible by 5. This makes it straightforward
to encode them as Bech32 strings.

On Thu, 16 Feb 2023 at 09:30, Russell O'Connor via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I've been asked by Dr. Curr and Professor Snead to forward this message to
> this mailing list, as it may be of general interest to Bitcoin users.
>
> Dear Colleague:
>
> In 1967, during excavation for the construction of a new shopping center
> in
> Monroeville, Pennsylvania, workers uncovered a vault containing a cache of
> ancient scrolls[1].  Most were severely damaged, but those that could be
> recovered confirmed the existence of a secret society long suspected to
> have
> been active in the region around the year 200 BC.
>
> Based on a translation of these documents, we now know that the society,
> the
> Cult of the Bound Variable, was devoted to the careful study of
> computation,
> over two millennia before the invention of the digital computer.
>
> While the Monroeville scrolls make reference to computing machines made of
> sandstone, most researchers believed this to be a poetic metaphor and that
> the
> "computers" were in fact the initiates themselves, carrying out the
> unimaginably tedious steps of their computations with reed pens on
> parchment.
>
> Within the vault, a collection of sandstone wheels marked in a language
> consisting of 32 glyphs was found. After 15 years of study, we have
> successfully
> completed the translation of what is known as "Codex32," a document that
> describes the functions of the wheels. It was discovered that the wheels
> operate
> a system of cryptographic computations that was used by cult members to
> safeguard their most valuable secrets.
>
> The Codex32 system allows secrets to be carved into multiple tablets and
> scattered to the far corners of the earth. When a sufficient number of
> tablets are
> brought together the stone wheels are manipulated in a manner to recover
> the
> secrets. This finding may be of particular interest to the Bitcoin
> community.
>
> Below we provide a summary of the cult's secret sharing system, which is
> graciously hosted at
> <
> https://github.com/apoelstra/bips/blob/2023-02--volvelles/bip-0000.mediawiki
> >.
> We are requesting a record assignment in the Bibliography of Immemorial
> Philosophy (BIP) repository.
>
> Thank you for your consideration.
>
> Dr. Leon O. Curr and Professor Pearlwort Snead
> Department of Archaeocryptography
> Harry Q. Bovik Institute for the Advancement
>
> [1] http://www.boundvariable.org/task.shtml
>
> -----BEGIN BIP-----
>
> <pre>
>   BIP: ????
>   Layer: Applications
>   Title: codex32
>   Author: Leon Olsson Curr and Pearlwort Sneed <pearlwort at wpsoftware.net>
>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????
>   Status: Draft
>   Type: ????
>   Created: 2023-02-13
>   License: BSD-3-Clause
>   Post-History: FIXME
> </pre>
>
> ==Introduction==
>
> ===Abstract===
>
> This document describes a standard for backing up and restoring the master
> seed of a
> [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP-0032]
> hierarchical deterministic wallet, using Shamir's secret sharing.
> It includes an encoding format, a BCH error-correcting checksum, and
> algorithms for share generation and secret recovery.
> Secret data can be split into up to 31 shares.
> A minimum threshold of shares, which can be between 1 and 9, is needed to
> recover the secret, whereas without sufficient shares, no information about
> the secret is recoverable.
>
> ===Copyright===
>
> This document is licensed under the 3-clause BSD license.
>
> ===Motivation===
>
> BIP-0032 master seed data is the source entropy used to derive all private
> keys in an HD wallet.
> Safely storing this secret data is the hardest and most important part of
> self-custody.
> However, there is a tension between security, which demands limiting the
> number of backups, and resilience, which demands widely replicated backups.
> Encrypting the seed does not change this fundamental tradeoff, since it
> leaves essentially the same problem of how to back up the encryption key(s).
>
> To allow users freedom to make this tradeoff, we use Shamir's secret
> sharing, which guarantees that any number of shares less than the threshold
> leaks no information about the secret.
> This approach allows increasing safety by widely distributing the
> generated shares, while also providing security against the compromise of
> one or more shares (as long as fewer than the threshold have been
> compromised).
>
> [https://github.com/satoshilabs/slips/blob/master/slip-0039.md SLIP-0039]
> has essentially the same motivations as this standard.
> However, unlike SLIP-0039, this standard also aims to be simple enough for
> hand computation.
> Users who demand a higher level of security for particular secrets, or
> have a general distrust in digital electronic devices, have the option of
> using hand computation to backup and restore secret data in an
> interoperable manner.
> Note that hand computation is optional, the particular details of hand
> computation are outside the scope of this standard, and implementers do not
> need to be concerned with this possibility.
>
> [https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki BIP-0039]
> serves the same purpose as this standard: encoding master seeds for storage
> by users.
> However, BIP-0039 has no error-correcting ability, cannot sensibly be
> extended to support secret sharing, has no support for versioning or other
> metadata, and has many technical design decisions that make implementation
> and interoperability difficult (for example, the use of SHA-512 to derive
> seeds, or the use of 11-bit words).
>
> ==Specification==
>
> ===codex32===
>
> A codex32 string is similar to a Bech32 string defined in [
> https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP-0173].
> It reuses the base32 character set from BIP-0173, and consists of:
>
> * A human-readable part, which is the string "ms" (or "MS").
> * A separator, which is always "1".
> * A data part which is in turn subdivided into:
> ** A threshold parameter, which MUST be a single digit between "2" and
> "9", or the digit "0".
> *** If the threshold parameter is "0" then the share index, defined below,
> MUST have a value of "s" (or "S").
> ** An identifier consisting of 4 Bech32 characters.
> ** A share index, which is any Bech32 character. Note that a share index
> value of "s" (or "S") is special and denotes the unshared secret (see
> section "Unshared Secret").
> ** A payload which is a sequence of up to 74 Bech32 characters. (However,
> see '''Long codex32 Strings''' below for an exception to this limit.)
> ** A checksum which consists of 13 Bech32 characters as described below.
>
> As with Bech32 strings, a codex32 string MUST be entirely uppercase or
> entirely lowercase.
> The lowercase form is used when determining a character's value for
> checksum purposes.
> For presentation, lowercase is usually preferable, but uppercase SHOULD be
> used for handwritten codex32 strings.
>
> ===Checksum===
>
> The last thirteen characters of the data part form a checksum and contain
> no information.
> Valid strings MUST pass the criteria for validity specified by the Python3
> code snippet below.
> The function <code>ms32_verify_checksum</code> must return true when its
> argument is the data part as a list of integers representing the characters
> converted using the bech32 character table from BIP-0173.
>
> To construct a valid checksum given the data-part characters (excluding
> the checksum), the <code>ms32_create_checksum</code> function can be used.
>
> <source lang="python">
> MS32_CONST = 0x10ce0795c2fd1e62a
>
> def ms32_polymod(values):
>     GEN = [
>         0x19dc500ce73fde210,
>         0x1bfae00def77fe529,
>         0x1fbd920fffe7bee52,
>         0x1739640bdeee3fdad,
>         0x07729a039cfc75f5a,
>     ]
>     residue = 0x23181b3
>     for v in values:
>         b = (residue >> 60)
>         residue = (residue & 0x0fffffffffffffff) << 5 ^ v
>         for i in range(5):
>             residue ^= GEN[i] if ((b >> i) & 1) else 0
>     return residue
>
> def ms32_verify_checksum(data):
>     if len(data) >= 96:                      # See Long codex32 Strings
>         return ms32_verify_long_checksum(data)
>     if len(data) <= 93:
>         return ms32_polymod(data) == MS32_CONST
>     return False
>
> def ms32_create_checksum(data):
>     if len(data) > 80:                       # See Long codex32 Strings
>         return ms32_create_long_checksum(data)
>     values = data
>     polymod = ms32_polymod(values + [0] * 13) ^ MS32_CONST
>     return [(polymod >> 5 * (12 - i)) & 31 for i in range(13)]
> </source>
>
> ===Error Correction===
>
> A codex32 string without a valid checksum MUST NOT be used.
> The checksum is designed to be an error correcting code that can correct
> up to 4 character substitutions, up to 8 unreadable characters (called
> erasures), or up to 13 consecutive erasures.
> Implementations SHOULD provide the user with a corrected valid codex32
> string if possible.
> However, implementations SHOULD NOT automatically proceed with a corrected
> codex32 string without user confirmation of the corrected string, either by
> prompting the user, or returning a corrected string in an error message and
> allowing the user to repeat their action.
> We do not specify how an implementation should implement error correction.
> However, we recommend that:
>
> * Implementations make suggestions to substitute non-bech32 characters
> with bech32 characters in some situations, such as replacing "B" with "8",
> "O" with "0", "I" with "l", etc.
> * Implementations interpret "?" as an erasure.
> * Implementations optionally interpret other non-bech32 characters, or
> characters with incorrect case, as erasures.
> * If a string with 8 or fewer erasures can have those erasures filled in
> to make a valid codex32 string, then the implementation suggests such a
> string as a correction.
> * If a string consisting of valid Bech32 characters in the proper case can
> be made valid by substituting 4 or fewer characters, then the
> implementation suggests such a string as a correction.
>
> ===Unshared Secret===
>
> When the share index of a valid codex32 string (converted to lowercase) is
> the letter "s", we call the string a codex32 secret.
> The subsequent data characters in a codex32 secret, excluding the final
> checksum of 13 characters, is a direct encoding of a BIP-0032 HD master
> seed.
>
> The master seed is decoded by converting the data to bytes:
>
> * Translate the characters to 5 bits values using the bech32 character
> table from BIP-0173, most significant bit first.
> * Re-arrange those bits into groups of 8 bits. Any incomplete group at the
> end MUST be 4 bits or less, and is discarded.
>
> Note that unlike the decoding process in BIP-0173, we do NOT require that
> the incomplete group be all zeros.
>
> For an unshared secret, the threshold parameter (the first character of
> the data part) is ignored (beyond the fact it must be a digit for the
> codex32 string to be valid).
> We recommend using the digit "0" for the threshold parameter in this case.
> The 4 character identifier also has no effect beyond aiding users in
> distinguishing between multiple different master seeds in cases where they
> have more than one.
>
> ===Recovering Master Seed===
>
> When the share index of a valid codex32 string (converted to lowercase) is
> not the letter "s", we call the string an codex32 share.
> The first character of the data part indicates the threshold of the share,
> and it is required to be a non-"0" digit.
>
> In order to recover a master seed, one needs a set of valid codex32 shares
> such that:
>
> * All shares have the same threshold value, the same identifier, and the
> same length.
> * All of the share index values are distinct.
> * The number of codex32 shares is exactly equal to the (common) threshold
> value.
>
> If all the above conditions are satisfied, the <code>ms32_recover</code>
> function will return a codex32 secret when its argument is the list of
> codex32 shares with each share represented as a list of integers
> representing the characters converted using the bech32 character table from
> BIP-0173.
>
> <source lang="python">
> bech32_inv = [
>     0, 1, 20, 24, 10, 8, 12, 29, 5, 11, 4, 9, 6, 28, 26, 31,
>     22, 18, 17, 23, 2, 25, 16, 19, 3, 21, 14, 30, 13, 7, 27, 15,
> ]
>
> def bech32_mul(a, b):
>     res = 0
>     for i in range(5):
>         res ^= a if ((b >> i) & 1) else 0
>         a *= 2
>         a ^= 41 if (32 <= a) else 0
>     return res
>
> def bech32_lagrange(l, x):
>     n = 1
>     c = []
>     for i in l:
>         n = bech32_mul(n, i ^ x)
>         m = 1
>         for j in l:
>             m = bech32_mul(m, (x if i == j else i) ^ j)
>         c.append(m)
>     return [bech32_mul(n, bech32_inv[i]) for i in c]
>
> def ms32_interpolate(l, x):
>     w = bech32_lagrange([s[5] for s in l], x)
>     res = []
>     for i in range(len(l[0])):
>         n = 0
>         for j in range(len(l)):
>             n ^= bech32_mul(w[j], l[j][i])
>         res.append(n)
>     return res
>
> def ms32_recover(l):
>     return ms32_interpolate(l, 16)
> </source>
>
> ===Generating Shares===
>
> If we already have ''t'' valid codex32 strings such that:
>
> * All strings have the same threshold value ''t'', the same identifier,
> and the same length
> * All of the share index values are distinct
>
> Then we can derive additional shares with the
> <code>ms32_interpolate</code> function by passing it a list of exactly
> ''t'' of these codex32 strings, together with a fresh share index distinct
> from all of the existing share indexes.
> The newly derived share will have the provided share index.
>
> Once a user has generated ''n'' codex32 shares, they may discard the
> codex32 secret (if it exists).
> The ''n'' shares form a ''t'' of ''n'' Shamir's secret sharing scheme of a
> codex32 secret.
>
> There are two ways to create an initial set of ''t'' valid codex32
> strings, depending on whether the user already has an existing master seed
> to split.
>
> ====For an existing master seed====
>
> Before generating shares for an existing master seed, it first must be
> converted into a codex32 secret, as described above.
> The conversion process consists of:
>
> * Choosing a threshold value ''t'' between 2 and 9, inclusive
> * Choosing a 4 bech32 character identifier
> ** We do not define how to choose the identifier, beyond noting that it
> SHOULD be distinct for every master seed the user may need to disambiguate.
> * Setting the share index to "s"
> * Setting the payload to a Bech32 encoding of the master seed, padded with
> arbitrary bits
> * Generating a valid checksum in accordance with the Checksum section
>
> Along with the codex32 secret, the user must generate ''t''-1 other
> codex32 shares, each with the same threshold value, the same identifier,
> and a distinct share index.
> The set of share indexes may be chosen arbitrarily.
> The payload of each of these codex32 shares is chosen uniformly at random
> such that it has the same length as the payload of the codex32 secret.
> For each share, a valid checksum must be generated in accordance with the
> Checksum section.
>
> The codex32 secret and the ''t''-1 codex32 shares form a set of ''t''
> valid codex32 strings from which additional shares can be derived as
> described above.
>
> ====For a fresh master seed====
>
> In the case that the user wishes to generate a fresh master seed, the user
> chooses a threshold value ''t'' and an identifier, then generates ''t''
> random codex32 shares, using the generation procedure from the previous
> section.
> As before, each share must have the same threshold value ''t'', the same
> identifier, and a distinct share index.
>
> With this set of ''t'' codex32 shares, new shares can be derived as
> discussed above. This process generates a fresh master seed, whose value
> can be retrieved by running the recovery process on any ''t'' of these
> shares.
>
> ===Long codex32 Strings===
>
> The 13 character checksum design only supports up to 80 data characters.
> Excluding the threshold, identifier and index characters, this limits the
> payload to 74 characters or 46 bytes.
> While this is enough to support the 32-byte advised size of BIP-0032
> master seeds, BIP-0032 allows seeds to be up to 64 bytes in size.
> We define a long codex32 string format to support these longer seeds by
> defining an alternative checksum.
>
> <source lang="python">
> MS32_LONG_CONST = 0x43381e570bf4798ab26
>
> def ms32_long_polymod(values):
>     GEN = [
>         0x3d59d273535ea62d897,
>         0x7a9becb6361c6c51507,
>         0x543f9b7e6c38d8a2a0e,
>         0x0c577eaeccf1990d13c,
>         0x1887f74f8dc71b10651,
>     ]
>     residue = 0x23181b3
>     for v in values:
>         b = (residue >> 70)
>         residue = (residue & 0x3fffffffffffffffff) << 5 ^ v
>         for i in range(5):
>             residue ^= GEN[i] if ((b >> i) & 1) else 0
>     return residue
>
> def ms32_verify_long_checksum(data):
>     return ms32_long_polymod(data) == MS32_LONG_CONST
>
> def ms32_create_long_checksum(data):
>     values = data
>     polymod = ms32_long_polymod(values + [0] * 15) ^ MS32_LONG_CONST
>     return [(polymod >> 5 * (14 - i)) & 31 for i in range(15)]
> </source>
>
> A long codex32 string follows the same specification as a regular codex32
> string with the following changes.
>
> * The payload is a sequence of between 75 and 103 Bech32 characters.
> * The checksum consists of 15 Bech32 characters as defined above.
>
> A codex32 string with a data part of 94 or 95 characters is never legal as
> a regular codex32 string is limited to 93 data characters and a long
> codex32 string is at least 96 characters.
>
> Generation of long shares and recovery of the master seed from long shares
> proceeds in exactly the same way as for regular shares with the
> <code>ms32_interpolate</code> function.
>
> The long checksum is designed to be an error correcting code that can
> correct up to 4 character substitutions, up to 8 unreadable characters
> (called erasures), or up to 15 consecutive erasures.
> As with regular checksums we do not specify how an implementation should
> implement error correction, and all our recommendations for error
> correction of regular codex32 strings also apply to long codex32 strings.
>
> ==Rationale==
>
> This scheme is based on the observation that the Lagrange interpolation of
> valid codewords in a BCH code will always be a valid codeword.
> This means that derived shares will always have valid checksum, and a
> sufficient threshold of shares with valid checksums will derive a secret
> with a valid checksum.
>
> The header system is also compatible with Lagrange interpolation, meaning
> all derived shares will have the same identifier and will have the
> appropriate share index.
> This fact allows the header data to be covered by the checksum.
>
> The checksum size and identifier size have been chosen so that the
> encoding of 128-bit seeds and shares fit within 48 characters.
> This is a standard size for many common seed storage formats, which has
> been popularized by the 12 four-letter word format of the BIP-0039 mnemonic.
>
> The 13 character checksum is adequate to correct 4 errors in up to 93
> characters (80 characters of data and 13 characters of the checksum). This
> is somewhat better quality than the checksum used in SLIP-0039.
>
> For 256-bit seeds and shares our strings are 74 characters, which fits
> into the 96 character format of the 24 four-letter word format of the
> BIP-0039 mnemonic, with plenty of room to spare.
>
> A longer checksum is needed to support up to 512-bit seeds, the longest
> seed length specified in BIP-0032, as the 13 character checksum isn't
> adequate for more than 80 data characters.
> While we could use the 15 character checksum for both cases, we prefer to
> keep the strings as short as possible for the more common cases of 128-bit
> and 256-bit master seeds.
> We only guarantee to correct 4 characters no matter how long the string is.
> Longer strings mean more chances for transcription errors, so shorter
> strings are better.
>
> The longest data part using the regular 13 character checksum is 93
> characters and corresponds to a 400-bit secret.
> At this length, the prefix <code>MS1</code> is not covered by the checksum.
> This is acceptable because the checksum scheme itself requires you to know
> that the <code>MS1</code> prefix is being used in the first place.
> If the prefix is damaged and a user is guessing that the data might be
> using this scheme, then the user can enter the available data explicitly
> using the suspected <code>MS1</code> prefix.
>
> ==Backwards Compatibility==
>
> codex32 is an alternative to BIP-0039 and SLIP-0039.
> It is technically possible to derive the BIP32 master seed from seed words
> encoded in one of these schemes, and then to encode this seed in codex32.
> For BIP-0039 this process is irreversible, since it involves hashing the
> original words.
> Furthermore, the resulting seed will be 512 bits long, which may be too
> large to be safely and conveniently handled.
>
> SLIP-0039 seed words can be reversibly converted to master seeds, so it is
> possible to interconvert between SLIP-0039 and codex32.
> However, SLIP-0039 '''shares''' cannot be converted to codex32 shares
> because the two schemes use a different underlying field.
>
> The authors of this BIP do not recommend interconversion.
> Instead, users who wish to switch to codex32 should generate a fresh seed
> and sweep their coins.
>
> ==Reference Implementation==
>
> * [https://secretcodex32.com/docs/2023-02-14--bw.ps Reference PostScript
> Implementation]
> * FIXME add Python implementation
> * FIXME add Rust implementation
>
> ==Test Vectors==
>
> ===Test vector 1===
>
> This example shows the codex32 format, when used without splitting the
> secret into any shares.
> The data part contains 26 Bech32 characters, which corresponds to 130
> bits. We truncate the last two bits in order to obtain a 128-bit master
> seed.
>
> codex32 secret (Bech32):
> <code>ms10testsxxxxxxxxxxxxxxxxxxxxxxxxxx4nzvca9cmczlw</code>
>
> Master secret (hex): <code>318c6318c6318c6318c6318c6318c631</code>
>
> * human-readable part: <code>ms</code>
> * separator: <code>1</code>
> * k value: <code>0</code> (no secret splitting)
> * identifier: <code>test</code>
> * share index: <code>s</code> (the secret)
> * data: <code>xxxxxxxxxxxxxxxxxxxxxxxxxx</code>
> * checksum: <code>4nzvca9cmczlw</code>
>
> ===Test vector 2===
>
> This example shows generating a new master seed using "random" codex32
> shares, as well as deriving an additional codex32 share, using ''k''=2 and
> an identifier of <code>NAME</code>.
> Although codex32 strings are canonically all lowercase, it's also valid to
> use all uppercase.
>
> Share with index <code>A</code>:
> <code>MS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM</code>
>
> Share with index <code>C</code>:
> <code>MS12NAMECACDEFGHJKLMNPQRSTUVWXYZ023FTR2GDZMPY6PN</code>
>
> * Derived share with index <code>D</code>:
> <code>MS12NAMEDLL4F8JLH4E5VDVULDLFXU2JHDNLSM97XVENRXEG</code>
> * Secret share with index <code>S</code>:
> <code>MS12NAMES6XQGUZTTXKEQNJSJZV4JV3NZ5K3KWGSPHUH6EVW</code>
> * Master secret (hex): <code>d1808e096b35b209ca12132b264662a5</code>
>
> Note that per BIP-0173, the lowercase form is used when determining a
> character's value for checksum purposes.
> In particular, given an all uppercase codex32 string, we still use
> lowercase <code>ms</code> as the human-readable part during checksum
> construction.
>
> ===Test vector 3===
>
> This example shows splitting an existing 128-bit master seed into "random"
> codex32 shares, using ''k''=3 and an identifier of <code>cash</code>.
> We appended two zero bits in order to obtain 26 Bech32 characters (130
> bits of data) from the 128-bit master seed.
>
> Master secret (hex): <code>ffeeddccbbaa99887766554433221100</code>
>
> Secret share with index <code>s</code>:
> <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qqjzqud4m0d6nln</code>
>
> Share with index <code>a</code>:
> <code>ms13casha320zyxwvutsrqpnmlkjhgfedca2a8d0zehn8a0t</code>
>
> Share with index <code>c</code>:
> <code>ms13cashcacdefghjklmnpqrstuvwxyz023949xq35my48dr</code>
>
> * Derived share with index <code>d</code>:
> <code>ms13cashd0wsedstcdcts64cd7wvy4m90lm28w4ffupqs7rm</code>
> * Derived share with index <code>e</code>:
> <code>ms13casheekgpemxzshcrmqhaydlp6yhms3ws7320xyxsar9</code>
> * Derived share with index <code>f</code>:
> <code>ms13cashf8jh6sdrkpyrsp5ut94pj8ktehhw2hfvyrj48704</code>
>
> Any three of the five shares among <code>acdef</code> can be used to
> recover the secret.
>
> Note that the choice to append two zero bits was arbitrary, and any of the
> following four secret shares would have been valid choices.
> However, each choice would have resulted in a different set of derived
> shares.
>
> * <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qqjzqud4m0d6nln</code>
> * <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qpte35dvzkjpt0r</code>
> * <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qzfatvdwq5692k6</code>
> * <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qrsx6ydhed97jx2</code>
>
> ===Test vector 4===
>
> This example shows converting a 256-bit secret into a codex32 secret,
> without splitting the secret into any shares.
> We appended four zero bits in order to obtain 52 Bech32 characters (260
> bits of data) from the 256-bit secret.
>
> 256-bit secret (hex):
> <code>ffeeddccbbaa99887766554433221100ffeeddccbbaa99887766554433221100</code>
>
> * codex32 secret:
> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqqtum9pgv99ycma</code>
>
> Note that the choice to append four zero bits was arbitrary, and any of
> the following sixteen codex32 secrets would have been valid:
>
> *
> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqqtum9pgv99ycma</code>
> *
> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqpj82dp34u6lqtd</code>
> *
> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqzsrs4pnh7jmpj5</code>
> *
> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqrfcpap2w8dqezy</code>
> *
> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqy5tdvphn6znrf0</code>
> *
> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq9dsuypw2ragmel</code>
> *
> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqx05xupvgp4v6qx</code>
> *
> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq8k0h5p43c2hzsk</code>
> *
> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqgum7hplmjtr8ks</code>
> *
> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqf9q0lpxzt5clxq</code>
> *
> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq28y48pyqfuu7le</code>
> *
> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqt7ly0paesr8x0f</code>
> *
> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqvrvg7pqydv5uyz</code>
> *
> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqd6hekpea5n0y5j</code>
> *
> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqwcnrwpmlkmt9dt</code>
> *
> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq0pgjxpzx0ysaam</code>
>
> ===Test vector 5===
>
> This example shows generating a new 512-bit master seed using "random"
> codex32 characters and appending a checksum.
> The payload contains 103 Bech32 characters, which corresponds to 515 bits.
> The last three bits are discarded when converting to a 512-bit master seed.
>
> This is an example of a '''Long codex32 String'''.
>
> * Secret share with index <code>S</code>:
> <code>MS100C8VSM32ZXFGUHPCHTLUPZRY9X8GF2TVDW0S3JN54KHCE6MUA7LQPZYGSFJD6AN074RXVCEMLH8WU3TK925ACDEFGHJKLMNPQRSTUVWXY06FHPV80UNDVARHRAK</code>
> * Master secret (hex):
> <code>dc5423251cb87175ff8110c8531d0952d8d73e1194e95b5f19d6f9df7c01111104c9baecdfea8cccc677fb9ddc8aec5553b86e528bcadfdcc201c17c638c47e9</code>
>
> ==Appendix==
>
> ===Mathematical Companion===
>
> Below we use the Bech32 character set to denote values in GF[32].
> In Bech32, the letter <code>Q</code> denotes zero and the letter
> <code>P</code> denotes one.
> The digits <code>0</code> and <code>2</code> through <code>9</code> do
> ''not'' denote their numeric values.
> They are simply elements of GF[32].
>
> The generating polynomial for our BCH code is as follows.
>
> We extend GF[32] to GF[1024] by adjoining a primitive cube root of unity,
> <code>?</code>, satisfying <code>?^2 = ? + P</code>.
>
> We select <code>? := G ?</code> which has order 93, and construct the
> product <code>(x - ?^i)</code> for <code>i</code> in <code>{17, 20, 46, 49,
> 52, 77, 78, 79, 80, 81, 82, 83, 84}</code>.
> The resulting polynomial is our generating polynomial for our 13 character
> checksum:
>
>     x^13 + E x^12 + M x^11 + 3 x^10 + G x^9 + Q x^8 + E x^7 + E x^6 + E
> x^5 + L x^4 + M x^3 + C x^2 + S x + S
>
> For our long checksum, we select <code>? := E + X ?</code>, which has
> order 1023, and construct the product <code>(x - ?^i)</code> for
> <code>i</code> in <code>{32, 64, 96, 895, 927, 959, 991, 1019, 1020, 1021,
> 1022, 1023, 1024, 1025, 1026}</code>.
> The resulting polynomial is our generating polynomial for our 15 character
> checksum for long strings:
>
>     x^15 + 0 x^14 + 2 x^13 + E x^12 + 6 x^11 + F x^10 + E x^9 + 4 x^8 + X
> x^7 + H x^6 + 4 x^5 + X x^4 + 9 x^3 + K x^2 + Y x^1 + H
>
> (Reminder: the character <code>0</code> does ''not'' denote the zero of
> the field.)
>
> -----END BIP-----
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>


-- 
Best Regards / S pozdravom,

Pavol "Stick" Rusnak
Co-Founder, SatoshiLabs
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230216/d2e67885/attachment-0001.html>

From apoelstra at wpsoftware.net  Thu Feb 16 13:49:53 2023
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Thu, 16 Feb 2023 13:49:53 +0000
Subject: [bitcoin-dev] Codex32
In-Reply-To: <CAF90AvmaRYO6HKn9npyfzO6M6FZnN6DRhqopLpeSnHJNK=5i9g@mail.gmail.com>
References: <CAMZUoKmiwXW50F2onqNUZO8HXQa4+Z=z3s3WyN7-rAMV=KiSgw@mail.gmail.com>
 <CAF90AvmaRYO6HKn9npyfzO6M6FZnN6DRhqopLpeSnHJNK=5i9g@mail.gmail.com>
Message-ID: <Y+40gVnMpj0prfQk@camus>

On Thu, Feb 16, 2023 at 12:50:12PM +0100, Pavol Rusnak via bitcoin-dev wrote:
> Hi!
> 
> The BIP states that its only advantage over SLIP-0039, which has been used
> in production for nearly three years (in at at least 3 SW/HW wallet
> implementations), is that it aims to be simple enough for hand computation.
> However, the BIP also indicates that "details of hand computation are
> outside the scope of this standard, and implementers do not need to be
> concerned with this possibility." Therefore, I am curious about how
> significant this advantage over SLIP-0039 really is. If hand computation is
> not straightforward and there are no other substantial advantages over
> SLIP-0039, I cannot help but feel that this BIP is simply a result of
> not-invented-here syndrome, but please correct me if I am wrong.
>

In my view, the hand computation is actually the main benefit of this
scheme. The process *is* straightforward, but tedious enough (and the
security benefits obscure enough, though they really shouldn't be...
"computers are opaque and untrustworthy" should be a common sentiment)
that it's hard to expect more than a small absolute number of users to
actually do it.

But for the purpose of the *standard*, what is important is that it is
possible to implement and use this within a normal hww workflow. This is
important for hand-computing users who know that their coins will not
die with them (since the 'standard' has fallen into obscurity), and
important for "normal" users who have the option to seamlessly switch
over to hand computation as the BTC price goes up or the world becomes
scarier.

For what it's worth, the draft lists several benefits over SLIP-0039.
I agree that none of them are particularly strong [1], and even together
they probably wouldn't meet the threshold to take the time to write a
standard, but I assure you the motivation was not NIH :).

> Keep in mind that the encoded shares in SLIP-0039 consist of exactly 200 or
> 330 bits, both of which are divisible by 5. This makes it straightforward
> to encode them as Bech32 strings.
> 

This is true! And very convenient for people who may want to simply
"layer on" the codex32 checksum/splitting logic onto their SLIP39 words.
They can use a lookup table to do the conversion, spend years or
whataever doing hand-computation on them, and then use a lookup table
to go back.


[1] One listed reason is that "a SLIP is not a BIP". I have heard people
    speculate that this is one reason SLIP-0039 is not nearly as
    widespread as BIP-0039, even though it is objectively a far better
    standard. I'm unsure whether I believe this, but "there is no other
    BIP" does seem like a good reason for BIP-0039's continued
    dominance.

    At the very least, it means that on BIP-0039 itself we have nothing
    that we could say "supercedes" or "is recommended instead of" the
    BIP. See https://github.com/bitcoin/bips/pull/1413

    So it's something of an aside, but I think it would probably be good
    for the ecosystem (though maybe bad for this BIP's prospects :)) if
    you would request a BIP number for SLIP-0039.


-- 
Andrew Poelstra
Director of Research, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

The sun is always shining in space
    -Justin Lewis-Webster

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230216/7f6aa147/attachment.sig>

From dhruv at bip324.com  Thu Feb 16 17:43:22 2023
From: dhruv at bip324.com (Dhruv M)
Date: Thu, 16 Feb 2023 17:43:22 +0000
Subject: [bitcoin-dev] Refreshed BIP324
In-Reply-To: <Y7vMGVQz8TjS4Cad@erisian.com.au>
References: <56677685-619a-691f-d5bc-54b69fdb6ed2@bip324.com>
 <zxv58iXZ73hf9ge8S0QLTanW-uLzaWjNtMHuKONP9hrqS5RhwitxzfVaMH8hbi3yImgNrKme3lCuDcHYKkpxEQHyGZZHJ8xtReOcnAx3o4g=@wuille.net>
 <Y2nK99fHUKxbPHmw@erisian.com.au>
 <wDqcIVw-YGTsjdf5M2GO9NNRl_UQuBeka2CUQUyQ329u6u-o7RabW_7S4FD3EDfk02kUczb3bXf8LtHhKLtx773UhQ7djKOl-JPOIrXqBSc=@wuille.net>
 <JXfTBjsA71dHE3h9wkxnWXANrwTbMADO4s2w34gEvMbiduKu4PEt5t-KA3EAIz-Xs4urjBHZ15NDFZST2a7e0x_NqyJymUnEORuTp3SNfMs=@wuille.net>
 <Y3dBUXPhTskCx+Fu@erisian.com.au>
 <gSxFQedPc72pTioi9vuxvLKpaRBsnKFL4gkPKPn2G-EJgz_2Y1pYQ7cHD5SnunyCaLln7UQEHIxnopqP74LlnK__Mf9BURbJW8B5MYTZvCU=@wuille.net>
 <Y7dZctMlZtH6PEsz@erisian.com.au> <Y7vMGVQz8TjS4Cad@erisian.com.au>
Message-ID: <6b83c32e-59ca-65ef-2553-d66f8d117e56@bip324.com>

Attempting to summarize the thread thus far:

Problem:

- 1 byte message type IDs are lacking a co-ordination mechanism when multiple in-flight BIPs are proposing new message types as the id space is reduced form 12 ASCII bytes to 1 byte.
- 1 byte IDs are scarce and should be allocated judiciously, especially given that gains on bandwidth are very much non-uniform across message types.

Solutions:

- Uniform encoding using the high-bit increases the available ID space drastically, however, there's still the issue of making sure that the most frequent message types get the shorter IDs.
- Making type IDs negotiable(editable, really) per direction per connection solves that issue at the cost of some increased complexity.

Since we don't really know the extent to which the protocol will ossify over time and that BIP324 is already quite a large change, we might want to optimize for the least additional complexity that doesn't close the doors on any of the solutions. How about this:

- BIP324 restricts type IDs to [1, 127]
- We remove 1 byte allocations for messages that are sent at most once per connection per direction
- Optionally, in the implementation we can attempt to move the type id mapping to the p2p layer away from the transport layer. I suspect this could also be done after the implementation is merged but might be cleaner as the mapping is a p2p concern.

Best,

-Dhruv

On 1/9/23 00:11, Anthony Towns via bitcoin-dev wrote:

> On Fri, Jan 06, 2023 at 09:12:50AM +1000, Anthony Towns via bitcoin-dev wrote:
>
>> On Thu, Jan 05, 2023 at 10:06:29PM +0000, Pieter Wuille via bitcoin-dev wrote:
>>
>>> Oh, yes. I meant this as an encoding scheme, not as a (replacement for) the negotiation/coordination mechanism. There could still be an initial assignment for 1-byte encodings, and/or an explicit mechanism to negotiate other assignment, and/or nothing at all for now.
>
>> The current implementation for 324 does the aliasing
>> as part of V2TransportDeserializer::GetMessage and
>> V2TransportSerializer::prepareForTransport. That makes a lot of sense,
>> [...]
>
> So I think you can make this setup work with a negotiated assignment of
> shortids, perhaps starting off something like:
> https://github.com/ajtowns/bitcoin/commit/6b8edd754bdcb582e293e4f5d0b41297711bdbb7
> That has a 242 element array per peer giving the mappings (which
> is just ~250 bytes per peer) for deserialization, which seems
> workable. [0]
>
> It also has a single global map for serialization, so we'll always shorten
> CFILTER to shortid 39 for every peer that supports shortids, even, eg, for
> a peer who's told us they'll send CFILTER as shortid 99 and that we should
> interpret shortid 39 from them as NEWFEATUREX. That has three advantages:
>
>  * each peer can choose a mapping that minimises their own outbound
>    traffic, even potentially for asymmetric connections, and don't need
>    to coordinate with the other peer to decide a common optimal mapping
>    that they both use across their connection
>
>  * you don't have to have different serialization tables per-peer,
>    reducing memory usage / implementation complexity
>
>  * you can leave V2TransportSerializer as a `const` object, and not have
>    to introduce additional locking logic to be able to update its
>    state...
>
> I'm not seeing a good way to introduce shortids for future one-shot
> negotiation messages though (like VERSION, VERACK, SENDADDRV2,
> WTXIDRELAY, SENDTXRCNCL):
>
>  * if you explicitly announce the mapping first, you're just wasting
>    bytes ("99=FOOBAR; 99 baz quux" vs just "FOOBAR baz quux")
>  * if you negotiate the tables you support between VERSION/VERACK and
>    then choose a mutually supported table after VERACK, that's too late
>    for pre-VERACK negotation messages
>  * announcing the tables you support as part of the VERSION message
>    would work, but seems a bit klunky
>
> Also, if you did want to shift to a new table, you'd probably want to
> always support sending/receiving {37, 44, 46, 47, 36} messages?
>
> I guess I still kind-of think it'd make more sense to just reserve
> shortids for post-VERACK messages that are going to be sent more
> than once per connection... At that point, even if you don't have any
> table in common with your peer, just following VERACK with an immediate
> announcement of each shortid you want to use and its meaning would still
> make reasonable sense.
>
> If we included the ability to define your own shortids concurrently
> with bip324 rollout, then I think nodes could always have a static set
> of shortids they use for all their peers for outbound messages, which,
> as above, seems like it would make for simpler implementations.
>
> ie, you might send:
>
>    VERSION
>    SHORTIDTBLS ["","awesomeshortids"]
>    WTXIDRELAY
>    SENDADDRV2
>    SENDPACKAGES 1
>    VERACK
>    SHORTID "" [(52,"getpkgtxns"), (53, "pkgtxns"), (54, "ancpkginfo")]
>
> ...but you'd do all that long form, and only switch to shortids for
> messages after you've declared exactly what your shortids are going to
> be.
>
> (where "" is the table name for bip324's table, and "awesomeshortids"
> is an updated table that includes the package relay commands already,
> perhaps)
>
> Cheers,
> aj
>
> [0] m_deserializer is used from the SocketHandler thread in
>     CNode::ReceiveMsgBytes(), but the p2p protocol is managed from the
>     MessageHandler thread; with multiple messages potentially deserialized
>     into vRecvMsg() at once -- but that means that if the first message
>     redefines shortid decoding, and the second message uses one of the
>     redefined shortids, it will have already been decoded incorrectly.
>     So that would need some futzing about still.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
>
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230216/43ace413/attachment.html>

From aymeric at peersm.com  Thu Feb 16 18:23:55 2023
From: aymeric at peersm.com (Aymeric Vitte)
Date: Thu, 16 Feb 2023 19:23:55 +0100
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <f5c0abc5-e52f-6d41-c050-bb3ecbeb3986@peersm.com>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>
 <57f780b1-f262-9394-036c-70084320e9cf@peersm.com>
 <CACrqygCNf3Gv8+VjhyqS4GTb3Epo8qXEKGtQB6sqyR6ib44-fA@mail.gmail.com>
 <CABE6yHtM2Dqc63_eURSr7dMirJti5sYnqvHj7vQ_Ab9FC_d04g@mail.gmail.com>
 <3d00aacb-585d-f875-784d-34352860d725@peersm.com>
 <CACrqygB_FbsRGWYPSUEFTnP15y94Hmo4JtAuv6bH1D3YtbAw9Q@mail.gmail.com>
 <b292d887-cbd5-165c-de01-793df2b5e8f3@peersm.com>
 <CACrqygAv842ucN7PLYMENXFiSwAZJy2Y+FziJXrWjyCcOXmL3g@mail.gmail.com>
 <230265ee-c3f8-dff3-9192-f0c8dc4d913c@peersm.com>
 <CAMZUoKkAdQ9TSMm4vPJOrThu_h6VbqwPhOQQR7-Yr+WZ0DMBYw@mail.gmail.com>
 <76718304-A8E3-46E6-B2F7-DE86831F15DF@petertodd.org>
 <CAMZUoKnrs-uxnTqpa96B4H86=gAtafowDi0D5HdnExvBWqTqPQ@mail.gmail.com>
 <f5c0abc5-e52f-6d41-c050-bb3ecbeb3986@peersm.com>
Message-ID: <228e8706-72c7-8d5f-b6fb-c71a2e56efde@peersm.com>

It's super unclear how long it could take for such a change to be adopted

Then the answer is simple, see:
https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7#workaround-to-the-80b-op_return-limitation

Outstandingly, very, mega, bad, but working, bringing bitcoin back 10
years ago

But why not? If bitcoin folks don't get that we need a 1tx storage
solution for the future, then let's bring back bitcoin into the past and
destroy coins

Le 12/02/2023 ? 17:23, Aymeric Vitte a ?crit :
>
> https://github.com/bitcoin/bitcoin/issues/27043#issuecomment-1427069403
>
> "What is the process to have someone do the PR for this? Or I do it
> and most likely it will be a very shxtty one since I am not a C/C++
> expert, then wasting the time of everybody
>
> It's urgently required, I did consider OP_RETURN as a dart in the past
> but changed my mind, it's adapted to the current evolutions, not
> flooding bitcoin with 2 txs while only 1 is needed
>
> If not the best 1 tx solution is super simple: store in addresses, and
> super bad at the end because burning bitcoins, while still not
> expensive if you don't need to store big things"
>
>
> Le 05/02/2023 ? 19:12, Russell O'Connor via bitcoin-dev a ?crit :
>>
>>
>> On Sat., Feb. 4, 2023, 21:01 Peter Todd, <pete at petertodd.org
>> <mailto:pete at petertodd.org>> wrote:
>>
>>
>>
>>     On February 5, 2023 1:11:35 AM GMT+01:00, Russell O'Connor via
>>     bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org
>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>     >Since bytes in the witness are cheaper than bytes in the script
>>     pubkey,
>>     >there is a crossover point in data size where it will simply be
>>     cheaper to
>>     >use witness data.  Where that crossover point is depends on the
>>     finer
>>     >details of the overhead of the two methods, but you could make some
>>     >reasonable assumptions.  Such a calculation could form the basis
>>     of a
>>     >reasonable OP_RETURN proposal.  I don't know if it would be
>>     persuasive, but
>>     >it would at least be coherent.
>>
>>     I don't think it's worth the technical complexity trying to
>>     carefully argue a specific limit. Let users decide for themselves
>>     how they want to use OpReturn.
>>
>>
>> Even better.
>>
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> -- 
> Sophia-Antipolis, France
> CV: https://www.peersm.com/CVAV.pdf
> LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26
> GitHub : https://www.github.com/Ayms
> A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7
> A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7
> Move your coins by yourself (browser version): https://peersm.com/wallet
> Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
> torrent-live: https://github.com/Ayms/torrent-live
> node-Tor : https://www.github.com/Ayms/node-Tor
> Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com
> Peersm : http://www.peersm.com

-- 
Sophia-Antipolis, France
CV: https://www.peersm.com/CVAV.pdf
LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26
GitHub : https://www.github.com/Ayms
A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7
A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com
Peersm : http://www.peersm.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230216/59e07bc2/attachment-0001.html>

From aubergemediale at gmail.com  Thu Feb 16 19:59:06 2023
From: aubergemediale at gmail.com (Claus Ehrenberg)
Date: Thu, 16 Feb 2023 20:59:06 +0100
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <228e8706-72c7-8d5f-b6fb-c71a2e56efde@peersm.com>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>
 <57f780b1-f262-9394-036c-70084320e9cf@peersm.com>
 <CACrqygCNf3Gv8+VjhyqS4GTb3Epo8qXEKGtQB6sqyR6ib44-fA@mail.gmail.com>
 <CABE6yHtM2Dqc63_eURSr7dMirJti5sYnqvHj7vQ_Ab9FC_d04g@mail.gmail.com>
 <3d00aacb-585d-f875-784d-34352860d725@peersm.com>
 <CACrqygB_FbsRGWYPSUEFTnP15y94Hmo4JtAuv6bH1D3YtbAw9Q@mail.gmail.com>
 <b292d887-cbd5-165c-de01-793df2b5e8f3@peersm.com>
 <CACrqygAv842ucN7PLYMENXFiSwAZJy2Y+FziJXrWjyCcOXmL3g@mail.gmail.com>
 <230265ee-c3f8-dff3-9192-f0c8dc4d913c@peersm.com>
 <CAMZUoKkAdQ9TSMm4vPJOrThu_h6VbqwPhOQQR7-Yr+WZ0DMBYw@mail.gmail.com>
 <76718304-A8E3-46E6-B2F7-DE86831F15DF@petertodd.org>
 <CAMZUoKnrs-uxnTqpa96B4H86=gAtafowDi0D5HdnExvBWqTqPQ@mail.gmail.com>
 <f5c0abc5-e52f-6d41-c050-bb3ecbeb3986@peersm.com>
 <228e8706-72c7-8d5f-b6fb-c71a2e56efde@peersm.com>
Message-ID: <CANPykMq2xCKTVPkQGoRu9iYMdARQKZQq-b5mv3X-7FHKv1FGww@mail.gmail.com>

I propose to require all data to be in the op_return output PLUS add a
required op_return_hash field, which is checked by consensus. So that node
can re-validate the chain without having to store/download/look at the
contents of op_return data. The benefit of that little redundancy is that
"content-sensitive" communities can ignore the date they don't like.

Cheers
Claus

On Thu, Feb 16, 2023 at 7:30 PM Aymeric Vitte via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> It's super unclear how long it could take for such a change to be adopted
>
> Then the answer is simple, see:
> https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7#workaround-to-the-80b-op_return-limitation
>
> Outstandingly, very, mega, bad, but working, bringing bitcoin back 10
> years ago
>
> But why not? If bitcoin folks don't get that we need a 1tx storage
> solution for the future, then let's bring back bitcoin into the past and
> destroy coins
> Le 12/02/2023 ? 17:23, Aymeric Vitte a ?crit :
>
> https://github.com/bitcoin/bitcoin/issues/27043#issuecomment-1427069403
>
> "What is the process to have someone do the PR for this? Or I do it and
> most likely it will be a very shxtty one since I am not a C/C++ expert,
> then wasting the time of everybody
>
> It's urgently required, I did consider OP_RETURN as a dart in the past but
> changed my mind, it's adapted to the current evolutions, not flooding
> bitcoin with 2 txs while only 1 is needed
>
> If not the best 1 tx solution is super simple: store in addresses, and
> super bad at the end because burning bitcoins, while still not expensive if
> you don't need to store big things"
>
> Le 05/02/2023 ? 19:12, Russell O'Connor via bitcoin-dev a ?crit :
>
>
>
> On Sat., Feb. 4, 2023, 21:01 Peter Todd, <pete at petertodd.org> wrote:
>
>>
>>
>> On February 5, 2023 1:11:35 AM GMT+01:00, Russell O'Connor via
>> bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> >Since bytes in the witness are cheaper than bytes in the script pubkey,
>> >there is a crossover point in data size where it will simply be cheaper
>> to
>> >use witness data.  Where that crossover point is depends on the finer
>> >details of the overhead of the two methods, but you could make some
>> >reasonable assumptions.  Such a calculation could form the basis of a
>> >reasonable OP_RETURN proposal.  I don't know if it would be persuasive,
>> but
>> >it would at least be coherent.
>>
>> I don't think it's worth the technical complexity trying to carefully
>> argue a specific limit. Let users decide for themselves how they want to
>> use OpReturn.
>>
>
> Even better.
>
>>
>
> _______________________________________________
> bitcoin-dev mailing listbitcoin-dev at lists.linuxfoundation.orghttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> --
> Sophia-Antipolis, France
> CV: https://www.peersm.com/CVAV.pdf
> LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26
> GitHub : https://www.github.com/Ayms
> A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7
> A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7
> Move your coins by yourself (browser version): https://peersm.com/wallet
> Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
> torrent-live: https://github.com/Ayms/torrent-live
> node-Tor : https://www.github.com/Ayms/node-Tor
> Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com
> Peersm : http://www.peersm.com
>
>
> --
> Sophia-Antipolis, France
> CV: https://www.peersm.com/CVAV.pdf
> LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26
> GitHub : https://www.github.com/Ayms
> A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7
> A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7
> Move your coins by yourself (browser version): https://peersm.com/wallet
> Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
> torrent-live: https://github.com/Ayms/torrent-live
> node-Tor : https://www.github.com/Ayms/node-Tor
> Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com
> Peersm : http://www.peersm.com
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230216/8a0f80cf/attachment.html>

From aymeric at peersm.com  Fri Feb 17 10:56:19 2023
From: aymeric at peersm.com (Aymeric Vitte)
Date: Fri, 17 Feb 2023 11:56:19 +0100
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <CANPykMq2xCKTVPkQGoRu9iYMdARQKZQq-b5mv3X-7FHKv1FGww@mail.gmail.com>
References: <CACrqygAMsO1giYuxm=DZUqfeRjEqGM7msmEnZ-AHws3oA2=aqw@mail.gmail.com>
 <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>
 <57f780b1-f262-9394-036c-70084320e9cf@peersm.com>
 <CACrqygCNf3Gv8+VjhyqS4GTb3Epo8qXEKGtQB6sqyR6ib44-fA@mail.gmail.com>
 <CABE6yHtM2Dqc63_eURSr7dMirJti5sYnqvHj7vQ_Ab9FC_d04g@mail.gmail.com>
 <3d00aacb-585d-f875-784d-34352860d725@peersm.com>
 <CACrqygB_FbsRGWYPSUEFTnP15y94Hmo4JtAuv6bH1D3YtbAw9Q@mail.gmail.com>
 <b292d887-cbd5-165c-de01-793df2b5e8f3@peersm.com>
 <CACrqygAv842ucN7PLYMENXFiSwAZJy2Y+FziJXrWjyCcOXmL3g@mail.gmail.com>
 <230265ee-c3f8-dff3-9192-f0c8dc4d913c@peersm.com>
 <CAMZUoKkAdQ9TSMm4vPJOrThu_h6VbqwPhOQQR7-Yr+WZ0DMBYw@mail.gmail.com>
 <76718304-A8E3-46E6-B2F7-DE86831F15DF@petertodd.org>
 <CAMZUoKnrs-uxnTqpa96B4H86=gAtafowDi0D5HdnExvBWqTqPQ@mail.gmail.com>
 <f5c0abc5-e52f-6d41-c050-bb3ecbeb3986@peersm.com>
 <228e8706-72c7-8d5f-b6fb-c71a2e56efde@peersm.com>
 <CANPykMq2xCKTVPkQGoRu9iYMdARQKZQq-b5mv3X-7FHKv1FGww@mail.gmail.com>
Message-ID: <7e552bc6-6cbd-56d6-934d-6d4578fd03bd@peersm.com>

Hi Claus,

Thanks but I am not sure to understand the solution, how the transaction
will look like and will it be standard ?

Regards

Aymeric


Le 16/02/2023 ? 20:59, Claus Ehrenberg a ?crit :
> I propose to require all data to be in the op_return output PLUS add a
> required op_return_hash field, which is checked by consensus. So that
> node can re-validate the chain without having to store/download/look
> at the contents of op_return data. The benefit of that little
> redundancy is that "content-sensitive" communities can ignore the date
> they don't like.
>
> Cheers
> Claus
>
> On Thu, Feb 16, 2023 at 7:30 PM Aymeric Vitte via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org
> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>
>     It's super unclear how long it could take for such a change to be
>     adopted
>
>     Then the answer is simple, see:
>     https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7#workaround-to-the-80b-op_return-limitation
>
>     Outstandingly, very, mega, bad, but working, bringing bitcoin back
>     10 years ago
>
>     But why not? If bitcoin folks don't get that we need a 1tx storage
>     solution for the future, then let's bring back bitcoin into the
>     past and destroy coins
>
>     Le 12/02/2023 ? 17:23, Aymeric Vitte a ?crit :
>>
>>     https://github.com/bitcoin/bitcoin/issues/27043#issuecomment-1427069403
>>
>>     "What is the process to have someone do the PR for this? Or I do
>>     it and most likely it will be a very shxtty one since I am not a
>>     C/C++ expert, then wasting the time of everybody
>>
>>     It's urgently required, I did consider OP_RETURN as a dart in the
>>     past but changed my mind, it's adapted to the current evolutions,
>>     not flooding bitcoin with 2 txs while only 1 is needed
>>
>>     If not the best 1 tx solution is super simple: store in
>>     addresses, and super bad at the end because burning bitcoins,
>>     while still not expensive if you don't need to store big things"
>>
>>
>>     Le 05/02/2023 ? 19:12, Russell O'Connor via bitcoin-dev a ?crit :
>>>
>>>
>>>     On Sat., Feb. 4, 2023, 21:01 Peter Todd, <pete at petertodd.org
>>>     <mailto:pete at petertodd.org>> wrote:
>>>
>>>
>>>
>>>         On February 5, 2023 1:11:35 AM GMT+01:00, Russell O'Connor
>>>         via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org
>>>         <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>>         >Since bytes in the witness are cheaper than bytes in the
>>>         script pubkey,
>>>         >there is a crossover point in data size where it will
>>>         simply be cheaper to
>>>         >use witness data.  Where that crossover point is depends on
>>>         the finer
>>>         >details of the overhead of the two methods, but you could
>>>         make some
>>>         >reasonable assumptions.  Such a calculation could form the
>>>         basis of a
>>>         >reasonable OP_RETURN proposal.  I don't know if it would be
>>>         persuasive, but
>>>         >it would at least be coherent.
>>>
>>>         I don't think it's worth the technical complexity trying to
>>>         carefully argue a specific limit. Let users decide for
>>>         themselves how they want to use OpReturn.
>>>
>>>
>>>     Even better.
>>>
>>>
>>>
>>>     _______________________________________________
>>>     bitcoin-dev mailing list
>>>     bitcoin-dev at lists.linuxfoundation.org
>>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>     -- 
>>     Sophia-Antipolis, France
>>     CV: https://www.peersm.com/CVAV.pdf
>>     LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26
>>     GitHub : https://www.github.com/Ayms
>>     A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7
>>     A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7
>>     Move your coins by yourself (browser version): https://peersm.com/wallet
>>     Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
>>     torrent-live: https://github.com/Ayms/torrent-live
>>     node-Tor : https://www.github.com/Ayms/node-Tor
>>     Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com
>>     Peersm : http://www.peersm.com
>
>     -- 
>     Sophia-Antipolis, France
>     CV: https://www.peersm.com/CVAV.pdf
>     LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26
>     GitHub : https://www.github.com/Ayms
>     A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7
>     A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7
>     Move your coins by yourself (browser version): https://peersm.com/wallet
>     Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
>     torrent-live: https://github.com/Ayms/torrent-live
>     node-Tor : https://www.github.com/Ayms/node-Tor
>     Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com
>     Peersm : http://www.peersm.com
>
>     _______________________________________________
>     bitcoin-dev mailing list
>     bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

-- 
Sophia-Antipolis, France
CV: https://www.peersm.com/CVAV.pdf
LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26
GitHub : https://www.github.com/Ayms
A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7
A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com
Peersm : http://www.peersm.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230217/e26f5760/attachment-0001.html>

From aj at erisian.com.au  Fri Feb 17 12:49:41 2023
From: aj at erisian.com.au (Anthony Towns)
Date: Fri, 17 Feb 2023 22:49:41 +1000
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <CAMZUoKkAdQ9TSMm4vPJOrThu_h6VbqwPhOQQR7-Yr+WZ0DMBYw@mail.gmail.com>
References: <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>
 <57f780b1-f262-9394-036c-70084320e9cf@peersm.com>
 <CACrqygCNf3Gv8+VjhyqS4GTb3Epo8qXEKGtQB6sqyR6ib44-fA@mail.gmail.com>
 <CABE6yHtM2Dqc63_eURSr7dMirJti5sYnqvHj7vQ_Ab9FC_d04g@mail.gmail.com>
 <3d00aacb-585d-f875-784d-34352860d725@peersm.com>
 <CACrqygB_FbsRGWYPSUEFTnP15y94Hmo4JtAuv6bH1D3YtbAw9Q@mail.gmail.com>
 <b292d887-cbd5-165c-de01-793df2b5e8f3@peersm.com>
 <CACrqygAv842ucN7PLYMENXFiSwAZJy2Y+FziJXrWjyCcOXmL3g@mail.gmail.com>
 <230265ee-c3f8-dff3-9192-f0c8dc4d913c@peersm.com>
 <CAMZUoKkAdQ9TSMm4vPJOrThu_h6VbqwPhOQQR7-Yr+WZ0DMBYw@mail.gmail.com>
Message-ID: <Y+935dALZxEEVMmc@erisian.com.au>

On Sat, Feb 04, 2023 at 07:11:35PM -0500, Russell O'Connor via bitcoin-dev wrote:
> Since bytes in the witness are cheaper than bytes in the script pubkey,
> there is a crossover point in data size where it will simply be cheaper to
> use witness data.

Given today's standardness constraints, that's true (because you first
need to construct a p2wsh/tapscript output that commits to the data,
then you have to spend it), but it needn't stay that way. Allowing a data
carrier entry in the annex (as contemplated for eltoo [0]) would allow
you to publish the data with a single transaction, with malleability
prevented because the annex content is committed to by the signature.

[0] https://github.com/bitcoin-inquisition/bitcoin/pull/22

I think the cost for publishing data via the witness today is roughly:

  115 vb - for the commitment tx
  115 vb + datalen/4 - for the publication tx

versus

  125 vb + datalen - for a tx with an OP_RETURN output

so the crossover point is at a datalen of about 140 bytes. Perhaps
slightly more or less depending on how much you can combine these
inputs/outputs with other txs you would have made anyway.

With a datacarrier in the annex that has similar or higher limits than
OP_RETURN, I don't think OP_RETURN would ever be cheaper.

The other advantage to using the witness for random data compared to
OP_RETURN is that the txid commits to OP_RETURN output, so you must
download all OP_RETURN data to validate a block's merkle tree, whereas
you can partially validate a block (in particular, you can validate the
spendable utxo set) without downloading witness data [1].

[1] https://github.com/bitcoin/bitcoin/pull/27050

Cheers,
aj

From vjudeu at gazeta.pl  Fri Feb 17 14:56:31 2023
From: vjudeu at gazeta.pl (vjudeu at gazeta.pl)
Date: Fri, 17 Feb 2023 15:56:31 +0100
Subject: [bitcoin-dev] Testing censorship resistance of bitcoin p2p
	network
In-Reply-To: <TG0yVn41L6VFOHFRYqd3iGz7mxHWtjFdaBrz8mlP6Uk8bmog_isDbtq_2QyvdUs9_Q-jStmx7V7l5rAesXDfHlK9Ehft7SkK5EWQ_3mg-eQ=@protonmail.com>
Message-ID: <177016307-23dca06637e70217317077657442d0d8@pmq7v.m5r2.onet>

> [0]: https://gist.github.com/luke-jr/4c022839584020444915c84bdd825831

I wonder how far should that rule go: SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS. Because "OP_FALSE OP_IF <anything> OP_ENDIF" is effectively the same as "OP_NOP", and putting NOPs in many places is considered non-standard. The same is true for "OP_TRUE OP_NOTIF <anything> OP_ENDIF", and also there are many variants, where someone could use "OP_FALSE OP_NOT" instead of "OP_TRUE", or check if "2+2==4" by using "OP_2 OP_2 OP_ADD OP_4 OP_EQUAL" (instead of putting "OP_TRUE").

There are endless combinations, and even if there will be a rule to evaluate constant values on the input stack, and put OP_NOP, where any non-empty set of opcodes will evaluate into nothing, then still, there are ways to include spam on-chain. So, the question is: how strict should those rules be?

> "I disapprove of what you say, but I will defend to the death your right to say it."

Yes, I disapprove spamming the blockchain. But because people will rather die than stop it, creating some kind of official alternative is needed. I think most of the time it is not needed to store that data on-chain, all that is needed, is just proving they existed, and that they are connected to a certain transaction (so, it is about timestamping, not about storage).

When it comes to the solution, I think a commitment to a signature should handle all cases. In this way, it can be done for any address type that can support OP_CHECKSIG. To validate such commitment, all that is needed, is converting R-value of a signature into the Taproot address, and then checking if a given commitment matches such key.

> I agree with Peter that, given that users have found ways to store arbitrary amounts of data on-chain if they really want, we might as well just make OP_RETURN a free-for-all.

I think we should go in the opposite direction. Using OP_RETURN means that all nodes will store such data. Using witness means that only witness nodes will keep that. So, if it is already possible to have a node that cannot see witness data, and still remain in the network, I think commitments should be stored only by nodes that will enable them explicitly. So, from that point of view, commitment is "a witness of a signature", it is additional information that can be skipped if needed.

On 2023-02-13 14:08:21 user alicexbt via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> Hi Bitcoin Developers,

There is a famous quote attributed to Evelyn Beatrice Hall in her biography of Voltaire: "I disapprove of what you say, but I will defend to the death your right to say it." I'm curious to know how many Bitcoin developers share this sentiment.

Recently there was a lot of enthusiasm on social media to run bitcoin core with a [patch][0] that would reject some transactions in mempool. Bitcoin Knots already has an option to reject transactions that reuse addresses. What if such practices become common and some projects that provide easy to use node software start censoring transactions? How would government agencies take advantage of this whole drama?

I understand it is difficult to censor different type of transaction because there will be some nodes relaying them and miners including in blocks. It is still important to discuss this and different ways to test censorship resistance.

- Peter Todd had written a [blog post][1] in which counting number of INVs (step 5,6,7 and 8) helps in testing if your transactions are getting relayed by the connected peers. 
- I had tried broadcasting transaction to specific nodes using [libbtc][2]. Based on my understanding it uses GETDATA to confirm your transaction was seen on other nodes after broadcasting.

What would an ideal tool for testing censorship resistance look like?

- Allows user to construct different types of transactions that might be considered "bad" by some people. Example: OFAC address in output, Inscription, OP_RETURN, Address reuse etc.
- Option to broadcast transaction to specific nodes
- Verify if the transaction was relayed successfully or rejected
- Ban such peers using [setban][3] RPC as it would increase the probability of tx getting propagated to miners

There was even some discussion about an [external mempool][4] that could be used for non-standard transactions. It could also help in avoiding censorship in some cases. I welcome your thoughts and feedback on this topic.

[0]: https://gist.github.com/luke-jr/4c022839584020444915c84bdd825831
[1]: https://petertodd.org/2022/bitcoin-core-nodes-running-fullrbf
[2]: https://twitter.com/1440000bytes/status/1574225052240777216
[3]: https://bitcoincore.org/en/doc/24.0.0/rpc/network/setban/
[4]: https://twitter.com/jamesob/status/1623827708168863747

/dev/fd0
floppy disc guy

Sent with Proton Mail secure email.
_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From aj at erisian.com.au  Fri Feb 17 15:51:19 2023
From: aj at erisian.com.au (Anthony Towns)
Date: Sat, 18 Feb 2023 01:51:19 +1000
Subject: [bitcoin-dev] Refreshed BIP324
In-Reply-To: <6b83c32e-59ca-65ef-2553-d66f8d117e56@bip324.com>
References: <56677685-619a-691f-d5bc-54b69fdb6ed2@bip324.com>
 <zxv58iXZ73hf9ge8S0QLTanW-uLzaWjNtMHuKONP9hrqS5RhwitxzfVaMH8hbi3yImgNrKme3lCuDcHYKkpxEQHyGZZHJ8xtReOcnAx3o4g=@wuille.net>
 <Y2nK99fHUKxbPHmw@erisian.com.au>
 <wDqcIVw-YGTsjdf5M2GO9NNRl_UQuBeka2CUQUyQ329u6u-o7RabW_7S4FD3EDfk02kUczb3bXf8LtHhKLtx773UhQ7djKOl-JPOIrXqBSc=@wuille.net>
 <JXfTBjsA71dHE3h9wkxnWXANrwTbMADO4s2w34gEvMbiduKu4PEt5t-KA3EAIz-Xs4urjBHZ15NDFZST2a7e0x_NqyJymUnEORuTp3SNfMs=@wuille.net>
 <Y3dBUXPhTskCx+Fu@erisian.com.au>
 <gSxFQedPc72pTioi9vuxvLKpaRBsnKFL4gkPKPn2G-EJgz_2Y1pYQ7cHD5SnunyCaLln7UQEHIxnopqP74LlnK__Mf9BURbJW8B5MYTZvCU=@wuille.net>
 <Y7dZctMlZtH6PEsz@erisian.com.au> <Y7vMGVQz8TjS4Cad@erisian.com.au>
 <6b83c32e-59ca-65ef-2553-d66f8d117e56@bip324.com>
Message-ID: <Y++id6mXsscfxduH@erisian.com.au>

On Thu, Feb 16, 2023 at 05:43:22PM +0000, Dhruv M via bitcoin-dev wrote:
> Problem:
> - 1 byte message type IDs are lacking a co-ordination mechanism when multiple in-flight BIPs are proposing new message types as the id space is reduced form 12 ASCII bytes to 1 byte.
> - 1 byte IDs are scarce and should be allocated judiciously, especially given that gains on bandwidth are very much non-uniform across message types.

ACK.

> Solutions:
> - Uniform encoding using the high-bit increases the available ID space drastically, however, there's still the issue of making sure that the most frequent message types get the shorter IDs.
> - Making type IDs negotiable(editable, really) per direction per connection solves that issue at the cost of some increased complexity.
> 
> Since we don't really know the extent to which the protocol will ossify over time and that BIP324 is already quite a large change, we might want to optimize for the least additional complexity that doesn't close the doors on any of the solutions. 

I think it's probably less complex to close *some* of the doors?

In particular, I think there's two questions that have to get answered:

 1) how do you distinguish the command from the payload for
    non short-ids -- by a length prefix, or by setting the high-bit
    of the final command byte?

 2) are short ids available/meaningful to send prior to VERACK being
    completed?

> How about this:
> - BIP324 restricts type IDs to [1, 127]

Is this for short ids (currently [13-255] per the bip) or for every byte
in a non-short-id command (for p2p v1, IsCommandValid() restricts each
byte to being in the printable ascii range, ie [32-126])?

Here's another approach:

 idea: we use short ids to minimise bandwidth, and don't care about
       bandwidth for long ids

 implementation:
       short id 0 is reserved for long commands. when received, we
       decode the first 12 bytes of the payload and treat them
       exactly the same as a v1 p2p message (trailing 0-bytes, etc)
       (if there's not 12 bytes of payload, it's just treated as an
       invalid command and dropped)

       short ids 1-255 are available for use as aliases of particular
       long commands

(That's exactly compatible with p2p v1, and also avoids the temptation
to try to choose short command names rather than descriptive ones -- the
0-padding to 12 bytes prevents you from saving any bandwidth that way;
but that's what we have short ids for anyway)

If we decide we want >255 short ids, we can figure out how to extend
them later, in a fairly open ended way I think, eg by having [128-255]
imply a 2 byte short id, so that seems fine?

> - We remove 1 byte allocations for messages that are sent at most once per connection per direction

I think this leaves 32 commands that get short ids initially:

    misc: ADDR, ADDRV2, BLOCK, FEEFILTER, GETBLOCKS, GETDATA, GETHEADERS,
          HEADERS, INV, NOTFOUND, PING, PONG, TX
    bip 35/37: FILTERADD, FILTERCLEAR, FILTERLOAD, MEMPOOL, MERKLEBLOCK
    bip 152: BLOCKTXN, CMPCTBLOCK, GETBLOCKTXN
    bip 157: CFCHECKPT, CFHEADERS, CFILTER, GETCFCHCKPT, GETCFHEADERS,
        GETCFILTERS
    bip 330: RECONCILDIFF, REQRECON, REQSKETCHEXT, SENDCMPCT, SKETCH

which drops:

    VERSION, VERACK, GETADDR, SENDADDRV2, SENDHEADERS, SENDTXRCNCL,
    WTXIDRELAY  

compared to bip 324 currently.

I think the things missing from the current list (and not currently in
use by bitcoin core) are:

    bip 61: REJECT
    bip 331: GETPKGTXNS, PKGTXNS, ANCPKGINFO

> - Optionally, in the implementation we can attempt to move the type id mapping to the p2p layer away from the transport layer. I suspect this could also be done after the implementation is merged but might be cleaner as the mapping is a p2p concern.

I agree that's fine, though I expect that we'll probably want to do it
not long after bip 331 is ready for merge (or some other p2p improvement
comes along)...

Cheers,
aj


From bitcoin-dev at wuille.net  Fri Feb 17 22:13:05 2023
From: bitcoin-dev at wuille.net (Pieter Wuille)
Date: Fri, 17 Feb 2023 22:13:05 +0000
Subject: [bitcoin-dev] Refreshed BIP324
In-Reply-To: <Y++id6mXsscfxduH@erisian.com.au>
References: <56677685-619a-691f-d5bc-54b69fdb6ed2@bip324.com>
 <wDqcIVw-YGTsjdf5M2GO9NNRl_UQuBeka2CUQUyQ329u6u-o7RabW_7S4FD3EDfk02kUczb3bXf8LtHhKLtx773UhQ7djKOl-JPOIrXqBSc=@wuille.net>
 <JXfTBjsA71dHE3h9wkxnWXANrwTbMADO4s2w34gEvMbiduKu4PEt5t-KA3EAIz-Xs4urjBHZ15NDFZST2a7e0x_NqyJymUnEORuTp3SNfMs=@wuille.net>
 <Y3dBUXPhTskCx+Fu@erisian.com.au>
 <gSxFQedPc72pTioi9vuxvLKpaRBsnKFL4gkPKPn2G-EJgz_2Y1pYQ7cHD5SnunyCaLln7UQEHIxnopqP74LlnK__Mf9BURbJW8B5MYTZvCU=@wuille.net>
 <Y7dZctMlZtH6PEsz@erisian.com.au> <Y7vMGVQz8TjS4Cad@erisian.com.au>
 <6b83c32e-59ca-65ef-2553-d66f8d117e56@bip324.com>
 <Y++id6mXsscfxduH@erisian.com.au>
Message-ID: <S1zoL4CCIDVTrjmXx2JtYhO2qjgGyNIAP6X9FXRCRKPDjoQj20VcqKFCYkmmPQkNuMyNf9zp6GFVWWC7l8dBzCogUqvzmDx9D811NPheNJ8=@wuille.net>

On Friday, February 17th, 2023 at 10:51 AM, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> I think it's probably less complex to close some of the doors?
 
> 2) are short ids available/meaningful to send prior to VERACK being
> completed?

Ah, I hadn't considered this nuance. If we don't care about them being available before VERACK negotiation, then it may be possible to introduce a way to negotiate a different short id mapping table without needing a mechanism for *re*-negotiating.

> Here's another approach:
> 
> idea: we use short ids to minimise bandwidth, and don't care about
> bandwidth for long ids
> 
> implementation:
> short id 0 is reserved for long commands. when received, we
> decode the first 12 bytes of the payload and treat them
> exactly the same as a v1 p2p message (trailing 0-bytes, etc)
> (if there's not 12 bytes of payload, it's just treated as an
> invalid command and dropped)
> 
> short ids 1-255 are available for use as aliases of particular
> long commands
> 
> (That's exactly compatible with p2p v1, and also avoids the temptation
> to try to choose short command names rather than descriptive ones -- the
> 0-padding to 12 bytes prevents you from saving any bandwidth that way;
> but that's what we have short ids for anyway)

I like this idea. It avoids the variable-length encoding question and related complexity entirely for things where we admittedly don't care about the bandwidth impact anyway.

It may also have another (rather weak) advantage, in that it may reduce how much information a passive observe may learn about application level features (sendheaders, sendaddrv2, ...) from the packet size sent (which would otherwise depend on command lengths), even when decoys are not in use, if no short commands are included for these messages.

> > - We remove 1 byte allocations for messages that are sent at most once per connection per direction
> 
> I think this leaves 32 commands that get short ids initially:
> 
> misc: ADDR, ADDRV2, BLOCK, FEEFILTER, GETBLOCKS, GETDATA, GETHEADERS,
> HEADERS, INV, NOTFOUND, PING, PONG, TX
> bip 35/37: FILTERADD, FILTERCLEAR, FILTERLOAD, MEMPOOL, MERKLEBLOCK
> bip 152: BLOCKTXN, CMPCTBLOCK, GETBLOCKTXN
> bip 157: CFCHECKPT, CFHEADERS, CFILTER, GETCFCHCKPT, GETCFHEADERS,
> GETCFILTERS
> bip 330: RECONCILDIFF, REQRECON, REQSKETCHEXT, SENDCMPCT, SKETCH

Sounds right.

> which drops:
> 
> VERSION, VERACK, GETADDR, SENDADDRV2, SENDHEADERS, SENDTXRCNCL,
> WTXIDRELAY

Indeed.

> compared to bip 324 currently.
> 
> I think the things missing from the current list (and not currently in
> use by bitcoin core) are:
> 
> bip 61: REJECT
> bip 331: GETPKGTXNS, PKGTXNS, ANCPKGINFO

Do you feel REJECT should be included?

> > - Optionally, in the implementation we can attempt to move the type id mapping to the p2p layer away from the transport layer. I suspect this could also be done after the implementation is merged but might be cleaner as the mapping is a p2p concern.
>
> I agree that's fine, though I expect that we'll probably want to do it
> not long after bip 331 is ready for merge (or some other p2p improvement
> comes along)...

I do prefer that as well; it feels like the transport layer shouldn't be aware of the different command names that exist, but this is very much just an implementation issue.

Perhaps a possibility is having the transport layer translate short-command-number-N to the 12-byte command "\x00\x00..." + byte(N), and hand that to the application layer, which could then do the mapping?

Cheers,

-- 
Pieter


From apoelstra at wpsoftware.net  Fri Feb 17 23:35:34 2023
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Fri, 17 Feb 2023 23:35:34 +0000
Subject: [bitcoin-dev] Testing censorship resistance of bitcoin p2p
 network
In-Reply-To: <177016307-23dca06637e70217317077657442d0d8@pmq7v.m5r2.onet>
References: <TG0yVn41L6VFOHFRYqd3iGz7mxHWtjFdaBrz8mlP6Uk8bmog_isDbtq_2QyvdUs9_Q-jStmx7V7l5rAesXDfHlK9Ehft7SkK5EWQ_3mg-eQ=@protonmail.com>
 <177016307-23dca06637e70217317077657442d0d8@pmq7v.m5r2.onet>
Message-ID: <Y/APRs3IPYapIpGg@camus>

On Fri, Feb 17, 2023 at 03:56:31PM +0100, vjudeu via bitcoin-dev wrote:
> > [0]: https://gist.github.com/luke-jr/4c022839584020444915c84bdd825831
> 
> I wonder how far should that rule go: SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS. Because "OP_FALSE OP_IF <anything> OP_ENDIF" is effectively the same as "OP_NOP", and putting NOPs in many places is considered non-standard. The same is true for "OP_TRUE OP_NOTIF <anything> OP_ENDIF", and also there are many variants, where someone could use "OP_FALSE OP_NOT" instead of "OP_TRUE", or check if "2+2==4" by using "OP_2 OP_2 OP_ADD OP_4 OP_EQUAL" (instead of putting "OP_TRUE").
>

If you ban any of these specific script fragments then spammers will
just use `IF <anything> ENDIF` and provide the `FALSE` as a zero push.
And banning *this* would ban legitimate use cases.

You could try statically analyze `<anything>` to determine whether the
IF branch could ever be taken. For example there is no path through
the "inscription script" that would result in all the crap being dropped
by the end of the script, violating the CLEANSTACK rule.

This sort of filtering, assuming it could be reliably and efficiently
done, would at least force inscription scripts to be "plausible", and
would greatly increase their space cost by e.g. requiring OP_DROP to be
added somewhere hundreds of times.

-- 
Andrew Poelstra
Director of Research, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

The sun is always shining in space
    -Justin Lewis-Webster

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230217/c02a60b1/attachment-0001.sig>

From apoelstra at wpsoftware.net  Fri Feb 17 23:39:11 2023
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Fri, 17 Feb 2023 23:39:11 +0000
Subject: [bitcoin-dev] Testing censorship resistance of bitcoin p2p
 network
In-Reply-To: <Y/APRs3IPYapIpGg@camus>
References: <TG0yVn41L6VFOHFRYqd3iGz7mxHWtjFdaBrz8mlP6Uk8bmog_isDbtq_2QyvdUs9_Q-jStmx7V7l5rAesXDfHlK9Ehft7SkK5EWQ_3mg-eQ=@protonmail.com>
 <177016307-23dca06637e70217317077657442d0d8@pmq7v.m5r2.onet>
 <Y/APRs3IPYapIpGg@camus>
Message-ID: <Y/AQH9s7RN14uKvE@camus>

On Fri, Feb 17, 2023 at 11:35:34PM +0000, Andrew Poelstra via bitcoin-dev wrote:
> 
> If you ban any of these specific script fragments then spammers will
> just use `IF <anything> ENDIF` and provide the `FALSE` as a zero push.
> And banning *this* would ban legitimate use cases.
>

I realize this is confusingly worded. I mean, they'd provide the `FALSE`
as a separate witness element rather than being part of the witnessScript.




-- 
Andrew Poelstra
Director of Research, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

The sun is always shining in space
    -Justin Lewis-Webster

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230217/ac844572/attachment.sig>

From pete at petertodd.org  Sat Feb 18 00:03:15 2023
From: pete at petertodd.org (Peter Todd)
Date: Sat, 18 Feb 2023 02:03:15 +0200
Subject: [bitcoin-dev] Testing censorship resistance of bitcoin p2p
	network
In-Reply-To: <Y/APRs3IPYapIpGg@camus>
References: <TG0yVn41L6VFOHFRYqd3iGz7mxHWtjFdaBrz8mlP6Uk8bmog_isDbtq_2QyvdUs9_Q-jStmx7V7l5rAesXDfHlK9Ehft7SkK5EWQ_3mg-eQ=@protonmail.com>
 <177016307-23dca06637e70217317077657442d0d8@pmq7v.m5r2.onet>
 <Y/APRs3IPYapIpGg@camus>
Message-ID: <B837E586-894E-40E8-9814-385EF59402B6@petertodd.org>



On February 18, 2023 1:35:34 AM GMT+02:00, Andrew Poelstra via bitcoin-dev 
>You could try statically analyze `<anything>` to determine whether the
>IF branch could ever be taken. For example there is no path through
>the "inscription script" that would result in all the crap being dropped
>by the end of the script, violating the CLEANSTACK rule.
>
>This sort of filtering, assuming it could be reliably and efficiently
>done, would at least force inscription scripts to be "plausible", and
>would greatly increase their space cost by e.g. requiring OP_DROP to be
>added somewhere hundreds of times.

"greatly increase their space cost"?

Tell me, what is the actual % increase to adding OP_DROPs like you propose?

From apoelstra at wpsoftware.net  Sat Feb 18 01:28:38 2023
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Sat, 18 Feb 2023 01:28:38 +0000
Subject: [bitcoin-dev] Testing censorship resistance of bitcoin p2p
 network
In-Reply-To: <B837E586-894E-40E8-9814-385EF59402B6@petertodd.org>
References: <TG0yVn41L6VFOHFRYqd3iGz7mxHWtjFdaBrz8mlP6Uk8bmog_isDbtq_2QyvdUs9_Q-jStmx7V7l5rAesXDfHlK9Ehft7SkK5EWQ_3mg-eQ=@protonmail.com>
 <177016307-23dca06637e70217317077657442d0d8@pmq7v.m5r2.onet>
 <Y/APRs3IPYapIpGg@camus>
 <B837E586-894E-40E8-9814-385EF59402B6@petertodd.org>
Message-ID: <Y/Apxhqij1v56dT8@camus>

On Sat, Feb 18, 2023 at 02:03:15AM +0200, Peter Todd wrote:
> On February 18, 2023 1:35:34 AM GMT+02:00, Andrew Poelstra via bitcoin-dev 
> >You could try statically analyze `<anything>` to determine whether the
> >IF branch could ever be taken. For example there is no path through
> >the "inscription script" that would result in all the crap being dropped
> >by the end of the script, violating the CLEANSTACK rule.
> >
> >This sort of filtering, assuming it could be reliably and efficiently
> >done, would at least force inscription scripts to be "plausible", and
> >would greatly increase their space cost by e.g. requiring OP_DROP to be
> >added somewhere hundreds of times.
> 
> "greatly increase their space cost"?
> 
> Tell me, what is the actual % increase to adding OP_DROPs like you propose?
>

By standardness rules (where you can have up to 80-byte pushes), a
little over 1%. By consensus (520-byte pushes) less than 0.2%.

Perhaps "greatly increase" is a stretch :) but if the fee market is
functioning and we're talking about large amounts of data, it's not
trivial either.

-- 
Andrew Poelstra
Director of Research, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

The sun is always shining in space
    -Justin Lewis-Webster

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230218/dcd75895/attachment.sig>

From vjudeu at gazeta.pl  Sat Feb 18 09:48:02 2023
From: vjudeu at gazeta.pl (vjudeu at gazeta.pl)
Date: Sat, 18 Feb 2023 10:48:02 +0100
Subject: [bitcoin-dev] Testing censorship resistance of bitcoin p2p
 network
In-Reply-To: <Y/AQH9s7RN14uKvE@camus>
Message-ID: <177848612-ad2b15230d78bcd732bbe8621af89a1e@pmq3v.m5r2.onet>

> By standardness rules (where you can have up to 80-byte pushes), a little over 1%. By consensus (520-byte pushes) less than 0.2%.

Note that instead of "OP_DROP OP_DROP", people can use "OP_2DROP", so the number of dropping opcodes could be halved.

> I mean, they'd provide the `FALSE` as a separate witness element rather than being part of the witnessScript.

That means people can still reject an official alternative (for example commitments), so a different approach is needed to fight that spam. Assuming that transactions will be sent directly to the miners, they will be included, that way or another. So, the solution should assume that we will have large NOPs in the chain. And then, if we want to deal with them, some kind of pruning is needed. Switching from witness to non-witness node is not an option, because it would require additional witness validation, and because rules for OP_RETURN can be also lifted.

So, how to prune the Script? In a typical hash function, like SHA-256, data are splitted into smaller chunks, and then processed linearly. I think it is possible to store the first and the last chunk, and keep the internal state of SHA-256, before entering the last chunk. In this way, it should be possible to prune those OP_NOPs. Because that solution will also cover raw scripts (people can switch to them if witness will be more restricted than now).

Also, it gives us a hint, that if any Script upgrade will be considered in the future, we can think about doing it in a way, where unused parts can be pruned, without invalidating signatures.

On 2023-02-18 00:39:16 user Andrew Poelstra <apoelstra at wpsoftware.net> wrote:
> On Fri, Feb 17, 2023 at 11:35:34PM +0000, Andrew Poelstra via bitcoin-dev wrote:
> 
> If you ban any of these specific script fragments then spammers will
> just use `IF <anything> ENDIF` and provide the `FALSE` as a zero push.
> And banning *this* would ban legitimate use cases.
>

I realize this is confusingly worded. I mean, they'd provide the `FALSE`
as a separate witness element rather than being part of the witnessScript.




-- 
Andrew Poelstra
Director of Research, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

The sun is always shining in space
    -Justin Lewis-Webster

From roconnor at blockstream.com  Sat Feb 18 18:03:45 2023
From: roconnor at blockstream.com (Russell O'Connor)
Date: Sat, 18 Feb 2023 13:03:45 -0500
Subject: [bitcoin-dev] Testing censorship resistance of bitcoin p2p
	network
In-Reply-To: <177848612-ad2b15230d78bcd732bbe8621af89a1e@pmq3v.m5r2.onet>
References: <Y/AQH9s7RN14uKvE@camus>
 <177848612-ad2b15230d78bcd732bbe8621af89a1e@pmq3v.m5r2.onet>
Message-ID: <CAMZUoKmTNQd9k0h2T2Vv0Nn2M4JEvAo9NC7FL5EdJ+45KL4VSA@mail.gmail.com>

On Sat, Feb 18, 2023 at 5:11 AM vjudeu via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> Also, it gives us a hint, that if any Script upgrade will be considered in
> the future, we can think about doing it in a way, where unused parts can be
> pruned, without invalidating signatures.
>

FWIW, pruning unused case branches is a core design principle of the
Simplicity language I am developing.

That being said, even this is not enough to thwart agents that specifically
desire to post unused data blobs as part of their programs.  This is
largely because there are many mathematical expressions for what is
equivalently an identity function.  Think computing (x ^ 257) mod 257 (see
Fermat's little theorem).

Even in Simplicity users can write Word *<some data blob>*; unit which is
roughly equivalent PUSH *<data blob>* DROP in Script.  I don't even bother
trying to prevent it.  Doing so just adds more consensus complexity, and
only raises the bar slightly on how to work around it.

Simplicity's pruning is instead meant as a way to (usually) lower costs for
users who aren't actively trying to spam the network.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230218/2db79aa2/attachment.html>

From aymeric at peersm.com  Sat Feb 18 18:38:00 2023
From: aymeric at peersm.com (Aymeric Vitte)
Date: Sat, 18 Feb 2023 19:38:00 +0100
Subject: [bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE
 OP_IF OP_PUSH
In-Reply-To: <Y+935dALZxEEVMmc@erisian.com.au>
References: <ca8622cb-445e-4258-bbac-b3ee1ce95f4c@protonmail.com>
 <57f780b1-f262-9394-036c-70084320e9cf@peersm.com>
 <CACrqygCNf3Gv8+VjhyqS4GTb3Epo8qXEKGtQB6sqyR6ib44-fA@mail.gmail.com>
 <CABE6yHtM2Dqc63_eURSr7dMirJti5sYnqvHj7vQ_Ab9FC_d04g@mail.gmail.com>
 <3d00aacb-585d-f875-784d-34352860d725@peersm.com>
 <CACrqygB_FbsRGWYPSUEFTnP15y94Hmo4JtAuv6bH1D3YtbAw9Q@mail.gmail.com>
 <b292d887-cbd5-165c-de01-793df2b5e8f3@peersm.com>
 <CACrqygAv842ucN7PLYMENXFiSwAZJy2Y+FziJXrWjyCcOXmL3g@mail.gmail.com>
 <230265ee-c3f8-dff3-9192-f0c8dc4d913c@peersm.com>
 <CAMZUoKkAdQ9TSMm4vPJOrThu_h6VbqwPhOQQR7-Yr+WZ0DMBYw@mail.gmail.com>
 <Y+935dALZxEEVMmc@erisian.com.au>
Message-ID: <26619d50-669d-1a7d-82cb-c7de8795dc92@peersm.com>

So with datacarrier we can store data in taproot annex with one tx which
will be data and/or extension of the script validation via PUSH_ANNEX

I looked at your links and plenty of others, but had some hard time to
find the proposal
(https://github.com/bitcoin/bips/blob/9dc3f74b384f143b7f1bdad30dc0fe2529c8e63f/bip-annex.mediawiki
I suppose), when do you think datacarrier can happen for real on the
network?

Now I think the OP_RETURN debate remains relevant, it's a quite trivial
modification to do, from my standpoint it is certainly not intended to
store big things (but 80B, what do you want to do with this?), but if
people want to store big things and pay for it... what is the real
issue? (I saw your argument of "partial" block validation and others
like skipping witness data, at the end nodes must validate the whole thing)


Le 17/02/2023 ? 13:49, Anthony Towns a ?crit :
> On Sat, Feb 04, 2023 at 07:11:35PM -0500, Russell O'Connor via bitcoin-dev wrote:
>> Since bytes in the witness are cheaper than bytes in the script pubkey,
>> there is a crossover point in data size where it will simply be cheaper to
>> use witness data.
> Given today's standardness constraints, that's true (because you first
> need to construct a p2wsh/tapscript output that commits to the data,
> then you have to spend it), but it needn't stay that way. Allowing a data
> carrier entry in the annex (as contemplated for eltoo [0]) would allow
> you to publish the data with a single transaction, with malleability
> prevented because the annex content is committed to by the signature.
>
> [0] https://github.com/bitcoin-inquisition/bitcoin/pull/22
>
> I think the cost for publishing data via the witness today is roughly:
>
>   115 vb - for the commitment tx
>   115 vb + datalen/4 - for the publication tx
>
> versus
>
>   125 vb + datalen - for a tx with an OP_RETURN output
>
> so the crossover point is at a datalen of about 140 bytes. Perhaps
> slightly more or less depending on how much you can combine these
> inputs/outputs with other txs you would have made anyway.
>
> With a datacarrier in the annex that has similar or higher limits than
> OP_RETURN, I don't think OP_RETURN would ever be cheaper.
>
> The other advantage to using the witness for random data compared to
> OP_RETURN is that the txid commits to OP_RETURN output, so you must
> download all OP_RETURN data to validate a block's merkle tree, whereas
> you can partially validate a block (in particular, you can validate the
> spendable utxo set) without downloading witness data [1].
>
> [1] https://github.com/bitcoin/bitcoin/pull/27050
>
> Cheers,
> aj

-- 
Sophia-Antipolis, France
CV: https://www.peersm.com/CVAV.pdf
LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26
GitHub : https://www.github.com/Ayms
A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7
A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com
Peersm : http://www.peersm.com



From alicexbt at protonmail.com  Sun Feb 19 00:33:11 2023
From: alicexbt at protonmail.com (alicexbt)
Date: Sun, 19 Feb 2023 00:33:11 +0000
Subject: [bitcoin-dev] Testing censorship resistance of bitcoin p2p
	network
In-Reply-To: <177016307-23dca06637e70217317077657442d0d8@pmq7v.m5r2.onet>
References: <177016307-23dca06637e70217317077657442d0d8@pmq7v.m5r2.onet>
Message-ID: <T-fJqnql1ZDCPF95PkotBhXswPgfI84UZYUwin4pNTFbWFn5iXPoWX8uvVk8-Mok0VuUqtLONhNqQy5TRSOwwaxaLz_rpReFO9W2Hl6osE0=@protonmail.com>

Hi vjudeu,

Before I respond to your email, I would like to share the [python script][0] that could be used to do 3 things:

1) List peers
2) Broadcast a transaction to peers and see if it was relayed
3) Ban peers that did not relay your transaction

The primary goal of this script is testing however it can be used by anyone as it does not make sense to waste resources connecting to peers that do not relay your transactions. There is another [solution][1] for users to ensure all transactions get relayed properly.

Note: There could be some false positives and it mainly uses libbtc

> Yes, I disapprove spamming the blockchain. But because people will rather die than stop it, creating some kind of official alternative is needed. I think most of the time it is not needed to store that data on-chain, all that is needed, is just proving they existed, and that they are connected to a certain transaction (so, it is about timestamping, not about storage).

Why do you think people don't stop and willing to pay for inscribing something on-chain although it could be done for free using BitTorrent? As far as 'spam' is concerned these are bitcoin transactions until you open ordinals explorer or believe in ordinals theory to track the ownership of inscription. There are some bitcoin transactions that I could consider spam and have no interest in keeping them on my disk. However I believe people should be free to do anything with their money and I don't care about the content or intent of any bitcoin transaction as long as its valid, paid fee etc. (except vulnerability) Blocks cannot exceed their limit and I was prepared for a fee market with new limits since segwit got activated.

Here's my opinion why people don't stop doing it and we could always disagree:

Money or financial transactions have been done differently in countries, cultures, communities etc. across the world. People have done inscriptions on paper money issued by governments for graffiti, political, personal or other reasons. Since years inscriptions have been on different types of [coins][2]. Example: Jahangir issued many gold and silver [coins with poetic verses][3] on them and was the only Mughal emperor to bestow the right of coinage to his royal consort.

Some positives of inscriptions that I have observed in last couple of weeks:

- More users interested in running full nodes (non-pruned) and trying bitcoin wallets, lightning etc.
- Taproot usage increased
- More developers interested in learning bitcoin development and looking for libraries, docs etc.
- Demand for block space has increased
- ~50 BTC paid in fees to miners for creating inscriptions until now

It creates more opportunities for bitcoin developers and everyone involved in bitcoin.

[0]: https://ordinals.com/content/f39b5f0a9e9af05da03ab0c52a407972b9678e8db80160febd6bd899acebe141i0
[1]: https://github.com/casey/ord/pull/1783
[2]: https://en.wikipedia.org/wiki/Coinage_of_India
[3]: https://web.archive.org/web/20180705070913/https://www.mintageworld.com/blog/coins-of-jahangir/


/dev/fd0
floppy disk guy

Sent with Proton Mail secure email.

------- Original Message -------
On Friday, February 17th, 2023 at 8:26 PM, vjudeu via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:


> 
> I wonder how far should that rule go: SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS. Because "OP_FALSE OP_IF <anything> OP_ENDIF" is effectively the same as "OP_NOP", and putting NOPs in many places is considered non-standard. The same is true for "OP_TRUE OP_NOTIF <anything> OP_ENDIF", and also there are many variants, where someone could use "OP_FALSE OP_NOT" instead of "OP_TRUE", or check if "2+2==4" by using "OP_2 OP_2 OP_ADD OP_4 OP_EQUAL" (instead of putting "OP_TRUE").
> 
> 
> There are endless combinations, and even if there will be a rule to evaluate constant values on the input stack, and put OP_NOP, where any non-empty set of opcodes will evaluate into nothing, then still, there are ways to include spam on-chain. So, the question is: how strict should those rules be?
> 
> > "I disapprove of what you say, but I will defend to the death your right to say it."
> 
> 
> Yes, I disapprove spamming the blockchain. But because people will rather die than stop it, creating some kind of official alternative is needed. I think most of the time it is not needed to store that data on-chain, all that is needed, is just proving they existed, and that they are connected to a certain transaction (so, it is about timestamping, not about storage).
> 
> When it comes to the solution, I think a commitment to a signature should handle all cases. In this way, it can be done for any address type that can support OP_CHECKSIG. To validate such commitment, all that is needed, is converting R-value of a signature into the Taproot address, and then checking if a given commitment matches such key.
> 
> > I agree with Peter that, given that users have found ways to store arbitrary amounts of data on-chain if they really want, we might as well just make OP_RETURN a free-for-all.
> 
> 
> I think we should go in the opposite direction. Using OP_RETURN means that all nodes will store such data. Using witness means that only witness nodes will keep that. So, if it is already possible to have a node that cannot see witness data, and still remain in the network, I think commitments should be stored only by nodes that will enable them explicitly. So, from that point of view, commitment is "a witness of a signature", it is additional information that can be skipped if needed.
> 
> On 2023-02-13 14:08:21 user alicexbt via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:
> 
> > Hi Bitcoin Developers,
> 
> 
> There is a famous quote attributed to Evelyn Beatrice Hall in her biography of Voltaire: "I disapprove of what you say, but I will defend to the death your right to say it." I'm curious to know how many Bitcoin developers share this sentiment.
> 
> Recently there was a lot of enthusiasm on social media to run bitcoin core with a patch that would reject some transactions in mempool. Bitcoin Knots already has an option to reject transactions that reuse addresses. What if such practices become common and some projects that provide easy to use node software start censoring transactions? How would government agencies take advantage of this whole drama?
> 
> I understand it is difficult to censor different type of transaction because there will be some nodes relaying them and miners including in blocks. It is still important to discuss this and different ways to test censorship resistance.
> 
> - Peter Todd had written a [blog post][1] in which counting number of INVs (step 5,6,7 and 8) helps in testing if your transactions are getting relayed by the connected peers.
> - I had tried broadcasting transaction to specific nodes using [libbtc][2]. Based on my understanding it uses GETDATA to confirm your transaction was seen on other nodes after broadcasting.
> 
> What would an ideal tool for testing censorship resistance look like?
> 
> - Allows user to construct different types of transactions that might be considered "bad" by some people. Example: OFAC address in output, Inscription, OP_RETURN, Address reuse etc.
> - Option to broadcast transaction to specific nodes
> - Verify if the transaction was relayed successfully or rejected
> - Ban such peers using [setban][3] RPC as it would increase the probability of tx getting propagated to miners
> 
> There was even some discussion about an [external mempool][4] that could be used for non-standard transactions. It could also help in avoiding censorship in some cases. I welcome your thoughts and feedback on this topic.
> 
> 0: https://gist.github.com/luke-jr/4c022839584020444915c84bdd825831
> [1]: https://petertodd.org/2022/bitcoin-core-nodes-running-fullrbf
> [2]: https://twitter.com/1440000bytes/status/1574225052240777216
> [3]: https://bitcoincore.org/en/doc/24.0.0/rpc/network/setban/
> [4]: https://twitter.com/jamesob/status/1623827708168863747
> 
> /dev/fd0
> floppy disc guy
> 
> Sent with Proton Mail secure email.
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From dave at dtrt.org  Sun Feb 19 20:13:33 2023
From: dave at dtrt.org (David A. Harding)
Date: Sun, 19 Feb 2023 10:13:33 -1000
Subject: [bitcoin-dev] Codex32
In-Reply-To: <Y+40gVnMpj0prfQk@camus>
References: <CAMZUoKmiwXW50F2onqNUZO8HXQa4+Z=z3s3WyN7-rAMV=KiSgw@mail.gmail.com>
 <CAF90AvmaRYO6HKn9npyfzO6M6FZnN6DRhqopLpeSnHJNK=5i9g@mail.gmail.com>
 <Y+40gVnMpj0prfQk@camus>
Message-ID: <f19acdabd3fbc0ff389669131acbb79e@dtrt.org>

On 2023-02-16 03:49, Andrew Poelstra via bitcoin-dev wrote:
> the draft lists several benefits over SLIP-0039.

The only benefit over SLIP39 that I see explicitly mentioned in the
draft BIP is "simple enough for hand computation".  In the FAQ[1] on the
project's website, I see some additional reasons:

| This scheme is essentially the same as SLIP39, with the following 
differences:
|
| - The checksum is longer, slightly stronger, and designed to be
|   computable by hand.
|
| - Our encoding is more compact, giving us room for a bit of more
|   metadata, which is also designed to be readable by hand.
|
| - Unlike SLIP39, we do not support passphrases or hardening of any
|   form.
|
| - Unlike SLIP39, we have no hardware wallet support. But we hope that
|   will change!

 From having perused the extended documentation myself, I think I would
personally note the following differences.

- Alphabet: Codex32 uses the bech32 alphabet rather than SLIP39's
   alphabet consisting of English words.  The benefit to human-language
   words is easier memorization for those proficient in the particular
   language (in this case, SLIP39 only allows the use of English).  A
   disadvantage, IMO, is that it encourages the practice of memorization
   (which does have a few advantages but also a lot of drawbacks).

   Interestingly, Codex32 addresses what I think is the main problems of
   memorization: difficult-to-prove successful recollection.  Someone who
   wants to reliably keep seed-related material only in their head
   needs to practice recalling it on a regular basis, but for BIP39,
   SLIP39, Aezeed, etc... there's no way for them to confirm they
   successfully recalled it short of going through the entire recovery
   process; they probably just judge how confident they feel about the
   recollection and assume that feeling like they recalled it correctly
   is the same thing as recalling it correctly.

   Codex32 allows the individual to periodically perform their
   recollection on paper in a private room without electronics and use
   nothing but a pen and some loookup tables (or a paper device) to
   verify that they recalled the string correctly (and its checksum can
   help with correcting up to several errors, although you might need a
   computer for error location and correction assistance).

- Hierarchy: Codex32 does not natively provide support for nested SSSS
   whereas SLIP39 does.  E.g., in SLIP39, you can require 2-of-3 for
   {me, family, friends} where me is 2-of-3 {fire_safe, bank_safe,
   buried_in_woods}, family is 1-of-3 {alice, bob, carol}, and friends
   are 2-of-5 {d, e, f, g, h}.  I assume you can do the same with Codex32
   by using the share for one level as the secret for the next level,
   although this is not described in the protocol.

- Versioning: Codex32's metadata can store version information for
   wallets that use implicit BIP32 paths (e.g. BIP44/49/84/86), although
   this would cut into the space available for users to set their own
   metadata and it is not specified in the draft BIP.  SLIP39 also
   doesn't specify anything about implicit path versioning and, AFAICT,
   doesn't have any room to store such metadata without reducing seed
   entropy.

- Plausible deniability dummy wallets: Codex32 doesn't support this;
   SLIP39 does.  Much has been written by other people about whether
   dummy wallets are a good idea or not, with strong opinions on both
   sides, so maybe we can just leave it at that.

---

When I first saw the post about this, it was unclear to me that it was a
serious project, but I've become increasingly interested as I researched
it.  I'm not personally that interested in generating entropy from dice
or encoding shares by hand---it's already imperative that I acquire a
trustworthy computer and load it with trustworthy software in order to
use my seed securely, so I might as well have it generate my seeds and 
my
recovery codes for me.

What really did catch my attention, but which was kind of buried in the
project documentation, is the ability to verify the integrity of each
share independently without using a computer.  For example, if I store a
share with some relative who lives thousands of kilometers away, I'll be
able to take that share out of its tamper-evident bag on my annual
holiday visit, verify that I can still read it accurately by validating
its checksum, and put it into a new bag for another year.  For this
procedure, I don't need to bring copies of any of my other shares,
allowing them (and my seed) to stay safe.

---

I do have one question after watching an excellent video[2] about the
motivation for this system.  In the video, one of the threat models
described is a disarrangement of the words in a metal backup system.
The implication seems to be that this would be an accidental
disarrangement, which obviously the Codex32 checksum would catch during
periodic offline verification.  But what about deliberate modification
of a recovery code?  For example, Bob doesn't keep his seed loaded on
any computer; it only exists in Codex32 shares which Bob plans to
combine together in 20 years when he retires, although he makes regular
deposits to the pubkeys derived from the seed's master xpub.  Mallory is
able to obtain access to Bob's shares, allowing her to immediately steal
his current funds---but also allowing her to replace them with 
similar-looking
shares with the same metadata and valid checksums so that Bob
continues making deposits to the wallet.

I'm curious about whether there's a way to prevent this attack without
otherwise compromising the properties of the code?  For example, some
extra data that Bob can carry around (or memorize) for verifying the
shares haven't changed, but which is not otherwise needed for recovery
(so there's no problem if it's lost).

Thanks,

-Dave

[1] https://secretcodex32.com/faq/index.html
[2] 
https://www.youtube.com/watch?v=kf48oPoiHX0&list=PLyOGyBytgcuQLi9DC5g88DOEGnqBDPmq1&index=2

From apoelstra at wpsoftware.net  Sun Feb 19 22:12:51 2023
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Sun, 19 Feb 2023 22:12:51 +0000
Subject: [bitcoin-dev] Codex32
In-Reply-To: <f19acdabd3fbc0ff389669131acbb79e@dtrt.org>
References: <CAMZUoKmiwXW50F2onqNUZO8HXQa4+Z=z3s3WyN7-rAMV=KiSgw@mail.gmail.com>
 <CAF90AvmaRYO6HKn9npyfzO6M6FZnN6DRhqopLpeSnHJNK=5i9g@mail.gmail.com>
 <Y+40gVnMpj0prfQk@camus>
 <f19acdabd3fbc0ff389669131acbb79e@dtrt.org>
Message-ID: <Y/Ke4yV7eV/87Kat@camus>

On Sun, Feb 19, 2023 at 10:13:33AM -1000, David A. Harding wrote:
> On 2023-02-16 03:49, Andrew Poelstra via bitcoin-dev wrote:
> > the draft lists several benefits over SLIP-0039.
> 
> The only benefit over SLIP39 that I see explicitly mentioned in the
> draft BIP is "simple enough for hand computation".  In the FAQ[1] on the
> project's website, I see some additional reasons:
>

Oh, you're right! I think we removed this text in one of our revisions.
I'll see if it makes sense to put it back.

> | This scheme is essentially the same as SLIP39, with the following
> differences:
> |
> | - The checksum is longer, slightly stronger, and designed to be
> |   computable by hand.
> |
> | - Our encoding is more compact, giving us room for a bit of more
> |   metadata, which is also designed to be readable by hand.
> |
> | - Unlike SLIP39, we do not support passphrases or hardening of any
> |   form.
> |
> | - Unlike SLIP39, we have no hardware wallet support. But we hope that
> |   will change!
> 

These are roughly the benefits -- a more compact encoding which is
always a fixed width. We also list "not supporting features such as
passphrases" as a benefit, for users who don't need/want this.

> <snip>
> 
> When I first saw the post about this, it was unclear to me that it was a
> serious project, but I've become increasingly interested as I researched
> it.  I'm not personally that interested in generating entropy from dice
> or encoding shares by hand---it's already imperative that I acquire a
> trustworthy computer and load it with trustworthy software in order to
> use my seed securely, so I might as well have it generate my seeds and my
> recovery codes for me.
>

Yes, we've been a bit coy about how serious this project is, because on
its face it's such a silly thing. But for my part, I've been using it
for real coins for over a year and I consider it to be serious.

> What really did catch my attention, but which was kind of buried in the
> project documentation, is the ability to verify the integrity of each
> share independently without using a computer.  For example, if I store a
> share with some relative who lives thousands of kilometers away, I'll be
> able to take that share out of its tamper-evident bag on my annual
> holiday visit, verify that I can still read it accurately by validating
> its checksum, and put it into a new bag for another year.  For this
> procedure, I don't need to bring copies of any of my other shares,
> allowing them (and my seed) to stay safe.
> 

This is good feedback. I strongly agree that this is the big selling
point for this -- that you can vet shares/seeds which *aren't* being
actively used, without exposing them to the sorts of threats associated
with active use.

We should make this more prominent in the BIP motivation.

> 
> I do have one question after watching an excellent video[2] about the
> motivation for this system.  In the video, one of the threat models
> described is a disarrangement of the words in a metal backup system.
> The implication seems to be that this would be an accidental
> disarrangement, which obviously the Codex32 checksum would catch during
> periodic offline verification.  But what about deliberate modification
> of a recovery code?  For example, Bob doesn't keep his seed loaded on
> any computer; it only exists in Codex32 shares which Bob plans to
> combine together in 20 years when he retires, although he makes regular
> deposits to the pubkeys derived from the seed's master xpub.  Mallory is
> able to obtain access to Bob's shares, allowing her to immediately steal
> his current funds---but also allowing her to replace them with
> similar-looking
> shares with the same metadata and valid checksums so that Bob
> continues making deposits to the wallet.
> 
> I'm curious about whether there's a way to prevent this attack without
> otherwise compromising the properties of the code?  For example, some
> extra data that Bob can carry around (or memorize) for verifying the
> shares haven't changed, but which is not otherwise needed for recovery
> (so there's no problem if it's lost).
>

Unfortunately not, as near as I can tell ... one way to think of this is
that Alice can flip a lot of random tiles then "error correct" it to get
a new valid, but incorrect, seed. So as long as we support error
correction it'll be possible to wreck seeds in this way.

It's actually even worse than this ... as long as there's a clearly
defined "checksum" at the end of a share, Alice will be able to mangele
tiles and then just re-compute the checksum at the end.

So what we really need to prevent this is something like a MAC: where
Bob has a secret value which gets input into the checksum somehow, which
Alice can't create valid checksums without knowing. Unfortunately I
don't see any way to do this with linear codes. With a hash-based
"checksum" a la BIP39 it would definitely be possible, but of course,
not hand-computable.

BTW, to execute this attack Alice doesn't need to compromise *all* the
shares. Just enough that Bob no longer has threshold-many un-tampered
ones left.

-- 
Andrew Poelstra
Director of Research, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

The sun is always shining in space
    -Justin Lewis-Webster

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230219/56f6c656/attachment-0001.sig>

From ChristopherA at lifewithalacrity.com  Sun Feb 19 23:05:12 2023
From: ChristopherA at lifewithalacrity.com (Christopher Allen)
Date: Sun, 19 Feb 2023 15:05:12 -0800
Subject: [bitcoin-dev] Codex32
In-Reply-To: <Y/Ke4yV7eV/87Kat@camus>
References: <CAMZUoKmiwXW50F2onqNUZO8HXQa4+Z=z3s3WyN7-rAMV=KiSgw@mail.gmail.com>
 <CAF90AvmaRYO6HKn9npyfzO6M6FZnN6DRhqopLpeSnHJNK=5i9g@mail.gmail.com>
 <Y+40gVnMpj0prfQk@camus> <f19acdabd3fbc0ff389669131acbb79e@dtrt.org>
 <Y/Ke4yV7eV/87Kat@camus>
Message-ID: <CACrqygByMiEJNmn33DjOet8m3kjz116y-8y8v7EYrLq1-NG95w@mail.gmail.com>

An easy but possibly very important tip:

If you use only UPPER CASE alpha and numbers in codex32, and avoid most
punctuation, it makes QR rendering of it significantly smaller. This is
because the QR code to the ISO SPEC, when seeing lowercase, assumes the
value is binary, then converts it to a two byte value. If instead, the
codex32 is all upper, and it uses only the 45 allowed characters (see
https://www.thonky.com/qr-code-tutorial/alphanumeric-table) , it will leave
it single byte and try to compress it. Of course it doesn?t compress well,
but that is OK because it at least didn?t double the size first.

See our research on this topic at
https://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2020-003-uri-binary-compatibility.md

A superior QR codec can do better (see our
https://github.com/BlockchainCommons/QRCodeGenerator or
https://www.nayuki.io/page/qr-code-generator-library) but many platforms
and more basic QR codecs will double the size of the QR if you have any
lower case.

? Christopher Allen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230219/34d9d295/attachment.html>

From aj at erisian.com.au  Sun Feb 19 23:56:02 2023
From: aj at erisian.com.au (Anthony Towns)
Date: Mon, 20 Feb 2023 09:56:02 +1000
Subject: [bitcoin-dev] Refreshed BIP324
In-Reply-To: <S1zoL4CCIDVTrjmXx2JtYhO2qjgGyNIAP6X9FXRCRKPDjoQj20VcqKFCYkmmPQkNuMyNf9zp6GFVWWC7l8dBzCogUqvzmDx9D811NPheNJ8=@wuille.net>
References: <56677685-619a-691f-d5bc-54b69fdb6ed2@bip324.com>
 <wDqcIVw-YGTsjdf5M2GO9NNRl_UQuBeka2CUQUyQ329u6u-o7RabW_7S4FD3EDfk02kUczb3bXf8LtHhKLtx773UhQ7djKOl-JPOIrXqBSc=@wuille.net>
 <JXfTBjsA71dHE3h9wkxnWXANrwTbMADO4s2w34gEvMbiduKu4PEt5t-KA3EAIz-Xs4urjBHZ15NDFZST2a7e0x_NqyJymUnEORuTp3SNfMs=@wuille.net>
 <Y3dBUXPhTskCx+Fu@erisian.com.au>
 <gSxFQedPc72pTioi9vuxvLKpaRBsnKFL4gkPKPn2G-EJgz_2Y1pYQ7cHD5SnunyCaLln7UQEHIxnopqP74LlnK__Mf9BURbJW8B5MYTZvCU=@wuille.net>
 <Y7dZctMlZtH6PEsz@erisian.com.au> <Y7vMGVQz8TjS4Cad@erisian.com.au>
 <6b83c32e-59ca-65ef-2553-d66f8d117e56@bip324.com>
 <Y++id6mXsscfxduH@erisian.com.au>
 <S1zoL4CCIDVTrjmXx2JtYhO2qjgGyNIAP6X9FXRCRKPDjoQj20VcqKFCYkmmPQkNuMyNf9zp6GFVWWC7l8dBzCogUqvzmDx9D811NPheNJ8=@wuille.net>
Message-ID: <Y/K3Ejkwlj4NIMMa@erisian.com.au>

On Fri, Feb 17, 2023 at 10:13:05PM +0000, Pieter Wuille via bitcoin-dev wrote:
> > I think it's probably less complex to close some of the doors?
> > 2) are short ids available/meaningful to send prior to VERACK being
> > completed?
> Ah, I hadn't considered this nuance. If we don't care about them being available before VERACK negotiation, then it may be possible to introduce a way to negotiate a different short id mapping table without needing a mechanism for *re*-negotiating.

I think you still need/want two negotiation steps -- once to tell each
other what tables you know about, once to choose a mutually recognised
table and specify any additions.

> > I think the things missing from the current list (and not currently in
> > use by bitcoin core) are:
> > bip 61: REJECT
> > bip 331: GETPKGTXNS, PKGTXNS, ANCPKGINFO
> Do you feel REJECT should be included?

I don't think it matters much; reject messages are both rare and include
a reason so you'd only be saving maybe 12 bytes out of 62 (~20%)
for maybe 6000 messages a day per peer that sends reject messages,
so 72kB/day/reject-peer?

> Perhaps a possibility is having the transport layer translate short-command-number-N to the 12-byte command "\x00\x00..." + byte(N), and hand that to the application layer, which could then do the mapping?

Presuming the transport layer also continues to reject commands that
have a '\x00' byte at the start or in the middle (ie !IsCommandValid()),
that seems pretty reasonable...

Cheers,
aj

From roconnor at blockstream.com  Mon Feb 20 00:52:36 2023
From: roconnor at blockstream.com (Russell O'Connor)
Date: Sun, 19 Feb 2023 19:52:36 -0500
Subject: [bitcoin-dev] Codex32
In-Reply-To: <Y/Ke4yV7eV/87Kat@camus>
References: <CAMZUoKmiwXW50F2onqNUZO8HXQa4+Z=z3s3WyN7-rAMV=KiSgw@mail.gmail.com>
 <CAF90AvmaRYO6HKn9npyfzO6M6FZnN6DRhqopLpeSnHJNK=5i9g@mail.gmail.com>
 <Y+40gVnMpj0prfQk@camus> <f19acdabd3fbc0ff389669131acbb79e@dtrt.org>
 <Y/Ke4yV7eV/87Kat@camus>
Message-ID: <CAMZUoKnXd9yP+5aLCA+tJYV4dW4gqcyjDuc+AbXiXF6JGf7H=g@mail.gmail.com>

On Sun, Feb 19, 2023 at 5:13 PM Andrew Poelstra via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Sun, Feb 19, 2023 at 10:13:33AM -1000, David A. Harding wrote:
>
> I'm curious about whether there's a way to prevent this attack without
> > otherwise compromising the properties of the code?  For example, some
> > extra data that Bob can carry around (or memorize) for verifying the
> > shares haven't changed, but which is not otherwise needed for recovery
> > (so there's no problem if it's lost).
> >
>
> Unfortunately not, as near as I can tell ... one way to think of this is
> that Alice can flip a lot of random tiles then "error correct" it to get
> a new valid, but incorrect, seed. So as long as we support error
> correction it'll be possible to wreck seeds in this way.
>
> It's actually even worse than this ... as long as there's a clearly
> defined "checksum" at the end of a share, Alice will be able to mangele
> tiles and then just re-compute the checksum at the end.
>
> So what we really need to prevent this is something like a MAC: where
> Bob has a secret value which gets input into the checksum somehow, which
> Alice can't create valid checksums without knowing. Unfortunately I
> don't see any way to do this with linear codes. With a hash-based
> "checksum" a la BIP39 it would definitely be possible, but of course,
> not hand-computable.
>

Speaking off the cuff and as a non-cryptographer (i.e do NOT rush off and
do this without any vetting) but Christopher Allen once referred me to an
cypher tile set called LS47 <https://gitea.blesmrt.net/exa/ls47>.  If we
set aside the cypertext, I suspect we can form a MAC by recording some
random initial tile configuration, running the LS47 algorithm, and
recording the final tile configuration.  These records are not sensitive as
(presumably!) the share data is not recoverable from just knowing these two
configurations.  So one can keep these records with you, digitally sign
them or whatever, and then take them to your share on a regular basis to
rerun the LS47 algorithm to see if you still get the same final state from
the initial state.

Perhaps something more specific to Bech32 could be designed, but otherwise
this (alleged) MAC process isn't Codex32 specific.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230219/7fa702ff/attachment.html>

From bitcoin-dev at wuille.net  Mon Feb 20 15:22:30 2023
From: bitcoin-dev at wuille.net (Pieter Wuille)
Date: Mon, 20 Feb 2023 15:22:30 +0000
Subject: [bitcoin-dev] Refreshed BIP324
In-Reply-To: <Y/K3Ejkwlj4NIMMa@erisian.com.au>
References: <56677685-619a-691f-d5bc-54b69fdb6ed2@bip324.com>
 <Y3dBUXPhTskCx+Fu@erisian.com.au>
 <gSxFQedPc72pTioi9vuxvLKpaRBsnKFL4gkPKPn2G-EJgz_2Y1pYQ7cHD5SnunyCaLln7UQEHIxnopqP74LlnK__Mf9BURbJW8B5MYTZvCU=@wuille.net>
 <Y7dZctMlZtH6PEsz@erisian.com.au> <Y7vMGVQz8TjS4Cad@erisian.com.au>
 <6b83c32e-59ca-65ef-2553-d66f8d117e56@bip324.com>
 <Y++id6mXsscfxduH@erisian.com.au>
 <S1zoL4CCIDVTrjmXx2JtYhO2qjgGyNIAP6X9FXRCRKPDjoQj20VcqKFCYkmmPQkNuMyNf9zp6GFVWWC7l8dBzCogUqvzmDx9D811NPheNJ8=@wuille.net>
 <Y/K3Ejkwlj4NIMMa@erisian.com.au>
Message-ID: <1zGcFRzB9Has9bXWlYaOXXnOy9jxwLJvhkL_46OlA8JRsx2ultkYweDdPnW3Tbf145byXb8cG8pimWBT0qBBDaKisufJufP2wssDtigKass=@wuille.net>

On Sunday, February 19th, 2023 at 6:56 PM, Anthony Towns <aj at erisian.com.au> wrote:

> On Fri, Feb 17, 2023 at 10:13:05PM +0000, Pieter Wuille via bitcoin-dev wrote:
> 
> > > I think it's probably less complex to close some of the doors?
> > > 2) are short ids available/meaningful to send prior to VERACK being
> > > completed?
> > > Ah, I hadn't considered this nuance. If we don't care about them being available before VERACK negotiation, then it may be possible to introduce a way to negotiate a different short id mapping table without needing a mechanism for re-negotiating.
> 
> I think you still need/want two negotiation steps -- once to tell each
> other what tables you know about, once to choose a mutually recognised
> table and specify any additions.

Right, I wasn't talking about how many steps/messages the negotiation takes. I just meant that if all negotiation of the mapping table happens just once (before VERACK) and that negotiation itself happens without use of short commands, then there is no need for re-negotiating short commands after they are already in use. Nothing concrete, but I can imagine that that may simplify some implementations.

Cheers,

-- 
Pieter


From apoelstra at wpsoftware.net  Mon Feb 20 18:44:36 2023
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Mon, 20 Feb 2023 18:44:36 +0000
Subject: [bitcoin-dev] Codex32
In-Reply-To: <CAMZUoKmiwXW50F2onqNUZO8HXQa4+Z=z3s3WyN7-rAMV=KiSgw@mail.gmail.com>
References: <CAMZUoKmiwXW50F2onqNUZO8HXQa4+Z=z3s3WyN7-rAMV=KiSgw@mail.gmail.com>
Message-ID: <Y/O/lPBsfCaE+uVV@camus>

On Wed, Feb 15, 2023 at 09:16:02PM -0500, Russell O'Connor via bitcoin-dev wrote:
> I've been asked by Dr. Curr and Professor Snead to forward this message to
> this mailing list, as it may be of general interest to Bitcoin users.
>
> <snip>
>

I have opened a PR to the BIPs repo for this scheme: https://github.com/bitcoin/bips/pull/1425

Thanks very much to Pavol Rusnak, David Harding, and Christopher Allen
for their comments on this list. We've updated the draft text to try to
address your concerns. In particular:

  * Added more text to "Motivation" distinguishing the scheme from SLIP-39
  * Added more details to "Rationale"  about error correction capabilities
    of the code, and to explain that the code does not defend against
    malicious errors
  * Added a note to use uppercase for QR codes
  * Rearranged and clarified the "creating shares" instructions
  * Added text about hand-computation, in particular hand-computation
    of share verification, to "Motivation".

If any of you would like to be listed under Acknowledgements, please let
me know here or on the PR.


Cheers
Andrew


-- 
Andrew Poelstra
Director of Research, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

The sun is always shining in space
    -Justin Lewis-Webster

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230220/38465703/attachment.sig>

From stick at satoshilabs.com  Mon Feb 20 18:48:32 2023
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Mon, 20 Feb 2023 19:48:32 +0100
Subject: [bitcoin-dev] Codex32
In-Reply-To: <Y/O/lPBsfCaE+uVV@camus>
References: <CAMZUoKmiwXW50F2onqNUZO8HXQa4+Z=z3s3WyN7-rAMV=KiSgw@mail.gmail.com>
 <Y/O/lPBsfCaE+uVV@camus>
Message-ID: <CAF90Avm9U0J4s3akNVt64HaqsOUc3Wx-889E6fA5O7J7v1NOGQ@mail.gmail.com>

Thanks Andrew!

New draft makes it much more obvious what are the differences between
Codex32 and SLIP-0039 scheme.
-- 
Best Regards / S pozdravom,

Pavol "Stick" Rusnak
Co-Founder, SatoshiLabs
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230220/3b001b72/attachment.html>

From antoine.riard at gmail.com  Tue Feb 21 00:40:48 2023
From: antoine.riard at gmail.com (Antoine Riard)
Date: Tue, 21 Feb 2023 00:40:48 +0000
Subject: [bitcoin-dev] Bitcoin Contracting Primitives WG 4rd Meeting,
 Tuesday 21 Feb. 18:00 UTC
In-Reply-To: <CALZpt+Ep+pSkO58eOrzM57EZCGi--iperhyiEtrGP83rLp5atA@mail.gmail.com>
References: <CALZpt+Ep+pSkO58eOrzM57EZCGi--iperhyiEtrGP83rLp5atA@mail.gmail.com>
Message-ID: <CALZpt+HW85LiwAOQOAYCVpogr+--eT1sbt9_zK3XnT7NjuybPQ@mail.gmail.com>

Reminder: this is happening this _upcoming_ Tuesday.

Looking forward to the fourth session to roam over things like anyprevout,
the annex, vault primitive, annexcarrier!

Issue opened if anyone would like to propose an agenda topic:
https://github.com/ariard/bitcoin-contracting-primitives-wg/issues/34

Best,
Antoine

Le mer. 8 f?vr. 2023 ? 01:59, Antoine Riard <antoine.riard at gmail.com> a
?crit :

> Hi list,
>
> I'm proposing Tuesday 21st February at 18:00, i.e 2 weeks from now for the
> 4th Bitcoin contracting primitives WG meeting (the third Tuesday of
> February month, as done previously).
>
> As mentioned during the previous session, there is an issue if anyone
> would like to propose an agenda topic in advance in an open fashion:
> https://github.com/ariard/bitcoin-contracting-primitives-wg/issues/34
>
> I would like to propose 2 topics for this upcoming meeting.
>
> Firstly, ANYPREVOUT / "Eltoo", there has been a work in progress during
> the last year for eltoo lightning channels [0]. I think there are still few
> high-level open questions around fee-bumping and watchtowers, how the
> proposal would benefit other off-chain constructions, how the proposal
> works compared to other update mechanisms and a bunch of other things.
>
> Secondly, if there is sufficient interest, setting up an open meatspace
> event during S2 2023 or S1 2024. Meatspace events can be a great thing to
> accelerate the development pace of contracting protocols. From my
> experience in-person whiteboard sessions are highly valuable to sync on
> complex subjects and it has been already evoked in the context of this
> community process. Ideally, the event would piggyback on some existing
> bitcoin conference. And I would see this as complementary to the other
> bitcoin engineering meetings we've already scheduled, just open contracting
> primitives R&D to a large set of people beyond the usual crowd contributing
> already to Bitcoin Core [1].
>
> If we have time remaining, we could listen to everyone blockers in their
> contracting primitives/covenant research.
>
> Communication venue is #bitcoin-contracting-primitives-wg on Libera Chat
> IRC. Logs of the previous session are available here [2].
>
> If you have any questions or feedback, I'm staying responsive.
>
> Cheers,
> Antoine
>
> [0]
> https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-December/003788.html
> [1] In term of janitorial role decentralization, I think it would be
> valuable to have the event organization carried on by someone else reliable
> other than myself. Contributed to CoreDev Zurich 2021 organisation, so I
> can share the operational practices.
> [2]
> https://github.com/ariard/bitcoin-contracting-primitives-wg/blob/main/meetings/meetings-17-01.md
>
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230221/c113d883/attachment.html>

From aj at erisian.com.au  Tue Feb 21 16:03:37 2023
From: aj at erisian.com.au (Anthony Towns)
Date: Wed, 22 Feb 2023 02:03:37 +1000
Subject: [bitcoin-dev] Refreshed BIP324
In-Reply-To: <1zGcFRzB9Has9bXWlYaOXXnOy9jxwLJvhkL_46OlA8JRsx2ultkYweDdPnW3Tbf145byXb8cG8pimWBT0qBBDaKisufJufP2wssDtigKass=@wuille.net>
References: <56677685-619a-691f-d5bc-54b69fdb6ed2@bip324.com>
 <Y3dBUXPhTskCx+Fu@erisian.com.au>
 <gSxFQedPc72pTioi9vuxvLKpaRBsnKFL4gkPKPn2G-EJgz_2Y1pYQ7cHD5SnunyCaLln7UQEHIxnopqP74LlnK__Mf9BURbJW8B5MYTZvCU=@wuille.net>
 <Y7dZctMlZtH6PEsz@erisian.com.au> <Y7vMGVQz8TjS4Cad@erisian.com.au>
 <6b83c32e-59ca-65ef-2553-d66f8d117e56@bip324.com>
 <Y++id6mXsscfxduH@erisian.com.au>
 <S1zoL4CCIDVTrjmXx2JtYhO2qjgGyNIAP6X9FXRCRKPDjoQj20VcqKFCYkmmPQkNuMyNf9zp6GFVWWC7l8dBzCogUqvzmDx9D811NPheNJ8=@wuille.net>
 <Y/K3Ejkwlj4NIMMa@erisian.com.au>
 <1zGcFRzB9Has9bXWlYaOXXnOy9jxwLJvhkL_46OlA8JRsx2ultkYweDdPnW3Tbf145byXb8cG8pimWBT0qBBDaKisufJufP2wssDtigKass=@wuille.net>
Message-ID: <Y/TrWS1Y3JkxHsQn@erisian.com.au>

On Mon, Feb 20, 2023 at 03:22:30PM +0000, Pieter Wuille via bitcoin-dev wrote:
> On Sunday, February 19th, 2023 at 6:56 PM, Anthony Towns <aj at erisian.com.au> wrote:
> > On Fri, Feb 17, 2023 at 10:13:05PM +0000, Pieter Wuille via bitcoin-dev wrote:
> > > > I think it's probably less complex to close some of the doors?
> > > > 2) are short ids available/meaningful to send prior to VERACK being
> > > > completed?
> > > > Ah, I hadn't considered this nuance. If we don't care about them being available before VERACK negotiation, then it may be possible to introduce a way to negotiate a different short id mapping table without needing a mechanism for re-negotiating.
> > I think you still need/want two negotiation steps -- once to tell each
> > other what tables you know about, once to choose a mutually recognised
> > table and specify any additions.
> Right, I wasn't talking about how many steps/messages the negotiation takes. I just meant that if all negotiation of the mapping table happens just once (before VERACK) and that negotiation itself happens without use of short commands, then there is no need for re-negotiating short commands after they are already in use. Nothing concrete, but I can imagine that that may simplify some implementations.

Yeah; I was just thinking of the fact that currently the negotiation is:

 * send your VERSION message
 * see what their VERSION message is

 * announce a bunch of features, depending on the version (or service
   flags)
 * send the VERACK (and GETADDR and final ALERT)

 * wait for their announcements and VERACK
 * negotiation is finished; we know everything; we're ready to go

which only gets you two steps if you send the short id stuff as part of
the VERSION message. Obviously you could just add an extra phase either
just before or just after the VERACK, though.

I suppose being able to choose your own short id mapping from day 0 would
mean that every bip324 node could use a single short id mapping for all
outgoing messages, which might also make implementation marginally easier
(no need to use one table for modern nodes, but also support the original
table for old bip324 implementations)...

Cheers,
aj

From pete at petertodd.org  Wed Feb 22 16:29:03 2023
From: pete at petertodd.org (Peter Todd)
Date: Wed, 22 Feb 2023 11:29:03 -0500
Subject: [bitcoin-dev] Codex32
In-Reply-To: <Y/Ke4yV7eV/87Kat@camus>
References: <CAMZUoKmiwXW50F2onqNUZO8HXQa4+Z=z3s3WyN7-rAMV=KiSgw@mail.gmail.com>
 <CAF90AvmaRYO6HKn9npyfzO6M6FZnN6DRhqopLpeSnHJNK=5i9g@mail.gmail.com>
 <Y+40gVnMpj0prfQk@camus>
 <f19acdabd3fbc0ff389669131acbb79e@dtrt.org>
 <Y/Ke4yV7eV/87Kat@camus>
Message-ID: <Y/ZCz2JlYiQ1MvaG@petertodd.org>

On Sun, Feb 19, 2023 at 10:12:51PM +0000, Andrew Poelstra via bitcoin-dev wrote:
> > What really did catch my attention, but which was kind of buried in the
> > project documentation, is the ability to verify the integrity of each
> > share independently without using a computer.  For example, if I store a
> > share with some relative who lives thousands of kilometers away, I'll be
> > able to take that share out of its tamper-evident bag on my annual
> > holiday visit, verify that I can still read it accurately by validating
> > its checksum, and put it into a new bag for another year.  For this
> > procedure, I don't need to bring copies of any of my other shares,
> > allowing them (and my seed) to stay safe.
> > 
> 
> This is good feedback. I strongly agree that this is the big selling
> point for this -- that you can vet shares/seeds which *aren't* being
> actively used, without exposing them to the sorts of threats associated
> with active use.
> 
> We should make this more prominent in the BIP motivation.

I don't think that use-case is a good selling point. The checksum that Codex32
uses is much more complex than necessary if you are simply verifying a share by
itself.

A *much* simpler approach would be to use a simple mod N = 0 checksum, either
by creating the seed such that each share passes, or by just storing an
additional word/symbol with the seed in such a way that sum(words) mod N = 0
passes. This approach is not only possible to compute by hand with a
word/symbol->number lookup table, and pen and paper or a calculator. It's so
simple they could probably *remember* how to do it themselves.


Secondly, if all shares have mod N checksums, it may be sufficient for everyone
to write down the checksums of the *other* shares, to verify they are the
correct ones and a different (otherwise correct) share hasn't accidentally been
substituted.

Indeed, with some brute forcing and small checksums, I'd expect it to be
mathematically possible to generate Shamir's secret sharing shards such that
every shard can share the *same* checksum. In which case the share verification
procedure would be to simply ask every share holder to verify the checksum
manually using the mod N procedure, and then verify that each share holder has
the same checksum. This would be less error prone in terms of leaking
information accidentally if the checksum was obviously *not* part of the share:
eg by encoding the share with words, and the checksum with a number.

Obviously, small checksums aren't fool proof. But we're probably better off
creating a relatively easy procedure with a 1-in-1000 chance of an error going
undetected than a complex procedure that people don't actually do at all.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230222/b56aa2ec/attachment.sig>

From pete at petertodd.org  Wed Feb 22 16:39:04 2023
From: pete at petertodd.org (Peter Todd)
Date: Wed, 22 Feb 2023 11:39:04 -0500
Subject: [bitcoin-dev] Testing censorship resistance of bitcoin p2p
 network
In-Reply-To: <Y/Apxhqij1v56dT8@camus>
References: <TG0yVn41L6VFOHFRYqd3iGz7mxHWtjFdaBrz8mlP6Uk8bmog_isDbtq_2QyvdUs9_Q-jStmx7V7l5rAesXDfHlK9Ehft7SkK5EWQ_3mg-eQ=@protonmail.com>
 <177016307-23dca06637e70217317077657442d0d8@pmq7v.m5r2.onet>
 <Y/APRs3IPYapIpGg@camus>
 <B837E586-894E-40E8-9814-385EF59402B6@petertodd.org>
 <Y/Apxhqij1v56dT8@camus>
Message-ID: <Y/ZFKM2PGG+ijoBO@petertodd.org>

On Sat, Feb 18, 2023 at 01:28:38AM +0000, Andrew Poelstra wrote:
> On Sat, Feb 18, 2023 at 02:03:15AM +0200, Peter Todd wrote:
> > On February 18, 2023 1:35:34 AM GMT+02:00, Andrew Poelstra via bitcoin-dev 
> > >You could try statically analyze `<anything>` to determine whether the
> > >IF branch could ever be taken. For example there is no path through
> > >the "inscription script" that would result in all the crap being dropped
> > >by the end of the script, violating the CLEANSTACK rule.
> > >
> > >This sort of filtering, assuming it could be reliably and efficiently
> > >done, would at least force inscription scripts to be "plausible", and
> > >would greatly increase their space cost by e.g. requiring OP_DROP to be
> > >added somewhere hundreds of times.
> > 
> > "greatly increase their space cost"?
> > 
> > Tell me, what is the actual % increase to adding OP_DROPs like you propose?
> >
> 
> By standardness rules (where you can have up to 80-byte pushes), a
> little over 1%. By consensus (520-byte pushes) less than 0.2%.
> 
> Perhaps "greatly increase" is a stretch :) but if the fee market is
> functioning and we're talking about large amounts of data, it's not
> trivial either.

I would definitely call ~1% trivial. Fees vary more by that on an hour to hour
basis.

Anyway, it goes to show that protocols relying on data embedded in Bitcoin
transactions would do well to have flexible encoding rules, eg by considering
all PUSHDATA's with certain characteristics to be data, so that encoders can be
adapted on the fly if there are any censorship issues. It's also useful if the
rules allow data to be encoded in UTXO outputs, so that censorship of witness
data always risks people switching to filling up the UTXO set. A kind of
Mutually Assured Destruction threat in a way.

FWIW, OpenTimestamps was deliberately designed to have this property. So don't
mess with it. :D

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230222/4d5cfae9/attachment.sig>

From roconnor at blockstream.com  Wed Feb 22 17:24:19 2023
From: roconnor at blockstream.com (Russell O'Connor)
Date: Wed, 22 Feb 2023 12:24:19 -0500
Subject: [bitcoin-dev] Codex32
In-Reply-To: <f19acdabd3fbc0ff389669131acbb79e@dtrt.org>
References: <CAMZUoKmiwXW50F2onqNUZO8HXQa4+Z=z3s3WyN7-rAMV=KiSgw@mail.gmail.com>
 <CAF90AvmaRYO6HKn9npyfzO6M6FZnN6DRhqopLpeSnHJNK=5i9g@mail.gmail.com>
 <Y+40gVnMpj0prfQk@camus> <f19acdabd3fbc0ff389669131acbb79e@dtrt.org>
Message-ID: <CAMZUoKnV6gGBY1_zzAdPyzHLhNAMzM1PiLAHDwiPdBQds3MAxA@mail.gmail.com>

On Sun, Feb 19, 2023 at 3:13 PM David A. Harding via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>    Codex32 allows the individual to periodically perform their
>    recollection on paper in a private room without electronics and use
>    nothing but a pen and some loookup tables (or a paper device) to
>    verify that they recalled the string correctly (and its checksum can
>    help with correcting up to several errors, although you might need a
>    computer for error location and correction assistance).
>

While perhaps not entirely impossible, doing error correction by hand is
far more difficult than just the error detection process.
Fortunately, error correction can be aided by a computer needing very
little trust.

When doing hand computation of the checksum, there is an error if the final
"residue" is different from the value given in the codex32 spec.
After double checking your hand computation by redoing it, if you still get
the same incorrect residue, there is an error in your share data somewhere.

What you can do is plug in the residue that you did compute into a
computer, and have it produce an error correction string.
You can then, by hand, add this error correction string to your share to
get a corrected share.

If it were the case that all types of character errors were equally likely
(as in during an error any character is equally likely to be transformed
into any other character), then the computer would gain zero information
about your actual share data.  Of course, it is not in fact the case that
all transcription errors are equally likely, and so the computer can learn
a little bit about your share. The fewer errors that are made, the less
data it can recover. If you only have one character in error, then 5 bits
is the most data it can recover, and that is assuming that it can somehow
infer your error perfectly from the delta of the error correction, which
isn't actually going to be the case.

Of course, a single share from a split secret has no information about your
master seed (the master seed is hidden in the correlation between different
shares).  So learning partial information about one share isn't going to be
enough by itself to even begin compromising your master key.

This all still needs to be written up in more detail, but I figured I would
give a preview here.

- Hierarchy: Codex32 does not natively provide support for nested SSSS
>    whereas SLIP39 does.  E.g., in SLIP39, you can require 2-of-3 for
>    {me, family, friends} where me is 2-of-3 {fire_safe, bank_safe,
>    buried_in_woods}, family is 1-of-3 {alice, bob, carol}, and friends
>    are 2-of-5 {d, e, f, g, h}.  I assume you can do the same with Codex32
>    by using the share for one level as the secret for the next level,
>    although this is not described in the protocol.
>

There was a design for a second level share scheme floating around
somewhere. I'll have to dig it up. As I recall this is made slightly more
complicated by needing to incorporate share metadata (i.e. the share index)
when doing a second split, but it seemed doable at the time.


> - Versioning: Codex32's metadata can store version information for
>    wallets that use implicit BIP32 paths (e.g. BIP44/49/84/86), although
>    this would cut into the space available for users to set their own
>    metadata and it is not specified in the draft BIP.  SLIP39 also
>    doesn't specify anything about implicit path versioning and, AFAICT,
>    doesn't have any room to store such metadata without reducing seed
>    entropy.
>

Personally, I don't consider the derivation path / descriptor data as that
sensitive, and I would recommend making wide backups of that data.
It certainly would make sense to store descriptor data alongside wherever
you keep your shares, and more places beyond that.
On the other hand, if you are trying to keep your shares innocuous somehow,
perhaps you won't be able to keep the descriptor data alongside your shares.

When I first saw the post about this, it was unclear to me that it was a
> serious project, but I've become increasingly interested as I researched
> it.  I'm not personally that interested in generating entropy from dice
> or encoding shares by hand---it's already imperative that I acquire a
> trustworthy computer and load it with trustworthy software in order to
> use my seed securely, so I might as well have it generate my seeds and
> my
> recovery codes for me.
>

I do think hardware wallets are great, and overall provide a lot of
practical protection.  What is notable is that once the secrets are loaded
onto a hardware wallet, as long as that wallet remains isolated, it cannot
leak any secrets.

Of course, a wallet needs to interact with the Bitcoin protocol and P2P
network, at least indirectly, in order to  function, so we must break that
isolation.  However, if we can limit the communication capabilities of a
hardware wallet, even a malicious wallet shouldn't be able to leak the
secret data.

There are three main vectors a hardware wallet can try to communicate that
I am aware of:

1. Compromise at seed/master secret (or in this case shares of the master
secret) during generation time.
2. Lie about public keys at public key generation time.
3. Exfiltrate data though signature data or otherwise during signature
generation time.

#3 is largely mitigated through using anti-exfil signing and air gapping
the hardware wallet (e.g. using QR codes, or using RS-232
<https://en.wikipedia.org/wiki/RS-232> if you consider that air gaping).
Using multiple wallets from different vendors doing deterministic signing
is another possibility, but I consider the method deprecated in favour of
anti-exfil.

Addressing #1 is where codex32 lies, by taking master secret handling
functions out of the hardware wallet.

My understanding is that it is difficult for digital hardware, which tries
very hard to be deterministic, to generate randomness, especially for
isolated hardware devices like hardware wallets.
Also it is hard for hardware to tell if their hardware random number
generator is broken.  Generally I don't trust small pieces of isolated
digital hardware to generate master seeds, even when they are not
malicious. This may just be due to my ignorance of how they operate.

#2 seems to be the hardest issue to address.  My current thinking is to
generate addresses on a diverse set of hardware and/or using public
derivations.
Perhaps an alternative to BIP-32 could be designed to make it easy to
generate zero-knowledge proofs of pubkey derivations.

Of course there are other ways for a hardware wallets to exfiltrate data:
The wallet can blink lights, make noise, or it can try to use radio
broadcasts, etc.  These other attack vectors seem to require physically
local support, which is a fairly big hurdle to overcome.  I suppose even
these vectors could be mitigated through various levels of tinfoil.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230222/041a5132/attachment-0001.html>

From roconnor at blockstream.com  Wed Feb 22 19:01:10 2023
From: roconnor at blockstream.com (Russell O'Connor)
Date: Wed, 22 Feb 2023 14:01:10 -0500
Subject: [bitcoin-dev] Codex32
In-Reply-To: <Y/ZCz2JlYiQ1MvaG@petertodd.org>
References: <CAMZUoKmiwXW50F2onqNUZO8HXQa4+Z=z3s3WyN7-rAMV=KiSgw@mail.gmail.com>
 <CAF90AvmaRYO6HKn9npyfzO6M6FZnN6DRhqopLpeSnHJNK=5i9g@mail.gmail.com>
 <Y+40gVnMpj0prfQk@camus> <f19acdabd3fbc0ff389669131acbb79e@dtrt.org>
 <Y/Ke4yV7eV/87Kat@camus> <Y/ZCz2JlYiQ1MvaG@petertodd.org>
Message-ID: <CAMZUoK=j8spJv8UEu1WoThWL=gSrU=Gq+=mg3i9yA7V8+6susw@mail.gmail.com>

After some poking around at the math, I do see that the 13 character
generator (for regular sized shares) is reasonably "smooth", having roots
at T{11}, S{16}, and C{24}.

This means we could build a "quick check" worksheet to evaluate the string
modulo (x - T) to verify a 5 bit checksum, whose operation would be similar
to the existing checksum worksheet in structure but significantly less work.

Perhaps 5 bits is too short, and it is more reasonable working modulo (x -
T)*(x - S) to get a 10 bit checksum.  A worksheet for a 15 bit checksum is
also an option, and possibly others well depending on the size of the other
factors.  I think this process is would be about as simple as any other
comparable hand operated checksum over the bech32 alphabet would be.

I haven't looked into the smoothness of the long generator for seeds that
are greater than 400 bits.  If it isn't smooth and smoother options are
available, perhaps it should be changed.

On Wed, Feb 22, 2023 at 11:29 AM Peter Todd via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Sun, Feb 19, 2023 at 10:12:51PM +0000, Andrew Poelstra via bitcoin-dev
> wrote:
> > > What really did catch my attention, but which was kind of buried in the
> > > project documentation, is the ability to verify the integrity of each
> > > share independently without using a computer.  For example, if I store
> a
> > > share with some relative who lives thousands of kilometers away, I'll
> be
> > > able to take that share out of its tamper-evident bag on my annual
> > > holiday visit, verify that I can still read it accurately by validating
> > > its checksum, and put it into a new bag for another year.  For this
> > > procedure, I don't need to bring copies of any of my other shares,
> > > allowing them (and my seed) to stay safe.
> > >
> >
> > This is good feedback. I strongly agree that this is the big selling
> > point for this -- that you can vet shares/seeds which *aren't* being
> > actively used, without exposing them to the sorts of threats associated
> > with active use.
> >
> > We should make this more prominent in the BIP motivation.
>
> I don't think that use-case is a good selling point. The checksum that
> Codex32
> uses is much more complex than necessary if you are simply verifying a
> share by
> itself.
>
> A *much* simpler approach would be to use a simple mod N = 0 checksum,
> either
> by creating the seed such that each share passes, or by just storing an
> additional word/symbol with the seed in such a way that sum(words) mod N =
> 0
> passes. This approach is not only possible to compute by hand with a
> word/symbol->number lookup table, and pen and paper or a calculator. It's
> so
> simple they could probably *remember* how to do it themselves.
>
>
> Secondly, if all shares have mod N checksums, it may be sufficient for
> everyone
> to write down the checksums of the *other* shares, to verify they are the
> correct ones and a different (otherwise correct) share hasn't accidentally
> been
> substituted.
>
> Indeed, with some brute forcing and small checksums, I'd expect it to be
> mathematically possible to generate Shamir's secret sharing shards such
> that
> every shard can share the *same* checksum. In which case the share
> verification
> procedure would be to simply ask every share holder to verify the checksum
> manually using the mod N procedure, and then verify that each share holder
> has
> the same checksum. This would be less error prone in terms of leaking
> information accidentally if the checksum was obviously *not* part of the
> share:
> eg by encoding the share with words, and the checksum with a number.
>
> Obviously, small checksums aren't fool proof. But we're probably better off
> creating a relatively easy procedure with a 1-in-1000 chance of an error
> going
> undetected than a complex procedure that people don't actually do at all.
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230222/8b9500fc/attachment.html>

From roconnor at blockstream.com  Thu Feb 23 03:30:10 2023
From: roconnor at blockstream.com (Russell O'Connor)
Date: Wed, 22 Feb 2023 22:30:10 -0500
Subject: [bitcoin-dev] Codex32
In-Reply-To: <CAMZUoK=j8spJv8UEu1WoThWL=gSrU=Gq+=mg3i9yA7V8+6susw@mail.gmail.com>
References: <CAMZUoKmiwXW50F2onqNUZO8HXQa4+Z=z3s3WyN7-rAMV=KiSgw@mail.gmail.com>
 <CAF90AvmaRYO6HKn9npyfzO6M6FZnN6DRhqopLpeSnHJNK=5i9g@mail.gmail.com>
 <Y+40gVnMpj0prfQk@camus> <f19acdabd3fbc0ff389669131acbb79e@dtrt.org>
 <Y/Ke4yV7eV/87Kat@camus> <Y/ZCz2JlYiQ1MvaG@petertodd.org>
 <CAMZUoK=j8spJv8UEu1WoThWL=gSrU=Gq+=mg3i9yA7V8+6susw@mail.gmail.com>
Message-ID: <CAMZUoKkHg8i9=-=obnjsfqg9d38CaxOtqeLmNhjuv1dTXbcUtw@mail.gmail.com>

After some consultation, I now see that generators for all degree 2 BCH
codes, such as ours, are smooth and factor into quadratic and linear
components.

Anyhow the upshot of all this is that you can perform a "quickcheck"
verification of the codex32 strings for whatever size of verification you
want to do, 1 character, 2 characters, 3 characters, upto the full 13
characters.  Each of these partial verifications will have BCH properties.
A 1 character quickchecksum will guarantee to detect any 1 character
error.  A 3 character quickchecksum will guarantee to detect any 2
character error, etc.  There remains a 1 in 32^n chance of failing to
detect larger numbers of errors where n is the size of your quickcheck.

To illustrate, let's consider a quickcheck of size 2.  This can detect any
1 character error and will only have a 1/1024 chance of failing to detect
other random errors.  Let's take the second test vector as our example: "
MS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM"

You start in a specified initial state with a pair of bech32 characters.
For MS1 strings and a size 2 quickcheck it would be the pair of Bech32
characters 'AS'.

Next we "add" the first character after the prefix, which is '2' by using
the addition volvelle or lookup table.  "Adding" '2' to 'S' yields '6' and
our state becomes 'A6'.

Next we have to look up 'A6' in a lookup table.  This table is too big to
fit in the margin of this email, so I will have to omit it.  But it would
have an entry mapping 'A6' -> 'QM'.  Our state becomes 'QM'

>From this point we have an even number of remaining characters in the input
string and we can work 2 characters at a time. We "add" the next two data
characters from our string, which are 'NA'.  Again, using the volvelle or
lookup table we get that adding 'N' to 'Q' yields 'N', and adding 'A' to
'M' yields 'X'.  So our state is now 'NX'

Next we look up 'NX' in this table I haven't given you and we will find an
entry mapping 'NX' -> 'DX', making 'DX' our new state.

We keep repeating this process alternating between adding pairs of
characters and using this unstated lookup table all the way until the end
where we will reach a final state which will be 'H9'.

If you follow this procedure with any string (upto 400 bit master seeds)
you will always end up in the state 'H9'.

A specialized worksheet would help guide the process making the process
easier to follow.


This process is somewhat close to Peter Todd's suggestion of using a lookup
table on "words", which in this case would be pairs of bech32 characters,
and adding values together.  The catch is that the addition is done with
Bech32 addition rather than calculator addition, which I accept is a
moderately large catch.

Anyhow, the point is that you can do this sort of partial verification by
hand to whatever degree you like, if you are in a rush and are willing to
accept larger chances of failing to catch random errors.


On Wed, Feb 22, 2023 at 2:01 PM Russell O'Connor <roconnor at blockstream.com>
wrote:

> After some poking around at the math, I do see that the 13 character
> generator (for regular sized shares) is reasonably "smooth", having roots
> at T{11}, S{16}, and C{24}.
>
> This means we could build a "quick check" worksheet to evaluate the string
> modulo (x - T) to verify a 5 bit checksum, whose operation would be similar
> to the existing checksum worksheet in structure but significantly less work.
>
> Perhaps 5 bits is too short, and it is more reasonable working modulo (x -
> T)*(x - S) to get a 10 bit checksum.  A worksheet for a 15 bit checksum is
> also an option, and possibly others well depending on the size of the other
> factors.  I think this process is would be about as simple as any other
> comparable hand operated checksum over the bech32 alphabet would be.
>
> I haven't looked into the smoothness of the long generator for seeds that
> are greater than 400 bits.  If it isn't smooth and smoother options are
> available, perhaps it should be changed.
>
> On Wed, Feb 22, 2023 at 11:29 AM Peter Todd via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> On Sun, Feb 19, 2023 at 10:12:51PM +0000, Andrew Poelstra via bitcoin-dev
>> wrote:
>> > > What really did catch my attention, but which was kind of buried in
>> the
>> > > project documentation, is the ability to verify the integrity of each
>> > > share independently without using a computer.  For example, if I
>> store a
>> > > share with some relative who lives thousands of kilometers away, I'll
>> be
>> > > able to take that share out of its tamper-evident bag on my annual
>> > > holiday visit, verify that I can still read it accurately by
>> validating
>> > > its checksum, and put it into a new bag for another year.  For this
>> > > procedure, I don't need to bring copies of any of my other shares,
>> > > allowing them (and my seed) to stay safe.
>> > >
>> >
>> > This is good feedback. I strongly agree that this is the big selling
>> > point for this -- that you can vet shares/seeds which *aren't* being
>> > actively used, without exposing them to the sorts of threats associated
>> > with active use.
>> >
>> > We should make this more prominent in the BIP motivation.
>>
>> I don't think that use-case is a good selling point. The checksum that
>> Codex32
>> uses is much more complex than necessary if you are simply verifying a
>> share by
>> itself.
>>
>> A *much* simpler approach would be to use a simple mod N = 0 checksum,
>> either
>> by creating the seed such that each share passes, or by just storing an
>> additional word/symbol with the seed in such a way that sum(words) mod N
>> = 0
>> passes. This approach is not only possible to compute by hand with a
>> word/symbol->number lookup table, and pen and paper or a calculator. It's
>> so
>> simple they could probably *remember* how to do it themselves.
>>
>>
>> Secondly, if all shares have mod N checksums, it may be sufficient for
>> everyone
>> to write down the checksums of the *other* shares, to verify they are the
>> correct ones and a different (otherwise correct) share hasn't
>> accidentally been
>> substituted.
>>
>> Indeed, with some brute forcing and small checksums, I'd expect it to be
>> mathematically possible to generate Shamir's secret sharing shards such
>> that
>> every shard can share the *same* checksum. In which case the share
>> verification
>> procedure would be to simply ask every share holder to verify the checksum
>> manually using the mod N procedure, and then verify that each share
>> holder has
>> the same checksum. This would be less error prone in terms of leaking
>> information accidentally if the checksum was obviously *not* part of the
>> share:
>> eg by encoding the share with words, and the checksum with a number.
>>
>> Obviously, small checksums aren't fool proof. But we're probably better
>> off
>> creating a relatively easy procedure with a 1-in-1000 chance of an error
>> going
>> undetected than a complex procedure that people don't actually do at all.
>>
>> --
>> https://petertodd.org 'peter'[:-1]@petertodd.org
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230222/8bca8605/attachment-0001.html>

From roconnor at blockstream.com  Thu Feb 23 16:36:59 2023
From: roconnor at blockstream.com (Russell O'Connor)
Date: Thu, 23 Feb 2023 11:36:59 -0500
Subject: [bitcoin-dev] Codex32
In-Reply-To: <CAMZUoKkHg8i9=-=obnjsfqg9d38CaxOtqeLmNhjuv1dTXbcUtw@mail.gmail.com>
References: <CAMZUoKmiwXW50F2onqNUZO8HXQa4+Z=z3s3WyN7-rAMV=KiSgw@mail.gmail.com>
 <CAF90AvmaRYO6HKn9npyfzO6M6FZnN6DRhqopLpeSnHJNK=5i9g@mail.gmail.com>
 <Y+40gVnMpj0prfQk@camus> <f19acdabd3fbc0ff389669131acbb79e@dtrt.org>
 <Y/Ke4yV7eV/87Kat@camus> <Y/ZCz2JlYiQ1MvaG@petertodd.org>
 <CAMZUoK=j8spJv8UEu1WoThWL=gSrU=Gq+=mg3i9yA7V8+6susw@mail.gmail.com>
 <CAMZUoKkHg8i9=-=obnjsfqg9d38CaxOtqeLmNhjuv1dTXbcUtw@mail.gmail.com>
Message-ID: <CAMZUoK=Y_AoTo+=_h-kqk12Kw=54bfboKKgD+rtJ26Q2m7sJLQ@mail.gmail.com>

Sorry for the repeated replies, but I would like to make one more remark
regarding the 1 character "quick check".

Because the 1 character "quick check" state is so small, the procedure
becomes simplified to just using a single table.  You start with the
specified initial state, which would be the bech32 character '9', and then
you have a lookup mapping (<current state>, <next input character>) ->
<next state>.  You go through the table for each character after the
prefix, updating the state as you go along. ('9','2') -> '0', then
('0','N') -> '4', and so on until you reach the final state which should be
'5'.  If you like volvelles, one could be designed to implement this lookup
table.

However, I do want to note that an adjustment could be made to the codex32
generator so that this 1 character "quick check" table would become
identical to the Bech32 addition table.  In other words the 1 character
quick check would become the same as adding up all the characters and
checking that you get the required final constant.

If this change were free to make, I would probably make it.  However such
an adjustment would come at a cost.  The current generator was chosen to
have three identical coefficients in a row (you can find the generator in
the appendix of the draft BIP).  This special property slightly eases the
computation needed when creating checksums by hand (no compromise to the
quality of the checksum itself).  If we made the above adjustment to the
codex32 generator, we would lose this property of having three identical
coefficients in a row.

Therefore, I am pretty hesitant to make this adjustment.  Firstly the 1
character quick check is simply too small to be safely used.  While it does
guarantee to detect single character errors, it has a 1 in 32 chance of
failing to detect more errors.  I think a 3% failure rate is pretty bad,
and would definitely recommend people performing quick checks use a minimum
size of 2 (which has a 0.1% failure rate).  Secondly the difference between
using the addition table/volvelle versus a specific table/volvelle for the
purpose of performing 1 character quick checks (which you ought not to be
doing anyways) is pretty minimal.  The addition table is possibly slightly
less error prone to use because it is symmetric, but other than that the
amount of work to do is pretty much the same either way.

My conclusion is that it isn't worth compromising the ease of hand
computation for the sake of possibly making a
too-low-quality-checksum-that-no-one-should-be-using slightly more
convenient, but I thought I should mention it at least.


On Wed, Feb 22, 2023 at 10:30 PM Russell O'Connor <roconnor at blockstream.com>
wrote:

> After some consultation, I now see that generators for all degree 2 BCH
> codes, such as ours, are smooth and factor into quadratic and linear
> components.
>
> Anyhow the upshot of all this is that you can perform a "quickcheck"
> verification of the codex32 strings for whatever size of verification you
> want to do, 1 character, 2 characters, 3 characters, upto the full 13
> characters.  Each of these partial verifications will have BCH properties.
> A 1 character quickchecksum will guarantee to detect any 1 character
> error.  A 3 character quickchecksum will guarantee to detect any 2
> character error, etc.  There remains a 1 in 32^n chance of failing to
> detect larger numbers of errors where n is the size of your quickcheck.
>
> To illustrate, let's consider a quickcheck of size 2.  This can detect any
> 1 character error and will only have a 1/1024 chance of failing to detect
> other random errors.  Let's take the second test vector as our example: "
> MS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM"
>
> You start in a specified initial state with a pair of bech32 characters.
> For MS1 strings and a size 2 quickcheck it would be the pair of Bech32
> characters 'AS'.
>
> Next we "add" the first character after the prefix, which is '2' by using
> the addition volvelle or lookup table.  "Adding" '2' to 'S' yields '6' and
> our state becomes 'A6'.
>
> Next we have to look up 'A6' in a lookup table.  This table is too big to
> fit in the margin of this email, so I will have to omit it.  But it would
> have an entry mapping 'A6' -> 'QM'.  Our state becomes 'QM'
>
> From this point we have an even number of remaining characters in the
> input string and we can work 2 characters at a time. We "add" the next two
> data characters from our string, which are 'NA'.  Again, using the volvelle
> or lookup table we get that adding 'N' to 'Q' yields 'N', and adding 'A' to
> 'M' yields 'X'.  So our state is now 'NX'
>
> Next we look up 'NX' in this table I haven't given you and we will find an
> entry mapping 'NX' -> 'DX', making 'DX' our new state.
>
> We keep repeating this process alternating between adding pairs of
> characters and using this unstated lookup table all the way until the end
> where we will reach a final state which will be 'H9'.
>
> If you follow this procedure with any string (upto 400 bit master seeds)
> you will always end up in the state 'H9'.
>
> A specialized worksheet would help guide the process making the process
> easier to follow.
>
>
> This process is somewhat close to Peter Todd's suggestion of using a
> lookup table on "words", which in this case would be pairs of bech32
> characters, and adding values together.  The catch is that the addition is
> done with Bech32 addition rather than calculator addition, which I accept
> is a moderately large catch.
>
> Anyhow, the point is that you can do this sort of partial verification by
> hand to whatever degree you like, if you are in a rush and are willing to
> accept larger chances of failing to catch random errors.
>
>
> On Wed, Feb 22, 2023 at 2:01 PM Russell O'Connor <roconnor at blockstream.com>
> wrote:
>
>> After some poking around at the math, I do see that the 13 character
>> generator (for regular sized shares) is reasonably "smooth", having roots
>> at T{11}, S{16}, and C{24}.
>>
>> This means we could build a "quick check" worksheet to evaluate the
>> string modulo (x - T) to verify a 5 bit checksum, whose operation would be
>> similar to the existing checksum worksheet in structure but significantly
>> less work.
>>
>> Perhaps 5 bits is too short, and it is more reasonable working modulo (x
>> - T)*(x - S) to get a 10 bit checksum.  A worksheet for a 15 bit checksum
>> is also an option, and possibly others well depending on the size of the
>> other factors.  I think this process is would be about as simple as any
>> other comparable hand operated checksum over the bech32 alphabet would be.
>>
>> I haven't looked into the smoothness of the long generator for seeds that
>> are greater than 400 bits.  If it isn't smooth and smoother options are
>> available, perhaps it should be changed.
>>
>> On Wed, Feb 22, 2023 at 11:29 AM Peter Todd via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> On Sun, Feb 19, 2023 at 10:12:51PM +0000, Andrew Poelstra via
>>> bitcoin-dev wrote:
>>> > > What really did catch my attention, but which was kind of buried in
>>> the
>>> > > project documentation, is the ability to verify the integrity of each
>>> > > share independently without using a computer.  For example, if I
>>> store a
>>> > > share with some relative who lives thousands of kilometers away,
>>> I'll be
>>> > > able to take that share out of its tamper-evident bag on my annual
>>> > > holiday visit, verify that I can still read it accurately by
>>> validating
>>> > > its checksum, and put it into a new bag for another year.  For this
>>> > > procedure, I don't need to bring copies of any of my other shares,
>>> > > allowing them (and my seed) to stay safe.
>>> > >
>>> >
>>> > This is good feedback. I strongly agree that this is the big selling
>>> > point for this -- that you can vet shares/seeds which *aren't* being
>>> > actively used, without exposing them to the sorts of threats associated
>>> > with active use.
>>> >
>>> > We should make this more prominent in the BIP motivation.
>>>
>>> I don't think that use-case is a good selling point. The checksum that
>>> Codex32
>>> uses is much more complex than necessary if you are simply verifying a
>>> share by
>>> itself.
>>>
>>> A *much* simpler approach would be to use a simple mod N = 0 checksum,
>>> either
>>> by creating the seed such that each share passes, or by just storing an
>>> additional word/symbol with the seed in such a way that sum(words) mod N
>>> = 0
>>> passes. This approach is not only possible to compute by hand with a
>>> word/symbol->number lookup table, and pen and paper or a calculator.
>>> It's so
>>> simple they could probably *remember* how to do it themselves.
>>>
>>>
>>> Secondly, if all shares have mod N checksums, it may be sufficient for
>>> everyone
>>> to write down the checksums of the *other* shares, to verify they are the
>>> correct ones and a different (otherwise correct) share hasn't
>>> accidentally been
>>> substituted.
>>>
>>> Indeed, with some brute forcing and small checksums, I'd expect it to be
>>> mathematically possible to generate Shamir's secret sharing shards such
>>> that
>>> every shard can share the *same* checksum. In which case the share
>>> verification
>>> procedure would be to simply ask every share holder to verify the
>>> checksum
>>> manually using the mod N procedure, and then verify that each share
>>> holder has
>>> the same checksum. This would be less error prone in terms of leaking
>>> information accidentally if the checksum was obviously *not* part of the
>>> share:
>>> eg by encoding the share with words, and the checksum with a number.
>>>
>>> Obviously, small checksums aren't fool proof. But we're probably better
>>> off
>>> creating a relatively easy procedure with a 1-in-1000 chance of an error
>>> going
>>> undetected than a complex procedure that people don't actually do at all.
>>>
>>> --
>>> https://petertodd.org 'peter'[:-1]@petertodd.org
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230223/0526acda/attachment.html>

From roconnor at blockstream.com  Thu Feb 23 18:26:17 2023
From: roconnor at blockstream.com (Russell O'Connor)
Date: Thu, 23 Feb 2023 13:26:17 -0500
Subject: [bitcoin-dev] Codex32
In-Reply-To: <CAMZUoKkHg8i9=-=obnjsfqg9d38CaxOtqeLmNhjuv1dTXbcUtw@mail.gmail.com>
References: <CAMZUoKmiwXW50F2onqNUZO8HXQa4+Z=z3s3WyN7-rAMV=KiSgw@mail.gmail.com>
 <CAF90AvmaRYO6HKn9npyfzO6M6FZnN6DRhqopLpeSnHJNK=5i9g@mail.gmail.com>
 <Y+40gVnMpj0prfQk@camus> <f19acdabd3fbc0ff389669131acbb79e@dtrt.org>
 <Y/Ke4yV7eV/87Kat@camus> <Y/ZCz2JlYiQ1MvaG@petertodd.org>
 <CAMZUoK=j8spJv8UEu1WoThWL=gSrU=Gq+=mg3i9yA7V8+6susw@mail.gmail.com>
 <CAMZUoKkHg8i9=-=obnjsfqg9d38CaxOtqeLmNhjuv1dTXbcUtw@mail.gmail.com>
Message-ID: <CAMZUoK=3twzvpvP0=59T_X+4YYg-j=_DC8fGhyTsfm_18W-bjw@mail.gmail.com>

One more thing (Again apologies. This idea of doing partial verification is
novel to me, and I see now that I should have just waited to give a
consolidated reply).

Focusing in on the example of performing 2 character quick checks.  There
are 7 different ways of building the table used in this quick check
verification process (actually there are 8, but we only need 7 of them for
our purposes here).  Fun fact: If you perform the 2 character quick check
in all 7 different ways, this is equivalent to doing a full checksum
verification.

This suggests a strategy of visiting your shares on a regular basis and
performing a different 2 character quick check each time, rotating through
the 7 different ways of performing it.

Moreover, these 7 different 2 character quick checks come with a prescribed
order that will accumulate BCH guarantees as you go along.  Assuming the
string isn't changing between visits then

* After the 1st table you are guaranteed to detect any 1 character error.
* After the 2nd table you are guaranteed to detect any 2 character error.
* After the 3rd table you are guaranteed to detect any 4 character error.
* After the 4th table you are guaranteed to detect any 5 character error.
* After the 5th table you are guaranteed to detect any 6 character error.
* After the 6th table you are guaranteed to detect any 7 character error.
* After the 7th table you are guaranteed to detect any 8 character error,
which is the guarantee of the full 13 character checksum.  You are also
guaranteed that the full 13 character checksum is now correct.

You could perform the checks out of order, and that is okay.  You will
eventually reach these BCH levels of guarantees, just not as quickly as if
you follow the prescribed order.

Of course, doing a series of 7 different 2 character quick checks is
overall more work than doing the full 13 character checksum validation.
But there is certainly an advantage in spreading the work out over time.
Each time you visit you still have the guarantee of catching any new 1
character error introduced since the last time you visited and a 99.9%
chance of catching any other random errors introduced since your last
visit.  Personally I am likely to follow such a validation strategy myself,
now that I am aware of it.


On Wed, Feb 22, 2023 at 10:30 PM Russell O'Connor <roconnor at blockstream.com>
wrote:

> After some consultation, I now see that generators for all degree 2 BCH
> codes, such as ours, are smooth and factor into quadratic and linear
> components.
>
> Anyhow the upshot of all this is that you can perform a "quickcheck"
> verification of the codex32 strings for whatever size of verification you
> want to do, 1 character, 2 characters, 3 characters, upto the full 13
> characters.  Each of these partial verifications will have BCH properties.
> A 1 character quickchecksum will guarantee to detect any 1 character
> error.  A 3 character quickchecksum will guarantee to detect any 2
> character error, etc.  There remains a 1 in 32^n chance of failing to
> detect larger numbers of errors where n is the size of your quickcheck.
>
> To illustrate, let's consider a quickcheck of size 2.  This can detect any
> 1 character error and will only have a 1/1024 chance of failing to detect
> other random errors.  Let's take the second test vector as our example: "
> MS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM"
>
> You start in a specified initial state with a pair of bech32 characters.
> For MS1 strings and a size 2 quickcheck it would be the pair of Bech32
> characters 'AS'.
>
> Next we "add" the first character after the prefix, which is '2' by using
> the addition volvelle or lookup table.  "Adding" '2' to 'S' yields '6' and
> our state becomes 'A6'.
>
> Next we have to look up 'A6' in a lookup table.  This table is too big to
> fit in the margin of this email, so I will have to omit it.  But it would
> have an entry mapping 'A6' -> 'QM'.  Our state becomes 'QM'
>
> From this point we have an even number of remaining characters in the
> input string and we can work 2 characters at a time. We "add" the next two
> data characters from our string, which are 'NA'.  Again, using the volvelle
> or lookup table we get that adding 'N' to 'Q' yields 'N', and adding 'A' to
> 'M' yields 'X'.  So our state is now 'NX'
>
> Next we look up 'NX' in this table I haven't given you and we will find an
> entry mapping 'NX' -> 'DX', making 'DX' our new state.
>
> We keep repeating this process alternating between adding pairs of
> characters and using this unstated lookup table all the way until the end
> where we will reach a final state which will be 'H9'.
>
> If you follow this procedure with any string (upto 400 bit master seeds)
> you will always end up in the state 'H9'.
>
> A specialized worksheet would help guide the process making the process
> easier to follow.
>
>
> This process is somewhat close to Peter Todd's suggestion of using a
> lookup table on "words", which in this case would be pairs of bech32
> characters, and adding values together.  The catch is that the addition is
> done with Bech32 addition rather than calculator addition, which I accept
> is a moderately large catch.
>
> Anyhow, the point is that you can do this sort of partial verification by
> hand to whatever degree you like, if you are in a rush and are willing to
> accept larger chances of failing to catch random errors.
>
>
> On Wed, Feb 22, 2023 at 2:01 PM Russell O'Connor <roconnor at blockstream.com>
> wrote:
>
>> After some poking around at the math, I do see that the 13 character
>> generator (for regular sized shares) is reasonably "smooth", having roots
>> at T{11}, S{16}, and C{24}.
>>
>> This means we could build a "quick check" worksheet to evaluate the
>> string modulo (x - T) to verify a 5 bit checksum, whose operation would be
>> similar to the existing checksum worksheet in structure but significantly
>> less work.
>>
>> Perhaps 5 bits is too short, and it is more reasonable working modulo (x
>> - T)*(x - S) to get a 10 bit checksum.  A worksheet for a 15 bit checksum
>> is also an option, and possibly others well depending on the size of the
>> other factors.  I think this process is would be about as simple as any
>> other comparable hand operated checksum over the bech32 alphabet would be.
>>
>> I haven't looked into the smoothness of the long generator for seeds that
>> are greater than 400 bits.  If it isn't smooth and smoother options are
>> available, perhaps it should be changed.
>>
>> On Wed, Feb 22, 2023 at 11:29 AM Peter Todd via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> On Sun, Feb 19, 2023 at 10:12:51PM +0000, Andrew Poelstra via
>>> bitcoin-dev wrote:
>>> > > What really did catch my attention, but which was kind of buried in
>>> the
>>> > > project documentation, is the ability to verify the integrity of each
>>> > > share independently without using a computer.  For example, if I
>>> store a
>>> > > share with some relative who lives thousands of kilometers away,
>>> I'll be
>>> > > able to take that share out of its tamper-evident bag on my annual
>>> > > holiday visit, verify that I can still read it accurately by
>>> validating
>>> > > its checksum, and put it into a new bag for another year.  For this
>>> > > procedure, I don't need to bring copies of any of my other shares,
>>> > > allowing them (and my seed) to stay safe.
>>> > >
>>> >
>>> > This is good feedback. I strongly agree that this is the big selling
>>> > point for this -- that you can vet shares/seeds which *aren't* being
>>> > actively used, without exposing them to the sorts of threats associated
>>> > with active use.
>>> >
>>> > We should make this more prominent in the BIP motivation.
>>>
>>> I don't think that use-case is a good selling point. The checksum that
>>> Codex32
>>> uses is much more complex than necessary if you are simply verifying a
>>> share by
>>> itself.
>>>
>>> A *much* simpler approach would be to use a simple mod N = 0 checksum,
>>> either
>>> by creating the seed such that each share passes, or by just storing an
>>> additional word/symbol with the seed in such a way that sum(words) mod N
>>> = 0
>>> passes. This approach is not only possible to compute by hand with a
>>> word/symbol->number lookup table, and pen and paper or a calculator.
>>> It's so
>>> simple they could probably *remember* how to do it themselves.
>>>
>>>
>>> Secondly, if all shares have mod N checksums, it may be sufficient for
>>> everyone
>>> to write down the checksums of the *other* shares, to verify they are the
>>> correct ones and a different (otherwise correct) share hasn't
>>> accidentally been
>>> substituted.
>>>
>>> Indeed, with some brute forcing and small checksums, I'd expect it to be
>>> mathematically possible to generate Shamir's secret sharing shards such
>>> that
>>> every shard can share the *same* checksum. In which case the share
>>> verification
>>> procedure would be to simply ask every share holder to verify the
>>> checksum
>>> manually using the mod N procedure, and then verify that each share
>>> holder has
>>> the same checksum. This would be less error prone in terms of leaking
>>> information accidentally if the checksum was obviously *not* part of the
>>> share:
>>> eg by encoding the share with words, and the checksum with a number.
>>>
>>> Obviously, small checksums aren't fool proof. But we're probably better
>>> off
>>> creating a relatively easy procedure with a 1-in-1000 chance of an error
>>> going
>>> undetected than a complex procedure that people don't actually do at all.
>>>
>>> --
>>> https://petertodd.org 'peter'[:-1]@petertodd.org
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230223/4b73d4e8/attachment-0001.html>

From rastislavbudinsky at gmail.com  Mon Feb 27 13:32:01 2023
From: rastislavbudinsky at gmail.com (Rastislav Budinsky)
Date: Mon, 27 Feb 2023 14:32:01 +0100
Subject: [bitcoin-dev] BIP proposal: Fee-redistribution contracts
Message-ID: <CACVgDWbZKzmq+j0Hu-k5fW3J+ni-nasq74Ad+a0mkZJE_mPwSQ@mail.gmail.com>

Hello,

I am working on my Bachelor's thesis, in which a new way of collecting
transaction fees is introduced or rather how they are distributed.

When a miner mines a block he takes all the fees currently. However with
the proposed solution he takes only fraction M and remaining fraction C is
sent to one of more contracts. One contract at its simplest collects fees
from the miner and at the same time redistributes it back to the miner.

This means no new Bitcoins are introduced, only the one collected from fees
are collected, averaged and rewarded back to the miner in a "smarter" way.

We can have multiple such contracts, where each averages the collected fees
over different time frames. I would like to refer you to our paper for more
details [1], which is not yet in the final form.

Benefits are discussed in the paper [1] as well, mainly it should make
mining more secure and predictable against drastic fluctuations in fees. I
personally do not think miners should oppose this solution as for most
miners it should make a better mining environment. Similarly in a sense to
what mining pools bring.

I would like to know your opinions about this proposal and we can also
discuss the needed parameters introduced with such a solution if you are in
favor of it or think it might be interesting.

Introducing this solution soon enough will not make a great difference to
miners with current block rewards and at the same time the contracts will
be adapted before transaction fees become the main source of income for
miners.

As I have very little to none developer experience from blockchain's point
(especially on Bitcoin), I am not sure if this would be possible as
soft-fork as scripts in Bitcoin are stateless I suppose.
However maybe a generally spendable script by anyone holding the funds is
created, which a miner of the block would be the one spending it, and the
correct logic of following the contracts is embedded into consensus nodes
themselves. Thus perhaps a less disruptive solution to hard-fork.

Once again, I would love to know your opinions about this & I apologize for
making this a bit less conventional BIP proposal.

[1] https://arxiv.org/abs/2302.04910

Best regards.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230227/707b50c7/attachment.html>

From HcaFc_jbe at protonmail.com  Mon Feb 27 21:41:35 2023
From: HcaFc_jbe at protonmail.com (HcaFc_jbe)
Date: Mon, 27 Feb 2023 21:41:35 +0000
Subject: [bitcoin-dev] BIP proposal: Fee-redistribution contracts
In-Reply-To: <CACVgDWbZKzmq+j0Hu-k5fW3J+ni-nasq74Ad+a0mkZJE_mPwSQ@mail.gmail.com>
References: <CACVgDWbZKzmq+j0Hu-k5fW3J+ni-nasq74Ad+a0mkZJE_mPwSQ@mail.gmail.com>
Message-ID: <6OFVqxYXytFKbCYhzK7GjtrkWA0IuRRXaiWuH9mwPuNPMw3LOtC_1c-txfamKNO9XfNvWmRbVDev_FBmUsjpoYgRcGIxi486sYVJRNQjtb8=@protonmail.com>

Greetings, Brno is a beautiful city.

Long term miner incentives remain an open question, and this is an interesting proposal, but it has flaws.

-----To intervene or not intervene

--No intervention: When block subsidies do run out, years from now, it's possible that we live in a world where ordinals, LN-settlements, and on-chain transactions will be filling block space to the extent that miners are incentivized to continue mining. --Intervention: Tail-emissions? Demurrage? Fee-redistribution schemes like this one?

Really, it is too early to say whether mining incentives _will even_ be a problem, let alone _what_ the solution(s) should be.

This fee-redistribution scheme aims to solve

1. Undercutting attacks [which have been precluded AFAIK with anti fee-sniping

nLocktime since Core 0.11]

2. Fee-variance between blocks, whether due to the mining gap or variance in block

demand.

--Flaws

0. A miner in this world could be more aggressive in excluding certain blocks to the detriment of their counter parties. I.e. If a miner can ignore high-fee transactions, knowing they won't receive the _benefits_ of mining them [or less benefit], they can exclude these transactions without losing fees. E.g. if a miner is or represents a counterparty in a LN commitment transaction, and this counter party prefers that a time threshold is reached [so that they can mine a different version of the commitment transaction] then under this scheme they can avoid mining the first commitment transaction without really losing its fee, since it's fee is socialized anyway. This attack then becomes free or very cheap.

1. How would this smart-contract actually be constructed? The paper contains no references to op_codes or implementations. You do mention that you are not a bitcoin dev, so that's fair. AFAIK this isn't even _possible_ with the current Script, and could remain impossible. Maybe DLCs could be applied somehow. IDK.

2.0. I think it will be difficult to convince the ecosystem that the mining incentive structure should be changed from competitive to cooperative. This effectively changes the mining ecosystem into one giant mining pool. How would this affect mining centralization?

2.1. How do we achieve miner consensus in implementing the fee-redistribution scheme? And what is the consensus for updating?

---Paper-nits:

I believe the distribution in block creation is not exponential, but poisson -> on page two it's described as exponential.

Cheers,

-Paul

------- Original Message -------
On Monday, February 27th, 2023 at 8:32 AM, Rastislav Budinsky via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hello,
>
> I am working on my Bachelor's thesis, in which a new way of collecting transaction fees is introduced or rather how they are distributed.
>
> When a miner mines a block he takes all the fees currently. However with the proposed solution he takes only fraction M and remaining fraction C is sent to one of more contracts. One contract at its simplest collects fees from the miner and at the same time redistributes it back to the miner.
>
> This means no new Bitcoins are introduced, only the one collected from fees are collected, averaged and rewarded back to the miner in a "smarter" way.
>
> We can have multiple such contracts, where each averages the collected fees over different time frames. I would like to refer you to our paper for more details [1], which is not yet in the final form.
>
> Benefits are discussed in the paper [1] as well, mainly it should make mining more secure and predictable against drastic fluctuations in fees. I personally do not think miners should oppose this solution as for most miners it should make a better mining environment. Similarly in a sense to what mining pools bring.
>
> I would like to know your opinions about this proposal and we can also discuss the needed parameters introduced with such a solution if you are in favor of it or think it might be interesting.
>
> Introducing this solution soon enough will not make a great difference to miners with current block rewards and at the same time the contracts will be adapted before transaction fees become the main source of income for miners.
>
> As I have very little to none developer experience from blockchain's point (especially on Bitcoin), I am not sure if this would be possible as soft-fork as scripts in Bitcoin are stateless I suppose.
> However maybe a generally spendable script by anyone holding the funds is created, which a miner of the block would be the one spending it, and the correct logic of following the contracts is embedded into consensus nodes themselves. Thus perhaps a less disruptive solution to hard-fork.
>
> Once again, I would love to know your opinions about this & I apologize for making this a bit less conventional BIP proposal.
>
> [1] https://arxiv.org/abs/2302.04910
>
> Best regards.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230227/bbfc0651/attachment-0001.html>

From shymaa.arafat at gmail.com  Tue Feb 28 10:02:47 2023
From: shymaa.arafat at gmail.com (shymaa arafat)
Date: Tue, 28 Feb 2023 12:02:47 +0200
Subject: [bitcoin-dev] BIP proposal: Fee-redistribution contracts
In-Reply-To: <6OFVqxYXytFKbCYhzK7GjtrkWA0IuRRXaiWuH9mwPuNPMw3LOtC_1c-txfamKNO9XfNvWmRbVDev_FBmUsjpoYgRcGIxi486sYVJRNQjtb8=@protonmail.com>
References: <CACVgDWbZKzmq+j0Hu-k5fW3J+ni-nasq74Ad+a0mkZJE_mPwSQ@mail.gmail.com>
 <6OFVqxYXytFKbCYhzK7GjtrkWA0IuRRXaiWuH9mwPuNPMw3LOtC_1c-txfamKNO9XfNvWmRbVDev_FBmUsjpoYgRcGIxi486sYVJRNQjtb8=@protonmail.com>
Message-ID: <CAM98U8mxLsbMcaEY7PHUSeRNBQgUA4bs9-L=e80wk=M97MXmBg@mail.gmail.com>

If you allow me to comment (just with a bird eye, have not read the paper
only the abstract)

I think the Bitcoin community may consider the intuition of somewhat
"Future Saving" through TX fees:
ie, the idea of saving a ratio of the fees (say half to be decreased to
half with each reward halving)is worth thinking of:
Keep in mind that the block reward problem will not start only in 2140, but
when the mining cost becomes comparable to the reward value (could this be
as near as 2040?I don't know, you know the answer better than me)
.
-So, why not start a fee splitting  mechanism in analogy to reward
splitting mechanism
*(the saved ratio is half the total now, and to be halved with every
Bitcoin reward halving until a threshold is reached where the saved amounts
gets added to the low block reward)*

Ofcourse this is very rough, a game theoritic model has to be built with
the appropriate incentives and costs to get the exact numbers
.
Thank you for letting me comment in your list
.
Regards
.
Shymaa M Arafat

On Tue, Feb 28, 2023, 02:18 HcaFc_jbe via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Greetings, Brno is a beautiful city.
>
>
>
>
> Long term miner incentives remain an open question, and this is an
> interesting proposal, but it has flaws.
>
>
>
>
> -----To intervene or not intervene
>
> --No intervention:  When block subsidies do run out, years from now, it's
> possible that we live in a world where ordinals, LN-settlements, and
> on-chain transactions will be filling block space to the extent that miners
> are incentivized to continue mining.
>
>                       --Intervention: Tail-emissions? Demurrage?
> Fee-redistribution schemes like this one?
>
> Really, it is too early to say whether mining incentives _will even_ be a
> problem, let alone _what_ the solution(s) should be.
>
> This fee-redistribution scheme aims to solve
>
>      1. Undercutting attacks [which have been precluded AFAIK with anti
> fee-sniping
>
> nLocktime since Core 0.11]
>
>      2. Fee-variance between blocks, whether due to the mining gap or
> variance in block
>
> demand.
>
>
>
> --Flaws
>
> 0. A miner in this world could be more aggressive in excluding certain
> blocks to the detriment of their counter parties. I.e. If a miner can
> ignore high-fee transactions, knowing they won't receive the _benefits_ of
> mining them [or less benefit], they can exclude these transactions without
> losing fees. E.g. if a miner is or represents a counterparty in a LN
> commitment transaction, and this counter party prefers that a time
> threshold is reached [so that they can mine a different version of the
> commitment transaction] then under this scheme they can avoid mining the
> first commitment transaction without really losing its fee, since it's fee
> is socialized anyway. This attack then becomes free or very cheap.
>
> 1. How would this smart-contract actually be constructed? The paper
> contains no references to op_codes or implementations. You do mention that
> you are not a bitcoin dev, so that's fair. AFAIK this isn't even _possible_
> with the current Script, and could remain impossible. Maybe DLCs could be
> applied somehow. IDK.
>
> 2.0. I think it will be difficult to convince the ecosystem that the
> mining incentive structure should be changed from competitive to
> cooperative. This effectively changes the mining ecosystem into one giant
> mining pool. How would this affect mining centralization?
>
> 2.1. How do we achieve miner consensus in implementing the
> fee-redistribution scheme? And what is the consensus for updating?
>
> ---Paper-nits:
>
> I believe the distribution in block creation is not exponential, but
> poisson -> on page two it's described as exponential.
>
> Cheers,
>
> -Paul
>
> ------- Original Message -------
> On Monday, February 27th, 2023 at 8:32 AM, Rastislav Budinsky via
> bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Hello,
>
> I am working on my Bachelor's thesis, in which a new way of collecting
> transaction fees is introduced or rather how they are distributed.
>
> When a miner mines a block he takes all the fees currently. However with
> the proposed solution he takes only fraction M and remaining fraction C is
> sent to one of more contracts. One contract at its simplest collects fees
> from the miner and at the same time redistributes it back to the miner.
>
> This means no new Bitcoins are introduced, only the one collected from
> fees are collected, averaged and rewarded back to the miner in a "smarter"
> way.
>
> We can have multiple such contracts, where each averages the collected
> fees over different time frames. I would like to refer you to our paper for
> more details [1], which is not yet in the final form.
>
> Benefits are discussed in the paper [1] as well, mainly it should make
> mining more secure and predictable against drastic fluctuations in fees. I
> personally do not think miners should oppose this solution as for most
> miners it should make a better mining environment. Similarly in a sense to
> what mining pools bring.
>
> I would like to know your opinions about this proposal and we can also
> discuss the needed parameters introduced with such a solution if you are in
> favor of it or think it might be interesting.
>
> Introducing this solution soon enough will not make a great difference to
> miners with current block rewards and at the same time the contracts will
> be adapted before transaction fees become the main source of income for
> miners.
>
> As I have very little to none developer experience from blockchain's point
> (especially on Bitcoin), I am not sure if this would be possible as
> soft-fork as scripts in Bitcoin are stateless I suppose.
> However maybe a generally spendable script by anyone holding the funds is
> created, which a miner of the block would be the one spending it, and the
> correct logic of following the contracts is embedded into consensus nodes
> themselves. Thus perhaps a less disruptive solution to hard-fork.
>
> Once again, I would love to know your opinions about this & I apologize
> for making this a bit less conventional BIP proposal.
>
> [1] https://arxiv.org/abs/2302.04910
>
> Best regards.
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230228/ce1d3450/attachment.html>

From dhruv at bip324.com  Tue Feb 28 18:07:06 2023
From: dhruv at bip324.com (Dhruv M)
Date: Tue, 28 Feb 2023 18:07:06 +0000
Subject: [bitcoin-dev] Refreshed BIP324
In-Reply-To: <Y/TrWS1Y3JkxHsQn@erisian.com.au>
References: <56677685-619a-691f-d5bc-54b69fdb6ed2@bip324.com>
 <Y7dZctMlZtH6PEsz@erisian.com.au> <Y7vMGVQz8TjS4Cad@erisian.com.au>
 <6b83c32e-59ca-65ef-2553-d66f8d117e56@bip324.com>
 <Y++id6mXsscfxduH@erisian.com.au>
 <S1zoL4CCIDVTrjmXx2JtYhO2qjgGyNIAP6X9FXRCRKPDjoQj20VcqKFCYkmmPQkNuMyNf9zp6GFVWWC7l8dBzCogUqvzmDx9D811NPheNJ8=@wuille.net>
 <Y/K3Ejkwlj4NIMMa@erisian.com.au>
 <1zGcFRzB9Has9bXWlYaOXXnOy9jxwLJvhkL_46OlA8JRsx2ultkYweDdPnW3Tbf145byXb8cG8pimWBT0qBBDaKisufJufP2wssDtigKass=@wuille.net>
 <Y/TrWS1Y3JkxHsQn@erisian.com.au>
Message-ID: <f57b879d-a1f1-43c8-2557-874b1456d972@bip324.com>

The relevant changes from this discussion about short 1-byte message
type IDs are now in a PR for the bips repo:
https://github.com/bitcoin/bips/pull/1428

On 2/21/23 08:03, Anthony Towns via bitcoin-dev wrote:
> On Mon, Feb 20, 2023 at 03:22:30PM +0000, Pieter Wuille via bitcoin-dev wrote:
>> On Sunday, February 19th, 2023 at 6:56 PM, Anthony Towns <aj at erisian.com.au> wrote:
>>> On Fri, Feb 17, 2023 at 10:13:05PM +0000, Pieter Wuille via bitcoin-dev wrote:
>>>>> I think it's probably less complex to close some of the doors?
>>>>> 2) are short ids available/meaningful to send prior to VERACK being
>>>>> completed?
>>>>> Ah, I hadn't considered this nuance. If we don't care about them being available before VERACK negotiation, then it may be possible to introduce a way to negotiate a different short id mapping table without needing a mechanism for re-negotiating.
>>> I think you still need/want two negotiation steps -- once to tell each
>>> other what tables you know about, once to choose a mutually recognised
>>> table and specify any additions.
>> Right, I wasn't talking about how many steps/messages the negotiation takes. I just meant that if all negotiation of the mapping table happens just once (before VERACK) and that negotiation itself happens without use of short commands, then there is no need for re-negotiating short commands after they are already in use. Nothing concrete, but I can imagine that that may simplify some implementations.
> Yeah; I was just thinking of the fact that currently the negotiation is:
>
>   * send your VERSION message
>   * see what their VERSION message is
>
>   * announce a bunch of features, depending on the version (or service
>     flags)
>   * send the VERACK (and GETADDR and final ALERT)
>
>   * wait for their announcements and VERACK
>   * negotiation is finished; we know everything; we're ready to go
>
> which only gets you two steps if you send the short id stuff as part of
> the VERSION message. Obviously you could just add an extra phase either
> just before or just after the VERACK, though.
>
> I suppose being able to choose your own short id mapping from day 0 would
> mean that every bip324 node could use a single short id mapping for all
> outgoing messages, which might also make implementation marginally easier
> (no need to use one table for modern nodes, but also support the original
> table for old bip324 implementations)...
>
> Cheers,
> aj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From erik at q32.com  Tue Feb 28 21:02:41 2023
From: erik at q32.com (Erik Aronesty)
Date: Tue, 28 Feb 2023 16:02:41 -0500
Subject: [bitcoin-dev] Refreshed BIP324
In-Reply-To: <f57b879d-a1f1-43c8-2557-874b1456d972@bip324.com>
References: <56677685-619a-691f-d5bc-54b69fdb6ed2@bip324.com>
 <Y7dZctMlZtH6PEsz@erisian.com.au> <Y7vMGVQz8TjS4Cad@erisian.com.au>
 <6b83c32e-59ca-65ef-2553-d66f8d117e56@bip324.com>
 <Y++id6mXsscfxduH@erisian.com.au>
 <S1zoL4CCIDVTrjmXx2JtYhO2qjgGyNIAP6X9FXRCRKPDjoQj20VcqKFCYkmmPQkNuMyNf9zp6GFVWWC7l8dBzCogUqvzmDx9D811NPheNJ8=@wuille.net>
 <Y/K3Ejkwlj4NIMMa@erisian.com.au>
 <1zGcFRzB9Has9bXWlYaOXXnOy9jxwLJvhkL_46OlA8JRsx2ultkYweDdPnW3Tbf145byXb8cG8pimWBT0qBBDaKisufJufP2wssDtigKass=@wuille.net>
 <Y/TrWS1Y3JkxHsQn@erisian.com.au>
 <f57b879d-a1f1-43c8-2557-874b1456d972@bip324.com>
Message-ID: <CAJowKg+gOTCE=S2KYTF9j-uPYysUZJsJty5CHkkVp6+Ugy6Vtw@mail.gmail.com>

you can always do what protocols usually do.   1 byte is fine for now, but
reserve the top bit for "this is a two byte id" (128 choices).   then when
you run out of room, set the top bit which means "this is a 2 byte id
(again with one reserved) and so-on.   ie: how protobuf stores integers.

On Tue, Feb 28, 2023 at 1:42 PM Dhruv M via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> The relevant changes from this discussion about short 1-byte message
> type IDs are now in a PR for the bips repo:
> https://github.com/bitcoin/bips/pull/1428
>
> On 2/21/23 08:03, Anthony Towns via bitcoin-dev wrote:
> > On Mon, Feb 20, 2023 at 03:22:30PM +0000, Pieter Wuille via bitcoin-dev
> wrote:
> >> On Sunday, February 19th, 2023 at 6:56 PM, Anthony Towns <
> aj at erisian.com.au> wrote:
> >>> On Fri, Feb 17, 2023 at 10:13:05PM +0000, Pieter Wuille via
> bitcoin-dev wrote:
> >>>>> I think it's probably less complex to close some of the doors?
> >>>>> 2) are short ids available/meaningful to send prior to VERACK being
> >>>>> completed?
> >>>>> Ah, I hadn't considered this nuance. If we don't care about them
> being available before VERACK negotiation, then it may be possible to
> introduce a way to negotiate a different short id mapping table without
> needing a mechanism for re-negotiating.
> >>> I think you still need/want two negotiation steps -- once to tell each
> >>> other what tables you know about, once to choose a mutually recognised
> >>> table and specify any additions.
> >> Right, I wasn't talking about how many steps/messages the negotiation
> takes. I just meant that if all negotiation of the mapping table happens
> just once (before VERACK) and that negotiation itself happens without use
> of short commands, then there is no need for re-negotiating short commands
> after they are already in use. Nothing concrete, but I can imagine that
> that may simplify some implementations.
> > Yeah; I was just thinking of the fact that currently the negotiation is:
> >
> >   * send your VERSION message
> >   * see what their VERSION message is
> >
> >   * announce a bunch of features, depending on the version (or service
> >     flags)
> >   * send the VERACK (and GETADDR and final ALERT)
> >
> >   * wait for their announcements and VERACK
> >   * negotiation is finished; we know everything; we're ready to go
> >
> > which only gets you two steps if you send the short id stuff as part of
> > the VERSION message. Obviously you could just add an extra phase either
> > just before or just after the VERACK, though.
> >
> > I suppose being able to choose your own short id mapping from day 0 would
> > mean that every bip324 node could use a single short id mapping for all
> > outgoing messages, which might also make implementation marginally easier
> > (no need to use one table for modern nodes, but also support the original
> > table for old bip324 implementations)...
> >
> > Cheers,
> > aj
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230228/e41051b1/attachment.html>

