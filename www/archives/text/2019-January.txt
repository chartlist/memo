From vitteaymeric at gmail.com  Tue Jan  1 19:44:57 2019
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Tue, 1 Jan 2019 20:44:57 +0100
Subject: [bitcoin-dev] BIP39 seeds
In-Reply-To: <CALPhJawf98+uqZXQRGH3Tjo1CnZJfE+CMw9J2ZqiHHmwDSdugQ@mail.gmail.com>
References: <68330522-7e7c-c3b4-99a9-1c68ddb56f23@gmail.com>
	<f2d73a92-e1c5-9072-e255-fa012a9f9d1b@satoshilabs.com>
	<db184306-7ec0-322e-5637-7889b51f50bf@gmail.com>
	<CAH+Axy6dKDOkE6cQYZUusTUxxOSwWchOWxYh6ZkhnOgXuELaYg@mail.gmail.com>
	<743fb106-977e-1f34-47af-9fb3b8621e72@gmail.com>
	<CAH+Axy7v=26P8=CJPUqymKOcromGz+zYZ2cb2KaASgXNPpE2tQ@mail.gmail.com>
	<c91cd61b-3ec5-6c7a-c7e3-7ceb48539625@gmail.com>
	<CALPhJawf98+uqZXQRGH3Tjo1CnZJfE+CMw9J2ZqiHHmwDSdugQ@mail.gmail.com>
Message-ID: <3ea2e92d-5be6-3331-5d6f-9c29d87e0546@gmail.com>

You are simplifying too much what I am suggesting

What I am suggesting is: set a derivation method for BIP39 like for 
BIP32 (having the seed for BIP32 and not the derivation path is just 
like having nothing) and use this derivation method from a "book" (a 
"book" being a book, a document, a link, an image, whatever your secret 
can be), based on the fact that you will easily find from this 
derivation method "valid" BIP39 seeds (even if BIP39 does not enforce 
anything regarding valid phrases, everything can be valid as you 
mention, and this does not help in fact)

The derivation method will just define the way you select the words in 
the secret, and if everybody chooses the bible as the secret then this 
will not change the fact that it will be impossible to find the real 
seed without knowing the derivation path

Then you don't need to write the seed, you can easily plausible deny it, 
you can easily pass it to the family (using a passphrase does not say to 
them where they are supposed to use it)

"people lost"--> people think that there is some magic with BIP39 that 
will save them whatever they do (ie they don't even care of managing 
correctly the many easy to generate BIP39 seeds they are using) where 
they will always recover their seed and keys from BIP39/44/49, of course 
this does not work at all


Le 31/12/2018 ? 17:52, Alan Evans a ?crit :
> > Using some algorithm to take some input and generate a bip39 phrase 
> that you can use with any bip39 wallet sounds perfectly reasonable.
>
> I think any method that doesn't use real entropy, but some fake source 
> of randomness, such as a book is asking to be hacked and so is not a 
> reasonable idea.
>
> If an algorithm for book text to BIP39 sentence ever became well used, 
> common books will be systematically searched for accounts. People will 
> also choose their favourite passages, so I would expect to see collisions.
>
> You should also note that BIP39 does not need input that is from the 
> word list. You can use _any text as its input_, the word list and 
> checksum check is just recommended to be a warning, but again, text 
> chosen from public sources or common phrases is a bad idea for many 
> reasons.
>
> From BIP0039:
> /> The conversion of the mnemonic sentence to a binary seed is 
> completely independent from generating the sentence. This results in 
> rather simple code; *there are no constraints on sentence structure* 
> and clients are free to implement their own wordlists or even whole 
> sentence generators, allowing for flexibility in wordlists for typo 
> detection or other purposes./
> /> Although using a mnemonic not generated by the algorithm described 
> in "Generating the mnemonic" section is possible, this is not advised 
> and software must compute a checksum for the mnemonic sentence using a 
> wordlist and issue a warning if it is invalid./
>
> What you could do is use a regular true random BIP39 sentence in 
> conjunction with a phrase from a book as the "passphrase" giving you 
> that plausible deniability, right up to the point you put that in your 
> will or tell someone, i.e. for the "what if something happens to me" 
> case. Though I still think redirecting people to a book phase is risky 
> for this, e.g. books have editions, there may be a change in the key 
> place.
>
> From BIP0039:/
> /
> /> The described method also provides plausible deniability, because 
> every passphrase generates a valid seed (and thus a deterministic 
> wallet) but only the correct one will make the desired wallet available./
>
> Alan
>
> P.S. "I have seen many people completely lost with their wallets 
> because of [BIP39]": I would say "despite" not "because". These people 
> would have lost/miss recorded a BIP32 hex seed as well.
>
>
> On Thu, 27 Dec 2018 at 11:02, Aymeric Vitte via bitcoin-dev 
> <bitcoin-dev at lists.linuxfoundation.org 
> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>
>
>     Le 26/12/2018 ? 19:54, James MacWhyte a ?crit :
>>
>>     On Wed, Dec 26, 2018 at 11:33 AM Aymeric Vitte
>>     <vitteaymeric at gmail.com <mailto:vitteaymeric at gmail.com>> wrote:
>>
>>         so, even with a tool like yours, they can be misleaded, for
>>         example trying a few words to replace the missing/incorrect
>>         one, get a valid seed and stay stuck with it forever trying
>>         to play with BIP44/49 to find their keys
>>
>>
>>     Just a small detail, but my tool actually looks up all the
>>     possible combinations and then finds which one has been used
>>     before by looking for past transactions on the blockchain.
>>     Therefore, it won't tell you your phrase is correct unless it is
>>     a phrase that has actually been used before (preventing what you
>>     described).
>
>     I saw that your tool was querying blockchain.info
>     <http://blockchain.info>, but it cannot guess what derivation path
>     was used and if it is a standard one what addresses were used, and
>     even if successful it works only for bitcoin (so maybe it should
>     just output the ~1500 possible phrases and/or xprv, and be
>     completely offline, this is still doable for people)
>
>>
>>     Using some algorithm to take some input and generate a bip39
>>     phrase that you can use with any bip39 wallet sounds perfectly
>>     reasonable.
>
>     I forgot to mention that this can help also solving the "what if
>     something happens to me" case giving to the family the seed and
>     the parameter(s) for the derivation path, or an easy way to find
>     it (better than something like: remind this passphrase, take the
>     sha256 of it, then use some other stuff to find the encryption
>     algo, take n bytes of the hash, use it to decode my wallet or my
>     seed... and then everybody looking at you like crazy)
>
>     _______________________________________________
>     bitcoin-dev mailing list
>     bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190101/916f37ee/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Wed Jan  2 13:39:57 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 02 Jan 2019 13:39:57 +0000
Subject: [bitcoin-dev] Create a BIP to implement Confidential
	Transactions in Bitcoin Core
In-Reply-To: <DB6PR10MB1832A1A6EB2628CAB0035192A6B00@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>
References: <3VIFGj5yxFpKlSgjMAlPCuTJOSzYkZI2l7tMwtQq4LStjiXgfS7A61jdZ5ZoyalJmjo71EQtNC_F06JgpQ1m046fWbq_6Nhe3BGkMOU-17I=@protonmail.com>
	<DB6PR10MB1832A1A6EB2628CAB0035192A6B00@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>
Message-ID: <knV3VcCBvchmrBDvcYs8I2mImVR7_fbYmtWPY1GOxHkhKlYsMjFCReM1d3_me13YekyI4NZYRovD8s103Yj6wLWBMir6SOBYlrCdS1tLqgo=@protonmail.com>

Good morning SomberNight,

> "Bulletproofs ... are computationally binding. An adversary that could
> break the discrete logarithm assumption could generate acceptable range
> proofs for a value outside the correct range. ... An adversary that can
> break the binding property of the commitment scheme or the soundness of
> the proof system can generate coins out of thin air and thus create
> uncontrolled but undetectable inflation rendering the currency useless"
>
> I don't have the domain knowledge to debate whether quantum computers will
> ever exist but AFAICT their emergence would easily kill a currency that
> uses these kind of range proofs for confidential transactions.

This can be mitigated by splitting the blockchain into a public part and a confidential-transactions part (i.e. extension block).
This may be necessary for softforking of CT onto the blockchain anyway; existing pre-CT coins remain in the public part.

When moving from public to CT, you send to some special "lockbox address" on the public part, then they will now be put in a coinbase-like transaction on the CT part.
You then do some mixing and splitting in the CT part to obscure which of your UTXOs have what value.
Then to move from CT to public, you can claim any of the lockboxes on the public part, by revealing the values of your CT UTXOs (and destroying them) and showing that they are equal or less than the lockboxes you are claiming on the public part, and putting back any remainder between the lockboxes total and your own CT UTXOs into another lockbox UTXO.

This is essentially the same concept as sidechains, but with the "side" chain here being part of the consensus, and thus an extension block instead of a true sidechain.

In this way, the amount of total money in the CT part is the sum of all the lockboxes.
In case of a cryptographic break in the CT rangeproof protocol, then the first owner of a quantum computer can claim all the lockboxes, but at least the damage is bounded to only those UTXOs in the CT part.
UTXOs in the public part retain their money.
In addition, since creation of new coins remains in the public part, coin supply is protected, which I believe is the most important property.

The weakness in this scheme is that there is incentive not to put your money for long in the CT part.

Note that CT only hides transaction values.
Structure of transactions from payers to payees remains visible onchain.
I would suggest rather to use MimbleWimble, since at least under MimbleWimble transaction structure will need to be stored by the monitors of the blockchain rather than by the blockchain itself, which would help reduce their ability to see into historical data (they would only be able to see data they recorded themselves, and MimbleWimble allows third-party trustless CoinJoin so they might not even record accurate transaction structure).
Drawback is lack of SCRIPT, but Scriptless Script should be sufficient for e.g. LN.

Regards,
ZmnSCPxj

From macwhyte at gmail.com  Wed Jan  2 18:06:08 2019
From: macwhyte at gmail.com (James MacWhyte)
Date: Wed, 2 Jan 2019 18:06:08 +0000
Subject: [bitcoin-dev] BIP39 seeds
In-Reply-To: <CALPhJawf98+uqZXQRGH3Tjo1CnZJfE+CMw9J2ZqiHHmwDSdugQ@mail.gmail.com>
References: <68330522-7e7c-c3b4-99a9-1c68ddb56f23@gmail.com>
	<f2d73a92-e1c5-9072-e255-fa012a9f9d1b@satoshilabs.com>
	<db184306-7ec0-322e-5637-7889b51f50bf@gmail.com>
	<CAH+Axy6dKDOkE6cQYZUusTUxxOSwWchOWxYh6ZkhnOgXuELaYg@mail.gmail.com>
	<743fb106-977e-1f34-47af-9fb3b8621e72@gmail.com>
	<CAH+Axy7v=26P8=CJPUqymKOcromGz+zYZ2cb2KaASgXNPpE2tQ@mail.gmail.com>
	<c91cd61b-3ec5-6c7a-c7e3-7ceb48539625@gmail.com>
	<CALPhJawf98+uqZXQRGH3Tjo1CnZJfE+CMw9J2ZqiHHmwDSdugQ@mail.gmail.com>
Message-ID: <CAH+Axy72BTi8+yiUnbrr_Fd8XDf0g6eygOT-6OHRZ8En7W3qbA@mail.gmail.com>

On Wed, Jan 2, 2019 at 3:40 AM Alan Evans via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> I think any method that doesn't use real entropy, but some fake source of
> randomness, such as a book is asking to be hacked and so is not a
> reasonable idea.
>
> If an algorithm for book text to BIP39 sentence ever became well used,
> common books will be systematically searched for accounts. People will also
> choose their favourite passages, so I would expect to see collisions.
>
>
I tend to have this conversation a lot ;) I'm not sure what Aymeric has in
mind, but my suggestions are for use by the small few who properly
understand how these things work. I am not suggesting blockchain.info
require every user to choose a book passage to use as their backup phrase!

There are so many small things that could be done to make a text input
unique. Choose the X number of words from the start of the Nth sentence.
Replace all punctuation with exclamation points. Combine two sentences from
different pages. It would be nigh impossible to brute force any of these,
and would require hints/instructions from the owner to recover.

But I admit if this is not intended for standardization, discussing it on
this mailing list is probably unwarranted.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190102/c926eff7/attachment.html>

From vitteaymeric at gmail.com  Fri Jan  4 00:02:35 2019
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Fri, 4 Jan 2019 01:02:35 +0100
Subject: [bitcoin-dev] BIP39 seeds
In-Reply-To: <CAH+Axy72BTi8+yiUnbrr_Fd8XDf0g6eygOT-6OHRZ8En7W3qbA@mail.gmail.com>
References: <68330522-7e7c-c3b4-99a9-1c68ddb56f23@gmail.com>
	<f2d73a92-e1c5-9072-e255-fa012a9f9d1b@satoshilabs.com>
	<db184306-7ec0-322e-5637-7889b51f50bf@gmail.com>
	<CAH+Axy6dKDOkE6cQYZUusTUxxOSwWchOWxYh6ZkhnOgXuELaYg@mail.gmail.com>
	<743fb106-977e-1f34-47af-9fb3b8621e72@gmail.com>
	<CAH+Axy7v=26P8=CJPUqymKOcromGz+zYZ2cb2KaASgXNPpE2tQ@mail.gmail.com>
	<c91cd61b-3ec5-6c7a-c7e3-7ceb48539625@gmail.com>
	<CALPhJawf98+uqZXQRGH3Tjo1CnZJfE+CMw9J2ZqiHHmwDSdugQ@mail.gmail.com>
	<CAH+Axy72BTi8+yiUnbrr_Fd8XDf0g6eygOT-6OHRZ8En7W3qbA@mail.gmail.com>
Message-ID: <2df60f7f-58a4-b5b6-757f-7d50a339ff97@gmail.com>

What I have in mind is in my latest reply (difficult to have some kind
of fluent discussions on this list given the moderation and delayed posts)

I would just add that the derivation method (indeed something like what
you are sketching below) should estimate that there is enough entropy
from the secret, if not just throw

Le 02/01/2019 ? 19:06, James MacWhyte via bitcoin-dev a ?crit?:
> On Wed, Jan 2, 2019 at 3:40 AM Alan Evans via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org
> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>
>
>     I think any method that doesn't use real entropy, but some fake
>     source of randomness, such as a book is asking to be hacked and so
>     is not a reasonable idea.
>
>     If an algorithm for book text to BIP39 sentence?ever became well
>     used, common books will be systematically searched for accounts.
>     People will also choose their favourite passages, so I would
>     expect to see collisions.
>
>
> I tend to have this conversation a lot ;) I'm not sure what Aymeric
> has in mind, but my suggestions are for use by the small few who
> properly understand how these things work. I am not suggesting
> blockchain.info <http://blockchain.info> require every user to choose
> a book passage to use as their backup phrase!
>
> There are so many small things that could be done to make a text input
> unique. Choose the X number of words from the start of the Nth
> sentence. Replace all punctuation with exclamation points. Combine two
> sentences from different pages. It would be nigh impossible to brute
> force any of these, and would require hints/instructions from the
> owner to recover.
>
> But I admit if this is not intended for standardization, discussing it
> on this mailing list is probably unwarranted.
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190104/d8b994a9/attachment.html>

From lf-lists at mattcorallo.com  Mon Jan  7 15:18:52 2019
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Mon, 7 Jan 2019 15:18:52 +0000
Subject: [bitcoin-dev] [Lightning-dev] CPFP Carve-Out for Fee-Prediction
 Issues in Contracting Applications (eg Lightning)
In-Reply-To: <878t163qzi.fsf@rustcorp.com.au>
References: <c3f68b73-84c6-7428-4bf6-b47802141392@mattcorallo.com>
	<878t163qzi.fsf@rustcorp.com.au>
Message-ID: <725fc55a-6263-a9fc-74a5-1017cb1cc885@mattcorallo.com>

Sorry for the late reply.

Hmm, I included the old RBF-pinning proposal as a comparison. 
Personally, I find it both less clean and less convincingly secure.

Ultimately, defining a "near the top of the mempool" criteria is fraught 
with issues. While it's probably OK for the original problem (large 
batched transactions where you don't want a single counterparty to 
prevent confirmation), lightning's requirements are very different. 
Instead is wanting a high probability that the transaction in question 
confirms "soon", we need certainty that it will confirm by some deadline.

Thus, even if you imagine a steady-state mempool growth, unless the 
"near the top of the mempool" criteria is "near the top of the next 
block" (which is obviously *not* incentive-compatible), its easy to see 
how the package would fail to confirm within a handful of blocks given 
block time variance. Giving up the ability to RBF/CPFP more than once in 
case the fee moves away from us seems to be a rather significant 
restriction.

THe original proposal is somewhat of a hack, but its a hack on the 
boundary condition where packages meet our local anti-DoS rules in 
violation of the "incentive compatible" goal anyway (essentially, though 
miners also care about anti-DoS). This proposal is very different and, 
similar to how it doesn't work if blocks randomly come in a bit slow for 
an hour or two, isn't incentive compatible if blocks come in a bit fast 
for an hour or two, as all of a sudden that "near the top of the 
mempool" criteria makes no sense and you should have accepted the new 
transaction(s).

As for package relay, indeed, we can probably do soemthing simpler for 
this specific case, but itdepends on what the scope of that design is. 
Suhas opened an issue to try to scope it out a bit more at 
https://github.com/bitcoin/bitcoin/issues/14895

Matt

> On Dec 3, 2018, at 22:33, Rusty Russell <rusty at rustcorp.com.au> wrote:
> 
> Matt Corallo <lf-lists at mattcorallo.com> writes:
>> As an alternative proposal, at various points there have been 
>> discussions around solving the "RBF-pinning" problem by allowing 
>> transactors to mark their transactions as "likely-to-be-RBF'ed", which 
>> could enable a relay policy where children of such transactions would be 
>> rejected unless the resulting package would be "near the top of the 
>> mempool". This would theoretically imply such attacks are not possible 
>> to pull off consistently, as any "transaction-delaying" channel 
>> participant will have to place the package containing A at an effective 
>> feerate which makes confirmation to occur soon with some likelihood. It 
>> is, however, possible to pull off this attack with low probability in 
>> case of feerate spikes right after broadcast.
> 
> I like this idea.
> 
> Firstly, it's incentive-compatible[1]: assuming blocks are full, miners
> should always take a higher feerate tx if that tx would be in the
> current block and the replaced txs would not.[2]
> 
> Secondly, it reduces the problem that the current lightning proposal
> adds to the UTXO set with two anyone-can-spend txs for 1000 satoshis,
> which might be too small to cleanup later.  This rule would allow a
> simple single P2WSH(OP_TRUE) output, or, with IsStandard changed,
> a literal OP_TRUE.
> 
>> Note that this clearly relies on some form of package relay, which comes 
>> with its own challenges, but I'll start a separate thread on that.
> 
> Could be done client-side, right?  Do a quick check if this is above 250
> satoshi per kweight but below minrelayfee, put it in a side-cache with a
> 60 second timeout sweep.  If something comes in which depends on it
> which is above minrelayfee, then process them as a pair[3].
> 
> Cheers,
> Rusty.
> [1] Miners have generally been happy with Defaults Which Are Good For The
>    Network, but I feel a long term development aim should to be reduce
>    such cases to smaller and smaller corners.
> [2] The actual condition is subtler, but this is a clear subset AFAICT.
> [3] For Lightning, we don't care about child-pays-for-grandparent etc.

From rusty at rustcorp.com.au  Tue Jan  8 05:50:20 2019
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Tue, 08 Jan 2019 16:20:20 +1030
Subject: [bitcoin-dev] [Lightning-dev] CPFP Carve-Out for Fee-Prediction
	Issues in Contracting Applications (eg Lightning)
In-Reply-To: <725fc55a-6263-a9fc-74a5-1017cb1cc885@mattcorallo.com>
References: <c3f68b73-84c6-7428-4bf6-b47802141392@mattcorallo.com>
	<878t163qzi.fsf@rustcorp.com.au>
	<725fc55a-6263-a9fc-74a5-1017cb1cc885@mattcorallo.com>
Message-ID: <87wonfem03.fsf@rustcorp.com.au>

Matt Corallo <lf-lists at mattcorallo.com> writes:
> Ultimately, defining a "near the top of the mempool" criteria is fraught 
> with issues. While it's probably OK for the original problem (large 
> batched transactions where you don't want a single counterparty to 
> prevent confirmation), lightning's requirements are very different. 
> Instead is wanting a high probability that the transaction in question 
> confirms "soon", we need certainty that it will confirm by some deadline.

I don't think it's different, in practice.

> Thus, even if you imagine a steady-state mempool growth, unless the 
> "near the top of the mempool" criteria is "near the top of the next 
> block" (which is obviously *not* incentive-compatible)

I was defining "top of mempool" as "in the first 4 MSipa", ie. next
block, and assumed you'd only allow RBF if the old package wasn't in the
top and the replacement would be.  That seems incentive compatible; more
than the current scheme?

The attack against this is to make a 100k package which would just get
into this "top", then push it out with a separate tx at slightly higher
fee, then repeat.  Of course, timing makes that hard to get right, and
you're paying real fees for it too.

Sure, an attacker can make you pay next-block high fees, but it's still
better than our current "*always* overpay and hope!", and you can always
decide at the time based on whether the expiring HTLC(s) are worth it.

But I think whatever's simplest to implement should win, and I'm not in
a position to judge that accurately.

Thanks,
Rusty.

From lf-lists at mattcorallo.com  Tue Jan  8 14:46:45 2019
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Tue, 8 Jan 2019 09:46:45 -0500
Subject: [bitcoin-dev] [Lightning-dev] CPFP Carve-Out for Fee-Prediction
	Issues in Contracting Applications (eg Lightning)
In-Reply-To: <87wonfem03.fsf@rustcorp.com.au>
References: <c3f68b73-84c6-7428-4bf6-b47802141392@mattcorallo.com>
	<878t163qzi.fsf@rustcorp.com.au>
	<725fc55a-6263-a9fc-74a5-1017cb1cc885@mattcorallo.com>
	<87wonfem03.fsf@rustcorp.com.au>
Message-ID: <D072562F-5AD0-4B38-94D1-A0AEF04C3DEB@mattcorallo.com>

I responded to a few things in-line before realizing I think we're out of sync on what this alternative proposal actually implies. In my understanding is it, it does *not* imply that you are guaranteed the ability to RBF as fees change. The previous problem is still there - your counterparty can announce a bogus package and leave you unable to add a new transaction to it, the difference being it may be significantly more expensive to do so. If it were the case the you could RBF after the fact, I would likely agree with you.

> On Jan 8, 2019, at 00:50, Rusty Russell <rusty at rustcorp.com.au> wrote:
> 
> Matt Corallo <lf-lists at mattcorallo.com> writes:
>> Ultimately, defining a "near the top of the mempool" criteria is fraught 
>> with issues. While it's probably OK for the original problem (large 
>> batched transactions where you don't want a single counterparty to 
>> prevent confirmation), lightning's requirements are very different. 
>> Instead is wanting a high probability that the transaction in question 
>> confirms "soon", we need certainty that it will confirm by some deadline.
> 
> I don't think it's different, in practice.

I strongly disagree. If you're someone sending a batched payment, 5% chance it takes 13 blocks is perfectly acceptable. If you're a lightning operator, that quickly turns into "5% chance, or 35% chance if your counterparty is malicious and knows more about the market structure than you". Eg in the past it's been the case that transaction volume would spike every day at the same time when Bitmex proceed a flood of withdrawals all at once in separate transactions. Worse, it's probably still the case that, in case is sudden market movement, transaction volume can spike while people arb exchanges and move coins into exchanges to sell.

>> Thus, even if you imagine a steady-state mempool growth, unless the 
>> "near the top of the mempool" criteria is "near the top of the next 
>> block" (which is obviously *not* incentive-compatible)
> 
> I was defining "top of mempool" as "in the first 4 MSipa", ie. next
> block, and assumed you'd only allow RBF if the old package wasn't in the
> top and the replacement would be.  That seems incentive compatible; more
> than the current scheme?

My point was, because of block time variance, even that criteria doesn't hold up. If you assume a steady flow of new transactions and one or two blocks come in "late", suddenly "top 4MWeight" isn't likely to get confirmed until a few blocks come in "early". Given block variance within a 12 block window, this is a relatively likely scenario.

> The attack against this is to make a 100k package which would just get
> into this "top", then push it out with a separate tx at slightly higher
> fee, then repeat.  Of course, timing makes that hard to get right, and
> you're paying real fees for it too.
> 
> Sure, an attacker can make you pay next-block high fees, but it's still
> better than our current "*always* overpay and hope!", and you can always
> decide at the time based on whether the expiring HTLC(s) are worth it.
> 
> But I think whatever's simplest to implement should win, and I'm not in
> a position to judge that accurately.
> 
> Thanks,
> Rusty.


From mappum at gmail.com  Fri Jan 18 22:59:35 2019
From: mappum at gmail.com (Matt Bell)
Date: Fri, 18 Jan 2019 14:59:35 -0800
Subject: [bitcoin-dev] Proof-of-Stake Bitcoin Sidechains
Message-ID: <CACV3+OU1ynRuR2SioW+O+CAp5M7ZQA6af_hEY5JZCVrXpqjtKQ@mail.gmail.com>

I have been working on a design for Bitcoin sidechains using the Tendermint
BFT consensus protocol, which is commonly used to build proof-of-stake
networks (Cosmos is the notable one).

The design ends up being very similar to Blockstream's Liquid sidechain,
since Tendermint consensus is not far off from Liquid's "strong federation"
consensus.

Any feedback about improvements or critical flaws would be greatly
appreciated. The design document is here:
https://github.com/mappum/bitcoin-peg/blob/master/bitcoinPeg.md (that repo
also contains a simplified implementation of this sidechain design).

Thanks for your feedback,
Matt Bell
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190118/f588117a/attachment.html>

From ZmnSCPxj at protonmail.com  Sat Jan 19 01:42:47 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 19 Jan 2019 01:42:47 +0000
Subject: [bitcoin-dev] Proof-of-Stake Bitcoin Sidechains
In-Reply-To: <CACV3+OU1ynRuR2SioW+O+CAp5M7ZQA6af_hEY5JZCVrXpqjtKQ@mail.gmail.com>
References: <CACV3+OU1ynRuR2SioW+O+CAp5M7ZQA6af_hEY5JZCVrXpqjtKQ@mail.gmail.com>
Message-ID: <BTyUDt_7oOQmFj_V61w2eUJ7rfi-eOuNphy5nN0xNAhY4sUHnR2-0U9m-ZEKip4YjFi2-hGBtucvFv7nCTVo3aBxZ94VQCa1Kx2pP_zgdxU=@protonmail.com>

Good morning Matt,

It seems to me much more interesting if the stakes used to weigh voting power are UTXOs on the Bitcoin blockchain.
This idea is what I call "mainstake"; rather than a blockchain having its own token that is self-attesting (which is insecure).
It seems to me, naively, that the same script you propose here can be used for mainstake.

For instance, the sidechain network might accept potential stakers on the mainchain, if the staker proves the existence of a mainchain transaction whose output is for example:

<sidechain identifier> OP_DROP
"1 year" OP_CHECKSEQUENCEVERIFY OP_DROP
<pubkey> OP_CHECKSIG

The sidechain network could accept this and use the value of the output as the weight of the vote of that stake.

Regards,
ZmnSCPxj

Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Saturday, January 19, 2019 6:59 AM, Matt Bell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> I have been working on a design for Bitcoin sidechains using the Tendermint BFT consensus protocol, which is commonly used to build proof-of-stake networks (Cosmos is the notable one).
>
> The design ends up being very similar to Blockstream's Liquid sidechain, since Tendermint consensus is not far off from Liquid's "strong federation" consensus.
>
> Any feedback about improvements or critical flaws would be greatly appreciated. The design document is here: https://github.com/mappum/bitcoin-peg/blob/master/bitcoinPeg.md (that repo also contains a simplified implementation of this sidechain design).
>
> Thanks for your feedback,
> Matt Bell

From mappum at gmail.com  Sat Jan 19 05:35:43 2019
From: mappum at gmail.com (Matt Bell)
Date: Fri, 18 Jan 2019 21:35:43 -0800
Subject: [bitcoin-dev] Proof-of-Stake Bitcoin Sidechains
In-Reply-To: <BTyUDt_7oOQmFj_V61w2eUJ7rfi-eOuNphy5nN0xNAhY4sUHnR2-0U9m-ZEKip4YjFi2-hGBtucvFv7nCTVo3aBxZ94VQCa1Kx2pP_zgdxU=@protonmail.com>
References: <CACV3+OU1ynRuR2SioW+O+CAp5M7ZQA6af_hEY5JZCVrXpqjtKQ@mail.gmail.com>
	<BTyUDt_7oOQmFj_V61w2eUJ7rfi-eOuNphy5nN0xNAhY4sUHnR2-0U9m-ZEKip4YjFi2-hGBtucvFv7nCTVo3aBxZ94VQCa1Kx2pP_zgdxU=@protonmail.com>
Message-ID: <CACV3+OWjszx6istHo7yaNxiS22kyhHQhcPxGT3QLDx3KPUMU6g@mail.gmail.com>

Hi ZmnSCPxj,

Just to clarify, my design does not specify the source of voting power, so
it is agnostic to whatever system you want to derive stake or valdiator set
membership from.

Your idea of timelocking Bitcoin is interesting, I am eager to find a
solution where holding Bitcoin is enough to get voting power. It's possible
there may be an issue with the fact that the Bitcoin is not slashable
(although their voting power is), meaning a validator who double-signs
cannot have their Bitcoin removed from them. However their UTXO can be
blacklisted which does make their attack costly since they lose out on the
time-value of their stake.

Our current thinking for the source of stake is to pay out stake to Bitcoin
merged-miners although I'll definitely do some more thinking about
timelocked Bitcoin as stake.

On Fri, Jan 18, 2019, 5:42 PM ZmnSCPxj <ZmnSCPxj at protonmail.com wrote:

> Good morning Matt,
>
> It seems to me much more interesting if the stakes used to weigh voting
> power are UTXOs on the Bitcoin blockchain.
> This idea is what I call "mainstake"; rather than a blockchain having its
> own token that is self-attesting (which is insecure).
> It seems to me, naively, that the same script you propose here can be used
> for mainstake.
>
> For instance, the sidechain network might accept potential stakers on the
> mainchain, if the staker proves the existence of a mainchain transaction
> whose output is for example:
>
> <sidechain identifier> OP_DROP
> "1 year" OP_CHECKSEQUENCEVERIFY OP_DROP
> <pubkey> OP_CHECKSIG
>
> The sidechain network could accept this and use the value of the output as
> the weight of the vote of that stake.
>
> Regards,
> ZmnSCPxj
>
> Sent with ProtonMail Secure Email.
>
> ??????? Original Message ???????
> On Saturday, January 19, 2019 6:59 AM, Matt Bell via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > I have been working on a design for Bitcoin sidechains using the
> Tendermint BFT consensus protocol, which is commonly used to build
> proof-of-stake networks (Cosmos is the notable one).
> >
> > The design ends up being very similar to Blockstream's Liquid sidechain,
> since Tendermint consensus is not far off from Liquid's "strong federation"
> consensus.
> >
> > Any feedback about improvements or critical flaws would be greatly
> appreciated. The design document is here:
> https://github.com/mappum/bitcoin-peg/blob/master/bitcoinPeg.md (that
> repo also contains a simplified implementation of this sidechain design).
> >
> > Thanks for your feedback,
> > Matt Bell
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190118/de50b59d/attachment.html>

From ZmnSCPxj at protonmail.com  Sun Jan 20 02:06:08 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sun, 20 Jan 2019 02:06:08 +0000
Subject: [bitcoin-dev] Proof-of-Stake Bitcoin Sidechains
In-Reply-To: <CACV3+OWjszx6istHo7yaNxiS22kyhHQhcPxGT3QLDx3KPUMU6g@mail.gmail.com>
References: <CACV3+OU1ynRuR2SioW+O+CAp5M7ZQA6af_hEY5JZCVrXpqjtKQ@mail.gmail.com>
	<BTyUDt_7oOQmFj_V61w2eUJ7rfi-eOuNphy5nN0xNAhY4sUHnR2-0U9m-ZEKip4YjFi2-hGBtucvFv7nCTVo3aBxZ94VQCa1Kx2pP_zgdxU=@protonmail.com>
	<CACV3+OWjszx6istHo7yaNxiS22kyhHQhcPxGT3QLDx3KPUMU6g@mail.gmail.com>
Message-ID: <nq9NDv6z-EJuJ9jGMWdlIZbpVM6Rm8QyuWL3nRYtXWF90I-cErA_WS1ib28kt950bZYyfF1_eP153aDjhUy523wYSM9TVaeHqeZdp3xJpsk=@protonmail.com>

Good Morning Matt,

It seems to me that double signing can be punished by requiring that R be a trivial function on the blockheight of the block being signed on the sidechain network. Then a validator who signs multiple versions of history at a particular blockheight reveals their privkey. Since the privkey also protects their Bitcoin stake UTXO, they risk loss of their Bitcoin stake. A similar idea is used by Discrete Log Contracts to ensure Oracles do not sign multiple values at a particular time.

Regards,
ZmnSCPxj


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Saturday, January 19, 2019 1:35 PM, Matt Bell <mappum at gmail.com> wrote:

> Hi ZmnSCPxj,
>
> Just to clarify, my design does not specify the source of voting power, so it is agnostic to whatever system you want to derive stake or valdiator set membership from.
>
> Your idea of timelocking Bitcoin is interesting, I am eager to find a solution where holding Bitcoin is enough to get voting power. It's possible there may be an issue with the fact that the Bitcoin is not slashable (although their voting power is), meaning a validator who double-signs cannot have their Bitcoin removed from them. However their UTXO can be blacklisted which does make their attack costly since they lose out on the time-value of their stake.
>
> Our current thinking for the source of stake is to pay out stake to Bitcoin merged-miners although?I'll definitely do some more thinking about timelocked Bitcoin as stake.
>
> On Fri, Jan 18, 2019, 5:42 PM ZmnSCPxj <ZmnSCPxj at protonmail.com wrote:
>
> > Good morning Matt,
> >
> > It seems to me much more interesting if the stakes used to weigh voting power are UTXOs on the Bitcoin blockchain.
> > This idea is what I call "mainstake"; rather than a blockchain having its own token that is self-attesting (which is insecure).
> > It seems to me, naively, that the same script you propose here can be used for mainstake.
> >
> > For instance, the sidechain network might accept potential stakers on the mainchain, if the staker proves the existence of a mainchain transaction whose output is for example:
> >
> > <sidechain identifier> OP_DROP
> > "1 year" OP_CHECKSEQUENCEVERIFY OP_DROP
> > <pubkey> OP_CHECKSIG
> >
> > The sidechain network could accept this and use the value of the output as the weight of the vote of that stake.
> >
> > Regards,
> > ZmnSCPxj
> >
> > Sent with ProtonMail Secure Email.
> >
> > ??????? Original Message ???????
> > On Saturday, January 19, 2019 6:59 AM, Matt Bell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> > > I have been working on a design for Bitcoin sidechains using the Tendermint BFT consensus protocol, which is commonly used to build proof-of-stake networks (Cosmos is the notable one).
> > >
> > > The design ends up being very similar to Blockstream's Liquid sidechain, since Tendermint consensus is not far off from Liquid's "strong federation" consensus.
> > >
> > > Any feedback about improvements or critical flaws would be greatly appreciated. The design document is here: https://github.com/mappum/bitcoin-peg/blob/master/bitcoinPeg.md (that repo also contains a simplified implementation of this sidechain design).
> > >
> > > Thanks for your feedback,
> > > Matt Bell



From mappum at gmail.com  Mon Jan 21 18:47:13 2019
From: mappum at gmail.com (Matt Bell)
Date: Mon, 21 Jan 2019 10:47:13 -0800
Subject: [bitcoin-dev] Proof-of-Stake Bitcoin Sidechains
In-Reply-To: <nq9NDv6z-EJuJ9jGMWdlIZbpVM6Rm8QyuWL3nRYtXWF90I-cErA_WS1ib28kt950bZYyfF1_eP153aDjhUy523wYSM9TVaeHqeZdp3xJpsk=@protonmail.com>
References: <CACV3+OU1ynRuR2SioW+O+CAp5M7ZQA6af_hEY5JZCVrXpqjtKQ@mail.gmail.com>
	<BTyUDt_7oOQmFj_V61w2eUJ7rfi-eOuNphy5nN0xNAhY4sUHnR2-0U9m-ZEKip4YjFi2-hGBtucvFv7nCTVo3aBxZ94VQCa1Kx2pP_zgdxU=@protonmail.com>
	<CACV3+OWjszx6istHo7yaNxiS22kyhHQhcPxGT3QLDx3KPUMU6g@mail.gmail.com>
	<nq9NDv6z-EJuJ9jGMWdlIZbpVM6Rm8QyuWL3nRYtXWF90I-cErA_WS1ib28kt950bZYyfF1_eP153aDjhUy523wYSM9TVaeHqeZdp3xJpsk=@protonmail.com>
Message-ID: <CACV3+OXQsUsgquJWZ9o8tTtak=axnbsdiNgLzF-j6yz1dDv4bA@mail.gmail.com>

ZmnSCPxj,

I'm intrigued by this mechanism of using fixed R values to prevent multiple
signatures, but how do we derive the R values in a way where they are
unique for each blockheight but still can be used to create signatures or
verify?

Thanks,
Matt

On Sat, Jan 19, 2019 at 6:06 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good Morning Matt,
>
> It seems to me that double signing can be punished by requiring that R be
> a trivial function on the blockheight of the block being signed on the
> sidechain network. Then a validator who signs multiple versions of history
> at a particular blockheight reveals their privkey. Since the privkey also
> protects their Bitcoin stake UTXO, they risk loss of their Bitcoin stake. A
> similar idea is used by Discrete Log Contracts to ensure Oracles do not
> sign multiple values at a particular time.
>
> Regards,
> ZmnSCPxj
>
>
> Sent with ProtonMail Secure Email.
>
> ??????? Original Message ???????
> On Saturday, January 19, 2019 1:35 PM, Matt Bell <mappum at gmail.com> wrote:
>
> > Hi ZmnSCPxj,
> >
> > Just to clarify, my design does not specify the source of voting power,
> so it is agnostic to whatever system you want to derive stake or valdiator
> set membership from.
> >
> > Your idea of timelocking Bitcoin is interesting, I am eager to find a
> solution where holding Bitcoin is enough to get voting power. It's possible
> there may be an issue with the fact that the Bitcoin is not slashable
> (although their voting power is), meaning a validator who double-signs
> cannot have their Bitcoin removed from them. However their UTXO can be
> blacklisted which does make their attack costly since they lose out on the
> time-value of their stake.
> >
> > Our current thinking for the source of stake is to pay out stake to
> Bitcoin merged-miners although I'll definitely do some more thinking about
> timelocked Bitcoin as stake.
> >
> > On Fri, Jan 18, 2019, 5:42 PM ZmnSCPxj <ZmnSCPxj at protonmail.com wrote:
> >
> > > Good morning Matt,
> > >
> > > It seems to me much more interesting if the stakes used to weigh
> voting power are UTXOs on the Bitcoin blockchain.
> > > This idea is what I call "mainstake"; rather than a blockchain having
> its own token that is self-attesting (which is insecure).
> > > It seems to me, naively, that the same script you propose here can be
> used for mainstake.
> > >
> > > For instance, the sidechain network might accept potential stakers on
> the mainchain, if the staker proves the existence of a mainchain
> transaction whose output is for example:
> > >
> > > <sidechain identifier> OP_DROP
> > > "1 year" OP_CHECKSEQUENCEVERIFY OP_DROP
> > > <pubkey> OP_CHECKSIG
> > >
> > > The sidechain network could accept this and use the value of the
> output as the weight of the vote of that stake.
> > >
> > > Regards,
> > > ZmnSCPxj
> > >
> > > Sent with ProtonMail Secure Email.
> > >
> > > ??????? Original Message ???????
> > > On Saturday, January 19, 2019 6:59 AM, Matt Bell via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> > >
> > > > I have been working on a design for Bitcoin sidechains using the
> Tendermint BFT consensus protocol, which is commonly used to build
> proof-of-stake networks (Cosmos is the notable one).
> > > >
> > > > The design ends up being very similar to Blockstream's Liquid
> sidechain, since Tendermint consensus is not far off from Liquid's "strong
> federation" consensus.
> > > >
> > > > Any feedback about improvements or critical flaws would be greatly
> appreciated. The design document is here:
> https://github.com/mappum/bitcoin-peg/blob/master/bitcoinPeg.md (that
> repo also contains a simplified implementation of this sidechain design).
> > > >
> > > > Thanks for your feedback,
> > > > Matt Bell
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190121/d7bc33e3/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Tue Jan 22 09:19:27 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 22 Jan 2019 09:19:27 +0000
Subject: [bitcoin-dev] Proof-of-Stake Bitcoin Sidechains
In-Reply-To: <CACV3+OXQsUsgquJWZ9o8tTtak=axnbsdiNgLzF-j6yz1dDv4bA@mail.gmail.com>
References: <CACV3+OU1ynRuR2SioW+O+CAp5M7ZQA6af_hEY5JZCVrXpqjtKQ@mail.gmail.com>
	<BTyUDt_7oOQmFj_V61w2eUJ7rfi-eOuNphy5nN0xNAhY4sUHnR2-0U9m-ZEKip4YjFi2-hGBtucvFv7nCTVo3aBxZ94VQCa1Kx2pP_zgdxU=@protonmail.com>
	<CACV3+OWjszx6istHo7yaNxiS22kyhHQhcPxGT3QLDx3KPUMU6g@mail.gmail.com>
	<nq9NDv6z-EJuJ9jGMWdlIZbpVM6Rm8QyuWL3nRYtXWF90I-cErA_WS1ib28kt950bZYyfF1_eP153aDjhUy523wYSM9TVaeHqeZdp3xJpsk=@protonmail.com>
	<CACV3+OXQsUsgquJWZ9o8tTtak=axnbsdiNgLzF-j6yz1dDv4bA@mail.gmail.com>
Message-ID: <wTXHV7W_AXHz5xdhXJVJr2OdSpEOaFh0PBQubFdZv4JyF6SlImszj2QyF9G-_Dem06A3iBWLF3vdgiHC_NlsVqy7DFX5XTphajNnMqiU6r0=@protonmail.com>

Good Morning Matt,

> ### ZmnSCPxj,
>
> I'm intrigued by this mechanism of using fixed R values to prevent multiple signatures, but how do we derive the R values in a way where they are
unique for each blockheight but still can be used to create signatures or verify?

One possibility is to derive `R` using standard hierarchical derivation.
Then require that the staking pubkey be revealed to the sidechain network as actually being `staking_pubkey = P + hash(P || parent_R) * G` (possibly with some trivial protection against Taproot).
To sign for a blockheight `h`, you must use your public key `P` and the specific `R` we get from hierarchical derivation from `parent_R` and the blockheight as index.



Regards,
ZmnSCPxj

From satoshin at mybitcoincenter.com  Tue Jan 22 14:58:25 2019
From: satoshin at mybitcoincenter.com (Satoshin)
Date: Tue, 22 Jan 2019 09:58:25 -0500
Subject: [bitcoin-dev] Proof-of-Stake Bitcoin Sidechains
In-Reply-To: <wTXHV7W_AXHz5xdhXJVJr2OdSpEOaFh0PBQubFdZv4JyF6SlImszj2QyF9G-_Dem06A3iBWLF3vdgiHC_NlsVqy7DFX5XTphajNnMqiU6r0=@protonmail.com>
References: <CACV3+OU1ynRuR2SioW+O+CAp5M7ZQA6af_hEY5JZCVrXpqjtKQ@mail.gmail.com>
	<BTyUDt_7oOQmFj_V61w2eUJ7rfi-eOuNphy5nN0xNAhY4sUHnR2-0U9m-ZEKip4YjFi2-hGBtucvFv7nCTVo3aBxZ94VQCa1Kx2pP_zgdxU=@protonmail.com>
	<CACV3+OWjszx6istHo7yaNxiS22kyhHQhcPxGT3QLDx3KPUMU6g@mail.gmail.com>
	<nq9NDv6z-EJuJ9jGMWdlIZbpVM6Rm8QyuWL3nRYtXWF90I-cErA_WS1ib28kt950bZYyfF1_eP153aDjhUy523wYSM9TVaeHqeZdp3xJpsk=@protonmail.com>
	<CACV3+OXQsUsgquJWZ9o8tTtak=axnbsdiNgLzF-j6yz1dDv4bA@mail.gmail.com>
	<wTXHV7W_AXHz5xdhXJVJr2OdSpEOaFh0PBQubFdZv4JyF6SlImszj2QyF9G-_Dem06A3iBWLF3vdgiHC_NlsVqy7DFX5XTphajNnMqiU6r0=@protonmail.com>
Message-ID: <9D2883DC-360C-401A-B518-B8205A3AAA53@mybitcoincenter.com>

This could could be a viable option. I think this is the right approach.

Any downside to this and how much does this add to the blockweight if anything at all.

Anonymouse

> On Jan 22, 2019, at 4:19 AM, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Good Morning Matt,
> 
>> ### ZmnSCPxj,
>> 
>> I'm intrigued by this mechanism of using fixed R values to prevent multiple signatures, but how do we derive the R values in a way where they are
> unique for each blockheight but still can be used to create signatures or verify?
> 
> One possibility is to derive `R` using standard hierarchical derivation.
> Then require that the staking pubkey be revealed to the sidechain network as actually being `staking_pubkey = P + hash(P || parent_R) * G` (possibly with some trivial protection against Taproot).
> To sign for a blockheight `h`, you must use your public key `P` and the specific `R` we get from hierarchical derivation from `parent_R` and the blockheight as index.
> 
> 
> 
> Regards,
> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From dustinpaystaxes at gmail.com  Tue Jan 22 16:33:23 2019
From: dustinpaystaxes at gmail.com (Dustin Dettmer)
Date: Tue, 22 Jan 2019 08:33:23 -0800
Subject: [bitcoin-dev] Proof-of-Stake Bitcoin Sidechains
In-Reply-To: <wTXHV7W_AXHz5xdhXJVJr2OdSpEOaFh0PBQubFdZv4JyF6SlImszj2QyF9G-_Dem06A3iBWLF3vdgiHC_NlsVqy7DFX5XTphajNnMqiU6r0=@protonmail.com>
References: <CACV3+OU1ynRuR2SioW+O+CAp5M7ZQA6af_hEY5JZCVrXpqjtKQ@mail.gmail.com>
	<BTyUDt_7oOQmFj_V61w2eUJ7rfi-eOuNphy5nN0xNAhY4sUHnR2-0U9m-ZEKip4YjFi2-hGBtucvFv7nCTVo3aBxZ94VQCa1Kx2pP_zgdxU=@protonmail.com>
	<CACV3+OWjszx6istHo7yaNxiS22kyhHQhcPxGT3QLDx3KPUMU6g@mail.gmail.com>
	<nq9NDv6z-EJuJ9jGMWdlIZbpVM6Rm8QyuWL3nRYtXWF90I-cErA_WS1ib28kt950bZYyfF1_eP153aDjhUy523wYSM9TVaeHqeZdp3xJpsk=@protonmail.com>
	<CACV3+OXQsUsgquJWZ9o8tTtak=axnbsdiNgLzF-j6yz1dDv4bA@mail.gmail.com>
	<wTXHV7W_AXHz5xdhXJVJr2OdSpEOaFh0PBQubFdZv4JyF6SlImszj2QyF9G-_Dem06A3iBWLF3vdgiHC_NlsVqy7DFX5XTphajNnMqiU6r0=@protonmail.com>
Message-ID: <CABLeJxRmdccf2tVZ4MsdsEj6H9+NnOpp+AeMLZwYh-zTMkWJXw@mail.gmail.com>

Wouldn?t a revealed private key for time locked funds create a race to
spend? I imagine miners who are paying attention would have the advantage
but it would still just be a race.

Would be nice to have the funds destroyed or sent somewhere specific. Like
if somehow the revealed key was actually itself a presigned transaction. Or
perhaps a 32 byte piece of a tx needed to complete it.

On Tue, Jan 22, 2019 at 6:14 AM ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Good Morning Matt,
>
> > ### ZmnSCPxj,
> >
> > I'm intrigued by this mechanism of using fixed R values to prevent
> multiple signatures, but how do we derive the R values in a way where they
> are
> unique for each blockheight but still can be used to create signatures or
> verify?
>
> One possibility is to derive `R` using standard hierarchical derivation.
> Then require that the staking pubkey be revealed to the sidechain network
> as actually being `staking_pubkey = P + hash(P || parent_R) * G` (possibly
> with some trivial protection against Taproot).
> To sign for a blockheight `h`, you must use your public key `P` and the
> specific `R` we get from hierarchical derivation from `parent_R` and the
> blockheight as index.
>
>
>
> Regards,
> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190122/0ef4688e/attachment.html>

From dustinpaystaxes at gmail.com  Tue Jan 22 20:03:06 2019
From: dustinpaystaxes at gmail.com (Dustin Dettmer)
Date: Tue, 22 Jan 2019 12:03:06 -0800
Subject: [bitcoin-dev] Proof-of-Stake Bitcoin Sidechains
In-Reply-To: <9D2883DC-360C-401A-B518-B8205A3AAA53@mybitcoincenter.com>
References: <CACV3+OU1ynRuR2SioW+O+CAp5M7ZQA6af_hEY5JZCVrXpqjtKQ@mail.gmail.com>
	<BTyUDt_7oOQmFj_V61w2eUJ7rfi-eOuNphy5nN0xNAhY4sUHnR2-0U9m-ZEKip4YjFi2-hGBtucvFv7nCTVo3aBxZ94VQCa1Kx2pP_zgdxU=@protonmail.com>
	<CACV3+OWjszx6istHo7yaNxiS22kyhHQhcPxGT3QLDx3KPUMU6g@mail.gmail.com>
	<nq9NDv6z-EJuJ9jGMWdlIZbpVM6Rm8QyuWL3nRYtXWF90I-cErA_WS1ib28kt950bZYyfF1_eP153aDjhUy523wYSM9TVaeHqeZdp3xJpsk=@protonmail.com>
	<CACV3+OXQsUsgquJWZ9o8tTtak=axnbsdiNgLzF-j6yz1dDv4bA@mail.gmail.com>
	<wTXHV7W_AXHz5xdhXJVJr2OdSpEOaFh0PBQubFdZv4JyF6SlImszj2QyF9G-_Dem06A3iBWLF3vdgiHC_NlsVqy7DFX5XTphajNnMqiU6r0=@protonmail.com>
	<9D2883DC-360C-401A-B518-B8205A3AAA53@mybitcoincenter.com>
Message-ID: <CABLeJxT=ne=bP4LrVi=CQhXcSJ64t8FE8vJ=2S_yiVxET-4Xuw@mail.gmail.com>

How could you prove the private key is in the burning transaction?

On Tue, Jan 22, 2019 at 11:56 AM Satoshin via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> This could could be a viable option. I think this is the right approach.
>
> Any downside to this and how much does this add to the blockweight if
> anything at all.
>
> Anonymouse
>
> > On Jan 22, 2019, at 4:19 AM, ZmnSCPxj via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> > Good Morning Matt,
> >
> >> ### ZmnSCPxj,
> >>
> >> I'm intrigued by this mechanism of using fixed R values to prevent
> multiple signatures, but how do we derive the R values in a way where they
> are
> > unique for each blockheight but still can be used to create signatures
> or verify?
> >
> > One possibility is to derive `R` using standard hierarchical derivation.
> > Then require that the staking pubkey be revealed to the sidechain
> network as actually being `staking_pubkey = P + hash(P || parent_R) * G`
> (possibly with some trivial protection against Taproot).
> > To sign for a blockheight `h`, you must use your public key `P` and the
> specific `R` we get from hierarchical derivation from `parent_R` and the
> blockheight as index.
> >
> >
> >
> > Regards,
> > ZmnSCPxj
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190122/46b08c8b/attachment-0001.html>

From adam at cypherspace.org  Tue Jan 22 20:22:36 2019
From: adam at cypherspace.org (Dr Adam Back)
Date: Tue, 22 Jan 2019 21:22:36 +0100
Subject: [bitcoin-dev] Proof-of-Stake Bitcoin Sidechains
In-Reply-To: <wTXHV7W_AXHz5xdhXJVJr2OdSpEOaFh0PBQubFdZv4JyF6SlImszj2QyF9G-_Dem06A3iBWLF3vdgiHC_NlsVqy7DFX5XTphajNnMqiU6r0=@protonmail.com>
References: <CACV3+OU1ynRuR2SioW+O+CAp5M7ZQA6af_hEY5JZCVrXpqjtKQ@mail.gmail.com>
	<BTyUDt_7oOQmFj_V61w2eUJ7rfi-eOuNphy5nN0xNAhY4sUHnR2-0U9m-ZEKip4YjFi2-hGBtucvFv7nCTVo3aBxZ94VQCa1Kx2pP_zgdxU=@protonmail.com>
	<CACV3+OWjszx6istHo7yaNxiS22kyhHQhcPxGT3QLDx3KPUMU6g@mail.gmail.com>
	<nq9NDv6z-EJuJ9jGMWdlIZbpVM6Rm8QyuWL3nRYtXWF90I-cErA_WS1ib28kt950bZYyfF1_eP153aDjhUy523wYSM9TVaeHqeZdp3xJpsk=@protonmail.com>
	<CACV3+OXQsUsgquJWZ9o8tTtak=axnbsdiNgLzF-j6yz1dDv4bA@mail.gmail.com>
	<wTXHV7W_AXHz5xdhXJVJr2OdSpEOaFh0PBQubFdZv4JyF6SlImszj2QyF9G-_Dem06A3iBWLF3vdgiHC_NlsVqy7DFX5XTphajNnMqiU6r0=@protonmail.com>
Message-ID: <CALqxMTFC9uEarJ7wA3LcLbpNtWfqrkqbadADgpbeUA7ixVDhcQ@mail.gmail.com>

Brands credentials use this single show, and multiple show
credentials. It's based on the representation problem which is the
generalisation to multiple bases where Schnorr is one base, Pedersen
Commitments are two bases, Representation problem is n>2 bases.

The method used would work for Schnorr or DSA and there was some 2013
era #bitcoin-wizards discussion on this topic, where if you spend
twice miners can take your money, as a strong way to "discourage"
address reuse.  One side effect though is you force ACID log oriented
storage on the wallet, and many wallets are low power devices or even
a few in VMs that could be snapshotted or rolled back. Similar risk
model to the lightning penalty for accidentally doing a hostile close
in the current model (where ELTOO has non-penalty based close).

You would have to be careful to not use related nonces (k=nonce
committed to by R=kG), as Schnorr and DSA are highly vulnerable to
that, like simultaneous equation two samples solvable.

What the Brands n-show credential looks like is a precommitment like
single show the address becomes A=H(R,Q) where Q is the public key,
and n-show becomes A=H(R1,...,Rn,Q).

Signing becomes providing i,Ri,Q in the Script to satisfy a
ScriptPubKey that includes the three. You would need to in practice
store the Ri values in a merkle tree probably so that you don't need
to provide n inputs, but log(n) or some other structuring.

Anyway main point being the fragility to related nonces, and cost of
ACID log structured storage levels of reliability in wallets.

Adam

On Tue, 22 Jan 2019 at 15:14, ZmnSCPxj via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Good Morning Matt,
>
> > ### ZmnSCPxj,
> >
> > I'm intrigued by this mechanism of using fixed R values to prevent multiple signatures, but how do we derive the R values in a way where they are
> unique for each blockheight but still can be used to create signatures or verify?
>
> One possibility is to derive `R` using standard hierarchical derivation.
> Then require that the staking pubkey be revealed to the sidechain network as actually being `staking_pubkey = P + hash(P || parent_R) * G` (possibly with some trivial protection against Taproot).
> To sign for a blockheight `h`, you must use your public key `P` and the specific `R` we get from hierarchical derivation from `parent_R` and the blockheight as index.
>
>
>
> Regards,
> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From ZmnSCPxj at protonmail.com  Thu Jan 24 10:03:25 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 24 Jan 2019 10:03:25 +0000
Subject: [bitcoin-dev] Proof-of-Stake Bitcoin Sidechains
In-Reply-To: <CABLeJxRmdccf2tVZ4MsdsEj6H9+NnOpp+AeMLZwYh-zTMkWJXw@mail.gmail.com>
References: <CACV3+OU1ynRuR2SioW+O+CAp5M7ZQA6af_hEY5JZCVrXpqjtKQ@mail.gmail.com>
	<BTyUDt_7oOQmFj_V61w2eUJ7rfi-eOuNphy5nN0xNAhY4sUHnR2-0U9m-ZEKip4YjFi2-hGBtucvFv7nCTVo3aBxZ94VQCa1Kx2pP_zgdxU=@protonmail.com>
	<CACV3+OWjszx6istHo7yaNxiS22kyhHQhcPxGT3QLDx3KPUMU6g@mail.gmail.com>
	<nq9NDv6z-EJuJ9jGMWdlIZbpVM6Rm8QyuWL3nRYtXWF90I-cErA_WS1ib28kt950bZYyfF1_eP153aDjhUy523wYSM9TVaeHqeZdp3xJpsk=@protonmail.com>
	<CACV3+OXQsUsgquJWZ9o8tTtak=axnbsdiNgLzF-j6yz1dDv4bA@mail.gmail.com>
	<wTXHV7W_AXHz5xdhXJVJr2OdSpEOaFh0PBQubFdZv4JyF6SlImszj2QyF9G-_Dem06A3iBWLF3vdgiHC_NlsVqy7DFX5XTphajNnMqiU6r0=@protonmail.com>
	<CABLeJxRmdccf2tVZ4MsdsEj6H9+NnOpp+AeMLZwYh-zTMkWJXw@mail.gmail.com>
Message-ID: <8u0ExA_vvhRGzmFmxUoyqk6IBrnUEtEHAEMKzqLWLxC6IgBtvZR24jZBgeMeJlsPcjJKYgVar_rC388ZNjP09ZUkukfP1KRcL9NMDkrVrQM=@protonmail.com>

Good morning Dustin,

> Wouldn?t a revealed private key for time locked funds create a race to spend? I imagine miners who are paying attention would have the advantage but it would still just be a race.

If Bitcoin had implemented RBF "properly" (i.e. not have the silly "opt-out" rule) then such races are won by bidding up the fees.  A random person who is not the original staker would be willing to pay miners a fee up to the entire staked amount minus dustlimit satoshis; obviously a staker would be far less willing to pay up such a fee, so the random person slashing the funds would have a major advantage in that race.
Thus the race will be won by whoever mines the highest-fee transaction.
It still becomes very unlikely that the staker will win unless the staker already has a significant mining hashpower (and if the staker has significant hashpower, then the Bitoin layer itself is at peril anyway, never mind sidechains built on top of it).

Regards,
ZmnSCPxj

>
> On Tue, Jan 22, 2019 at 6:14 AM ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > Good Morning Matt,
> >
> > > ### ZmnSCPxj,
> > >
> > > I'm intrigued by this mechanism of using fixed R values to prevent multiple signatures, but how do we derive the R values in a way where they are
> > unique for each blockheight but still can be used to create signatures or verify?
> >
> > One possibility is to derive `R` using standard hierarchical derivation.
> > Then require that the staking pubkey be revealed to the sidechain network as actually being `staking_pubkey = P + hash(P || parent_R) * G` (possibly with some trivial protection against Taproot).
> > To sign for a blockheight `h`, you must use your public key `P` and the specific `R` we get from hierarchical derivation from `parent_R` and the blockheight as index.
> >
> > Regards,
> > ZmnSCPxj
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From mappum at gmail.com  Thu Jan 24 18:46:11 2019
From: mappum at gmail.com (Matt Bell)
Date: Thu, 24 Jan 2019 10:46:11 -0800
Subject: [bitcoin-dev] Proof-of-Stake Bitcoin Sidechains
In-Reply-To: <8u0ExA_vvhRGzmFmxUoyqk6IBrnUEtEHAEMKzqLWLxC6IgBtvZR24jZBgeMeJlsPcjJKYgVar_rC388ZNjP09ZUkukfP1KRcL9NMDkrVrQM=@protonmail.com>
References: <CACV3+OU1ynRuR2SioW+O+CAp5M7ZQA6af_hEY5JZCVrXpqjtKQ@mail.gmail.com>
	<BTyUDt_7oOQmFj_V61w2eUJ7rfi-eOuNphy5nN0xNAhY4sUHnR2-0U9m-ZEKip4YjFi2-hGBtucvFv7nCTVo3aBxZ94VQCa1Kx2pP_zgdxU=@protonmail.com>
	<CACV3+OWjszx6istHo7yaNxiS22kyhHQhcPxGT3QLDx3KPUMU6g@mail.gmail.com>
	<nq9NDv6z-EJuJ9jGMWdlIZbpVM6Rm8QyuWL3nRYtXWF90I-cErA_WS1ib28kt950bZYyfF1_eP153aDjhUy523wYSM9TVaeHqeZdp3xJpsk=@protonmail.com>
	<CACV3+OXQsUsgquJWZ9o8tTtak=axnbsdiNgLzF-j6yz1dDv4bA@mail.gmail.com>
	<wTXHV7W_AXHz5xdhXJVJr2OdSpEOaFh0PBQubFdZv4JyF6SlImszj2QyF9G-_Dem06A3iBWLF3vdgiHC_NlsVqy7DFX5XTphajNnMqiU6r0=@protonmail.com>
	<CABLeJxRmdccf2tVZ4MsdsEj6H9+NnOpp+AeMLZwYh-zTMkWJXw@mail.gmail.com>
	<8u0ExA_vvhRGzmFmxUoyqk6IBrnUEtEHAEMKzqLWLxC6IgBtvZR24jZBgeMeJlsPcjJKYgVar_rC388ZNjP09ZUkukfP1KRcL9NMDkrVrQM=@protonmail.com>
Message-ID: <CACV3+OX-mx6eLMOvk5eh6nKGmS_6ZHR=G76LCCCkiPugB9NgRg@mail.gmail.com>

It seems that miners would always claim the stake for themselves, why not
since the private key is public knowledge anyway? This is a nice security
property since it wouldn't make economical sense for a miner to take a
bribe from an attacker since it would have to be less than the stake amount.

It still becomes very unlikely that the staker will win unless the staker
> already has a significant mining hashpower (and if the staker has
> significant hashpower, then the Bitoin layer itself is at peril anyway,
> never mind sidechains built on top of it).


Since the likelihood of a successful attack is proportional to the
attacker's share of the Bitcoin hashrate, the sidechain's integrity
essentially has the same security level as the Bitcoin main chain.
Although, the Bitcoin which was moved to the sidechain is susceptible to
being stolen if 67% of the stakers collude, which does makes storing funds
on it weaker to some degree.

On Thu, Jan 24, 2019 at 2:03 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Dustin,
>
> > Wouldn?t a revealed private key for time locked funds create a race to
> spend? I imagine miners who are paying attention would have the advantage
> but it would still just be a race.
>
> If Bitcoin had implemented RBF "properly" (i.e. not have the silly
> "opt-out" rule) then such races are won by bidding up the fees.  A random
> person who is not the original staker would be willing to pay miners a fee
> up to the entire staked amount minus dustlimit satoshis; obviously a staker
> would be far less willing to pay up such a fee, so the random person
> slashing the funds would have a major advantage in that race.
> Thus the race will be won by whoever mines the highest-fee transaction.
> It still becomes very unlikely that the staker will win unless the staker
> already has a significant mining hashpower (and if the staker has
> significant hashpower, then the Bitoin layer itself is at peril anyway,
> never mind sidechains built on top of it).
>
> Regards,
> ZmnSCPxj
>
> >
> > On Tue, Jan 22, 2019 at 6:14 AM ZmnSCPxj via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> > > Good Morning Matt,
> > >
> > > > ### ZmnSCPxj,
> > > >
> > > > I'm intrigued by this mechanism of using fixed R values to prevent
> multiple signatures, but how do we derive the R values in a way where they
> are
> > > unique for each blockheight but still can be used to create signatures
> or verify?
> > >
> > > One possibility is to derive `R` using standard hierarchical
> derivation.
> > > Then require that the staking pubkey be revealed to the sidechain
> network as actually being `staking_pubkey = P + hash(P || parent_R) * G`
> (possibly with some trivial protection against Taproot).
> > > To sign for a blockheight `h`, you must use your public key `P` and
> the specific `R` we get from hierarchical derivation from `parent_R` and
> the blockheight as index.
> > >
> > > Regards,
> > > ZmnSCPxj
> > > _______________________________________________
> > > bitcoin-dev mailing list
> > > bitcoin-dev at lists.linuxfoundation.org
> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190124/edf6f67a/attachment.html>

From pete at petertodd.org  Fri Jan 25 00:16:30 2019
From: pete at petertodd.org (Peter Todd)
Date: Fri, 25 Jan 2019 00:16:30 +0000
Subject: [bitcoin-dev] Proof-of-Stake Bitcoin Sidechains
In-Reply-To: <8u0ExA_vvhRGzmFmxUoyqk6IBrnUEtEHAEMKzqLWLxC6IgBtvZR24jZBgeMeJlsPcjJKYgVar_rC388ZNjP09ZUkukfP1KRcL9NMDkrVrQM=@protonmail.com>
References: <CACV3+OU1ynRuR2SioW+O+CAp5M7ZQA6af_hEY5JZCVrXpqjtKQ@mail.gmail.com>
	<BTyUDt_7oOQmFj_V61w2eUJ7rfi-eOuNphy5nN0xNAhY4sUHnR2-0U9m-ZEKip4YjFi2-hGBtucvFv7nCTVo3aBxZ94VQCa1Kx2pP_zgdxU=@protonmail.com>
	<CACV3+OWjszx6istHo7yaNxiS22kyhHQhcPxGT3QLDx3KPUMU6g@mail.gmail.com>
	<nq9NDv6z-EJuJ9jGMWdlIZbpVM6Rm8QyuWL3nRYtXWF90I-cErA_WS1ib28kt950bZYyfF1_eP153aDjhUy523wYSM9TVaeHqeZdp3xJpsk=@protonmail.com>
	<CACV3+OXQsUsgquJWZ9o8tTtak=axnbsdiNgLzF-j6yz1dDv4bA@mail.gmail.com>
	<wTXHV7W_AXHz5xdhXJVJr2OdSpEOaFh0PBQubFdZv4JyF6SlImszj2QyF9G-_Dem06A3iBWLF3vdgiHC_NlsVqy7DFX5XTphajNnMqiU6r0=@protonmail.com>
	<CABLeJxRmdccf2tVZ4MsdsEj6H9+NnOpp+AeMLZwYh-zTMkWJXw@mail.gmail.com>
	<8u0ExA_vvhRGzmFmxUoyqk6IBrnUEtEHAEMKzqLWLxC6IgBtvZR24jZBgeMeJlsPcjJKYgVar_rC388ZNjP09ZUkukfP1KRcL9NMDkrVrQM=@protonmail.com>
Message-ID: <23C4B29C-0A0C-4680-BF99-3A86C215BE34@petertodd.org>



On January 24, 2019 10:03:25 AM UTC, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>Good morning Dustin,
>
>> Wouldn?t a revealed private key for time locked funds create a race
>to spend? I imagine miners who are paying attention would have the
>advantage but it would still just be a race.
>
>If Bitcoin had implemented RBF "properly" (i.e. not have the silly
>"opt-out" rule) then such races are won by bidding up the fees.  A

Note that CSV using transactions are always RBF as CSV disables the opt-out.
-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 500 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190125/471ee608/attachment.sig>

From ZmnSCPxj at protonmail.com  Fri Jan 25 05:33:37 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 25 Jan 2019 05:33:37 +0000
Subject: [bitcoin-dev] Proof-of-Stake Bitcoin Sidechains
In-Reply-To: <23C4B29C-0A0C-4680-BF99-3A86C215BE34@petertodd.org>
References: <CACV3+OU1ynRuR2SioW+O+CAp5M7ZQA6af_hEY5JZCVrXpqjtKQ@mail.gmail.com>
	<BTyUDt_7oOQmFj_V61w2eUJ7rfi-eOuNphy5nN0xNAhY4sUHnR2-0U9m-ZEKip4YjFi2-hGBtucvFv7nCTVo3aBxZ94VQCa1Kx2pP_zgdxU=@protonmail.com>
	<CACV3+OWjszx6istHo7yaNxiS22kyhHQhcPxGT3QLDx3KPUMU6g@mail.gmail.com>
	<nq9NDv6z-EJuJ9jGMWdlIZbpVM6Rm8QyuWL3nRYtXWF90I-cErA_WS1ib28kt950bZYyfF1_eP153aDjhUy523wYSM9TVaeHqeZdp3xJpsk=@protonmail.com>
	<CACV3+OXQsUsgquJWZ9o8tTtak=axnbsdiNgLzF-j6yz1dDv4bA@mail.gmail.com>
	<wTXHV7W_AXHz5xdhXJVJr2OdSpEOaFh0PBQubFdZv4JyF6SlImszj2QyF9G-_Dem06A3iBWLF3vdgiHC_NlsVqy7DFX5XTphajNnMqiU6r0=@protonmail.com>
	<CABLeJxRmdccf2tVZ4MsdsEj6H9+NnOpp+AeMLZwYh-zTMkWJXw@mail.gmail.com>
	<8u0ExA_vvhRGzmFmxUoyqk6IBrnUEtEHAEMKzqLWLxC6IgBtvZR24jZBgeMeJlsPcjJKYgVar_rC388ZNjP09ZUkukfP1KRcL9NMDkrVrQM=@protonmail.com>
	<23C4B29C-0A0C-4680-BF99-3A86C215BE34@petertodd.org>
Message-ID: <Bug73hgjU4TRIBFN5mQOLITGwsT5nHcr4J4ssOL2qXcLVh-GHClWYNm6UK-snj9uJFrVrcW2OQWZ94DhzukauNp-L1jk53p0J6WbekbKvpQ=@protonmail.com>


Good mornint Peter,

> > > Wouldn?t a revealed private key for time locked funds create a race
> > > to spend? I imagine miners who are paying attention would have the
> > > advantage but it would still just be a race.
> >
> > If Bitcoin had implemented RBF "properly" (i.e. not have the silly
> > "opt-out" rule) then such races are won by bidding up the fees. A
>
> Note that CSV using transactions are always RBF as CSV disables the opt-out.
>

Thank you for this information.
I forgot that RBF opt-out was hacked on top of `nSequence`, and relative timelocks were also hacked on top of `nSequence`.
In particular coins locked on mainchain for the purpose of staking a sidechain (mainstake) have to be locked with an `OP_CSV`, which immediately enables this protection.

Regards,
ZmnSCPxj

From ekaggata at gmail.com  Fri Jan 25 14:47:34 2019
From: ekaggata at gmail.com (Adam Gibson)
Date: Fri, 25 Jan 2019 15:47:34 +0100
Subject: [bitcoin-dev] bustapay BIP :: a practical sender/receiver
 coinjoin protocol
In-Reply-To: <TtjH2zicjKr8PBVCMOvA7ryt2z_XXvtrpC4y1wuWSxexNwMdbPGE7vPmu6UnzmfYqYBMxZ8NNoz4VUnODdIcjR4j-E1sYz_FA6ZZMjKHtuM=@protonmail.com>
References: <TtjH2zicjKr8PBVCMOvA7ryt2z_XXvtrpC4y1wuWSxexNwMdbPGE7vPmu6UnzmfYqYBMxZ8NNoz4VUnODdIcjR4j-E1sYz_FA6ZZMjKHtuM=@protonmail.com>
Message-ID: <e15c5dd7-6fe1-b253-e129-aeae6493acd1@gmail.com>

Ryan and list,
I want to add some commentary to this (BIP79) to see if we can get
further in standardizing this idea.

When I first mulled it over I thought it too impractical, but its virtue
of steganographic hiding means only minimal uptake is still enormously
interesting and worth pursuing; that's my current feeling. I've offered
more detailed thoughts in my blog post[1] (def not required reading here).

Both Joinmarket and Samourai have started implementing this kind of
transaction. And while that's interesting experimentally, some kind of
cross-wallet standard would be helpful, albeit there some differences
between that and the merchant/centralized service use-case.

We might imagine as a concrete goal for this BIP to create something
that would be acceptable for inclusion into a project like BTCPayServer,
so that it could be used in a realistic use case by smaller bitcoin
accepting merchants.

Comments to the BIP[2] as follows, with generic comments first, and then
specific comments for existing points in the BIP:

[1] https://joinmarket.me/blog/blog/payjoin
[2] https://github.com/bitcoin/bips/blob/master/bip-0079.mediawiki

Generic comments
============
* Protocol versioning. Since inevitably (even if only merchants), this
must be implemented by multiple wallets to be useful, the communication
protocol will need versioning (for example i have in my
simple/experimental Joinmarket PayJoin that sender sends min and max
supported version and receiver responds with a chosen protocol version
so we can update). I do understand that as a client-server model can
apply here, we can ditch a lot of the complexities around network/p2p
interaction, but this much at least seems necessary.
* Although it has its logic, I don't think "Bustapay" is a good name for
this protocol. I prefer "PayJoin" which is neutral sounding and
self-descriptive. Needless to say this is not a hill I intend to die on.
* PSBT/BIP174. I realise this has already been discussed, but this is a
good example of what this standardisation was designed for, so I'd be
against not including it, even given the reality that, as you correctly
observe, it is not yet implemented in the majority of wallets and
libraries. One way round that is to make it optional (possibly combined
with above point about versioning). Note that for example you were
observing the necessity to check the sequence number was unchanged; that
would be encapsulated by checking equality of PSBT Input objects/fields.
While one can make such software architecture arguments, the really
fundamental point is the need for standards for x-wallet compatibility.
* Version, Locktime: Perhaps this is not needed; in a peer to peer
wallet scenario I think there might be logic in trying to get cover
traffic of (Core, Electrum, others), say, by using
last-block-locktime-mostly, as they do. Version should be 2 and sequence
is a function of your suggestion to use BIP125. Worth noting that BIP125
is *not* currently widely used on the network, though (see
https://p2sh.info/dashboard/db/replace-by-fee?orgId=1). For this reason
it should perhaps be explicitly only optional.
* Avoidance of non-payment "Unnecessary Input Heuristic" (1, 2). For
reference, see the definition here
https://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e#gistcomment-2796539
and some data here
https://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e#gistcomment-2800791
(whole comment thread may be of interest) - note this UIH name is afaik
Chris Belcher's invention, it seems useful as a categorisation.
 So, it seems that UIH2 is more important to avoid; while some more
sophisticated wallet coin selection algorithms *may* occasionally pick
an input set where one input is larger than any output, most won't, and
some in particular never will. So I think the text here should indicate
that *the receiver's contributed input(s) SHOULD be chosen to avoid
triggering the UIH2 heuristic where possible, so that the final payjoin
transaction is maximally plausible as an ordinary payment" or similar.
UIH1 is a nice-to-have (meaning the plausibility extends to two
different (both wrong) payment amounts, but it may not be necessary to
mention it in the BIP.


Specific comments
=================

>> ====Step 4. Receiver validates, re-signs, and propagates on the
bitcoin network====

I believe this should say "Sender" not Receiver. Also for the next
sentence, s/receiver/sender/:

>> The receiver MUST validate the ''partial transaction'' was changed
correctly and non-maliciously (to allow using potentially untrusted
communication channels), re-sign its original inputs and propagate the
final transaction over the bitcoin network.

Your very correct highlighting of the attack vector of "receiver gives
sender other inputs belonging to sender to unwittingly sign (described
below), should be highlighted here, perhaps with the phrase "re-sign its
ORIGINAL inputs" (only!)".

>> When the sender is creating a "template transaction" it is done
almost identically to creating a normal send, with the exception that
*only* segwit inputs may be used. The sender is also encouraged to use a
slightly more aggressive feerate than usual as well as BIP125 (Opt-in
Full Replace-by-Fee Signaling), but neither is strictly required.

"slightly more aggressive feerate than usual" - this I understand is to
make up for receiver contributed utxo, OK.

"*only* segwit inputs" - it certainly makes things simpler. One can work
with non-segwit inputs but especially considering (as mentioned below)
we really ought to "MUST" the part about matching input types, I tend to
agree that non-segwit should be disallowed.

>> The receiver must add at least one input to the transaction (the
"contributed inputs"). If the receiver has no inputs, it should use a
500 internal server error, so the client can send the transaction as per
normal (or try again later).

Would it not be much simpler for the server to return a different
(non-error) response indicating that it will broadcast the template tx
in this case?

>> Its generally advised to only add a single contributed input, however
they are circumstances where adding more than a single input can be useful.

I don't see a good reason to advise the use of only 1 input? (but this
will also connect with the above generic comment about "UIH"). I guess
it's because of your approach to fees. I'd prefer not to create a
limitation here.

>> To prevent an attack where a receiver is continually sent variations
of the same transaction to enumerate the receivers utxo set, it is
essential that the receiver always returns the same contributed inputs
when it's seen the same inputs.

This is an approach to avoiding this problem which has the virtue of
simplicity, but it seems a little problematic. (1) You must keep a
mapping of proposed payment utxos to one's proposed contributed input
utxos, but (2) how should this be updated if you need to spend the
contribution mentioned in (1)? Ironically use of payjoin exacerbates
this issue, because it results in a smaller number of utxos being held
by the receiver at any one time :) All this considered, I still see the
value in your approach, but it might end up with a re-attempted payment
being rejected. Certainly the more complex suggested solutions coming
out of the summer 2018 coinjoin workshop aren't as practical as this,
and may be overkill for small merchants/receivers.

>> It is strongly preferable that the receiver makes an effort to pick a
contributed input of the same type as the other transaction inputs if
possible.

I have also thought about this and you could reasonably argue this
should be a MUST section in the BIP, that is, if the receiver cannot use
inputs of the same type, he should fall back to the template
transaction. A mixed-input payjoin/coinjoin is essentially
near-perfectly identifiable as such (there is almost zero other usage of
multi-type-input transactions), which is a very different thing than a
non-identifiable payjoin transaction. That may or may not be OK to the
sender. This is debatable though, for sure.

>> After adding inputs to the transaction, the receiver generally will
want to adjust the output that pays himself by increasing it by the sum
of the contributed input amounts (minus any fees he wants to
contribute). However the only strict requirement is that the receiver
*must never* add or remove inputs, and *must not* ever decrease any
output amount.

"*must never* add or remove inputs" - did you mean "must never remove
inputs"? he surely has to add one! Or, perhaps you mean he must not
alter the list of inputs provided by the sender (in which case it should
be clarified).

"must not decrease any output amount" - I initally disagreed with this
but it is a better option than the one I currently chose in Joinmarket
payjoin (sender pays all fee as long as receiver utxos are not too
much). So this means that the receiver either consciously chooses to not
increase the fee, meaning the fee rate may be a bit low (hence your
earlier comment about being generous, got it), or contributes via the
payout amount. I guess the latter might break merchant software
expecting to have amount output fixed and fees determined by change.

Regards,
Adam Gibson/waxwing

On 30. 08. 18 22:24, Ryan Havar via bitcoin-dev wrote:
> I've just finished writing an implementing of this, and extremely happy
> with how it turned out. So I'd like to go and try go down the path of
> more formally describing it and getting some comments and ultimately
> encourage its wide-spread use.
> 
> 
> ==Abstract==
> 
> The way bitcoin transactions are overwhelming used is known to leak more
> information than desirable. This has lead to fungibility concerns in bitcoin
> and a raise of unreasonably effective blockchain analysis.
> 
> Bustapay proposes a simple, practical way to bust these assumptions to
> immediate
> benefit of the sender and recievers. Furthermore it does so in such a
> way that
> helps recievers avoid utxo bloat, a constant problem for bitcoin merchants.
> 
> ==Copyright==
> 
> This BIP is in the public domain.
> 
> ==Motivation==
> 
> One of the most powerful heuristic's employed by those whose goal is to
> undermine
> bitcoin's fungiblity has been to assume all inputs of a transaction are
> signed by
> a single party. In the few cases this assumption does not hold, it is
> generally
> readibly recognizable (e.g. traditional coinjoins have a very obvious
> structure,
> or multisig outputs are most frequently validated onchain).
> 
> Bustapay requires no changes to bitcoin and creates bitcoin transactions
> that are
> indistinguishable from normal ones.
> 
> It is worth noting that this specification has been intentionally kept
> as simple
> as possible to encourage adoption. There are almost an endless amount of
> extensions
> possible but the harder the implementation of clients/server the less
> likely it
> will ever be done. Should bustapay enjoy widespread adoption, a "v2"
> specification
> will be created with desired extensions.
> 
> ==Specification==
> 
> A bustapay payment is made from a sender to a receiver.
> 
> Step 1. Sender creates a bitcoin transaction paying the receiver
> 
> This transaction must be fully valid, signed and all inputs must use
> segwit. This transaction is known as the "template transaction". This
> transaction must not be propagated on the bitcoin network.
> 
> Step 2. Sender gives the "template transaction" to the receiver
> 
> This would generally be done as an HTTP POST. The exact URL to submit it
> to could be specified with a bip21 encoded address. Such as
> bitcoin:2NABbUr9yeRCp1oUCtVmgJF8HGRCo3ifpTT?bustapay=https://bp.bustabit.com/submit
> and the HTTP body should be the raw transaction hex encoded as text.
> 
> Step 3. Receiver processes the transaction and returns a partially
> signed coinjoin
> 
> The receiver validates the transaction is valid, pays himself and is
> eligible for propation. The receiver then adds one of his own inputs
> (known as the "contributed input") and increase the output that pays
> himself by the contributed input amount. Doing so will invalidate the
> "template transaction"'s original input signatures, so the sender needs
> to return this "partial transaction" back to the receiver to sign. This
> is returned as a hex-encoded raw transaction a response to the original
> HTTP POST request.
> 
> Step 4. Receiver validates, re-signs, and propagates on the bitcoin network
> 
> The receiver is responsible in making sure the "partial transaction"
> returned by the sender was changed correctly (it should assume the
> connection has been MITM'd and act accordingly), resign its original
> inputs and propagates this transaction over the bitcoin network. The
> client must be aware that the server can reorder inputs and outputs.
> 
> Step 5. Receiver observes the finalized transaction on the bitcoin network
> 
> Once the receiver has seen the finalized transactions on the network
> (and has enough confirmations) it can process it like a normal payment
> for the sent amount (as opposed to the amount that it looks like on the
> network). If the receiver does not see the finalized transaction after a
> timeout will propagate the original "template transaction" to ensure the
> payment happens and function a strong anti-DoS mechanism.
> 
> 
> === Implementation Notes ===
> For anyone wanting to implement bustapay payments, here are some notes
> for receivers:
> 
> * A transaction can easily be checked if it's suitable for the mempool
> with testmempoolaccept in bitcoin core 0.17
> * Tracking transactions by txid is precarious. To keep your sanity make
> sure all inputs are segwit. But remember segwit does not prevent txid
> malleability unless you validate the transaction. So really make sure
> you're using testmempoolaccept at the very least
> * Bustapay could be abused by a malicious party to query if you own a
> deposit address or not. So never accept a bustapay transaction that pays
> an already used deposit address
> * You will need to keep a mapping of which utxos people have showed you
> and which you revealed. So if you see them again, you can reveal the
> same one of your own
> * Check if the transaction was already sorted according to BIP69, if so
> ensure the result stays that way. Otherwise probably just shuffle the
> inputs/outpus
> 
> Notes for sending applications:
> 
> * The HTTP response must *not* be trusted. It should be fully validated
> that no unexpected changes have been made to the transaction.
> * The sender should be aware the original "template transaction" may be
> propagated at any time, and in fact can intentionally be
> ? done so for the purpose of RBF as it should have a slightly higher fee
> rate.
> 
> == Credits ==
> The idea is obviously based upon Dr. Maxwell's seminal CoinJoin
> proposal, and reduced scope inspired by a simplification of the "pay 2
> endpoint" (now offline) blog post by blockstream.
> 
> 
> -Ryan
> 
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From rhavar at protonmail.com  Sun Jan 27 07:36:59 2019
From: rhavar at protonmail.com (rhavar at protonmail.com)
Date: Sun, 27 Jan 2019 07:36:59 +0000
Subject: [bitcoin-dev] bustapay BIP :: a practical sender/receiver
	coinjoin protocol
In-Reply-To: <e15c5dd7-6fe1-b253-e129-aeae6493acd1@gmail.com>
References: <TtjH2zicjKr8PBVCMOvA7ryt2z_XXvtrpC4y1wuWSxexNwMdbPGE7vPmu6UnzmfYqYBMxZ8NNoz4VUnODdIcjR4j-E1sYz_FA6ZZMjKHtuM=@protonmail.com>
	<e15c5dd7-6fe1-b253-e129-aeae6493acd1@gmail.com>
Message-ID: <-yZhdFkKfKAEz1_4GKKSpTxjvR8EDSsH_5-TTh_4X5qwa79igXKR14rh6JASrald-F97o1htWY_kcBQ7IVr7ZH9zOQlOEwzhkWDjTq0d7F4=@protonmail.com>

Thanks Adam,

I have fixed the mistakes you have pointed out: https://github.com/bitcoin/bips/pull/754

Thanks for the detailed look!

> but its virtue of steganographic hiding means only minimal uptake
> is still enormously interesting and worth pursuing; that's my current feeling.

I very much agree =) I really think anything that (silently) breaks the assumption of common ownership of transaction inputs offers outsized benefits for the whole ecosystem.

One other idea I have  is (way) better support for moving utxo's between wallets. The least controversial use case is moving funds between wallets you own. Like I might want to move *specific* utxo's from/to my joinmarket wallet, but not create a (privacy losing / expensive) transaction. Both core and joinmarket fail at this at a practical point of view.

Like imho it'd be pretty cool having a standardized format for (txid:vout:privatekey) with wallets showing it as "External UTXO" and preferentially spending it (and wallet not automatically importing any other utxo from that address).

Taken a bit further (this is the part which everyone hates) you could send someone money (or withdraw it from a service) by giving a person. It's not generally useful (for obvious reasons), but there's a lot of cases I think it's super cool.

---

Getting back on topic, without trying to do a point-by-point reply, I agree with pretty much everything you said but I am reluctant to make any changes.

I don't meant to be obtuse or anything, but I strongly believe the limiting factor to adoption to all these protocols is actually just getting people to implement it. I made multiple implementations of bustapay from both the sending/receiving end, so I could try develop the easiest to implement system that is still practical.

For instance I like PSBT and it's nice in theory. I actually had an original implementation using it, which is how I found some bugs in the core and golang version of PSBT). But in practice it's hugely overkill and significantly increases the implementation complexity complexity and is poorly supported. Switching to just a raw transaction actually made everything easier. (And that's not to criticise PSBT, I would definitely want to use it in other contexts).

Anyway, a big motivation for me even writing it as a BIP was to formalize my little anti-DOS trick of privately creating a "template transaction" which can just be dumped on the network as punishment. So if nothing else, hopefully I'll have demonstrated it's a pretty practical way of doing things.

--

Also your analysis on "Unnecessary Input Heuristic" is pretty cool, but I also don't like telling people to "avoid the UIH2" without providing the actual algo they should use. But really I think it's better off in a sort of article "how to pick contributed inputs" or something, as while it's nice it's not a huge deal and there's a lot of debatable tradeoffs that can/should be used. For instance the implementation I wrote for bustabit.com currently just heavily biases tainted inputs (e.g. ones associated with address reuse).



-Ryan

??????? Original Message ???????
On Friday, January 25, 2019 6:47 AM, Adam Gibson via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Ryan and list,
> I want to add some commentary to this (BIP79) to see if we can get
> further in standardizing this idea.
>
> When I first mulled it over I thought it too impractical, but its virtue
> of steganographic hiding means only minimal uptake is still enormously
> interesting and worth pursuing; that's my current feeling. I've offered
> more detailed thoughts in my blog post[1] (def not required reading here).
>
> Both Joinmarket and Samourai have started implementing this kind of
> transaction. And while that's interesting experimentally, some kind of
> cross-wallet standard would be helpful, albeit there some differences
> between that and the merchant/centralized service use-case.
>
> We might imagine as a concrete goal for this BIP to create something
> that would be acceptable for inclusion into a project like BTCPayServer,
> so that it could be used in a realistic use case by smaller bitcoin
> accepting merchants.
>
> Comments to the BIP[2] as follows, with generic comments first, and then
> specific comments for existing points in the BIP:
>
> [1] https://joinmarket.me/blog/blog/payjoin
> [2] https://github.com/bitcoin/bips/blob/master/bip-0079.mediawiki
>
> Generic comments
>
> ==================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================
>
> -   Protocol versioning. Since inevitably (even if only merchants), this
>     must be implemented by multiple wallets to be useful, the communication
>     protocol will need versioning (for example i have in my
>     simple/experimental Joinmarket PayJoin that sender sends min and max
>     supported version and receiver responds with a chosen protocol version
>     so we can update). I do understand that as a client-server model can
>     apply here, we can ditch a lot of the complexities around network/p2p
>     interaction, but this much at least seems necessary.
>
> -   Although it has its logic, I don't think "Bustapay" is a good name for
>     this protocol. I prefer "PayJoin" which is neutral sounding and
>     self-descriptive. Needless to say this is not a hill I intend to die on.
>
> -   PSBT/BIP174. I realise this has already been discussed, but this is a
>     good example of what this standardisation was designed for, so I'd be
>     against not including it, even given the reality that, as you correctly
>     observe, it is not yet implemented in the majority of wallets and
>     libraries. One way round that is to make it optional (possibly combined
>     with above point about versioning). Note that for example you were
>     observing the necessity to check the sequence number was unchanged; that
>     would be encapsulated by checking equality of PSBT Input objects/fields.
>     While one can make such software architecture arguments, the really
>     fundamental point is the need for standards for x-wallet compatibility.
>
> -   Version, Locktime: Perhaps this is not needed; in a peer to peer
>     wallet scenario I think there might be logic in trying to get cover
>     traffic of (Core, Electrum, others), say, by using
>     last-block-locktime-mostly, as they do. Version should be 2 and sequence
>     is a function of your suggestion to use BIP125. Worth noting that BIP125
>     is not currently widely used on the network, though (see
>     https://p2sh.info/dashboard/db/replace-by-fee?orgId=1). For this reason
>     it should perhaps be explicitly only optional.
>
> -   Avoidance of non-payment "Unnecessary Input Heuristic" (1, 2). For
>     reference, see the definition here
>     https://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e#gistcomment-2796539
>     and some data here
>     https://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e#gistcomment-2800791
>     (whole comment thread may be of interest) - note this UIH name is afaik
>     Chris Belcher's invention, it seems useful as a categorisation.
>     So, it seems that UIH2 is more important to avoid; while some more
>     sophisticated wallet coin selection algorithms may occasionally pick
>     an input set where one input is larger than any output, most won't, and
>     some in particular never will. So I think the text here should indicate
>     that *the receiver's contributed input(s) SHOULD be chosen to avoid
>     triggering the UIH2 heuristic where possible, so that the final payjoin
>     transaction is maximally plausible as an ordinary payment" or similar.
>     UIH1 is a nice-to-have (meaning the plausibility extends to two
>     different (both wrong) payment amounts, but it may not be necessary to
>     mention it in the BIP.
>
>     Specific comments
>     =================
>
>
> > > ====Step 4. Receiver validates, re-signs, and propagates on the
>
> bitcoin network====
>
> I believe this should say "Sender" not Receiver. Also for the next
> sentence, s/receiver/sender/:
>
> > > The receiver MUST validate the ''partial transaction'' was changed
>
> correctly and non-maliciously (to allow using potentially untrusted
> communication channels), re-sign its original inputs and propagate the
> final transaction over the bitcoin network.
>
> Your very correct highlighting of the attack vector of "receiver gives
> sender other inputs belonging to sender to unwittingly sign (described
> below), should be highlighted here, perhaps with the phrase "re-sign its
> ORIGINAL inputs" (only!)".
>
> > > When the sender is creating a "template transaction" it is done
>
> almost identically to creating a normal send, with the exception that
> only segwit inputs may be used. The sender is also encouraged to use a
> slightly more aggressive feerate than usual as well as BIP125 (Opt-in
> Full Replace-by-Fee Signaling), but neither is strictly required.
>
> "slightly more aggressive feerate than usual" - this I understand is to
> make up for receiver contributed utxo, OK.
>
> "only segwit inputs" - it certainly makes things simpler. One can work
> with non-segwit inputs but especially considering (as mentioned below)
> we really ought to "MUST" the part about matching input types, I tend to
> agree that non-segwit should be disallowed.
>
> > > The receiver must add at least one input to the transaction (the
>
> "contributed inputs"). If the receiver has no inputs, it should use a
> 500 internal server error, so the client can send the transaction as per
> normal (or try again later).
>
> Would it not be much simpler for the server to return a different
> (non-error) response indicating that it will broadcast the template tx
> in this case?
>
> > > Its generally advised to only add a single contributed input, however
>
> they are circumstances where adding more than a single input can be useful.
>
> I don't see a good reason to advise the use of only 1 input? (but this
> will also connect with the above generic comment about "UIH"). I guess
> it's because of your approach to fees. I'd prefer not to create a
> limitation here.
>
> > > To prevent an attack where a receiver is continually sent variations
>
> of the same transaction to enumerate the receivers utxo set, it is
> essential that the receiver always returns the same contributed inputs
> when it's seen the same inputs.
>
> This is an approach to avoiding this problem which has the virtue of
> simplicity, but it seems a little problematic. (1) You must keep a
> mapping of proposed payment utxos to one's proposed contributed input
> utxos, but (2) how should this be updated if you need to spend the
> contribution mentioned in (1)? Ironically use of payjoin exacerbates
> this issue, because it results in a smaller number of utxos being held
> by the receiver at any one time :) All this considered, I still see the
> value in your approach, but it might end up with a re-attempted payment
> being rejected. Certainly the more complex suggested solutions coming
> out of the summer 2018 coinjoin workshop aren't as practical as this,
> and may be overkill for small merchants/receivers.
>
> > > It is strongly preferable that the receiver makes an effort to pick a
>
> contributed input of the same type as the other transaction inputs if
> possible.
>
> I have also thought about this and you could reasonably argue this
> should be a MUST section in the BIP, that is, if the receiver cannot use
> inputs of the same type, he should fall back to the template
> transaction. A mixed-input payjoin/coinjoin is essentially
> near-perfectly identifiable as such (there is almost zero other usage of
> multi-type-input transactions), which is a very different thing than a
> non-identifiable payjoin transaction. That may or may not be OK to the
> sender. This is debatable though, for sure.
>
> > > After adding inputs to the transaction, the receiver generally will
>
> want to adjust the output that pays himself by increasing it by the sum
> of the contributed input amounts (minus any fees he wants to
> contribute). However the only strict requirement is that the receiver
> must never add or remove inputs, and must not ever decrease any
> output amount.
>
> "must never add or remove inputs" - did you mean "must never remove
> inputs"? he surely has to add one! Or, perhaps you mean he must not
> alter the list of inputs provided by the sender (in which case it should
> be clarified).
>
> "must not decrease any output amount" - I initally disagreed with this
> but it is a better option than the one I currently chose in Joinmarket
> payjoin (sender pays all fee as long as receiver utxos are not too
> much). So this means that the receiver either consciously chooses to not
> increase the fee, meaning the fee rate may be a bit low (hence your
> earlier comment about being generous, got it), or contributes via the
> payout amount. I guess the latter might break merchant software
> expecting to have amount output fixed and fees determined by change.
>
> Regards,
> Adam Gibson/waxwing
>
> On 30. 08. 18 22:24, Ryan Havar via bitcoin-dev wrote:
>
> > I've just finished writing an implementing of this, and extremely happy
> > with how it turned out. So I'd like to go and try go down the path of
> > more formally describing it and getting some comments and ultimately
> > encourage its wide-spread use.
> > ==Abstract==
> > The way bitcoin transactions are overwhelming used is known to leak more
> > information than desirable. This has lead to fungibility concerns in bitcoin
> > and a raise of unreasonably effective blockchain analysis.
> > Bustapay proposes a simple, practical way to bust these assumptions to
> > immediate
> > benefit of the sender and recievers. Furthermore it does so in such a
> > way that
> > helps recievers avoid utxo bloat, a constant problem for bitcoin merchants.
> > ==Copyright==
> > This BIP is in the public domain.
> > ==Motivation==
> > One of the most powerful heuristic's employed by those whose goal is to
> > undermine
> > bitcoin's fungiblity has been to assume all inputs of a transaction are
> > signed by
> > a single party. In the few cases this assumption does not hold, it is
> > generally
> > readibly recognizable (e.g. traditional coinjoins have a very obvious
> > structure,
> > or multisig outputs are most frequently validated onchain).
> > Bustapay requires no changes to bitcoin and creates bitcoin transactions
> > that are
> > indistinguishable from normal ones.
> > It is worth noting that this specification has been intentionally kept
> > as simple
> > as possible to encourage adoption. There are almost an endless amount of
> > extensions
> > possible but the harder the implementation of clients/server the less
> > likely it
> > will ever be done. Should bustapay enjoy widespread adoption, a "v2"
> > specification
> > will be created with desired extensions.
> > ==Specification==
> > A bustapay payment is made from a sender to a receiver.
> > Step 1. Sender creates a bitcoin transaction paying the receiver
> > This transaction must be fully valid, signed and all inputs must use
> > segwit. This transaction is known as the "template transaction". This
> > transaction must not be propagated on the bitcoin network.
> > Step 2. Sender gives the "template transaction" to the receiver
> > This would generally be done as an HTTP POST. The exact URL to submit it
> > to could be specified with a bip21 encoded address. Such as
> > bitcoin:2NABbUr9yeRCp1oUCtVmgJF8HGRCo3ifpTT?bustapay=https://bp.bustabit.com/submit
> > and the HTTP body should be the raw transaction hex encoded as text.
> > Step 3. Receiver processes the transaction and returns a partially
> > signed coinjoin
> > The receiver validates the transaction is valid, pays himself and is
> > eligible for propation. The receiver then adds one of his own inputs
> > (known as the "contributed input") and increase the output that pays
> > himself by the contributed input amount. Doing so will invalidate the
> > "template transaction"'s original input signatures, so the sender needs
> > to return this "partial transaction" back to the receiver to sign. This
> > is returned as a hex-encoded raw transaction a response to the original
> > HTTP POST request.
> > Step 4. Receiver validates, re-signs, and propagates on the bitcoin network
> > The receiver is responsible in making sure the "partial transaction"
> > returned by the sender was changed correctly (it should assume the
> > connection has been MITM'd and act accordingly), resign its original
> > inputs and propagates this transaction over the bitcoin network. The
> > client must be aware that the server can reorder inputs and outputs.
> > Step 5. Receiver observes the finalized transaction on the bitcoin network
> > Once the receiver has seen the finalized transactions on the network
> > (and has enough confirmations) it can process it like a normal payment
> > for the sent amount (as opposed to the amount that it looks like on the
> > network). If the receiver does not see the finalized transaction after a
> > timeout will propagate the original "template transaction" to ensure the
> > payment happens and function a strong anti-DoS mechanism.
> > === Implementation Notes ===
> > For anyone wanting to implement bustapay payments, here are some notes
> > for receivers:
> >
> > -   A transaction can easily be checked if it's suitable for the mempool
> >     with testmempoolaccept in bitcoin core 0.17
> >
> > -   Tracking transactions by txid is precarious. To keep your sanity make
> >     sure all inputs are segwit. But remember segwit does not prevent txid
> >     malleability unless you validate the transaction. So really make sure
> >     you're using testmempoolaccept at the very least
> >
> > -   Bustapay could be abused by a malicious party to query if you own a
> >     deposit address or not. So never accept a bustapay transaction that pays
> >     an already used deposit address
> >
> > -   You will need to keep a mapping of which utxos people have showed you
> >     and which you revealed. So if you see them again, you can reveal the
> >     same one of your own
> >
> > -   Check if the transaction was already sorted according to BIP69, if so
> >     ensure the result stays that way. Otherwise probably just shuffle the
> >     inputs/outpus
> >
> >
> > Notes for sending applications:
> >
> > -   The HTTP response must not be trusted. It should be fully validated
> >     that no unexpected changes have been made to the transaction.
> >
> > -   The sender should be aware the original "template transaction" may be
> >     propagated at any time, and in fact can intentionally be
> >     ? done so for the purpose of RBF as it should have a slightly higher fee
> >     rate.
> >
> >
> > == Credits ==
> > The idea is obviously based upon Dr. Maxwell's seminal CoinJoin
> > proposal, and reduced scope inspired by a simplification of the "pay 2
> > endpoint" (now offline) blog post by blockstream.
> > -Ryan
> >
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From ekaggata at gmail.com  Sun Jan 27 12:20:54 2019
From: ekaggata at gmail.com (Adam Gibson)
Date: Sun, 27 Jan 2019 13:20:54 +0100
Subject: [bitcoin-dev] bustapay BIP :: a practical sender/receiver
 coinjoin protocol
In-Reply-To: <-yZhdFkKfKAEz1_4GKKSpTxjvR8EDSsH_5-TTh_4X5qwa79igXKR14rh6JASrald-F97o1htWY_kcBQ7IVr7ZH9zOQlOEwzhkWDjTq0d7F4=@protonmail.com>
References: <TtjH2zicjKr8PBVCMOvA7ryt2z_XXvtrpC4y1wuWSxexNwMdbPGE7vPmu6UnzmfYqYBMxZ8NNoz4VUnODdIcjR4j-E1sYz_FA6ZZMjKHtuM=@protonmail.com>
	<e15c5dd7-6fe1-b253-e129-aeae6493acd1@gmail.com>
	<-yZhdFkKfKAEz1_4GKKSpTxjvR8EDSsH_5-TTh_4X5qwa79igXKR14rh6JASrald-F97o1htWY_kcBQ7IVr7ZH9zOQlOEwzhkWDjTq0d7F4=@protonmail.com>
Message-ID: <2cd4fe6d-c0ca-5ae7-4107-38e1609743a8@gmail.com>



On 27. 01. 19 8:36, rhavar at protonmail.com wrote:
> Thanks Adam,
> 
> I have fixed the mistakes you have pointed out: https://github.com/bitcoin/bips/pull/754
> 
> Thanks for the detailed look!
> 
>> but its virtue of steganographic hiding means only minimal uptake
>> is still enormously interesting and worth pursuing; that's my current feeling.
> 
> I very much agree =) I really think anything that (silently) breaks the assumption of common ownership of transaction inputs offers outsized benefits for the whole ecosystem.
> 
> One other idea I have  is (way) better support for moving utxo's between wallets. The least controversial use case is moving funds between wallets you own. Like I might want to move *specific* utxo's from/to my joinmarket wallet, but not create a (privacy losing / expensive) transaction. Both core and joinmarket fail at this at a practical point of view.

(tangential, but yes coin control in JM is an obviously necessary
feature and will be done, I just don't have time).

> 
> Like imho it'd be pretty cool having a standardized format for (txid:vout:privatekey) with wallets showing it as "External UTXO" and preferentially spending it (and wallet not automatically importing any other utxo from that address).
> 
> Taken a bit further (this is the part which everyone hates) you could send someone money (or withdraw it from a service) by giving a person. It's not generally useful (for obvious reasons), but there's a lot of cases I think it's super cool.

Is there a missing word. "by giving a person.."? Not actually sure what
you're getting at here but I suspect it's again tangential to this BIP
discussion.

> 
> ---
> 
> Getting back on topic, without trying to do a point-by-point reply, I agree with pretty much everything you said but I am reluctant to make any changes.
> 
> I don't meant to be obtuse or anything, but I strongly believe the limiting factor to adoption to all these protocols is actually just getting people to implement it. I made multiple implementations of bustapay from both the sending/receiving end, so I could try develop the easiest to implement system that is still practical.

You know, there's considerable evidence to the contrary, I'd argue: this
idea *has* been implemented already three times: by yourself, by myself
and by Samourai. And in fully incompatible ways :) So I think the
limiting factor is in fact creating a standard that a reasonable number
of people could agree with (and I like operational definitions, so
subjective as it is, I like the goal of "good/clear enough that it could
be incorporated into something like BtcPayServer")

> 
> For instance I like PSBT and it's nice in theory. I actually had an original implementation using it, which is how I found some bugs in the core and golang version of PSBT). But in practice it's hugely overkill and significantly increases the implementation complexity complexity and is poorly supported. Switching to just a raw transaction actually made everything easier. (And that's not to criticise PSBT, I would definitely want to use it in other contexts).

But this relates back to my first "generic" point that you haven't
addressed here - protocol versioning and the possibility of more than
one option. Perhaps more realistic (debatable): have the current version
be non-PSBT but with a plan to have a version bump with PSBT in future.
Stuff like that. It seems crazy to actually long term reject it.

> 
> Anyway, a big motivation for me even writing it as a BIP was to formalize my little anti-DOS trick of privately creating a "template transaction" which can just be dumped on the network as punishment. So if nothing else, hopefully I'll have demonstrated it's a pretty practical way of doing things.
> 

I don't want to be that guy, but this was a central part of the proposal
that came of the meetup last summer and is in Haywood's blogpost. I mean
if you came up it with separately, then cool :) But I was there, that
was established immediately as the right way of doing this to avoid a
trivial attack.
What might have confused you is all that stuff about multiple candidates
and even ZKP approaches - those were just extra ideas about making it
really secure at large scale; but those ideas don't quite meet the goal
(for various reasons); well, arguably. The basic anti-DOS of an initial
non-coinjoin was sorta central.
(Also I'm noting you didn't respond to my critique of your "always use
the same contributions" defence; I mean, probably that's fine, it was
only really saying it isn't perfect. Was just curious to hear
your/others thoughts on it).

> --
> 
> Also your analysis on "Unnecessary Input Heuristic" is pretty cool, but I also don't like telling people to "avoid the UIH2" without providing the actual algo they should use. But really I think it's better off in a sort of article "how to pick contributed inputs" or something, as while it's nice it's not a huge deal and there's a lot of debatable tradeoffs that can/should be used. For instance the implementation I wrote for bustabit.com currently just heavily biases tainted inputs (e.g. ones associated with address reuse).
> 

Good point about algo.
I wrote my best effort at a procedure here:
https://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e#gistcomment-2799709

I asked for comments on it but got none back so far (gists are terrible
for this unfortunately, perhaps I'll have more luck on the list).

I would argue that this issue *should* be mentioned on the BIP. A *huge*
part of what makes PayJoin/BustaPay of interest is the steganographic
feature, if you don't pay attention to this then it doesn't look like a
payment (caveat.-->).
The counterargument is Laurent's statistics which I previously linked,
suggesting that maybe 30% of txs violate this anyway, today. I'm not
sure about that, will need more analysis; Core's SRD algo may be one
reason, but anyway ... better to make things look like payments.

It doesn't hurt to prompt an implementer to do this; whether it's
feasible in that specific wallet situation or not is up to them; whether
they want to go hog wild and control percentages of UIH1 and UIH2 and
whatnot is there business, or they can totally ignore it - but without
it being mentioned in the BIP, they may not even think of it.

A last point, you also don't see value in being more explicit about
simple things like transaction version and locktime? Even if you think
these things should *not* be controlled, e.g. the protocol should allow
either transaction version, then it'd be better to explicitly say so.
> 
> 
> -Ryan
> 
> ??????? Original Message ???????
> On Friday, January 25, 2019 6:47 AM, Adam Gibson via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
>> Ryan and list,
>> I want to add some commentary to this (BIP79) to see if we can get
>> further in standardizing this idea.
>>
>> When I first mulled it over I thought it too impractical, but its virtue
>> of steganographic hiding means only minimal uptake is still enormously
>> interesting and worth pursuing; that's my current feeling. I've offered
>> more detailed thoughts in my blog post[1] (def not required reading here).
>>
>> Both Joinmarket and Samourai have started implementing this kind of
>> transaction. And while that's interesting experimentally, some kind of
>> cross-wallet standard would be helpful, albeit there some differences
>> between that and the merchant/centralized service use-case.
>>
>> We might imagine as a concrete goal for this BIP to create something
>> that would be acceptable for inclusion into a project like BTCPayServer,
>> so that it could be used in a realistic use case by smaller bitcoin
>> accepting merchants.
>>
>> Comments to the BIP[2] as follows, with generic comments first, and then
>> specific comments for existing points in the BIP:
>>
>> [1] https://joinmarket.me/blog/blog/payjoin
>> [2] https://github.com/bitcoin/bips/blob/master/bip-0079.mediawiki
>>
>> Generic comments
>>
>> ==================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================
>>
>> -   Protocol versioning. Since inevitably (even if only merchants), this
>>     must be implemented by multiple wallets to be useful, the communication
>>     protocol will need versioning (for example i have in my
>>     simple/experimental Joinmarket PayJoin that sender sends min and max
>>     supported version and receiver responds with a chosen protocol version
>>     so we can update). I do understand that as a client-server model can
>>     apply here, we can ditch a lot of the complexities around network/p2p
>>     interaction, but this much at least seems necessary.
>>
>> -   Although it has its logic, I don't think "Bustapay" is a good name for
>>     this protocol. I prefer "PayJoin" which is neutral sounding and
>>     self-descriptive. Needless to say this is not a hill I intend to die on.
>>
>> -   PSBT/BIP174. I realise this has already been discussed, but this is a
>>     good example of what this standardisation was designed for, so I'd be
>>     against not including it, even given the reality that, as you correctly
>>     observe, it is not yet implemented in the majority of wallets and
>>     libraries. One way round that is to make it optional (possibly combined
>>     with above point about versioning). Note that for example you were
>>     observing the necessity to check the sequence number was unchanged; that
>>     would be encapsulated by checking equality of PSBT Input objects/fields.
>>     While one can make such software architecture arguments, the really
>>     fundamental point is the need for standards for x-wallet compatibility.
>>
>> -   Version, Locktime: Perhaps this is not needed; in a peer to peer
>>     wallet scenario I think there might be logic in trying to get cover
>>     traffic of (Core, Electrum, others), say, by using
>>     last-block-locktime-mostly, as they do. Version should be 2 and sequence
>>     is a function of your suggestion to use BIP125. Worth noting that BIP125
>>     is not currently widely used on the network, though (see
>>     https://p2sh.info/dashboard/db/replace-by-fee?orgId=1). For this reason
>>     it should perhaps be explicitly only optional.
>>
>> -   Avoidance of non-payment "Unnecessary Input Heuristic" (1, 2). For
>>     reference, see the definition here
>>     https://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e#gistcomment-2796539
>>     and some data here
>>     https://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e#gistcomment-2800791
>>     (whole comment thread may be of interest) - note this UIH name is afaik
>>     Chris Belcher's invention, it seems useful as a categorisation.
>>     So, it seems that UIH2 is more important to avoid; while some more
>>     sophisticated wallet coin selection algorithms may occasionally pick
>>     an input set where one input is larger than any output, most won't, and
>>     some in particular never will. So I think the text here should indicate
>>     that *the receiver's contributed input(s) SHOULD be chosen to avoid
>>     triggering the UIH2 heuristic where possible, so that the final payjoin
>>     transaction is maximally plausible as an ordinary payment" or similar.
>>     UIH1 is a nice-to-have (meaning the plausibility extends to two
>>     different (both wrong) payment amounts, but it may not be necessary to
>>     mention it in the BIP.
>>
>>     Specific comments
>>     =================
>>
>>
>>>> ====Step 4. Receiver validates, re-signs, and propagates on the
>>
>> bitcoin network====
>>
>> I believe this should say "Sender" not Receiver. Also for the next
>> sentence, s/receiver/sender/:
>>
>>>> The receiver MUST validate the ''partial transaction'' was changed
>>
>> correctly and non-maliciously (to allow using potentially untrusted
>> communication channels), re-sign its original inputs and propagate the
>> final transaction over the bitcoin network.
>>
>> Your very correct highlighting of the attack vector of "receiver gives
>> sender other inputs belonging to sender to unwittingly sign (described
>> below), should be highlighted here, perhaps with the phrase "re-sign its
>> ORIGINAL inputs" (only!)".
>>
>>>> When the sender is creating a "template transaction" it is done
>>
>> almost identically to creating a normal send, with the exception that
>> only segwit inputs may be used. The sender is also encouraged to use a
>> slightly more aggressive feerate than usual as well as BIP125 (Opt-in
>> Full Replace-by-Fee Signaling), but neither is strictly required.
>>
>> "slightly more aggressive feerate than usual" - this I understand is to
>> make up for receiver contributed utxo, OK.
>>
>> "only segwit inputs" - it certainly makes things simpler. One can work
>> with non-segwit inputs but especially considering (as mentioned below)
>> we really ought to "MUST" the part about matching input types, I tend to
>> agree that non-segwit should be disallowed.
>>
>>>> The receiver must add at least one input to the transaction (the
>>
>> "contributed inputs"). If the receiver has no inputs, it should use a
>> 500 internal server error, so the client can send the transaction as per
>> normal (or try again later).
>>
>> Would it not be much simpler for the server to return a different
>> (non-error) response indicating that it will broadcast the template tx
>> in this case?
>>
>>>> Its generally advised to only add a single contributed input, however
>>
>> they are circumstances where adding more than a single input can be useful.
>>
>> I don't see a good reason to advise the use of only 1 input? (but this
>> will also connect with the above generic comment about "UIH"). I guess
>> it's because of your approach to fees. I'd prefer not to create a
>> limitation here.
>>
>>>> To prevent an attack where a receiver is continually sent variations
>>
>> of the same transaction to enumerate the receivers utxo set, it is
>> essential that the receiver always returns the same contributed inputs
>> when it's seen the same inputs.
>>
>> This is an approach to avoiding this problem which has the virtue of
>> simplicity, but it seems a little problematic. (1) You must keep a
>> mapping of proposed payment utxos to one's proposed contributed input
>> utxos, but (2) how should this be updated if you need to spend the
>> contribution mentioned in (1)? Ironically use of payjoin exacerbates
>> this issue, because it results in a smaller number of utxos being held
>> by the receiver at any one time :) All this considered, I still see the
>> value in your approach, but it might end up with a re-attempted payment
>> being rejected. Certainly the more complex suggested solutions coming
>> out of the summer 2018 coinjoin workshop aren't as practical as this,
>> and may be overkill for small merchants/receivers.
>>
>>>> It is strongly preferable that the receiver makes an effort to pick a
>>
>> contributed input of the same type as the other transaction inputs if
>> possible.
>>
>> I have also thought about this and you could reasonably argue this
>> should be a MUST section in the BIP, that is, if the receiver cannot use
>> inputs of the same type, he should fall back to the template
>> transaction. A mixed-input payjoin/coinjoin is essentially
>> near-perfectly identifiable as such (there is almost zero other usage of
>> multi-type-input transactions), which is a very different thing than a
>> non-identifiable payjoin transaction. That may or may not be OK to the
>> sender. This is debatable though, for sure.
>>
>>>> After adding inputs to the transaction, the receiver generally will
>>
>> want to adjust the output that pays himself by increasing it by the sum
>> of the contributed input amounts (minus any fees he wants to
>> contribute). However the only strict requirement is that the receiver
>> must never add or remove inputs, and must not ever decrease any
>> output amount.
>>
>> "must never add or remove inputs" - did you mean "must never remove
>> inputs"? he surely has to add one! Or, perhaps you mean he must not
>> alter the list of inputs provided by the sender (in which case it should
>> be clarified).
>>
>> "must not decrease any output amount" - I initally disagreed with this
>> but it is a better option than the one I currently chose in Joinmarket
>> payjoin (sender pays all fee as long as receiver utxos are not too
>> much). So this means that the receiver either consciously chooses to not
>> increase the fee, meaning the fee rate may be a bit low (hence your
>> earlier comment about being generous, got it), or contributes via the
>> payout amount. I guess the latter might break merchant software
>> expecting to have amount output fixed and fees determined by change.
>>
>> Regards,
>> Adam Gibson/waxwing
>>
>> On 30. 08. 18 22:24, Ryan Havar via bitcoin-dev wrote:
>>
>>> I've just finished writing an implementing of this, and extremely happy
>>> with how it turned out. So I'd like to go and try go down the path of
>>> more formally describing it and getting some comments and ultimately
>>> encourage its wide-spread use.
>>> ==Abstract==
>>> The way bitcoin transactions are overwhelming used is known to leak more
>>> information than desirable. This has lead to fungibility concerns in bitcoin
>>> and a raise of unreasonably effective blockchain analysis.
>>> Bustapay proposes a simple, practical way to bust these assumptions to
>>> immediate
>>> benefit of the sender and recievers. Furthermore it does so in such a
>>> way that
>>> helps recievers avoid utxo bloat, a constant problem for bitcoin merchants.
>>> ==Copyright==
>>> This BIP is in the public domain.
>>> ==Motivation==
>>> One of the most powerful heuristic's employed by those whose goal is to
>>> undermine
>>> bitcoin's fungiblity has been to assume all inputs of a transaction are
>>> signed by
>>> a single party. In the few cases this assumption does not hold, it is
>>> generally
>>> readibly recognizable (e.g. traditional coinjoins have a very obvious
>>> structure,
>>> or multisig outputs are most frequently validated onchain).
>>> Bustapay requires no changes to bitcoin and creates bitcoin transactions
>>> that are
>>> indistinguishable from normal ones.
>>> It is worth noting that this specification has been intentionally kept
>>> as simple
>>> as possible to encourage adoption. There are almost an endless amount of
>>> extensions
>>> possible but the harder the implementation of clients/server the less
>>> likely it
>>> will ever be done. Should bustapay enjoy widespread adoption, a "v2"
>>> specification
>>> will be created with desired extensions.
>>> ==Specification==
>>> A bustapay payment is made from a sender to a receiver.
>>> Step 1. Sender creates a bitcoin transaction paying the receiver
>>> This transaction must be fully valid, signed and all inputs must use
>>> segwit. This transaction is known as the "template transaction". This
>>> transaction must not be propagated on the bitcoin network.
>>> Step 2. Sender gives the "template transaction" to the receiver
>>> This would generally be done as an HTTP POST. The exact URL to submit it
>>> to could be specified with a bip21 encoded address. Such as
>>> bitcoin:2NABbUr9yeRCp1oUCtVmgJF8HGRCo3ifpTT?bustapay=https://bp.bustabit.com/submit
>>> and the HTTP body should be the raw transaction hex encoded as text.
>>> Step 3. Receiver processes the transaction and returns a partially
>>> signed coinjoin
>>> The receiver validates the transaction is valid, pays himself and is
>>> eligible for propation. The receiver then adds one of his own inputs
>>> (known as the "contributed input") and increase the output that pays
>>> himself by the contributed input amount. Doing so will invalidate the
>>> "template transaction"'s original input signatures, so the sender needs
>>> to return this "partial transaction" back to the receiver to sign. This
>>> is returned as a hex-encoded raw transaction a response to the original
>>> HTTP POST request.
>>> Step 4. Receiver validates, re-signs, and propagates on the bitcoin network
>>> The receiver is responsible in making sure the "partial transaction"
>>> returned by the sender was changed correctly (it should assume the
>>> connection has been MITM'd and act accordingly), resign its original
>>> inputs and propagates this transaction over the bitcoin network. The
>>> client must be aware that the server can reorder inputs and outputs.
>>> Step 5. Receiver observes the finalized transaction on the bitcoin network
>>> Once the receiver has seen the finalized transactions on the network
>>> (and has enough confirmations) it can process it like a normal payment
>>> for the sent amount (as opposed to the amount that it looks like on the
>>> network). If the receiver does not see the finalized transaction after a
>>> timeout will propagate the original "template transaction" to ensure the
>>> payment happens and function a strong anti-DoS mechanism.
>>> === Implementation Notes ===
>>> For anyone wanting to implement bustapay payments, here are some notes
>>> for receivers:
>>>
>>> -   A transaction can easily be checked if it's suitable for the mempool
>>>     with testmempoolaccept in bitcoin core 0.17
>>>
>>> -   Tracking transactions by txid is precarious. To keep your sanity make
>>>     sure all inputs are segwit. But remember segwit does not prevent txid
>>>     malleability unless you validate the transaction. So really make sure
>>>     you're using testmempoolaccept at the very least
>>>
>>> -   Bustapay could be abused by a malicious party to query if you own a
>>>     deposit address or not. So never accept a bustapay transaction that pays
>>>     an already used deposit address
>>>
>>> -   You will need to keep a mapping of which utxos people have showed you
>>>     and which you revealed. So if you see them again, you can reveal the
>>>     same one of your own
>>>
>>> -   Check if the transaction was already sorted according to BIP69, if so
>>>     ensure the result stays that way. Otherwise probably just shuffle the
>>>     inputs/outpus
>>>
>>>
>>> Notes for sending applications:
>>>
>>> -   The HTTP response must not be trusted. It should be fully validated
>>>     that no unexpected changes have been made to the transaction.
>>>
>>> -   The sender should be aware the original "template transaction" may be
>>>     propagated at any time, and in fact can intentionally be
>>>     ? done so for the purpose of RBF as it should have a slightly higher fee
>>>     rate.
>>>
>>>
>>> == Credits ==
>>> The idea is obviously based upon Dr. Maxwell's seminal CoinJoin
>>> proposal, and reduced scope inspired by a simplification of the "pay 2
>>> endpoint" (now offline) blog post by blockstream.
>>> -Ryan
>>>
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> 

From rhavar at protonmail.com  Sun Jan 27 19:24:11 2019
From: rhavar at protonmail.com (rhavar at protonmail.com)
Date: Sun, 27 Jan 2019 19:24:11 +0000
Subject: [bitcoin-dev] bustapay BIP :: a practical sender/receiver
	coinjoin protocol
In-Reply-To: <2cd4fe6d-c0ca-5ae7-4107-38e1609743a8@gmail.com>
References: <TtjH2zicjKr8PBVCMOvA7ryt2z_XXvtrpC4y1wuWSxexNwMdbPGE7vPmu6UnzmfYqYBMxZ8NNoz4VUnODdIcjR4j-E1sYz_FA6ZZMjKHtuM=@protonmail.com>
	<e15c5dd7-6fe1-b253-e129-aeae6493acd1@gmail.com>
	<-yZhdFkKfKAEz1_4GKKSpTxjvR8EDSsH_5-TTh_4X5qwa79igXKR14rh6JASrald-F97o1htWY_kcBQ7IVr7ZH9zOQlOEwzhkWDjTq0d7F4=@protonmail.com>
	<2cd4fe6d-c0ca-5ae7-4107-38e1609743a8@gmail.com>
Message-ID: <vJMuB76ZLt0LrRQZKavdrbfJZOdlTF_cmt81c2Eu2jwvzZ3c2SYaBu5aI6lAP-gEDO1QQdUB-WMJE-XkEGEOpNdSWGFBA8ptWDFVihGHTc4=@protonmail.com>

> Is there a missing word. "by giving a person.."? Not actually sure what
> you're getting at here but I suspect it's again tangential to this BIP
> discussion.

Correct on both points. I meant to say "giving a (txid:vout:privkey)" to a person as means of payment.


> So I think the limiting factor is in fact creating a standard that a reasonable number
> of people could agree with (and I like operational definitions, so
> subjective as it is, I like the goal of "good/clear enough that it could
> be incorporated into something like BtcPayServer")


The problem with BtcPayServer (and a lot of similar software), is that it's not very unsuitable for any sender/receiver coinjoin due to it not having its own wallet. As I understand the basic architecture is just a fancy wrapper around bip32 address generation and monitoring the payment to those addresses. This means that adding support is not only a large code change, but it also entails a substantial change for merchants (you can't just have your payments flow into your trezor, but need to run a hot wallet)

But I strongly believe that bustapay is good enough _right now_ for BtcPayServer integration (which I'd happily contribute myself, if it wasn't for my unfamiliarity of the project and c#)


> But this relates back to my first "generic" point that you haven't
> addressed here - protocol versioning and the possibility of more than
> one option. Perhaps more realistic (debatable): have the current version
> be non-PSBT but with a plan to have a version bump with PSBT in future.
> Stuff like that. It seems crazy to actually long term reject it.

Adding backwards-compatible versioning at a later stage would be pretty trivial through either the URL or HTTP header (e.g  version=2)  and if breaking backwards compatible is desirable it can also easily been done (e.g. bump the bip21 or send an incompatible request/response). I don't see this as a problem at all, and I'm not rejecting it long-term, I just don't think it's particularly helpful to bikeshed now, when adoption is pretty much zero.



> I don't want to be that guy, but this was a central part of the proposal
> that came of the meetup last summer and is in Haywood's blogpost. I mean
> if you came up it with separately, then cool :) But I was there, that
> was established immediately as the right way of doing this to avoid a
> trivial attack.

Oh wow. had no idea. I saw the part about the receiver spamming the sender with a bunch of transactions, where only 1 of them are real and thought "ewww" and "came up" with the idea of a "template transaction" instead. I was always wondering why no one came up it, but now it makes sense. The transaction-spam stage was just an _additional_ layer of protection.

Ok, now I feel like an idiot =)  Thanks for letting me know.


> The counterargument is Laurent's statistics which I previously linked,
> suggesting that maybe 30% of txs violate this anyway, today. I'm not
> sure about that, will need more analysis; Core's SRD algo may be one
> reason, but anyway ... better to make things look like payments.

I think it's interesting, but I don't think it particularly matters. Avoiding UIH1 I think is pretty much irrelevant, as it'll likely just confuse any analysis into thinking the payment is the reverse of what it actually is. And wallets already don't care about violating UIH2(as a way to do implicit consolidation). If 30% of tx's are violating it, you can be pretty sure it means the _vast majority_ of wallets run coin selection in such a way that can violation UIH2.  Most wallets use a coin selection algorithm that you can approximate with:

while !enoughMoney {
    inputs += getAnotherInput();
}

and don't run a final pass that would prune superfluous inputs.  Even coinsayer (shill alert) which I believe runs the most advanced coin selection algorithms, will routinely and intentionally violate UIH2 when it's ideal (e.g. most classic case: when `consolidationFeeRate >= minFeeRate`).

I'm not trying to dismiss your analysis, as I find it interesting. I'm just against increasing the cognitive burden on implementations by mentioning all this stuff, when the truth is it (barely) matters.  If wallets routinely avoided UIH2 and making a UIH2 payment would "out" the transaction as much more likely to be a bustapay, then I'd definitely reconsider and provide a basic suggestion into how to try avoid it.

And like I said, I also think there's much more important things that go into "picking a contributed input" than just this.



> A last point, you also don't see value in being more explicit about
> simple things like transaction version and locktime? Even if you think
> these things should not be controlled, e.g. the protocol should allow
> either transaction version, then it'd be better to explicitly say so.


My intention was that wallets create a transaction exactly like they normally would do, and use that as the template transaction. The only time I wanted to be prescriptive was when it would increase the implementation complexity (e.g. being non-segwit compatible is a pain in the ass. So I'd rather just be "pure segwit only" transactions). But something like locktime makes no difference as long as the transaction is mempool eligible, so I'd rather just wallets do what they do anyway.

Although I think there should be a separate discussion on improving the uniformity of bitcoin transactions in general. The current state of affairs is really atrocious.



---


P.S. I know I come across as obstinate, but it's not really so. If you can come up with an alternative to bustapay with some traction, I'd love to get behind it and deprecate bustapay in favor of it. I just am pretty happy with the state of bustapay and it's status a sort of "MVP of pay2endpoint", and unless the argument is in the form: "We'd love to support it, but in order to do so we'd need X" I'm probably going to disagree.

From keatonatron at gmail.com  Sun Jan 27 19:42:03 2019
From: keatonatron at gmail.com (James MacWhyte)
Date: Sun, 27 Jan 2019 11:42:03 -0800
Subject: [bitcoin-dev] bustapay BIP :: a practical sender/receiver
 coinjoin protocol
In-Reply-To: <2cd4fe6d-c0ca-5ae7-4107-38e1609743a8@gmail.com>
References: <TtjH2zicjKr8PBVCMOvA7ryt2z_XXvtrpC4y1wuWSxexNwMdbPGE7vPmu6UnzmfYqYBMxZ8NNoz4VUnODdIcjR4j-E1sYz_FA6ZZMjKHtuM=@protonmail.com>
	<e15c5dd7-6fe1-b253-e129-aeae6493acd1@gmail.com>
	<-yZhdFkKfKAEz1_4GKKSpTxjvR8EDSsH_5-TTh_4X5qwa79igXKR14rh6JASrald-F97o1htWY_kcBQ7IVr7ZH9zOQlOEwzhkWDjTq0d7F4=@protonmail.com>
	<2cd4fe6d-c0ca-5ae7-4107-38e1609743a8@gmail.com>
Message-ID: <CAH+Axy7SJhTskrTX_i+Nc+HMtcNXhOFuGi11X=EjFEfBW=H06A@mail.gmail.com>

Why does the template transaction need to be signed in step one and passed
back and forth so many times? What is wrong with:

1. Sender creates unsigned tx with their relevant inputs and outputs. This
tx is passed to receiver.

2. Receiver adds their relevant inputs and outputs and signs their portion
before returning the tx to sender.

3. Sender confirms their inputs and outputs have not been modified, and
signs the remainder of the tx before broadcasting it (or sending it to the
recipient if you want to follow the payment protocol spec).

James

On Sun, Jan 27, 2019, 08:45 Adam Gibson via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org wrote:

>
>
> On 27. 01. 19 8:36, rhavar at protonmail.com wrote:
> > Thanks Adam,
> >
> > I have fixed the mistakes you have pointed out:
> https://github.com/bitcoin/bips/pull/754
> >
> > Thanks for the detailed look!
> >
> >> but its virtue of steganographic hiding means only minimal uptake
> >> is still enormously interesting and worth pursuing; that's my current
> feeling.
> >
> > I very much agree =) I really think anything that (silently) breaks the
> assumption of common ownership of transaction inputs offers outsized
> benefits for the whole ecosystem.
> >
> > One other idea I have  is (way) better support for moving utxo's between
> wallets. The least controversial use case is moving funds between wallets
> you own. Like I might want to move *specific* utxo's from/to my joinmarket
> wallet, but not create a (privacy losing / expensive) transaction. Both
> core and joinmarket fail at this at a practical point of view.
>
> (tangential, but yes coin control in JM is an obviously necessary
> feature and will be done, I just don't have time).
>
> >
> > Like imho it'd be pretty cool having a standardized format for
> (txid:vout:privatekey) with wallets showing it as "External UTXO" and
> preferentially spending it (and wallet not automatically importing any
> other utxo from that address).
> >
> > Taken a bit further (this is the part which everyone hates) you could
> send someone money (or withdraw it from a service) by giving a person. It's
> not generally useful (for obvious reasons), but there's a lot of cases I
> think it's super cool.
>
> Is there a missing word. "by giving a person.."? Not actually sure what
> you're getting at here but I suspect it's again tangential to this BIP
> discussion.
>
> >
> > ---
> >
> > Getting back on topic, without trying to do a point-by-point reply, I
> agree with pretty much everything you said but I am reluctant to make any
> changes.
> >
> > I don't meant to be obtuse or anything, but I strongly believe the
> limiting factor to adoption to all these protocols is actually just getting
> people to implement it. I made multiple implementations of bustapay from
> both the sending/receiving end, so I could try develop the easiest to
> implement system that is still practical.
>
> You know, there's considerable evidence to the contrary, I'd argue: this
> idea *has* been implemented already three times: by yourself, by myself
> and by Samourai. And in fully incompatible ways :) So I think the
> limiting factor is in fact creating a standard that a reasonable number
> of people could agree with (and I like operational definitions, so
> subjective as it is, I like the goal of "good/clear enough that it could
> be incorporated into something like BtcPayServer")
>
> >
> > For instance I like PSBT and it's nice in theory. I actually had an
> original implementation using it, which is how I found some bugs in the
> core and golang version of PSBT). But in practice it's hugely overkill and
> significantly increases the implementation complexity complexity and is
> poorly supported. Switching to just a raw transaction actually made
> everything easier. (And that's not to criticise PSBT, I would definitely
> want to use it in other contexts).
>
> But this relates back to my first "generic" point that you haven't
> addressed here - protocol versioning and the possibility of more than
> one option. Perhaps more realistic (debatable): have the current version
> be non-PSBT but with a plan to have a version bump with PSBT in future.
> Stuff like that. It seems crazy to actually long term reject it.
>
> >
> > Anyway, a big motivation for me even writing it as a BIP was to
> formalize my little anti-DOS trick of privately creating a "template
> transaction" which can just be dumped on the network as punishment. So if
> nothing else, hopefully I'll have demonstrated it's a pretty practical way
> of doing things.
> >
>
> I don't want to be that guy, but this was a central part of the proposal
> that came of the meetup last summer and is in Haywood's blogpost. I mean
> if you came up it with separately, then cool :) But I was there, that
> was established immediately as the right way of doing this to avoid a
> trivial attack.
> What might have confused you is all that stuff about multiple candidates
> and even ZKP approaches - those were just extra ideas about making it
> really secure at large scale; but those ideas don't quite meet the goal
> (for various reasons); well, arguably. The basic anti-DOS of an initial
> non-coinjoin was sorta central.
> (Also I'm noting you didn't respond to my critique of your "always use
> the same contributions" defence; I mean, probably that's fine, it was
> only really saying it isn't perfect. Was just curious to hear
> your/others thoughts on it).
>
> > --
> >
> > Also your analysis on "Unnecessary Input Heuristic" is pretty cool, but
> I also don't like telling people to "avoid the UIH2" without providing the
> actual algo they should use. But really I think it's better off in a sort
> of article "how to pick contributed inputs" or something, as while it's
> nice it's not a huge deal and there's a lot of debatable tradeoffs that
> can/should be used. For instance the implementation I wrote for
> bustabit.com currently just heavily biases tainted inputs (e.g. ones
> associated with address reuse).
> >
>
> Good point about algo.
> I wrote my best effort at a procedure here:
>
> https://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e#gistcomment-2799709
>
> I asked for comments on it but got none back so far (gists are terrible
> for this unfortunately, perhaps I'll have more luck on the list).
>
> I would argue that this issue *should* be mentioned on the BIP. A *huge*
> part of what makes PayJoin/BustaPay of interest is the steganographic
> feature, if you don't pay attention to this then it doesn't look like a
> payment (caveat.-->).
> The counterargument is Laurent's statistics which I previously linked,
> suggesting that maybe 30% of txs violate this anyway, today. I'm not
> sure about that, will need more analysis; Core's SRD algo may be one
> reason, but anyway ... better to make things look like payments.
>
> It doesn't hurt to prompt an implementer to do this; whether it's
> feasible in that specific wallet situation or not is up to them; whether
> they want to go hog wild and control percentages of UIH1 and UIH2 and
> whatnot is there business, or they can totally ignore it - but without
> it being mentioned in the BIP, they may not even think of it.
>
> A last point, you also don't see value in being more explicit about
> simple things like transaction version and locktime? Even if you think
> these things should *not* be controlled, e.g. the protocol should allow
> either transaction version, then it'd be better to explicitly say so.
> >
> >
> > -Ryan
> >
> > ??????? Original Message ???????
> > On Friday, January 25, 2019 6:47 AM, Adam Gibson via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> >> Ryan and list,
> >> I want to add some commentary to this (BIP79) to see if we can get
> >> further in standardizing this idea.
> >>
> >> When I first mulled it over I thought it too impractical, but its virtue
> >> of steganographic hiding means only minimal uptake is still enormously
> >> interesting and worth pursuing; that's my current feeling. I've offered
> >> more detailed thoughts in my blog post[1] (def not required reading
> here).
> >>
> >> Both Joinmarket and Samourai have started implementing this kind of
> >> transaction. And while that's interesting experimentally, some kind of
> >> cross-wallet standard would be helpful, albeit there some differences
> >> between that and the merchant/centralized service use-case.
> >>
> >> We might imagine as a concrete goal for this BIP to create something
> >> that would be acceptable for inclusion into a project like BTCPayServer,
> >> so that it could be used in a realistic use case by smaller bitcoin
> >> accepting merchants.
> >>
> >> Comments to the BIP[2] as follows, with generic comments first, and then
> >> specific comments for existing points in the BIP:
> >>
> >> [1] https://joinmarket.me/blog/blog/payjoin
> >> [2] https://github.com/bitcoin/bips/blob/master/bip-0079.mediawiki
> >>
> >> Generic comments
> >>
> >>
> ==================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================
> >>
> >> -   Protocol versioning. Since inevitably (even if only merchants), this
> >>     must be implemented by multiple wallets to be useful, the
> communication
> >>     protocol will need versioning (for example i have in my
> >>     simple/experimental Joinmarket PayJoin that sender sends min and max
> >>     supported version and receiver responds with a chosen protocol
> version
> >>     so we can update). I do understand that as a client-server model can
> >>     apply here, we can ditch a lot of the complexities around
> network/p2p
> >>     interaction, but this much at least seems necessary.
> >>
> >> -   Although it has its logic, I don't think "Bustapay" is a good name
> for
> >>     this protocol. I prefer "PayJoin" which is neutral sounding and
> >>     self-descriptive. Needless to say this is not a hill I intend to
> die on.
> >>
> >> -   PSBT/BIP174. I realise this has already been discussed, but this is
> a
> >>     good example of what this standardisation was designed for, so I'd
> be
> >>     against not including it, even given the reality that, as you
> correctly
> >>     observe, it is not yet implemented in the majority of wallets and
> >>     libraries. One way round that is to make it optional (possibly
> combined
> >>     with above point about versioning). Note that for example you were
> >>     observing the necessity to check the sequence number was unchanged;
> that
> >>     would be encapsulated by checking equality of PSBT Input
> objects/fields.
> >>     While one can make such software architecture arguments, the really
> >>     fundamental point is the need for standards for x-wallet
> compatibility.
> >>
> >> -   Version, Locktime: Perhaps this is not needed; in a peer to peer
> >>     wallet scenario I think there might be logic in trying to get cover
> >>     traffic of (Core, Electrum, others), say, by using
> >>     last-block-locktime-mostly, as they do. Version should be 2 and
> sequence
> >>     is a function of your suggestion to use BIP125. Worth noting that
> BIP125
> >>     is not currently widely used on the network, though (see
> >>     https://p2sh.info/dashboard/db/replace-by-fee?orgId=1). For this
> reason
> >>     it should perhaps be explicitly only optional.
> >>
> >> -   Avoidance of non-payment "Unnecessary Input Heuristic" (1, 2). For
> >>     reference, see the definition here
> >>
> https://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e#gistcomment-2796539
> >>     and some data here
> >>
> https://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e#gistcomment-2800791
> >>     (whole comment thread may be of interest) - note this UIH name is
> afaik
> >>     Chris Belcher's invention, it seems useful as a categorisation.
> >>     So, it seems that UIH2 is more important to avoid; while some more
> >>     sophisticated wallet coin selection algorithms may occasionally pick
> >>     an input set where one input is larger than any output, most won't,
> and
> >>     some in particular never will. So I think the text here should
> indicate
> >>     that *the receiver's contributed input(s) SHOULD be chosen to avoid
> >>     triggering the UIH2 heuristic where possible, so that the final
> payjoin
> >>     transaction is maximally plausible as an ordinary payment" or
> similar.
> >>     UIH1 is a nice-to-have (meaning the plausibility extends to two
> >>     different (both wrong) payment amounts, but it may not be necessary
> to
> >>     mention it in the BIP.
> >>
> >>     Specific comments
> >>     =================
> >>
> >>
> >>>> ====Step 4. Receiver validates, re-signs, and propagates on the
> >>
> >> bitcoin network====
> >>
> >> I believe this should say "Sender" not Receiver. Also for the next
> >> sentence, s/receiver/sender/:
> >>
> >>>> The receiver MUST validate the ''partial transaction'' was changed
> >>
> >> correctly and non-maliciously (to allow using potentially untrusted
> >> communication channels), re-sign its original inputs and propagate the
> >> final transaction over the bitcoin network.
> >>
> >> Your very correct highlighting of the attack vector of "receiver gives
> >> sender other inputs belonging to sender to unwittingly sign (described
> >> below), should be highlighted here, perhaps with the phrase "re-sign its
> >> ORIGINAL inputs" (only!)".
> >>
> >>>> When the sender is creating a "template transaction" it is done
> >>
> >> almost identically to creating a normal send, with the exception that
> >> only segwit inputs may be used. The sender is also encouraged to use a
> >> slightly more aggressive feerate than usual as well as BIP125 (Opt-in
> >> Full Replace-by-Fee Signaling), but neither is strictly required.
> >>
> >> "slightly more aggressive feerate than usual" - this I understand is to
> >> make up for receiver contributed utxo, OK.
> >>
> >> "only segwit inputs" - it certainly makes things simpler. One can work
> >> with non-segwit inputs but especially considering (as mentioned below)
> >> we really ought to "MUST" the part about matching input types, I tend to
> >> agree that non-segwit should be disallowed.
> >>
> >>>> The receiver must add at least one input to the transaction (the
> >>
> >> "contributed inputs"). If the receiver has no inputs, it should use a
> >> 500 internal server error, so the client can send the transaction as per
> >> normal (or try again later).
> >>
> >> Would it not be much simpler for the server to return a different
> >> (non-error) response indicating that it will broadcast the template tx
> >> in this case?
> >>
> >>>> Its generally advised to only add a single contributed input, however
> >>
> >> they are circumstances where adding more than a single input can be
> useful.
> >>
> >> I don't see a good reason to advise the use of only 1 input? (but this
> >> will also connect with the above generic comment about "UIH"). I guess
> >> it's because of your approach to fees. I'd prefer not to create a
> >> limitation here.
> >>
> >>>> To prevent an attack where a receiver is continually sent variations
> >>
> >> of the same transaction to enumerate the receivers utxo set, it is
> >> essential that the receiver always returns the same contributed inputs
> >> when it's seen the same inputs.
> >>
> >> This is an approach to avoiding this problem which has the virtue of
> >> simplicity, but it seems a little problematic. (1) You must keep a
> >> mapping of proposed payment utxos to one's proposed contributed input
> >> utxos, but (2) how should this be updated if you need to spend the
> >> contribution mentioned in (1)? Ironically use of payjoin exacerbates
> >> this issue, because it results in a smaller number of utxos being held
> >> by the receiver at any one time :) All this considered, I still see the
> >> value in your approach, but it might end up with a re-attempted payment
> >> being rejected. Certainly the more complex suggested solutions coming
> >> out of the summer 2018 coinjoin workshop aren't as practical as this,
> >> and may be overkill for small merchants/receivers.
> >>
> >>>> It is strongly preferable that the receiver makes an effort to pick a
> >>
> >> contributed input of the same type as the other transaction inputs if
> >> possible.
> >>
> >> I have also thought about this and you could reasonably argue this
> >> should be a MUST section in the BIP, that is, if the receiver cannot use
> >> inputs of the same type, he should fall back to the template
> >> transaction. A mixed-input payjoin/coinjoin is essentially
> >> near-perfectly identifiable as such (there is almost zero other usage of
> >> multi-type-input transactions), which is a very different thing than a
> >> non-identifiable payjoin transaction. That may or may not be OK to the
> >> sender. This is debatable though, for sure.
> >>
> >>>> After adding inputs to the transaction, the receiver generally will
> >>
> >> want to adjust the output that pays himself by increasing it by the sum
> >> of the contributed input amounts (minus any fees he wants to
> >> contribute). However the only strict requirement is that the receiver
> >> must never add or remove inputs, and must not ever decrease any
> >> output amount.
> >>
> >> "must never add or remove inputs" - did you mean "must never remove
> >> inputs"? he surely has to add one! Or, perhaps you mean he must not
> >> alter the list of inputs provided by the sender (in which case it should
> >> be clarified).
> >>
> >> "must not decrease any output amount" - I initally disagreed with this
> >> but it is a better option than the one I currently chose in Joinmarket
> >> payjoin (sender pays all fee as long as receiver utxos are not too
> >> much). So this means that the receiver either consciously chooses to not
> >> increase the fee, meaning the fee rate may be a bit low (hence your
> >> earlier comment about being generous, got it), or contributes via the
> >> payout amount. I guess the latter might break merchant software
> >> expecting to have amount output fixed and fees determined by change.
> >>
> >> Regards,
> >> Adam Gibson/waxwing
> >>
> >> On 30. 08. 18 22:24, Ryan Havar via bitcoin-dev wrote:
> >>
> >>> I've just finished writing an implementing of this, and extremely happy
> >>> with how it turned out. So I'd like to go and try go down the path of
> >>> more formally describing it and getting some comments and ultimately
> >>> encourage its wide-spread use.
> >>> ==Abstract==
> >>> The way bitcoin transactions are overwhelming used is known to leak
> more
> >>> information than desirable. This has lead to fungibility concerns in
> bitcoin
> >>> and a raise of unreasonably effective blockchain analysis.
> >>> Bustapay proposes a simple, practical way to bust these assumptions to
> >>> immediate
> >>> benefit of the sender and recievers. Furthermore it does so in such a
> >>> way that
> >>> helps recievers avoid utxo bloat, a constant problem for bitcoin
> merchants.
> >>> ==Copyright==
> >>> This BIP is in the public domain.
> >>> ==Motivation==
> >>> One of the most powerful heuristic's employed by those whose goal is to
> >>> undermine
> >>> bitcoin's fungiblity has been to assume all inputs of a transaction are
> >>> signed by
> >>> a single party. In the few cases this assumption does not hold, it is
> >>> generally
> >>> readibly recognizable (e.g. traditional coinjoins have a very obvious
> >>> structure,
> >>> or multisig outputs are most frequently validated onchain).
> >>> Bustapay requires no changes to bitcoin and creates bitcoin
> transactions
> >>> that are
> >>> indistinguishable from normal ones.
> >>> It is worth noting that this specification has been intentionally kept
> >>> as simple
> >>> as possible to encourage adoption. There are almost an endless amount
> of
> >>> extensions
> >>> possible but the harder the implementation of clients/server the less
> >>> likely it
> >>> will ever be done. Should bustapay enjoy widespread adoption, a "v2"
> >>> specification
> >>> will be created with desired extensions.
> >>> ==Specification==
> >>> A bustapay payment is made from a sender to a receiver.
> >>> Step 1. Sender creates a bitcoin transaction paying the receiver
> >>> This transaction must be fully valid, signed and all inputs must use
> >>> segwit. This transaction is known as the "template transaction". This
> >>> transaction must not be propagated on the bitcoin network.
> >>> Step 2. Sender gives the "template transaction" to the receiver
> >>> This would generally be done as an HTTP POST. The exact URL to submit
> it
> >>> to could be specified with a bip21 encoded address. Such as
> >>> bitcoin:2NABbUr9yeRCp1oUCtVmgJF8HGRCo3ifpTT?bustapay=
> https://bp.bustabit.com/submit
> >>> and the HTTP body should be the raw transaction hex encoded as text.
> >>> Step 3. Receiver processes the transaction and returns a partially
> >>> signed coinjoin
> >>> The receiver validates the transaction is valid, pays himself and is
> >>> eligible for propation. The receiver then adds one of his own inputs
> >>> (known as the "contributed input") and increase the output that pays
> >>> himself by the contributed input amount. Doing so will invalidate the
> >>> "template transaction"'s original input signatures, so the sender needs
> >>> to return this "partial transaction" back to the receiver to sign. This
> >>> is returned as a hex-encoded raw transaction a response to the original
> >>> HTTP POST request.
> >>> Step 4. Receiver validates, re-signs, and propagates on the bitcoin
> network
> >>> The receiver is responsible in making sure the "partial transaction"
> >>> returned by the sender was changed correctly (it should assume the
> >>> connection has been MITM'd and act accordingly), resign its original
> >>> inputs and propagates this transaction over the bitcoin network. The
> >>> client must be aware that the server can reorder inputs and outputs.
> >>> Step 5. Receiver observes the finalized transaction on the bitcoin
> network
> >>> Once the receiver has seen the finalized transactions on the network
> >>> (and has enough confirmations) it can process it like a normal payment
> >>> for the sent amount (as opposed to the amount that it looks like on the
> >>> network). If the receiver does not see the finalized transaction after
> a
> >>> timeout will propagate the original "template transaction" to ensure
> the
> >>> payment happens and function a strong anti-DoS mechanism.
> >>> === Implementation Notes ===
> >>> For anyone wanting to implement bustapay payments, here are some notes
> >>> for receivers:
> >>>
> >>> -   A transaction can easily be checked if it's suitable for the
> mempool
> >>>     with testmempoolaccept in bitcoin core 0.17
> >>>
> >>> -   Tracking transactions by txid is precarious. To keep your sanity
> make
> >>>     sure all inputs are segwit. But remember segwit does not prevent
> txid
> >>>     malleability unless you validate the transaction. So really make
> sure
> >>>     you're using testmempoolaccept at the very least
> >>>
> >>> -   Bustapay could be abused by a malicious party to query if you own a
> >>>     deposit address or not. So never accept a bustapay transaction
> that pays
> >>>     an already used deposit address
> >>>
> >>> -   You will need to keep a mapping of which utxos people have showed
> you
> >>>     and which you revealed. So if you see them again, you can reveal
> the
> >>>     same one of your own
> >>>
> >>> -   Check if the transaction was already sorted according to BIP69, if
> so
> >>>     ensure the result stays that way. Otherwise probably just shuffle
> the
> >>>     inputs/outpus
> >>>
> >>>
> >>> Notes for sending applications:
> >>>
> >>> -   The HTTP response must not be trusted. It should be fully validated
> >>>     that no unexpected changes have been made to the transaction.
> >>>
> >>> -   The sender should be aware the original "template transaction" may
> be
> >>>     propagated at any time, and in fact can intentionally be
> >>>       done so for the purpose of RBF as it should have a slightly
> higher fee
> >>>     rate.
> >>>
> >>>
> >>> == Credits ==
> >>> The idea is obviously based upon Dr. Maxwell's seminal CoinJoin
> >>> proposal, and reduced scope inspired by a simplification of the "pay 2
> >>> endpoint" (now offline) blog post by blockstream.
> >>> -Ryan
> >>>
> >>> bitcoin-dev mailing list
> >>> bitcoin-dev at lists.linuxfoundation.org
> >>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >>
> >> bitcoin-dev mailing list
> >> bitcoin-dev at lists.linuxfoundation.org
> >> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> >
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190127/7a236457/attachment-0001.html>

From rhavar at protonmail.com  Sun Jan 27 22:11:47 2019
From: rhavar at protonmail.com (rhavar at protonmail.com)
Date: Sun, 27 Jan 2019 22:11:47 +0000
Subject: [bitcoin-dev] bustapay BIP :: a practical sender/receiver
	coinjoin protocol
In-Reply-To: <CAH+Axy7SJhTskrTX_i+Nc+HMtcNXhOFuGi11X=EjFEfBW=H06A@mail.gmail.com>
References: <TtjH2zicjKr8PBVCMOvA7ryt2z_XXvtrpC4y1wuWSxexNwMdbPGE7vPmu6UnzmfYqYBMxZ8NNoz4VUnODdIcjR4j-E1sYz_FA6ZZMjKHtuM=@protonmail.com>
	<e15c5dd7-6fe1-b253-e129-aeae6493acd1@gmail.com>
	<-yZhdFkKfKAEz1_4GKKSpTxjvR8EDSsH_5-TTh_4X5qwa79igXKR14rh6JASrald-F97o1htWY_kcBQ7IVr7ZH9zOQlOEwzhkWDjTq0d7F4=@protonmail.com>
	<2cd4fe6d-c0ca-5ae7-4107-38e1609743a8@gmail.com>
	<CAH+Axy7SJhTskrTX_i+Nc+HMtcNXhOFuGi11X=EjFEfBW=H06A@mail.gmail.com>
Message-ID: <MN5bgFMThBJ_6HiuX-aC9lAp7ainm0vhzOFMYefU-Z2QI26RUE7EmW0xTgvnxArriD-lQUTaB_wBZyKga1po6hquh1fVH5N_5wuLVIEIBfQ=@protonmail.com>

> Why does the template transaction need to be signed in step one and passed back and forth so many times? What is wrong with:

It isn't passed "back and forth so many times".  It works exactly as you proposed, with the only difference is in "Step 1" the sender uses a *signed* transaction instead of an unsigned one.  This is an important anti-DoS/anti-spy tactic, as it proves the sender actually owns those inputs and if the protocol is not followed to completion, the transaction can be dumped on the network.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190127/785cba15/attachment.html>

From ZmnSCPxj at protonmail.com  Mon Jan 28 04:14:41 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 28 Jan 2019 04:14:41 +0000
Subject: [bitcoin-dev] bustapay BIP :: a practical sender/receiver
	coinjoin protocol
In-Reply-To: <-yZhdFkKfKAEz1_4GKKSpTxjvR8EDSsH_5-TTh_4X5qwa79igXKR14rh6JASrald-F97o1htWY_kcBQ7IVr7ZH9zOQlOEwzhkWDjTq0d7F4=@protonmail.com>
References: <TtjH2zicjKr8PBVCMOvA7ryt2z_XXvtrpC4y1wuWSxexNwMdbPGE7vPmu6UnzmfYqYBMxZ8NNoz4VUnODdIcjR4j-E1sYz_FA6ZZMjKHtuM=@protonmail.com>
	<e15c5dd7-6fe1-b253-e129-aeae6493acd1@gmail.com>
	<-yZhdFkKfKAEz1_4GKKSpTxjvR8EDSsH_5-TTh_4X5qwa79igXKR14rh6JASrald-F97o1htWY_kcBQ7IVr7ZH9zOQlOEwzhkWDjTq0d7F4=@protonmail.com>
Message-ID: <-NShvd5jVPHb7_QmmjQMHX4f-O53noLWK8DKl37mJGcNlIvGoGbBrJVAwly9cHtLrB1tSz8FVL_wSMvaj2uAA760Sgr4Mg6M4VQuKZx0m7w=@protonmail.com>

Good morning Ryan and Adam,

> [UIH2 snipped]

Perhaps I am being naive, but I seem, the B2EP and similar do not need to worry about UIH2.

>From the github discussion:

> "UIH2": one input is larger than any output.
.
I.e. there exists an input, for all outputs, input > output
To avoid this, we should ensure that, for all inputs, there exists an output, input < output.

>From the proposal BIP:

> The receiver then adds one of his own inputs (known as the "contributed input") and increase the output that pays himself by the contributed input amount.

Suppose the original transaction avoids the UIH2 (i.e. for all inputs, there exists an output, input < output).
The single added input will also avoid the UIH2, since the contributed output value is added to the receiver output, thereby ensuring that contributed input < output.

Suppose the original transaction does not avoid the UIH2.
The receiver adding their own contributed input would then have a chance that the addition on the output will now cause the final transaction to avoid the UIH2, since the sum of the receiver amount and the contributed input may now exceed the largest sender input.
But since there are more transactions that avoid the UIH2 than not avoid UIH2, the increased probability of now avoiding the UIH2 will lead to a greater anonymity set (especially for the sender, whose coin selection algorithm might have a consistent bias that makes it create transactions that trigger UIH2).

So it seems to me that the simple solution, i.e. sender uses standard coin selection algorithms already in use today, and receiver does not do any UIH2 checks at all, would be an improvement in both privacy and implementation simplicity.

Regards,
ZmnSCPxj

From ekaggata at gmail.com  Mon Jan 28 13:19:09 2019
From: ekaggata at gmail.com (Adam Gibson)
Date: Mon, 28 Jan 2019 14:19:09 +0100
Subject: [bitcoin-dev] bustapay BIP :: a practical sender/receiver
 coinjoin protocol
In-Reply-To: <-NShvd5jVPHb7_QmmjQMHX4f-O53noLWK8DKl37mJGcNlIvGoGbBrJVAwly9cHtLrB1tSz8FVL_wSMvaj2uAA760Sgr4Mg6M4VQuKZx0m7w=@protonmail.com>
References: <TtjH2zicjKr8PBVCMOvA7ryt2z_XXvtrpC4y1wuWSxexNwMdbPGE7vPmu6UnzmfYqYBMxZ8NNoz4VUnODdIcjR4j-E1sYz_FA6ZZMjKHtuM=@protonmail.com>
	<e15c5dd7-6fe1-b253-e129-aeae6493acd1@gmail.com>
	<-yZhdFkKfKAEz1_4GKKSpTxjvR8EDSsH_5-TTh_4X5qwa79igXKR14rh6JASrald-F97o1htWY_kcBQ7IVr7ZH9zOQlOEwzhkWDjTq0d7F4=@protonmail.com>
	<-NShvd5jVPHb7_QmmjQMHX4f-O53noLWK8DKl37mJGcNlIvGoGbBrJVAwly9cHtLrB1tSz8FVL_wSMvaj2uAA760Sgr4Mg6M4VQuKZx0m7w=@protonmail.com>
Message-ID: <226c43d8-1fad-9d90-ba47-9230118e447d@gmail.com>

ZmnSCPxj, thanks, responses inline.

On 28. 01. 19 5:14, ZmnSCPxj wrote:
> Good morning Ryan and Adam,
> 
>> [UIH2 snipped]
> 
> Perhaps I am being naive, but I seem, the B2EP and similar do not need to worry about UIH2.
> 
> From the github discussion:
> 
>> "UIH2": one input is larger than any output.
> .
> I.e. there exists an input, for all outputs, input > output
> To avoid this, we should ensure that, for all inputs, there exists an output, input < output.
> 
> From the proposal BIP:
> 
>> The receiver then adds one of his own inputs (known as the "contributed input") and increase the output that pays himself by the contributed input amount.
> 
> Suppose the original transaction avoids the UIH2 (i.e. for all inputs, there exists an output, input < output).
> The single added input will also avoid the UIH2, since the contributed output value is added to the receiver output, thereby ensuring that contributed input < output.
> 
Yes, I had noted this (see link below).

> Suppose the original transaction does not avoid the UIH2.
> The receiver adding their own contributed input would then have a chance that the addition on the output will now cause the final transaction to avoid the UIH2, since the sum of the receiver amount and the contributed input may now exceed the largest sender input.

(Just to note (see link below) what I'm sure you're aware of but a
reader might forget: if the change output that the sender provided is
larger than the payment amount, the above won't happen).

> But since there are more transactions that avoid the UIH2 than not avoid UIH2, the increased probability of now avoiding the UIH2 will lead to a greater anonymity set (especially for the sender, whose coin selection algorithm might have a consistent bias that makes it create transactions that trigger UIH2).
> 
> So it seems to me that the simple solution, i.e. sender uses standard coin selection algorithms already in use today, and receiver does not do any UIH2 checks at all, would be an improvement in both privacy and implementation simplicity.
> 
> Regards,
> ZmnSCPxj
> 

Really good point, and I think your argument is reasonable, if not
watertight. (Just in case you missed it I tried to outline an algo to
let the receiver avoid UIH2 on best effort basis here:
https://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e#gistcomment-2799709).

Although I ~ sorta agree, there is a slight counterargument: receiver is
adding utxos, so in the absence of any transaction inspection you're
creating a different distribution than one gets from existing wallet
selection algos. For example:
Note that the most likely/desirable/considered use case may be a
merchant use case (after all, who receives coins most frequently? in
theory, people selling stuff), and it is highly plausible that they
might concentrate larger and larger sums into utxo(s) via use of
PayJoin. Completely mismatched input sizes could be a problem, it's
debatable, and it's also debatable whether it can be avoided, but what I
don't quite buy is that this issue can just be ignored.

And I'm reminded that a related point is made by belcher in the gist
comment thread iirc (after we discussed it on IRC): over time a
"PayJoin-only" merchant doing the simplest thing - using a single utxo
over and over again, will concentrate more and more funds into it, and
inevitably violating UIH2 in an increasingly dramatic fashion
(contributing a 100BTC utxo to a 0.1BTC payment etc.). Suggesting it's
better if there's a mix of payjoin/non-payjoin.

From stevenroose at gmail.com  Tue Jan 29 22:03:04 2019
From: stevenroose at gmail.com (Steven Roose)
Date: Tue, 29 Jan 2019 22:03:04 +0000
Subject: [bitcoin-dev] [BIP Proposal] Simple Proof-of-Reserves Transactions
Message-ID: <CAChG=YV2em+6c9P4DEUB1=+ZSEA6S0j9HDuWoKBeRVMmtzaMNg@mail.gmail.com>

Been working on a proof-of-reserves tool POC for a while, trying to
formalize the formats so that wallets can integrate more easily.


<pre>
  BIP: ?
  Layer: Applications
  Title: Simple Proof-of-Reserves Transactions
  Author: Steven Roose <steven at stevenroose.org>
  Comments-Summary: No comments yet.
  Comments-URI: tbd
  Status: Draft
  Type: Standards Track
  Created: 2019-01-28
  License: CC0-1.0
</pre>


==Abstract==

This BIP describes a simple way to construct proof-of-reserves transactions.
This proposal formalizes a standard format for constructing such proofs,
easing
their construction with existing wallet infrastructure and enabling general
proof-verification software.  It relies on existing standards such as
regular
Bitcoin transaction serialization/validation and the BIP 174 PSBT format.
The proposal also includes the description of a PSBT extension for a better
user experience.

==Copyright==

This BIP is licensed under the Creative Commons CC0 1.0 Universal license.

==Motivation==

>From the very early days in the history of Bitcoin, there have been
companies
managing bitcoins for their users.  These users give up control over their
coins
in return for a certain service.  Inevitably, there have been many cases of
companies losing their users' bitcoins without timely disclosing such
events to
the public.  Proofs of Reserves are a way for companies managing large
amounts
of bitcoins to prove ownership over a given amount of funds.  The regular
proof
of control helps to ensure that no significant loss has occurred.

While the term proof-of-reserves is not new by any means, the procedure is
not
very common among high-value custodian companies.  One of the reasons for
this
is that every company that wants to perform a proof-of-reserves has to
construct
its own way to do so.  Accordingly, their users have to understand the
construction of the proof in order to be able to verify it.  This raises
the bar
of entry both for custodians and for users.


===What this BIP is not doing===

The proof-of-reserve construction described in this document has some known
shortcomings, mostly with regards to its privacy properties.  While there
exists
research about improved proof-of-reserves mechanisms that have much better
privacy properties<ref>Dagher, Gaby G., Benedikt B?nz, Joseph Bonneau,
Jeremy
Clark, and Dan Boneh. "Provisions: Privacy-preserving proofs of solvency for
Bitcoin exchanges." (2015).</ref>, this BIP intentionally only formalizes
the de-facto existing method.


==Specification==

Our specification consists of two parts:
# the format for the actual proofs
# a file format used to package a set of proofs and relevant metadata

The final construction should have the following properties:
* flexible proof construction to support complex wallet infrastructures
* easy integration with existing wallet solutions (both hardware and
software wallets)
* support for verification via a standard procedure, regardless of
publisher of the proof
* proof prevents reuse of proofs by other parties by commiting to a message
* allow validating that the issuer had the funds under his control at a
certain block, regardless of what happened after that block

===Proof Format===

To allow for maximal compatibility with existing systems, proofs are
formatted as regular Bitcoin
transactions.  However, one small adaptation to the transaction is made
that has two functions:
# make the transaction unspendable to avoid putting funds at risk
# link the proof to the issuer of the proof to prevent copying proofs from
other custodians

The resulting construction is a Bitcoin transaction with the following
characteristics:

* The first input (the "commitment input")
** MUST have the txid part of the previous outpoint set to the SHA-256 hash
of the commitment message prefixed with "Proof-of-Reserves: "<ref>If the
message is "Some Message", the txid part should be
<tt>SHA-256("Proof-of-Reserves: Some Message")</tt> with the string encoded
as UTF-8.</ref> and index 0.
* The remaining inputs
** MUST have signatures that commit to the commitment input (e.g. using
<tt>SIGHASH_ALL</tt>).
* The transaction MUST have a single output that is the exact sum of all
the inputs, assuming the commitment input to have 0 value; this means the
transaction has no miner fee.

The existence of the first input (which is just a commitment hash) ensures
that this transaction is invalid and can never be confirmed.


===Proof File Format===

In theory, the first part of the specification would be sufficient as a
minimum
viable standard.  However, there are a number of motivations to extend the
standard with an extra layer of metadata:

# constructing and combining multiple proofs
#:Having thousands of UTXOs spread across different offline and online
wallets could make it difficult to construct a single proof transaction
with all UTXOs.  Allowing multiple proof transactions with the same
commitment message and block number gives extra flexibility to custodians
with complex wallet infrastructure without making the combined proof less
secure.
# metadata for verification
#:Not all systems that will be used for verification have access to a full
index of all transactions.  However, proofs should be easily verifiable
even after some of the UTXOs used in the proof are no longer unspent.
Metadata present in the proof allows for relatively efficient verification
of proofs even if no transaction index is available.
# potential future improvements
#:The extensible metadata format allows for amending the standard in the
future.  One potential improvement would be having UTXO set commitments.
These would allow the proofs-of-reserves to come with accompanying
proofs-of-inclusion of all used UTXOs in the UTXO set at the block of proof
constsruction (making validation even more efficient).

The proposed proof-file format provides a standard way of combining multiple
proofs and associated metadata.  The specification of the format is in the
Protocol Buffers<ref>https://github.com/protocolbuffers/protobuf/</ref>
format.

<pre>
syntax = "proto3";
import "google/protobuf/any.proto";

message OutputMeta {
// Identify the outpoint.
bytes txid = 1;
uint32 vout = 2;

// The block hash of the block where this output was created.
bytes block_hash = 3;
}

message FinalProof {
// The proof transaction.  Should be able to be parsed like a regular
// Bitcoin transaction.
bytes proof_tx = 1;

// The metadata of the ouputs used in the proof transaction.
repeated OutputMeta output_metadata = 2;
}

message ProofOfReserves {
// A version number for this format to enable extending it with
// additional fields.
uint32 version = 1;

// The network magic for the network in which the proofs are valid.
// 0xD9B4BEF9 for mainnet, 0x0709110B for testnet
//TODO consider BIP44 coin type ids instead:
// https://github.com/satoshilabs/slips/blob/master/slip-0044.md
uint32 network_magic = 2;

// The commitment message for this proof-of-reserves.
// This message is global for all the proofs.
string message = 3;

// The block at which this proof is supposed to be validated.
// Verification should take into account unspentness of outputs at this
// block height.
bytes block_hash = 4;

// The set of final proof transactions with their output metadata.
repeated FinalProof final_proofs = 5;

// Reserved field that can potentially be used by proof-construction tools.
// It can be ignored for verification.
repeated google.protobuf.Any pending_proofs = 6;
}
</pre>

The last field, <tt>pending_proofs</tt>, leaves open some space in the same
file that can be used by proof-construction tools.  This allows them to
construct different proofs incrementally without having to switch between
file
formats.


===PSBT (BIP 174) extension===

The "commitment input" detailed in the proof format section does not spend
an
existing UTXO and thus shouldn't be signed (empty <tt>scriptSig</tt> and
witness).  This can cause some problems when signing this type of
transactions.
For example, hardware wallets often require the signer to provide
information
about all inputs of transactions they are signing, such as the previous
output
or previous transaction; this data obviously doesn't exist for the
commitment
inputs.

For most existing devices, it's possible to circumvent these requirements by
providing dummy data or by instructing the device to ignore this specific
input.  However, there is still a UX problem.  Because the hardware wallet
device doesn't recognize the transaction as a proof-of-reserves transaction
it
will think it is signing a regular transaction that is spending all the
money
in the UTXOs.  Most devices will ask for confirmation with a message along
the
lines of "Are you sure you want to send XXX BTC to address [...]?".  This is
not the best user experience.

An addition to the BIP 174 PSBT format could help signing devices to
recognize proof-of-reserve transactions.
The following field is added to the BIP 174 <tt>INPUT</tt> map:

* Type: Proof-of-reserves commitment <tt>PSBT_IN_POR_COMMITMENT = 0x09</tt>
** Key: None. The key must only contain the 1 byte type.
*** <tt>{0x09}</tt>
** Value: The UTF-8 encoded commitment message string for the
proof-of-reserves.
*** <tt>{porCommitment}</tt>

Wallets processing an input that has this field set
* MUST make sure the txid of the previous outpoint is set to the SHA-256
hash of the prefixed commitment message string, as detailed above;
* MUST assume the input value to be 0 (without requiring the previous
output or transaction to be provided);
* SHOULD display the commitment message to ask the user for confirmation
before signing any inputs;
* SHOULD only provide signatures with a signature hash that commits to this
input;
* SHOULD accept an empty <tt>scriptSig</tt> for this input (as if the
<tt>scriptPubKey</tt> was <tt>OP_TRUE</tt>).


==Implementations==

A proof-of-concept implementation of the PSBT extension in the
[https://github.com/rust-bitcoin/rust-bitcoin rust-bitcoin] project can be
found in the <tt>psbt-por</tt> branch here:
https://github.com/stevenroose/rust-bitcoin/tree/psbt-por

A work-in-progress implementation of a tool that produces and verifies
proofs
in the described format can be found here:
https://github.com/stevenroose/reserves


== Footnotes ==

<references />

PR: https://github.com/bitcoin/bips/pull/756
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190129/e217f099/attachment-0001.html>

From keatonatron at gmail.com  Wed Jan 30 02:06:30 2019
From: keatonatron at gmail.com (James MacWhyte)
Date: Tue, 29 Jan 2019 18:06:30 -0800
Subject: [bitcoin-dev] bustapay BIP :: a practical sender/receiver
 coinjoin protocol
In-Reply-To: <MN5bgFMThBJ_6HiuX-aC9lAp7ainm0vhzOFMYefU-Z2QI26RUE7EmW0xTgvnxArriD-lQUTaB_wBZyKga1po6hquh1fVH5N_5wuLVIEIBfQ=@protonmail.com>
References: <TtjH2zicjKr8PBVCMOvA7ryt2z_XXvtrpC4y1wuWSxexNwMdbPGE7vPmu6UnzmfYqYBMxZ8NNoz4VUnODdIcjR4j-E1sYz_FA6ZZMjKHtuM=@protonmail.com>
	<e15c5dd7-6fe1-b253-e129-aeae6493acd1@gmail.com>
	<-yZhdFkKfKAEz1_4GKKSpTxjvR8EDSsH_5-TTh_4X5qwa79igXKR14rh6JASrald-F97o1htWY_kcBQ7IVr7ZH9zOQlOEwzhkWDjTq0d7F4=@protonmail.com>
	<2cd4fe6d-c0ca-5ae7-4107-38e1609743a8@gmail.com>
	<CAH+Axy7SJhTskrTX_i+Nc+HMtcNXhOFuGi11X=EjFEfBW=H06A@mail.gmail.com>
	<MN5bgFMThBJ_6HiuX-aC9lAp7ainm0vhzOFMYefU-Z2QI26RUE7EmW0xTgvnxArriD-lQUTaB_wBZyKga1po6hquh1fVH5N_5wuLVIEIBfQ=@protonmail.com>
Message-ID: <CAH+Axy68O76GjjKtdzwOQBS0bQauoPXJEYnrztSfYzVNDSbcNw@mail.gmail.com>

James


On Sun, Jan 27, 2019 at 2:11 PM <rhavar at protonmail.com> wrote:

>
> It isn't passed "back and forth so many times".
>

You are right, I got the wrong impression the first time I read it.


> This is an important anti-DoS/anti-spy tactic, as it proves the sender
> actually owns those inputs and if the protocol is not followed to
> completion, the transaction can be dumped on the network.
>

I'm not convinced this is a valid concern, at least not valid enough to add
extra complications to the process. The sender could still refuse to sign
the final transaction after they see the recipient's in-/outputs; "show me
yours and I'll show you mine" isn't much of a spy deterrent, and nothing
here prevents a DOS attack.

As an implementor, I would suggest keeping the protocol as simple as
possible. By dropping the signing in the first step, the recipient doesn't
need to maintain the ability to lookup and verify unspent outputs. It also
would enforce the increased privacy, which the sender obviously wants if
they are going down this path (in other words, either have the process
complete or fail -- don't give the recipient the ability to broadcast the
not-private transaction against the wishes of the sender).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190129/e3d08376/attachment.html>

From rhavar at protonmail.com  Wed Jan 30 02:46:47 2019
From: rhavar at protonmail.com (rhavar at protonmail.com)
Date: Wed, 30 Jan 2019 02:46:47 +0000
Subject: [bitcoin-dev] bustapay BIP :: a practical sender/receiver
	coinjoin protocol
In-Reply-To: <CAH+Axy68O76GjjKtdzwOQBS0bQauoPXJEYnrztSfYzVNDSbcNw@mail.gmail.com>
References: <TtjH2zicjKr8PBVCMOvA7ryt2z_XXvtrpC4y1wuWSxexNwMdbPGE7vPmu6UnzmfYqYBMxZ8NNoz4VUnODdIcjR4j-E1sYz_FA6ZZMjKHtuM=@protonmail.com>
	<e15c5dd7-6fe1-b253-e129-aeae6493acd1@gmail.com>
	<-yZhdFkKfKAEz1_4GKKSpTxjvR8EDSsH_5-TTh_4X5qwa79igXKR14rh6JASrald-F97o1htWY_kcBQ7IVr7ZH9zOQlOEwzhkWDjTq0d7F4=@protonmail.com>
	<2cd4fe6d-c0ca-5ae7-4107-38e1609743a8@gmail.com>
	<CAH+Axy7SJhTskrTX_i+Nc+HMtcNXhOFuGi11X=EjFEfBW=H06A@mail.gmail.com>
	<MN5bgFMThBJ_6HiuX-aC9lAp7ainm0vhzOFMYefU-Z2QI26RUE7EmW0xTgvnxArriD-lQUTaB_wBZyKga1po6hquh1fVH5N_5wuLVIEIBfQ=@protonmail.com>
	<CAH+Axy68O76GjjKtdzwOQBS0bQauoPXJEYnrztSfYzVNDSbcNw@mail.gmail.com>
Message-ID: <rw6S6-g_a3GdPaJ1pspzBCAVxromSSYzw_jQhgsZ9VmWPLxfMG-DB_ne2VhMvAkpppbc20mwXXyYjUmy1ifVHHfDXGUTnZdI87omk8T6gV4=@protonmail.com>

On Tuesday, January 29, 2019 6:06 PM, James MacWhyte <keatonatron at gmail.com> wrote:

> I'm not convinced this is a valid concern, at least not valid enough to add extra complications to the process.

Signing a transaction is something a wallet needs to be able to do anyway AND at the final-step. And actually a signed transaction is _simpler_ because it's more standard and way format to send and validate.

> The sender could still refuse to sign the final transaction after they see the recipient's in-/outputs; "show me yours and I'll show you mine" isn't much of a spy deterrent, and nothing here prevents a DOS attack.

If the sender refuses to sign the final transaction, the receiver just propagates the template transaction which pays the receiver! So it's a pretty weak attack.

The only real attack is that the sender could double-spend the template-transaction before it's propagated, but the cost of doing this isn't free, as at the very least you need to pay the transaction fees of creating a double spend. It's not an amazingly good defence, but it's good enough that it's unlikely to get abused (and an attacker would only learn a single utxo of the receiver) .

> As an implementor, I would suggest keeping the protocol as simple as possible. By dropping the signing in the first step, the recipient doesn't need to maintain the ability to lookup and verify unspent outputs.

Being able to verify a transaction tends to be pretty simple in practice.  (e.g. `testmempoolaccept` in bitcoin core's wallet) but if it's really hard for a receiver to do, it can easily just not do it... (and assume the template transaction is valid even if it's not).

But I suspect this actually complicates the job for the receiver, because now you have to deal with transaction malleability as they can now give you an invalid transaction, you sign it  and then they malleate into a valid transaction with a different txid. So if you're tracking the transaction by txid, you'll get really confused...).

> It also would enforce the increased privacy, which the sender obviously wants if they are going down this path

I guess that's a valid concern. A sender might want to make a payment, but *only* if it can be done via a bustapay, while the current spec doesn't support that.

But there's no way that justifies removing the protection for receivers. Without some _basic_ protection, every company that takes bustapayments will just get constantly attacked by a simple costless `wget` that leaks their wallet utxos...

The only viable way I can see, would be the sender pays the first part of his invoice in lightning. And then pays the rest with a bustapay. Now the anti-spy thing is the fact the first part of the invoice was already paid.

But with so many moving parts, no one is ever going to implement that :P
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190130/dbe00339/attachment.html>

From ZmnSCPxj at protonmail.com  Wed Jan 30 08:34:46 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 30 Jan 2019 08:34:46 +0000
Subject: [bitcoin-dev] bustapay BIP :: a practical sender/receiver
	coinjoin protocol
In-Reply-To: <226c43d8-1fad-9d90-ba47-9230118e447d@gmail.com>
References: <TtjH2zicjKr8PBVCMOvA7ryt2z_XXvtrpC4y1wuWSxexNwMdbPGE7vPmu6UnzmfYqYBMxZ8NNoz4VUnODdIcjR4j-E1sYz_FA6ZZMjKHtuM=@protonmail.com>
	<e15c5dd7-6fe1-b253-e129-aeae6493acd1@gmail.com>
	<-yZhdFkKfKAEz1_4GKKSpTxjvR8EDSsH_5-TTh_4X5qwa79igXKR14rh6JASrald-F97o1htWY_kcBQ7IVr7ZH9zOQlOEwzhkWDjTq0d7F4=@protonmail.com>
	<-NShvd5jVPHb7_QmmjQMHX4f-O53noLWK8DKl37mJGcNlIvGoGbBrJVAwly9cHtLrB1tSz8FVL_wSMvaj2uAA760Sgr4Mg6M4VQuKZx0m7w=@protonmail.com>
	<226c43d8-1fad-9d90-ba47-9230118e447d@gmail.com>
Message-ID: <q_EImVoLLoTdTZI0kPb4olI3FFjIMx9Uj0O8acFefNbsMtU7K25wWz69Alm-jbwZ8SEV1U3Y6Re3705Xi2zQb5129MbtjEVE8dT_JtSSfmA=@protonmail.com>

Good morning Adam,

> And I'm reminded that a related point is made by belcher in the gist
> comment thread iirc (after we discussed it on IRC): over time a
> "PayJoin-only" merchant doing the simplest thing - using a single utxo
> over and over again, will concentrate more and more funds into it, and
> inevitably violating UIH2 in an increasingly dramatic fashion
> (contributing a 100BTC utxo to a 0.1BTC payment etc.). Suggesting it's
> better if there's a mix of payjoin/non-payjoin.

To be pedantic: as I understand bustapay, it would still not violate UIH2 (unless I misunderstand UIH2).

Suppose the original transaction is: (0.05 payer, 0.07 payer) -> (0.1 payee, 0.02 payer)

Then bustapay with such a PayJoin-only merchant with 100BTC UTXO would give: (100 payee, 0.05 payer, 0.07 payer) -> (100.1 payee, 0.02 payer).
As I understand it, this technically does not violate UIH2.

It would still conceivably be interpreted as a payment of 100.1 BTC, from a payer who happens to have massively lopsided UTXOs being owned, but still does not violate UIH2.

However, if that 100.1 UTXO is subsequently used to pay a 100.3 payment, then that is used to pay a 100.7 payment, that strongly suggests such a naive PayJoin-only merchant.

Perhaps a simple heuristic against this would be:

1.  For every UTXO you own, flip a coin.
    If all of them come up heads, do not payjoin; just broadcast the original transaction.
2.  Else, randomly select a UTXO (value not care?) and payjoin with that UTXO.

However, I have no proper analysis of the blockchain, so --

Regards,
ZmnSCPxj

From antoniy at lbry.io  Wed Jan 30 14:24:21 2019
From: antoniy at lbry.io (Antoniy Shumanov)
Date: Wed, 30 Jan 2019 16:24:21 +0200
Subject: [bitcoin-dev] Contribution
Message-ID: <CAAdU4QpePWKmDZL65Agyd9CTWHooAy8wDtgu0TF8kFZvDZ_-JQ@mail.gmail.com>

Hi, bitcoin devs. I'm working at lbry.io and we stay closely to your core,
i want to discuss what you think about a contribution like:
base_blob and/or base_uint to be derived from std::array to be enabled move
semantics, as well on uint160, uint256, COutPoint.
Another approach that bother me is acquiring / releasing recursive mutex in
a loop, snippet from minig.cpp
while (nHeight < nHeightEnd && !ShutdownRequested())
{
    std::unique_ptr<CBlockTemplate>

pblocktemplate(BlockAssembler(Params()).CreateNewBlock(coinbaseScript->reserveScript));
    CBlock *pblock = &pblocktemplate->block;
    {
        LOCK(cs_main); // <--------- acquiring
        IncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce);
    } // <-------- release
    std::shared_ptr<const CBlock> shared_pblock =
    std::make_shared<const CBlock>(*pblock);
    if (!ProcessNewBlock(Params(), shared_pblock, true, nullptr)) // <----
acquiring / release again inside
}
Doing it in a loop makes things to be slow down even more, what's idea
behind?
Also consider using of atomic global variable rather than acquiring mutex
again, no?
Did you interested in contribution in these approaches?

Regards
Antoniy Shumanov
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190130/ed88efe2/attachment-0001.html>

From falke.marco at gmail.com  Wed Jan 30 16:29:05 2019
From: falke.marco at gmail.com (Marco Falke)
Date: Wed, 30 Jan 2019 11:29:05 -0500
Subject: [bitcoin-dev] Contribution
In-Reply-To: <CAAdU4QpePWKmDZL65Agyd9CTWHooAy8wDtgu0TF8kFZvDZ_-JQ@mail.gmail.com>
References: <CAAdU4QpePWKmDZL65Agyd9CTWHooAy8wDtgu0TF8kFZvDZ_-JQ@mail.gmail.com>
Message-ID: <CAK51vgDqRQe5vWfjax-me=rcHaLoqkp+63+6Ya7J+_zmH8FBng@mail.gmail.com>

This mailing list is for the development of the Bitcoin protocol (see
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev).
Code changes to Bitcoin Core can be discussed on
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-core-dev or
preferably be submitted to https://github.com/bitcoin/bitcoin/
directly.

-- Marco

From keatonatron at gmail.com  Wed Jan 30 20:58:03 2019
From: keatonatron at gmail.com (James MacWhyte)
Date: Wed, 30 Jan 2019 12:58:03 -0800
Subject: [bitcoin-dev] bustapay BIP :: a practical sender/receiver
 coinjoin protocol
In-Reply-To: <rw6S6-g_a3GdPaJ1pspzBCAVxromSSYzw_jQhgsZ9VmWPLxfMG-DB_ne2VhMvAkpppbc20mwXXyYjUmy1ifVHHfDXGUTnZdI87omk8T6gV4=@protonmail.com>
References: <TtjH2zicjKr8PBVCMOvA7ryt2z_XXvtrpC4y1wuWSxexNwMdbPGE7vPmu6UnzmfYqYBMxZ8NNoz4VUnODdIcjR4j-E1sYz_FA6ZZMjKHtuM=@protonmail.com>
	<e15c5dd7-6fe1-b253-e129-aeae6493acd1@gmail.com>
	<-yZhdFkKfKAEz1_4GKKSpTxjvR8EDSsH_5-TTh_4X5qwa79igXKR14rh6JASrald-F97o1htWY_kcBQ7IVr7ZH9zOQlOEwzhkWDjTq0d7F4=@protonmail.com>
	<2cd4fe6d-c0ca-5ae7-4107-38e1609743a8@gmail.com>
	<CAH+Axy7SJhTskrTX_i+Nc+HMtcNXhOFuGi11X=EjFEfBW=H06A@mail.gmail.com>
	<MN5bgFMThBJ_6HiuX-aC9lAp7ainm0vhzOFMYefU-Z2QI26RUE7EmW0xTgvnxArriD-lQUTaB_wBZyKga1po6hquh1fVH5N_5wuLVIEIBfQ=@protonmail.com>
	<CAH+Axy68O76GjjKtdzwOQBS0bQauoPXJEYnrztSfYzVNDSbcNw@mail.gmail.com>
	<rw6S6-g_a3GdPaJ1pspzBCAVxromSSYzw_jQhgsZ9VmWPLxfMG-DB_ne2VhMvAkpppbc20mwXXyYjUmy1ifVHHfDXGUTnZdI87omk8T6gV4=@protonmail.com>
Message-ID: <CAH+Axy77+OTZ12=FFhrdg-1xznKjVQUT58mP6yjVbt7sWtgA7g@mail.gmail.com>

On Tue, Jan 29, 2019 at 6:46 PM <rhavar at protonmail.com> wrote:

>
> If the sender refuses to sign the final transaction, the receiver just
> propagates the template transaction which pays the receiver! So it's a
> pretty weak attack.
>
> The only real attack is that the sender could double-spend the
> template-transaction before it's propagated, but the cost of doing this
> isn't free, as at the very least you need to pay the transaction fees of
> creating a double spend. It's not an amazingly good defence, but it's good
> enough that it's unlikely to get abused (and an attacker would only learn a
> single utxo of the receiver) .
>

Okay, I see what you mean. I better understand the weaknesses you've
identified, and I can't really think of a better solution than what you've
proposed. I also realized that implementors who aren't capable of
integrating signing and UTXO validation wouldn't be the ones trying to
implement this feature, so my concerns there are also moot. Carry on ;)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190130/f26a6e84/attachment.html>

From aj at erisian.com.au  Thu Jan 31 06:04:05 2019
From: aj at erisian.com.au (Anthony Towns)
Date: Thu, 31 Jan 2019 16:04:05 +1000
Subject: [bitcoin-dev] Safer NOINPUT with output tagging
In-Reply-To: <B2h-WuZWvKKnCqz_qvciHFHf16SgY_63GAF_Y5KbsiJ_wRRoZMw-LBT6Beob9oYOzm9TMaeewJhZXqvPr7TizXOLBoOsOiKPQDyax4aefGY=@protonmail.com>
References: <9F8C0789-48E9-448A-A239-DB4AFB902A00@xbt.hk>
	<8z5NQkaOUo9z-wdBphQtZrxIf7OCtVQFvK3neMWvcRsngld5XJs-vt7CLuY46ZOp_pX8gEd92pMdkEkp8CUOMH9lUTw5ocWsbDPiaKdSa2I=@protonmail.com>
	<34B38940-524D-42B9-8A67-6A62DCE04665@xbt.hk>
	<KFCfNAmHhRvsDJs70UW3l4ssqBtdBrb8gYP5A3cN2hsTPrXVg7f5Yrt2LOo5V0QdAhhoooc3lllXxiiXSVt_28obYBl_XKAgEQkGg1kOj8I=@protonmail.com>
	<CAABEECD-2B12-4852-A440-58809EB6BF56@xbt.hk>
	<B2h-WuZWvKKnCqz_qvciHFHf16SgY_63GAF_Y5KbsiJ_wRRoZMw-LBT6Beob9oYOzm9TMaeewJhZXqvPr7TizXOLBoOsOiKPQDyax4aefGY=@protonmail.com>
Message-ID: <20190131060405.e7hefirxcars4bpu@erisian.com.au>

On Mon, Dec 24, 2018 at 11:47:38AM +0000, ZmnSCPxj via bitcoin-dev wrote:
> A boutique protocol would reduce the number of existing onchain wallets that could be integrated in such UI.

Seems like PSBT would be a sufficient protocol:

 0) lightning node generates a PSBT for a new channel,
    with no inputs and a single output of the 2-of-2 address

 1) wallet funds the PSBT but doesn't sign it, adding a change address
    if necessary, and could combine with other tx's bustapay style

 2) lightning determines txid from PSBT, and creates update/settlement
    tx's for funding tx so funds can be recovered

 3) wallet signs and publishes the PSBT

 4) lightning sees tx on chain and channel is open

That's a bit more convoluted than "(0) lightning generates an address and
value, and creates NOINPUT update/settlement tx's for that address/value;
(1) wallet funds address to exactly that value; (2) lightning monitors
blockchain for payment to that address" of course.

But it avoids letting users get into the habit of passing NOINPUT
addresses around, or the risk of a user typo'ing the value and losing
money immediately, and it has the benefit that the wallet can tweak the
value if (eg) that avoids a change address or enhances privacy (iirc,
c-lightning tweaks payment values for that reason). If the channel's
closed cooperatively, it also avoids ever needing to publish a NOINPUT
sig (or NOINPUT tagged output).

Does that seem a fair trade off?

Cheers,
aj


From oleganza at gmail.com  Thu Jan 31 23:44:43 2019
From: oleganza at gmail.com (Oleg Andreev)
Date: Thu, 31 Jan 2019 15:44:43 -0800
Subject: [bitcoin-dev] Predicate Tree in ZkVM: a variant of Taproot/G'root
Message-ID: <B88B34DB-8FBE-4B45-9E24-6676384C54F2@gmail.com>

Hi,

We've been working for a thing called ZkVM [1] for the last few weeks. It is a "blockchain virtual machine" in the spirit of Bitcoin, with multi-asset transfers and zero-knowledge programmable constraints.

As a part of its design, there is a "Predicate Tree" ? a variant of Taproot by Greg Maxwell [2] and G'root by Anthony Towns [3] that I would like to present here. Hopefully it is useful to the discussion, and I would appreciate any feedback.

## Background

In ZkVM there are linear types Contract and Value (in addition to plain data types), where Contract also implements "object capabilities" pattern: Contract "locks" a collection of data and Values under a "predicate" which is represented by a single group element ("point" in ECC terms). The predicate can be "satisfied" in a number of allowed ways which makes the contract unlock its contents, e.g. release the stored Value which can then be locked in a new unspent output.

## Predicate Tree

Predicate is a point that represents one of three things, which allows composing conditions in an arbitrary tree:

1. Public key
2. Program
3. Disjunction of two other predicates

Public key allows representing N-of-N signing conditions (and M-of-N with proper threshold key setup, although small combinations like 2-of-3 can be non-interactively represented as a tree of 3 combinations of 2-of-2 conditions):

   P = x*B  (x is a secret, B is a primary generator point)

Program commitment is a P2SH-like commitment:

   P = hash2scalar(program)*B2   (B2 is orthogonal to B, so one cannot sign for P, but must reveal the program)

Disjunction (asymmetric to allow happy-path signing with the left predicate):

   P = L + hash2scalar(L,R)*B


## VM instructions

To use the predicate trees, ZkVM provides 4 instructions:

1. `signtx` to verify the signature over the transaction ID treating the predicate as a pubkey.
2. `call` to reveal the committed program and execute it.
3. `left`/`right` to replace the contract's predicate with one of the sub-predicates in a disjunction.
4. `delegate` to check a signature over a program and execute that program (pay-to-signed-program pattern).

More details are in the ZkVM spec: https://github.com/interstellar/zkvm/blob/main/spec/ZkVM.md#signtx

`call` and `delegate` differ in that `call` reveals and runs a pre-arranged program (like in P2SH), while `delegate` allows choosing the program later which can be signed with a pre-arranged public key. `delegate` also enables use cases for SIGHASH: if a specific output or outputs or constraints must be signed, they can be represented by such program snippet. Likewise, a "revocation token" for the payment channel (LN) can be implemented with `delegate` instruction.


## Performance

For performance, the following rules are built into ZkVM:

1. All point operations are deferred. Signature checks, disjunction proofs, program commitment proofs - are not executed right away, but deferred and verified in a batch after the VM execution is complete. This enables significant savings, especially since half or third of the terms reuse static points B and B2.
2. `signtx` does not accept individual signatures, but uses a single aggregated signature for the whole transaction. All the pubkeys are remembered in a separate set and combined via MuSig-style [4] protocol to check the single 64-byte signature over txid in the end of the VM execution. In other words, signature aggregation is not optional for `signtx` (signatures over txid). Note: the `delegate` instruction permits arbitrary programs, so it uses one signature per program.


## What is different from Taproot/G'root

(1) No pure hash-based MAST: each time one peels off a layer of a tree, there's an ECC check which is more expensive than pure-hash merkle path check, but makes the design simpler and all ECC ops are batched alongside bulletproofs R1CS verification statement, making the performance difference unimportant.

(2) There is no designated blinding factor or a pubkey with the program commitment like in G'root. This is not something i'm particularly sure about, but will lay out the current rationale:
1. The happy-path one-time-key normally acts as a sufficient blinding factor for the program.
2. If the program needs a blinding factor, it can be embedded as a `<garbage> drop`.
3. The combo of "sign + programmatic constraints" is done by having instructions inside the program that wrap the value(s) in a transient contract with the required pubkey and leaving it on the stack.


## References

[1] https://github.com/interstellar/zkvm
[2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-January/015614.html
[3] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016249.html
[4] https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures/




