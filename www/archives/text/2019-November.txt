From riccardo.casatta at gmail.com  Wed Nov  6 16:52:06 2019
From: riccardo.casatta at gmail.com (Riccardo Casatta)
Date: Wed, 6 Nov 2019 17:52:06 +0100
Subject: [bitcoin-dev] Draft BIP for SNICKER
In-Reply-To: <mq_HOhcWf2T7ik9Em3nb5VCePi5cV17Wf_c8qS5zWwXh0vnJVzBO_q6Nl8RQBJysBOhZC2rjAw3hbq2tHIoEyTKE8QQaJgF9LpgpcP0Nl8g=@protonmail.com>
References: <YwZ3vq20LFvpx-nKn1RJjcRHwYTAVCC0v0EyD0y6zVMlQtKXUFNAaEk_QE2dzYDU6z2eK0S0TDXRPfl1_y93RgDjdCGboOgjcERBTLUPHao=@protonmail.com>
	<20191021000608.ajvzjxh6phtuhydp@ganymede>
	<clOIQUf5e2vT3KqKplQwrS5MgB8ptPDSQWkpOMGoAE3rS90i7y-8mNRmcecfVJwiYePhNYAfFlBYsOKqvavm4yVI-zEfo8pnG6AY_fiyMXs=@protonmail.com>
	<mq_HOhcWf2T7ik9Em3nb5VCePi5cV17Wf_c8qS5zWwXh0vnJVzBO_q6Nl8RQBJysBOhZC2rjAw3hbq2tHIoEyTKE8QQaJgF9LpgpcP0Nl8g=@protonmail.com>
Message-ID: <CADabwBAAstxX4ezm3B2sGcDWOcrJUNJ+wfPMY6ArWd4qSAkrLg@mail.gmail.com>

Hello Adam,

are you sure you can't tackle the watch-only issue?

What if the proposer create the coinjoin-tx, plus another tx (encrypted
with the shared secret) which is a 1 input-1 output (1to1) tx which spend
his output to another of his key.
At this point when the receiver accept the proposal tx he could create
other tx 1to1 which are spending his tweaked output to pure bip32 derived
key, he than broadcast together the coinjoin tx and for every output of the
coinjoin tx one other tx which is a 1to1 tx.

Notes:
* We are obviously spending more fee because there are more txs involved
but the receiver ends up having only bip32 derived outputs.
* The receiver must create the 1to1 tx or the receiver lose privacy by
being the only one to create 1to1 tx
* a good strategy could be to let the coinjoin tx have a very low fee,
while the 1to1 tx an higher one so there is less risk that only the
coinjoin gets mined
* Whit this spending strategy, the wallet initial scan does not need to be
modified


Il giorno mar 22 ott 2019 alle ore 15:29 AdamISZ via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> ha scritto:

> Just to chime in on these points:
>
> My discussions with ghost43 and ThomasV led me to the same conclusion, at
> least in general, for the whole watch-only issue:
>
> It's necessary that the key tweak (`c` as per draft BIP) be known by
> Proposer (because has to add it to transaction before signing) and Receiver
> (to check ownership), but must not be known by anyone else (else Coinjoin
> function fails), hence it can't be publically derivable in any way but must
> require information secret to the two parties. This can be a pure random
> sent along with the encrypted proposal (the original concept), or based on
> such, or implicit via ECDH (arubi's suggestion, now in the draft, requiring
> each party to access their own secret key). So I reached the same
> conclusion: the classic watch-only use case of monitoring a wallet in real
> time with no privkey access is incompatible with this.
>
> It's worth mentioning a nuance, however: distinguish two requirements: (1)
> to recover from zero information and (2) to monitor in real time as new
> SNICKER transactions arrive.
>
> For (2) it's interesting to observe that the tweak `c` is not a
> money-controlling secret; it's only a privacy-controlling secret. If you
> imagined two wallets, one hot and one cold, with the second tracking the
> first but having a lower security requirement because cold, then the `c`
> values could be sent along from the hot to the cold, as they are created,
> without changing the cold's security model as they are not
> money-controlling private keys. They should still be encrypted of course,
> but that's largely a technical detail, if they were exposed it would only
> break the effect of the coinjoin outputs being indistinguishable.
>
> For (1) the above does not apply; for there, we don't have anyone telling
> us what `c` values to look for, we have to somehow rederive, and to do that
> we need key access, so it reverts to the discussion above about whether it
> might be possible to interact with the cold wallet 'manually' so to speak.
>
> To be clear, I don't think either of the above paragraphs describe things
> that are particularly likely to be implemented, but the hot/cold monitoring
> is at least feasible, if there were enough desire for it.
>
> At the higher level, how important is this? I guess it just depends; there
> are similar problems (not identical, and perhaps more addressable?) in
> Lightning; importing keys is generally non-trivial; one can always sweep
> non-standard keys back into the HD tree, but clearly that is not really a
> solution in general; one can mark out wallets/seeds of this type as
> distinct; not all wallets need to have watch-only (phone wallets? small
> wallets? lower security?) one can prioritise spends of these coins. Etc.
>
> Some more general comments:
>
> Note Elichai's comment on the draft (repeated here for local convenience:
> https://gist.github.com/AdamISZ/2c13fb5819bd469ca318156e2cf25d79#gistcomment-3014924)
> about AES-GCM vs AES-CBC, any thoughts?
>
> I didn't discuss the security of the construction for a Receiver from a
> Proposer who should after all be assumed to be an attacker (except, I
> emphasised that PSBT parsing could be sensitive on this point); I hope it's
> clear to everyone that the construction Q = P + cG is only controllable by
> the owner of the discrete log of P (trivial reduction: if an attacker who
> knows c, can find the private key q of Q, he can derive the private key p
> of P as q - c, thus he is an ECDLP cracker).
>
> Thanks for all the comments so far, it's been very useful.
>
> AdamISZ/waxwing/Adam Gibson
>
> Sent with ProtonMail Secure Email.
>
> ??????? Original Message ???????
> On Monday, October 21, 2019 4:04 PM, SomberNight via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > > The SNICKER recovery process is, of course, only required for wallet
> >
> > recovery and not normal wallet use, so I don't think a small amount of
> > round-trip communication between the hot wallet and the cold wallet is
> > too much to ask---especially since anyone using SNICKER with a
> > watching-only wallet must be regularly interacting with their cold
> > wallet anyway to sign the coinjoins.
> >
> > What you described only considers the "initial setup" of a watch-only
> wallet. There are many usecases for watch-only wallets. There doesn't even
> necessarily need to be any offline-signing involved. For example, consider
> a user who has a hot wallet on their laptop with xprv; and wants to watch
> their addresses using an xpub from their mobile. Or consider giving an xpub
> to an accountant. Or giving an xpub to your Electrum Personal Server (which
> is how it works).
> >
> > Note that all these usecases require "on-going" discovery of addresses,
> and so they would break.
> >
> > ghost43
> >
> > (ps: Apologies Dave for the double-email; forgot to cc list originally)
> >
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>


-- 
Riccardo Casatta - @RCasatta <https://twitter.com/RCasatta>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191106/8c5a95bc/attachment.html>

From pieter.wuille at gmail.com  Thu Nov  7 22:35:42 2019
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Thu, 7 Nov 2019 14:35:42 -0800
Subject: [bitcoin-dev] Bech32 weakness and impact on bip-taproot addresses
Message-ID: <CAPg+sBjC-D2iWYywj_X-evQoWx56nb0YnASLVwCSCzWT6Guu3A@mail.gmail.com>

Hello all,

A while ago it was discovered that bech32 has a mutation weakness (see
https://github.com/sipa/bech32/issues/51 for details). Specifically,
when a bech32 string ends with a "p", inserting or erasing "q"s right
before that "p" does not invalidate it. While insertion/erasure
robustness was not an explicit goal (BCH codes in general only have
guarantees about substitution errors), this is very much not by
design, and this specific issue could have been made much less
impactful with a slightly different approach. I'm sorry it wasn't
caught earlier.

This has little effect on the security of P2WPKH/P2WSH addresses, as
those are only valid (per BIP173) for specific lengths (42 and 62
characters respectively). Inserting 20 consecutive "p"s in a typo
seems highly improbable.

I'm making this post because this property may unfortunately influence
design decisions around bip-taproot, as was brought up in the review
session (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-October/017427.html)
past tuesday. In the current draft, witness v1 outputs of length other
than 32 remain unencumbered, which means that for now such an
insertion or erasure would result in an output that can be spent by
anyone. If that is considered unacceptable, it could be prevented by
for example outlawing v1 witness outputs of length 31 and 33.

Thoughts?

Cheers,

-- 
Pieter

From gsanders87 at gmail.com  Thu Nov  7 22:45:02 2019
From: gsanders87 at gmail.com (Greg Sanders)
Date: Thu, 7 Nov 2019 17:45:02 -0500
Subject: [bitcoin-dev] Bech32 weakness and impact on bip-taproot
	addresses
In-Reply-To: <CAPg+sBjC-D2iWYywj_X-evQoWx56nb0YnASLVwCSCzWT6Guu3A@mail.gmail.com>
References: <CAPg+sBjC-D2iWYywj_X-evQoWx56nb0YnASLVwCSCzWT6Guu3A@mail.gmail.com>
Message-ID: <CAB3F3DsbPyqUutBNbVcHME0kGWsbTzTtb5tWV+zRERHwpibXBw@mail.gmail.com>

Could the softer touch of just making them non-standard apply as a future
preparation for an accepted softfork? Relaxations could easily be done
later if desired.

On Thu, Nov 7, 2019, 5:37 PM Pieter Wuille via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hello all,
>
> A while ago it was discovered that bech32 has a mutation weakness (see
> https://github.com/sipa/bech32/issues/51 for details). Specifically,
> when a bech32 string ends with a "p", inserting or erasing "q"s right
> before that "p" does not invalidate it. While insertion/erasure
> robustness was not an explicit goal (BCH codes in general only have
> guarantees about substitution errors), this is very much not by
> design, and this specific issue could have been made much less
> impactful with a slightly different approach. I'm sorry it wasn't
> caught earlier.
>
> This has little effect on the security of P2WPKH/P2WSH addresses, as
> those are only valid (per BIP173) for specific lengths (42 and 62
> characters respectively). Inserting 20 consecutive "p"s in a typo
> seems highly improbable.
>
> I'm making this post because this property may unfortunately influence
> design decisions around bip-taproot, as was brought up in the review
> session (
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-October/017427.html
> )
> past tuesday. In the current draft, witness v1 outputs of length other
> than 32 remain unencumbered, which means that for now such an
> insertion or erasure would result in an output that can be spent by
> anyone. If that is considered unacceptable, it could be prevented by
> for example outlawing v1 witness outputs of length 31 and 33.
>
> Thoughts?
>
> Cheers,
>
> --
> Pieter
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191107/ffd8acac/attachment.html>

From lf-lists at mattcorallo.com  Fri Nov  8 00:41:54 2019
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Thu, 7 Nov 2019 19:41:54 -0500
Subject: [bitcoin-dev] Bech32 weakness and impact on bip-taproot
	addresses
In-Reply-To: <CAB3F3DsbPyqUutBNbVcHME0kGWsbTzTtb5tWV+zRERHwpibXBw@mail.gmail.com>
References: <CAB3F3DsbPyqUutBNbVcHME0kGWsbTzTtb5tWV+zRERHwpibXBw@mail.gmail.com>
Message-ID: <701F6185-EB2C-4EB1-AAAA-1133879CF541@mattcorallo.com>

Given the issue is in the address format, not the consensus/standardness layer, it does seem somewhat strange to jump to addressing it with a consensus/standardness fix. Maybe the ship has sailed, but for the sake of considering all our options, we could also redefine bech32 to not allow such addresses.

Matt

>> On Nov 7, 2019, at 17:47, Greg Sanders via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> ?
> Could the softer touch of just making them non-standard apply as a future preparation for an accepted softfork? Relaxations could easily be done later if desired.
> 
>>> On Thu, Nov 7, 2019, 5:37 PM Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> Hello all,
>> 
>> A while ago it was discovered that bech32 has a mutation weakness (see
>> https://github.com/sipa/bech32/issues/51 for details). Specifically,
>> when a bech32 string ends with a "p", inserting or erasing "q"s right
>> before that "p" does not invalidate it. While insertion/erasure
>> robustness was not an explicit goal (BCH codes in general only have
>> guarantees about substitution errors), this is very much not by
>> design, and this specific issue could have been made much less
>> impactful with a slightly different approach. I'm sorry it wasn't
>> caught earlier.
>> 
>> This has little effect on the security of P2WPKH/P2WSH addresses, as
>> those are only valid (per BIP173) for specific lengths (42 and 62
>> characters respectively). Inserting 20 consecutive "p"s in a typo
>> seems highly improbable.
>> 
>> I'm making this post because this property may unfortunately influence
>> design decisions around bip-taproot, as was brought up in the review
>> session (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-October/017427.html)
>> past tuesday. In the current draft, witness v1 outputs of length other
>> than 32 remain unencumbered, which means that for now such an
>> insertion or erasure would result in an output that can be spent by
>> anyone. If that is considered unacceptable, it could be prevented by
>> for example outlawing v1 witness outputs of length 31 and 33.
>> 
>> Thoughts?
>> 
>> Cheers,
>> 
>> -- 
>> Pieter
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191107/37c1fe47/attachment.html>

From dave at dtrt.org  Fri Nov  8 02:15:41 2019
From: dave at dtrt.org (David A. Harding)
Date: Thu, 7 Nov 2019 16:15:41 -1000
Subject: [bitcoin-dev] Bech32 weakness and impact on bip-taproot
	addresses
In-Reply-To: <CAPg+sBjC-D2iWYywj_X-evQoWx56nb0YnASLVwCSCzWT6Guu3A@mail.gmail.com>
References: <CAPg+sBjC-D2iWYywj_X-evQoWx56nb0YnASLVwCSCzWT6Guu3A@mail.gmail.com>
Message-ID: <20191108021541.n3jk54vucplryrbl@ganymede>

On Thu, Nov 07, 2019 at 02:35:42PM -0800, Pieter Wuille via bitcoin-dev wrote:
> In the current draft, witness v1 outputs of length other
> than 32 remain unencumbered, which means that for now such an
> insertion or erasure would result in an output that can be spent by
> anyone. If that is considered unacceptable, it could be prevented by
> for example outlawing v1 witness outputs of length 31 and 33.

Either a consensus rule or a standardness rule[1] would require anyone
using a bech32 library supporting v1+ segwit to upgrade their library.
Otherwise, users of old libraries will still attempt to pay v1 witness
outputs of length 31 or 33, causing their transactions to get rejected
by newer nodes or get stuck on older nodes.  This is basically the
problem #15846[2] was meant to prevent.

If we're going to need everyone to upgrade their bech32 libraries
anyway, I think it's probably best that the problem is fixed in the
bech32 algorithm rather than at the consensus/standardness layer.

-Dave

[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-November/017444.html
[2] https://github.com/bitcoin/bitcoin/pull/15846

P.S. My thanks as well to the people who asked the question during
     review that lead to this discussion:

     http://www.erisian.com.au/meetbot/taproot-bip-review/2019/taproot-bip-review.2019-11-05-19.00.log.html#l-88

From eric at voskuil.org  Fri Nov  8 03:15:53 2019
From: eric at voskuil.org (Eric Voskuil)
Date: Fri, 8 Nov 2019 12:15:53 +0900
Subject: [bitcoin-dev] Bech32 weakness and impact on bip-taproot
	addresses
In-Reply-To: <20191108021541.n3jk54vucplryrbl@ganymede>
References: <20191108021541.n3jk54vucplryrbl@ganymede>
Message-ID: <FB218E84-0F03-4BDB-BB48-1EF45B44FDB9@voskuil.org>



> On Nov 8, 2019, at 11:16, David A. Harding via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> ?On Thu, Nov 07, 2019 at 02:35:42PM -0800, Pieter Wuille via bitcoin-dev wrote:
>> In the current draft, witness v1 outputs of length other
>> than 32 remain unencumbered, which means that for now such an
>> insertion or erasure would result in an output that can be spent by
>> anyone. If that is considered unacceptable, it could be prevented by
>> for example outlawing v1 witness outputs of length 31 and 33.
> 
> Either a consensus rule or a standardness rule[1] would require anyone
> using a bech32 library supporting v1+ segwit to upgrade their library.
> Otherwise, users of old libraries will still attempt to pay v1 witness
> outputs of length 31 or 33, causing their transactions to get rejected
> by newer nodes or get stuck on older nodes.  This is basically the
> problem #15846[2] was meant to prevent.
> 
> If we're going to need everyone to upgrade their bech32 libraries
> anyway, I think it's probably best that the problem is fixed in the
> bech32 algorithm rather than at the consensus/standardness layer.

As an implementer of both the address encoding and script validation, I agree.

e

> -Dave
> 
> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-November/017444.html
> [2] https://github.com/bitcoin/bitcoin/pull/15846
> 
> P.S. My thanks as well to the people who asked the question during
>     review that lead to this discussion:
> 
>     http://www.erisian.com.au/meetbot/taproot-bip-review/2019/taproot-bip-review.2019-11-05-19.00.log.html#l-88
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From ZmnSCPxj at protonmail.com  Fri Nov  8 05:11:53 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 08 Nov 2019 05:11:53 +0000
Subject: [bitcoin-dev] Bech32 weakness and impact on bip-taproot
	addresses
In-Reply-To: <CAPg+sBjC-D2iWYywj_X-evQoWx56nb0YnASLVwCSCzWT6Guu3A@mail.gmail.com>
References: <CAPg+sBjC-D2iWYywj_X-evQoWx56nb0YnASLVwCSCzWT6Guu3A@mail.gmail.com>
Message-ID: <sZtrFEIbPoH5v6IpNboec9kgSui-E8QLHllL3u3TgB42iRU3zkzi6cJuGTqUp1-9MMp0kURGuMRCmBv9AC6e9RPmMZpGVSAr0-HSRfyfhzM=@protonmail.com>

Good morning Pieter, and all,

Can we modify Bech32 SegWit address format for version 1 and above as below?

      * The data-part values:
      ** 1 byte: the witness version
    + ** If the witness version is non-zero, 1 byte: the length of the witness program.
      ** A conversion of the 2-to-40-byte witness program (as defined by [https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki BIP141]) to base32:
      *** Start with the bits of the witness program, most significant bit per byte first.
      *** Re-arrange those bits into groups of 5, and pad with zeroes at the end if needed.
      *** Translate those bits to characters using the table above.

This retains the ability of a bech32 address to specify any valid witness length and allows future version 1 addresses with lengths other than 32, while closing this malleation.

Older software being given the modified v1 address format would mis-send it to the wrong witness program, however.

Alternately we could just keep using version 0 in the address format forever.
The requirement would be to ensure that SegWit vN (N >= 1) output witness programs would have a data-part value encoded as below:

    * The data-part values:
    ** 1 byte: legacy witness version, which must always be 0.
    ** 1 byte: actual witness version, which must be non-zero.
    ** 1 byte: padding length: 0 or 1.
    ** If padding length is 1, 1 byte: padding, which must be 0.
    ** 1 byte: witness program length.
    ** variable: witness program.

A writer for a v1 or later address would initially set an empty padding, then compute:

      1 // actual witness version
    + 1 // padding length
    + 1 // witness length
    + witness_length

If the above sum is 20 or 32, then the writer selects a non-zero padding and inserts the padding byte so that the above sum is now 21 or 33.

To a reader that understands only bech32 v0, such an encoding would look like a SegWit v0 invalid-program-length, and be rejected.
A reader which understands the above protocol would, instead of rejecting a SegWit v0 invalid-program-length, instead attempt to parse it as above first, and consider it as SegWit v1 or higher if it was parsed correctly as above.

The above proposal is of course ridiculous and I am now currently running diagnostics on my processing units to see if further glitches occur in test reasoning skills.

Regards,
ZmnSCPxj

From roconnor at blockstream.io  Fri Nov  8 13:03:52 2019
From: roconnor at blockstream.io (Russell O'Connor)
Date: Fri, 8 Nov 2019 08:03:52 -0500
Subject: [bitcoin-dev] Bech32 weakness and impact on bip-taproot
	addresses
In-Reply-To: <sZtrFEIbPoH5v6IpNboec9kgSui-E8QLHllL3u3TgB42iRU3zkzi6cJuGTqUp1-9MMp0kURGuMRCmBv9AC6e9RPmMZpGVSAr0-HSRfyfhzM=@protonmail.com>
References: <CAPg+sBjC-D2iWYywj_X-evQoWx56nb0YnASLVwCSCzWT6Guu3A@mail.gmail.com>
	<sZtrFEIbPoH5v6IpNboec9kgSui-E8QLHllL3u3TgB42iRU3zkzi6cJuGTqUp1-9MMp0kURGuMRCmBv9AC6e9RPmMZpGVSAr0-HSRfyfhzM=@protonmail.com>
Message-ID: <CAMZUoK=QFPAzZzxFOA6ZYez_dwCTi_OxYup19w32suDvBdXJoQ@mail.gmail.com>

I do like the idea of length prefixing the witness program.  I will note
that the 1 byte witness version is really more like a 1 character witness
version.  There are 17 different segwit versions and there are 32
characters in the bech32 alphabet.  That leaves 15 unused characters that
we can use for assigning new meanings too.

That said, it is probably most sensible to define a new
human-readable-prefix for length prefixed bitcoin witness programs.  "btc1"
anyone?

On Fri, Nov 8, 2019 at 12:12 AM ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Good morning Pieter, and all,
>
> Can we modify Bech32 SegWit address format for version 1 and above as
> below?
>
>       * The data-part values:
>       ** 1 byte: the witness version
>     + ** If the witness version is non-zero, 1 byte: the length of the
> witness program.
>       ** A conversion of the 2-to-40-byte witness program (as defined by [
> https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki BIP141])
> to base32:
>       *** Start with the bits of the witness program, most significant bit
> per byte first.
>       *** Re-arrange those bits into groups of 5, and pad with zeroes at
> the end if needed.
>       *** Translate those bits to characters using the table above.
>
> This retains the ability of a bech32 address to specify any valid witness
> length and allows future version 1 addresses with lengths other than 32,
> while closing this malleation.
>
> Older software being given the modified v1 address format would mis-send
> it to the wrong witness program, however.
>
> Alternately we could just keep using version 0 in the address format
> forever.
> The requirement would be to ensure that SegWit vN (N >= 1) output witness
> programs would have a data-part value encoded as below:
>
>     * The data-part values:
>     ** 1 byte: legacy witness version, which must always be 0.
>     ** 1 byte: actual witness version, which must be non-zero.
>     ** 1 byte: padding length: 0 or 1.
>     ** If padding length is 1, 1 byte: padding, which must be 0.
>     ** 1 byte: witness program length.
>     ** variable: witness program.
>
> A writer for a v1 or later address would initially set an empty padding,
> then compute:
>
>       1 // actual witness version
>     + 1 // padding length
>     + 1 // witness length
>     + witness_length
>
> If the above sum is 20 or 32, then the writer selects a non-zero padding
> and inserts the padding byte so that the above sum is now 21 or 33.
>
> To a reader that understands only bech32 v0, such an encoding would look
> like a SegWit v0 invalid-program-length, and be rejected.
> A reader which understands the above protocol would, instead of rejecting
> a SegWit v0 invalid-program-length, instead attempt to parse it as above
> first, and consider it as SegWit v1 or higher if it was parsed correctly as
> above.
>
> The above proposal is of course ridiculous and I am now currently running
> diagnostics on my processing units to see if further glitches occur in test
> reasoning skills.
>
> Regards,
> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191108/7280da70/attachment.html>

From btc at meedamian.com  Fri Nov  8 13:42:13 2019
From: btc at meedamian.com (Damian Mee)
Date: Fri, 8 Nov 2019 14:42:13 +0100
Subject: [bitcoin-dev] Bech32 weakness and impact on bip-taproot
	addresses
In-Reply-To: <CAMZUoK=QFPAzZzxFOA6ZYez_dwCTi_OxYup19w32suDvBdXJoQ@mail.gmail.com>
References: <CAPg+sBjC-D2iWYywj_X-evQoWx56nb0YnASLVwCSCzWT6Guu3A@mail.gmail.com>
	<sZtrFEIbPoH5v6IpNboec9kgSui-E8QLHllL3u3TgB42iRU3zkzi6cJuGTqUp1-9MMp0kURGuMRCmBv9AC6e9RPmMZpGVSAr0-HSRfyfhzM=@protonmail.com>
	<CAMZUoK=QFPAzZzxFOA6ZYez_dwCTi_OxYup19w32suDvBdXJoQ@mail.gmail.com>
Message-ID: <CANeGfAeOK3bC+NkAtYaT-6XVmi8_200rU_=Jv7OszEGdkXN85g@mail.gmail.com>

> a new human-readable-prefix for length prefixed bitcoin witness
programs.  "btc1" anyone?

Yes, please!

On Fri, Nov 8, 2019 at 2:04 PM Russell O'Connor via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I do like the idea of length prefixing the witness program.  I will note
> that the 1 byte witness version is really more like a 1 character witness
> version.  There are 17 different segwit versions and there are 32
> characters in the bech32 alphabet.  That leaves 15 unused characters that
> we can use for assigning new meanings too.
>
> That said, it is probably most sensible to define a new
> human-readable-prefix for length prefixed bitcoin witness programs.  "btc1"
> anyone?
>
> On Fri, Nov 8, 2019 at 12:12 AM ZmnSCPxj via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Good morning Pieter, and all,
>>
>> Can we modify Bech32 SegWit address format for version 1 and above as
>> below?
>>
>>       * The data-part values:
>>       ** 1 byte: the witness version
>>     + ** If the witness version is non-zero, 1 byte: the length of the
>> witness program.
>>       ** A conversion of the 2-to-40-byte witness program (as defined by [
>> https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki BIP141])
>> to base32:
>>       *** Start with the bits of the witness program, most significant
>> bit per byte first.
>>       *** Re-arrange those bits into groups of 5, and pad with zeroes at
>> the end if needed.
>>       *** Translate those bits to characters using the table above.
>>
>> This retains the ability of a bech32 address to specify any valid witness
>> length and allows future version 1 addresses with lengths other than 32,
>> while closing this malleation.
>>
>> Older software being given the modified v1 address format would mis-send
>> it to the wrong witness program, however.
>>
>> Alternately we could just keep using version 0 in the address format
>> forever.
>> The requirement would be to ensure that SegWit vN (N >= 1) output witness
>> programs would have a data-part value encoded as below:
>>
>>     * The data-part values:
>>     ** 1 byte: legacy witness version, which must always be 0.
>>     ** 1 byte: actual witness version, which must be non-zero.
>>     ** 1 byte: padding length: 0 or 1.
>>     ** If padding length is 1, 1 byte: padding, which must be 0.
>>     ** 1 byte: witness program length.
>>     ** variable: witness program.
>>
>> A writer for a v1 or later address would initially set an empty padding,
>> then compute:
>>
>>       1 // actual witness version
>>     + 1 // padding length
>>     + 1 // witness length
>>     + witness_length
>>
>> If the above sum is 20 or 32, then the writer selects a non-zero padding
>> and inserts the padding byte so that the above sum is now 21 or 33.
>>
>> To a reader that understands only bech32 v0, such an encoding would look
>> like a SegWit v0 invalid-program-length, and be rejected.
>> A reader which understands the above protocol would, instead of rejecting
>> a SegWit v0 invalid-program-length, instead attempt to parse it as above
>> first, and consider it as SegWit v1 or higher if it was parsed correctly as
>> above.
>>
>> The above proposal is of course ridiculous and I am now currently running
>> diagnostics on my processing units to see if further glitches occur in test
>> reasoning skills.
>>
>> Regards,
>> ZmnSCPxj
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191108/e3ee321a/attachment.html>

From gurvy51 at gmail.com  Thu Nov  7 03:33:36 2019
From: gurvy51 at gmail.com (Trevor Groves)
Date: Wed, 6 Nov 2019 20:33:36 -0700
Subject: [bitcoin-dev] Dynamic MaxBlockSize - 3 Byte Solution
Message-ID: <CAN+Of7A9pmrhEma49cQ0eP7vn50WxFemAEvztFxhgX2om_8Dpw@mail.gmail.com>

Dynamic MaxBlockSize  - 3 Byte Solution
"DMBS"

If
(Last TOTAL Block Trans fees)  >  (AVG (Last 100 Blocks Trans Fees))
AND
current MaxBlockSize  => 0.99 MB
AND
MaxBlockSize has not changed in 10 Blocks
** see error catch below
Then
ON (Current Block #  + 9)  Set MaxBlockSize  = (MaxBlockSize x 1.1)
ELSE
AT (Current Block #  + 9)  Set MaxBlockSize  = (MaxBlockSize  / 1.1)
ELSEIF
(current MaxBlockSize  =< 0.99  or current MaxBlockSize > 6553.5 MB)
Null (no action taken)
**where 9 above represents the ActivateONBlock (software side) Variable
 -------------
We add this 3 Byte Variable Factor to the white space in the Current Block.

eg.  this 3 byte HEX    19000A
the first bit "1"  can be 1,2 or 0
1  =  increase future block (9 blocks ahead)
2  decrease future block  (9 blocks ahead)
0    No Action (rules evaluate to null)
**where 9 above represents the ActivateONBlock (software side) Variable
--------------
The Second bit is a Global Variable "9" represents a countdown to the set
value action, placed to synchronize network forward  changes in "x" blocks.
software lowers value if evaluates to True a second time  and so on.
("Count down" if you will)
the last 2 bytes represent  the globally accepted "MaxBlockSize" Variable,
and is distributed within each block moving forward in this rightmost (2
byte) factor.  In this case above,
The variable portion  "000A" (32 Bit value) represents decimal value 10
being 1.0 MB block.
the decimal place is Always Assumed, and must be hard coded
Because this presents a  theoretical  Max limit of "FFFF"  or 6553.5 MB, We
would
have to add a last rule "only as a error catch"
 ** AND IF MaxBlockSize < 6553.5
---
Increasing and decreasing
On Every Block mined or distributed, the software can run the above rule
set, Change the Variable and Distribute the next block " In Synchronized
fashion". The above rules when combined evaluate to a YES or NO, This
translates to a market reflection of increased system pressure or decreased
market pressure.   I think we can agree, at peak periods the system chokes
itself off with fees and this is always only temporarily.  So we can have
the block, analyse system demand dynamically, and adjust on a globally
agreed rule dynamically by market driven demand.
Considering the ruleset above also Decreases  the Block ONLY if its greater
than 0.99mb this brings size back to a competitive state /and size once
market demand pressures subside, yet achieves the smallest market feasible
block size while also maintaining all current rule sets.
 An attacker would have to affect all block fees over the last 16 hours
worth of transactions to affect a 10% max block size increase but then only
after waiting 1.5 hours, so long as nothing has changed in the last 1.5
hours and only for a limited amount of time. This approach also limits
bloat. This safety block window of 9 blocks provides a look forward and
look behind value, in turn provides the network time to synchronize.
10 block sync window.  This, by design, also limits changes to one change
every 3 hours (20 blocks), if there is a market pressure "STATE" occurring.
My Question to the community is. Will our current Block accommodate the 3
Byte
Variable, Is solving the Scaling issue worth using the 3 Bytes of space?
I believe it is.
--
Software,  Will need  to Evaluate MaxBlockSize Variable, and
ActivateONBlock Variable from the most recent distributed blocks DMBS  3
byte value.
Run the rules , get the answer set the now known MaxBlockSize Var and
Propegate the "DMBS" value.

As capacity limits are breached, I think the majority agree "we need to
agree".

MaxBlockSize would provide a suitable middle ground and address concerns in
a dynamic fashion, without compromising  or changing  existing security.
 Examples reflected in the blockchain 19000A   rules has evaluates to
true, increase expected in 9 blocks.1.0mb increases to 1.1mb
if true for 9 more blocks  MaxBlockSize Var becomes  18000A..
17000A..,16000A ..and so on if  still true at 10000A var written becomes
00000B when read from left to right,  0-no change, in 0 blocks current "
DMBS" value 000B or 1.1MB  and stays that way  00000B until MaxBlockSize
evaluates to "True" under a market pressure/ relief situation.
I hope this makes sense, I would appreciate some feedback.
TG
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191106/ec280d20/attachment-0001.html>

From me at emilengler.com  Fri Nov  8 14:36:52 2019
From: me at emilengler.com (Emil Engler)
Date: Fri, 8 Nov 2019 15:36:52 +0100
Subject: [bitcoin-dev] Dynamic MaxBlockSize - 3 Byte Solution
In-Reply-To: <CAN+Of7A9pmrhEma49cQ0eP7vn50WxFemAEvztFxhgX2om_8Dpw@mail.gmail.com>
References: <CAN+Of7A9pmrhEma49cQ0eP7vn50WxFemAEvztFxhgX2om_8Dpw@mail.gmail.com>
Message-ID: <CAL6iL8VwYVpFkZuExpk=7LKGTLxVdQODtZmHnaK4MR0J9McdVQ@mail.gmail.com>

NACK!
1. We have Lightning and SegWit so thankfully we do not need to deal with
blocksizes anymore really.
2. What if a reorg happens? Then it could generate huge problems at the
validation.

Correct me if I understood it wrong please.

Greetings,
Emil Engler

Trevor Groves via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
schrieb am Fr. 8. Nov. 2019 um 15:26:

> Dynamic MaxBlockSize  - 3 Byte Solution
> "DMBS"
>
> If
> (Last TOTAL Block Trans fees)  >  (AVG (Last 100 Blocks Trans Fees))
> AND
> current MaxBlockSize  => 0.99 MB
> AND
> MaxBlockSize has not changed in 10 Blocks
> ** see error catch below
> Then
> ON (Current Block #  + 9)  Set MaxBlockSize  = (MaxBlockSize x 1.1)
> ELSE
> AT (Current Block #  + 9)  Set MaxBlockSize  = (MaxBlockSize  / 1.1)
> ELSEIF
> (current MaxBlockSize  =< 0.99  or current MaxBlockSize > 6553.5 MB)
> Null (no action taken)
> **where 9 above represents the ActivateONBlock (software side) Variable
>  -------------
> We add this 3 Byte Variable Factor to the white space in the Current Block.
>
> eg.  this 3 byte HEX    19000A
> the first bit "1"  can be 1,2 or 0
> 1  =  increase future block (9 blocks ahead)
> 2  decrease future block  (9 blocks ahead)
> 0    No Action (rules evaluate to null)
> **where 9 above represents the ActivateONBlock (software side) Variable
> --------------
> The Second bit is a Global Variable "9" represents a countdown to the set
> value action, placed to synchronize network forward  changes in "x" blocks.
> software lowers value if evaluates to True a second time  and so on.
> ("Count down" if you will)
> the last 2 bytes represent  the globally accepted "MaxBlockSize" Variable,
> and is distributed within each block moving forward in this rightmost (2
> byte) factor.  In this case above,
> The variable portion  "000A" (32 Bit value) represents decimal value 10
> being 1.0 MB block.
> the decimal place is Always Assumed, and must be hard coded
> Because this presents a  theoretical  Max limit of "FFFF"  or 6553.5 MB,
> We would
> have to add a last rule "only as a error catch"
>  ** AND IF MaxBlockSize < 6553.5
> ---
> Increasing and decreasing
> On Every Block mined or distributed, the software can run the above rule
> set, Change the Variable and Distribute the next block " In Synchronized
> fashion". The above rules when combined evaluate to a YES or NO, This
> translates to a market reflection of increased system pressure or decreased
> market pressure.   I think we can agree, at peak periods the system chokes
> itself off with fees and this is always only temporarily.  So we can have
> the block, analyse system demand dynamically, and adjust on a globally
> agreed rule dynamically by market driven demand.
> Considering the ruleset above also Decreases  the Block ONLY if its
> greater than 0.99mb this brings size back to a competitive state /and size
> once market demand pressures subside, yet achieves the smallest market
> feasible block size while also maintaining all current rule sets.
>  An attacker would have to affect all block fees over the last 16 hours
> worth of transactions to affect a 10% max block size increase but then only
> after waiting 1.5 hours, so long as nothing has changed in the last 1.5
> hours and only for a limited amount of time. This approach also limits
> bloat. This safety block window of 9 blocks provides a look forward and
> look behind value, in turn provides the network time to synchronize.
> 10 block sync window.  This, by design, also limits changes to one change
> every 3 hours (20 blocks), if there is a market pressure "STATE" occurring.
> My Question to the community is. Will our current Block accommodate the 3
> Byte
> Variable, Is solving the Scaling issue worth using the 3 Bytes of space?
> I believe it is.
> --
> Software,  Will need  to Evaluate MaxBlockSize Variable, and
> ActivateONBlock Variable from the most recent distributed blocks DMBS  3
> byte value.
> Run the rules , get the answer set the now known MaxBlockSize Var and
> Propegate the "DMBS" value.
>
> As capacity limits are breached, I think the majority agree "we need to
> agree".
>
> MaxBlockSize would provide a suitable middle ground and address concerns
> in a dynamic fashion, without compromising  or changing  existing
> security.
>  Examples reflected in the blockchain 19000A   rules has evaluates to
> true, increase expected in 9 blocks.1.0mb increases to 1.1mb
> if true for 9 more blocks  MaxBlockSize Var becomes  18000A..
> 17000A..,16000A ..and so on if  still true at 10000A var written becomes
> 00000B when read from left to right,  0-no change, in 0 blocks current "
> DMBS" value 000B or 1.1MB  and stays that way  00000B until MaxBlockSize
> evaluates to "True" under a market pressure/ relief situation.
> I hope this makes sense, I would appreciate some feedback.
> TG
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191108/788a634f/attachment.html>

From luke at dashjr.org  Fri Nov  8 15:07:36 2019
From: luke at dashjr.org (Luke Dashjr)
Date: Fri, 8 Nov 2019 15:07:36 +0000
Subject: [bitcoin-dev] CVE-2017-18350 disclosure
Message-ID: <201911081507.40441.luke@dashjr.org>

CVE-2017-18350 is a buffer overflow vulnerability which allows a malicious 
SOCKS proxy server to overwrite the program stack on systems with a signed 
`char` type (including common 32-bit and 64-bit x86 PCs).

The vulnerability was introduced in 60a87bce873ce1f76a80b7b8546e83a0cd4e07a5 
(SOCKS5 support) and first released in Bitcoin Core v0.7.0rc1 in 2012 Aug 27.
A fix was hidden in d90a00eabed0f3f1acea4834ad489484d0012372 ("Improve and 
document SOCKS code") released in v0.15.1, 2017 Nov 6.

To be vulnerable, the node must be configured to use such a malicious proxy in 
the first place. Note that using *any* proxy over an insecure network (such 
as the Internet) is potentially a vulnerability since the connection could be 
intercepted for such a purpose.

Upon a connection request from the node, the malicious proxy would respond 
with an acknowledgement of a different target domain name than the one
requested. Normally this acknowledgement is entirely ignored, but if the 
length uses the high bit (ie, a length 128-255 inclusive), it will be 
interpreted by vulnerable versions as a negative number instead. When the 
negative number is passed to the recv() system call to read the domain name, 
it is converted back to an unsigned/positive number, but at a much wider size 
(typically 32-bit), resulting in an effectively infinite read into and beyond 
the 256-byte dummy stack buffer.

To fix this vulnerability, the dummy buffer was changed to an explicitly 
unsigned data type, avoiding the conversion to/from a negative number.

Credit goes to practicalswift (https://twitter.com/practicalswift) for 
discovering and providing the initial fix for the vulnerability, and Wladimir 
J. van der Laan for a disguised version of the fix as well as general cleanup 
to the at-risk code.

Timeline:
- 2012-04-01: Vulnerability introduced in PR #1141.
- 2012-05-08: Vulnerability merged to master git repository.
- 2012-08-27: Vulnerability published in v0.7.0rc1.
- 2012-09-17: Vulnerability released in v0.7.0.
...
- 2017-09-21: practicalswift discloses vulnerability to security team.
- 2017-09-23: Wladimir opens PR #11397 to quietly fix vulernability.
- 2017-09-27: Fix merged to master git repository.
- 2017-10-18: Fix merged to 0.15 git repository.
- 2017-11-04: Fix published in v0.15.1rc1.
- 2017-11-09: Fix released in v0.15.1.
...
- 2019-06-22: Vulnerability existence disclosed to bitcoin-dev ML.
- 2019-11-08: Vulnerability details disclosure to bitcoin-dev ML.

From joachimstr at protonmail.com  Fri Nov  8 15:19:17 2019
From: joachimstr at protonmail.com (=?UTF-8?Q?Joachim_Str=C3=B6mbergson?=)
Date: Fri, 08 Nov 2019 15:19:17 +0000
Subject: [bitcoin-dev] Dynamic MaxBlockSize - 3 Byte Solution
In-Reply-To: <CAL6iL8VwYVpFkZuExpk=7LKGTLxVdQODtZmHnaK4MR0J9McdVQ@mail.gmail.com>
References: <CAN+Of7A9pmrhEma49cQ0eP7vn50WxFemAEvztFxhgX2om_8Dpw@mail.gmail.com>
	<CAL6iL8VwYVpFkZuExpk=7LKGTLxVdQODtZmHnaK4MR0J9McdVQ@mail.gmail.com>
Message-ID: <gL39Si8vPw6SjouvjkN016eQD9ZybpO1Yf2kvaF11SKU3ECl9JFBr_RXR_BVDiqEu3yVnwKzgxlathhoMg5khGQQbiM0ExasjQQ3QYkOugw=@protonmail.com>

While I agree on NACKing the proposal as it does not add anything new and fundamentally misunderstands what scaling is (or is not in this case), I disagree with the claim that we do not need to deal with block size issue in the future any more. Segwit increased our possibilities on how to use the space more efficiently, but so far it did not completely. It's yet to be seen if advanced offchain constructions such as channel factories are enough. At this moment to claim that would be very bold and hardly justified.

Sent with [ProtonMail](https://protonmail.com) Secure Email.

??????? Original Message ???????
On Friday, November 8, 2019 2:36 PM, Emil Engler via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> NACK!
> 1. We have Lightning and SegWit so thankfully we do not need to deal with blocksizes anymore really.
> 2. What if a reorg happens? Then it could generate huge problems at the validation.
>
> Correct me if I understood it wrong please.
>
> Greetings,
> Emil Engler
>
> Trevor Groves via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> schrieb am Fr. 8. Nov. 2019 um 15:26:
>
>> Dynamic MaxBlockSize  - 3 Byte Solution
>> "DMBS"
>>
>> If
>> (Last TOTAL Block Trans fees)  >  (AVG (Last 100 Blocks Trans Fees))
>> AND
>> current MaxBlockSize  => 0.99 MB
>> AND
>> MaxBlockSize has not changed in 10 Blocks
>> ** see error catch below
>> Then
>> ON (Current Block #  + 9)  Set MaxBlockSize  = (MaxBlockSize x 1.1)
>> ELSE
>> AT (Current Block #  + 9)  Set MaxBlockSize  = (MaxBlockSize  / 1.1)
>> ELSEIF
>> (current MaxBlockSize  =< 0.99  or current MaxBlockSize > 6553.5 MB)
>> Null (no action taken)
>> **where 9 above represents the ActivateONBlock (software side) Variable
>>  -------------
>> We add this 3 Byte Variable Factor to the white space in the Current Block.
>>
>> eg.  this 3 byte HEX    19000A
>> the first bit "1"  can be 1,2 or 0
>> 1  =  increase future block (9 blocks ahead)
>> 2  decrease future block  (9 blocks ahead)
>> 0    No Action (rules evaluate to null)
>> **where 9 above represents the ActivateONBlock (software side) Variable
>> --------------
>> The Second bit is a Global Variable "9" represents a countdown to the set value action, placed to synchronize network forward  changes in "x" blocks. software lowers value if evaluates to True a second time  and so on.
>> ("Count down" if you will)
>> the last 2 bytes represent  the globally accepted "MaxBlockSize" Variable, and is distributed within each block moving forward in this rightmost (2 byte) factor.  In this case above,
>> The variable portion  "000A" (32 Bit value) represents decimal value 10 being 1.0 MB block.
>> the decimal place is Always Assumed, and must be hard coded
>> Because this presents a  theoretical  Max limit of "FFFF"  or 6553.5 MB, We would
>> have to add a last rule "only as a error catch"
>>  ** AND IF MaxBlockSize < 6553.5
>> ---
>> Increasing and decreasing
>> On Every Block mined or distributed, the software can run the above rule set, Change the Variable and Distribute the next block " In Synchronized fashion". The above rules when combined evaluate to a YES or NO, This translates to a market reflection of increased system pressure or decreased market pressure.   I think we can agree, at peak periods the system chokes itself off with fees and this is always only temporarily.  So we can have the block, analyse system demand dynamically, and adjust on a globally agreed rule dynamically by market driven demand.
>> Considering the ruleset above also Decreases  the Block ONLY if its greater than 0.99mb this brings size back to a competitive state /and size once market demand pressures subside, yet achieves the smallest market feasible block size while also maintaining all current rule sets.
>>  An attacker would have to affect all block fees over the last 16 hours worth of transactions to affect a 10% max block size increase but then only after waiting 1.5 hours, so long as nothing has changed in the last 1.5 hours and only for a limited amount of time. This approach also limits bloat. This safety block window of 9 blocks provides a look forward and look behind value, in turn provides the network time to synchronize.
>> 10 block sync window.  This, by design, also limits changes to one change  every 3 hours (20 blocks), if there is a market pressure "STATE" occurring.
>> My Question to the community is. Will our current Block accommodate the 3 Byte
>> Variable, Is solving the Scaling issue worth using the 3 Bytes of space?
>> I believe it is.
>> --
>> Software,  Will need  to Evaluate MaxBlockSize Variable, and ActivateONBlock Variable from the most recent distributed blocks DMBS  3 byte value.
>> Run the rules , get the answer set the now known MaxBlockSize Var and Propegate the "DMBS" value.
>>
>> As capacity limits are breached, I think the majority agree "we need to agree".
>>
>> MaxBlockSize would provide a suitable middle ground and address concerns in a dynamic fashion, without compromising  or changing  existing security.
>>  Examples reflected in the blockchain 19000A   rules has evaluates to  true, increase expected in 9 blocks.1.0mb increases to 1.1mb
>> if true for 9 more blocks  MaxBlockSize Var becomes  18000A.. 17000A..,16000A ..and so on if  still true at 10000A var written becomes
>> 00000B when read from left to right,  0-no change, in 0 blocks current " DMBS" value 000B or 1.1MB  and stays that way  00000B until MaxBlockSize  evaluates to "True" under a market pressure/ relief situation.
>> I hope this makes sense, I would appreciate some feedback.
>> TG
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191108/d63a8de2/attachment-0001.html>

From aaldave at gmail.com  Fri Nov  8 17:04:20 2019
From: aaldave at gmail.com (Alberto Aldave)
Date: Fri, 8 Nov 2019 18:04:20 +0100
Subject: [bitcoin-dev] Dynamic MaxBlockSize - 3 Byte Solution
In-Reply-To: <gL39Si8vPw6SjouvjkN016eQD9ZybpO1Yf2kvaF11SKU3ECl9JFBr_RXR_BVDiqEu3yVnwKzgxlathhoMg5khGQQbiM0ExasjQQ3QYkOugw=@protonmail.com>
References: <gL39Si8vPw6SjouvjkN016eQD9ZybpO1Yf2kvaF11SKU3ECl9JFBr_RXR_BVDiqEu3yVnwKzgxlathhoMg5khGQQbiM0ExasjQQ3QYkOugw=@protonmail.com>
Message-ID: <8C273BE4-CF45-46D5-97F6-7E7AD0C9D365@gmail.com>

NACK

1.- At some point in time, fees will need to be the the main part of the reward of miners, so, I do not see any need to lower them. If we keep them forever low, the network will be less and less secure because of the halvings.
2.- I think this change involves a Hard Fork (please correct me if I am wrong). In my opinion, the risk of a HF is not worth it.
3.- And more important for me, If blocks get bigger and bigger it would hurt decentralization which is absolutely key for Bitcoin to be valuable.

Alberto


> El 8 nov 2019, a las 16:54, Joachim Str?mbergson via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> escribi?:
> 
> ?
> While I agree on NACKing the proposal as it does not add anything new and fundamentally misunderstands what scaling is (or is not in this case), I disagree with the claim that we do not need to deal with block size issue in the future any more. Segwit increased our possibilities on how to use the space more efficiently, but so far it did not completely. It's yet to be seen if advanced offchain constructions such as channel factories are enough. At this moment to claim that would be very bold and hardly justified.
> 
> 
> Sent with ProtonMail Secure Email.
> 
> ??????? Original Message ???????
>> On Friday, November 8, 2019 2:36 PM, Emil Engler via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> 
>> NACK!
>> 1. We have Lightning and SegWit so thankfully we do not need to deal with blocksizes anymore really.
>> 2. What if a reorg happens? Then it could generate huge problems at the validation.
>> 
>> Correct me if I understood it wrong please.
>> 
>> Greetings,
>> Emil Engler
>> 
>> Trevor Groves via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> schrieb am Fr. 8. Nov. 2019 um 15:26:
>>> Dynamic MaxBlockSize  - 3 Byte Solution
>>> "DMBS"
>>> 
>>> If 
>>> (Last TOTAL Block Trans fees)  >  (AVG (Last 100 Blocks Trans Fees))
>>> AND
>>> current MaxBlockSize  => 0.99 MB  
>>> AND 
>>> MaxBlockSize has not changed in 10 Blocks
>>> ** see error catch below
>>> Then  
>>> ON (Current Block #  + 9)  Set MaxBlockSize  = (MaxBlockSize x 1.1)
>>> ELSE  
>>> AT (Current Block #  + 9)  Set MaxBlockSize  = (MaxBlockSize  / 1.1)
>>> ELSEIF 
>>> (current MaxBlockSize  =< 0.99  or current MaxBlockSize > 6553.5 MB)
>>> Null (no action taken)
>>> **where 9 above represents the ActivateONBlock (software side) Variable
>>>  -------------
>>> We add this 3 Byte Variable Factor to the white space in the Current Block.
>>> 
>>> eg.  this 3 byte HEX    19000A
>>> the first bit "1"  can be 1,2 or 0    
>>> 1  =  increase future block (9 blocks ahead)
>>> 2  decrease future block  (9 blocks ahead)
>>> 0    No Action (rules evaluate to null)
>>> **where 9 above represents the ActivateONBlock (software side) Variable
>>> --------------
>>> The Second bit is a Global Variable "9" represents a countdown to the set value action, placed to synchronize network forward  changes in "x" blocks. software lowers value if evaluates to True a second time  and so on. 
>>> ("Count down" if you will)
>>> the last 2 bytes represent  the globally accepted "MaxBlockSize" Variable, and is distributed within each block moving forward in this rightmost (2 byte) factor.  In this case above,
>>> The variable portion  "000A" (32 Bit value) represents decimal value 10 being 1.0 MB block.
>>> the decimal place is Always Assumed, and must be hard coded 
>>> Because this presents a  theoretical  Max limit of "FFFF"  or 6553.5 MB, We would 
>>> have to add a last rule "only as a error catch"
>>>  ** AND IF MaxBlockSize < 6553.5 
>>> ---
>>> Increasing and decreasing
>>> On Every Block mined or distributed, the software can run the above rule set, Change the Variable and Distribute the next block " In Synchronized fashion". The above rules when combined evaluate to a YES or NO, This translates to a market reflection of increased system pressure or decreased market pressure.   I think we can agree, at peak periods the system chokes itself off with fees and this is always only temporarily.  So we can have the block, analyse system demand dynamically, and adjust on a globally agreed rule dynamically by market driven demand.
>>> Considering the ruleset above also Decreases  the Block ONLY if its greater than 0.99mb this brings size back to a competitive state /and size once market demand pressures subside, yet achieves the smallest market feasible block size while also maintaining all current rule sets.
>>>  An attacker would have to affect all block fees over the last 16 hours worth of transactions to affect a 10% max block size increase but then only after waiting 1.5 hours, so long as nothing has changed in the last 1.5 hours and only for a limited amount of time. This approach also limits bloat. This safety block window of 9 blocks provides a look forward and look behind value, in turn provides the network time to synchronize. 
>>> 10 block sync window.  This, by design, also limits changes to one change  every 3 hours (20 blocks), if there is a market pressure "STATE" occurring.
>>> My Question to the community is. Will our current Block accommodate the 3 Byte 
>>> Variable, Is solving the Scaling issue worth using the 3 Bytes of space?  
>>> I believe it is.  
>>> --
>>> Software,  Will need  to Evaluate MaxBlockSize Variable, and ActivateONBlock Variable from the most recent distributed blocks DMBS  3 byte value. 
>>> Run the rules , get the answer set the now known MaxBlockSize Var and Propegate the "DMBS" value. 
>>> 
>>> As capacity limits are breached, I think the majority agree "we need to agree".  
>>> 
>>> MaxBlockSize would provide a suitable middle ground and address concerns in a dynamic fashion, without compromising  or changing  existing security.   
>>>  Examples reflected in the blockchain 19000A   rules has evaluates to  true, increase expected in 9 blocks.1.0mb increases to 1.1mb
>>> if true for 9 more blocks  MaxBlockSize Var becomes  18000A.. 17000A..,16000A ..and so on if  still true at 10000A var written becomes 
>>> 00000B when read from left to right,  0-no change, in 0 blocks current " DMBS" value 000B or 1.1MB  and stays that way  00000B until MaxBlockSize  evaluates to "True" under a market pressure/ relief situation. 
>>> I hope this makes sense, I would appreciate some feedback. 
>>> TG
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191108/f6739b1b/attachment.html>

From willtech at live.com.au  Fri Nov  8 17:03:02 2019
From: willtech at live.com.au (LORD HIS EXCELLENCY JAMES HRMH)
Date: Fri, 8 Nov 2019 17:03:02 +0000
Subject: [bitcoin-dev] CVE-2017-18350 disclosure
In-Reply-To: <201911081507.40441.luke@dashjr.org>
References: <201911081507.40441.luke@dashjr.org>
Message-ID: <PS2P216MB0179D441FBC93122CDE5354D9D7B0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>

It goes without saying in that all privately known CVE should be handled so professionally but, that is, well done team.

Regards,
LORD HIS EXCELLENCY JAMES HRMH


________________________________
From: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
Sent: Saturday, 9 November 2019 2:07 AM
To: bitcoin-dev at lists.linuxfoundation.org <bitcoin-dev at lists.linuxfoundation.org>
Cc: security at bitcoincore.org <security at bitcoincore.org>
Subject: [bitcoin-dev] CVE-2017-18350 disclosure

CVE-2017-18350 is a buffer overflow vulnerability which allows a malicious
SOCKS proxy server to overwrite the program stack on systems with a signed
`char` type (including common 32-bit and 64-bit x86 PCs).

The vulnerability was introduced in 60a87bce873ce1f76a80b7b8546e83a0cd4e07a5
(SOCKS5 support) and first released in Bitcoin Core v0.7.0rc1 in 2012 Aug 27.
A fix was hidden in d90a00eabed0f3f1acea4834ad489484d0012372 ("Improve and
document SOCKS code") released in v0.15.1, 2017 Nov 6.

To be vulnerable, the node must be configured to use such a malicious proxy in
the first place. Note that using *any* proxy over an insecure network (such
as the Internet) is potentially a vulnerability since the connection could be
intercepted for such a purpose.

Upon a connection request from the node, the malicious proxy would respond
with an acknowledgement of a different target domain name than the one
requested. Normally this acknowledgement is entirely ignored, but if the
length uses the high bit (ie, a length 128-255 inclusive), it will be
interpreted by vulnerable versions as a negative number instead. When the
negative number is passed to the recv() system call to read the domain name,
it is converted back to an unsigned/positive number, but at a much wider size
(typically 32-bit), resulting in an effectively infinite read into and beyond
the 256-byte dummy stack buffer.

To fix this vulnerability, the dummy buffer was changed to an explicitly
unsigned data type, avoiding the conversion to/from a negative number.

Credit goes to practicalswift (https://twitter.com/practicalswift) for
discovering and providing the initial fix for the vulnerability, and Wladimir
J. van der Laan for a disguised version of the fix as well as general cleanup
to the at-risk code.

Timeline:
- 2012-04-01: Vulnerability introduced in PR #1141.
- 2012-05-08: Vulnerability merged to master git repository.
- 2012-08-27: Vulnerability published in v0.7.0rc1.
- 2012-09-17: Vulnerability released in v0.7.0.
...
- 2017-09-21: practicalswift discloses vulnerability to security team.
- 2017-09-23: Wladimir opens PR #11397 to quietly fix vulernability.
- 2017-09-27: Fix merged to master git repository.
- 2017-10-18: Fix merged to 0.15 git repository.
- 2017-11-04: Fix published in v0.15.1rc1.
- 2017-11-09: Fix released in v0.15.1.
...
- 2019-06-22: Vulnerability existence disclosed to bitcoin-dev ML.
- 2019-11-08: Vulnerability details disclosure to bitcoin-dev ML.
_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191108/aace00bf/attachment-0001.html>

From vitteaymeric at gmail.com  Fri Nov  8 19:40:17 2019
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Fri, 8 Nov 2019 20:40:17 +0100
Subject: [bitcoin-dev] CVE-2017-18350 disclosure
In-Reply-To: <PS2P216MB0179D441FBC93122CDE5354D9D7B0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
References: <201911081507.40441.luke@dashjr.org>
	<PS2P216MB0179D441FBC93122CDE5354D9D7B0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
Message-ID: <b6ccd41b-3232-80d2-ab66-5ffa0f7abfac@gmail.com>

Sure, but what is questionable here is the use of SOCKS proxy, for Tor I
think as the main purpose, making it dangerous for the "whole bitcoin
world" while it's something like of zero interest/use (or please let me
know what it is beside Tor)

The Tor network is very centralized and not designed at all to handle
p2p networks (which bitcoin is still not), it is designed to be used via
the Tor Browser to browse the web and to hide web servers, not bitcoin
nodes, and there are a lot of misbehaving/dangerous nodes there, there
is no encryption in bitcoin protocol, an exit node can fake whatever it
likes, this seems to be a use case as far as I can see, but even if the
initiator is configured to connect to a hidden bitcoin node, I don't see
the point

I have advertised recentlty the open sourcing of node-Tor
(https://github.com/Ayms/node-Tor) here

This one is designed for p2p, not over the Tor network but using the Tor
protocol, as simple as bitcoin.pipe(node-Tor), or <any
protocol>.pipe(node-Tor), which is the finality of the project as far as
I see it since years (maybe see http://www.peersm.com/Convergence.pdf
even if I would modify some parts now)

Inside servers or browsers acting as servers also (WebRTC or
WebSockets), bitcoin peers (servers/browsers) relaying the bitcoin
anonymized protocol using the Tor protocol (and not the Tor network)
between each others, there is no story of exit nodes here and rdv points
would not apply for bitcoin use, this "just" adds the internal missing
encryption and anonymity layer to the bitcoin protocol

Personally I would remove the socks proxy interface from bitcoin core,
independently of Tor this can be misused too and offers absolutely zero
security


Le 08/11/2019 ? 18:03, LORD HIS EXCELLENCY JAMES HRMH via bitcoin-dev a
?crit?:
> It goes without saying in that all privately known CVE should be
> handled so professionally but, that is, well done team.
>
> Regards,
> LORD HIS EXCELLENCY JAMES HRMH
>
>
> ------------------------------------------------------------------------
> *From:* bitcoin-dev-bounces at lists.linuxfoundation.org
> <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Luke
> Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
> *Sent:* Saturday, 9 November 2019 2:07 AM
> *To:* bitcoin-dev at lists.linuxfoundation.org
> <bitcoin-dev at lists.linuxfoundation.org>
> *Cc:* security at bitcoincore.org <security at bitcoincore.org>
> *Subject:* [bitcoin-dev] CVE-2017-18350 disclosure
> ?
> CVE-2017-18350 is a buffer overflow vulnerability which allows a
> malicious
> SOCKS proxy server to overwrite the program stack on systems with a
> signed
> `char` type (including common 32-bit and 64-bit x86 PCs).
>
> The vulnerability was introduced in
> 60a87bce873ce1f76a80b7b8546e83a0cd4e07a5
> (SOCKS5 support) and first released in Bitcoin Core v0.7.0rc1 in 2012
> Aug 27.
> A fix was hidden in d90a00eabed0f3f1acea4834ad489484d0012372 ("Improve
> and
> document SOCKS code") released in v0.15.1, 2017 Nov 6.
>
> To be vulnerable, the node must be configured to use such a malicious
> proxy in
> the first place. Note that using *any* proxy over an insecure network
> (such
> as the Internet) is potentially a vulnerability since the connection
> could be
> intercepted for such a purpose.
>
> Upon a connection request from the node, the malicious proxy would
> respond
> with an acknowledgement of a different target domain name than the one
> requested. Normally this acknowledgement is entirely ignored, but if the
> length uses the high bit (ie, a length 128-255 inclusive), it will be
> interpreted by vulnerable versions as a negative number instead. When the
> negative number is passed to the recv() system call to read the domain
> name,
> it is converted back to an unsigned/positive number, but at a much
> wider size
> (typically 32-bit), resulting in an effectively infinite read into and
> beyond
> the 256-byte dummy stack buffer.
>
> To fix this vulnerability, the dummy buffer was changed to an explicitly
> unsigned data type, avoiding the conversion to/from a negative number.
>
> Credit goes to practicalswift (https://twitter.com/practicalswift) for
> discovering and providing the initial fix for the vulnerability, and
> Wladimir
> J. van der Laan for a disguised version of the fix as well as general
> cleanup
> to the at-risk code.
>
> Timeline:
> - 2012-04-01: Vulnerability introduced in PR #1141.
> - 2012-05-08: Vulnerability merged to master git repository.
> - 2012-08-27: Vulnerability published in v0.7.0rc1.
> - 2012-09-17: Vulnerability released in v0.7.0.
> ...
> - 2017-09-21: practicalswift discloses vulnerability to security team.
> - 2017-09-23: Wladimir opens PR #11397 to quietly fix vulernability.
> - 2017-09-27: Fix merged to master git repository.
> - 2017-10-18: Fix merged to 0.15 git repository.
> - 2017-11-04: Fix published in v0.15.1rc1.
> - 2017-11-09: Fix released in v0.15.1.
> ...
> - 2019-06-22: Vulnerability existence disclosed to bitcoin-dev ML.
> - 2019-11-08: Vulnerability details disclosure to bitcoin-dev ML.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191108/e9797500/attachment.html>

From vitteaymeric at gmail.com  Sat Nov  9 19:33:25 2019
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Sat, 9 Nov 2019 20:33:25 +0100
Subject: [bitcoin-dev] CVE-2017-18350 disclosure
In-Reply-To: <PS2P216MB0179591B9D8380B290BF4A5C9D7A0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
References: <201911081507.40441.luke@dashjr.org>
	<PS2P216MB0179D441FBC93122CDE5354D9D7B0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
	<b6ccd41b-3232-80d2-ab66-5ffa0f7abfac@gmail.com>
	<PS2P216MB0179591B9D8380B290BF4A5C9D7A0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
Message-ID: <256d3775-814a-02ad-8152-f2b689219653@gmail.com>

???


Well, you obviously don't know what you are talking about and did not
even consider reading correctly what I wrote, neither to read node-Tor


What you are saying here is quite trivial, typical of people thinking
that the Tor network will solve everything and is not centralized (but
you seem unsure about it), that's not the case, it's completely wrong
and the "normal" use of the Tor network is for browsing only, basically
the Tor network is still the same since years: 1000 guards, 1000 relays,
1000 exits (so not "hundreds", happier, and there are of course
intersections between them, knowing that they are the supposed working
nodes as tested by node-Tor), quite small at the end with finally many
misbehaving nodes among the 3000 set, not at all able or willing to
handle bitcoin nodes load


Using bitcoin with the Tor network is absurd, using socks proxy with
bitcoin is absurd too (I don't get the comparison with a http proxy,
nothing to do),? except if limited to a local use, ie you socks proxy
inside your device, for example to pipe to node-Tor, but this remains as
a whole dangerous if the local proxy has been hacked, as we could see
recently with malware Tor sw being used by people


Using the Tor protocol for bitcoin is not absurd at all (do you
understand the difference?) + browsers, webRTC, etc I will not repeat
what I wrote


Please do some readings or consider at least what I sent, or ask
questions if what I am saying is unclear for you


But from my standpoint the discussion on this list is not about
explaining all of this that is probably well known by everybody but what
can/could be next to anonymize/help anonymizing bitcoin

?when required and make it a real p2p network


Unfortunately I am afraid that we get moderated here because that's not
the place to give basic lessons about Tor that you don't know


Le 09/11/2019 ? 12:42, LORD HIS EXCELLENCY JAMES HRMH a ?crit?:
> Socks proxies have their use in controlled gateway infrastructure and
> is a relevant feature for any software required to operate behind a
> secure network boundary and allows for UDP connectivity (whether it is
> utilised in any particular application) which a HTTP proxy does not.
>
> You are obviously not well abreast of the Tor project, regardless of
> whether it seems centralised, whether it is or it isn't, the Tor
> project is to allow anonymity and connection privacy. For this it
> works very well and there seem to be hundreds of known Tor nodes, to
> be known they are not isolated and are connected.
>
> Even if an exit node performs all logging it is only aware of the node
> one hop up but the originator is higher still. In the case where we
> perform a Tor cluster and make hundreds of guard, middle and exit
> nodes we still cannot with absolute certainty say that the connecting
> node is the originator and, the eventual Bitcoin node is still unaware
> of the originator IP which is the primary objective. Otherwise, can
> you hide your IP from your ISP would be a better goal?
>
> You may prefer to familiarise yourself first with the history of Tor,
> even a brief from [WikipediaTor_(anonymity_network)
> <https://en.wikipedia.org/wiki/Tor_(anonymity_network)>](https://en.wikipedia.org/wiki/Tor_(anonymity_network))
> and consider some of the possible uses, and consider how its
> implementation benefits the privacy and anonymity of Bitcoin in public
> where it is allowed in many countries; Tor is just as useful in
> countries where Bitcoin is allowed to hide from third-parties. You may
> also enjoy an example of activating Bitcoin Cores Tor implementation:
> [How can I setup Bitcoin to be anonymous with
> Tor?](https://bitcoin.stackexchange.com/questions/70069/how-can-i-setup-bitcoin-to-be-anonymous-with-tor/70070#70070)
> <https://en.wikipedia.org/wiki/Tor_(anonymity_network)>
> 	
> Tor (anonymity network) - Wikipedia
> <https://en.wikipedia.org/wiki/Tor_(anonymity_network)>
> Tor is free and open-source software for enabling anonymous
> communication.The name is derived from an acronym for the original
> software project name "The Onion Router". Tor directs Internet traffic
> through a free, worldwide, volunteer overlay network consisting of
> more than seven thousand relays to conceal a user's location and usage
> from anyone conducting network surveillance or traffic analysis.
> en.wikipedia.org
>
>
> <https://bitcoin.stackexchange.com/questions/70069/how-can-i-setup-bitcoin-to-be-anonymous-with-tor/70070#70070>
> 	
> bitcoind - How can I setup Bitcoin to be anonymous with Tor? - Bitcoin
> Stack Exchange
> <https://bitcoin.stackexchange.com/questions/70069/how-can-i-setup-bitcoin-to-be-anonymous-with-tor/70070#70070>
> Bitcoin is billed as many things, among them its anonymity is highly
> regarded. While it is true that a transaction does not identify a user
> or wallet, recent news shows that there is the potential ...
> bitcoin.stackexchange.com
>
>
>
> There should be no rational consideration that gives rise to reducing
> Tor connectivity, possibly v3 integration will be coming along.
>
> Regards,
> LORD HIS EXCELLENCY JAMES HRMH
>
>
> ------------------------------------------------------------------------
> *From:* Aymeric Vitte <vitteaymeric at gmail.com>
> *Sent:* Saturday, 9 November 2019 6:40 AM
> *To:* LORD HIS EXCELLENCY JAMES HRMH <willtech at live.com.au>; Bitcoin
> Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>; Luke
> Dashjr <luke at dashjr.org>
> *Cc:* security at bitcoincore.org <security at bitcoincore.org>
> *Subject:* Re: [bitcoin-dev] CVE-2017-18350 disclosure
> ?
>
> Sure, but what is questionable here is the use of SOCKS proxy, for Tor
> I think as the main purpose, making it dangerous for the "whole
> bitcoin world" while it's something like of zero interest/use (or
> please let me know what it is beside Tor)
>
> The Tor network is very centralized and not designed at all to handle
> p2p networks (which bitcoin is still not), it is designed to be used
> via the Tor Browser to browse the web and to hide web servers, not
> bitcoin nodes, and there are a lot of misbehaving/dangerous nodes
> there, there is no encryption in bitcoin protocol, an exit node can
> fake whatever it likes, this seems to be a use case as far as I can
> see, but even if the initiator is configured to connect to a hidden
> bitcoin node, I don't see the point
>
> I have advertised recentlty the open sourcing of node-Tor
> (https://github.com/Ayms/node-Tor) here
>
> This one is designed for p2p, not over the Tor network but using the
> Tor protocol, as simple as bitcoin.pipe(node-Tor), or <any
> protocol>.pipe(node-Tor), which is the finality of the project as far
> as I see it since years (maybe see
> http://www.peersm.com/Convergence.pdf even if I would modify some
> parts now)
>
> Inside servers or browsers acting as servers also (WebRTC or
> WebSockets), bitcoin peers (servers/browsers) relaying the bitcoin
> anonymized protocol using the Tor protocol (and not the Tor network)
> between each others, there is no story of exit nodes here and rdv
> points would not apply for bitcoin use, this "just" adds the internal
> missing encryption and anonymity layer to the bitcoin protocol
>
> Personally I would remove the socks proxy interface from bitcoin core,
> independently of Tor this can be misused too and offers absolutely
> zero security
>
>
> Le 08/11/2019 ? 18:03, LORD HIS EXCELLENCY JAMES HRMH via bitcoin-dev
> a ?crit?:
>> It goes without saying in that all privately known CVE should be
>> handled so professionally but, that is, well done team.
>>
>> Regards,
>> LORD HIS EXCELLENCY JAMES HRMH
>>
>>
>> ------------------------------------------------------------------------
>> *From:* bitcoin-dev-bounces at lists.linuxfoundation.org
>> <mailto:bitcoin-dev-bounces at lists.linuxfoundation.org>
>> <bitcoin-dev-bounces at lists.linuxfoundation.org>
>> <mailto:bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of
>> Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
>> <mailto:bitcoin-dev at lists.linuxfoundation.org>
>> *Sent:* Saturday, 9 November 2019 2:07 AM
>> *To:* bitcoin-dev at lists.linuxfoundation.org
>> <mailto:bitcoin-dev at lists.linuxfoundation.org>
>> <bitcoin-dev at lists.linuxfoundation.org>
>> <mailto:bitcoin-dev at lists.linuxfoundation.org>
>> *Cc:* security at bitcoincore.org <mailto:security at bitcoincore.org>
>> <security at bitcoincore.org> <mailto:security at bitcoincore.org>
>> *Subject:* [bitcoin-dev] CVE-2017-18350 disclosure
>> ?
>> CVE-2017-18350 is a buffer overflow vulnerability which allows a
>> malicious
>> SOCKS proxy server to overwrite the program stack on systems with a
>> signed
>> `char` type (including common 32-bit and 64-bit x86 PCs).
>>
>> The vulnerability was introduced in
>> 60a87bce873ce1f76a80b7b8546e83a0cd4e07a5
>> (SOCKS5 support) and first released in Bitcoin Core v0.7.0rc1 in 2012
>> Aug 27.
>> A fix was hidden in d90a00eabed0f3f1acea4834ad489484d0012372
>> ("Improve and
>> document SOCKS code") released in v0.15.1, 2017 Nov 6.
>>
>> To be vulnerable, the node must be configured to use such a malicious
>> proxy in
>> the first place. Note that using *any* proxy over an insecure network
>> (such
>> as the Internet) is potentially a vulnerability since the connection
>> could be
>> intercepted for such a purpose.
>>
>> Upon a connection request from the node, the malicious proxy would
>> respond
>> with an acknowledgement of a different target domain name than the one
>> requested. Normally this acknowledgement is entirely ignored, but if the
>> length uses the high bit (ie, a length 128-255 inclusive), it will be
>> interpreted by vulnerable versions as a negative number instead. When
>> the
>> negative number is passed to the recv() system call to read the
>> domain name,
>> it is converted back to an unsigned/positive number, but at a much
>> wider size
>> (typically 32-bit), resulting in an effectively infinite read into
>> and beyond
>> the 256-byte dummy stack buffer.
>>
>> To fix this vulnerability, the dummy buffer was changed to an explicitly
>> unsigned data type, avoiding the conversion to/from a negative number.
>>
>> Credit goes to practicalswift (https://twitter.com/practicalswift) for
>> discovering and providing the initial fix for the vulnerability, and
>> Wladimir
>> J. van der Laan for a disguised version of the fix as well as general
>> cleanup
>> to the at-risk code.
>>
>> Timeline:
>> - 2012-04-01: Vulnerability introduced in PR #1141.
>> - 2012-05-08: Vulnerability merged to master git repository.
>> - 2012-08-27: Vulnerability published in v0.7.0rc1.
>> - 2012-09-17: Vulnerability released in v0.7.0.
>> ...
>> - 2017-09-21: practicalswift discloses vulnerability to security team.
>> - 2017-09-23: Wladimir opens PR #11397 to quietly fix vulernability.
>> - 2017-09-27: Fix merged to master git repository.
>> - 2017-10-18: Fix merged to 0.15 git repository.
>> - 2017-11-04: Fix published in v0.15.1rc1.
>> - 2017-11-09: Fix released in v0.15.1.
>> ...
>> - 2019-06-22: Vulnerability existence disclosed to bitcoin-dev ML.
>> - 2019-11-08: Vulnerability details disclosure to bitcoin-dev ML.
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> <mailto:bitcoin-dev at lists.linuxfoundation.org>
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191109/0e41bee1/attachment-0001.html>

From vitteaymeric at gmail.com  Sun Nov 10 00:23:03 2019
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Sun, 10 Nov 2019 01:23:03 +0100
Subject: [bitcoin-dev] CVE-2017-18350 disclosure
In-Reply-To: <PS2P216MB0179B7D2ADEA7CB544F7F90C9D7A0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
References: <201911081507.40441.luke@dashjr.org>
	<PS2P216MB0179D441FBC93122CDE5354D9D7B0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
	<b6ccd41b-3232-80d2-ab66-5ffa0f7abfac@gmail.com>
	<PS2P216MB0179591B9D8380B290BF4A5C9D7A0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
	<256d3775-814a-02ad-8152-f2b689219653@gmail.com>
	<PS2P216MB0179B7D2ADEA7CB544F7F90C9D7A0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
Message-ID: <64872879-885d-b7de-7224-73ab91a3bf12@gmail.com>

Do not find excuses (and vague statements or technical bulls) and learn,
you don't know what you are talking about and don't get the global
picture, we don't care about the Tor network and they don't care about
others neither do they care that they increase their network, so indeed
let's stop this discussion


Just replying here (for the last time) because expecting more clever
thoughts about what I wrote, maybe one day... but for sure something
like this will happen in the future


Le 09/11/2019 ? 21:21, LORD HIS EXCELLENCY JAMES HRMH a ?crit?:
> We do not need to discuss this back and forward publickly. I am not
> concerned whether Tors seems or is much centralised or not, it is not
> the concern of m statements, and it required directory nodes of which
> there are several and we could discuss the operation of its nodes and
> infrastructure all day, even comparing directory nodes to seed nodes.
> The fact is that browsing is the most common publicly understood usage
> of Tor but like with and without Tor the internet provides many services.
>
> It seems you have misunderstood the reason I reference making so many
> Tor nodes also but do not concern I will no reiterate. Also, whether
> Tor can provide for the bandwidth and connectivity required for
> Bitcoin you have not tested and provide only your opinion, where it
> seems that actually it can. The matter is that Tor carries Bitcoin
> traffic quite easily now and in fact as there is more Bitcoin traffic
> likely the Tor capacity increases in some proportion.
>
> Also, socks proxy is not a door in, it is a door out, do you realise
> but just works at a different network layer to HTTP proxy which works
> at layer 7 of the OSI model and Socks a bit lower?
>
> I have had some communication difficulty before where the native
> language is not English and although the communication happens in
> native English the though is still being formed in another language
> and so the presentation of the thought is not clear to the English
> presentation. Even if not this I do not consider wrong just that we
> write to consider not the same thing.
>
> Good day.
>
> Regards,
> LORD HIS EXCELLENCY JAMES HRMH
>
>
> ------------------------------------------------------------------------
> *From:* Aymeric Vitte <vitteaymeric at gmail.com>
> *Sent:* Sunday, 10 November 2019 6:33 AM
> *To:* LORD HIS EXCELLENCY JAMES HRMH <willtech at live.com.au>; Bitcoin
> Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>; Luke
> Dashjr <luke at dashjr.org>
> *Cc:* security at bitcoincore.org <security at bitcoincore.org>
> *Subject:* Re: [bitcoin-dev] CVE-2017-18350 disclosure
> ?
>
> ???
>
>
> Well, you obviously don't know what you are talking about and did not
> even consider reading correctly what I wrote, neither to read node-Tor
>
>
> What you are saying here is quite trivial, typical of people thinking
> that the Tor network will solve everything and is not centralized (but
> you seem unsure about it), that's not the case, it's completely wrong
> and the "normal" use of the Tor network is for browsing only,
> basically the Tor network is still the same since years: 1000 guards,
> 1000 relays, 1000 exits (so not "hundreds", happier, and there are of
> course intersections between them, knowing that they are the supposed
> working nodes as tested by node-Tor), quite small at the end with
> finally many misbehaving nodes among the 3000 set, not at all able or
> willing to handle bitcoin nodes load
>
>
> Using bitcoin with the Tor network is absurd, using socks proxy with
> bitcoin is absurd too (I don't get the comparison with a http proxy,
> nothing to do),? except if limited to a local use, ie you socks proxy
> inside your device, for example to pipe to node-Tor, but this remains
> as a whole dangerous if the local proxy has been hacked, as we could
> see recently with malware Tor sw being used by people
>
>
> Using the Tor protocol for bitcoin is not absurd at all (do you
> understand the difference?) + browsers, webRTC, etc I will not repeat
> what I wrote
>
>
> Please do some readings or consider at least what I sent, or ask
> questions if what I am saying is unclear for you
>
>
> But from my standpoint the discussion on this list is not about
> explaining all of this that is probably well known by everybody but
> what can/could be next to anonymize/help anonymizing bitcoin
>
> ?when required and make it a real p2p network
>
>
> Unfortunately I am afraid that we get moderated here because that's
> not the place to give basic lessons about Tor that you don't know
>
>
> Le 09/11/2019 ? 12:42, LORD HIS EXCELLENCY JAMES HRMH a ?crit?:
>> Socks proxies have their use in controlled gateway infrastructure and
>> is a relevant feature for any software required to operate behind a
>> secure network boundary and allows for UDP connectivity (whether it
>> is utilised in any particular application) which a HTTP proxy does not.
>>
>> You are obviously not well abreast of the Tor project, regardless of
>> whether it seems centralised, whether it is or it isn't, the Tor
>> project is to allow anonymity and connection privacy. For this it
>> works very well and there seem to be hundreds of known Tor nodes, to
>> be known they are not isolated and are connected.
>>
>> Even if an exit node performs all logging it is only aware of the
>> node one hop up but the originator is higher still. In the case where
>> we perform a Tor cluster and make hundreds of guard, middle and exit
>> nodes we still cannot with absolute certainty say that the connecting
>> node is the originator and, the eventual Bitcoin node is still
>> unaware of the originator IP which is the primary objective.
>> Otherwise, can you hide your IP from your ISP would be a better goal?
>>
>> You may prefer to familiarise yourself first with the history of Tor,
>> even a brief from [WikipediaTor_(anonymity_network)
>> <https://en.wikipedia.org/wiki/Tor_(anonymity_network)>](https://en.wikipedia.org/wiki/Tor_(anonymity_network))
>> and consider some of the possible uses, and consider how its
>> implementation benefits the privacy and anonymity of Bitcoin in
>> public where it is allowed in many countries; Tor is just as useful
>> in countries where Bitcoin is allowed to hide from third-parties. You
>> may also enjoy an example of activating Bitcoin Cores Tor
>> implementation: [How can I setup Bitcoin to be anonymous with
>> Tor?](https://bitcoin.stackexchange.com/questions/70069/how-can-i-setup-bitcoin-to-be-anonymous-with-tor/70070#70070)
>> <https://en.wikipedia.org/wiki/Tor_(anonymity_network)>
>> 	
>> Tor (anonymity network) - Wikipedia
>> <https://en.wikipedia.org/wiki/Tor_(anonymity_network)>
>> Tor is free and open-source software for enabling anonymous
>> communication.The name is derived from an acronym for the original
>> software project name "The Onion Router". Tor directs Internet
>> traffic through a free, worldwide, volunteer overlay network
>> consisting of more than seven thousand relays to conceal a user's
>> location and usage from anyone conducting network surveillance or
>> traffic analysis.
>> en.wikipedia.org
>>
>>
>> <https://bitcoin.stackexchange.com/questions/70069/how-can-i-setup-bitcoin-to-be-anonymous-with-tor/70070#70070>
>> 	
>> bitcoind - How can I setup Bitcoin to be anonymous with Tor? -
>> Bitcoin Stack Exchange
>> <https://bitcoin.stackexchange.com/questions/70069/how-can-i-setup-bitcoin-to-be-anonymous-with-tor/70070#70070>
>> Bitcoin is billed as many things, among them its anonymity is highly
>> regarded. While it is true that a transaction does not identify a
>> user or wallet, recent news shows that there is the potential ...
>> bitcoin.stackexchange.com
>>
>>
>>
>> There should be no rational consideration that gives rise to reducing
>> Tor connectivity, possibly v3 integration will be coming along.
>>
>> Regards,
>> LORD HIS EXCELLENCY JAMES HRMH
>>
>>
>> ------------------------------------------------------------------------
>> *From:* Aymeric Vitte <vitteaymeric at gmail.com>
>> <mailto:vitteaymeric at gmail.com>
>> *Sent:* Saturday, 9 November 2019 6:40 AM
>> *To:* LORD HIS EXCELLENCY JAMES HRMH <willtech at live.com.au>
>> <mailto:willtech at live.com.au>; Bitcoin Protocol Discussion
>> <bitcoin-dev at lists.linuxfoundation.org>
>> <mailto:bitcoin-dev at lists.linuxfoundation.org>; Luke Dashjr
>> <luke at dashjr.org> <mailto:luke at dashjr.org>
>> *Cc:* security at bitcoincore.org <mailto:security at bitcoincore.org>
>> <security at bitcoincore.org> <mailto:security at bitcoincore.org>
>> *Subject:* Re: [bitcoin-dev] CVE-2017-18350 disclosure
>> ?
>>
>> Sure, but what is questionable here is the use of SOCKS proxy, for
>> Tor I think as the main purpose, making it dangerous for the "whole
>> bitcoin world" while it's something like of zero interest/use (or
>> please let me know what it is beside Tor)
>>
>> The Tor network is very centralized and not designed at all to handle
>> p2p networks (which bitcoin is still not), it is designed to be used
>> via the Tor Browser to browse the web and to hide web servers, not
>> bitcoin nodes, and there are a lot of misbehaving/dangerous nodes
>> there, there is no encryption in bitcoin protocol, an exit node can
>> fake whatever it likes, this seems to be a use case as far as I can
>> see, but even if the initiator is configured to connect to a hidden
>> bitcoin node, I don't see the point
>>
>> I have advertised recentlty the open sourcing of node-Tor
>> (https://github.com/Ayms/node-Tor) here
>>
>> This one is designed for p2p, not over the Tor network but using the
>> Tor protocol, as simple as bitcoin.pipe(node-Tor), or <any
>> protocol>.pipe(node-Tor), which is the finality of the project as far
>> as I see it since years (maybe see
>> http://www.peersm.com/Convergence.pdf
>> <http://www.peersm.com/Convergence.pdf> even if I would modify some
>> parts now)
>>
>> Inside servers or browsers acting as servers also (WebRTC or
>> WebSockets), bitcoin peers (servers/browsers) relaying the bitcoin
>> anonymized protocol using the Tor protocol (and not the Tor network)
>> between each others, there is no story of exit nodes here and rdv
>> points would not apply for bitcoin use, this "just" adds the internal
>> missing encryption and anonymity layer to the bitcoin protocol
>>
>> Personally I would remove the socks proxy interface from bitcoin
>> core, independently of Tor this can be misused too and offers
>> absolutely zero security
>>
>>
>> Le 08/11/2019 ? 18:03, LORD HIS EXCELLENCY JAMES HRMH via bitcoin-dev
>> a ?crit?:
>>> It goes without saying in that all privately known CVE should be
>>> handled so professionally but, that is, well done team.
>>>
>>> Regards,
>>> LORD HIS EXCELLENCY JAMES HRMH
>>>
>>>
>>> ------------------------------------------------------------------------
>>> *From:* bitcoin-dev-bounces at lists.linuxfoundation.org
>>> <mailto:bitcoin-dev-bounces at lists.linuxfoundation.org>
>>> <bitcoin-dev-bounces at lists.linuxfoundation.org>
>>> <mailto:bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of
>>> Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
>>> <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>> *Sent:* Saturday, 9 November 2019 2:07 AM
>>> *To:* bitcoin-dev at lists.linuxfoundation.org
>>> <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>> <bitcoin-dev at lists.linuxfoundation.org>
>>> <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>> *Cc:* security at bitcoincore.org <mailto:security at bitcoincore.org>
>>> <security at bitcoincore.org> <mailto:security at bitcoincore.org>
>>> *Subject:* [bitcoin-dev] CVE-2017-18350 disclosure
>>> ?
>>> CVE-2017-18350 is a buffer overflow vulnerability which allows a
>>> malicious
>>> SOCKS proxy server to overwrite the program stack on systems with a
>>> signed
>>> `char` type (including common 32-bit and 64-bit x86 PCs).
>>>
>>> The vulnerability was introduced in
>>> 60a87bce873ce1f76a80b7b8546e83a0cd4e07a5
>>> (SOCKS5 support) and first released in Bitcoin Core v0.7.0rc1 in
>>> 2012 Aug 27.
>>> A fix was hidden in d90a00eabed0f3f1acea4834ad489484d0012372
>>> ("Improve and
>>> document SOCKS code") released in v0.15.1, 2017 Nov 6.
>>>
>>> To be vulnerable, the node must be configured to use such a
>>> malicious proxy in
>>> the first place. Note that using *any* proxy over an insecure
>>> network (such
>>> as the Internet) is potentially a vulnerability since the connection
>>> could be
>>> intercepted for such a purpose.
>>>
>>> Upon a connection request from the node, the malicious proxy would
>>> respond
>>> with an acknowledgement of a different target domain name than the one
>>> requested. Normally this acknowledgement is entirely ignored, but if
>>> the
>>> length uses the high bit (ie, a length 128-255 inclusive), it will be
>>> interpreted by vulnerable versions as a negative number instead.
>>> When the
>>> negative number is passed to the recv() system call to read the
>>> domain name,
>>> it is converted back to an unsigned/positive number, but at a much
>>> wider size
>>> (typically 32-bit), resulting in an effectively infinite read into
>>> and beyond
>>> the 256-byte dummy stack buffer.
>>>
>>> To fix this vulnerability, the dummy buffer was changed to an
>>> explicitly
>>> unsigned data type, avoiding the conversion to/from a negative number.
>>>
>>> Credit goes to practicalswift (https://twitter.com/practicalswift) for
>>> discovering and providing the initial fix for the vulnerability, and
>>> Wladimir
>>> J. van der Laan for a disguised version of the fix as well as
>>> general cleanup
>>> to the at-risk code.
>>>
>>> Timeline:
>>> - 2012-04-01: Vulnerability introduced in PR #1141.
>>> - 2012-05-08: Vulnerability merged to master git repository.
>>> - 2012-08-27: Vulnerability published in v0.7.0rc1.
>>> - 2012-09-17: Vulnerability released in v0.7.0.
>>> ...
>>> - 2017-09-21: practicalswift discloses vulnerability to security team.
>>> - 2017-09-23: Wladimir opens PR #11397 to quietly fix vulernability.
>>> - 2017-09-27: Fix merged to master git repository.
>>> - 2017-10-18: Fix merged to 0.15 git repository.
>>> - 2017-11-04: Fix published in v0.15.1rc1.
>>> - 2017-11-09: Fix released in v0.15.1.
>>> ...
>>> - 2019-06-22: Vulnerability existence disclosed to bitcoin-dev ML.
>>> - 2019-11-08: Vulnerability details disclosure to bitcoin-dev ML.
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-- 
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191110/51ff57f0/attachment-0001.html>

From pieter.wuille at gmail.com  Sun Nov 10 21:51:48 2019
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Sun, 10 Nov 2019 13:51:48 -0800
Subject: [bitcoin-dev] Bech32 weakness and impact on bip-taproot
	addresses
In-Reply-To: <20191108021541.n3jk54vucplryrbl@ganymede>
References: <CAPg+sBjC-D2iWYywj_X-evQoWx56nb0YnASLVwCSCzWT6Guu3A@mail.gmail.com>
	<20191108021541.n3jk54vucplryrbl@ganymede>
Message-ID: <CAPg+sBgus6HgYPVbXaAx51nO2ArsR3-6=obe2AwkO8kh11fB6Q@mail.gmail.com>

On Thu, Nov 7, 2019, 18:16 David A. Harding <dave at dtrt.org> wrote:

> On Thu, Nov 07, 2019 at 02:35:42PM -0800, Pieter Wuille via bitcoin-dev
> wrote:
> > In the current draft, witness v1 outputs of length other
> > than 32 remain unencumbered, which means that for now such an
> > insertion or erasure would result in an output that can be spent by
> > anyone. If that is considered unacceptable, it could be prevented by
> > for example outlawing v1 witness outputs of length 31 and 33.
>
> Either a consensus rule or a standardness rule[1] would require anyone
> using a bech32 library supporting v1+ segwit to upgrade their library.
> Otherwise, users of old libraries will still attempt to pay v1 witness
> outputs of length 31 or 33, causing their transactions to get rejected
> by newer nodes or get stuck on older nodes.  This is basically the
> problem #15846[2] was meant to prevent.
>
> If we're going to need everyone to upgrade their bech32 libraries
> anyway, I think it's probably best that the problem is fixed in the
> bech32 algorithm rather than at the consensus/standardness layer.
>

Admittedly, this affecting development of consensus or standardness rules
would feel unnatural. In addition, it also has the potential downside of
breaking batched transactions in some settings (ask an exchange for a
withdrawal to a invalid/nonstandard version, which they batch with other
outputs that then get stuck because the transaction does not go through).

So, Ideally this is indeed solved entirely on the bech32/address encoding
side of things. I did not initially expect the discussion here to go in
that direction, as that could come with all problems that rolling out a new
address scheme in the first place has. However, there may be a way to
mostly avoid those problems for the time being, while also not having any
impact on consensus or standardness rules.

I believe that most new witness programs we'd want to introduce anyway will
be 32 bytes in the future, if the option exists. It's enough for a 256-bit
hash (which has up to 128-bit collision security, and more than 128 bits is
hard to achieve in Bitcoin anyway), or for X coordinates directly. Either
of those, plus a small version number to indicate the commitment structure
should be enough to encode any spendability condition we'd want with any
achievable security level.

With that observation, I propose the following. We amend BIP173 to be
restricted to witness programs of length 20 or 32 (but still support
versions other than 0). This seems like it may be sufficient for several
years, until version numbers run out. I believe that some wallet
implementations already restrict sending to known versions only, which
means effectively no change for them in addition to normal deployment.

In the mean time we develop a variant of bech32 with better
insertion/erasure detecting properties, which will be used for witness
programs of length different from 20 or 32. If we make sure that there are
never two distinct valid checksum algorithms for the same output, I don't
believe there is any need for a new address scheme or a different HRP. The
latter is something I'd strongly try to avoid anyway, as it would mean
additional cognitive load on users because of another visually distinct
address style, plus more logistical overhead (coordination and keeping
track of 2 HRPs per chain).

I believe improving bech32 itself is preferable over changing the way
segwit addresses use bech32, as that can be done without making addresses
even longer. Furthermore, the root of the issue is in bech32, and it is
simplest to fix things there. The easiest solution is to simply change the
constant 1 that is xor'ed into the checksum before encoding it to a 30-bit
number. This has the advantage that a single checksum is never valid for
both algoritgms simultaneously. Another approach is to implicitly including
the length into the checksummed data.

What do people think?

Cheers,

-- 
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191110/5894b93f/attachment.html>

From lf-lists at mattcorallo.com  Mon Nov 11 01:02:15 2019
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Mon, 11 Nov 2019 01:02:15 +0000
Subject: [bitcoin-dev] Bech32 weakness and impact on bip-taproot
	addresses
In-Reply-To: <CAPg+sBgus6HgYPVbXaAx51nO2ArsR3-6=obe2AwkO8kh11fB6Q@mail.gmail.com>
References: <CAPg+sBjC-D2iWYywj_X-evQoWx56nb0YnASLVwCSCzWT6Guu3A@mail.gmail.com>
	<20191108021541.n3jk54vucplryrbl@ganymede>
	<CAPg+sBgus6HgYPVbXaAx51nO2ArsR3-6=obe2AwkO8kh11fB6Q@mail.gmail.com>
Message-ID: <611b4e5b-e7cf-adc7-31e1-b5ff24b6574b@mattcorallo.com>

Seems good to me, though I'm curious if we have any (even vaguely)
immediate need for non-32/20-byte Segwit outputs? It seems to me this
can be resolved by just limiting the size of bech32 outputs and calling
it a day - adding yet another address format has very significant
ecosystem costs, and if we don't anticipate needing it for 5 years (if
at all)...lets not jump to pay that cost.

Matt

On 11/10/19 9:51 PM, Pieter Wuille via bitcoin-dev wrote:
> On Thu, Nov 7, 2019, 18:16 David A. Harding <dave at dtrt.org
> <mailto:dave at dtrt.org>> wrote:
> 
>     On Thu, Nov 07, 2019 at 02:35:42PM -0800, Pieter Wuille via
>     bitcoin-dev wrote:
>     > In the current draft, witness v1 outputs of length other
>     > than 32 remain unencumbered, which means that for now such an
>     > insertion or erasure would result in an output that can be spent by
>     > anyone. If that is considered unacceptable, it could be prevented by
>     > for example outlawing v1 witness outputs of length 31 and 33.
> 
>     Either a consensus rule or a standardness rule[1] would require anyone
>     using a bech32 library supporting v1+ segwit to upgrade their library.
>     Otherwise, users of old libraries will still attempt to pay v1 witness
>     outputs of length 31 or 33, causing their transactions to get rejected
>     by newer nodes or get stuck on older nodes.? This is basically the
>     problem #15846[2] was meant to prevent.
> 
>     If we're going to need everyone to upgrade their bech32 libraries
>     anyway, I think it's probably best that the problem is fixed in the
>     bech32 algorithm rather than at the consensus/standardness layer.
> 
> 
> Admittedly, this affecting development of consensus or standardness
> rules would feel unnatural. In addition, it also?has the potential
> downside of breaking batched transactions in some settings (ask an
> exchange for a withdrawal to a invalid/nonstandard version, which they
> batch with other outputs that then get stuck because the transaction
> does not go through).
> 
> So, Ideally this is indeed solved entirely on the bech32/address
> encoding side of things. I?did not initially expect the discussion here
> to go in that direction, as that could come with all problems that
> rolling out a new address scheme in the first place has. However, there
> may be a way to mostly avoid those problems for the time being, while
> also not having any impact on consensus or standardness rules.
> 
> I believe that most new witness programs we'd want to introduce anyway
> will be 32 bytes in the future, if the option exists. It's enough for a
> 256-bit hash (which has up to 128-bit collision security, and more than
> 128 bits is hard to achieve in Bitcoin anyway), or for X coordinates
> directly. Either of those, plus a small version number to indicate the
> commitment structure should be enough to encode any spendability
> condition we'd want with any achievable security level.
> 
> With that observation, I propose the following. We amend BIP173 to be
> restricted to witness programs of length 20 or 32 (but still support
> versions other than 0). This seems like it may be sufficient for several
> years, until version numbers run out. I believe that some wallet
> implementations already restrict sending to known versions only, which
> means effectively no change for them in addition to normal deployment.
> 
> In the mean time we develop a variant of bech32 with better
> insertion/erasure detecting properties, which will be used for witness
> programs of length different from 20 or 32. If we make sure that there
> are never two distinct valid checksum algorithms for the same output, I
> don't believe there is any need for a new address scheme or a different
> HRP. The latter is something I'd strongly try to avoid anyway, as it
> would mean additional cognitive load on users because of another
> visually distinct address style, plus more logistical overhead
> (coordination and keeping track of 2 HRPs per chain).
> 
> I believe improving bech32 itself is preferable over changing the way
> segwit addresses use bech32, as that can be done without making
> addresses even longer. Furthermore, the root of the issue is in bech32,
> and it is simplest to fix things there. The easiest solution is to
> simply change the constant 1 that is xor'ed into the checksum before
> encoding it to a 30-bit number. This has the advantage that a single
> checksum is never valid for both algoritgms simultaneously. Another
> approach is to implicitly including the length into the checksummed data.
> 
> What do people think?
> 
> Cheers,
> 
> --?
> Pieter
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From ZmnSCPxj at protonmail.com  Mon Nov 11 13:52:49 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 11 Nov 2019 13:52:49 +0000
Subject: [bitcoin-dev] Dynamic MaxBlockSize - 3 Byte Solution
In-Reply-To: <CAN+Of7A9pmrhEma49cQ0eP7vn50WxFemAEvztFxhgX2om_8Dpw@mail.gmail.com>
References: <CAN+Of7A9pmrhEma49cQ0eP7vn50WxFemAEvztFxhgX2om_8Dpw@mail.gmail.com>
Message-ID: <P-TJrrShiuEPOOWqGpb2iLL9reReXD_IYPzSM5hB_brQfQORYgo-ALqTTf6aKAqUQimcFU-tpYBVQBlgkRDscJ3OxM43Z-LEsctoaD-gjIk=@protonmail.com>

Several days late, I would like to add my NACK here.

* The actual fees paid to miners are not in fact known.
  Miners may accept side fees that are not explicitly visible on the block, and miners may pad their blocks with faked self-paying transactions.
  Further, such side fees and faked transactions do not modify the economic assumptions of Bitcoin.
  * Mining fees are simply an anonymity technique: what is material economically is that miners are paid for confirming transactions, thus side fees are perfectly fine when considering economic incentives of Bitcoin mining.
  * Without this proposed mechanism, padding blocks with faked self-paying transactions is self-destructive behavior for miners, as the transaction takes up space that cannot be used for actually-paying transactions.
  * However, by computing only using the explicit fees on the block (and not the actual fees that miners actually get), various additional games can be played by miners.
    Such games make considering the overall security of mining much harder and we may end up with worse security due to misaligned incentives, including encouraging miners to pad blocks with faked transactions (which otherwise is discouraged by the current protocol).
* Scaling means getting more impact for less resource consumption.
  ***All*** block size increases are getting more impact for ***more*** resource consumption, thus not scaling.


> Dynamic MaxBlockSize ?- 3 Byte Solution
> "DMBS"
>
> If
> (Last TOTAL Block Trans fees)? > ?(AVG (Last 100 Blocks Trans Fees))
> AND
> current MaxBlockSize ?=> 0.99 MB ?
> AND
> MaxBlockSize has not changed in 10 Blocks
> ** see error catch below
> Then ?
> ON (Current Block # ?+ 9) ?Set MaxBlockSize ?= (MaxBlockSize x 1.1)
> ELSE ?
> AT (Current Block # ?+ 9) ?Set MaxBlockSize ?= (MaxBlockSize ?/ 1.1)
> ELSEIF
> (current MaxBlockSize ?=< 0.99 ?or current MaxBlockSize > 6553.5 MB)
> Null (no action taken)
> **where 9 above represents the ActivateONBlock (software side) Variable
> ?-------------
> We add this 3 Byte Variable Factor to the white space in the Current Block.
>
> eg. ?this 3 byte HEX? ? 19000A
> the first bit "1" ?can be 1,2 or 0 ? ?
> 1 ?= ?increase future block (9 blocks ahead)
> 2 ?decrease future block ?(9 blocks ahead)
> 0 ? ?No Action (rules evaluate to null)
> **where 9 above represents the ActivateONBlock (software side) Variable
> --------------
> The Second bit is a Global Variable "9" represents a countdown to the set value action, placed to synchronize network forward ?changes in "x" blocks. software lowers value if evaluates to True a second time? and so on.?
> ("Count down" if you will)
> the last 2 bytes represent ?the globally accepted "MaxBlockSize" Variable, and is distributed within each block moving forward in this rightmost (2 byte) factor.? In this case above,
> The variable portion ?"000A" (32 Bit value) represents decimal value 10 being 1.0 MB block.
> the decimal place is Always Assumed, and must be hard coded
> Because this presents a ?theoretical ?Max limit of "FFFF" ?or 6553.5 MB, We would
> have to add a last rule "only as a error catch"
> ?** AND IF MaxBlockSize < 6553.5
> ---
> Increasing and decreasing
> On Every Block mined or distributed, the software can run the above rule set, Change the Variable and Distribute the next block " In Synchronized fashion". The above rules when combined evaluate to a YES or NO, This translates to a market reflection of increased system pressure or decreased market pressure. ? I think we can agree, at peak periods the system chokes itself off with fees and this is always only temporarily.? So we can have the block, analyse system demand dynamically, and adjust on a globally agreed rule dynamically by market driven demand.
> Considering the ruleset above also Decreases ?the Block ONLY if its greater than 0.99mb this brings size back to a competitive state /and size once market demand pressures subside, yet achieves the smallest market feasible block size while also maintaining all current rule sets.
> ?An attacker would have to affect all block fees over the last 16 hours worth of transactions to affect a 10% max block size increase but then only after waiting 1.5 hours, so long as nothing has changed in the last 1.5 hours and only for a limited amount of time. This approach also limits bloat. This safety block window of 9 blocks provides a look forward and look behind value, in turn provides the network time to synchronize.
> 10 block sync window.? This, by design, also limits changes to one change? every 3 hours (20 blocks), if there is a market pressure "STATE" occurring.
> My Question to the community is. Will our current Block accommodate the 3 Byte
> Variable, Is solving the Scaling issue worth using the 3 Bytes of space? ?
> I believe it is. ?
> --
> Software, ?Will need ?to Evaluate MaxBlockSize Variable, and ActivateONBlock Variable from the most recent distributed blocks DMBS ?3 byte value.
> Run the rules , get the answer set the now known MaxBlockSize Var and Propegate the "DMBS" value.
>
> As capacity limits are breached, I think the majority agree "we need to agree". ?
>
> MaxBlockSize would provide a suitable middle ground and address concerns in a dynamic fashion, without compromising ?or changing ?existing security.? ?
> ?Examples reflected in the blockchain 19000A? ?rules has evaluates to? true, increase expected in 9 blocks.1.0mb increases to 1.1mb
> if true for 9 more blocks? MaxBlockSize Var becomes? 18000A.. 17000A..,16000A ..and so on if? still true at 10000A var written becomes?
> 00000B when read from left to right,? 0-no change, in 0 blocks current " DMBS" value 000B or 1.1MB? and stays that way? 00000B until MaxBlockSize? evaluates to "True" under a market pressure/ relief situation.?
> I hope this makes sense, I would appreciate some feedback.?
> TG



From hampus.sjoberg at gmail.com  Mon Nov 11 16:08:43 2019
From: hampus.sjoberg at gmail.com (=?UTF-8?Q?Hampus_Sj=C3=B6berg?=)
Date: Mon, 11 Nov 2019 17:08:43 +0100
Subject: [bitcoin-dev] Dynamic MaxBlockSize - 3 Byte Solution
In-Reply-To: <CAL6iL8VwYVpFkZuExpk=7LKGTLxVdQODtZmHnaK4MR0J9McdVQ@mail.gmail.com>
References: <CAN+Of7A9pmrhEma49cQ0eP7vn50WxFemAEvztFxhgX2om_8Dpw@mail.gmail.com>
	<CAL6iL8VwYVpFkZuExpk=7LKGTLxVdQODtZmHnaK4MR0J9McdVQ@mail.gmail.com>
Message-ID: <CAFMkqK9-8GRJWXgYOUHrQtApCQ0WW0beD1xr7+mbAQS6YXY65A@mail.gmail.com>

> 1. We have Lightning and SegWit so thankfully we do not need to deal with
blocksizes anymore really.

Regardless of the current proposal in this email thread, just because we
have Lightning doesn't mean we don't ever have to increase the blocksize
again.
Even with Lightning there would be too many channel open and closes to be
able to handle million users without transaction fees going through the
roof.
I am advocating to keep the blocksize low right now, but I don't leave out
in increasing it in the future when we have a need for it, preferably via
an extension block (softfork).

Hampus

Den fre 8 nov. 2019 kl 15:44 skrev Emil Engler via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org>:

> NACK!
> 1. We have Lightning and SegWit so thankfully we do not need to deal with
> blocksizes anymore really.
> 2. What if a reorg happens? Then it could generate huge problems at the
> validation.
>
> Correct me if I understood it wrong please.
>
> Greetings,
> Emil Engler
>
> Trevor Groves via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
> schrieb am Fr. 8. Nov. 2019 um 15:26:
>
>> Dynamic MaxBlockSize  - 3 Byte Solution
>> "DMBS"
>>
>> If
>> (Last TOTAL Block Trans fees)  >  (AVG (Last 100 Blocks Trans Fees))
>> AND
>> current MaxBlockSize  => 0.99 MB
>> AND
>> MaxBlockSize has not changed in 10 Blocks
>> ** see error catch below
>> Then
>> ON (Current Block #  + 9)  Set MaxBlockSize  = (MaxBlockSize x 1.1)
>> ELSE
>> AT (Current Block #  + 9)  Set MaxBlockSize  = (MaxBlockSize  / 1.1)
>> ELSEIF
>> (current MaxBlockSize  =< 0.99  or current MaxBlockSize > 6553.5 MB)
>> Null (no action taken)
>> **where 9 above represents the ActivateONBlock (software side) Variable
>>  -------------
>> We add this 3 Byte Variable Factor to the white space in the Current
>> Block.
>>
>> eg.  this 3 byte HEX    19000A
>> the first bit "1"  can be 1,2 or 0
>> 1  =  increase future block (9 blocks ahead)
>> 2  decrease future block  (9 blocks ahead)
>> 0    No Action (rules evaluate to null)
>> **where 9 above represents the ActivateONBlock (software side) Variable
>> --------------
>> The Second bit is a Global Variable "9" represents a countdown to the set
>> value action, placed to synchronize network forward  changes in "x" blocks.
>> software lowers value if evaluates to True a second time  and so on.
>> ("Count down" if you will)
>> the last 2 bytes represent  the globally accepted "MaxBlockSize"
>> Variable, and is distributed within each block moving forward in this
>> rightmost (2 byte) factor.  In this case above,
>> The variable portion  "000A" (32 Bit value) represents decimal value 10
>> being 1.0 MB block.
>> the decimal place is Always Assumed, and must be hard coded
>> Because this presents a  theoretical  Max limit of "FFFF"  or 6553.5 MB,
>> We would
>> have to add a last rule "only as a error catch"
>>  ** AND IF MaxBlockSize < 6553.5
>> ---
>> Increasing and decreasing
>> On Every Block mined or distributed, the software can run the above rule
>> set, Change the Variable and Distribute the next block " In Synchronized
>> fashion". The above rules when combined evaluate to a YES or NO, This
>> translates to a market reflection of increased system pressure or decreased
>> market pressure.   I think we can agree, at peak periods the system chokes
>> itself off with fees and this is always only temporarily.  So we can have
>> the block, analyse system demand dynamically, and adjust on a globally
>> agreed rule dynamically by market driven demand.
>> Considering the ruleset above also Decreases  the Block ONLY if its
>> greater than 0.99mb this brings size back to a competitive state /and size
>> once market demand pressures subside, yet achieves the smallest market
>> feasible block size while also maintaining all current rule sets.
>>  An attacker would have to affect all block fees over the last 16 hours
>> worth of transactions to affect a 10% max block size increase but then only
>> after waiting 1.5 hours, so long as nothing has changed in the last 1.5
>> hours and only for a limited amount of time. This approach also limits
>> bloat. This safety block window of 9 blocks provides a look forward and
>> look behind value, in turn provides the network time to synchronize.
>> 10 block sync window.  This, by design, also limits changes to one
>> change  every 3 hours (20 blocks), if there is a market pressure "STATE"
>> occurring.
>> My Question to the community is. Will our current Block accommodate the 3
>> Byte
>> Variable, Is solving the Scaling issue worth using the 3 Bytes of space?
>> I believe it is.
>> --
>> Software,  Will need  to Evaluate MaxBlockSize Variable, and
>> ActivateONBlock Variable from the most recent distributed blocks DMBS  3
>> byte value.
>> Run the rules , get the answer set the now known MaxBlockSize Var and
>> Propegate the "DMBS" value.
>>
>> As capacity limits are breached, I think the majority agree "we need to
>> agree".
>>
>> MaxBlockSize would provide a suitable middle ground and address concerns
>> in a dynamic fashion, without compromising  or changing  existing
>> security.
>>  Examples reflected in the blockchain 19000A   rules has evaluates to
>> true, increase expected in 9 blocks.1.0mb increases to 1.1mb
>> if true for 9 more blocks  MaxBlockSize Var becomes  18000A..
>> 17000A..,16000A ..and so on if  still true at 10000A var written becomes
>> 00000B when read from left to right,  0-no change, in 0 blocks current "
>> DMBS" value 000B or 1.1MB  and stays that way  00000B until MaxBlockSize
>> evaluates to "True" under a market pressure/ relief situation.
>> I hope this makes sense, I would appreciate some feedback.
>> TG
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191111/01e64494/attachment.html>

From luke at dashjr.org  Mon Nov 11 16:47:04 2019
From: luke at dashjr.org (Luke Dashjr)
Date: Mon, 11 Nov 2019 16:47:04 +0000
Subject: [bitcoin-dev] Dynamic MaxBlockSize - 3 Byte Solution
In-Reply-To: <CAFMkqK9-8GRJWXgYOUHrQtApCQ0WW0beD1xr7+mbAQS6YXY65A@mail.gmail.com>
References: <CAN+Of7A9pmrhEma49cQ0eP7vn50WxFemAEvztFxhgX2om_8Dpw@mail.gmail.com>
	<CAL6iL8VwYVpFkZuExpk=7LKGTLxVdQODtZmHnaK4MR0J9McdVQ@mail.gmail.com>
	<CAFMkqK9-8GRJWXgYOUHrQtApCQ0WW0beD1xr7+mbAQS6YXY65A@mail.gmail.com>
Message-ID: <201911111647.06200.luke@dashjr.org>

On Monday 11 November 2019 16:08:43 Hampus Sj?berg via bitcoin-dev wrote:
> I am advocating to keep the blocksize low right now, 

It ISN'T low right now...

> but I don't leave out 
> in increasing it in the future when we have a need for it, preferably via
> an extension block (softfork).

Extension blocks are not softforks, and are unreasonably convoluted for no 
real gain. When the time comes, the block size should be increased only using 
a hardfork.

Luke

From hampus.sjoberg at gmail.com  Mon Nov 11 17:10:16 2019
From: hampus.sjoberg at gmail.com (=?UTF-8?Q?Hampus_Sj=C3=B6berg?=)
Date: Mon, 11 Nov 2019 18:10:16 +0100
Subject: [bitcoin-dev] Dynamic MaxBlockSize - 3 Byte Solution
In-Reply-To: <201911111647.06200.luke@dashjr.org>
References: <CAN+Of7A9pmrhEma49cQ0eP7vn50WxFemAEvztFxhgX2om_8Dpw@mail.gmail.com>
	<CAL6iL8VwYVpFkZuExpk=7LKGTLxVdQODtZmHnaK4MR0J9McdVQ@mail.gmail.com>
	<CAFMkqK9-8GRJWXgYOUHrQtApCQ0WW0beD1xr7+mbAQS6YXY65A@mail.gmail.com>
	<201911111647.06200.luke@dashjr.org>
Message-ID: <CAFMkqK8fuB0BSpVsSnzgBv1WkZx_8Wqi4BQ6dL95PeGExM1nHQ@mail.gmail.com>

> It ISN'T low right now...

I agree, but I don't think it's a good idea to softfork it to lower than 4M
WU though, and I don't think we need to;
hopefully when exchanges start using Lightning or Liquid, avg blocksize
will go down.

> Extension blocks are not softforks, and are unreasonably convoluted for
no
real gain. When the time comes, the block size should be increased only
using
a hardfork.

It depends on how you define soft and hardforks, I suspect you don't see
extension blocks as a softforks because old nodes won't maintain a correct
UTXO set.
I think an extension block is a softfork because old nodes will still be
able to follow the mainchain.

I don't know if a blocksize increase hardfork will get consensus as the
idea has been ruined by all malicious hijack attempts we've seen over the
years.

Hampus

Den m?n 11 nov. 2019 kl 17:47 skrev Luke Dashjr <luke at dashjr.org>:

> On Monday 11 November 2019 16:08:43 Hampus Sj?berg via bitcoin-dev wrote:
> > I am advocating to keep the blocksize low right now,
>
> It ISN'T low right now...
>
> > but I don't leave out
> > in increasing it in the future when we have a need for it, preferably via
> > an extension block (softfork).
>
> Extension blocks are not softforks, and are unreasonably convoluted for no
> real gain. When the time comes, the block size should be increased only
> using
> a hardfork.
>
> Luke
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191111/606aa93f/attachment.html>

From luke at dashjr.org  Mon Nov 11 19:56:15 2019
From: luke at dashjr.org (Luke Dashjr)
Date: Mon, 11 Nov 2019 19:56:15 +0000
Subject: [bitcoin-dev] Dynamic MaxBlockSize - 3 Byte Solution
In-Reply-To: <CAFMkqK8fuB0BSpVsSnzgBv1WkZx_8Wqi4BQ6dL95PeGExM1nHQ@mail.gmail.com>
References: <CAN+Of7A9pmrhEma49cQ0eP7vn50WxFemAEvztFxhgX2om_8Dpw@mail.gmail.com>
	<201911111647.06200.luke@dashjr.org>
	<CAFMkqK8fuB0BSpVsSnzgBv1WkZx_8Wqi4BQ6dL95PeGExM1nHQ@mail.gmail.com>
Message-ID: <201911111956.16782.luke@dashjr.org>

On Monday 11 November 2019 17:10:16 Hampus Sj?berg wrote:
> > It ISN'T low right now...
>
> I agree, but I don't think it's a good idea to softfork it to lower than 4M
> WU though, and I don't think we need to;
> hopefully when exchanges start using Lightning or Liquid, avg blocksize
> will go down.

Not likely, so long as spam continues to pad blocks full.

> > Extension blocks are not softforks, and are unreasonably convoluted for
> no
> real gain. When the time comes, the block size should be increased only
> using
> a hardfork.
>
> It depends on how you define soft and hardforks, I suspect you don't see
> extension blocks as a softforks because old nodes won't maintain a correct
> UTXO set.
> I think an extension block is a softfork because old nodes will still be
> able to follow the mainchain.

Softforks leave old nodes *working*, so yes, maintaining the correct UTXO 
state.

Simply "following" is meaningless, as even soft-hardforks are "followed".

> I don't know if a blocksize increase hardfork will get consensus as the
> idea has been ruined by all malicious hijack attempts we've seen over the
> years.

If there isn't consensus, then it shouldn't be done, period.

Luke

From ee at cypherpunk.org  Tue Nov 12 15:02:09 2019
From: ee at cypherpunk.org (ee at cypherpunk.org)
Date: Tue, 12 Nov 2019 17:02:09 +0200
Subject: [bitcoin-dev] Towards a singular payment protocol
Message-ID: <D5859AF5-CA49-42DF-8FAE-5BBBE2DF6699@cypherpunk.org>

A proposal for a new blockchain-agnostic payment protocol:

https://cypherpunk.org/2019/11/10/towards-a-singular-payment-protocol/

Includes the following characteristics:

- can be used with crypto or fiat currencies
- multiple currency options for a single transaction
- multiple payments in a single transaction
- allow a payment in one currency, but the value to be referenced from a second currency
- fee payment by sender or recipient
- calculation of valuation and fees through common trusted third parties

This is a proposal for a new payment protocol that is not linked to a specific blockchain, and could be supported by many of them, as well as fiat currencies. With one system, wallet developers working on multiple currencies could still look to a single payment system, and thus full support for a single protocol would increase.

I understand that some people will oppose something like this simply because it supports other coins, but I ask that it be looked at from the perspective of a) does it offer better functionality for Bitcoin, and b) would increased support by more wallets for a payment protocol be better for Bitcoin? If those are true, and I think they are, then this can be developed to the benefit of everyone.

This is the first section, focused on the actual payments. Other future sections are planned to include a section on smart contracts and tokens, and a transport mechanism for private communications between buyer and seller.

The goal would be to transform this into a BIP, but I think it needs some discussion first. I would appreciate constructive criticism on the proposal. While I?m open to the argument that payment protocols need to be coin-specific, I think at this point it would be more useful to discuss the functionality first.

Nothing in this section is really blockchain-specific, and the goal would be to keep it that way, and offer the same functionality to everyone.

I thank anyone who takes the time to read this proposal, and I hope to see good feedback on it.

Thank you,

EE


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191112/488872fd/attachment.html>

From clark at clarkmoody.com  Wed Nov 13 02:56:54 2019
From: clark at clarkmoody.com (Clark Moody)
Date: Tue, 12 Nov 2019 20:56:54 -0600
Subject: [bitcoin-dev] Bech32 weakness and impact on bip-taproot
	addresses
In-Reply-To: <611b4e5b-e7cf-adc7-31e1-b5ff24b6574b@mattcorallo.com>
References: <CAPg+sBjC-D2iWYywj_X-evQoWx56nb0YnASLVwCSCzWT6Guu3A@mail.gmail.com>
	<20191108021541.n3jk54vucplryrbl@ganymede>
	<CAPg+sBgus6HgYPVbXaAx51nO2ArsR3-6=obe2AwkO8kh11fB6Q@mail.gmail.com>
	<611b4e5b-e7cf-adc7-31e1-b5ff24b6574b@mattcorallo.com>
Message-ID: <CAHGSxGv_BQAAkdcxsqVsjphqaoE=Xm05jXhdBnGw+m+vRxeQYQ@mail.gmail.com>

I agree on all points. The address space already brings enough confusion to
users out there. As it stands, we can use script version and program length
for address validity. Sneaking an alternate checksum into the mix for
different length programs lets us lean on our parsing libraries and not
increase cognitive load for users.


-Clark


On Sun, Nov 10, 2019 at 7:02 PM Matt Corallo via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Seems good to me, though I'm curious if we have any (even vaguely)
> immediate need for non-32/20-byte Segwit outputs? It seems to me this
> can be resolved by just limiting the size of bech32 outputs and calling
> it a day - adding yet another address format has very significant
> ecosystem costs, and if we don't anticipate needing it for 5 years (if
> at all)...lets not jump to pay that cost.
>
> Matt
>
> On 11/10/19 9:51 PM, Pieter Wuille via bitcoin-dev wrote:
> > On Thu, Nov 7, 2019, 18:16 David A. Harding <dave at dtrt.org
> > <mailto:dave at dtrt.org>> wrote:
> >
> >     On Thu, Nov 07, 2019 at 02:35:42PM -0800, Pieter Wuille via
> >     bitcoin-dev wrote:
> >     > In the current draft, witness v1 outputs of length other
> >     > than 32 remain unencumbered, which means that for now such an
> >     > insertion or erasure would result in an output that can be spent by
> >     > anyone. If that is considered unacceptable, it could be prevented
> by
> >     > for example outlawing v1 witness outputs of length 31 and 33.
> >
> >     Either a consensus rule or a standardness rule[1] would require
> anyone
> >     using a bech32 library supporting v1+ segwit to upgrade their
> library.
> >     Otherwise, users of old libraries will still attempt to pay v1
> witness
> >     outputs of length 31 or 33, causing their transactions to get
> rejected
> >     by newer nodes or get stuck on older nodes.  This is basically the
> >     problem #15846[2] was meant to prevent.
> >
> >     If we're going to need everyone to upgrade their bech32 libraries
> >     anyway, I think it's probably best that the problem is fixed in the
> >     bech32 algorithm rather than at the consensus/standardness layer.
> >
> >
> > Admittedly, this affecting development of consensus or standardness
> > rules would feel unnatural. In addition, it also has the potential
> > downside of breaking batched transactions in some settings (ask an
> > exchange for a withdrawal to a invalid/nonstandard version, which they
> > batch with other outputs that then get stuck because the transaction
> > does not go through).
> >
> > So, Ideally this is indeed solved entirely on the bech32/address
> > encoding side of things. I did not initially expect the discussion here
> > to go in that direction, as that could come with all problems that
> > rolling out a new address scheme in the first place has. However, there
> > may be a way to mostly avoid those problems for the time being, while
> > also not having any impact on consensus or standardness rules.
> >
> > I believe that most new witness programs we'd want to introduce anyway
> > will be 32 bytes in the future, if the option exists. It's enough for a
> > 256-bit hash (which has up to 128-bit collision security, and more than
> > 128 bits is hard to achieve in Bitcoin anyway), or for X coordinates
> > directly. Either of those, plus a small version number to indicate the
> > commitment structure should be enough to encode any spendability
> > condition we'd want with any achievable security level.
> >
> > With that observation, I propose the following. We amend BIP173 to be
> > restricted to witness programs of length 20 or 32 (but still support
> > versions other than 0). This seems like it may be sufficient for several
> > years, until version numbers run out. I believe that some wallet
> > implementations already restrict sending to known versions only, which
> > means effectively no change for them in addition to normal deployment.
> >
> > In the mean time we develop a variant of bech32 with better
> > insertion/erasure detecting properties, which will be used for witness
> > programs of length different from 20 or 32. If we make sure that there
> > are never two distinct valid checksum algorithms for the same output, I
> > don't believe there is any need for a new address scheme or a different
> > HRP. The latter is something I'd strongly try to avoid anyway, as it
> > would mean additional cognitive load on users because of another
> > visually distinct address style, plus more logistical overhead
> > (coordination and keeping track of 2 HRPs per chain).
> >
> > I believe improving bech32 itself is preferable over changing the way
> > segwit addresses use bech32, as that can be done without making
> > addresses even longer. Furthermore, the root of the issue is in bech32,
> > and it is simplest to fix things there. The easiest solution is to
> > simply change the constant 1 that is xor'ed into the checksum before
> > encoding it to a 30-bit number. This has the advantage that a single
> > checksum is never valid for both algoritgms simultaneously. Another
> > approach is to implicitly including the length into the checksummed data.
> >
> > What do people think?
> >
> > Cheers,
> >
> > --
> > Pieter
> >
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191112/a92d5501/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Wed Nov 13 05:32:32 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 13 Nov 2019 05:32:32 +0000
Subject: [bitcoin-dev] Bech32 weakness and impact on bip-taproot
	addresses
In-Reply-To: <CAHGSxGv_BQAAkdcxsqVsjphqaoE=Xm05jXhdBnGw+m+vRxeQYQ@mail.gmail.com>
References: <CAPg+sBjC-D2iWYywj_X-evQoWx56nb0YnASLVwCSCzWT6Guu3A@mail.gmail.com>
	<20191108021541.n3jk54vucplryrbl@ganymede>
	<CAPg+sBgus6HgYPVbXaAx51nO2ArsR3-6=obe2AwkO8kh11fB6Q@mail.gmail.com>
	<611b4e5b-e7cf-adc7-31e1-b5ff24b6574b@mattcorallo.com>
	<CAHGSxGv_BQAAkdcxsqVsjphqaoE=Xm05jXhdBnGw+m+vRxeQYQ@mail.gmail.com>
Message-ID: <2sU6YozN9nn30cofkAMhffgjDLZwjG3mvF0nBgOsVQQEY9ROmP72GuHWjnBlF_qa8eeQPU8bxleZqcvRGJgS-uJ2xWYmAm9HjrFWWx_9o8k=@protonmail.com>

Good morning all,

It seems to me that adding the length for checksumming purposes need not require the length to be *actually* added in the address format.

So, currently, below is my understanding of bech32 validation:

* Run BCH checksum on witness program.
* Compare checksum to checksum in address.
  * If the checksum matches:
    * If version is 0, validate that the witness program is length 20 or 32.
    * Else accept.
  * If the checksum does not match:
    * Reject

Let me propose then:

* Run BCH checksum on witness program.
* Compare checksum to checksum in address.
  * If the checksum matches:
    * If version is 0, validate that the witness program is length 20 or 32.
    * Else validate that the witness program is length 32.
  * If the checksum does not match:
    * Get the length of the witness program.
    * Prepend the length to the witness program.
    * Run BCH checksum on concatenated length | witness program.
    * Compare checksum to checksum in address.
      * If the checksum matches:
        * Accept.
      * Else reject.

A writer of bech32 addresses would then:

* If the witness program is length 32, or witness version is 0 and witness program length is 20, use a non-length-prefixed checksum.
* Otherwise, use a length-prefixed checksum (but not include the length in the address, just change the BCH checksum).

This has the following properties:

* The bech32 address format is retained, and no explicit length is added.
* There are now two checksum formats: one with just the witness program, the other which validates with the witness program length.
  * Readers that do not understand the new checksum format will simply reject them without mis-sending to the wrong witness program.

Is the above acceptable?

Regards,
ZmnSCPxj


From pieter.wuille at gmail.com  Wed Nov 13 06:30:18 2019
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Tue, 12 Nov 2019 22:30:18 -0800
Subject: [bitcoin-dev] Bech32 weakness and impact on bip-taproot
	addresses
In-Reply-To: <2sU6YozN9nn30cofkAMhffgjDLZwjG3mvF0nBgOsVQQEY9ROmP72GuHWjnBlF_qa8eeQPU8bxleZqcvRGJgS-uJ2xWYmAm9HjrFWWx_9o8k=@protonmail.com>
References: <CAPg+sBjC-D2iWYywj_X-evQoWx56nb0YnASLVwCSCzWT6Guu3A@mail.gmail.com>
	<20191108021541.n3jk54vucplryrbl@ganymede>
	<CAPg+sBgus6HgYPVbXaAx51nO2ArsR3-6=obe2AwkO8kh11fB6Q@mail.gmail.com>
	<611b4e5b-e7cf-adc7-31e1-b5ff24b6574b@mattcorallo.com>
	<CAHGSxGv_BQAAkdcxsqVsjphqaoE=Xm05jXhdBnGw+m+vRxeQYQ@mail.gmail.com>
	<2sU6YozN9nn30cofkAMhffgjDLZwjG3mvF0nBgOsVQQEY9ROmP72GuHWjnBlF_qa8eeQPU8bxleZqcvRGJgS-uJ2xWYmAm9HjrFWWx_9o8k=@protonmail.com>
Message-ID: <CAPg+sBio_8vT9NNp39rz7m+omfaRs0Mf6JkET1=caoVwvziJSA@mail.gmail.com>

On Tue, Nov 12, 2019, 21:33 ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Good morning all,
>
> It seems to me that adding the length for checksumming purposes need not
> require the length to be *actually* added in the address format.
>

Indeed!

This has the following properties:
>
> * The bech32 address format is retained, and no explicit length is added.
> * There are now two checksum formats: one with just the witness program,
> the other which validates with the witness program length.
>   * Readers that do not understand the new checksum format will simply
> reject them without mis-sending to the wrong witness program.
>

That's very close to what I was suggesting: create an improved bech32
algorithm and use that for future addresses, rather than working around the
problem in the address encoding while keeping the existing bech32 checksum.
Sorry if that wasn't clear from my previous email.

In this case, there is no need to even implicitly include the length in the
checksum algorithm. Replacing the "xor 1" at the end of the algorithm to
"xor (2^30 - 1)" would reduce the occurrence of this weakness from 1/32 to
1/2^30, and have no downsides otherwise. I'd like to do some analysis to
ascertain it actually will catch any other kind of insertion/deletion
errors with high probability as well before actually proposing it, though.

There are other solutions which do include the length in some fashion
directly in the checksum calculation, which may be preferable (I need to
analyse things...). It's also possible to do this in such a way that for
33-symbol and 53-symbol data parts (corresponding to P2WPKH and P2WSH
lengths) the new algorithm is defined as identical to the old one. That
would simplify upstream users of a bech32 library (which would then
effectively need no changes at all, apart from updating the
checksum/decoder code).

That brings me to Matt's point: there is no need to do this right now. We
can simply amend BIP173 to only permit length 20 and length 32 (and only
length 20 for v0, if you like; but they're so far apart that permitting
both shouldn't hurt), for now. Introducing the "new" address format (the
one using an improved checksum algorithm) only needs to be there in time
for when a non-32-byte-witness-program would come in sight.

Of course, I should update BIP173 to indicate the issue, and have a
suggested improvement for other users of bech32, if they feel this issue is
significant enough.

Cheers,

-- 
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191112/936e319a/attachment.html>

From b.dewaal at northernbitcoin.com  Wed Nov 13 08:52:19 2019
From: b.dewaal at northernbitcoin.com (Ben Dewaal)
Date: Wed, 13 Nov 2019 08:52:19 +0000
Subject: [bitcoin-dev] Towards a singular payment protocol
In-Reply-To: <D5859AF5-CA49-42DF-8FAE-5BBBE2DF6699@cypherpunk.org>
References: <D5859AF5-CA49-42DF-8FAE-5BBBE2DF6699@cypherpunk.org>
Message-ID: <FRXPR01MB04543D16EA2749E6900E8C5B81760@FRXPR01MB0454.DEUPRD01.PROD.OUTLOOK.DE>

I really don't see any merit to this idea.  To keep the reply brief, here's three of the larger problems I see with it:

1. Other schemes will still exist and aren't likely to be deprecated.  All this proposal is doing is adding one /more/ scheme for wallet developers to support.  It doesn't make their lives any easier.

2. Beyond basic payments, these kinds of simple URI scheme aren't going to be enough anyway.  As we build more complex payment systems with more advanced features, we'll find these kinds of schemes less and less suitable as they grow in the number and complexity of attributes we need to include.  It's just not future-proof, even in the short term.

3. I don't see any reasonable way to define the attributes and what developers should do when their software encounters something it doesn't understand.  It'd either be too strict so that no one implements it, or become a nightmare of incompatible and misunderstood implementations that you never trust your wallet is going to interpret how the URI creator intended.

Regards,
Ben
-- 

From ee at cypherpunk.org  Wed Nov 13 17:49:05 2019
From: ee at cypherpunk.org (EE)
Date: Wed, 13 Nov 2019 19:49:05 +0200
Subject: [bitcoin-dev] Towards a singular payment protocol
In-Reply-To: <FRXPR01MB04543D16EA2749E6900E8C5B81760@FRXPR01MB0454.DEUPRD01.PROD.OUTLOOK.DE>
References: <D5859AF5-CA49-42DF-8FAE-5BBBE2DF6699@cypherpunk.org>
	<FRXPR01MB04543D16EA2749E6900E8C5B81760@FRXPR01MB0454.DEUPRD01.PROD.OUTLOOK.DE>
Message-ID: <FE599986-C494-4473-8AFE-4250BB2533B3@cypherpunk.org>

Ben,

Thank you for your comments. Let me take a stab.

> On 13 Nov 2019, at 10:52 AM, Ben Dewaal <b.dewaal at northernbitcoin.com> wrote:
> 
> I really don't see any merit to this idea.  To keep the reply brief, here's three of the larger problems I see with it:
> 
> 1. Other schemes will still exist and aren't likely to be deprecated.  All this proposal is doing is adding one /more/ scheme for wallet developers to support.  It doesn't make their lives any easier.

To be fully realized, clearly it would be best to have the others depreciated. I would argue almost no existing standard is fully implemented in any wallet. I?m not even sure that BIP-21 is fully implemented ? which wallets include the req- option for example? Most implementations of the Ethereum standards are incomplete, and I haven?t seen anyone implement BUIP-86 for BCH yet (and its creator is working on BSV anyways). BIP-70 was just depreciated by Bitcoin Core, and its future is iffy (perhaps rightly so for having privacy problems). Part of the problem here is that these are under supported, and because they are different, it takes longer for wallet developers to implement. Keeping track of multiple standards is difficult for developers as well. The idea here is to get the major proposed standards (BIP-21, BIP-70-75, ERC-67, EIP-681, EIP-831, BUIP-86, etc. see my background article https://cypherpunk.org/2019/11/02/a-look-at-cryptocurrency-uris/ that goes further into what already exists) to merge into a single standard used by everyone. This helps everyone, and allows efforts to be focused on a single standard. I think it?s a mistake to say that the payment protocol is part of the blockchain and needs to be developed in tandem with it. In almost every way, it is not part of the blockchain, and is a layer above it. This is a chance to step back from what has been done here, take what is good, drop what is not, and move forward with a single protocol. If Bitcoin developers agree, I imagine other blockchain developers will also agree, and a common system can be developed.

> 2. Beyond basic payments, these kinds of simple URI scheme aren't going to be enough anyway.  As we build more complex payment systems with more advanced features, we'll find these kinds of schemes less and less suitable as they grow in the number and complexity of attributes we need to include.  It's just not future-proof, even in the short term.

As mentioned, this is really the first section of a larger system, the basic payments section. This could be thought of as the basis of the first BIP, and then additional BIPs would be added that are dependent on this one. However, getting this right is key to existing payments that use QR and NFC, and the changes described bring a lot of nice functionality (like being able to ask for payment in one currency based on the value of a second one).

> 3. I don't see any reasonable way to define the attributes and what developers should do when their software encounters something it doesn't understand.  It'd either be too strict so that no one implements it, or become a nightmare of incompatible and misunderstood implementations that you never trust your wallet is going to interpret how the URI creator intended.

I don?t think this is too difficult to define. If there are things that are difficult to interpret, then we can fix them before standardizing. Part of the problem with some of the existing efforts is the sparse standard documents that defined them, leaving things open to interpretation. A well written spec should be able to foresee issues of conflict and design around them.

There could also be different levels of support for this proposal, like 'pay: simple' that supports single payments, 'pay: multi' that supports multiple payments, etc. I?m not sure it?s necessary to do that, but this kind of break down would allow wallets and payment processors to explain exactly what they support without the current confusion where no one really knows which parts of which standards are supported. As they add support for other sets of features, they could announce the additional support.

The end-goal would be that wallets and payment systems would fully support this standard, and be able to say something like 'pay:' supported, and perhaps the other sections would be considered add-ons that could also be used. For example, a merchant could have an NFC terminal with a pay: logo on it. Tap your phone and get the pay: URI sent to your phone, to be processed by your wallet. If the section I?m working on that will discuss a private communication method is also supported by the merchant, the logo might show an additional icon to show that support, and the two-way functionality will be supported (allowing you to confirm things interactively). This is the beginning of a process to figure out these issues and develop a plan to address them.

> Regards,
> Ben

Thank you,

EE

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191113/8cf5f4c5/attachment.html>

From b.dewaal at northernbitcoin.com  Thu Nov 14 12:31:44 2019
From: b.dewaal at northernbitcoin.com (Ben Dewaal)
Date: Thu, 14 Nov 2019 12:31:44 +0000
Subject: [bitcoin-dev] Towards a singular payment protocol
In-Reply-To: <FE599986-C494-4473-8AFE-4250BB2533B3@cypherpunk.org>
References: <D5859AF5-CA49-42DF-8FAE-5BBBE2DF6699@cypherpunk.org>
	<FRXPR01MB04543D16EA2749E6900E8C5B81760@FRXPR01MB0454.DEUPRD01.PROD.OUTLOOK.DE>,
	<FE599986-C494-4473-8AFE-4250BB2533B3@cypherpunk.org>
Message-ID: <FRXPR01MB0454349170173F4A05B14E4C81710@FRXPR01MB0454.DEUPRD01.PROD.OUTLOOK.DE>

On 13 Nov 2019, at 18:49, EE wrote:

> To be fully realized, clearly it would be best to have the others depreciated.

And I'd argue that others won't be deprecated without a strong reason to switch. Bitcoin is an open protocol and no individual gets to dictate "the right way".  Just because something makes it in to a draft BIP, it doesn't mean it's going to be agreed or implemented.

>  I would argue almost no existing standard is fully implemented in any wallet.

This may be the case, but for Bitcoin at least, BIP-21 is relatively well standardised even if not fully implemented by everyone.  That said, I think most wallet developers - including myself and my team - would rather keep things simple until we see a clear way to proceed.  My current expectation is to support BOLT11 with BIP-21 fallback, plus BIP-21 standalone.  We're building a Bitcoin wallet, not a "cryptocurrency" wallet, so the complexities and difficulties that are faced by things other than Bitcoin really aren't a concern to me.

> BIP-70 was just depreciated by Bitcoin Core

Just to nitpick: BIP-70 was just deprecated *in* Bitcoin Core.  Again, see above where no individual gets to dictate those sorts of things.

> Part of the problem here is that these are under supported, and because they are different, it takes longer for wallet developers to implement.

This works on the assumption of people building cryptocurrency wallets rather than Bitcoin wallets.  I reject the idea that that basic assumption has any merit to it since in practical terms I see no push towards adoption of anything other than Bitcoin, and in theoretical terms, I see no way that anything other than Bitcoin will continue to exist over the mid to long term.  Spending effort to add standards to Bitcoin that bring no benefit to Bitcoin simply seems like a waste of time.

> I think it?s a mistake to say that the payment protocol is part of the blockchain and needs to be developed in tandem with it. In almost every way, it is not part of the blockchain, and is a layer above it.

Here, we agree.  Payments are indeed separate to the underlying technology.  The Lightning Network is a payment network and can be used with other blockchains (assuming you're willing to trust their fundamentally flawed security models).  With this in mind, why define a new standard when those other projects could just start using Lightning and take advantage of its invoice standard?

> the changes described bring a lot of nice functionality (like being able to ask for payment in one currency based on the value of a second one).

I don't understand the value of this.  Right now, I use Bitcoin exclusively, but goods are services around me are (usually) priced in euro.  The merchant will quote a price in euro and their system will ask me to pay in Bitcoin.  My wallet will then display this to me with an equivalent euro value.  It may differ slightly due to different exchange rate providers being called, but I am clear on what I need to pay and have an idea of whether it accords to the listed price of the item.
If however as you suggest, the merchant were to provide a payment request for ?5.00 in BTC, then they'd be reliant on my exchange rate provider to pay them.  What if they don't accept what my wallet then says?  It's adding confusion and complexity where that's neither needed nor wanted.  The current behaviour is superior to that.

> I don?t think this is too difficult to define.
> A well written spec should be able to foresee issues of conflict and design around them.

I don't have that level of optimism.  You're talking about a very broad array of different systems each with their own unique features, metadata, and expected two-way communication steps.  It feels to me like you're trying to shoehorn too much in to one thing and would end up with the worst of all possible worlds as the result.

I'm sorry for the quite negative-sounding answer here, but as my team is in the process of building a wallet, I'm strongly against proposals that - if adopted - would add complexity to our work without any obvious benefits to us.  I feel like Lightning invoices and the current discussions around enhancements and improvements in them are more than sufficient to cover our needs for the foreseeable future and beyond that I'd prefer solutions built on top of that than something built with complexity that I see as entirely unnecessary.

Regards,
Ben
-- 

From kroozbi at gmail.com  Fri Nov 15 22:29:01 2019
From: kroozbi at gmail.com (Ian Kroozbi)
Date: Fri, 15 Nov 2019 16:29:01 -0600
Subject: [bitcoin-dev] PSBT_GLOBAL_XPUB: Version bytes in xpub
Message-ID: <CALwkCwwGAwRE4vTPJJObr7q1GqS+d9==DBJc+yRZ+chC+_59SA@mail.gmail.com>

What?s the rational for including the version bytes in the xpub in the
GLOBAL_XPUB field? This was briefly touched upon in an earlier email from
Stepan, but I don?t think it was every fully addressed.

I am not sure if we need the whole xpub or keeping chain_code and
> public_key is enough, but I would suggest to keep other data
> just in case. For example, keeping prefix that defines if the key is used
> for testnet or mainnet may be useful.
>

The version bytes seem to be superfluous data considering the transaction
format and the rest of the PSBT key-values are network agnostic. If we
wanted to attach network data to the PSBT then I think that would be better
served by using a new key.

There is also a potential issue where we could have conflicting versions on
different xpubs in the PSBT. If we remove the version bytes then we can
eliminate this possibility.

I haven?t formed an opinion on whether or not the other data outside of the
public key and chain code should be included, but I think it would be good
to discuss any rational for either including it or omitting it.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191115/b63c95c8/attachment.html>

From achow101-lists at achow101.com  Sat Nov 16 04:54:49 2019
From: achow101-lists at achow101.com (Andrew Chow)
Date: Sat, 16 Nov 2019 04:54:49 +0000
Subject: [bitcoin-dev] PSBT_GLOBAL_XPUB: Version bytes in xpub
In-Reply-To: <CALwkCwwGAwRE4vTPJJObr7q1GqS+d9==DBJc+yRZ+chC+_59SA@mail.gmail.com>
References: <CALwkCwwGAwRE4vTPJJObr7q1GqS+d9==DBJc+yRZ+chC+_59SA@mail.gmail.com>
Message-ID: <818abbe7-518e-0927-946b-d8a99e75327b@achow101.com>

The rationale was that xpubs was already a predefined standard which many software already have serialization code for. It's simpler to just reuse what has been defined before.

IMO, the version bytes don't matter and should be ignored. In the proposed implementation to Bitcoin Core, the version bytes are ignored.

Andrew

On 11/15/19 5:29 PM, Ian Kroozbi via bitcoin-dev wrote:

> What?s the rational for including the version bytes in the xpub in the GLOBAL_XPUB field? This was briefly touched upon in an earlier email from Stepan, but I don?t think it was every fully addressed.
>
>> I am not sure if we need the whole xpub or keeping chain_code and
>> public_key is enough, but I would suggest to keep other data
>> just in case. For example, keeping prefix that defines if the key is used
>> for testnet or mainnet may be useful.
>
> The version bytes seem to be superfluous data considering the transaction format and the rest of the PSBT key-values are network agnostic. If we wanted to attach network data to the PSBT then I think that would be better served by using a new key.
>
> There is also a potential issue where we could have conflicting versions on different xpubs in the PSBT. If we remove the version bytes then we can eliminate this possibility.
>
> I haven?t formed an opinion on whether or not the other data outside of the public key and chain code should be included, but I think it would be good to discuss any rational for either including it or omitting it.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191116/7cfb25e7/attachment.html>

From lee.chiffre at secmail.pro  Sun Nov 17 04:33:31 2019
From: lee.chiffre at secmail.pro (Mr. Lee Chiffre)
Date: Sat, 16 Nov 2019 20:33:31 -0800
Subject: [bitcoin-dev] v3 onion services
Message-ID: <8fd4e30c4c1c24442686dd51727e75cc.squirrel@giyzk7o6dcunb2ry.onion>

Right now bitcoin client core supports use of tor hidden service. It
supports v2 hidden service. I am in progress of creating a new bitcoin
node which will use v3 hidden service instead of v2. I am looking at
bitcoin core and btcd to use. Do any of these or current node software
support the v3 onion addresses for the node address? What about I2P
addresses? If not what will it take to get it to support the longer
addresses that is used by i2p and tor v3?


-- 
lee.chiffre at secmail.pro
PGP 97F0C3AE985A191DA0556BCAA82529E2025BDE35


From s7r at sky-ip.org  Sun Nov 17 15:35:16 2019
From: s7r at sky-ip.org (s7r)
Date: Sun, 17 Nov 2019 17:35:16 +0200
Subject: [bitcoin-dev] v3 onion services
In-Reply-To: <8fd4e30c4c1c24442686dd51727e75cc.squirrel@giyzk7o6dcunb2ry.onion>
References: <8fd4e30c4c1c24442686dd51727e75cc.squirrel@giyzk7o6dcunb2ry.onion>
Message-ID: <c1371845-ef3e-c73b-f358-a0470bb48d07@sky-ip.org>

Mr. Lee Chiffre via bitcoin-dev wrote:
> Right now bitcoin client core supports use of tor hidden service. It
> supports v2 hidden service. I am in progress of creating a new bitcoin
> node which will use v3 hidden service instead of v2. I am looking at
> bitcoin core and btcd to use. Do any of these or current node software
> support the v3 onion addresses for the node address? What about I2P
> addresses? If not what will it take to get it to support the longer
> addresses that is used by i2p and tor v3?
> 
> 

Hello,

Yes, that is correct. Currently at present moment only v2 onion services
are supported. Bitcoin Core is limited at 128 bit 'addresses' in the p2p
protocol, so it requires a rework of the p2p protocol. v3 onion services
are whole ed25519 public keys, base32 encoded with .onion at the end.

Same reason applies to I2P 'address types' as well. However, I am not an
expert in I2P and don't actually know how many bitcoin full nodes might
exist in I2P.

See:
https://github.com/bitcoin/bitcoin/issues/9214

https://github.com/bitcoin/bitcoin/issues/2091


For the default `ADD_ONION` feature, the onion service key was
downgraded to explicitly RSA1024 (legacy, v2 onion services) to ensure
the feature still works out of the box:

https://github.com/bitcoin/bitcoin/pull/9234

If you want a Tor only full node, you are best to use v2 onion services
for now. Why do you need the bitcoin node to explicitly have a v3 onion
address? You can have a service that is accessible to the general public
as a v3 onion service, and in the back uses a bitcoin full node that
uses v2 onion service to talk to other nodes. The v2 onion service
bitcoin network is extended fairly.

You can use in the same torrc (Tor configuration file), implicitly same
Tor process/daemon simultaneously v2 and v3 onion services by setting
HiddenServiceVersion parameter after every HiddenServiceDir parameter.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191117/5a13ed1e/attachment.sig>

From willtech at live.com.au  Sun Nov 17 20:04:04 2019
From: willtech at live.com.au (LORD HIS EXCELLENCY JAMES HRMH)
Date: Sun, 17 Nov 2019 20:04:04 +0000
Subject: [bitcoin-dev] v3 onion services
In-Reply-To: <c1371845-ef3e-c73b-f358-a0470bb48d07@sky-ip.org>
References: <8fd4e30c4c1c24442686dd51727e75cc.squirrel@giyzk7o6dcunb2ry.onion>,
 <c1371845-ef3e-c73b-f358-a0470bb48d07@sky-ip.org>
Message-ID: <PS2P216MB01798627A61D2214FB3ED0D79D720@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>

For those perhaps not so well versed in the operation of Bitcoin (and Bitcoin Core) with Tor, connectivity through the outgoing connection to other nodes is all accomplished via the socks5 proxy which enables all current gossip and the distribution of the nodes own transactions to other nodes. This is a full connectivity feature.

For listening, Bitcoin Core instructs Tor to create an ephemeral hidden service which, depending on the various factors, may be currently v2 only or v3 (future implementation). This is not necessary for the functionality of node connectivity in any way and is only used to allow for hidden listening so that other nodes connecting out on the onion can connect privately without hopping on the public internet at all and without exposing the nodes public IP or ports as listening (no port forwarding required and no listing on nodes list with public IP). It is currently possible for many nodes to exist as onion only nodes.

For the time being, although I did wonder myself, the use of v3 ephemeral service is not a requirement of operation on Bitcoin and hardly adds anything to security especially if we enable transient onion listening (a feature proposal is currently waiting for consideration/approval on bitcoin-core-dev and GitHub), however, eventually it will be essential to make use of the v3 ephemeral service as the v2 service support will, as I understand, eventually be dropped from the Tor network. I do not know if there are any current distinct plans.

My opinion is, v3 support is a nice idea but hardly urgent yet. Good luck if it ends up with an ack as I suspect some of the changes required will be complex and this may be perhaps the best reason to begin on it while there is interest.

Regards,
LORD HIS EXCELLENCY JAMES HRMH

________________________________
From: bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of s7r via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
Sent: Monday, 18 November 2019 2:35 AM
To: Mr. Lee Chiffre <lee.chiffre at secmail.pro>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>
Subject: Re: [bitcoin-dev] v3 onion services

Mr. Lee Chiffre via bitcoin-dev wrote:
> Right now bitcoin client core supports use of tor hidden service. It
> supports v2 hidden service. I am in progress of creating a new bitcoin
> node which will use v3 hidden service instead of v2. I am looking at
> bitcoin core and btcd to use. Do any of these or current node software
> support the v3 onion addresses for the node address? What about I2P
> addresses? If not what will it take to get it to support the longer
> addresses that is used by i2p and tor v3?
>
>

Hello,

Yes, that is correct. Currently at present moment only v2 onion services
are supported. Bitcoin Core is limited at 128 bit 'addresses' in the p2p
protocol, so it requires a rework of the p2p protocol. v3 onion services
are whole ed25519 public keys, base32 encoded with .onion at the end.

Same reason applies to I2P 'address types' as well. However, I am not an
expert in I2P and don't actually know how many bitcoin full nodes might
exist in I2P.

See:
https://github.com/bitcoin/bitcoin/issues/9214

https://github.com/bitcoin/bitcoin/issues/2091


For the default `ADD_ONION` feature, the onion service key was
downgraded to explicitly RSA1024 (legacy, v2 onion services) to ensure
the feature still works out of the box:

https://github.com/bitcoin/bitcoin/pull/9234

If you want a Tor only full node, you are best to use v2 onion services
for now. Why do you need the bitcoin node to explicitly have a v3 onion
address? You can have a service that is accessible to the general public
as a v3 onion service, and in the back uses a bitcoin full node that
uses v2 onion service to talk to other nodes. The v2 onion service
bitcoin network is extended fairly.

You can use in the same torrc (Tor configuration file), implicitly same
Tor process/daemon simultaneously v2 and v3 onion services by setting
HiddenServiceVersion parameter after every HiddenServiceDir parameter.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191117/d4a1d20f/attachment.html>

From ChristopherA at lifewithalacrity.com  Sun Nov 17 23:01:23 2019
From: ChristopherA at lifewithalacrity.com (Christopher Allen)
Date: Sun, 17 Nov 2019 15:01:23 -0800
Subject: [bitcoin-dev] v3 onion services
In-Reply-To: <PS2P216MB01798627A61D2214FB3ED0D79D720@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
References: <8fd4e30c4c1c24442686dd51727e75cc.squirrel@giyzk7o6dcunb2ry.onion>
 <c1371845-ef3e-c73b-f358-a0470bb48d07@sky-ip.org>
 <PS2P216MB01798627A61D2214FB3ED0D79D720@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
Message-ID: <CACrqygB779UgCfr=BEUs_zsQeO=btdnEHbxaxEVwvqo9i3jBKw@mail.gmail.com>

Blockchain Commons is using v3 tor authentication for remote clients
controlling a full node created using our Bitcoin Standup project
(currently only macOS but more platforms coming):
https://github.com/BlockchainCommons/Bitcoin-Standup

Docs at:
https://github.com/BlockchainCommons/Bitcoin-Standup#tor-v3-authentication-using-standup-and-fullynoded


Video demonstrating securing remote connection of a full node to the iOS
wallet Fully Noded: https://youtu.be/pSm2VftTCBI

More details on v3 authentication at:
https://github.com/AnarchoTechNYC/meta/wiki/Connecting-to-an-authenticated-Onion-service#connecting-to-authenticated-version-3-onion-services

? Christopher Allen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191117/bcf562f0/attachment-0001.html>

From lf-lists at mattcorallo.com  Sun Nov 17 23:42:03 2019
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Sun, 17 Nov 2019 18:42:03 -0500
Subject: [bitcoin-dev] v3 onion services
In-Reply-To: <8fd4e30c4c1c24442686dd51727e75cc.squirrel@giyzk7o6dcunb2ry.onion>
References: <8fd4e30c4c1c24442686dd51727e75cc.squirrel@giyzk7o6dcunb2ry.onion>
Message-ID: <5E1011A2-9FDD-4FFF-B5AF-B35B7C375A5E@mattcorallo.com>

There is effort ongoing to upgrade the Bitcoin P2P protocol to support other address types, including onion v3. There are various posts on this ML under the title ?addrv2?. Further review and contributions to that effort is, as always, welcome.

> On Nov 17, 2019, at 00:05, Mr. Lee Chiffre via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> ?Right now bitcoin client core supports use of tor hidden service. It
> supports v2 hidden service. I am in progress of creating a new bitcoin
> node which will use v3 hidden service instead of v2. I am looking at
> bitcoin core and btcd to use. Do any of these or current node software
> support the v3 onion addresses for the node address? What about I2P
> addresses? If not what will it take to get it to support the longer
> addresses that is used by i2p and tor v3?
> 
> 
> -- 
> lee.chiffre at secmail.pro
> PGP 97F0C3AE985A191DA0556BCAA82529E2025BDE35
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From vitteaymeric at gmail.com  Mon Nov 18 11:59:03 2019
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Mon, 18 Nov 2019 12:59:03 +0100
Subject: [bitcoin-dev] v3 onion services
In-Reply-To: <5E1011A2-9FDD-4FFF-B5AF-B35B7C375A5E@mattcorallo.com>
References: <8fd4e30c4c1c24442686dd51727e75cc.squirrel@giyzk7o6dcunb2ry.onion>
 <5E1011A2-9FDD-4FFF-B5AF-B35B7C375A5E@mattcorallo.com>
Message-ID: <b498c783-f8ec-3078-a0f9-c8a1dd2f830f@gmail.com>

As I briefly sketched here before I think that a better long term
solution would be to link the bitcoin traffic with something like
node-Tor (https://github.com/Ayms/node-Tor)

Much more light (the whole code not minified is only ~1MB), not using
tons of libraries prone to security/maintenance issues, easy to
use/configure/maintain and you don't need the (heavy/complicate) onions
RDV concepts and addresses, which in addition is useless for bitcoin

As simple as a duplex stream *bitcoin.pipe(node-Tor)* inside servers or
browsers (difficult to imagine full nodes and the blocks inside browsers
but why not one day, so for light clients probably implementing part of
the bitcoin protocol like https://peersm.com/wallet, for now it's a
standalone offline webapp but of course it would be interesting to
connect it in a secure way to bitcoin nodes to retrieve info from the
utxo set and send txs for example since it's not obvious for users to
create their txs in its current form)

This would be a separate network using the Tor protocol over TCP,
WebSockets and WebRTC, making it possible also for browsers to relay the
traffic, probably the nodes discovery (to get the keys) could be linked
to the bitcoin peer discovery system (we just have to add the onion key
to the peer profile, and maybe long term id key), anyway that's simple
to setup, and probably for a p2p network 2 hops will be enough

I really don't think that the Tor network is designed and adapted to
support bitcoin nodes, using it for something else than browsing is just
a workaround and I would be surprised that the Tor project team
contradicts this and/or encourage this use

Le 18/11/2019 ? 00:42, Matt Corallo via bitcoin-dev a ?crit?:
> There is effort ongoing to upgrade the Bitcoin P2P protocol to support other address types, including onion v3. There are various posts on this ML under the title ?addrv2?. Further review and contributions to that effort is, as always, welcome.
>
>> On Nov 17, 2019, at 00:05, Mr. Lee Chiffre via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> ?Right now bitcoin client core supports use of tor hidden service. It
>> supports v2 hidden service. I am in progress of creating a new bitcoin
>> node which will use v3 hidden service instead of v2. I am looking at
>> bitcoin core and btcd to use. Do any of these or current node software
>> support the v3 onion addresses for the node address? What about I2P
>> addresses? If not what will it take to get it to support the longer
>> addresses that is used by i2p and tor v3?
>>
>>
>> -- 
>> lee.chiffre at secmail.pro
>> PGP 97F0C3AE985A191DA0556BCAA82529E2025BDE35
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191118/d8a62908/attachment.html>

From contact at carldong.me  Mon Nov 18 16:44:00 2019
From: contact at carldong.me (Carl Dong)
Date: Mon, 18 Nov 2019 16:44:00 +0000
Subject: [bitcoin-dev] v3 onion services
In-Reply-To: <46FCD14B-02CC-4986-9C60-D8EC547F33FA@carldong.me>
References: <8fd4e30c4c1c24442686dd51727e75cc.squirrel@giyzk7o6dcunb2ry.onion>
 <46FCD14B-02CC-4986-9C60-D8EC547F33FA@carldong.me>
Message-ID: <D16E0A83-67C2-4727-9FA0-410C43099CD0@carldong.me>

Hi Mr. Lee Chiffre,

I have been working on an implementation of addrv2 (BIP-155). Is this what you meant by I2P and Torv3 address support?

My WIP pull request: https://github.com/bitcoin/bitcoin/pull/16748
Merged BIP: https://github.com/bitcoin/bips/blob/master/bip-0155.mediawiki
Ongoing discussion: https://github.com/bitcoin/bips/pull/766
Note: Even though the pull request to the BIP repo is merged, we?re still discussing some details in the pull request thread and will amend the BIP once it seems like we?ve worked out all the kinks

Review and further discussion is very much welcome! :-)

Cheers,
Carl Dong
contact at carldong.me
"I fight for the users"

> On Nov 16, 2019, at 11:33 PM, Mr. Lee Chiffre via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> 
> Right now bitcoin client core supports use of tor hidden service. It
> supports v2 hidden service. I am in progress of creating a new bitcoin
> node which will use v3 hidden service instead of v2. I am looking at
> bitcoin core and btcd to use. Do any of these or current node software
> support the v3 onion addresses for the node address? What about I2P
> addresses? If not what will it take to get it to support the longer
> addresses that is used by i2p and tor v3?
> 
> 
> --
> lee.chiffre at secmail.pro
> PGP 97F0C3AE985A191DA0556BCAA82529E2025BDE35
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From willtech at live.com.au  Mon Nov 18 12:34:49 2019
From: willtech at live.com.au (LORD HIS EXCELLENCY JAMES HRMH)
Date: Mon, 18 Nov 2019 12:34:49 +0000
Subject: [bitcoin-dev] v3 onion services
In-Reply-To: <b498c783-f8ec-3078-a0f9-c8a1dd2f830f@gmail.com>
References: <8fd4e30c4c1c24442686dd51727e75cc.squirrel@giyzk7o6dcunb2ry.onion>
 <5E1011A2-9FDD-4FFF-B5AF-B35B7C375A5E@mattcorallo.com>,
 <b498c783-f8ec-3078-a0f9-c8a1dd2f830f@gmail.com>
Message-ID: <PS2P216MB0179FCB5050DD24B47DB30089D4D0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>

The Tor team encourages active participating Tor nodes, preferably exit/ middle/guard nodes and not only client nodes, which is actually a significant part of the reason that the documentation I put together in Bitcoin.SE does not deal much with configuration tweaking Tor; as out of the box Tor participates actively in the Tor network.

As for applications other than web browsing, i is simply not true to suggest that Tor is implemented solely for web browsing and I suppose that this view has come about because of the Tor browser, an attempt to engage more active Tor nodes while providing an OOB privacy solution to simplify setup for the not-so-technical. As just one example of other uses, you will note the Tor configuration item `LongLivedPorts` and its implications. No, it is completely not necessary to tweak this option for Bitcoin although you may.

I encourage you to forward these comments to the Tor mailing list.

>I really don't think that the Tor network is designed and adapted to support bitcoin nodes, using it for something else than browsing is just a workaround and I would be surprised that the Tor project team contradicts this and/or encourage this use

Regards,
LORD HIS EXCELLENCY JAMES HRMH

________________________________
From: bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Aymeric Vitte via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
Sent: Monday, 18 November 2019 10:59 PM
To: Matt Corallo <lf-lists at mattcorallo.com>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>; Mr. Lee Chiffre <lee.chiffre at secmail.pro>
Cc: fontainedenton at googlemail.com <fontainedenton at googlemail.com>
Subject: Re: [bitcoin-dev] v3 onion services


As I briefly sketched here before I think that a better long term solution would be to link the bitcoin traffic with something like node-Tor (https://github.com/Ayms/node-Tor)

Much more light (the whole code not minified is only ~1MB), not using tons of libraries prone to security/maintenance issues, easy to use/configure/maintain and you don't need the (heavy/complicate) onions RDV concepts and addresses, which in addition is useless for bitcoin

As simple as a duplex stream bitcoin.pipe(node-Tor) inside servers or browsers (difficult to imagine full nodes and the blocks inside browsers but why not one day, so for light clients probably implementing part of the bitcoin protocol like https://peersm.com/wallet, for now it's a standalone offline webapp but of course it would be interesting to connect it in a secure way to bitcoin nodes to retrieve info from the utxo set and send txs for example since it's not obvious for users to create their txs in its current form)

This would be a separate network using the Tor protocol over TCP, WebSockets and WebRTC, making it possible also for browsers to relay the traffic, probably the nodes discovery (to get the keys) could be linked to the bitcoin peer discovery system (we just have to add the onion key to the peer profile, and maybe long term id key), anyway that's simple to setup, and probably for a p2p network 2 hops will be enough

I really don't think that the Tor network is designed and adapted to support bitcoin nodes, using it for something else than browsing is just a workaround and I would be surprised that the Tor project team contradicts this and/or encourage this use

Le 18/11/2019 ? 00:42, Matt Corallo via bitcoin-dev a ?crit :

There is effort ongoing to upgrade the Bitcoin P2P protocol to support other address types, including onion v3. There are various posts on this ML under the title ?addrv2?. Further review and contributions to that effort is, as always, welcome.



On Nov 17, 2019, at 00:05, Mr. Lee Chiffre via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org><mailto:bitcoin-dev at lists.linuxfoundation.org> wrote:

?Right now bitcoin client core supports use of tor hidden service. It
supports v2 hidden service. I am in progress of creating a new bitcoin
node which will use v3 hidden service instead of v2. I am looking at
bitcoin core and btcd to use. Do any of these or current node software
support the v3 onion addresses for the node address? What about I2P
addresses? If not what will it take to get it to support the longer
addresses that is used by i2p and tor v3?


--
lee.chiffre at secmail.pro<mailto:lee.chiffre at secmail.pro>
PGP 97F0C3AE985A191DA0556BCAA82529E2025BDE35

_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191118/c266cf38/attachment.html>

From vitteaymeric at gmail.com  Mon Nov 18 22:19:23 2019
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Mon, 18 Nov 2019 23:19:23 +0100
Subject: [bitcoin-dev] v3 onion services
In-Reply-To: <D16E0A83-67C2-4727-9FA0-410C43099CD0@carldong.me>
References: <8fd4e30c4c1c24442686dd51727e75cc.squirrel@giyzk7o6dcunb2ry.onion>
 <46FCD14B-02CC-4986-9C60-D8EC547F33FA@carldong.me>
 <D16E0A83-67C2-4727-9FA0-410C43099CD0@carldong.me>
Message-ID: <285a3cde-f056-31cc-87f1-b896960609b6@gmail.com>

So I must ask the question: what is the rational for a bitcoin node to
be hidden? ie to use RDV points like hidden services?

For me the rational for bitcoin is to anonymize communications between
nodes and/or clients, typically who sent this tx, not to hide that you
are operating a bitcoin node, then back to what I sent earlier

I tried to find the explaination in the bitcoin docs before sending this
post but did not find any, except referring to the fact that bitcoin
communications should be anonymized, which does not need RDV points

Another question is why to mimic the Tor network for RDV points with
.onion addresses?

The answers might be "this is what exists and we have no other way to do
it", I am proposing another way

I will not repeat what I wrote before, but I am operating node-Tor nodes
inside the Tor network since ~10 years, the js implementation of the Tor
protocol had not been easy (as well as putting everything inside
browsers) but I consider that the most difficult had been to handle all
unexpected events that happen inside the Tor network, even after
selecting carefully the nodes and testing them, this is a mess, nodes
are coming in, going out, responding, not responding, responding
correcltly or all of a sudden responding shxtty stuff, I was even
considering to get the entropy for the js prng from all of those
unexpected events

I don't think that any other people except the Tor project team know
this, a good example is http://peersm.com/peersm2, see the logs (destroy
and destroy and destroy) and how long it takes to establish 6 circuits
knowing that our server is the first one in the path (eliminating one
dubious node among 3)

I am not "promoting" this, everything is open source now and it is made
to be used, and I think that my proposal has some interest, using the
Tor network for bitcoin is a very bad idea, for security and
performances reasons

Le 18/11/2019 ? 17:44, Carl Dong via bitcoin-dev a ?crit?:
> Hi Mr. Lee Chiffre,
>
> I have been working on an implementation of addrv2 (BIP-155). Is this what you meant by I2P and Torv3 address support?
>
> My WIP pull request: https://github.com/bitcoin/bitcoin/pull/16748
> Merged BIP: https://github.com/bitcoin/bips/blob/master/bip-0155.mediawiki
> Ongoing discussion: https://github.com/bitcoin/bips/pull/766
> Note: Even though the pull request to the BIP repo is merged, we?re still discussing some details in the pull request thread and will amend the BIP once it seems like we?ve worked out all the kinks
>
> Review and further discussion is very much welcome! :-)
>
> Cheers,
> Carl Dong
> contact at carldong.me
> "I fight for the users"
>
>> On Nov 16, 2019, at 11:33 PM, Mr. Lee Chiffre via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>
>> Right now bitcoin client core supports use of tor hidden service. It
>> supports v2 hidden service. I am in progress of creating a new bitcoin
>> node which will use v3 hidden service instead of v2. I am looking at
>> bitcoin core and btcd to use. Do any of these or current node software
>> support the v3 onion addresses for the node address? What about I2P
>> addresses? If not what will it take to get it to support the longer
>> addresses that is used by i2p and tor v3?
>>
>>
>> --
>> lee.chiffre at secmail.pro
>> PGP 97F0C3AE985A191DA0556BCAA82529E2025BDE35
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms


From AdamISZ at protonmail.com  Fri Nov 22 14:02:56 2019
From: AdamISZ at protonmail.com (AdamISZ)
Date: Fri, 22 Nov 2019 14:02:56 +0000
Subject: [bitcoin-dev] Draft BIP for SNICKER
In-Reply-To: <CADabwBAAstxX4ezm3B2sGcDWOcrJUNJ+wfPMY6ArWd4qSAkrLg@mail.gmail.com>
References: <YwZ3vq20LFvpx-nKn1RJjcRHwYTAVCC0v0EyD0y6zVMlQtKXUFNAaEk_QE2dzYDU6z2eK0S0TDXRPfl1_y93RgDjdCGboOgjcERBTLUPHao=@protonmail.com>
 <20191021000608.ajvzjxh6phtuhydp@ganymede>
 <clOIQUf5e2vT3KqKplQwrS5MgB8ptPDSQWkpOMGoAE3rS90i7y-8mNRmcecfVJwiYePhNYAfFlBYsOKqvavm4yVI-zEfo8pnG6AY_fiyMXs=@protonmail.com>
 <mq_HOhcWf2T7ik9Em3nb5VCePi5cV17Wf_c8qS5zWwXh0vnJVzBO_q6Nl8RQBJysBOhZC2rjAw3hbq2tHIoEyTKE8QQaJgF9LpgpcP0Nl8g=@protonmail.com>
 <CADabwBAAstxX4ezm3B2sGcDWOcrJUNJ+wfPMY6ArWd4qSAkrLg@mail.gmail.com>
Message-ID: <B6OyNJfSL9qQgAr7ktQzWvLW_Q3t5b9zHKb4CRd2sH_VdpW5ZsRUSNhG133JA64ZQ-TjjDZHlf8sBMhduzLpptTQo71iwhLoDqMx9GPPlVc=@protonmail.com>

Hi Riccardo,
Apologies for not answering before, this slipped my mind.
Clearly what you propose is possible, and adding the proposer's own signed transaction is a nice touch to make it more privacy-viable.
For now my inclination is not to add this complexity, especially because of the cost implication.
I'd note though that your idea about adding in second-stage transactions aligns with the CoinJoinXT idea (or perhaps, just the segwit idea!). Proposers could send sequences of transactions with various patterns, including backouts and promises, but it would clearly be way more complicated than what we're considering right now.
Regards,
Adam/waxwing

Sent with [ProtonMail](https://protonmail.com) Secure Email.

??????? Original Message ???????
On Wednesday, November 6, 2019 4:52 PM, Riccardo Casatta via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hello Adam,
>
> are you sure you can't tackle the watch-only issue?
>
> What if the proposer create the coinjoin-tx, plus another tx (encrypted with the shared secret) which is a 1 input-1 output (1to1) tx which spend his output to another of his key.
> At this point when the receiver accept the proposal tx he could create other tx 1to1 which are spending his tweaked output to pure bip32 derived key, he than broadcast together the coinjoin tx and for every output of the coinjoin tx one other tx which is a 1to1 tx.
>
> Notes:
> * We are obviously spending more fee because there are more txs involved but the receiver ends up having only bip32 derived outputs.
>
> * The receiver must create the 1to1 tx or the receiver lose privacy by being the only one to create 1to1 tx
> * a good strategy could be to let the coinjoin tx have a very low fee, while the 1to1 tx an higher one so there is less risk that only the coinjoin gets mined
> * Whit this spending strategy, the wallet initial scan does not need to be modified
>
> Il giorno mar 22 ott 2019 alle ore 15:29 AdamISZ via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> ha scritto:
>
>> Just to chime in on these points:
>>
>> My discussions with ghost43 and ThomasV led me to the same conclusion, at least in general, for the whole watch-only issue:
>>
>> It's necessary that the key tweak (`c` as per draft BIP) be known by Proposer (because has to add it to transaction before signing) and Receiver (to check ownership), but must not be known by anyone else (else Coinjoin function fails), hence it can't be publically derivable in any way but must require information secret to the two parties. This can be a pure random sent along with the encrypted proposal (the original concept), or based on such, or implicit via ECDH (arubi's suggestion, now in the draft, requiring each party to access their own secret key). So I reached the same conclusion: the classic watch-only use case of monitoring a wallet in real time with no privkey access is incompatible with this.
>>
>> It's worth mentioning a nuance, however: distinguish two requirements: (1) to recover from zero information and (2) to monitor in real time as new SNICKER transactions arrive.
>>
>> For (2) it's interesting to observe that the tweak `c` is not a money-controlling secret; it's only a privacy-controlling secret. If you imagined two wallets, one hot and one cold, with the second tracking the first but having a lower security requirement because cold, then the `c` values could be sent along from the hot to the cold, as they are created, without changing the cold's security model as they are not money-controlling private keys. They should still be encrypted of course, but that's largely a technical detail, if they were exposed it would only break the effect of the coinjoin outputs being indistinguishable.
>>
>> For (1) the above does not apply; for there, we don't have anyone telling us what `c` values to look for, we have to somehow rederive, and to do that we need key access, so it reverts to the discussion above about whether it might be possible to interact with the cold wallet 'manually' so to speak.
>>
>> To be clear, I don't think either of the above paragraphs describe things that are particularly likely to be implemented, but the hot/cold monitoring is at least feasible, if there were enough desire for it.
>>
>> At the higher level, how important is this? I guess it just depends; there are similar problems (not identical, and perhaps more addressable?) in Lightning; importing keys is generally non-trivial; one can always sweep non-standard keys back into the HD tree, but clearly that is not really a solution in general; one can mark out wallets/seeds of this type as distinct; not all wallets need to have watch-only (phone wallets? small wallets? lower security?) one can prioritise spends of these coins. Etc.
>>
>> Some more general comments:
>>
>> Note Elichai's comment on the draft (repeated here for local convenience: https://gist.github.com/AdamISZ/2c13fb5819bd469ca318156e2cf25d79#gistcomment-3014924) about AES-GCM vs AES-CBC, any thoughts?
>>
>> I didn't discuss the security of the construction for a Receiver from a Proposer who should after all be assumed to be an attacker (except, I emphasised that PSBT parsing could be sensitive on this point); I hope it's clear to everyone that the construction Q = P + cG is only controllable by the owner of the discrete log of P (trivial reduction: if an attacker who knows c, can find the private key q of Q, he can derive the private key p of P as q - c, thus he is an ECDLP cracker).
>>
>> Thanks for all the comments so far, it's been very useful.
>>
>> AdamISZ/waxwing/Adam Gibson
>>
>> Sent with ProtonMail Secure Email.
>>
>> ??????? Original Message ???????
>> On Monday, October 21, 2019 4:04 PM, SomberNight via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> > The SNICKER recovery process is, of course, only required for wallet
>>>
>>> recovery and not normal wallet use, so I don't think a small amount of
>>> round-trip communication between the hot wallet and the cold wallet is
>>> too much to ask---especially since anyone using SNICKER with a
>>> watching-only wallet must be regularly interacting with their cold
>>> wallet anyway to sign the coinjoins.
>>>
>>> What you described only considers the "initial setup" of a watch-only wallet. There are many usecases for watch-only wallets. There doesn't even necessarily need to be any offline-signing involved. For example, consider a user who has a hot wallet on their laptop with xprv; and wants to watch their addresses using an xpub from their mobile. Or consider giving an xpub to an accountant. Or giving an xpub to your Electrum Personal Server (which is how it works).
>>>
>>> Note that all these usecases require "on-going" discovery of addresses, and so they would break.
>>>
>>> ghost43
>>>
>>> (ps: Apologies Dave for the double-email; forgot to cc list originally)
>>>
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> --
> Riccardo Casatta - [@RCasatta](https://twitter.com/RCasatta)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191122/340f75bb/attachment.html>

From PoliceTerror at dyne.org  Fri Nov 22 14:57:10 2019
From: PoliceTerror at dyne.org (popo)
Date: Fri, 22 Nov 2019 15:57:10 +0100
Subject: [bitcoin-dev] Draft BIP for SNICKER
In-Reply-To: <B6OyNJfSL9qQgAr7ktQzWvLW_Q3t5b9zHKb4CRd2sH_VdpW5ZsRUSNhG133JA64ZQ-TjjDZHlf8sBMhduzLpptTQo71iwhLoDqMx9GPPlVc=@protonmail.com>
References: <YwZ3vq20LFvpx-nKn1RJjcRHwYTAVCC0v0EyD0y6zVMlQtKXUFNAaEk_QE2dzYDU6z2eK0S0TDXRPfl1_y93RgDjdCGboOgjcERBTLUPHao=@protonmail.com>
 <20191021000608.ajvzjxh6phtuhydp@ganymede>
 <clOIQUf5e2vT3KqKplQwrS5MgB8ptPDSQWkpOMGoAE3rS90i7y-8mNRmcecfVJwiYePhNYAfFlBYsOKqvavm4yVI-zEfo8pnG6AY_fiyMXs=@protonmail.com>
 <mq_HOhcWf2T7ik9Em3nb5VCePi5cV17Wf_c8qS5zWwXh0vnJVzBO_q6Nl8RQBJysBOhZC2rjAw3hbq2tHIoEyTKE8QQaJgF9LpgpcP0Nl8g=@protonmail.com>
 <CADabwBAAstxX4ezm3B2sGcDWOcrJUNJ+wfPMY6ArWd4qSAkrLg@mail.gmail.com>
 <B6OyNJfSL9qQgAr7ktQzWvLW_Q3t5b9zHKb4CRd2sH_VdpW5ZsRUSNhG133JA64ZQ-TjjDZHlf8sBMhduzLpptTQo71iwhLoDqMx9GPPlVc=@protonmail.com>
Message-ID: <adad1616-a8c2-9d76-4a14-2160e37fc8b2@dyne.org>

Hi, AFAIK snicker is limited to 2 party mixes for the foreseeable future.
What makes this a useful anonymity system for cryptocurrency/Bitcoin?

Thanks

On 11/22/19 3:02 PM, AdamISZ via bitcoin-dev wrote:
> Hi Riccardo,
> Apologies for not answering before, this slipped my mind.
> Clearly what you propose is possible, and adding the proposer's own
> signed transaction is a nice touch to make it more privacy-viable.
> For now my inclination is not to add this complexity, especially because
> of the cost implication.
> I'd note though that your idea about adding in second-stage transactions
> aligns with the CoinJoinXT idea (or perhaps, just the segwit idea!).
> Proposers could send sequences of transactions with various patterns,
> including backouts and promises, but it would clearly be way more
> complicated than what we're considering right now.
> Regards,
> Adam/waxwing
> 
> 
> Sent with ProtonMail <https://protonmail.com> Secure Email.
> 
> ??????? Original Message ???????
> On Wednesday, November 6, 2019 4:52 PM, Riccardo Casatta via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
>> Hello Adam,
>>
>> are you sure you can't tackle the watch-only issue?
>>
>> What if the proposer create the coinjoin-tx, plus another tx
>> (encrypted with the shared secret) which is a 1 input-1 output (1to1)
>> tx which spend his output to another of his key.
>> At this point when the receiver accept the proposal tx he could create
>> other tx 1to1 which are spending his tweaked output to pure bip32
>> derived key, he than broadcast together the coinjoin tx and for every
>> output of the coinjoin tx one other tx which is a 1to1 tx.
>>
>> Notes:
>> * We are obviously spending more fee because there are more txs
>> involved but the receiver ends up having only bip32 derived outputs.
>>
>> * The receiver must create the 1to1 tx or the receiver lose privacy by
>> being the only one to create 1to1 tx
>> * a good strategy could be to let the coinjoin tx have a very low fee,
>> while the 1to1 tx an higher one so there is less risk that only the
>> coinjoin gets mined
>> * Whit this spending strategy, the wallet initial scan does not need
>> to be modified
>>
>>
>> Il giorno mar 22 ott 2019 alle ore 15:29 AdamISZ via bitcoin-dev
>> <bitcoin-dev at lists.linuxfoundation.org
>> <mailto:bitcoin-dev at lists.linuxfoundation.org>> ha scritto:
>>
>>     Just to chime in on these points:
>>
>>     My discussions with ghost43 and ThomasV led me to the same
>>     conclusion, at least in general, for the whole watch-only issue:
>>
>>     It's necessary that the key tweak (`c` as per draft BIP) be known
>>     by Proposer (because has to add it to transaction before signing)
>>     and Receiver (to check ownership), but must not be known by anyone
>>     else (else Coinjoin function fails), hence it can't be publically
>>     derivable in any way but must require information secret to the
>>     two parties. This can be a pure random sent along with the
>>     encrypted proposal (the original concept), or based on such, or
>>     implicit via ECDH (arubi's suggestion, now in the draft, requiring
>>     each party to access their own secret key). So I reached the same
>>     conclusion: the classic watch-only use case of monitoring a wallet
>>     in real time with no privkey access is incompatible with this.
>>
>>     It's worth mentioning a nuance, however: distinguish two
>>     requirements: (1) to recover from zero information and (2) to
>>     monitor in real time as new SNICKER transactions arrive.
>>
>>     For (2) it's interesting to observe that the tweak `c` is not a
>>     money-controlling secret; it's only a privacy-controlling secret.
>>     If you imagined two wallets, one hot and one cold, with the second
>>     tracking the first but having a lower security requirement because
>>     cold, then the `c` values could be sent along from the hot to the
>>     cold, as they are created, without changing the cold's security
>>     model as they are not money-controlling private keys. They should
>>     still be encrypted of course, but that's largely a technical
>>     detail, if they were exposed it would only break the effect of the
>>     coinjoin outputs being indistinguishable.
>>
>>     For (1) the above does not apply; for there, we don't have anyone
>>     telling us what `c` values to look for, we have to somehow
>>     rederive, and to do that we need key access, so it reverts to the
>>     discussion above about whether it might be possible to interact
>>     with the cold wallet 'manually' so to speak.
>>
>>     To be clear, I don't think either of the above paragraphs describe
>>     things that are particularly likely to be implemented, but the
>>     hot/cold monitoring is at least feasible, if there were enough
>>     desire for it.
>>
>>     At the higher level, how important is this? I guess it just
>>     depends; there are similar problems (not identical, and perhaps
>>     more addressable?) in Lightning; importing keys is generally
>>     non-trivial; one can always sweep non-standard keys back into the
>>     HD tree, but clearly that is not really a solution in general; one
>>     can mark out wallets/seeds of this type as distinct; not all
>>     wallets need to have watch-only (phone wallets? small wallets?
>>     lower security?) one can prioritise spends of these coins. Etc.
>>
>>     Some more general comments:
>>
>>     Note Elichai's comment on the draft (repeated here for local
>>     convenience:
>>     https://gist.github.com/AdamISZ/2c13fb5819bd469ca318156e2cf25d79#gistcomment-3014924)
>>     about AES-GCM vs AES-CBC, any thoughts?
>>
>>     I didn't discuss the security of the construction for a Receiver
>>     from a Proposer who should after all be assumed to be an attacker
>>     (except, I emphasised that PSBT parsing could be sensitive on this
>>     point); I hope it's clear to everyone that the construction Q = P
>>     + cG is only controllable by the owner of the discrete log of P
>>     (trivial reduction: if an attacker who knows c, can find the
>>     private key q of Q, he can derive the private key p of P as q - c,
>>     thus he is an ECDLP cracker).
>>
>>     Thanks for all the comments so far, it's been very useful.
>>
>>     AdamISZ/waxwing/Adam Gibson
>>
>>     Sent with ProtonMail Secure Email.
>>
>>     ??????? Original Message ???????
>>     On Monday, October 21, 2019 4:04 PM, SomberNight via bitcoin-dev
>>     <bitcoin-dev at lists.linuxfoundation.org
>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>
>>     > > The SNICKER recovery process is, of course, only required for
>>     wallet
>>     >
>>     > recovery and not normal wallet use, so I don't think a small
>>     amount of
>>     > round-trip communication between the hot wallet and the cold
>>     wallet is
>>     > too much to ask---especially since anyone using SNICKER with a
>>     > watching-only wallet must be regularly interacting with their cold
>>     > wallet anyway to sign the coinjoins.
>>     >
>>     > What you described only considers the "initial setup" of a
>>     watch-only wallet. There are many usecases for watch-only wallets.
>>     There doesn't even necessarily need to be any offline-signing
>>     involved. For example, consider a user who has a hot wallet on
>>     their laptop with xprv; and wants to watch their addresses using
>>     an xpub from their mobile. Or consider giving an xpub to an
>>     accountant. Or giving an xpub to your Electrum Personal Server
>>     (which is how it works).
>>     >
>>     > Note that all these usecases require "on-going" discovery of
>>     addresses, and so they would break.
>>     >
>>     > ghost43
>>     >
>>     > (ps: Apologies Dave for the double-email; forgot to cc list
>>     originally)
>>     >
>>     > bitcoin-dev mailing list
>>     > bitcoin-dev at lists.linuxfoundation.org
>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>     > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>>     _______________________________________________
>>     bitcoin-dev mailing list
>>     bitcoin-dev at lists.linuxfoundation.org
>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>>
>> -- 
>> Riccardo Casatta - @RCasatta <https://twitter.com/RCasatta>
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From luke at dashjr.org  Fri Nov 22 17:13:14 2019
From: luke at dashjr.org (Luke Dashjr)
Date: Fri, 22 Nov 2019 17:13:14 +0000
Subject: [bitcoin-dev] CVE-2018-20586 disclosure (log injection
	vulnerability)
Message-ID: <201911221713.14678.luke@dashjr.org>

CVE-2018-20586 is a log injection vulnerability which allows any software with 
access to the RPC port to create fake or confusing entries in the debug log. 
Valid authentication (username/password/cookie) for the RPC service is NOT 
required to exploit this vulnerability, only the ability to connect to the 
RPC port (which is by default only exposed to the local machine).

The vulnerability was introduced in 40b556d3742a1f65d67e2d4c760d0b13fe8be5b7 
("libevent-based http server") and first released in Bitcoin Core v0.12.0rc1 
in 2016 Jan 13. A fix was hidden in 79358817e53ac0a7afa64c747115d492a74e3155 
("rpc: Make HTTP RPC debug logging more informative") released in v0.17.1, 
2018 Dec 22.

To be vulnerable, the malicious software must either be running on the same 
machine as the node, have the ability to proxy connections to the node via 
the local machine, or the node must be configured to accept RPC connections 
from a network via which the attacker can connect. Additionally, a human user 
must read the debug log and act on or otherwise believe the injected data, in 
a way that is somehow harmful.

Because the node would log the arbitrary POST request from any connection, an 
attacker can add nearly any content to the request to inject it into the log. 
To ensure their entire request is injected, standard spaces would need to be 
replaced with alternative whitespace characters, and newlines would need to 
become other control characters (such as "\r\v"). Because the injected data 
must use such non-standard characters, it is most likely to not fool other 
software parsing the debug log, and only a human visually reading it.

To fix this vulnerability, POST requests are now sanitised before being 
logged, removing all characters that shouldn't be in an ordinary POST 
request.

Credit goes to practicalswift (https://twitter.com/practicalswift) for 
discovering and fixing the vulnerability.

Timeline:
- 2015-01-18: Vulnerability introduced in PR #5677.
- 2015-09-04: Vulnerability merged to master git repository.
- 2016-01-13: Vulnerability published in v0.12.0rc1.
- 2016-02-18: Vulnerability released in v0.12.0.
...
- 2018-10-25: practicalswift discloses vulnerability to security team.
- 2018-10-31: practicalswift opens PR #14618 to quietly fix vulnerability.
- 2018-11-05: Fix merged to master git repository.
- 2018-11-30: Fix merged to 0.17 git repository.
- 2018-12-07: Fix published in v0.17.1rc1.
- 2018-12-22: Fix released in v0.17.1.
...
- 2019-06-22: Vulnerability existence disclosed to bitcoin-dev ML.
- 2019-11-22: Vulnerability details disclosure to bitcoin-dev ML.

From msafi at msafi.com  Sat Nov 23 06:45:02 2019
From: msafi at msafi.com (M.K. Safi)
Date: Fri, 22 Nov 2019 22:45:02 -0800
Subject: [bitcoin-dev] I want to rebuild the GUI in JavaScript
Message-ID: <CABCTTz6A_ahH_3VZ1stBP4uoqTTcwQCQ_X1Xywdi33etssCioA@mail.gmail.com>

I?d like to try to rebuild Bitcoin Core GUI using the JavaScript Electron
framework. My goal is to get a real world understanding of the pros and
cons of moving from Qt to Electron.

Before I start, I?d like to know if this has been tried before or if there
are ongoing efforts in this direction by anyone?

I spent sometime looking into how to implement this. One approach could be
for Electron to drive the UI by running bitcoind and communicating with it
through RPC. But I don?t know if such implementation can achieve
feature-parity with the Qt implementation. Qt has the advantage of direct
access to Bitcoin Core code.

Anyways, I just wanted to share these ideas before going further with them,
so please let me know if you have any information on the above!
-- 
Sent from my iPhone
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191122/e28e30c4/attachment.html>

From AdamISZ at protonmail.com  Sat Nov 23 12:43:27 2019
From: AdamISZ at protonmail.com (AdamISZ)
Date: Sat, 23 Nov 2019 12:43:27 +0000
Subject: [bitcoin-dev] Draft BIP for SNICKER
In-Reply-To: <adad1616-a8c2-9d76-4a14-2160e37fc8b2@dyne.org>
References: <YwZ3vq20LFvpx-nKn1RJjcRHwYTAVCC0v0EyD0y6zVMlQtKXUFNAaEk_QE2dzYDU6z2eK0S0TDXRPfl1_y93RgDjdCGboOgjcERBTLUPHao=@protonmail.com>
 <20191021000608.ajvzjxh6phtuhydp@ganymede>
 <clOIQUf5e2vT3KqKplQwrS5MgB8ptPDSQWkpOMGoAE3rS90i7y-8mNRmcecfVJwiYePhNYAfFlBYsOKqvavm4yVI-zEfo8pnG6AY_fiyMXs=@protonmail.com>
 <mq_HOhcWf2T7ik9Em3nb5VCePi5cV17Wf_c8qS5zWwXh0vnJVzBO_q6Nl8RQBJysBOhZC2rjAw3hbq2tHIoEyTKE8QQaJgF9LpgpcP0Nl8g=@protonmail.com>
 <CADabwBAAstxX4ezm3B2sGcDWOcrJUNJ+wfPMY6ArWd4qSAkrLg@mail.gmail.com>
 <B6OyNJfSL9qQgAr7ktQzWvLW_Q3t5b9zHKb4CRd2sH_VdpW5ZsRUSNhG133JA64ZQ-TjjDZHlf8sBMhduzLpptTQo71iwhLoDqMx9GPPlVc=@protonmail.com>
 <adad1616-a8c2-9d76-4a14-2160e37fc8b2@dyne.org>
Message-ID: <_KQ9Rhe6FCZjxJX7inBrWnwtHG0K-aiK7LBf7xhlyrbUr_zNC_A3Act3MiOJ1wl9S7mFwIlVl29H6tmP6SLWk-S5zUzsFOVexKiVGUC_1i4=@protonmail.com>

Two party mixes can be useful in the context of a very large number of them.
There is no pretence that doing one such, or even doing several such, gives any privacy *guarantees*.
However, if it can be arranged that such 'mixes' occur frequently across a broad spectrum of wallets - and the claim is that that is possible precisely because at least one of the two participants needs to do *absolutely nothing at all* for the join to happen - then the degradation of blockchain analysis could be pretty severe.

What's described here therefore is essentially an attempt to go to the other far extreme from 'rigidly controlled and coordinated large mix sets' to 'ultra loosely coupled almost zero coordination mixing', trading off size in one step for convenience/low effort/even zero effort mixing. Part of that may (or may not) involve Proposers being specialised entities, and it's only the Receiver side that's zero effort.

It should be noted that the two extremes are not incompatible; if one is valuable, it doesn't mean the other isn't.

But what I think you can deduce: a proposal to do SNICKER that just involved a very small set of users would not be much use (still not zero, though); the tradeoffs have been made having in mind the idea of more usage, especially more *broad* usage.

Answering about 2 party joins in more general terms:

Any such coinjoin, no matter its pattern, will break the common input ownership heuristic. If there are equal sized outputs of the same scriptpubkey type (as is proposed) then that delinking effect is of considerable value also.


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Friday, November 22, 2019 2:57 PM, popo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi, AFAIK snicker is limited to 2 party mixes for the foreseeable future.
> What makes this a useful anonymity system for cryptocurrency/Bitcoin?
>
> Thanks
>
> On 11/22/19 3:02 PM, AdamISZ via bitcoin-dev wrote:
>
> > Hi Riccardo,
> > Apologies for not answering before, this slipped my mind.
> > Clearly what you propose is possible, and adding the proposer's own
> > signed transaction is a nice touch to make it more privacy-viable.
> > For now my inclination is not to add this complexity, especially because
> > of the cost implication.
> > I'd note though that your idea about adding in second-stage transactions
> > aligns with the CoinJoinXT idea (or perhaps, just the segwit idea!).
> > Proposers could send sequences of transactions with various patterns,
> > including backouts and promises, but it would clearly be way more
> > complicated than what we're considering right now.
> > Regards,
> > Adam/waxwing
> > Sent with ProtonMail https://protonmail.com Secure Email.
> > ??????? Original Message ???????
> > On Wednesday, November 6, 2019 4:52 PM, Riccardo Casatta via bitcoin-dev
> > bitcoin-dev at lists.linuxfoundation.org wrote:
> >
> > > Hello Adam,
> > > are you sure you can't tackle the watch-only issue?
> > > What if the proposer create the coinjoin-tx, plus another tx
> > > (encrypted with the shared secret) which is a 1 input-1 output (1to1)
> > > tx which spend his output to another of his key.
> > > At this point when the receiver accept the proposal tx he could create
> > > other tx 1to1 which are spending his tweaked output to pure bip32
> > > derived key, he than broadcast together the coinjoin tx and for every
> > > output of the coinjoin tx one other tx which is a 1to1 tx.
> > > Notes:
> > >
> > > -   We are obviously spending more fee because there are more txs
> > >     involved but the receiver ends up having only bip32 derived outputs.
> > >
> > > -   The receiver must create the 1to1 tx or the receiver lose privacy by
> > >     being the only one to create 1to1 tx
> > >
> > > -   a good strategy could be to let the coinjoin tx have a very low fee,
> > >     while the 1to1 tx an higher one so there is less risk that only the
> > >     coinjoin gets mined
> > >
> > > -   Whit this spending strategy, the wallet initial scan does not need
> > >     to be modified
> > >
> > >
> > > Il giorno mar 22 ott 2019 alle ore 15:29 AdamISZ via bitcoin-dev
> > > <bitcoin-dev at lists.linuxfoundation.org
> > > mailto:bitcoin-dev at lists.linuxfoundation.org> ha scritto:
> > >
> > >     Just to chime in on these points:
> > >
> > >     My discussions with ghost43 and ThomasV led me to the same
> > >     conclusion, at least in general, for the whole watch-only issue:
> > >
> > >     It's necessary that the key tweak (`c` as per draft BIP) be known
> > >     by Proposer (because has to add it to transaction before signing)
> > >     and Receiver (to check ownership), but must not be known by anyone
> > >     else (else Coinjoin function fails), hence it can't be publically
> > >     derivable in any way but must require information secret to the
> > >     two parties. This can be a pure random sent along with the
> > >     encrypted proposal (the original concept), or based on such, or
> > >     implicit via ECDH (arubi's suggestion, now in the draft, requiring
> > >     each party to access their own secret key). So I reached the same
> > >     conclusion: the classic watch-only use case of monitoring a wallet
> > >     in real time with no privkey access is incompatible with this.
> > >
> > >     It's worth mentioning a nuance, however: distinguish two
> > >     requirements: (1) to recover from zero information and (2) to
> > >     monitor in real time as new SNICKER transactions arrive.
> > >
> > >     For (2) it's interesting to observe that the tweak `c` is not a
> > >     money-controlling secret; it's only a privacy-controlling secret.
> > >     If you imagined two wallets, one hot and one cold, with the second
> > >     tracking the first but having a lower security requirement because
> > >     cold, then the `c` values could be sent along from the hot to the
> > >     cold, as they are created, without changing the cold's security
> > >     model as they are not money-controlling private keys. They should
> > >     still be encrypted of course, but that's largely a technical
> > >     detail, if they were exposed it would only break the effect of the
> > >     coinjoin outputs being indistinguishable.
> > >
> > >     For (1) the above does not apply; for there, we don't have anyone
> > >     telling us what `c` values to look for, we have to somehow
> > >     rederive, and to do that we need key access, so it reverts to the
> > >     discussion above about whether it might be possible to interact
> > >     with the cold wallet 'manually' so to speak.
> > >
> > >     To be clear, I don't think either of the above paragraphs describe
> > >     things that are particularly likely to be implemented, but the
> > >     hot/cold monitoring is at least feasible, if there were enough
> > >     desire for it.
> > >
> > >     At the higher level, how important is this? I guess it just
> > >     depends; there are similar problems (not identical, and perhaps
> > >     more addressable?) in Lightning; importing keys is generally
> > >     non-trivial; one can always sweep non-standard keys back into the
> > >     HD tree, but clearly that is not really a solution in general; one
> > >     can mark out wallets/seeds of this type as distinct; not all
> > >     wallets need to have watch-only (phone wallets? small wallets?
> > >     lower security?) one can prioritise spends of these coins. Etc.
> > >
> > >     Some more general comments:
> > >
> > >     Note Elichai's comment on the draft (repeated here for local
> > >     convenience:
> > >     https://gist.github.com/AdamISZ/2c13fb5819bd469ca318156e2cf25d79#gistcomment-3014924)
> > >     about AES-GCM vs AES-CBC, any thoughts?
> > >
> > >     I didn't discuss the security of the construction for a Receiver
> > >     from a Proposer who should after all be assumed to be an attacker
> > >     (except, I emphasised that PSBT parsing could be sensitive on this
> > >     point); I hope it's clear to everyone that the construction Q = P
> > >     + cG is only controllable by the owner of the discrete log of P
> > >     (trivial reduction: if an attacker who knows c, can find the
> > >     private key q of Q, he can derive the private key p of P as q - c,
> > >     thus he is an ECDLP cracker).
> > >
> > >     Thanks for all the comments so far, it's been very useful.
> > >
> > >     AdamISZ/waxwing/Adam Gibson
> > >
> > >     Sent with ProtonMail Secure Email.
> > >
> > >     ??????? Original Message ???????
> > >     On Monday, October 21, 2019 4:04 PM, SomberNight via bitcoin-dev
> > >     <bitcoin-dev at lists.linuxfoundation.org
> > >     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
> > >
> > >     > > The SNICKER recovery process is, of course, only required for
> > >     wallet
> > >     >
> > >     > recovery and not normal wallet use, so I don't think a small
> > >     amount of
> > >     > round-trip communication between the hot wallet and the cold
> > >     wallet is
> > >     > too much to ask---especially since anyone using SNICKER with a
> > >     > watching-only wallet must be regularly interacting with their cold
> > >     > wallet anyway to sign the coinjoins.
> > >     >
> > >     > What you described only considers the "initial setup" of a
> > >     watch-only wallet. There are many usecases for watch-only wallets.
> > >     There doesn't even necessarily need to be any offline-signing
> > >     involved. For example, consider a user who has a hot wallet on
> > >     their laptop with xprv; and wants to watch their addresses using
> > >     an xpub from their mobile. Or consider giving an xpub to an
> > >     accountant. Or giving an xpub to your Electrum Personal Server
> > >     (which is how it works).
> > >     >
> > >     > Note that all these usecases require "on-going" discovery of
> > >     addresses, and so they would break.
> > >     >
> > >     > ghost43
> > >     >
> > >     > (ps: Apologies Dave for the double-email; forgot to cc list
> > >     originally)
> > >     >
> > >     > bitcoin-dev mailing list
> > >     > bitcoin-dev at lists.linuxfoundation.org
> > >     <mailto:bitcoin-dev at lists.linuxfoundation.org>
> > >     > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> > >
> > >
> > >     _______________________________________________
> > >     bitcoin-dev mailing list
> > >     bitcoin-dev at lists.linuxfoundation.org
> > >     <mailto:bitcoin-dev at lists.linuxfoundation.org>
> > >     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> > >
> > >
> > > --
> > > Riccardo Casatta - @RCasatta https://twitter.com/RCasatta
> >
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From otech47 at gmail.com  Sat Nov 23 16:49:18 2019
From: otech47 at gmail.com (Oscar Lafarga)
Date: Sat, 23 Nov 2019 17:49:18 +0100
Subject: [bitcoin-dev] I want to rebuild the GUI in JavaScript
In-Reply-To: <CABCTTz6A_ahH_3VZ1stBP4uoqTTcwQCQ_X1Xywdi33etssCioA@mail.gmail.com>
References: <CABCTTz6A_ahH_3VZ1stBP4uoqTTcwQCQ_X1Xywdi33etssCioA@mail.gmail.com>
Message-ID: <CAO7Y_eX2egYNw+h_jDGTYx1R5sC1zrTOXOHuJU4rY66rWKRwAw@mail.gmail.com>

Hi MK,

I very much share your interests and curiosities here and actually don't
have an answer on whether it's been tried before.

One of the few things I am imagining is that given the security-focused
nature of the Bitcoin Core software, any vulnerabilities in the way NPM
handles the dependencies of the Electron app would be a very high priority
(see https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/)

In NodeJS-land, my sense is that there is a "move fast and break things"
mentality that may have seeped into some practices that may be considered
standard. I have seen some recent developments over the past few years to
address these kinds of issues such as npm-audit (as of Node v6+) but I
would recommend doing some thorough research on this front to make sure
there is a secure dependency management solution in place for such a GUI.

Another comment I'd make is that if we consider the GUI as a layer that is
separate from the protocol layer, this mailing list may not be the best
place to fully discuss this. However I think if anyone here who has been
around longer can contribute info on past attempts at this, it could be
quite productive. This could technically exist as an independent client,
but I guess there's a conversation on whether this new Electron UI would
ever replace the Qt UI, but since it doesn't exist yet it could be far too
early for that.

Thanks,






On Sat, Nov 23, 2019, 2:17 PM M.K. Safi via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I?d like to try to rebuild Bitcoin Core GUI using the JavaScript Electron
> framework. My goal is to get a real world understanding of the pros and
> cons of moving from Qt to Electron.
>
> Before I start, I?d like to know if this has been tried before or if there
> are ongoing efforts in this direction by anyone?
>
> I spent sometime looking into how to implement this. One approach could be
> for Electron to drive the UI by running bitcoind and communicating with it
> through RPC. But I don?t know if such implementation can achieve
> feature-parity with the Qt implementation. Qt has the advantage of direct
> access to Bitcoin Core code.
>
> Anyways, I just wanted to share these ideas before going further with
> them, so please let me know if you have any information on the above!
> --
> Sent from my iPhone
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191123/9e503a84/attachment-0001.html>

From dev at jonasschnelli.ch  Sat Nov 23 18:27:47 2019
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Sat, 23 Nov 2019 08:27:47 -1000
Subject: [bitcoin-dev] I want to rebuild the GUI in JavaScript
In-Reply-To: <CABCTTz6A_ahH_3VZ1stBP4uoqTTcwQCQ_X1Xywdi33etssCioA@mail.gmail.com>
References: <CABCTTz6A_ahH_3VZ1stBP4uoqTTcwQCQ_X1Xywdi33etssCioA@mail.gmail.com>
Message-ID: <338F9187-AE9C-4771-8298-AC4AF11D1F8B@jonasschnelli.ch>

Hi

This is probably the wrong place to discuss that (OT).

> I?d like to try to rebuild Bitcoin Core GUI using the JavaScript Electron framework. My goal is to get a real world understanding of the pros and cons of moving from Qt to Electron.

There is a relatively new Bitcoin Core Github issue that covers that topic [1].
AFAIK many Bitcoin Core contributors (and users?) don?t like the idea of having a Browser and JavaScript to achieve a UI with relatively simple user-stories.

I think if you want to do this, try to work on a third party project and let your Electron UI connect to Bitcoin Core over RPC.
To avoid pulling, eventually use ZMQ or help getting long polling into Bitcoin Core [2].

Adding a Electron/JavaScript UI to the Bitcoin Core repository is very unlikely to happen.

[1] https://github.com/bitcoin/bitcoin/issues/17395
[2] https://github.com/bitcoin/bitcoin/pull/7949
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191123/2ef48e0b/attachment.sig>

From email at esotericnonsense.com  Sat Nov 23 20:07:17 2019
From: email at esotericnonsense.com (Daniel Edgecumbe)
Date: Sat, 23 Nov 2019 21:07:17 +0100
Subject: [bitcoin-dev] I want to rebuild the GUI in JavaScript
In-Reply-To: <CAO7Y_eX2egYNw+h_jDGTYx1R5sC1zrTOXOHuJU4rY66rWKRwAw@mail.gmail.com>
References: <CABCTTz6A_ahH_3VZ1stBP4uoqTTcwQCQ_X1Xywdi33etssCioA@mail.gmail.com>
 <CAO7Y_eX2egYNw+h_jDGTYx1R5sC1zrTOXOHuJU4rY66rWKRwAw@mail.gmail.com>
Message-ID: <2efb057a-4838-4fca-a24e-432091a63ea9@www.fastmail.com>

You may find my (incomplete) front-end of interest:

https://bitcoin.electronrelocation.com

The live demo is backed by a -disablewallet node, but it was able to accept payments and send them via QR codes before I stopped development.

The source is available via AGPLv3.

https://git.esotericnonsense.com/pub/bitcoin-top.git

I am unable to continue development due to time constraints.

Daniel Edgecumbe | esotericnonsense
email at esotericnonsense.com | https://esotericnonsense.com

On Sat, Nov 23, 2019, at 17:49, Oscar Lafarga via bitcoin-dev wrote:
> Hi MK,
> 
> I very much share your interests and curiosities here and actually 
> don't have an answer on whether it's been tried before.
> 
> One of the few things I am imagining is that given the security-focused 
> nature of the Bitcoin Core software, any vulnerabilities in the way NPM 
> handles the dependencies of the Electron app would be a very high 
> priority (see 
> https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/) 
> 
> In NodeJS-land, my sense is that there is a "move fast and break 
> things" mentality that may have seeped into some practices that may be 
> considered standard. I have seen some recent developments over the past 
> few years to address these kinds of issues such as npm-audit (as of 
> Node v6+) but I would recommend doing some thorough research on this 
> front to make sure there is a secure dependency management solution in 
> place for such a GUI.
> 
> Another comment I'd make is that if we consider the GUI as a layer that 
> is separate from the protocol layer, this mailing list may not be the 
> best place to fully discuss this. However I think if anyone here who 
> has been around longer can contribute info on past attempts at this, it 
> could be quite productive. This could technically exist as an 
> independent client, but I guess there's a conversation on whether this 
> new Electron UI would ever replace the Qt UI, but since it doesn't 
> exist yet it could be far too early for that. 
> 
> Thanks,
> 
> 
> 
> 
> 
> 
> On Sat, Nov 23, 2019, 2:17 PM M.K. Safi via bitcoin-dev 
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > I?d like to try to rebuild Bitcoin Core GUI using the JavaScript Electron framework. My goal is to get a real world understanding of the pros and cons of moving from Qt to Electron.
> > 
> > Before I start, I?d like to know if this has been tried before or if there are ongoing efforts in this direction by anyone?
> > 
> > I spent sometime looking into how to implement this. One approach could be for Electron to drive the UI by running bitcoind and communicating with it through RPC. But I don?t know if such implementation can achieve feature-parity with the Qt implementation. Qt has the advantage of direct access to Bitcoin Core code.
> > 
> > Anyways, I just wanted to share these ideas before going further with them, so please let me know if you have any information on the above!
> > -- 
> > Sent from my iPhone
> >  _______________________________________________
> >  bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From ZmnSCPxj at protonmail.com  Mon Nov 25 11:00:22 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 25 Nov 2019 11:00:22 +0000
Subject: [bitcoin-dev] Composable MuSig
Message-ID: <u1IeyK5A7zyklXzl26UpCliJrFEsDp5SXUGbtXGBCrEWw6Wi7vNcoy4HNv2WXUTG_SBuMURDLhvh3YCwL2r53rL0Yj19TZpumYFD5WqmYL8=@protonmail.com>

So I heard you like MuSig.


Introduction
============

Previously on lightning-dev, I propose Lightning Nodelets, wherein one signatory of a channel is in fact not a single entity, but instead an aggregate: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002236.html

Generalizing:

* There exists some protocol that requires multiple participants agreeing.
  * This can be implemented by use of MuSig on the public keys of the participants.
* One or more of the participants in the above protocol is in fact an aggregate, not a single participant.
  * Ideally, no protocol modification should be needed to support such aggregates, "only" software development without modifying the protocol layer.
  * Obviously, any participant of such a protocol, whether a direct participant, or a member of an aggregated participant of that protocol, would want to retain control of its own money in that protocol, without having to determine if it is being Sybilled (and all other participants are in fact just one participant).
  * Motivating example: a Lightning Network channel is the aggregate of two participants, the nodes creating that channel.
    However, with nodelets as proposed above, one of the participants is actually itself an aggregate of multiple nodelets.
    * This requires that a Lightning Network channel with a MuSig address, to have one or both participants, be potentially an aggregate of two or more nodelet participants, e.g. `MuSig(MuSig(A, B), C)`

This is the "MuSig composition" problem.
That is, given `MuSig(MuSig(A, B), C)`, and the *possibility* that in fact `B == C`, what protocol can A use to ensure that it uses the three-phase MuSig protocol (which has a proof of soundness) and not inadvertently use a two-phase MuSig protocol?

Schnorr Signatures
==================

The scheme is as follows.

Suppose an entity A needs to show a signature.
At setup:

* It generates a random scalar `a`.
* It computes `A` as `A = a * G`, where `G` is the standard generator point.
* It publishes `A`.

At signing a message `m`:

* It generates a random scalar `r`.
* It computes `R` as `R = r * G`.
* It computes `e` as `h(R | m)`, where `h()` is a standard hash function and `x | y` denotes the serialization of `x` concatenated by the serialization of `y`.
* It computes `s` as `s = r + e * a`.
* It publishes as signature the tuple of `(R, s)`.

An independent validator can then get `A`, `m`, and the signature `(R, s)`.
At validation:

* It recovers `e[validator]` as so: `e[validator] = h(R | m)`
* It computes `S[validator]` as so: `S[validator] = R + e[validator] * A`.
* It checks if `s * G == S[validator]`.
  * If `R` and `s` were indeed generated as per signing algorithm above, then:
    * `S[validator] = R + e[validator] * A`
    * `== r * G + e[validator] * A`; subbstitution of `R`
    * `== r * G + h(R | m) * A`; substitution of `e[validator]`
    * `== r * G + h(R | m) * a * G`; substitution of `A`.
    * `== (r + h(R | m) * a) * G`; factor out `G`
    * `== (r + e * a) * G`; substitution of `h(R | m)` with `e`
    * `== s * G`; substitution of `r + e * a`.

MuSig
=====

Under MuSig, validation must remain the same, and multiple participants must provide a single aggregate key and signature.

Suppose there exist two participants A and B.
At setup:

* A generates a random scalar `a` and B generates a random scalar `b`.
* A computes `A` as `A = a * G` and B computes `B` as `B = b * G`.
* A and B exchange `A` and `B`.
* They generate the list `L`, by sorting their public keys and concatenating their representations.
* They compute their aggregate public key `P` as `P = h(L) * A + h(L) * B`.
* They publish the aggregate public key `P`.

Signing takes three phases.

1.  `R` commitment exchange.
  * A generates a random scalar `r[a]` and B generates a random scalar `r[b]`.
  * A computes `R[a]` as `R[a] = r[a] * G` and B computes `R[b]` as `R[b] = r[b] * G`.
  * A computes `h(R[a])` and B computes `h(R[b])`.
  * A and B exchange `h(R[a])` and `h(R[b])`.
2.  `R` exchange.
  * A and B exchange `R[a]` and `R[b]`.
  * They validate that the previous given `h(R[a])` and `h(R[b])` matches.
3.  `s` exchange.
  * They compute `R` as `R = R[a] + R[b]`.
  * They compute `e` as `h(R | m)`.
  * A computes `s[a]` as `s[a] = r[a] + e * h(L) * a` and B computes `s[b]` as `s[b] = r[b] + e * h(L) * b`.
  * They exchange `s[a]` and `s[b]`.
  * They compute `s` as `s = s[a] + s[b]`.
  * They publish the signature as the tuple `(e, s)`.

At validation, the validator knows `P`, `m`, and the signature `(R, s)`.

* It recovers `e[validator]` as so: `e[validator] = h(R | m)`
* It computes `S[validator]` as so: `S[validator] = R + e[validator] * P`.
* It checks if `s * G == S[validator]`.
  * `S[validator] = R + e[validator] * P`
  * `== R[a] + R[b] + e[validator] * P`; substitution of `R`
  * `== r[a] * G + r[b] * G + e[validator] * P`; substitution of `R[a]` and `R[b]`
  * `== r[a] * G + r[b] * G + e * P`; substitution of `e[validator]` with `e`
  * `== r[a] * G + r[b] * G + e * (h(L) * A + h(L) * B)`; substitution of `P`
  * `== r[a] * G + r[b] * G + e * h(L) * A + e * h(L) * B`; distribution of `e` inside parentheses.
  * `== r[a] * G + r[b] * G + e * h(L) * a * G + e * h(L) * b * G`; substitution of `A` and `B`.
  * `== (r[a] + r[b] + e * h(L) * a + e * h(L) * b) * G`; factoring out of `G`
  * `== (r[a] + e * h(L) * a + r[b] + e * h(L) * b) * G`; rearrangement of terms
  * `== (s[a] + s[b]) * G`; substitution of `r[a] + e * h(L) * a` and `r[b] + e * h(L) * b`
  * `== s * G`;  substitution of `s[a] + s[b]`


Two-Phase MuSig Unsafe
======================

Original proposal of MuSig only had two phases, `R` exchange and `s` exchange.
However, there was a flaw found in the security proof in this two-phase MuSig.
In response, an earlier phase of exchanging commitments to `R` was added.

Thus, two-phase MuSig is potentially unsafe.

https://eprint.iacr.org/2018/417.pdf describes the argument.
Briefly, with two-phase MuSig, one of the participants can deliberately delay its side of a `R` exchange and control the resulting sum `R` by cancelling the `R` of the other participant.
Executed over many (aborted) signing sessions, one participant can induce the other to create a signature for a message it might not agree to, by using the Wagner Generalized Birthday Paradox attack.

Briefly, a two-phase MuSig signing would go this way:

1.  `R` exchange.
  * A generates random scalar `r[a]` and B generates random scalar `r[b]`.
  * A computes `R[a]` as `r[a] * G` and B computes `R[b]` as `r[b] * G`.
  * They exchange `R[a]` and `R[b]`.
2.  `s` exchange.
  * They compute `R` as `R = R[a] + R[b]`.
  * They compute `e` as `h(R | m)`.
  * A computes `s[a]` as `s[a] = r[a] + e * h(L) * a` and B computes `s[b]` as `s[b] = r[b] + e * h(L) * b`.
  * They exchange `s[a]` and `s[b]`.
  * They compute `s` as `s = s[a] + s[b]`.
  * They publish the signature as the tuple `(R, s)`.

The sticking point is "exchange" here.
Given that we live in a relativistic universe where there is no such thing as simultaneity-in-time-without-simultaneity-in-space, it is impossible to ensure that both A and B send their data "at the same time" in such a way that it is impossible for, for example, the send of B to be outside the future light cone of the send of A.
Or in human-level terms, it is not possible to ensure over the network that B will not send `R[b]` *after* it receives `R[a]`.

Suppose that instead of B generating a random `r[b]` and *then* computing `R[b] = r[b] * G`, it instead selects an arbitrary `R[selected]` it wants to target, then compute `R[b]` as `R[selected] - R[a]`.
Then at `s` exchange:

* They compute `R` as `R[a] + R[b]`, which is in fact `R[a] + R[selected] - R[a]`, or `R[selected]`, i.e. `R == R[selected]`.
* They compute `e` as `h(R[selected] | m)`.
* A computes `s[a]` as `s[a] = r[a] + e * h(L) * a`.
* B is unable to compute `s[b]` as it has no `r[b]` it can use in the computation, and aborts the signing.

The attack involved is that multiple such signing sessions, for the same message or for separate distinct messages, might be done in parallel.
Suppose that there are `n` such sessions, such that A provides `n` different `R[a][i]`, e.g. `R[a][1]`, `R[a][2]`, `R[a][3]` up to `R[a][n]`.
Then:

* B delays each session, pretending to have Internet connectivity problems.
* B selects a message `m[target]` that it knows A will never sign (e.g. "I, A, give all my money to B").
* B computes `R[target]` as `sum where i = 1 to n of R[a][i]`.
* B uses the Wagner Generalized Birthday Paradox technique to find `R[selected][i]` with the following constraint:
  * `h(R[target] | m[target]) == sum where i = 1 to n of h(R[selected][i] | m[i])`.
  * Given a large enough number of parallel sessions `n`, this can greatly reduce the effort from 2^128 to find a match to within the realm of a large computer to compute within a few seconds.
* B computes `R[b][i]` as `R[selected][i] - R[a][i]`, for each `i` from 1 to `n`.
* B provides `R[b][i]` for each session.
* A computes `R[i]` as `R[a][i] + R[b][i]` for each session.
  * However we know that `R[b][i] == R[selected][i] - R[a][i]` for each session, cancelling out `R[a][i]` and leaving `R[i] == R[selected][i]`
* A computes `s[a][i]` as `r[a][i] + h(R[selected][i] | m[i]) * h(L) * a` for each session.
* A gives `s[a][i]` for each session.
* B aborts each session.
* B sums up all the `s[a][i]`:
  * `(sum where i = 1 to n of r[a][i]) + (sum where i = 1 to n of h(R[selected][i] | m[i]) * h(L) * a)`.
  * Remember, B has specifically selected `R[selected][i]` such that `h(R[target] | m[target])` is equal to the sum of `h(R[selected][i] | m[i])`.
  * `== (sum where i = 1 to n of r[a][i]) + h(R[target] | m[target]) * h(L) * a)`.
* B adds `h(R[target] | m[target]) * h(L) * b` to the above sum.
  * This results in a signature for MuSig(A, B) to the message `m[target]`, even though A would never have agreed to this message.

Thus, 2-phase MuSig enables a Wagner attack on the participant, thus it is unsafe.

Now, any method of ensuring a "simultaneous" exchange of `R` points is largely the same as adding a "commit to `R`" phase, i.e. the fix for this is simply to add the "`R` commitment exchange" phase.

References: https://eprint.iacr.org/2018/417.pdf

MuSig Composition
=================

Let us suppose that we have some protocol that requires a MuSig signing session between signers with public keys `P` and `C`.
Let us further suppose that in fact, `P = MuSig(A, B)`, i.e. one of the public keys in this protocol is, in reality, itself a MuSig of two participants.

At the point of view of signer C, P is a single participant and it acts as such.
However, in reality, P is an aggregate.

We want to have the following properties:

* C should never need to know that P is in fact an aggregate.
* Even if B is secretly the same as C, the entire protocol as a whole (including the aggregate signing of `MuSig(A, B)`) should remain three-phase MuSig.

Now, from the point of view of C, what it sees are:

At setup:

* It generates a random scalar `c` and the public key `C` as `C = c * G`.
* It exchanges keys with P and gets the public key `P`.
* It computes `L` by sorting `C` and `P` and concatenating them.
* It determines their aggregate key as `h(L) * C + h(L) * P`.

At signing:

1.  `R` commitment exchange.
  * It generates a random scalar `r[c]` and computes `R[c]` as `R[c] = r[c] * G`.
  * It computes `h(R[c])`.
  * It exchanges the hash `h(R[c])` with P and gets `h(R[p])`.
2.  `R` exchange.
  * It exchanges `R[c]` with P and gets `R[p]`.
  * It validates that the hash `h(R[p])` matches the previously-committed hash.
3.  `s` exchange.
  * It computes `R` as `R = R[c] + R[p]`.
  * It computes `e` as `e = h(R | m)`.
  * It computes `s[c]` as `s[c] = r[c] + e * c`.
  * It exchanges `s[c]` with P and gets `s[p]`.
  * It computes `s` as `s = s[c] + s[p]`.

However, from point of view of A and B, what actually happens is this:

At setup:

* A generates a random scalar `a` and computes `A = a * G`, B generates a random scalar `b` and computes `B = b * G`.
* They exchange `A` and `B`.
* They generate their own `L[ab]`, by sorting `A` and `B` and concatenating their representations.
* They compute the inner MuSig pubkey `P` as `P = h(L[ab]) * A + h(L[ab]) * B`.
* They exchange `P` with C, and get `C`.
* They compute the outer MuSig pubkey as `h(L) * P + h(L) * C`.

At signing:

1.  `R` commitment exchange.
  * A generates a random scalar `r[a]` and computes `R[a] = r[a] * G`, B generates a random scalar `r[b]` and computes `R[b] = r[b] * G`.
  * A computes `h(R[a])`, B computes `h(R[b])`.
  * They exchange `h(R[a])` and `h(R[b])`.
  * They need to compute `h(R[p])` for the protocol with C.
    * However, even if we know `R[p] == R[a] + R[b]`, we cannot generate `h(R[p])`.
    * Thus, they have no choice but to exchange `R[a]` and `R[b]` at this phase, even though this is supposed to be the `R` commitment exchange phase (and they should not share `R[a]` and `R[b]` yet)!

Unfortunately, this means that, between A and B, we are now reduced to a two-phase MuSig.
This is relevant if B and C happen to be the same entity or are cooperating.

Basically, before C has to provide its `h(R[c])`, B now knows the generated `R[a]` and `R[b]`.
If B and C are really the same entity, then C can compute `R[c]` as `R[selected] - R[a] - R[b]` before providing `h(R[c])`.
Then this devolves to the same attack that brings down 2-phase MuSig.

Thus, composition with the current MuSig proposal is insecure.

Towards a Composable Multi-`R` MuSig
====================================

A key element is that the first phase simply requires that all participants provide *commitments* to their individual `R`, and the second phase reveals their `R`.

I propose here the modification below:

* In the first phase, any participant in the MuSig may submit one *or more* `R` commitments.
* In the second phase, the participant in the MuSig submits each `R` that decommits each of the `R` commitments it sent.

I call this the Remote R Replacement Remanded: Redundant R Required Realistically, or, in shorter terms, the Multi-`R` proposal.

This is a simple and direct extension of the MuSig protocol, and expected to not have any effect on the security proof of MuSig.

In the case where all MuSig participants are singletons and each participant just generates and sends a single `R` commitment, then this proposal reduces to the original MuSig proposal.

However, in the case where one participant is in reality itself an aggregate, then we shall describe it below.
The below example is `MuSig(MuSig(A, B), C)`.

1.  `R` commitment exchange.
  * A generates a random number `r[a]`, B generates a random number `r[b]`, C generates a random number `r[c]`.
  * A computes `R[a]` as `r[a] * G`, B computes `R[b]` as `r[b] * G`, C computes `R[c]` as `r[c] * G`.
  * A computes `h(R[a])`, B computes `h(R[b])`, C computes `h(R[c])`.
  * A and B exchange their hashes with each other.
  * A and B jointly exchange their `h(R[a])` and `h(R[b])` with the `h(R[c])` from C.
2.  `R` exchange.
  * A and B reveal their `R[a]` and `R[b]` with each other.
  * A and B validate the given `R[a]` matches `h(R[a])` and the given `R[b]` matches `h(R[b])`.
  * A and B jointly exchange their `R[a]` and `R[b]` with the `R[c]` from C.
  * C validates `R[a]` and `R[b]`, A and B validate `R[c]`.
  * They compute `R` as the sum of all `R[a] + R[b] + R[c]`.
3.  `s` exchange.
  * They compute `e` as `h(R | m)`.
  * A computes `s[a]` as `r[a] + e * h(L[abc]) * h(L[ab]) * a`, B computes `s[b]` as `r[b] + e * h(L[abc]) * h(L[ab]) * b`.
  * C computes `s[c]` as `r[c] + e * h(L[abc]) * c`.
  * A and B exchange `s[a]` and `s[b]`.
  * A and B compute `s[ab]` as `s[a] + s[b]`.
  * A and B jointly exchange their `s[ab]` with `s[c]` from C.
  * They compute `s` as `s[ab] + s[c]`.
  * They publish the signature as the tuple `(R, s)`.

Of note, is that the number of `R` a participant provides is a strong hint as to whether it is actually an aggregate or not, and forms an upper bound as to the size of the aggregate (i.e. an aggregate of `n` members can pretend to be an aggregate of `m` members where `n < m`, but cannot pretend with `n > m`).
Thus, C here learns that its counterparty is actually itself an aggregate rather than a singleton.
This may be acceptable as a weak reduction in privacy (in principle, C should never learn that it is talking to an aggregate rather than a single party).

Alternative Composable MuSig Schemes
====================================

The above proposal is not the only one.
Below are some additional proposals which have various flaws, ranging from outright insecurity to practical implementation complexity issues.

Pedersen Commitments in Phase 1
-------------------------------

My initial proposal was to use Pedersen commitments in phase 1.
At phase 1, each party would generate a `r[x]` and `q[x]`, and exchange the Pedersen commitments `r[x] * G + q[x] * H`, where `H` is a NUMS point used as a second standard generator.
Then at phase 2, each party reveals its `q[x]`.
All the Pedersen commitments are summed, then all `q[x]` are summed, multiplied by `H`, then subtracted from the sum of Pedersen commitments.

Unfortunately, this leads to a Wagner attack.

Suppose A and B have an aggregate MuSig(A, B).

* B initiates multiple parallel signing sessions with A.
* B selects a message `m[target]` that it knows A will never sign (e.g. "I, A, give all my money to B").
* In the first phase, B selects random points `R[b][i]` for each session `i` and provides that as its Pedersen commitment, receiving `R[a][i] + q[a][i] * H` in exchange.
* In the second phase, B delays each session, pretending to have Internet connectivity problems.
* A sends B the `q[a][i]` for all `i`.
* B computes `R[a][i]` for all `i` by subtracting `q[a][i] * H` from the Pedersen commitments given by A.
* B computes `R[target]` as `sum where i = 1 to n of R[a][i]`.
* B uses the Wagner Generalized Birthday Paradox technique to find `q[b][i]` with the following constraint:
  * First compute `R[selected][i]` as `R[a][i] +  R[b][i] - q[b][i] * H` for all `i`.
  * Then ensure this constraint: `h(R[target] | m[target]) == sum where i = 1 to n of h(R[selected][i] | m[i])`.
* B sends the `q[b][i]` found above.
* A computes `R[i]` as `R[a][i] + q[a][i] * H + R[b][i] - q[a][i] * H - q[b][i] * H` for all `i`.
  * This resolves down to `R[a][i] + R[b][i] - q[b][i] * H`, or `R[selected][i]`.
* A computes `s[a][i]` as `r[a][i] + h(R[selected][i] | m[i]) * a` for all `i`.
* B sums all `s[a][i]` for all `i` together, forming `(sum where i = 1 to n of r[a][i]) + (sum where i = 1 to n of h(R[selected][i] | m[i])) * a`.
  * This is also a valid signature on `m[target]`, since `sum where i = 1 to n of h(R[selected][i] | m[i])` equals `h(R[target] | m[target])`.

Thus, Pedersen commitments for phase 1 are insecure, as it allows counterparties to control `R`.

ElGamal Commitments in Phase 1
------------------------------

ElGamal commitments prevent B from just giving random `q[b][i]`, thus preventing the above Wagner attack.
However, it is still possible for B to control the resulting `R`, but in doing so this prevents the protocol from completing (thus, even with full control of `R`, B is still unable to promote this to an `R`-reuse attack or the above Wagner attack schema).
This is not quite as bad as the above case, but having just one participant control the nonce `R` should make us worry that other attacks may now become possible (unless we acquire some proof that this will be equivalent in security to the hash-using MuSig).

Briefly, with ElGamal commitments in Phase 1:

1. `R` commitment exchange.
  * A generates random numbers `r[a]` and `q[a]`, B generates random numbers `r[b]` and `q[b]`.
  * A computes its commitment as two points, `q[a] * G` and `r[a] * G + q[a] * H`, B computes its commitment as two points, `q[b] * G` and `r[b] * G + q[b] * H`.
    * `H` is a NUMS point used as a second standard generator.
    * Note that one point uses `q[] * G` while the other adds `q[] * H` to `r[] * G`.
  * They exchange their pairs of points.
2. `R` exchange.
  * They exchange `q[a]` and `q[b]`, and the points `r[a] * G` (== `R[a]`) and `r[b] * G` (== `R[b]`).
  * They validate the exchanged data from the previous `R` commitments.
  * They compute `R` as `R[a]` + `R[b]`.
3. `s` exchange.
  * Same as before.

B can attack this by delaying its phases as below:

1. `R` commitment exchange.
  * B generates random `q[selected]`.
  * B selects target `R[selected]`.
  * After receiving `q[a] * G` and `r[a] * G + q[a] * H`, B computes `q[selected] * G - q[a] * G` and `R[selected] + q[selected] * H - r[a] * G - q[a] * H` and sends those points as its own commitment.
2. `R` exchange.
  * After receiving `q[a]` and `R[a]`, B computes `q[b]` as `q[selected] - q[a]` and computes `R[b]` as `R[selected] - R[a]` and sends both as its decommitment.
  * The resulting `R` will now be `R[selected]` chosen by B.

`s` exchange cannot complete, as that would require that B know `r[selected] - r[a]` where `R[selected] = r[selected] * G`.
Even if B generates `R[selected]` from `r[selected]`, it does not know `r[a]`.
A would provide `r[a] + h(R[selected] | m) * h(L[ab]) * a`, but B would be unable to complete this signature.

The difference here is that B has to select `R[selected]` before it learns `R[a]`, and thus is unable to mount the above Wagner attack schema.
In particular, B first has to compute an `R[target]` equal to `sum where i = 1 to n of R[a][i]` across `n` sessions numbered `i`, in addition to selecting a message `m[i]`.
Then B has to perform a Wagner attack with the constraint `h(R[target] | m[target]) == sum where i = 1 to n of h(R[selected][i] | m[i])`
Fortunately for this scheme, B cannot determine such an `R[target]` before it has to select `R[selected]`, thus preventing this attack.

It may be possible that this scheme is safe, however I am not capable of proving it safe.

Acknowledgments
===============

I contacted Yannick Seurin, Andrew Poelstra, Pieter Wuille, and Greg Maxwell, the authors of MuSig, regarding this issue, and proposing to use Pedersen commitments for the first phase.
They informed me that Tim Ruffing had actually been thinking of similar issue before I did, and also pointed out that Pedersen commitments do not commit to `r * G`, only to `r` (i.e. would have to reveal `r` to serve as a verifiable commitment).
It seemed to me that the general agreement was that ElGamal commitments should work for committing to `r * G`.
However as I show above, this still allows a delaying participant to cancel the `R` contributions of the other parties, allowing it to control the aggregate `R` (though not quite to launch a Wagner attack).

`nickler` and `waxwing` on IRC confirmed my understanding of the attack on 2-phase MuSig.
`waxwing` also mentioned that the paper attacking 2-phase MuSig really attacks CoSi, and that the paper itself admits that given a knowledge-of-secret-keys, CoSi (and presumably 2-phase MuSig) would be safe.


From jlrubin at mit.edu  Tue Nov 26 01:50:40 2019
From: jlrubin at mit.edu (Jeremy)
Date: Mon, 25 Nov 2019 17:50:40 -0800
Subject: [bitcoin-dev] BIP OP_CHECKTEMPLATEVERIFY
Message-ID: <CAD5xwhjXidpeLLUr4TO30t7U3z_zUxTpU9GBpLxu3MWX3ZFeTA@mail.gmail.com>

Bitcoin Developers,

Pleased to announce refinements to the BIP draft for OP_CHECKTEMPLATEVERIFY
(replaces previous OP_SECURETHEBAG BIP). Primarily:

1) Changed the name to something more fitting and acceptable to the
community
2) Changed the opcode specification to use the argument off of the stack
with a primitive constexpr/literal tracker rather than script lookahead
3) Permits future soft-fork updates to loosen or remove "constexpr"
restrictions
4) More detailed comparison to alternatives in the BIP, and why
OP_CHECKTEMPLATEVERIFY should be favored even if a future technique may
make it semi-redundant.

Please see:
BIP: https://github.com/JeremyRubin/bips/blob/ctv/bip-ctv.mediawiki
Reference Implementation:
https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify

I believe this addresses all outstanding feedback on the design of this
opcode, unless there are any new concerns with these changes.

I'm also planning to host a review workshop in Q1 2020, most likely in San
Francisco. Please fill out the form here https://forms.gle/pkevHNj2pXH9MGee9
if you're interested in participating (even if you can't physically attend).

And as a "but wait, there's more":

1) RPC functions are under preliminary development, to aid in testing and
evaluation of OP_CHECKTEMPLATEVERIFY. The new command `sendmanycompacted`
shows one way to use OP_CHECKTEMPLATEVERIFY. See:
https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify-rpcs.
`sendmanycompacted` is still under early design. Standard practices for
using OP_CHECKTEMPLATEVERIFY & wallet behaviors may be codified into a
separate BIP. This work generalizes even if an alternative strategy is used
to achieve the scalability techniques of OP_CHECKTEMPLATEVERIFY.
2) Also under development are improvements to the mempool which will, in
conjunction with improvements like package relay, help make it safe to lift
some of the mempool's restrictions on longchains specifically for
OP_CHECKTEMPLATEVERIFY output trees. See:
https://github.com/bitcoin/bitcoin/pull/17268
This work offers an improvement irrespective of OP_CHECKTEMPLATEVERIFY's
fate.


Neither of these are blockers for proceeding with the BIP, as they are
ergonomics and usability improvements needed once/if the BIP is activated.

See prior mailing list discussions here:

*
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016934.html
*
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016997.html

Thanks to the many developers who have provided feedback on iterations of
this design.

Best,

Jeremy

--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191125/5fc81eb3/attachment.html>

From roconnor at blockstream.io  Wed Nov 27 21:29:32 2019
From: roconnor at blockstream.io (Russell O'Connor)
Date: Wed, 27 Nov 2019 16:29:32 -0500
Subject: [bitcoin-dev] Signing CHECKSIG position in Tapscript
Message-ID: <CAMZUoKm7Y8bRJ+hqmvyPwwTWHaMA7JJc5TZdx7Eufax9G0D=Gg@mail.gmail.com>

Hi all,

I'd like to revisit an old topic from last year about the data signed in
tapscript signatures <
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016508.html
>.

The current tapscript proposal requires a signature on the last executed
CODESEPRATOR position.  I'd like to propose an amendment whereby instead of
signing the last executed CODESEPRATOR position, we simply always sign the
position of the CHECKSIG (or other signing opcode) being executed. Then we
can deprecate CODESEPARTOR (either by making it OP_SUCCESS, or a nop, or
always fail when executed, or whatever).

The main motivation for this proposal is to increase robustness against
various signature-copying attacks in Scripts that have multiple spending
conditions.  Bitcoin is already robust against attacks where the attacker
attempts to peddle a victim's UTXO as their own and try to copy the
victim's signature from one transaction input to another input.  Because
Bitcoin signatures specify which input within a transaction is being signed
for, such attacks fail (see https://bitcoin.stackexchange.com/a/85665/49364
).

However, unless CODESEPARATOR is explicitly used, there is no protection
against these sorts of attacks when there are multiple participants that
have signing conditions within a single UTXO (or rather within a single
tapleaf in the tapscript case).  As it stands, Bitcoin's signed data only
covers which input is being signed, and not the specific conditions are
being signed for.  So for example, if Alice and Bob are engaged in some
kind of multi-party protocol, and Alice wants to pre-sign a transaction
redeeming a UTXO but subject to the condition that a certain hash-preimage
is revealed, she might verify the Script template shows that the code path
to her public key enforces that the hash pre-image is revealed (using a
toolkit like miniscript can aid in this), and she might make her signature
feeling secure that it, if her signature is used, the required preimage
must be revealed on the blockchain.  But perhaps Bob has masquated Alice's
pubkey as his own, and maybe he has inserted a copy of Alice's pubkey into
a different path of the Script template.  Now Alice's signature can be
copied and used in this alternate path, allowing the UTXO to be redeemed
under circumstances that Alice didn't believe she was authorizing.  In
general, to protect herself, Alice needs to inspect the Script to see if
her pubkey occurs in any other branch.  Given that her pubkey, in
principle, could be derived from a computation rather that pushed directly
into the stack, it is arguably infeasible for Alice to perform the required
check in general.

I believe that it would be safer, and less surprising to users, to always
sign the CHECKSIG position by default.  This will automatically enforce
conditions with the signature in most cases, rather than requiring users to
proactively try to reason if CODESEPARATOR is required for protection
within their protocol or not, and risk having them leave it out for cost
savings when it ends up being required for security after all.

I do not believe signing the CHECKSIG position is an undue burden on those
signers who have no conditions they require enforcement for.  As it stands,
the tapscript proposal already requires the tapleaf_hash value under the
signature; this CHECKSIG position value is simply more of the same kind of
data.  In simple Script templates (e.g. those with only one CHECKSIG
operation) the signed position will be a fixed known value.  Complex Script
templates are precisely the situations where you want to be careful about
enforcement of conditions with your signature.

As a side benefit, we get to eliminate CODESEPARATOR, removing a fairly
awkward opcode from this script version.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191127/8cc191b9/attachment.html>

From roconnor at blockstream.io  Wed Nov 27 21:32:51 2019
From: roconnor at blockstream.io (Russell O'Connor)
Date: Wed, 27 Nov 2019 16:32:51 -0500
Subject: [bitcoin-dev] BIP OP_CHECKTEMPLATEVERIFY
In-Reply-To: <CAD5xwhjXidpeLLUr4TO30t7U3z_zUxTpU9GBpLxu3MWX3ZFeTA@mail.gmail.com>
References: <CAD5xwhjXidpeLLUr4TO30t7U3z_zUxTpU9GBpLxu3MWX3ZFeTA@mail.gmail.com>
Message-ID: <CAMZUoKkS77GwTW0B+cbh5BE5koB5oR4zbvEFmufAH7rN+CkR+w@mail.gmail.com>

Thanks for this work Jeremy.

I know we've discussed this before, but I'll restate my concerns with
adding a new "global" state variable to the Script interpreter for tracking
whether the previous opcode was a push-data operation or not.  While it
isn't so hard to implement this in Bitcoin Core's Script interpreter,
adding a new global state variable adds that much more complexity to anyone
trying to formally model Script semantics.  Perhaps one can argue that
there is already (non-stack) state in Script, e.g. to deal with
CODESEPARATOR, so why not add more?  But I'd argue that we should avoid
making bad problems worse.

If we instead make the CHECKTEMPLATEVERIFY operation fail if it isn't
preceded by (or alternatively followed by) an appropriate sized
(canonical?) PUSHDATA constant, even in an unexecuted IF branch, then we
can model the Script semantics by considering the
PUSHDATA-CHECKTEMPLATEVERIFY pair as a single operation.  This allows
implementations to consider improper use of CHECKTEMPLATEVERIFY as a
parsing error (just as today unbalanced IF-ENDIF pairs can be modeled as a
parsing error, even though that isn't how it is implemented in Bitcoin
Core).

I admit we would lose your soft-fork upgrade path to reading values off the
stack; however, in my opinion, this is a reasonable tradeoff.  When we are
ready to add programmable covenants to Script, we'll do so by adding CAT
and operations to push transaction data right onto the stack, rather than
posting a preimage to this template hash.

Pleased to announce refinements to the BIP draft for OP_CHECKTEMPLATEVERIFY
> (replaces previous OP_SECURETHEBAG BIP). Primarily:
>
> 1) Changed the name to something more fitting and acceptable to the
> community
> 2) Changed the opcode specification to use the argument off of the stack
> with a primitive constexpr/literal tracker rather than script lookahead
> 3) Permits future soft-fork updates to loosen or remove "constexpr"
> restrictions
> 4) More detailed comparison to alternatives in the BIP, and why
> OP_CHECKTEMPLATEVERIFY should be favored even if a future technique may
> make it semi-redundant.
>
> Please see:
> BIP: https://github.com/JeremyRubin/bips/blob/ctv/bip-ctv.mediawiki
> Reference Implementation:
> https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify
>
> I believe this addresses all outstanding feedback on the design of this
> opcode, unless there are any new concerns with these changes.
>
> I'm also planning to host a review workshop in Q1 2020, most likely in San
> Francisco. Please fill out the form here
> https://forms.gle/pkevHNj2pXH9MGee9 if you're interested in participating
> (even if you can't physically attend).
>
> And as a "but wait, there's more":
>
> 1) RPC functions are under preliminary development, to aid in testing and
> evaluation of OP_CHECKTEMPLATEVERIFY. The new command `sendmanycompacted`
> shows one way to use OP_CHECKTEMPLATEVERIFY. See:
> https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify-rpcs.
> `sendmanycompacted` is still under early design. Standard practices for
> using OP_CHECKTEMPLATEVERIFY & wallet behaviors may be codified into a
> separate BIP. This work generalizes even if an alternative strategy is used
> to achieve the scalability techniques of OP_CHECKTEMPLATEVERIFY.
> 2) Also under development are improvements to the mempool which will, in
> conjunction with improvements like package relay, help make it safe to lift
> some of the mempool's restrictions on longchains specifically for
> OP_CHECKTEMPLATEVERIFY output trees. See: https://github.com/bitcoin/bitcoin/pull/17268
> This work offers an improvement irrespective of OP_CHECKTEMPLATEVERIFY's
> fate.
>
>
> Neither of these are blockers for proceeding with the BIP, as they are
> ergonomics and usability improvements needed once/if the BIP is activated.
>
> See prior mailing list discussions here:
>
> *
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016934.html
> *
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016997.html
>
> Thanks to the many developers who have provided feedback on iterations of
> this design.
>
> Best,
>
> Jeremy
>
> --
> @JeremyRubin <https://twitter.com/JeremyRubin>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191127/4bb82570/attachment.html>

From aj at erisian.com.au  Thu Nov 28 08:06:59 2019
From: aj at erisian.com.au (Anthony Towns)
Date: Thu, 28 Nov 2019 18:06:59 +1000
Subject: [bitcoin-dev] Signing CHECKSIG position in Tapscript
In-Reply-To: <CAMZUoKm7Y8bRJ+hqmvyPwwTWHaMA7JJc5TZdx7Eufax9G0D=Gg@mail.gmail.com>
References: <CAMZUoKm7Y8bRJ+hqmvyPwwTWHaMA7JJc5TZdx7Eufax9G0D=Gg@mail.gmail.com>
Message-ID: <20191128080659.msrpdpcjhhvbqtv2@erisian.com.au>

On Wed, Nov 27, 2019 at 04:29:32PM -0500, Russell O'Connor via bitcoin-dev wrote:
> The current tapscript proposal requires a signature on the last executed
> CODESEPRATOR position.? I'd like to propose an amendment whereby instead of
> signing the last executed CODESEPRATOR position, we simply always sign the
> position of the CHECKSIG (or other signing opcode) being executed.

FWIW, there's discussion of this at
http://www.erisian.com.au/taproot-bip-review/log-2019-11-28.html#l-65

> However, unless CODESEPARATOR is explicitly used, there is no protection
> against these sorts of attacks when there are multiple participants that have
> signing conditions within a single UTXO (or rather within a single tapleaf in
> the tapscript case).

(You already know this, but:)

With taproot key path spending, the only other conditions that can be
placed on a transaction are nSequence, nLockTime, and the annex, all of
which are committed to via the signature; so I think this concern only
applies to taproot script path spending.

The proposed sighashes for taproot script path spending all commit to
the script being used, so you can't reuse the signature in a different
leaf of the merkle tree of scripts for the UTXO, only in a separate
execution path within the script you're already looking at.

> So for example, if Alice and Bob are engaged in some kind of multi-party
> protocol, and Alice wants to pre-sign a transaction redeeming a UTXO but
> subject to the condition that a certain hash-preimage is revealed, she might
> verify the Script template shows that the code path to her public key enforces
> that the hash pre-image is revealed (using a toolkit like miniscript can aid in
> this), and she might make her signature feeling secure that it, if her
> signature is used, the required preimage must be revealed on the blockchain.?
> But perhaps Bob has masquated Alice's pubkey as his own, and maybe he has
> inserted a copy of Alice's pubkey into a different path of the Script
> template.
>
> Now Alice's signature can be copied and used in this alternate path,
> allowing the UTXO to be redeemed under circumstances that Alice didn't believe
> she was authorizing.? In general, to protect herself, Alice needs to inspect
> the Script to see if her pubkey occurs in any other branch.? Given that her
> pubkey, in principle, could be derived from a computation rather that pushed
> directly into the stack, it is arguably infeasible for Alice to perform the
> required check in general.

First, it seems like a bad idea for Alice to have put funds behind a
script she doesn't understand in the first place. There's plenty of
scripts that are analysable, so just not using ones that are too hard to
analyse sure seems like an option.

Second, if there are many branches in the script, it's probably more
efficient to do them via different branches in the merkle tree, which
at least for this purpose would make them easier to analyse as well
(since you can analyse them independently).

Third, if you are doing something crazy complex where a particular key
could appear in different CHECKSIG operators and they should have
independent signatures, that seems like you're at the level of
complexity where learning about CODESEPARATOR is a reasonable thing to
do.

I think CODESEPARATOR is a better solution to this problem anyway. In
particular, consider a "leaf path root OP_MERKLEPATHVERIFY" opcode,
and a script that says "anyone in group A can spend if the preimage for
X is revelaed, anyone in group B can spend unconditionally":

 IF HASH160 x EQUALVERIFY groupa ELSE groupb ENDIF
 MERKLEPATHVERIFY CHECKSIG

spendable by

 siga keya path preimagex 1

or

 sigb keyb path 0

With your proposed semantics, if my pubkey is in both groups, my signature
will sign for position 10, and still be valid on either path, even if
the signature commits to the CHECKSIG position.

I could fix my script either by having two CHECKSIG opcodes (one for
each branch) and also duplicating the MERKLEPATHVERIFY; or I could
add a CODESEPARATOR in either IF branch.

(Or I could just not reuse the exact same pubkey across groups; or I could
have two separate scripts: "HASH160 x EQUALVERIFY groupa MERKLEPATHVERIFY
CHECKSIG" and "groupb MERKLEPATHVERIFY CHECKSIG")

> I believe that it would be safer, and less surprising to users, to always sign
> the CHECKSIG position by default.

> As a side benefit, we get to eliminate CODESEPARATOR, removing a fairly awkward
> opcode from this script version.

As it stands, ANYPREVOUTANYSCRIPT proposes to not sign the script code
(allowing the signature to be reused in different scripts) but does
continue signing the CODESEPARATOR position, allowing you to optionally
restrict how flexibly you can reuse signatures. That seems like a better
tradeoff than having ANYPREVOUTANYSCRIPT signatures commit to the CHECKSIG
position which would make it a fair bit harder to design scripts that
can share signatures, or not having any way to restrict which scripts
the signature could apply to other than changing the pubkey.

A hypothetical alternate "codeseparator" design: when script execution
starts, initialise an empty byte string "trace"; each time an opcode
is executed append "0xFF"; each time an opcode is skipped append
"0x00". When a CODESEPARATOR is seen, calculate sha256(trace) and store
it, everytime a CHECKSIG is executed, include the sha256(trace) from the
last CODESEPARATOR in the digest [0]. That should make each checksig
commit to the exact path the script took up to the last CODESEPARATOR
seen. I think it's probably more complex than is really useful though,
so I'm not proposing it seriously.

[0] If there's not been a CODESEPARATOR, then sha256(trace)=sha256("");
    if there's been one CODESEPARATOR and it was the first opcode seen,
    sha256(trace)=sha256("\xff").

Cheers,
aj


From jlrubin at mit.edu  Thu Nov 28 19:59:42 2019
From: jlrubin at mit.edu (Jeremy)
Date: Fri, 29 Nov 2019 04:59:42 +0900
Subject: [bitcoin-dev] BIP OP_CHECKTEMPLATEVERIFY
In-Reply-To: <CAMZUoKkS77GwTW0B+cbh5BE5koB5oR4zbvEFmufAH7rN+CkR+w@mail.gmail.com>
References: <CAD5xwhjXidpeLLUr4TO30t7U3z_zUxTpU9GBpLxu3MWX3ZFeTA@mail.gmail.com>
 <CAMZUoKkS77GwTW0B+cbh5BE5koB5oR4zbvEFmufAH7rN+CkR+w@mail.gmail.com>
Message-ID: <CAD5xwhi115pHK4J4=WDX=xbusxG_qP-oOWYNsD4z1Hh7JZ1yzQ@mail.gmail.com>

Thanks for the feedback Russell, now and early. It deeply informed the
version I'm proposing here.

I weighed carefully when selecting this design that I thought it would be
an acceptable tradeoff after our discussion, but I recognize this isn't
exactly what you had argued for.

First off, with respect to the 'global state' issue, I figured it was
reasonable with this choice of constexpr rule given that a reasonable tail
recursive parser might look something like:

parse (code : rest) stack alt_stack just_pushed =
    match code with
        OP_PUSH => parse rest (x:stack) alt_stack True
        OP_DUP => parse rest (x:stack) alt_stack False
        // ...

So we're only adding one parameter which is a bool, and we only need to
ever set it to an exact value based on the current code path, no
complicated rules. I'm sensitive to the complexity added when formally
modeling script, but I think because it is only ever a literal, you could
re-write it as co-recursive:

parse_non_constexpr (code : rest) stack alt_stack =
    match code with
        OP_PUSH => parse_constexpr rest (x:stack) alt_stack
        OP_DUP => parse_non_constexpr rest (x:stack) alt_stack
        // ...

parse_constexpr (code : rest) stack alt_stack  =
    match code with
        OP_CTV => ...
        _ => parese_non_constexpr (code : rest) stack alt_stack


If I recall, this should help a bit with the proof automatability as it's
easier in the case by case breakdown to see the unconditional code paths.


In terms of upgrade-ability, one of the other reasons I liked this design
is that if we do enable OP_CTV for non-constexpr arguments, the issue
basically goes away and the OP becomes "pure" without any state tracking.
(I think the switching on argument size is much less a concern because we
already use similar upgrade mechanisms elsewhere, and it doesn't add
parsing context).


It's also possible, as I think *should be done* for tooling to treat an
unbalanced OP_CTV as a parsing error. This will always produce
consensus-valid scripts! However by keeping the consensus rules more
relaxed we keep our upgrade-ability paths open for OP_CTV, which as I
understand from speaking with other users is quite desirable.


Best (and happy thanksgiving to those celebrating),

Jeremy

--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>


On Thu, Nov 28, 2019 at 6:33 AM Russell O'Connor <roconnor at blockstream.io>
wrote:

> Thanks for this work Jeremy.
>
> I know we've discussed this before, but I'll restate my concerns with
> adding a new "global" state variable to the Script interpreter for tracking
> whether the previous opcode was a push-data operation or not.  While it
> isn't so hard to implement this in Bitcoin Core's Script interpreter,
> adding a new global state variable adds that much more complexity to anyone
> trying to formally model Script semantics.  Perhaps one can argue that
> there is already (non-stack) state in Script, e.g. to deal with
> CODESEPARATOR, so why not add more?  But I'd argue that we should avoid
> making bad problems worse.
>
> If we instead make the CHECKTEMPLATEVERIFY operation fail if it isn't
> preceded by (or alternatively followed by) an appropriate sized
> (canonical?) PUSHDATA constant, even in an unexecuted IF branch, then we
> can model the Script semantics by considering the
> PUSHDATA-CHECKTEMPLATEVERIFY pair as a single operation.  This allows
> implementations to consider improper use of CHECKTEMPLATEVERIFY as a
> parsing error (just as today unbalanced IF-ENDIF pairs can be modeled as a
> parsing error, even though that isn't how it is implemented in Bitcoin
> Core).
>
> I admit we would lose your soft-fork upgrade path to reading values off
> the stack; however, in my opinion, this is a reasonable tradeoff.  When we
> are ready to add programmable covenants to Script, we'll do so by adding
> CAT and operations to push transaction data right onto the stack, rather
> than posting a preimage to this template hash.
>
> Pleased to announce refinements to the BIP draft for
>> OP_CHECKTEMPLATEVERIFY (replaces previous OP_SECURETHEBAG BIP). Primarily:
>>
>> 1) Changed the name to something more fitting and acceptable to the
>> community
>> 2) Changed the opcode specification to use the argument off of the stack
>> with a primitive constexpr/literal tracker rather than script lookahead
>> 3) Permits future soft-fork updates to loosen or remove "constexpr"
>> restrictions
>> 4) More detailed comparison to alternatives in the BIP, and why
>> OP_CHECKTEMPLATEVERIFY should be favored even if a future technique may
>> make it semi-redundant.
>>
>> Please see:
>> BIP: https://github.com/JeremyRubin/bips/blob/ctv/bip-ctv.mediawiki
>> Reference Implementation:
>> https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify
>>
>> I believe this addresses all outstanding feedback on the design of this
>> opcode, unless there are any new concerns with these changes.
>>
>> I'm also planning to host a review workshop in Q1 2020, most likely in
>> San Francisco. Please fill out the form here
>> https://forms.gle/pkevHNj2pXH9MGee9 if you're interested in
>> participating (even if you can't physically attend).
>>
>> And as a "but wait, there's more":
>>
>> 1) RPC functions are under preliminary development, to aid in testing and
>> evaluation of OP_CHECKTEMPLATEVERIFY. The new command `sendmanycompacted`
>> shows one way to use OP_CHECKTEMPLATEVERIFY. See:
>> https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify-rpcs.
>> `sendmanycompacted` is still under early design. Standard practices for
>> using OP_CHECKTEMPLATEVERIFY & wallet behaviors may be codified into a
>> separate BIP. This work generalizes even if an alternative strategy is used
>> to achieve the scalability techniques of OP_CHECKTEMPLATEVERIFY.
>> 2) Also under development are improvements to the mempool which will, in
>> conjunction with improvements like package relay, help make it safe to lift
>> some of the mempool's restrictions on longchains specifically for
>> OP_CHECKTEMPLATEVERIFY output trees. See: https://github.com/bitcoin/bitcoin/pull/17268
>> This work offers an improvement irrespective of OP_CHECKTEMPLATEVERIFY's
>> fate.
>>
>>
>> Neither of these are blockers for proceeding with the BIP, as they are
>> ergonomics and usability improvements needed once/if the BIP is activated.
>>
>> See prior mailing list discussions here:
>>
>> *
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016934.html
>> *
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016997.html
>>
>> Thanks to the many developers who have provided feedback on iterations of
>> this design.
>>
>> Best,
>>
>> Jeremy
>>
>> --
>> @JeremyRubin <https://twitter.com/JeremyRubin>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191129/880e74bc/attachment.html>

From lloyd.fourn at gmail.com  Fri Nov 29 05:50:33 2019
From: lloyd.fourn at gmail.com (Lloyd Fournier)
Date: Fri, 29 Nov 2019 16:50:33 +1100
Subject: [bitcoin-dev] Composable MuSig
In-Reply-To: <u1IeyK5A7zyklXzl26UpCliJrFEsDp5SXUGbtXGBCrEWw6Wi7vNcoy4HNv2WXUTG_SBuMURDLhvh3YCwL2r53rL0Yj19TZpumYFD5WqmYL8=@protonmail.com>
References: <u1IeyK5A7zyklXzl26UpCliJrFEsDp5SXUGbtXGBCrEWw6Wi7vNcoy4HNv2WXUTG_SBuMURDLhvh3YCwL2r53rL0Yj19TZpumYFD5WqmYL8=@protonmail.com>
Message-ID: <CAH5Bsr2rsiU9gV6VsGH3ZCWGRoTz=g5hXNq37P3P6HB+MmxUAA@mail.gmail.com>

Hi ZmnSCPxj,

Very interesting problem.

Just a quick note: I think there is a way to commit to a point properly
with Pedersen commitments. Consider the following:
COM(X) = (y*G + z*H, y*G + X)  where y and z are random and the opening is
(y,z,X).  This seems to be a  unconditionally hiding and computationally
binding homomorphic commitment scheme to a point based on the DL problem
rather than DDH.

LL

On Mon, Nov 25, 2019 at 10:00 PM ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> So I heard you like MuSig.
>
>
> Introduction
> ============
>
> Previously on lightning-dev, I propose Lightning Nodelets, wherein one
> signatory of a channel is in fact not a single entity, but instead an
> aggregate:
> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002236.html
>
> Generalizing:
>
> * There exists some protocol that requires multiple participants agreeing.
>   * This can be implemented by use of MuSig on the public keys of the
> participants.
> * One or more of the participants in the above protocol is in fact an
> aggregate, not a single participant.
>   * Ideally, no protocol modification should be needed to support such
> aggregates, "only" software development without modifying the protocol
> layer.
>   * Obviously, any participant of such a protocol, whether a direct
> participant, or a member of an aggregated participant of that protocol,
> would want to retain control of its own money in that protocol, without
> having to determine if it is being Sybilled (and all other participants are
> in fact just one participant).
>   * Motivating example: a Lightning Network channel is the aggregate of
> two participants, the nodes creating that channel.
>     However, with nodelets as proposed above, one of the participants is
> actually itself an aggregate of multiple nodelets.
>     * This requires that a Lightning Network channel with a MuSig address,
> to have one or both participants, be potentially an aggregate of two or
> more nodelet participants, e.g. `MuSig(MuSig(A, B), C)`
>
> This is the "MuSig composition" problem.
> That is, given `MuSig(MuSig(A, B), C)`, and the *possibility* that in fact
> `B == C`, what protocol can A use to ensure that it uses the three-phase
> MuSig protocol (which has a proof of soundness) and not inadvertently use a
> two-phase MuSig protocol?
>
> Schnorr Signatures
> ==================
>
> The scheme is as follows.
>
> Suppose an entity A needs to show a signature.
> At setup:
>
> * It generates a random scalar `a`.
> * It computes `A` as `A = a * G`, where `G` is the standard generator
> point.
> * It publishes `A`.
>
> At signing a message `m`:
>
> * It generates a random scalar `r`.
> * It computes `R` as `R = r * G`.
> * It computes `e` as `h(R | m)`, where `h()` is a standard hash function
> and `x | y` denotes the serialization of `x` concatenated by the
> serialization of `y`.
> * It computes `s` as `s = r + e * a`.
> * It publishes as signature the tuple of `(R, s)`.
>
> An independent validator can then get `A`, `m`, and the signature `(R, s)`.
> At validation:
>
> * It recovers `e[validator]` as so: `e[validator] = h(R | m)`
> * It computes `S[validator]` as so: `S[validator] = R + e[validator] * A`.
> * It checks if `s * G == S[validator]`.
>   * If `R` and `s` were indeed generated as per signing algorithm above,
> then:
>     * `S[validator] = R + e[validator] * A`
>     * `== r * G + e[validator] * A`; subbstitution of `R`
>     * `== r * G + h(R | m) * A`; substitution of `e[validator]`
>     * `== r * G + h(R | m) * a * G`; substitution of `A`.
>     * `== (r + h(R | m) * a) * G`; factor out `G`
>     * `== (r + e * a) * G`; substitution of `h(R | m)` with `e`
>     * `== s * G`; substitution of `r + e * a`.
>
> MuSig
> =====
>
> Under MuSig, validation must remain the same, and multiple participants
> must provide a single aggregate key and signature.
>
> Suppose there exist two participants A and B.
> At setup:
>
> * A generates a random scalar `a` and B generates a random scalar `b`.
> * A computes `A` as `A = a * G` and B computes `B` as `B = b * G`.
> * A and B exchange `A` and `B`.
> * They generate the list `L`, by sorting their public keys and
> concatenating their representations.
> * They compute their aggregate public key `P` as `P = h(L) * A + h(L) * B`.
> * They publish the aggregate public key `P`.
>
> Signing takes three phases.
>
> 1.  `R` commitment exchange.
>   * A generates a random scalar `r[a]` and B generates a random scalar
> `r[b]`.
>   * A computes `R[a]` as `R[a] = r[a] * G` and B computes `R[b]` as `R[b]
> = r[b] * G`.
>   * A computes `h(R[a])` and B computes `h(R[b])`.
>   * A and B exchange `h(R[a])` and `h(R[b])`.
> 2.  `R` exchange.
>   * A and B exchange `R[a]` and `R[b]`.
>   * They validate that the previous given `h(R[a])` and `h(R[b])` matches.
> 3.  `s` exchange.
>   * They compute `R` as `R = R[a] + R[b]`.
>   * They compute `e` as `h(R | m)`.
>   * A computes `s[a]` as `s[a] = r[a] + e * h(L) * a` and B computes
> `s[b]` as `s[b] = r[b] + e * h(L) * b`.
>   * They exchange `s[a]` and `s[b]`.
>   * They compute `s` as `s = s[a] + s[b]`.
>   * They publish the signature as the tuple `(e, s)`.
>
> At validation, the validator knows `P`, `m`, and the signature `(R, s)`.
>
> * It recovers `e[validator]` as so: `e[validator] = h(R | m)`
> * It computes `S[validator]` as so: `S[validator] = R + e[validator] * P`.
> * It checks if `s * G == S[validator]`.
>   * `S[validator] = R + e[validator] * P`
>   * `== R[a] + R[b] + e[validator] * P`; substitution of `R`
>   * `== r[a] * G + r[b] * G + e[validator] * P`; substitution of `R[a]`
> and `R[b]`
>   * `== r[a] * G + r[b] * G + e * P`; substitution of `e[validator]` with
> `e`
>   * `== r[a] * G + r[b] * G + e * (h(L) * A + h(L) * B)`; substitution of
> `P`
>   * `== r[a] * G + r[b] * G + e * h(L) * A + e * h(L) * B`; distribution
> of `e` inside parentheses.
>   * `== r[a] * G + r[b] * G + e * h(L) * a * G + e * h(L) * b * G`;
> substitution of `A` and `B`.
>   * `== (r[a] + r[b] + e * h(L) * a + e * h(L) * b) * G`; factoring out of
> `G`
>   * `== (r[a] + e * h(L) * a + r[b] + e * h(L) * b) * G`; rearrangement of
> terms
>   * `== (s[a] + s[b]) * G`; substitution of `r[a] + e * h(L) * a` and
> `r[b] + e * h(L) * b`
>   * `== s * G`;  substitution of `s[a] + s[b]`
>
>
> Two-Phase MuSig Unsafe
> ======================
>
> Original proposal of MuSig only had two phases, `R` exchange and `s`
> exchange.
> However, there was a flaw found in the security proof in this two-phase
> MuSig.
> In response, an earlier phase of exchanging commitments to `R` was added.
>
> Thus, two-phase MuSig is potentially unsafe.
>
> https://eprint.iacr.org/2018/417.pdf describes the argument.
> Briefly, with two-phase MuSig, one of the participants can deliberately
> delay its side of a `R` exchange and control the resulting sum `R` by
> cancelling the `R` of the other participant.
> Executed over many (aborted) signing sessions, one participant can induce
> the other to create a signature for a message it might not agree to, by
> using the Wagner Generalized Birthday Paradox attack.
>
> Briefly, a two-phase MuSig signing would go this way:
>
> 1.  `R` exchange.
>   * A generates random scalar `r[a]` and B generates random scalar `r[b]`.
>   * A computes `R[a]` as `r[a] * G` and B computes `R[b]` as `r[b] * G`.
>   * They exchange `R[a]` and `R[b]`.
> 2.  `s` exchange.
>   * They compute `R` as `R = R[a] + R[b]`.
>   * They compute `e` as `h(R | m)`.
>   * A computes `s[a]` as `s[a] = r[a] + e * h(L) * a` and B computes
> `s[b]` as `s[b] = r[b] + e * h(L) * b`.
>   * They exchange `s[a]` and `s[b]`.
>   * They compute `s` as `s = s[a] + s[b]`.
>   * They publish the signature as the tuple `(R, s)`.
>
> The sticking point is "exchange" here.
> Given that we live in a relativistic universe where there is no such thing
> as simultaneity-in-time-without-simultaneity-in-space, it is impossible to
> ensure that both A and B send their data "at the same time" in such a way
> that it is impossible for, for example, the send of B to be outside the
> future light cone of the send of A.
> Or in human-level terms, it is not possible to ensure over the network
> that B will not send `R[b]` *after* it receives `R[a]`.
>
> Suppose that instead of B generating a random `r[b]` and *then* computing
> `R[b] = r[b] * G`, it instead selects an arbitrary `R[selected]` it wants
> to target, then compute `R[b]` as `R[selected] - R[a]`.
> Then at `s` exchange:
>
> * They compute `R` as `R[a] + R[b]`, which is in fact `R[a] + R[selected]
> - R[a]`, or `R[selected]`, i.e. `R == R[selected]`.
> * They compute `e` as `h(R[selected] | m)`.
> * A computes `s[a]` as `s[a] = r[a] + e * h(L) * a`.
> * B is unable to compute `s[b]` as it has no `r[b]` it can use in the
> computation, and aborts the signing.
>
> The attack involved is that multiple such signing sessions, for the same
> message or for separate distinct messages, might be done in parallel.
> Suppose that there are `n` such sessions, such that A provides `n`
> different `R[a][i]`, e.g. `R[a][1]`, `R[a][2]`, `R[a][3]` up to `R[a][n]`.
> Then:
>
> * B delays each session, pretending to have Internet connectivity problems.
> * B selects a message `m[target]` that it knows A will never sign (e.g.
> "I, A, give all my money to B").
> * B computes `R[target]` as `sum where i = 1 to n of R[a][i]`.
> * B uses the Wagner Generalized Birthday Paradox technique to find
> `R[selected][i]` with the following constraint:
>   * `h(R[target] | m[target]) == sum where i = 1 to n of h(R[selected][i]
> | m[i])`.
>   * Given a large enough number of parallel sessions `n`, this can greatly
> reduce the effort from 2^128 to find a match to within the realm of a large
> computer to compute within a few seconds.
> * B computes `R[b][i]` as `R[selected][i] - R[a][i]`, for each `i` from 1
> to `n`.
> * B provides `R[b][i]` for each session.
> * A computes `R[i]` as `R[a][i] + R[b][i]` for each session.
>   * However we know that `R[b][i] == R[selected][i] - R[a][i]` for each
> session, cancelling out `R[a][i]` and leaving `R[i] == R[selected][i]`
> * A computes `s[a][i]` as `r[a][i] + h(R[selected][i] | m[i]) * h(L) * a`
> for each session.
> * A gives `s[a][i]` for each session.
> * B aborts each session.
> * B sums up all the `s[a][i]`:
>   * `(sum where i = 1 to n of r[a][i]) + (sum where i = 1 to n of
> h(R[selected][i] | m[i]) * h(L) * a)`.
>   * Remember, B has specifically selected `R[selected][i]` such that
> `h(R[target] | m[target])` is equal to the sum of `h(R[selected][i] |
> m[i])`.
>   * `== (sum where i = 1 to n of r[a][i]) + h(R[target] | m[target]) *
> h(L) * a)`.
> * B adds `h(R[target] | m[target]) * h(L) * b` to the above sum.
>   * This results in a signature for MuSig(A, B) to the message
> `m[target]`, even though A would never have agreed to this message.
>
> Thus, 2-phase MuSig enables a Wagner attack on the participant, thus it is
> unsafe.
>
> Now, any method of ensuring a "simultaneous" exchange of `R` points is
> largely the same as adding a "commit to `R`" phase, i.e. the fix for this
> is simply to add the "`R` commitment exchange" phase.
>
> References: https://eprint.iacr.org/2018/417.pdf
>
> MuSig Composition
> =================
>
> Let us suppose that we have some protocol that requires a MuSig signing
> session between signers with public keys `P` and `C`.
> Let us further suppose that in fact, `P = MuSig(A, B)`, i.e. one of the
> public keys in this protocol is, in reality, itself a MuSig of two
> participants.
>
> At the point of view of signer C, P is a single participant and it acts as
> such.
> However, in reality, P is an aggregate.
>
> We want to have the following properties:
>
> * C should never need to know that P is in fact an aggregate.
> * Even if B is secretly the same as C, the entire protocol as a whole
> (including the aggregate signing of `MuSig(A, B)`) should remain
> three-phase MuSig.
>
> Now, from the point of view of C, what it sees are:
>
> At setup:
>
> * It generates a random scalar `c` and the public key `C` as `C = c * G`.
> * It exchanges keys with P and gets the public key `P`.
> * It computes `L` by sorting `C` and `P` and concatenating them.
> * It determines their aggregate key as `h(L) * C + h(L) * P`.
>
> At signing:
>
> 1.  `R` commitment exchange.
>   * It generates a random scalar `r[c]` and computes `R[c]` as `R[c] =
> r[c] * G`.
>   * It computes `h(R[c])`.
>   * It exchanges the hash `h(R[c])` with P and gets `h(R[p])`.
> 2.  `R` exchange.
>   * It exchanges `R[c]` with P and gets `R[p]`.
>   * It validates that the hash `h(R[p])` matches the previously-committed
> hash.
> 3.  `s` exchange.
>   * It computes `R` as `R = R[c] + R[p]`.
>   * It computes `e` as `e = h(R | m)`.
>   * It computes `s[c]` as `s[c] = r[c] + e * c`.
>   * It exchanges `s[c]` with P and gets `s[p]`.
>   * It computes `s` as `s = s[c] + s[p]`.
>
> However, from point of view of A and B, what actually happens is this:
>
> At setup:
>
> * A generates a random scalar `a` and computes `A = a * G`, B generates a
> random scalar `b` and computes `B = b * G`.
> * They exchange `A` and `B`.
> * They generate their own `L[ab]`, by sorting `A` and `B` and
> concatenating their representations.
> * They compute the inner MuSig pubkey `P` as `P = h(L[ab]) * A + h(L[ab])
> * B`.
> * They exchange `P` with C, and get `C`.
> * They compute the outer MuSig pubkey as `h(L) * P + h(L) * C`.
>
> At signing:
>
> 1.  `R` commitment exchange.
>   * A generates a random scalar `r[a]` and computes `R[a] = r[a] * G`, B
> generates a random scalar `r[b]` and computes `R[b] = r[b] * G`.
>   * A computes `h(R[a])`, B computes `h(R[b])`.
>   * They exchange `h(R[a])` and `h(R[b])`.
>   * They need to compute `h(R[p])` for the protocol with C.
>     * However, even if we know `R[p] == R[a] + R[b]`, we cannot generate
> `h(R[p])`.
>     * Thus, they have no choice but to exchange `R[a]` and `R[b]` at this
> phase, even though this is supposed to be the `R` commitment exchange phase
> (and they should not share `R[a]` and `R[b]` yet)!
>
> Unfortunately, this means that, between A and B, we are now reduced to a
> two-phase MuSig.
> This is relevant if B and C happen to be the same entity or are
> cooperating.
>
> Basically, before C has to provide its `h(R[c])`, B now knows the
> generated `R[a]` and `R[b]`.
> If B and C are really the same entity, then C can compute `R[c]` as
> `R[selected] - R[a] - R[b]` before providing `h(R[c])`.
> Then this devolves to the same attack that brings down 2-phase MuSig.
>
> Thus, composition with the current MuSig proposal is insecure.
>
> Towards a Composable Multi-`R` MuSig
> ====================================
>
> A key element is that the first phase simply requires that all
> participants provide *commitments* to their individual `R`, and the second
> phase reveals their `R`.
>
> I propose here the modification below:
>
> * In the first phase, any participant in the MuSig may submit one *or
> more* `R` commitments.
> * In the second phase, the participant in the MuSig submits each `R` that
> decommits each of the `R` commitments it sent.
>
> I call this the Remote R Replacement Remanded: Redundant R Required
> Realistically, or, in shorter terms, the Multi-`R` proposal.
>
> This is a simple and direct extension of the MuSig protocol, and expected
> to not have any effect on the security proof of MuSig.
>
> In the case where all MuSig participants are singletons and each
> participant just generates and sends a single `R` commitment, then this
> proposal reduces to the original MuSig proposal.
>
> However, in the case where one participant is in reality itself an
> aggregate, then we shall describe it below.
> The below example is `MuSig(MuSig(A, B), C)`.
>
> 1.  `R` commitment exchange.
>   * A generates a random number `r[a]`, B generates a random number
> `r[b]`, C generates a random number `r[c]`.
>   * A computes `R[a]` as `r[a] * G`, B computes `R[b]` as `r[b] * G`, C
> computes `R[c]` as `r[c] * G`.
>   * A computes `h(R[a])`, B computes `h(R[b])`, C computes `h(R[c])`.
>   * A and B exchange their hashes with each other.
>   * A and B jointly exchange their `h(R[a])` and `h(R[b])` with the
> `h(R[c])` from C.
> 2.  `R` exchange.
>   * A and B reveal their `R[a]` and `R[b]` with each other.
>   * A and B validate the given `R[a]` matches `h(R[a])` and the given
> `R[b]` matches `h(R[b])`.
>   * A and B jointly exchange their `R[a]` and `R[b]` with the `R[c]` from
> C.
>   * C validates `R[a]` and `R[b]`, A and B validate `R[c]`.
>   * They compute `R` as the sum of all `R[a] + R[b] + R[c]`.
> 3.  `s` exchange.
>   * They compute `e` as `h(R | m)`.
>   * A computes `s[a]` as `r[a] + e * h(L[abc]) * h(L[ab]) * a`, B computes
> `s[b]` as `r[b] + e * h(L[abc]) * h(L[ab]) * b`.
>   * C computes `s[c]` as `r[c] + e * h(L[abc]) * c`.
>   * A and B exchange `s[a]` and `s[b]`.
>   * A and B compute `s[ab]` as `s[a] + s[b]`.
>   * A and B jointly exchange their `s[ab]` with `s[c]` from C.
>   * They compute `s` as `s[ab] + s[c]`.
>   * They publish the signature as the tuple `(R, s)`.
>
> Of note, is that the number of `R` a participant provides is a strong hint
> as to whether it is actually an aggregate or not, and forms an upper bound
> as to the size of the aggregate (i.e. an aggregate of `n` members can
> pretend to be an aggregate of `m` members where `n < m`, but cannot pretend
> with `n > m`).
> Thus, C here learns that its counterparty is actually itself an aggregate
> rather than a singleton.
> This may be acceptable as a weak reduction in privacy (in principle, C
> should never learn that it is talking to an aggregate rather than a single
> party).
>
> Alternative Composable MuSig Schemes
> ====================================
>
> The above proposal is not the only one.
> Below are some additional proposals which have various flaws, ranging from
> outright insecurity to practical implementation complexity issues.
>
> Pedersen Commitments in Phase 1
> -------------------------------
>
> My initial proposal was to use Pedersen commitments in phase 1.
> At phase 1, each party would generate a `r[x]` and `q[x]`, and exchange
> the Pedersen commitments `r[x] * G + q[x] * H`, where `H` is a NUMS point
> used as a second standard generator.
> Then at phase 2, each party reveals its `q[x]`.
> All the Pedersen commitments are summed, then all `q[x]` are summed,
> multiplied by `H`, then subtracted from the sum of Pedersen commitments.
>
> Unfortunately, this leads to a Wagner attack.
>
> Suppose A and B have an aggregate MuSig(A, B).
>
> * B initiates multiple parallel signing sessions with A.
> * B selects a message `m[target]` that it knows A will never sign (e.g.
> "I, A, give all my money to B").
> * In the first phase, B selects random points `R[b][i]` for each session
> `i` and provides that as its Pedersen commitment, receiving `R[a][i] +
> q[a][i] * H` in exchange.
> * In the second phase, B delays each session, pretending to have Internet
> connectivity problems.
> * A sends B the `q[a][i]` for all `i`.
> * B computes `R[a][i]` for all `i` by subtracting `q[a][i] * H` from the
> Pedersen commitments given by A.
> * B computes `R[target]` as `sum where i = 1 to n of R[a][i]`.
> * B uses the Wagner Generalized Birthday Paradox technique to find
> `q[b][i]` with the following constraint:
>   * First compute `R[selected][i]` as `R[a][i] +  R[b][i] - q[b][i] * H`
> for all `i`.
>   * Then ensure this constraint: `h(R[target] | m[target]) == sum where i
> = 1 to n of h(R[selected][i] | m[i])`.
> * B sends the `q[b][i]` found above.
> * A computes `R[i]` as `R[a][i] + q[a][i] * H + R[b][i] - q[a][i] * H -
> q[b][i] * H` for all `i`.
>   * This resolves down to `R[a][i] + R[b][i] - q[b][i] * H`, or
> `R[selected][i]`.
> * A computes `s[a][i]` as `r[a][i] + h(R[selected][i] | m[i]) * a` for all
> `i`.
> * B sums all `s[a][i]` for all `i` together, forming `(sum where i = 1 to
> n of r[a][i]) + (sum where i = 1 to n of h(R[selected][i] | m[i])) * a`.
>   * This is also a valid signature on `m[target]`, since `sum where i = 1
> to n of h(R[selected][i] | m[i])` equals `h(R[target] | m[target])`.
>
> Thus, Pedersen commitments for phase 1 are insecure, as it allows
> counterparties to control `R`.
>
> ElGamal Commitments in Phase 1
> ------------------------------
>
> ElGamal commitments prevent B from just giving random `q[b][i]`, thus
> preventing the above Wagner attack.
> However, it is still possible for B to control the resulting `R`, but in
> doing so this prevents the protocol from completing (thus, even with full
> control of `R`, B is still unable to promote this to an `R`-reuse attack or
> the above Wagner attack schema).
> This is not quite as bad as the above case, but having just one
> participant control the nonce `R` should make us worry that other attacks
> may now become possible (unless we acquire some proof that this will be
> equivalent in security to the hash-using MuSig).
>
> Briefly, with ElGamal commitments in Phase 1:
>
> 1. `R` commitment exchange.
>   * A generates random numbers `r[a]` and `q[a]`, B generates random
> numbers `r[b]` and `q[b]`.
>   * A computes its commitment as two points, `q[a] * G` and `r[a] * G +
> q[a] * H`, B computes its commitment as two points, `q[b] * G` and `r[b] *
> G + q[b] * H`.
>     * `H` is a NUMS point used as a second standard generator.
>     * Note that one point uses `q[] * G` while the other adds `q[] * H` to
> `r[] * G`.
>   * They exchange their pairs of points.
> 2. `R` exchange.
>   * They exchange `q[a]` and `q[b]`, and the points `r[a] * G` (== `R[a]`)
> and `r[b] * G` (== `R[b]`).
>   * They validate the exchanged data from the previous `R` commitments.
>   * They compute `R` as `R[a]` + `R[b]`.
> 3. `s` exchange.
>   * Same as before.
>
> B can attack this by delaying its phases as below:
>
> 1. `R` commitment exchange.
>   * B generates random `q[selected]`.
>   * B selects target `R[selected]`.
>   * After receiving `q[a] * G` and `r[a] * G + q[a] * H`, B computes
> `q[selected] * G - q[a] * G` and `R[selected] + q[selected] * H - r[a] * G
> - q[a] * H` and sends those points as its own commitment.
> 2. `R` exchange.
>   * After receiving `q[a]` and `R[a]`, B computes `q[b]` as `q[selected] -
> q[a]` and computes `R[b]` as `R[selected] - R[a]` and sends both as its
> decommitment.
>   * The resulting `R` will now be `R[selected]` chosen by B.
>
> `s` exchange cannot complete, as that would require that B know
> `r[selected] - r[a]` where `R[selected] = r[selected] * G`.
> Even if B generates `R[selected]` from `r[selected]`, it does not know
> `r[a]`.
> A would provide `r[a] + h(R[selected] | m) * h(L[ab]) * a`, but B would be
> unable to complete this signature.
>
> The difference here is that B has to select `R[selected]` before it learns
> `R[a]`, and thus is unable to mount the above Wagner attack schema.
> In particular, B first has to compute an `R[target]` equal to `sum where i
> = 1 to n of R[a][i]` across `n` sessions numbered `i`, in addition to
> selecting a message `m[i]`.
> Then B has to perform a Wagner attack with the constraint `h(R[target] |
> m[target]) == sum where i = 1 to n of h(R[selected][i] | m[i])`
> Fortunately for this scheme, B cannot determine such an `R[target]` before
> it has to select `R[selected]`, thus preventing this attack.
>
> It may be possible that this scheme is safe, however I am not capable of
> proving it safe.
>
> Acknowledgments
> ===============
>
> I contacted Yannick Seurin, Andrew Poelstra, Pieter Wuille, and Greg
> Maxwell, the authors of MuSig, regarding this issue, and proposing to use
> Pedersen commitments for the first phase.
> They informed me that Tim Ruffing had actually been thinking of similar
> issue before I did, and also pointed out that Pedersen commitments do not
> commit to `r * G`, only to `r` (i.e. would have to reveal `r` to serve as a
> verifiable commitment).
> It seemed to me that the general agreement was that ElGamal commitments
> should work for committing to `r * G`.
> However as I show above, this still allows a delaying participant to
> cancel the `R` contributions of the other parties, allowing it to control
> the aggregate `R` (though not quite to launch a Wagner attack).
>
> `nickler` and `waxwing` on IRC confirmed my understanding of the attack on
> 2-phase MuSig.
> `waxwing` also mentioned that the paper attacking 2-phase MuSig really
> attacks CoSi, and that the paper itself admits that given a
> knowledge-of-secret-keys, CoSi (and presumably 2-phase MuSig) would be safe.
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191129/921bf18d/attachment-0001.html>

